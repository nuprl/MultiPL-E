name: HumanEval_87_get_row
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional\
  \ data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n\
  // each row may contain a different number of columns.\n// Given lst, and integer\
  \ x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with\
  \ 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates\
  \ of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n\
  // [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5),\
  \ (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2,\
  \ 2)]\nstd::vector<std::tuple<long, long>> get_row(std::vector<std::vector<long>>\
  \ lst, long x) {\n"
tests: "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 1, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 1})})), (1)) == (std::vector<std::tuple<long, long>>({std::make_tuple(0,\
  \ 0), std::make_tuple(1, 4), std::make_tuple(1, 0), std::make_tuple(2, 5), std::make_tuple(2,\
  \ 0)})));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6})})), (2)) == (std::vector<std::tuple<long,\
  \ long>>({std::make_tuple(0, 1), std::make_tuple(1, 1), std::make_tuple(2, 1), std::make_tuple(3,\
  \ 1), std::make_tuple(4, 1), std::make_tuple(5, 1)})));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1,\
  \ 2, 3, 4, 5, 6}), std::vector<long>({1, 2, 3, 4, 5, 6}), std::vector<long>({1,\
  \ 1, 3, 4, 5, 6}), std::vector<long>({1, 2, 1, 4, 5, 6}), std::vector<long>({1,\
  \ 2, 3, 1, 5, 6}), std::vector<long>({1, 2, 3, 4, 1, 6}), std::vector<long>({1,\
  \ 2, 3, 4, 5, 1})})), (1)) == (std::vector<std::tuple<long, long>>({std::make_tuple(0,\
  \ 0), std::make_tuple(1, 0), std::make_tuple(2, 1), std::make_tuple(2, 0), std::make_tuple(3,\
  \ 2), std::make_tuple(3, 0), std::make_tuple(4, 3), std::make_tuple(4, 0), std::make_tuple(5,\
  \ 4), std::make_tuple(5, 0), std::make_tuple(6, 5), std::make_tuple(6, 0)})));\n\
  \    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long,\
  \ long>>()));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>({1})})),\
  \ (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({std::vector<long>(),\
  \ std::vector<long>({1}), std::vector<long>({1, 2, 3})})), (3)) == (std::vector<std::tuple<long,\
  \ long>>({std::make_tuple(2, 2)})));\n}\n"
completions: ["    // Your code here\n    std::vector<std::tuple<long, long>> res;\n\
    \    if(lst.size() == 0){\n        return res;\n    }\n    if(lst[0].size() ==\
    \ 0){\n        for(auto it : res){\n            std::get<0>(it) = x;\n       \
    \     std::get<1>(it) = 0;\n        }\n        return res;\n    }\n\n    std::vector<std::vector<long>>\
    \ rows = lst;\n    for(auto it = rows.begin(); it != rows.end(); it++){\n    \
    \    std::sort(it->begin(), it->end(), [&](long a, long b){\n            return\
    \ b < a;\n        });\n        for(auto it2 = it->begin(); it2 != it->end(); it2++){\n\
    \            std::sort(it2, it2+1, [&](long a, long b){\n                return\
    \ b > a;\n            });\n        }\n    }\n\n    std::vector<std::tuple<long,\
    \ long>> res2;\n    for(auto it : rows){\n        std::tuple<long, long> temp;\n\
    \        for(auto it2 = it->begin(); it2 != it->end(); it2++){\n            temp\
    \ += std::make_tuple(x - *it2, *it2);\n        }\n        res2.push_back(temp);\n\
    \    }\n    return res2;", "    std::vector<std::tuple<long, long>> row;\n   \
    \ auto it = std::lower_bound(lst.begin(), lst.end(), x);\n    if (it == lst.end())\
    \ {\n        return row;\n    }\n    for (size_t i = 0; i < it->size(); ++i) {\n\
    \        row.emplace_back(it->size(), it->at(i));\n    }\n    auto it_row = std::find_if(lst.begin(),\
    \ lst.end(),\n                                [&row](std::vector<long> const&\
    \ lst) {\n                                    return std::find(lst.begin(), lst.end(),\
    \ row[0].first) != lst.end();\n                                });\n    assert(it_row\
    \ != lst.end());\n    row = std::move(it_row);\n    it = std::lower_bound(row.begin(),\
    \ row.end(), x);\n    for (size_t i = 0; i < it->size(); ++i) {\n        row.emplace_back(it->size(),\
    \ it->at(i));\n    }\n    std::sort(row.begin(), row.end(), [](auto const& a,\
    \ auto const& b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n\
    \    for (size_t i = 0; i < row.size(); ++i) {\n        it = std::upper_bound(row.begin(),\
    \ row.end(), x);\n        it->first = i;\n        std::sort(row.begin(), row.end(),\
    \ [](auto const& a, auto const& b) {\n            return std::get<1>(a) < std::get<1>(b);\n\
    \        });\n    }\n    return row;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    std::sort(lst.begin(), lst.end());\n    long m = lst.size();\n   \
    \ long n = lst[0].size();\n    long i = 0; // row index\n    long j = (n-1); //\
    \ column index\n    while (i<m) {\n        // if x > lst[i][0], skip this row.\n\
    \        if ((lst[i][0]>x) || (j<0)) {\n            i++;\n            continue;\n\
    \        }\n        // if x != lst[i][0], go ahead to search for x.\n        long\
    \ k = j;\n        while (lst[i][k] == x)\n            k++;\n        if ((k-1)\
    \ > j)\n            res.push_back(std::make_tuple(i, k-1));\n        i = k+1;\n\
    \        j = (j-1)+1;\n    }\n    std::sort(res.begin(), res.end());\n    for\
    \ (auto t : res){\n        std::cout << std::get<0>(t) << \",\" << std::get<1>(t)\
    \ << \"\\n\";\n    }\n    return res;", "    // Your code here\n    assert(lst.size()\
    \ > 0);\n    assert(x > 0);\n    std::vector<std::tuple<long, long>> result;\n\
    \    result.push_back(std::make_tuple(0, 0));\n    result.push_back(std::make_tuple(0,\
    \ -1));\n\n    std::vector<std::tuple<long, long>> row;\n    for (auto & v : lst)\
    \ {\n        if (v[0] != 0) {\n            row.push_back(std::make_tuple(result.back().first,\
    \ v[0]));\n        }\n        for (long j = 0; j < v[v.size() - 1]; j++) {\n \
    \           if (v[j] != 0) {\n                row.push_back(std::make_tuple(j,\
    \ v[j]));\n            }\n        }\n    }\n\n    for (auto & v : row) {\n   \
    \     std::swap(v.second, v.first);\n    }\n    row.erase(std::unique(row.begin(),\
    \ row.end()), row.end());\n\n    std::sort(row.begin(), row.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(row.begin(), row.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n\n    for (auto & v : row) {\n        result.push_back(std::make_tuple(v.first,\
    \ v.second));\n    }\n\n    std::sort(result.begin(), result.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(result.begin(), result.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<1>(a) < std::get<1>(b);\n    });\n    return result;", "    if(lst.size()\
    \ <= 0) return {};\n    std::vector<std::tuple<long, long>> res;\n    for(auto\
    \ it=lst.begin(); it!=lst.end(); ++it) {\n        long col = 0;\n        for(long\
    \ row = 0; row < it->size(); ++row) {\n            if((*it)[row] == x) res.push_back(std::make_tuple(row+1,\
    \ col));\n            ++col;\n        }\n    }\n    std::sort(res.begin(), res.end());\n\
    \    std::sort(res.begin(), res.end(), [](std::tuple<long, long> lhs, std::tuple<long,\
    \ long> rhs) {\n        return std::get<0>(lhs) < std::get<0>(rhs);\n    });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    long n =\
    \ lst.size();\n    if (n == 0) {\n        return res;\n    }\n    std::queue<std::tuple<long,\
    \ long>> q;\n    for (long i = 0; i < n; ++i) {\n        q.push(std::make_tuple(i,\
    \ 0));\n    }\n    std::vector<std::tuple<long, long>> cur;\n    std::vector<std::tuple<long,\
    \ long>> res0;\n    while (q.size() > 0) {\n        auto top = q.front();\n  \
    \      q.pop();\n        auto [row, col] = top;\n        long count = 0;\n   \
    \     for (long j = 0; j < n; ++j) {\n            if (lst[row - 1][col - 1] ==\
    \ x) {\n                ++count;\n                res0.push_back(std::make_tuple(row\
    \ - 1, col - 1));\n                q.push(std::make_tuple(row, col));\n      \
    \          break;\n            }\n        }\n        if (count > 0) {\n      \
    \      cur.push_back(top);\n            cur.push_back(std::make_tuple(row - 1,\
    \ col - 1));\n            res0.push_back(std::make_tuple(row - 1, col - 1));\n\
    \            q.push(std::make_tuple(row, col));\n        }\n    }\n    for (auto\
    \ itr = cur.rbegin(); itr != cur.rend(); ++itr) {\n        res.push_back(*itr);\n\
    \    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) -> bool {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(res0.begin(), res0.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) -> bool {\n    \
    \    return std::get<1>(a) < std::get<1>(b);\n    });\n    return res;", "   \
    \ // Your code here\n    std::vector<std::tuple<long, long>> results;\n    long\
    \ r=0, c=0;\n    for(long i=0; i<limit; ++i){\n        for(long j=0; j<limit;\
    \ ++j){\n            if(lst[i][j]==x){\n                results.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    sort(results.begin(), results.end());\n\
    \    for(long j=limit-1; j>-1; j--){\n        std::tie(r, c) =results[j];\n  \
    \      results.erase(results.begin()+j);\n        sort(results.begin(), results.end());\n\
    \        for(long i=r-1; i>-1; i--){\n            std::tie(r, c) =results[i];\n\
    \            results.erase(results.begin()+i);\n        }\n    }\n    return results;",
  "    assert(lst.size() > 0 && lst[0].size() > 0 && x > 0);\n    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end(),\
    \ [](long a, long b) {\n            return b < a;\n        });\n        std::sort(row.rbegin(),\
    \ row.rend(), [](long a, long b) {\n            return b < a;\n        });\n \
    \       res.push_back(std::make_tuple(row.front(), row.back()));\n    }\n    std::vector<std::tuple<long,\
    \ long>> res1;\n    long maxi = x;\n    for (auto &row : res) {\n        if (row.front()\
    \ == maxi) {\n            res1.push_back(std::make_tuple(row.front(), row.back()));\n\
    \        }\n        maxi = row.back();\n    }\n    long maxj = x;\n    for (auto\
    \ &row : res1) {\n        if (row.back() == maxj) {\n            res.push_back(std::make_tuple(row.front(),\
    \ row.back()));\n        }\n        maxj = row.front();\n    }\n    return res;",
  "    long n = lst.size();\n    long m = lst[0].size();\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    ret.reserve(n);\n    for (long i = 0; i < n; i++) {\n     \
    \   std::vector<long> row;\n        row.reserve(m);\n        for (long j = 0;\
    \ j < m; j++) {\n            if (j == 0 || i == 0) {\n                row.push_back(j);\n\
    \            } else {\n                row.push_back(lst[i][j-1]);\n         \
    \   }\n        }\n        std::sort(row.begin(), row.end());\n        std::reverse(row.begin(),\
    \ row.end());\n        std::vector<long> col;\n        col.reserve(m);\n     \
    \   for (long j = 0; j < m; j++) {\n            col.push_back(row.back());\n \
    \           row.pop_back();\n        }\n        ret.push_back(std::make_tuple(i,\
    \ col.size()));\n    }\n    std::sort(ret.begin(), ret.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::reverse(ret.begin(), ret.end());\n    return\
    \ ret;", "    auto it = std::min_element(\n        std::begin(lst),\n        std::end(lst),\n\
    \        [](std::vector<long> a, std::vector<long> b) {\n            return std::inner_product(\n\
    \                std::begin(a),\n                std::end(a),\n              \
    \  std::begin(b),\n                0);\n        });\n\n    if (it == std::end(lst))\
    \ {\n        return {};\n    }\n\n    auto rbegin = std::prev(it);\n    auto rend\
    \ = std::next(it);\n    auto col = std::inner_product(\n        std::begin(rbegin->second),\n\
    \        std::end(rbegin->second),\n        std::begin(rbegin->first),\n     \
    \   0,\n        std::plus<long>(),\n        [x](long a, long b) {\n          \
    \  return a + b * x;\n        });\n\n    auto row = {\n        std::make_tuple(\n\
    \            rbegin->first,\n            std::inner_product(\n               \
    \ std::begin(rend)->second,\n                std::end(rend)->second,\n       \
    \         std::begin(rend)->first,\n                0,\n                std::plus<long>(),\n\
    \                [col](long a, long b) {\n                    return a + b * x;\n\
    \                })),\n    };\n\n    std::sort(\n        std::begin(row),\n  \
    \      std::end(row),\n        [](const auto& a, const auto& b) {\n          \
    \  return std::get<0>(a) > std::get<0>(b);\n        });\n\n    std::reverse(\n\
    \        std::begin(row),\n        std::end(row));\n\n    return row;", "    std::sort(lst.begin(),\
    \ lst.end(), [](const std::vector<long> &a, const std::vector<long> &b) {\n  \
    \      return a[0] < b[0] || !b.empty() && a[0] == b[0];\n    });\n\n    std::vector<std::tuple<long,\
    \ long>> results;\n    std::set<long> seen_row_ids;\n    for (std::vector<long>\
    \ &row : lst) {\n        if (seen_row_ids.count(row[0]) == 0) {\n            seen_row_ids.insert(row[0]);\n\
    \            results.push_back(std::make_tuple(row[0], row[1]));\n        }\n\
    \    }\n\n    std::sort(results.begin(), results.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n\n    for (std::tuple<long, long> &row : results)\
    \ {\n        std::sort(std::get<1>(row).rbegin(), std::get<1>(row).rend());\n\
    \    }\n\n    return results;", "    std::vector<std::tuple<long, long>> res;\n\
    \    if(!lst.size()) {\n        std::cout << \"Empty list not allowed.\";\n  \
    \      return res;\n    }\n    if(!lst[0].size()) {\n        std::cout << \"Empty\
    \ list not allowed.\";\n        return res;\n    }\n    long long cnt = 0;\n \
    \   for(auto &i : lst) {\n        for(auto &j : i) {\n            if(j == x) {\n\
    \                ++cnt;\n            }\n        }\n    }\n    if(cnt <= 1) {\n\
    \        std::cout << \"Element not found.\";\n        return res;\n    }\n  \
    \  cnt = 0;\n    for(auto &i : lst) {\n        for(auto &j : i) {\n          \
    \  if(j != x) {\n                res.push_back({++cnt, j});\n            }\n \
    \       }\n    }\n    for(auto &i : lst) {\n        for(auto &j : i) {\n     \
    \       if(j != x) {\n                std::tuple<long, long> tmp = std::make_tuple(i,\
    \ j);\n                std::sort(res.begin(), res.end(), std::greater<std::tuple<long,\
    \ long>>());\n                std::sort(res.begin(), res.end(), std::less<std::tuple<long,\
    \ long>>());\n                res = std::move(tmp);\n            }\n        }\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    long\
    \ temp;\n    for(auto &row: lst) {\n        for(auto &num: row) {\n          \
    \  temp = num;\n            if(num == x) {\n                res.push_back(std::make_tuple(0,\
    \ std::distance(row.begin(), std::find(row.begin(), row.end(), num))));\n    \
    \        }\n            else if(num < x) {\n                temp = temp - x;\n\
    \            }\n            else if(num > x) {\n                temp = temp -\
    \ x - 1;\n            }\n        }\n    }\n    return res;", "    // TODO: Write\
    \ your code here\n    std::vector<std::tuple<long, long>> res;\n    if(lst.size()\
    \ == 0){\n        res.clear();\n    }\n    else{\n        long max_row = 0, max_col\
    \ = 0;\n        for(auto row : lst){\n            for(auto col : row){\n     \
    \           if(col == x){\n                    res.emplace_back(max_row+1, max_col+1);\n\
    \                    break;\n                }\n                else if(col >\
    \ x){\n                    res.emplace_back(max_row+1, max_col+1);\n         \
    \           max_col += 1;\n                    break;\n                }\n   \
    \             else{\n                    if(max_row < row){\n                \
    \        max_row = row;\n                    }\n                    if(max_col\
    \ < col){\n                        max_col = col;\n                    }\n   \
    \             }\n            }\n        }\n    }\n    if(res.empty()){\n     \
    \   return {};\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b){\n        if(a.first > b.first){\n      \
    \      return true;\n        }\n        if(a.first < b.first){\n            return\
    \ false;\n        }\n        return a.second > b.second;\n    });\n    return\
    \ res;", "    if (lst.size() == 0)\n        return {};\n    auto row = std::vector<std::tuple<long,\
    \ long>>(lst.size());\n    std::vector<std::tuple<long, long>> tuples;\n    for\
    \ (size_t i = 0; i < row.size(); ++i) {\n        tuples.push_back(std::make_tuple(i,\
    \ 0));\n    }\n    for (size_t i = 0; i < lst.size(); ++i) {\n        for (size_t\
    \ j = 0; j < row[i].size(); ++j) {\n            if (lst[i][j] == x) {\n      \
    \          std::tie(row[i].second, row[i].first) = std::make_tuple(i, j);\n  \
    \          }\n        }\n    }\n    std::sort(tuples.begin(), tuples.end(), [](auto\
    \ a, auto b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n   \
    \ std::sort(row.begin(), row.end(), [](auto a, auto b) {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n    return tuples;", "    // Your code here\n  \
    \  auto answer = {};\n    auto find_it = [](const std::vector<std::vector<long>>&\
    \ mat, int row, long col) {\n        for (auto it = 0; it < mat.size(); it++)\
    \ {\n            if (it != row && mat[it][col] == x)\n                return true;\n\
    \        }\n        return false;\n    };\n    auto add_coord = [](std::vector<std::tuple<long,\
    \ long>> &answer, const std::vector<long> &x) {\n        for (auto it = 0; it\
    \ < x.size(); it++) {\n            std::tie(answer[it][0], answer[it][1]) = x[it];\n\
    \        }\n    };\n    auto sort_by_row = [](std::vector<std::tuple<long, long>>\
    \ &answer, long row) {\n        answer.resize(answer.size() + 1);\n        for\
    \ (auto it = 0; it < answer.size(); it++) {\n            if (it != row) {\n  \
    \              std::vector<std::tuple<long, long>> temp;\n                for\
    \ (auto it1 = it + 1; it1 < answer.size(); it1++) {\n                    std::tie(temp[it][0],\
    \ temp[it][1]) = std::make_tuple(answer[it][0], answer[it][1]);\n            \
    \        std::tie(answer[it][0], answer[it][1]) = std::make_tuple(answer[it1][0],\
    \ answer[it1][1]);\n                }\n                answer.assign(temp.size(),\
    \ std::make_tuple(std::get<0>(temp[it]), std::get<1>(temp[it])));\n          \
    \  }\n        }\n    };\n    auto sort_by_col = [](std::vector<std::tuple<long,\
    \ long>> &answer, long col) {\n        answer.resize(answer.size() + 1);\n   \
    \     for (auto it = 0; it < answer.size(); it++) {\n            std::vector<std::tuple<long,\
    \ long>> temp;\n            for (auto it1 = it; it1 < answer.size(); it1++) {\n\
    \                std::tie(temp[it][0], temp[it][1]) = std::make_tuple(answer[it][0],\
    \ answer[it][1]);\n                std::tie(answer[it][0], answer[it][1]) = std::make_tuple(answer[it1][0],\
    \ answer[it1][1]);\n            }\n            if (it != col) {\n            \
    \    answer.assign(temp.size(), std::make_tuple(std::get<0>(temp[it]), std::get<1>(temp[it])));\n\
    \            }\n        }\n    };\n    add_coord(answer, get_row(lst, x));\n \
    \   sort_by_row(answer, 0);\n    sort_by_col(answer, 0);\n    return answer;",
  "    int n = lst.size();\n    std::vector<std::tuple<long, long>> res;\n    if (n\
    \ == 0) {\n        return res;\n    }\n    std::vector<long> row;\n    std::vector<long>\
    \ col;\n    for (long i = 0; i < n; ++i) {\n        row.push_back(0);\n      \
    \  for (long j = 0; j < lst[i].size(); ++j) {\n            if (lst[i][j] == x)\
    \ {\n                row.push_back(j + 1);\n                col.push_back(lst[i][j]);\n\
    \                row.push_back(lst[i][j]);\n            }\n        }\n       \
    \ std::sort(row.begin(), row.end());\n        std::sort(col.begin(), col.end());\n\
    \        res.push_back(std::make_tuple(row[0], col[0]));\n        if (i == n-1)\
    \ {\n            std::reverse(col.begin(), col.end());\n            std::reverse(row.begin(),\
    \ row.end());\n            res.push_back(std::make_tuple(row[0], col[0]));\n \
    \       }\n    }\n    return res;", "    // Your code here\n    long m = lst[0].size();\n\
    \    long n = lst[0].size();\n    std::vector<std::tuple<long, long>> ans;\n \
    \   for(long i = 0; i < m; i++){\n        for(long j = 0; j < n; j++){\n     \
    \       if(lst[i][j] == x){\n                long r1 = i;\n                long\
    \ r2 = j;\n                while(i != r1 && j != r2){\n                    if(r1\
    \ < r2){\n                        std::swap(r1, r2);\n                    }\n\
    \                    else{\n                        std::swap(r1, r2);\n     \
    \               }\n                    if(r1 < 0){\n                        r1\
    \ += m;\n                    }\n                    else{\n                  \
    \      r1 -= m;\n                    }\n                    if(r2 < 0){\n    \
    \                    r2 += n;\n                    }\n                    else{\n\
    \                        r2 -= n;\n                    }\n                }\n\
    \                ans.push_back(std::make_tuple(i, j));\n            }\n      \
    \  }\n    }\n    for(auto itr : ans){\n        std::sort(itr.begin(), itr.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b){\n            return\
    \ std::get<0>(a) > std::get<0>(b);\n        });\n    }\n    for(auto itr : ans){\n\
    \        std::sort(itr.begin(), itr.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b){\n            return std::get<1>(b) > std::get<1>(a);\n        });\n\
    \    }\n    return ans;", "    std::vector<std::tuple<long, long>> result;\n \
    \   if (lst.size() == 0) {\n        return result;\n    }\n    std::sort(lst.begin(),\
    \ lst.end(), [](std::vector<long> a, std::vector<long> b) {\n        return a[0]\
    \ > b[0];\n    });\n    std::sort(lst.begin(), lst.end(), [](std::vector<long>\
    \ a, std::vector<long> b) {\n        return a[2] < b[2];\n    });\n    long curr\
    \ = 0, max = 0;\n    for (auto &row : lst) {\n        if (row[0] == x) {\n   \
    \         max = row[1];\n        }\n        if (row[1] == max) {\n           \
    \ result.push_back({ std::get<0>(row), std::get<1>(row) });\n        }\n    }\n\
    \    return result;", "    std::vector<std::tuple<long, long>> result;\n    long\
    \ min_row = 0, min_col = 0, max_row = 0, max_col = 0;\n    for (auto &row : lst)\
    \ {\n        min_row = std::min(min_row, row[0]);\n        max_row = std::max(max_row,\
    \ row[0]);\n        min_col = std::min(min_col, row[1]);\n        max_col = std::max(max_col,\
    \ row[1]);\n    }\n    for (auto &row : lst) {\n        for (auto &col : row)\
    \ {\n            if (col == x) {\n                result.emplace_back(min_row\
    \ + max_row, min_col + max_col);\n                break;\n            }\n    \
    \    }\n    }\n    return result;", "    std::vector<std::tuple<long, long>> result;\n\
    \    for (size_t i = 0; i < lst.size(); i++) {\n        bool is_contained = std::find(lst.begin(),\
    \ lst.end(), lst[i]) != lst.end();\n        if (!is_contained) {\n           \
    \ continue;\n        }\n        auto it = std::find_if(lst.begin() + i, lst.end(),\n\
    \        [&](const auto& elem) {\n            return std::find(elem.begin(), elem.end(),\
    \ x) != elem.end();\n        });\n        if (it == lst.end()) {\n           \
    \ continue;\n        }\n        for (size_t j = 0; j < it->size(); j++) {\n  \
    \          if (it->at(j) == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    if (result.empty()) {\n        return\
    \ result;\n    }\n    std::sort(result.begin(), result.end(),\n        [](const\
    \ std::tuple<long, long>& a, const std::tuple<long, long>& b) {\n            return\
    \ std::get<0>(a) < std::get<0>(b);\n        });\n    std::vector<std::tuple<long,\
    \ long>> res(result.size());\n    for (auto& tuple : result) {\n        res[std::get<0>(tuple)]\
    \ = std::make_tuple(std::get<1>(tuple), -std::get<0>(tuple));\n    }\n    std::sort(res.begin(),\
    \ res.end(),\n        [](const std::tuple<long, long>& a, const std::tuple<long,\
    \ long>& b) {\n            return std::get<1>(a) < std::get<1>(b);\n        });\n\
    \    std::sort(res.begin(), res.end(),\n        [](const std::tuple<long, long>&\
    \ a, const std::tuple<long, long>& b) {\n            return std::get<0>(b) < std::get<0>(a);\n\
    \        });\n    return result;", "    std::vector<std::tuple<long, long>> result;\n\
    \n    // Sort the rows initially by rows in ascending order\n    sort(lst.begin(),\
    \ lst.end(), [](std::vector<long> &a, std::vector<long> &b) {\n        return\
    \ a.size() > b.size() ? true : false;\n    });\n\n    for (auto &row : lst) {\n\
    \        if (row.size() <= x) {\n            result.emplace_back(std::make_tuple(0,\
    \ 0));\n            continue;\n        }\n        // Sort the row by columns in\
    \ descending order\n        sort(row.begin(), row.end(), [](long &a, long &b)\
    \ {\n            return a > b ? true : false;\n        });\n\n        long min_row\
    \ = std::min_element(row.begin(), row.end()) - row.begin();\n        long max_row\
    \ = std::max_element(row.begin(), row.end()) - row.begin();\n\n        long min_column\
    \ = std::min_element(row.begin() + x, row.end()) - row.begin();\n        long\
    \ max_column = std::max_element(row.begin() + x, row.end()) - row.begin();\n\n\
    \        for (long i = min_row; i < max_row + 1; i++) {\n            for (long\
    \ j = min_column; j < max_column + 1; j++) {\n                if (i == 0 && j\
    \ == 0)\n                    result.emplace_back(std::make_tuple(i, j));\n   \
    \             else if (i == 0 && j == max_column + 1)\n                    result.emplace_back(std::make_tuple(i,\
    \ j + 1));\n                else if (i == max_row + 1)\n                    result.emplace_back(std::make_tuple(i\
    \ + 1, j));\n                else if (j == 0)\n                    result.emplace_back(std::make_tuple(i\
    \ + 1, j + 1));\n                else\n                    result.emplace_back(std::make_tuple(i\
    \ + 1, j + 1));\n            }\n        }\n    }\n\n    return result;", "   \
    \ // Your code here\n    std::vector<std::tuple<long, long>> ans;\n    for(auto\
    \ row: lst) {\n        std::vector<std::tuple<long, long>> row_ans;\n        for(auto\
    \ col: row) {\n            if(col == x) {\n                row_ans.push_back(std::make_tuple(row-row.begin(),\
    \ col-row.begin()));\n            }\n        }\n        std::sort(row_ans.begin(),\
    \ row_ans.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n        std::sort(row_ans.rbegin(),\
    \ row_ans.rend(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n        ans.push_back(std::move(row_ans));\n\
    \    }\n    return ans;", "    // Your code here\n    ", "    std::map<long, std::map<long,\
    \ long>> mp;\n    long nr = 0, nc = 0;\n    for(auto it = lst.begin(); it != lst.end();\
    \ ++it) {\n        for(auto it2 = it->begin(); it2 != it->end(); ++it2) {\n  \
    \          mp[*it2] += 1;\n        }\n        if(mp[*it].size() != 0) {\n    \
    \        nr += 1;\n            nc += mp[*it].size();\n        }\n    }\n    long\
    \ n = 0;\n    for(auto it1 = mp.begin(); it1 != mp.end(); ++it1) {\n        if(it1->second.size()\
    \ != 0) {\n            n += 1;\n        }\n    }\n    std::map<long, std::map<long,\
    \ long>> res;\n    for(long i = 0; i < n; ++i) {\n        long nc = 0, rc = nr;\n\
    \        for(auto it = lst.begin(); it != lst.end(); ++it) {\n            std::map<long,\
    \ long> mr;\n            std::map<long, long> mx;\n            for(auto it2 =\
    \ it->begin(); it2 != it->end(); ++it2) {\n                mr[*it2] += 1;\n  \
    \              if(mr[*it2] > nc && mr[*it2] != 0) {\n                    mr.erase(*it2);\n\
    \                }\n                mx[*it2] += 1;\n                if(mx[*it2]\
    \ > rc && mx[*it2] != 0) {\n                    mx.erase(*it2);\n            \
    \    }\n            }\n            if(mr.size() != 0) {\n                res.emplace(*it,\
    \ (std::make_tuple(rc, mc)));\n            }\n        }\n    }\n    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto it = res.begin(); it != res.end(); ++it) {\n     \
    \   long yy = it->second.begin()->first;\n        long xx = it->second.begin()->second;\n\
    \        long r = it->first.first;\n        long c = it->first.second;\n     \
    \   for(auto it2 = it->second.begin(); it2 != it->second.end(); ++it2) {\n   \
    \         if(it2->second < c) {\n                std::swap(it2->second, c);\n\
    \            }\n        }\n        std::vector<std::tuple<long, long>> tmp;\n\
    \        for(auto it1 = res.begin(); it1 != res.end(); ++it1) {\n            long\
    \ y2 = it1->second.begin()->first;\n            long x2 = it1->second.begin()->second;\n\
    \            long r2 = it1->first.first;\n            long c2 = it1->first.second;\n\
    \            long y2 = yy * nc + y2;\n            long x2 = ", "    assert(lst.size()\
    \ == 2);\n    long n = lst[0].size();\n    std::vector<std::tuple<long, long>>\
    \ res;\n    for (long i = 0; i < n; i++) {\n        long y = i;\n        for (long\
    \ j = 0; j < n; j++) {\n            if (i == j)\n                continue;\n \
    \           if (x <= lst[i][j])\n                y = j;\n        }\n        res.push_back({i,\
    \ y});\n    }\n    std::sort(res.begin(), res.end(), [](const auto& l, const auto&\
    \ r) {\n        return l.first < r.first;\n    });\n    return res;", "    auto\
    \ result = std::vector<std::tuple<long, long>>{};\n    auto row = get_row(lst,\
    \ 0);\n    for (auto row : row) {\n        if (std::get<0>(row) == x) {\n    \
    \        result.push_back(std::make_tuple(std::get<0>(row), std::get<1>(row)));\n\
    \        }\n    }\n    return result;", "    std::vector<std::tuple<long, long>>\
    \ ans;\n    auto it = lst.begin();\n    long i = 0; // Row number\n    long j\
    \ = 0; // Column number\n    long temp = 0; // Holds x\n    // Iterate until end\
    \ of list\n    while(it != lst.end()) {\n        // Check if x\n        if(std::get<0>(*it)\
    \ == x) {\n            // Add to answer\n            ans.emplace_back(i, j);\n\
    \            i++;\n            // Get next element\n            temp = std::get<0>(*it);\n\
    \            j++;\n        } else {\n            // If not x\n            if(i\
    \ == 0) // If row number is 0\n                i = 1; // Set row number to 1\n\
    \            j = 1; // Set column number to 1\n            temp = std::get<0>(*it);\
    \ // Get next element\n        }\n        // Move to next element\n        it++;\n\
    \    }\n    // Sort answer\n    std::sort(ans.begin(), ans.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    for(int i = 0; i < ans.size(); i++)\n        std::sort(ans[i].begin(),\
    \ ans[i].end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \         return std::get<1>(b) > std::get<1>(a);\n        });\n    return ans;",
  "    assert(lst.size() > 0);\n    std::vector<std::tuple<long, long>> result;\n\
    \    std::sort(std::begin(lst), std::end(lst), [](const std::vector<long> &l,\
    \ const std::vector<long> &r) -> bool {\n        return l.size() > r.size();\n\
    \    });\n    std::sort(std::begin(lst[0]), std::end(lst[0]), [](const std::vector<long>\
    \ &l, const long &r) -> bool {\n        return l > r;\n    });\n    for (auto\
    \ &row : lst) {\n        std::sort(std::begin(row), std::end(row), [](const long\
    \ &l, const long &r) -> bool {\n            return l > r;\n        });\n    }\n\
    \    for (auto &row : lst) {\n        for (auto &item : row) {\n            if\
    \ (item == x) {\n                result.push_back({std::distance(std::begin(lst),\
    \ std::end(lst)), std::distance(std::begin(lst[0]), std::end(lst[0]))});\n   \
    \         }\n        }\n    }\n    return result;", "    std::vector<std::tuple<long,\
    \ long>> ans;\n    for (auto &row : lst) {\n        std::vector<long> col;\n \
    \       for (auto &val : row)\n            col.push_back(val);\n        std::sort(col.begin(),\
    \ col.end());\n        col.push_back(-1);\n        std::reverse(col.begin(), col.end());\n\
    \        std::sort(col.begin(), col.end());\n        col.push_back(-1);\n    \
    \    col.push_back(x);\n        ans.push_back(std::make_tuple(0, col));\n    }\n\
    \    ans.push_back({-1, {0}});\n    std::sort(ans.begin(), ans.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    return ans;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    res.reserve(lst[0].size());\n\n    // Sort the first row by\
    \ ascending value of each element.\n    // The order of elements in each row is\
    \ already in ascending order.\n    // For example, row1 contains elements [1,2,3],\
    \ so it is sorted.\n    std::sort(lst.begin(), lst.end(), [](const std::vector<long>\
    \ &a, const std::vector<long> &b) { return a.front() < b.front(); });\n\n    //\
    \ Sort the second row by descending value of each element.\n    // The order of\
    \ elements in each row is already in descending order.\n    // For example, row2\
    \ contains elements [5,6,4,1], so it is sorted.\n    std::sort(lst.begin(), lst.end(),\
    \ [](const std::vector<long> &a, const std::vector<long> &b) { return a.back()\
    \ < b.back(); });\n\n    // Iterate each row and sort each column by descending\
    \ value of each element.\n    // The order of elements in each column is already\
    \ in descending order.\n    // For example, row1 contains elements [2,5,6,4],\
    \ so it is sorted.\n    for (size_t i = 0; i < lst.size(); i++) {\n        std::sort(lst[i].begin(),\
    \ lst[i].end(), [](const long &a, const long &b) { return b < a; });\n    }\n\n\
    \    // Iterate each row and sort each column by ascending value of each element.\n\
    \    // The order of elements in each column is already in ascending order.\n\
    \    // For example, row1 contains elements [1,2,3,4,5,6], so it is sorted.\n\
    \    for (size_t i = 0; i < lst.size(); i++) {\n        std::sort(lst[i].begin(),\
    \ lst[i].end(), [](const long &a, const long &b) { return a < b; });\n    }\n\n\
    \    // Get the coordinate of the target element.\n    // The coordinate will\
    \ be returned as an integer pair - (row, columns).\n    auto it = std::find(lst.begin(),\
    \ lst.end(), x);\n    assert(it != lst.end());\n\n    // Get the coordinate of\
    \ the target element as (row, columns).\n    auto row = std::distance(std::begin(lst),\
    \ it);\n    auto col = std::distance(std::begin(lst), std::prev(it));\n\n    //\
    \ Add coordinate to the result.\n    res.push_back(std::make_tuple(row, col));\n\
    \    return res;", "  // write your code here\n  std::vector<std::tuple<long,\
    \ long>> res;\n  std::unordered_map<long, std::unordered_map<long, long>> table;\n\
    \  for (auto& row : lst) {\n    // Sort the row by columns in ascending order\n\
    \    std::sort(row.begin(), row.end(), [&](long a, long b){\n      return a[x\
    \ - 1] < b[x - 1];\n    });\n    // Sort the row by columns in descending order\n\
    \    std::sort(row.rbegin(), row.rend(), [&](long a, long b){\n      return a[x\
    \ - 1] > b[x - 1];\n    });\n    // Iterate through the columns to find the index\n\
    \    for (auto col : row) {\n      // Update the table if needed\n      if (table.count(col)\
    \ > 0) table[col][x] = col;\n      else table.emplace(col, std::unordered_map<long,\
    \ long>());\n    }\n  }\n  // Iterate through the table to collect the result\n\
    \  for (auto &kvp : table) {\n    for (auto it = kvp.second.begin(); it != kvp.second.end();\
    \ ++it) {\n      res.push_back(*it);\n    }\n  }\n  return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &it : lst) {\n        // std::sort(it.begin(), it.end());\n\
    \        std::sort(it.begin(), it.end(), [](long a, long b) { return b < a; });\n\
    \        std::vector<std::tuple<long, long>> temp;\n        long curr = 0;\n \
    \       for (auto &it : it) {\n            curr += 1;\n            temp.emplace_back(std::make_tuple(curr\
    \ - 1, curr - 1));\n            if (x == it) {\n                temp.emplace_back(std::make_tuple(curr,\
    \ curr - 1));\n                res.emplace_back(std::move(temp));\n          \
    \      break;\n            }\n            temp.emplace_back(std::make_tuple(curr\
    \ - 1, curr));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    // Write your code here\n    for(auto &row : lst){\n      \
    \  for(auto &num : row){\n            if(num==x)\n                res.push_back(std::make_tuple(row.size(),row.size()));\n\
    \        }\n    }\n    res.sort();\n    res.sort((std::greater<std::tuple<long,\
    \ long>>()));\n    for(auto &row : res){\n        res.sort((std::greater<std::tuple<long,\
    \ long>>()));\n        for(auto &num : row){\n            res.sort((std::less<std::tuple<long,\
    \ long>>()));\n            std::cout << std::get<0>(num) << '\\t' << std::get<1>(num)\
    \ << '\\n';\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    res.reserve(lst.size());\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        long n = lst[i].size();\n        if (x == n) return res;\n \
    \       if (x == 0) return res;\n        std::vector<std::tuple<long, long>> v;\n\
    \        for (long j = 0; j < n; j++) {\n            if (j == 0 && lst[i][j] ==\
    \ x) v.push_back(std::make_tuple(i, j));\n            else if (lst[i][j] == x)\
    \ v.push_back(std::make_tuple(i - 1, j));\n            else if (j == n - 1 &&\
    \ lst[i][j] == x) v.push_back(std::make_tuple(i, j - 1));\n        }\n       \
    \ if (v.size() == 1) res.push_back(std::get<0>(v.front()));\n        std::sort(v.begin(),\
    \ v.end());\n        res.push_back(std::get<0>(v.front()));\n        res.push_back(std::get<1>(v.front()));\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> ans;\n    for\
    \ (auto &row : lst) {\n        for (auto &el : row)\n            if (el == x)\n\
    \                ans.emplace_back(row.size(), row.size() - 1);\n    }\n    ans.emplace_back(ans.begin(),\
    \ ans.begin() + ans.size() - 1);\n    std::sort(ans.begin(), ans.end(), [](auto\
    \ a, auto b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(ans.begin()\
    \ + ans.size() - 1, ans.end(), [](auto a, auto b) { return std::get<1>(a) < std::get<1>(b);\
    \ });\n    return ans;", "    std::vector<std::tuple<long, long>> res;\n    res.reserve(lst.size());\n\
    \    \n    auto cmp = [](std::tuple<long, long> a, std::tuple<long, long> b) {\
    \ return std::get<1>(a) > std::get<1>(b); };\n    \n    for (auto & v : lst) {\n\
    \        auto row = v.size();\n        auto cols = v.front();\n        \n    \
    \    std::sort(v.begin(), v.end(), cmp);\n        std::sort(v.begin(), v.end(),\
    \ cmp);\n        \n        std::vector<std::tuple<long, long>> vRow(row);\n  \
    \      std::vector<std::tuple<long, long>> vCol(cols);\n        \n        for\
    \ (auto j = 0; j < cols; ++j) {\n            vCol[j] = std::make_tuple(j, std::get<0>(v[j]));\n\
    \        }\n        \n        for (auto j = 0; j < row; ++j) {\n            vRow[j]\
    \ = std::make_tuple(std::get<0>(v[j]), j);\n        }\n        \n        res.emplace_back(vRow.begin(),\
    \ vRow.end());\n    }\n    \n    return res;", "  if (lst.size() == 0) {\n   \
    \ return std::vector<std::tuple<long, long>>();\n  }\n  if (lst.size() == 1) {\n\
    \    long row = 0;\n    long col = 0;\n    return {{row, col}};\n  }\n  long col\
    \ = lst[0].size() - 1;\n  std::vector<std::tuple<long, long>> ans;\n  for (size_t\
    \ i = 0; i < lst.size(); i++) {\n    long row = (lst[i][0] - 1) * col + lst[i][1];\n\
    \    col--;\n    if (row == x) {\n      ans.push_back(std::make_tuple(row, col));\n\
    \    }\n  }\n  sort(ans.begin(), ans.end());\n  std::reverse(ans.begin(), ans.end());\n\
    \  return ans;", "    if (lst.size() == 0) {\n        return std::vector<std::tuple<long,\
    \ long>>();\n    }\n    // sort the coordinates by rows in ascending order\n \
    \   std::vector<std::tuple<long, long>> lst1(lst.size());\n    for (size_t i =\
    \ 0; i < lst.size(); i++) {\n        lst1[i] = std::make_tuple(i, lst[i].size());\n\
    \        std::sort(lst1[i].begin(), lst1[i].end(), [](auto a, auto b) { return\
    \ a[1] < b[1]; });\n    }\n    // sort the coordinates by columns in descending\
    \ order\n    for (size_t i = lst1.size() - 1; i >= 0; i--) {\n        lst1[i]\
    \ = std::make_tuple(std::get<0>(lst1[i]), i);\n        std::sort(lst1[i].begin(),\
    \ lst1[i].end(), [](auto a, auto b) { return a[1] > b[1]; });\n    }\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    for (size_t i = 0; i < lst1.size(); i++) {\n        if (std::get<1>(lst1[i])\
    \ == x) {\n            ret.push_back(std::make_tuple(i, x));\n        }\n    }\n\
    \    return ret;", "    std::vector<std::tuple<long, long>> ret;\n    ret.push_back(std::make_tuple(0,\
    \ 0));\n    for(size_t i = 1; i < lst.size(); ++i) {\n        long cur = lst[i\
    \ - 1].size();\n        long cur2 = lst[i].size();\n        if(cur == cur2) {\n\
    \            for(long j = 0; j < cur; ++j) {\n                ret.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n        else if(cur > cur2) {\n            for(long\
    \ j = 0; j < cur2; ++j) {\n                ret.push_back(std::make_tuple(i, j));\n\
    \            }\n            for(long j = 0; j < cur; ++j) {\n                ret.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n        else {\n            for(long j = 0;\
    \ j < cur2; ++j) {\n                ret.push_back(std::make_tuple(i, j));\n  \
    \          }\n            for(long j = 0; j < cur; ++j) {\n                ret.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    for(size_t i = 0; i < ret.size();\
    \ ++i) {\n        auto it = std::max_element(std::begin(ret[i]), std::end(ret[i]));\n\
    \        if(std::get<0>(it) == i) {\n            ret.erase(std::remove(std::begin(ret),\
    \ std::end(ret), it), std::end(ret));\n        }\n    }\n    std::sort(std::begin(ret),\
    \ std::end(ret), [](auto const &a, auto const &b) {\n        return std::get<0>(b)\
    \ < std::get<0>(a);\n    });\n    ret.erase(std::remove(std::begin(ret), std::end(ret),\
    \ std::make_tuple(0, 0)), std::end(ret));\n    std::sort(std::begin(ret), std::end(ret),\
    \ [](auto const &a, auto const &b) {\n        return std::get<1>(b) < std::get<1>(a);\n\
    \    });\n    ret.erase(std::remove(std::begin(ret), std::end(ret), std::make_tuple(0,\
    \ 0)), std::end(ret));\n    return ret;", "    // Your code here\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    std::sort(lst.begin(), lst.end(), [](const std::vector<long>&\
    \ a, const std::vector<long>& b) {\n        return a[0] < b[0];\n    });\n   \
    \ for (long i = 0; i < lst.size(); i++) {\n        std::vector<long> lst1 = lst[i];\n\
    \        std::sort(lst1.begin(), lst1.end(), [](const long& a, const long& b)\
    \ {\n            return a > b;\n        });\n        for (long j = 0; j < lst1.size();\
    \ j++) {\n            if (x == lst1[j]) {\n                ret.push_back(std::make_tuple(i,\
    \ j));\n                break;\n            }\n        }\n    }\n    std::sort(ret.begin(),\
    \ ret.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) {\n        return a[1] < b[1];\n    });\n    return ret;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    result.reserve(lst.size());\n    for (auto & row : lst)\
    \ {\n        if (row.size() < 2)\n            result.emplace_back(0, 0);\n   \
    \     else {\n            result.emplace_back(0, row.size() - 1);\n          \
    \  result.emplace_back(row.size() - 1, row.size() - 2);\n        }\n    }\n\n\
    \    std::sort(result.begin(), result.end(), [](auto lhs, auto rhs) {\n      \
    \  return std::get<0>(lhs) < std::get<0>(rhs);\n    });\n\n    std::sort(result.begin(),\
    \ result.end(), [](auto lhs, auto rhs) {\n        return std::get<1>(lhs) < std::get<1>(rhs);\n\
    \    });\n\n    for (auto & pair : result) {\n        if (pair.first == x)\n \
    \           return result;\n    }\n    throw std::runtime_error(\"Invalid input.\"\
    );", "    long n = lst.size();\n    long m = lst[0].size();\n    if (m < n) {\n\
    \        return {};\n    }\n    std::vector<std::tuple<long, long>> res;\n   \
    \ for (long i = 0; i < n; ++i) {\n        std::vector<long> row = lst[i];\n  \
    \      for (long j = 0; j < m; ++j) {\n            if (row[j] == x) {\n      \
    \          res.push_back(std::make_tuple(i, j));\n            }\n        }\n \
    \   }\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::vector<std::tuple<long,\
    \ long>> temp_res;\n    long idx = 0;\n    for (auto it = res.begin(); it != res.end();\
    \ ++it) {\n        long r = std::get<0>(*it);\n        long c = std::get<1>(*it);\n\
    \        while (idx < n) {\n            long row_r = std::get<0>(lst[idx]);\n\
    \            long row_c = std::get<1>(lst[idx]);\n            if (r == row_r)\
    \ {\n                for (long i = row_c; i < m; ++i) {\n                    if\
    \ (lst[idx].at(i) == c) {\n                        temp_res.push_back(std::make_tuple(r,\
    \ std::get<1>(lst[idx].at(i))));\n                    }\n                }\n \
    \           }\n            ++idx;\n        }\n    }\n    return temp_res.empty()\
    \ ? std::vector<std::tuple<long, long>>() : (temp_res.rbegin(), temp_res.rend());",
  "    std::vector<std::tuple<long, long>> res;\n    if (lst.empty())\n        return\
    \ res;\n    if (x == 1)\n        return res;\n\n    // Store x coordinates in\
    \ lst, sort row by rows\n    // Then, store coordinates of sorted rows in descending\
    \ order in res\n    std::vector<long> xs;\n    for (const auto& row : lst) {\n\
    \        xs.emplace_back(row[x]);\n    }\n    std::sort(xs.begin(), xs.end());\n\
    \    for (auto itr = xs.rbegin(); itr != xs.rend(); ++itr) {\n        auto it\
    \ = std::lower_bound(xs.begin(), xs.end(), *itr);\n        std::tuple<long, long>\
    \ row(*itr);\n        long col = it - xs.begin();\n        if (col < res.size())\
    \ {\n            res[col] = std::make_tuple(row, col);\n        }\n    }\n   \
    \ return res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto v\
    \ : lst) {\n        auto it = std::find(v.begin(), v.end(), x);\n        if(it\
    \ != v.end()) {\n            auto r = std::make_tuple(std::distance(v.begin(),\
    \ it), std::distance(it, v.end()));\n            res.push_back(r);\n        }\n\
    \    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>&\
    \ l, const std::tuple<long, long>& r) {\n        return std::get<0>(l) < std::get<0>(r);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>&\
    \ l, const std::tuple<long, long>& r) {\n        return std::get<1>(l) > std::get<1>(r);\n\
    \    });\n    return res;", "    // Your code here\n    std::vector<std::tuple<long,\
    \ long>> row;\n    for (auto &row : lst) {\n        for (auto &val : row) {\n\
    \            if (val == x) {\n                row.emplace_back(0, row.size() -\
    \ 1);\n            }\n        }\n    }\n    std::sort(row.begin(), row.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(row.begin(), row.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return row;", "    assert(lst);\n    std::vector<std::tuple<long,\
    \ long>> result;\n    result.push_back({0, lst[0][0]});\n    for (auto &row :\
    \ lst) {\n        result.push_back({row[0], row[row.size() - 1]});\n    }\n  \
    \  std::sort(result.begin(), result.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) {\n        return a.get<1>() < b.get<1>();\n\
    \    });\n    for (auto &row : result) {\n        std::sort(row.begin(), row.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \         return a.get<0>() < b.get<0>();\n        });\n    }\n    for (auto &row\
    \ : result) {\n        if (std::find(row.begin(), row.end(), x) != row.end())\
    \ {\n            return result;\n        }\n    }\n    return {};", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto i = 0; i < lst.size(); i++) {\n        for(auto j\
    \ = 0; j < lst[i].size(); j++) {\n            if(lst[i][j] == x) {\n         \
    \       res.emplace_back(i, j);\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) -> bool {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n  \
    \  std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) -> bool {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> answer;\n\
    \    long first_row = 0, first_col = 0;\n    long row_num = 0, col_num = 0;\n\
    \    // Find the first row and column\n    while (first_row + col_num < lst.size())\
    \ {\n        if (lst[first_row][col_num] == x) {\n            break;\n       \
    \ } else {\n            if (col_num == 0) {\n                first_row = first_row\
    \ + 1;\n                row_num = row_num + 1;\n                col_num = 1;\n\
    \            } else {\n                first_col = first_col + 1;\n          \
    \      col_num = col_num + 1;\n            }\n        }\n    }\n    // Store the\
    \ result for all the coordinates of this row\n    for (int i = first_row + 1;\
    \ i <= first_row + row_num - 1; i++) {\n        for (int j = first_col + 1; j\
    \ <= first_col + col_num - 1; j++) {\n            std::tuple<long, long> tuple\
    \ = std::make_tuple(i, j);\n            answer.push_back(tuple);\n        }\n\
    \    }\n    // Sort the answer\n    std::sort(answer.begin(), answer.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(answer.begin(), answer.end(), [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return answer;", "        auto res = {0};\n        for(auto& it1\
    \ : lst) {\n            for(auto& it2 : it1) {\n                if(it2 == x) {\n\
    \                    res.emplace_back(it1, it1);\n                }\n        \
    \    }\n        }\n        std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        });\n        for(auto& it : res) {\n            std::sort(it.begin(),\
    \ it.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) {\n                return std::get<0>(a) < std::get<0>(b);\n            });\n\
    \        }\n        return res;\n    }\nint main()\n{\n    int t;\n    std::cin>>t;\n\
    \    while(t--) {\n        std::cin>>n;\n        for(int i = 0;i < n;i++) {\n\
    \            std::cin>>arr[i];\n        }\n        std::vector<std::tuple<long,\
    \ long>> res;\n        std::sort(arr.begin(), arr.end(), [](const long a, const\
    \ long b) {\n            return a>b;\n        });\n        std::sort(arr.begin(),\
    \ arr.end(), [](const long a, const long b) {\n            return a>b;\n     \
    \   });\n        res = get_row(arr, arr[0]);\n        int count = 0;\n       \
    \ for(auto& it : res) {\n            std::cout<<std::get<0>(it)<<\" \"<<std::get<1>(it)<<\"\
    \\n\";\n            if(std::get<0>(it) == std::get<0>(res.back())) {\n       \
    \         count++;\n            }\n        }\n        std::cout<<count<<\"\\n\"\
    ;\n    }\n    return 0;", "    // Your code goes here\n    std::vector<std::tuple<long,\
    \ long>> ans;\n    for (long i = 0; i < lst.size(); i++) {\n        long max_y\
    \ = 0;\n        for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j]\
    \ == x) {\n                long y = j + 1;\n                while (y <= lst[i][j])\
    \ {\n                    max_y = y;\n                    y++;\n              \
    \  }\n                ans.push_back(std::make_tuple(i, max_y));\n            }\n\
    \        }\n    }\n    long row_max = std::max_element(ans.begin(), ans.end())\
    \ - ans.begin();\n    for (long i = 0; i < ans.size(); i++) {\n        ans[i]\
    \ = std::make_tuple(ans[i][0] - row_max, ans[i][1]);\n    }\n    std::sort(ans.begin(),\
    \ ans.end());\n    for (long i = 0; i < ans.size(); i++) {\n        ans[i] = std::make_tuple(ans[i][0],\
    \ ans[i][1]);\n    }\n    return ans;", "    std::sort(lst.begin(), lst.end(),\
    \ [](std::vector<long> a, std::vector<long> b) {\n        return a[0] > b[0];\n\
    \    });\n    std::vector<std::tuple<long, long>> ret;\n    for (auto it = lst.rbegin();\
    \ it != lst.rend(); ++it) {\n        std::vector<long> row = *it;\n        for\
    \ (auto it2 = row.rbegin(); it2 != row.rend(); ++it2) {\n            if (x ==\
    \ it2[0]) {\n                ret.push_back(std::make_tuple(it2[0], it2[1]));\n\
    \                break;\n            }\n        }\n    }\n    return ret;", " \
    \   // Write your code here\n    std::vector< std::vector<std::pair<long, long>>>\
    \ results;\n    for (auto& row : lst){\n        std::vector<std::pair<long, long>>\
    \ rowResult;\n        for (auto col : row){\n            if (col == x){\n    \
    \            rowResult.push_back(std::make_pair(row.size() - 1, col.size() - 1));\n\
    \            }\n        }\n        results.push_back(rowResult);\n    }\n    std::sort(results.begin(),\
    \ results.end(), [](auto &lhs, auto &rhs){return lhs.size() < rhs.size(); });\n\
    \    std::sort(results.begin(), results.end(), [](auto &lhs, auto &rhs){return\
    \ lhs.back().second > rhs.back().second; });\n\n    return std::vector<std::tuple<long,\
    \ long>>(results);", "    // write your code here\n    std::vector<std::tuple<long,\
    \ long>> results;\n    for(int row = 0; row < lst.size(); row++) {\n        int\
    \ row_size = lst[row].size();\n        if(row_size == 0)\n            continue;\n\
    \        int column_size = lst[0].size();\n        if(column_size == 0)\n    \
    \        continue;\n        \n        bool row_ascending = true;\n        bool\
    \ column_ascending = true;\n        std::vector<std::tuple<long, long>> row_results;\n\
    \        std::vector<std::tuple<long, long>> column_results;\n        for(int\
    \ i = 0; i < row_size; i++) {\n            bool element_ascending = row_ascending\
    \ && lst[row][i] > x;\n            bool element_descending = !row_ascending &&\
    \ lst[row][i] < x;\n            if(element_ascending) {\n                row_results.push_back(std::make_tuple(i,\
    \ lst[row][i]));\n                row_ascending = false;\n            } else if(element_descending)\
    \ {\n                row_results.push_back(std::make_tuple(i, lst[row][i]));\n\
    \                row_ascending = true;\n            } else {\n               \
    \ row_results.push_back(std::make_tuple(i, lst[row][i]));\n            }\n   \
    \     }\n        for(int i = 0; i < column_size; i++) {\n            bool element_ascending\
    \ = column_ascending && lst[0][i] > x;\n            bool element_descending =\
    \ !column_ascending && lst[0][i] < x;\n            if(element_ascending) {\n \
    \               column_results.push_back(std::make_tuple(i, lst[0][i]));\n   \
    \             column_ascending = false;\n            } else if(element_descending)\
    \ {\n                column_results.push_back(std::make_tuple(i, lst[0][i]));\n\
    \                column_ascending = true;\n            } else {\n            \
    \    column_results.push_back(std::make_tuple(i, lst[0][i]));\n            }\n\
    \        }\n        std::sort(row_results.begin(), row_results.end());\n     \
    \   std::sort(column_results.begin(), column_results.end());\n        results.insert(results.end(),\
    \ row_results.begin(), row_results.end());\n        results.insert(results.end(),\
    \ column_results.begin(), column_results.end());\n    }\n    return results;",
  "    std::vector<std::tuple<long, long>> res;\n    assert(lst.size() > 0);\n   \
    \ assert(lst.size() == lst[0].size());\n    for (size_t i = 0; i < lst.size();\
    \ i++) {\n        std::vector<long> v = lst[i];\n        auto it = std::find(v.begin(),\
    \ v.end(), x);\n        if (it != v.end()) {\n            int index = (it - v.begin())\
    \ / v.size();\n            long column = (it - v.begin()) % v.size();\n      \
    \      auto r = std::make_tuple(i, index);\n            auto c = std::make_tuple(i,\
    \ column);\n            res.push_back(r);\n            res.push_back(c);\n   \
    \     }\n    }\n    // sort coordinates by rows in ascending order\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> & a, const std::tuple<long, long>\
    \ & b) { return std::get<0>(a) < std::get<0>(b); });\n    // sort coordinates\
    \ of rows by columns in descending order\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> & a, const std::tuple<long, long> & b) { return\
    \ std::get<1>(a) > std::get<1>(b); });\n    return res;", "    assert(lst.size()\
    \ > 0);\n    assert(x > 0); \n    std::vector<std::tuple<long, long>> res;\n \
    \   res.reserve(lst.size());\n    std::sort(lst.begin(), lst.end());\n    long\
    \ row_num = 0;\n    std::for_each(lst.begin(), lst.end(), [&res, x](const std::vector<long>\
    \ &lst) {\n        long col_num = 0;\n        for (long i = 0; i < lst.size();\
    \ i++) {\n            if (lst[i] == x) res.push_back({row_num, col_num});\n  \
    \          col_num++;\n        }\n        row_num++;\n    });\n    return res;",
  "    std::vector<std::tuple<long, long>> result;\n\n    if (lst.size() == 0)\n \
    \       return result;\n\n    std::vector<std::vector<long>> matrix(lst[0].size());\n\
    \    std::vector<std::tuple<long, long>> row;\n    for (size_t i = 0; i < matrix.size();\
    \ ++i) {\n        matrix[i] = std::vector<long>(lst[0].size());\n    }\n\n   \
    \ for (auto &v : matrix) {\n        std::copy(lst.begin(), lst.end(), v.begin());\n\
    \    }\n\n    bool first_col = true;\n    for (size_t r = 0; r < matrix.size();\
    \ ++r) {\n        std::vector<std::tuple<long, long>> row;\n        for (size_t\
    \ c = 0; c < matrix[r].size(); ++c) {\n            if (first_col) {\n        \
    \        row.emplace_back(std::make_tuple(r, matrix[r][c]));\n            } else\
    \ {\n                row.emplace_back(std::make_tuple(r, c));\n            }\n\
    \        }\n\n        std::sort(row.begin(), row.end(),\n            [](const\
    \ std::tuple<long, long> &left, const std::tuple<long, long> &right) -> bool {\n\
    \                return left.second > right.second;\n            }\n        );\n\
    \n        for (auto &r : row) {\n            std::sort(r.begin(), r.end(),\n \
    \               [](const std::tuple<long, long> &left, const std::tuple<long,\
    \ long> &right) -> bool {\n                    return left.second > right.second;\n\
    \                }\n            );\n        }\n\n        for (size_t c = 0; c\
    \ < matrix[r].size(); ++c) {\n            if (matrix[r][c] == x) {\n         \
    \       std::sort(row.begin(), row.end(),\n                    [](const std::tuple<long,\
    \ long> &left, const std::tuple<long, long> &right) -> bool {\n              \
    \          return left.second > right.second;\n                    }\n       \
    \         );\n                result.push_back(std::move(row.front()));\n    \
    \            break;\n            }\n        }\n        std::sort(row.begin(),\
    \ row.end(),\n            [](const std::tuple<long, long> &left, const std::tuple<long,\
    \ long> &right) -> bool {\n                return left.second > right.second;\n\
    \            }\n        );\n        result.push_back(std::move(row.front()));\n\
    \        first_col = false;\n    }\n\n    return result;", "    std::vector<std::tuple<long,\
    \ long>> ans;\n    auto it_lst = lst.begin();\n    auto it_lst_end = lst.end();\n\
    \    for (; it_lst != it_lst_end; ++it_lst) {\n        std::vector<long> row(*it_lst);\n\
    \        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(), row.rend());\n\
    \        auto row_end = row.end();\n        std::sort(row.begin(), row_end);\n\
    \        auto row_begin_it = row.begin();\n        std::vector<std::tuple<long,\
    \ long>> rows;\n        for (; row_begin_it != row_end; ++row_begin_it) {\n  \
    \          auto col_begin_it = row_begin_it;\n            auto col_end_it = row_begin_it\
    \ + row_begin_it->size();\n            while (col_begin_it != col_end_it) {\n\
    \                if (col_begin_it->first * x == col_begin_it->first * x + col_end_it->first)\
    \ {\n                    rows.emplace_back(col_begin_it->first, col_begin_it->second);\n\
    \                    col_begin_it += row_begin_it->size();\n                }\
    \ else {\n                    col_begin_it = col_begin_it->next();\n         \
    \       }\n            }\n        }\n        for (auto &row : rows) {\n      \
    \      std::reverse(row.begin(), row.end());\n            std::reverse(row.rbegin(),\
    \ row.rend());\n            ans.emplace_back(std::get<0>(row), std::get<1>(row));\n\
    \        }\n    }\n    return ans;", "  assert(lst.size() > 0);\n  assert(x >\
    \ 0);\n  // sort coordinates initially by rows in ascending order.\n  std::vector<std::tuple<long,\
    \ long>> res;\n  for (const auto& row : lst) {\n    std::sort(row.begin(), row.end(),\
    \ [](long l, long r) { return l < r; });\n    std::sort(row.rbegin(), row.rend(),\
    \ [](long l, long r) { return l < r; });\n    // sort coordinates of the row by\
    \ columns in descending order.\n    std::sort(row.begin(), row.end(), [](long\
    \ l, long r) { return l > r; });\n    res.emplace_back(std::make_tuple(row[0],\
    \ row.back()));\n  }\n  for (const auto& row : lst) {\n    std::sort(row.begin(),\
    \ row.end(), [](long l, long r) { return l < r; });\n    std::sort(row.rbegin(),\
    \ row.rend(), [](long l, long r) { return l > r; });\n  }\n  return res;", " \
    \   std::vector<std::tuple<long, long>> result;\n    long x_ind = -1, col_ind\
    \ = -1, row_ind = -1;\n    for (auto &row : lst) {\n        x_ind = -1;\n    \
    \    col_ind = -1;\n        for (auto &ele : row) {\n            if (ele == x)\
    \ {\n                x_ind = col_ind;\n            } else {\n                x_ind\
    \ += 1;\n            }\n            col_ind += 1;\n        }\n        row_ind\
    \ += 1;\n        result.push_back({row_ind, x_ind});\n    }\n    std::sort(result.begin(),\
    \ result.end(), [&](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ std::move(result.begin(), result.end());", "    if (lst.empty()) {\n       \
    \ return std::vector<std::tuple<long, long>>();\n    }\n    std::vector<std::tuple<long,\
    \ long>> row;\n    row.push_back({ 0, lst.size() });\n    for (auto e : lst) {\n\
    \        row.push_back({ static_cast<long>(*std::max_element(e.begin(), e.end())),\
    \ std::distance(e.begin(), std::max_element(e.begin(), e.end())) });\n    }\n\
    \    sort(row.begin(), row.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) { return a.get<1>() < b.get<1>(); });\n    auto it1 = std::find_if(row.begin(),\
    \ row.end(), [&](std::tuple<long, long> e) { return e.get<0>() == 0; });\n   \
    \ auto it2 = std::find_if(row.begin(), row.end(), [&](std::tuple<long, long> e)\
    \ { return e.get<1>() == 0; });\n    if (it1 != row.end()) {\n        for (auto\
    \ it2 = row.end(); it2 != row.begin(); --it2) {\n            if (it2->get<1>()\
    \ == it1->get<1>()) {\n                break;\n            }\n        }\n    \
    \    it2--;\n        std::rotate(it1, it2, row.end());\n        row.erase(it2,\
    \ row.end());\n    }\n    std::vector<std::tuple<long, long>> ans;\n    for (auto\
    \ e : row) {\n        for (auto i : std::get<1>(e)) {\n            if (i < x)\
    \ {\n                ans.push_back(std::make_tuple(std::get<0>(e), i));\n    \
    \        }\n        }\n    }\n    std::sort(ans.begin(), ans.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<1>(a) < std::get<1>(b);\
    \ });\n    return ans;", "\tassert(lst.size() > 0);\n\tassert(lst[0].size() >=\
    \ 1);\n\tstd::vector<std::tuple<long, long>> row;\n\tfor (auto i = 0; i < lst.size();\
    \ i++)\n\t\trow.push_back(std::make_tuple(i, x));\n\tstd::sort(row.begin(), row.end(),\
    \ [](auto &lhs, auto &rhs) {\n\t\treturn std::get<0>(lhs) < std::get<0>(rhs);\n\
    \t});\n\tstd::sort(row.begin(), row.end(), [](auto &lhs, auto &rhs) {\n\t\treturn\
    \ std::get<1>(lhs) < std::get<1>(rhs);\n\t});\n\treturn row;", "    std::vector<std::tuple<long,\
    \ long>> ret;\n    ret.reserve(lst.size());\n    for (auto &r : lst) {\n     \
    \   ret.emplace_back(0, 0); // init tuple\n        for (auto &c : r) {\n     \
    \       ret.back() += c;\n        }\n    }\n    std::sort(ret.begin(), ret.end(),\
    \ [](auto &x, auto &y) {\n        return x[0] < y[0];\n    });\n    std::sort(ret.begin(),\
    \ ret.end(), [](auto &x, auto &y) {\n        return x[1] < y[1];\n    });\n  \
    \  auto &rows = ret.front();\n    auto &cols = ret.back();\n    for (auto &row\
    \ : rows) {\n        if (std::find(rows.begin(), rows.end(), row) != rows.end())\
    \ {\n            rows.erase(std::find(rows.begin(), rows.end(), row));\n     \
    \   }\n    }\n    std::sort(rows.begin(), rows.end(), [](auto &x, auto &y) {\n\
    \        return cols[0] < y[0];\n    });\n    std::sort(rows.begin(), rows.end(),\
    \ [](auto &x, auto &y) {\n        return cols[1] > y[1];\n    });\n    return\
    \ ret;", "    int row = 0, column = 0;\n    for (std::vector<long> row : lst)\
    \ {\n        row++; column = 0;\n        for (long elem : row)\n            column++,\
    \ elem = elem * x;\n        std::make_tuple(row, column);\n    }\n    return std::vector<std::tuple<long,\
    \ long>>(lst);", "    // Your code here\n    std::vector<std::tuple<long, long>>\
    \ result;\n    std::vector<long> row;\n    for (auto row : lst) {\n        row.push_back(0);\n\
    \    }\n    for (auto row : lst) {\n        for (auto col : row) {\n         \
    \   if (col == x) {\n                result.push_back(std::make_tuple(row, row));\n\
    \            } else {\n                result.push_back(std::make_tuple(row, col));\n\
    \            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\
    \ [](std::tuple<long, long> p1, std::tuple<long, long> p2) -> bool {\n       \
    \ return std::get<0>(p1) == std::get<0>(p2);\n    });\n    std::sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> p1, std::tuple<long, long> p2) -> bool\
    \ {\n        return std::get<1>(p1) > std::get<1>(p2);\n    });\n    return result;",
  "    std::vector<std::tuple<long, long>> ans;\n    long max_row = get_max_row(lst);\n\
    \    for (long i = 0; i < max_row; i++) {\n        std::vector<long> row;\n  \
    \      for (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] ==\
    \ x) row.push_back(j);\n        }\n        if (row.size() > 0)\n            std::sort(row.begin(),\
    \ row.end(), [](long i, long j) {return lst[i][j] > lst[j][i];});\n        if\
    \ (row.size() > 1) {\n            std::sort(row.begin(), row.end(), [](long i,\
    \ long j) {return lst[i][j] < lst[j][i];});\n        }\n        for (long j =\
    \ 0; j < row.size(); j++) {\n            ans.push_back(std::make_tuple(i, row[j]));\n\
    \        }\n    }\n    ans.push_back(std::make_tuple(-1, -1));\n    return ans;",
  "  assert(lst.size() > 0);\n  assert(lst.size() == lst[0].size());\n  long ans =\
    \ 0;\n  for (size_t i = 0; i < lst.size(); i++) {\n    if (lst[i][0] == x) {\n\
    \      ans += 1;\n      continue;\n    }\n    for (size_t j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] > x) {\n        break;\n      }\n      ans += 1;\n\
    \    }\n  }\n  std::vector<std::tuple<long, long>> ret;\n  ret.reserve(ans + 1);\n\
    \  for (size_t i = 0; i < lst.size(); i++) {\n    for (size_t j = 0; j < lst[i].size();\
    \ j++) {\n      if (lst[i][j] == x) {\n        ret.emplace_back(i - 1, j - 1);\n\
    \        break;\n      }\n    }\n  }\n  std::reverse(ret.begin(), ret.end());\n\
    \  std::sort(ret.begin(), ret.end(), [](const std::tuple<long, long>& t1, const\
    \ std::tuple<long, long>& t2) { return std::get<0>(t1) < std::get<0>(t2); });\n\
    \  std::reverse(ret.begin(), ret.end());\n  return ret;", "    std::sort(lst.begin(),\
    \ lst.end(), [](std::vector<long> a, std::vector<long> b) { return a[0] < b[0];\
    \ });\n\n    std::vector<std::tuple<long, long>> row;\n    row.push_back(std::make_tuple(0,\
    \ 0));\n    long curRow = 0;\n    long curCol = 0;\n    for (size_t i = 0; i <\
    \ lst.size(); ++i) {\n        long colLen = std::count(lst[i].begin(), lst[i].end(),\
    \ x);\n        if (colLen > 0) {\n            row.push_back(std::make_tuple(curRow,\
    \ curCol));\n            curCol += colLen;\n            while (lst[i][curCol]\
    \ == x) {\n                ++curCol;\n            }\n        } else {\n      \
    \      while (lst[i][curCol] == x) {\n                ++curCol;\n            }\n\
    \            if (curRow != i) {\n                row.push_back(std::make_tuple(curRow,\
    \ curCol));\n            }\n            curRow = i;\n            curCol = 0;\n\
    \        }\n    }\n\n    row.push_back(std::make_tuple(curRow, curCol));\n   \
    \ std::sort(row.begin(), row.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) { return a[0] > b[0]; });\n    return row;", "    std::vector<std::tuple<long,\
    \ long>> coords;\n    coords.reserve(lst.size());\n    for (auto& row : lst) {\n\
    \        for (auto& val : row) {\n            if (val == x) {\n              \
    \  coords.push_back(std::make_tuple(row, row.size()));\n            }\n      \
    \  }\n    }\n    std::sort(coords.begin(), coords.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) { return std::get<0>(a) > std::get<0>(b);\
    \ });\n    std::sort(coords.begin(), coords.end(), [](const std::tuple<long, long>&\
    \ a, const std::tuple<long, long>& b) { return std::get<1>(a) > std::get<1>(b);\
    \ });\n    return coords;", "    // Write your code here\n    int m = lst.size();\n\
    \    std::vector<std::tuple<long, long>> ret;\n    std::vector<std::vector<long>>\
    \ m;\n    std::vector<std::vector<long>> n;\n    std::vector<long> m1(m, 0);\n\
    \    std::vector<long> n1(m, 0);\n    for(int i = 0; i < m; i++) {\n        std::tuple<long,\
    \ long> t = std::make_tuple(i, 0);\n        if(m[i] > x) {\n            t.first\
    \ = i;\n            t.second = m[i];\n            ret.push_back(t);\n        \
    \    n.push_back(0);\n        } else {\n            while(x.compare(m[i]) < 0)\
    \ {\n                ret.push_back(t);\n                n[i]++;\n            }\n\
    \            while(x.compare(m[i]) > 0) {\n                n[i]--;\n         \
    \   }\n        }\n        m[i] = m[i] + n[i];\n        m1[i] = m1[i] + n[i];\n\
    \    }\n    for(long i = 0; i < m.size(); i++) {\n        for(long j = 0; j <\
    \ m[i].size(); j++) {\n            n[i][j] = n[i][j] + m1[i];\n        }\n   \
    \ }\n    for(long i = 0; i < m.size(); i++) {\n        for(long j = 0; j < m[i].size();\
    \ j++) {\n            m[i][j] = m[i][j] - m1[i];\n        }\n    }\n    return\
    \ ret;", "  std::vector<std::tuple<long, long>> res;\n  if (lst.size() == 0 ||\
    \ x == 0) return res;\n  long n = lst.size();\n  long m = lst[0].size();\n  long\
    \ row = 0, col = 0;\n  for (long i = 0; i < n; i++) {\n    long curr = lst[i][0];\n\
    \    long next = (i == n) ? 0 : lst[i + 1][0];\n    if (curr == x) {\n      res.emplace_back(row,\
    \ col);\n    }\n    while (curr <= next) {\n      ++col;\n      curr++;\n    \
    \  if (curr > next && col == m) {\n        col = 0;\n        row++;\n      }\n\
    \      res.emplace_back(row, col);\n    }\n  }\n  sort(res.begin(), res.end());\n\
    \  return res;", "    assert(lst.size() > 0);\n    assert(x >= 0);\n    std::vector<std::tuple<long,\
    \ long>> res;\n    res.push_back(std::make_tuple(0, 0));\n    for (size_t i =\
    \ 0; i < lst.size(); i++) {\n        auto curr_row = std::make_tuple(i, 0);\n\
    \        for (auto j : lst[i]) {\n            if (j == x) {\n                res.push_back(curr_row);\n\
    \            } else {\n                auto next = std::make_tuple(i, j);\n  \
    \              if (curr_row > next)\n                    curr_row = next;\n  \
    \          }\n        }\n    }\n    sort(res.begin(), res.end());\n    for (auto\
    \ res : res)\n        std::cout << std::get<0>(res) << \" \" << std::get<1>(res)\
    \ << \" \" << std::endl;\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> answer;\n    // Your code goes here\n    answer.push_back(std::make_tuple(0,\
    \ 0));\n    auto row = get_row(lst, [&](std::vector<long> &lst){\n        for\
    \ (long i=1; i<lst.size(); ++i)\n            if (lst[i] < x)\n               \
    \ return std::make_tuple(i, 0);\n        return std::make_tuple(i, -1);\n    });\n\
    \    // Your code goes here\n    return answer;", "    int m = lst.size();\n \
    \   std::vector<std::tuple<long, long>> coordinates(m);\n    for(int i = 0; i\
    \ < m; i++) {\n        coordinates[i] = std::make_tuple(i, lst[i][0]);\n    }\n\
    \    std::sort(std::begin(coordinates), std::end(coordinates), [](const std::tuple<long,\
    \ long>& p1, const std::tuple<long, long>& p2) -> bool {\n        return std::get<0>(p1)\
    \ < std::get<0>(p2);\n    });\n\n    for(long i = 0; i < (m - 1); i++) {\n   \
    \     long j = i + 1;\n        std::vector<std::tuple<long, long>> new_coordinates((std::get<1>(coordinates[i])\
    \ - std::get<1>(coordinates[j]) + 1));\n        for(long k = 0; k < (std::get<1>(coordinates[i])\
    \ - std::get<1>(coordinates[j])); k++) {\n            int row_no = std::get<0>(coordinates[i]);\n\
    \            int col_no = std::get<1>(coordinates[j]) + k + 1;\n            if(col_no\
    \ >= (std::get<1>(coordinates[i]) - 1)) {\n                col_no = (std::get<1>(coordinates[i])\
    \ - 1);\n                row_no++;\n            }\n            new_coordinates.push_back(std::make_tuple(row_no,\
    \ col_no));\n        }\n        coordinates = new_coordinates;\n    }\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    for(long i = 0; i < m; i++) {\n        ret.push_back(std::make_tuple(i,\
    \ coordinates[i][1]));\n    }\n    return ret;", "    std::sort(lst.begin(), lst.end(),\
    \ [](std::vector<long> a, std::vector<long> b) {\n        return a.size() == b.size()\
    \ ? std::get<0>(a) < std::get<0>(b) : std::get<0>(a) > std::get<0>(b);\n    });\n\
    \    long rows = lst.size();\n    long cols = std::accumulate(lst.begin(), lst.end(),\
    \ 0);\n    std::vector<std::tuple<long, long>> result;\n    std::vector<std::tuple<long,\
    \ long>> tmp;\n    for (long r = 0; r < rows; ++r) {\n        tmp.clear();\n \
    \       for (long c = 0; c < cols; ++c) {\n            if (lst.at(r).at(c) ==\
    \ x) {\n                tmp.push_back(std::make_tuple(r, c));\n            }\n\
    \        }\n        result.push_back(tmp.at(0));\n    }\n    std::sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \     return std::get<1>(a) < std::get<1>(b);\n    });\n    std::vector<std::tuple<long,\
    \ long>> result1(result);\n    std::sort(result1.begin(), result1.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    return result1;", "    std::vector<std::tuple<long, long>> ans;\n\
    \    // Complete the implementation here.\n    // Do not use std::sort. Rewrite\
    \ your sort algorithm.\n    for (long i = 0; i < lst.size(); ++i) {\n        std::set<std::pair<long,\
    \ long> > row;\n        for (long j = 0; j < lst[i].size(); ++j) {\n         \
    \   row.insert({lst[i][j], j});\n        }\n        row.insert({x, i});\n    \
    \    std::set<std::pair<long, long> > tmp;\n        for (std::set<std::pair<long,\
    \ long> >::iterator it = row.begin();\n             it != row.end(); ++it) {\n\
    \            tmp.insert(*it);\n        }\n        std::pair<long, long> minPair;\n\
    \        std::minmax_element(tmp.begin(), tmp.end(), std::greater<std::pair<long,\
    \ long> >(),\n            [&](std::pair<long, long> a, std::pair<long, long> b)\
    \ { return a.first > b.first; });\n        std::pair<long, long> minPair2(minPair.second,\
    \ minPair.first);\n        ans.push_back({minPair2.second, minPair2.first});\n\
    \    }\n    return ans;", "    if (lst.empty())\n        return std::vector<std::tuple<long,\
    \ long>>{};\n    std::vector<std::tuple<long, long>> v;\n    long nrows = lst.size();\n\
    \    long ncols = lst[0].size();\n    auto it = std::find_if(lst.begin(), lst.end(),\
    \ [&ncols](std::vector<long> col) {return col.size() == ncols;});\n    long ncol\
    \ = std::distance(it, lst.end());\n    auto it = std::find_if(lst[0].begin(),\
    \ lst[0].end(), [&ncol](long col) {return col.size() == ncol;});\n    long ncol0\
    \ = std::distance(it, lst[0].end());\n    for (long i = 0; i < nrows; ++i) {\n\
    \        for (long j = 0; j < ncol0; ++j) {\n            long minpos = std::min(j,\
    \ ncol);\n            for (long k = j + 1; k < ncol; ++k) {\n                long\
    \ maxpos = std::max(ncol - 1, 0);\n                long minpos2 = std::min(k,\
    \ ncol);\n                bool match = false;\n                for (long l = 0;\
    \ l < ncol; ++l) {\n                    if (j == k || j == l || i == k || i ==\
    \ l) {\n                        match = true;\n                        break;\n\
    \                    }\n                    if (l+1 == minpos2 && l != minpos)\
    \ {\n                        minpos = l;\n                    } else if (l+1 ==\
    \ maxpos) {\n                        maxpos = l;\n                    }\n    \
    \            }\n                if (match) {\n                    v.push_back(std::make_tuple(i,\
    \ minpos));\n                    v.push_back(std::make_tuple(i, maxpos));\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    std::sort(v.begin(), v.end(), [](const auto& a, const auto& b) {return std::get<0>(a)\
    \ < std::get<0>(b);});\n    std::sort(v.begin(), v.end(), [](const auto& a, const\
    \ auto& b) {return std::get<1>(a) < std::get<1>(b);});\n    return v;", "    //\
    \ Your code goes here\n    std::vector<std::tuple<long, long>> res;\n    // Base\
    \ case\n    if (lst.size() == 0)\n        return res;\n    // Sort the rows\n\
    \    auto comp = [](long a, long b) -> bool {\n        // Your code goes here\n\
    \        // Your code goes here\n        return a > b;\n    };\n    std::sort(lst.begin(),\
    \ lst.end(), comp);\n    // Sort the columns\n    for (auto &row : lst) {\n  \
    \      std::sort(row.begin(), row.end(), comp);\n    }\n    for (auto &row : lst)\
    \ {\n        // Your code goes here\n        long col = 0;\n        for (auto\
    \ &e : row)\n            if (e == x)\n                res.emplace_back(0, col);\n\
    \            else\n                res.emplace_back(e, col);\n            col++;\n\
    \    }\n    return res;", "    // Your code here\n    auto itr = lst.begin();\n\
    \    std::vector<std::tuple<long, long>> res;\n    long row = 0;\n    long col\
    \ = 0;\n    while (itr != lst.end()) {\n        if ((*itr).size() >= x) {\n  \
    \          row = *itr;\n            col = x;\n            res.push_back({row,\
    \ col});\n        }\n        ++itr;\n    }\n    std::sort(res.begin(), res.end());\n\
    \    auto itr2 = res.begin();\n    row = *itr2;\n    res.erase(itr2);\n    std::sort(res.begin(),\
    \ res.end());\n    res.push_back(std::make_tuple(row, row));\n    return res;",
  "    if (lst.size() == 0)\n        return std::vector<std::tuple<long, long>>();\n\
    \    std::vector<std::tuple<long, long>> result;\n    std::map<long, std::map<long,\
    \ int> > rows;\n    for (auto& row : lst) {\n        std::map<long, int> cols;\n\
    \        for (long i = 0; i < (long)row.size(); i++) {\n            cols[i] =\
    \ 0;\n        }\n        rows[row.at(0)] = cols;\n    }\n    for (auto& row :\
    \ rows) {\n        auto sorted_rows = sort(row.second.begin(), row.second.end());\n\
    \        std::map<long, int> sorted_cols;\n        for (auto it = sorted_rows.rbegin();\
    \ it != sorted_rows.rend(); it++) {\n            sorted_cols[it.first] = it.second;\n\
    \        }\n        result.push_back(std::make_tuple(row.first, sorted_cols));\n\
    \    }\n    for (auto it2 = result.rbegin(); it2 != result.rend(); it2++) {\n\
    \        auto sorted_cols2 = it2->second.rbegin();\n        for (long i = 0; i\
    \ < it2->first; i++) {\n            std::swap(sorted_cols2->second, sorted_cols2->second);\n\
    \        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    return result;", "    if (lst.empty())\n        return std::vector<std::tuple<long,\
    \ long>>();\n    long row = lst[0][0];\n    long col = std::max(0, (row + x -\
    \ 1) % lst[0][0]);\n    return std::vector<std::tuple<long, long>>(std::make_tuple(row,\
    \ col));", '    // Write your code here', "    std::vector<std::tuple<long, long>>\
    \ result;\n    std::vector<long> row;\n    // First sort by rows in ascending\
    \ order.\n    std::sort(lst.begin(), lst.end(), [](std::vector<long> a, std::vector<long>\
    \ b) {\n        if (a.size() != b.size()) {\n            return a.size() < b.size();\n\
    \        }\n        long min_size = a.size();\n        for (long i = 0; i != min_size;\
    \ i++) {\n            if (a[i] < b[i]) {\n                return true;\n     \
    \       }\n        }\n        return false;\n    });\n    for (auto& row : lst)\
    \ {\n        // Then sort by columns in descending order.\n        std::sort(row.begin(),\
    \ row.end(), [](long a, long b) {\n            return b > a;\n        });\n  \
    \      result.push_back(std::make_tuple(row.front(), row.back()));\n    }\n  \
    \  if (result.empty()) {\n        return result;\n    }\n    // Now sort the tuple\
    \ of coordinates initially by rows in ascending order.\n    std::sort(result.begin(),\
    \ result.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n   \
    \     if (a.first > b.first) {\n            return true;\n        }\n        if\
    \ (a.first < b.first) {\n            return false;\n        }\n        // Sort\
    \ by columns in descending order.\n        if (a.second > b.second) {\n      \
    \      return true;\n        }\n        if (a.second < b.second) {\n         \
    \   return false;\n        }\n        return false;\n    });\n    return result;",
  "    if (lst.size() == 0) return {};\n    std::vector<std::tuple<long, long>> res;\n\
    \    for (auto &v : lst) {\n        std::sort(v.begin(), v.end());\n        std::sort(v.begin()\
    \ + v.size() - 1, v.end());\n        if (std::count_if(v.begin(), v.end(), [&](long\
    \ &i) { return i == x; }) > 0) {\n            res.push_back({v.size() - 1, v.size()\
    \ - std::count_if(v.begin(), v.end(), [&](long &i) { return i == x; }) + 1});\n\
    \        }\n    }\n    std::sort(res.begin(), res.end());\n    return res;", " \
    \   std::priority_queue<long, std::vector<long>, std::greater<long>> pq;\n   \
    \ pq.push(0);\n    std::vector<std::tuple<long, long>> res;\n    while (!pq.empty())\
    \ {\n        long i = pq.top();\n        pq.pop();\n        std::vector<long>::iterator\
    \ it;\n        for (it = lst[i].begin(); it != lst[i].end(); ++it) {\n       \
    \     if (*it == x) {\n                res.push_back({i, *it});\n            }\n\
    \            if (*it < x) {\n                pq.push(*it);\n            }\n  \
    \      }\n    }\n    return res;", "  assert(lst.size() >= 1);\n  assert(lst.size()\
    \ % 2 == 0);\n  std::sort(lst.begin(), lst.end(), [](std::vector<long> a, std::vector<long>\
    \ b) {\n    return a[0] < b[0] || a[0] == b[0] && a[1] > b[1];\n  });\n  std::vector<std::vector<long>>\
    \ row_by_column;\n  long row_size = lst.size() / 2;\n  for (long r = 0; r < row_size;\
    \ ++r) {\n    std::vector<long> column(lst.begin() + (2 * r), lst.begin() + (2\
    \ * r + 1));\n    column.erase(std::remove(column.begin(), column.end(), x), column.end());\n\
    \    row_by_column.emplace_back(column);\n  }\n  // std::sort(row_by_column.begin(),\
    \ row_by_column.end(), [](std::vector<long> a, std::vector<long> b) {\n  //  \
    \   return a[0] < b[0] || a[0] == b[0] && a[1] > b[1];\n  // });\n  // std::sort(row_by_column[0].begin(),\
    \ row_by_column[0].end(), [](long a, long b) {\n  //     return a<b;\n  // });\n\
    \  std::vector<std::tuple<long, long>> result;\n  for (long r = 0; r < row_size;\
    \ ++r) {\n    for (long c = 0; c < row_by_column[r].size(); ++c) {\n      if (std::get<0>(row_by_column[r][c])\
    \ == x) {\n        result.emplace_back(std::make_tuple(row_by_column[r][c], c));\n\
    \      }\n    }\n  }\n  return result;", "    // Write your code here\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    assert(lst.size() == 2);\n    assert(lst[0].size() == lst[1].size());\n\
    \    for (long i = 0; i < lst[0].size(); i++) {\n        for (long j = 0; j <\
    \ lst[0].size(); j++) {\n            if (i == j) {\n                if (lst[0][i]\
    \ == x)\n                    ret.push_back(std::make_tuple(i, 0));\n         \
    \       if (lst[1][j] == x)\n                    ret.push_back(std::make_tuple(i,\
    \ 1));\n            } else {\n                for (long k = 0; k < lst[0].size();\
    \ k++) {\n                    if (lst[0][i] == lst[0][k] && lst[1][j] == lst[1][k])\n\
    \                        ret.push_back(std::make_tuple(i, j));\n             \
    \   }\n            }\n        }\n    }\n    std::sort(ret.begin(), ret.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    return ret;", "    // Write your code here\n\
    \    std::vector<std::tuple<long, long>> result;\n    if (lst.size() == 0) return\
    \ result;\n    std::vector<std::tuple<long, long>> row;\n    for (auto row : lst)\
    \ {\n        row.clear();\n    }\n    for (auto element : row) {\n        std::sort(element.begin(),\
    \ element.end(), [](const auto &a, const auto &b) {\n            return std::get<1>(a)\
    \ > std::get<1>(b);\n        });\n    }\n    for (auto element : row) {\n    \
    \    element.clear();\n    }\n    for (auto element : row) {\n        std::sort(element.begin(),\
    \ element.end(), [](const auto &a, const auto &b) {\n            return std::get<0>(a)\
    \ > std::get<0>(b);\n        });\n    }\n    for (auto element : row) {\n    \
    \    result.push_back(element);\n    }\n    return result;", "    // Write your\
    \ code here\n    auto row = std::vector<std::tuple<long, long>>(lst.size());\n\
    \    for (auto &v : lst)\n        for (auto &x : v)\n            if (x == x)\n\
    \                row[v.size()-1] = std::make_tuple(v.size(), 0);\n           \
    \ else\n                row[v.size()-1] = std::make_tuple(v.size(), 1);\n    std::sort(row.begin(),\
    \ row.end(), [](auto &x, auto &y){ return std::get<0>(x) < std::get<0>(y); });\n\
    \    std::reverse(row.begin(), row.end());\n    for (auto &x : row)\n        if\
    \ (std::get<1>(x) == 0)\n            return std::vector<std::tuple<long, long>>();\n\
    \    return row;", "    // Fill this in.\n    return {};", "    if(lst.empty())\
    \ return std::vector<std::tuple<long, long>>();\n    std::vector<std::tuple<long,\
    \ long>> row;\n    long max_row = 0, min_row = 0, max_col = 0;\n    for(auto row\
    \ : lst) {\n        auto count = row.size();\n        if(max_row < count) {\n\
    \            max_row = count;\n        }\n        if(min_row > count) {\n    \
    \        min_row = count;\n        }\n        if(max_col < row.size()) {\n   \
    \         max_col = row.size();\n        }\n    }\n    std::vector<std::tuple<long,\
    \ long>> result;\n    for(long i = 0; i < max_row; ++i) {\n        std::vector<std::tuple<long,\
    \ long>> current_row;\n        for(long j = 0; j < max_col; ++j) {\n         \
    \   if(lst[i][j] == x) {\n                result.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n        if(current_row.size() > 0) {\n     \
    \       std::sort(current_row.begin(), current_row.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n                return a.first\
    \ > b.first;\n            });\n            std::reverse(current_row.begin(), current_row.end());\n\
    \            std::sort(current_row.begin(), current_row.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n                return a.second\
    \ > b.second;\n            });\n            std::reverse(current_row.begin(),\
    \ current_row.end());\n            row.push_back(std::move(current_row));\n  \
    \      }\n    }\n    return result;", "    std::vector<std::tuple<long, long>>\
    \ results;\n    if(lst.empty()) return results;\n    for(long r = 0; r < lst.size();\
    \ ++r) {\n        std::tuple<long, long> row;\n        row = r; // initially,\
    \ rows are sorted by rows\n        for(long c = 0; c < lst[r].size(); ++c) {\n\
    \            if(lst[r][c] == x) { // if x is found, return row\n             \
    \   results.push_back(row);\n                break;\n            }\n         \
    \   auto iter = std::find_if(row.cbegin(), row.cend(), [&](long i) { return i\
    \ == lst[r][c]; });\n            if(iter == row.cend()) row = std::make_tuple(std::max<long>(0,\
    \ c - 1), std::max<long>(r, c - 1));\n            else row = std::make_tuple(std::max<long>(0,\
    \ c - 1), iter);\n        }\n        if(row.cend() == row.cbegin()) return results;\
    \ // if x is not found, return empty list\n        results.push_back(row);\n \
    \   }\n    std::sort(results.cbegin(), results.cend(),\n             [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<0>(a) > std::get<0>(b);\
    \ }\n    );\n    for(auto row : results) std::sort(row.cbegin(), row.cend(),\n\
    \                                        [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) { return std::get<1>(a) < std::get<1>(b); }\n    );\n    return results;",
  "    std::vector<std::tuple<long, long>> res;\n    if (lst.empty() || x == 0) {\n\
    \        return res;\n    }\n    auto get_row = std::bind(std::mem_fn(&get_row),\
    \ std::placeholders::_1);\n    auto get_col = std::bind(std::mem_fn(&get_col),\
    \ std::placeholders::_1);\n    // Sort the rows initially by rows lexicographically\n\
    \    std::sort(lst.begin(), lst.end(), get_row);\n    // Sort the rows by cols\
    \ lexicographically\n    std::sort(lst.begin(), lst.end(), get_col);\n    // Get\
    \ the first row to iterate over the columns later\n    auto row = get_row(lst.front());\n\
    \    // Iterate over the columns\n    for (auto col : get_col(row)) {\n      \
    \  // Find the x in the given row and column\n        if (std::find(lst.begin(),\
    \ lst.end(), x) != lst.end()) {\n            res.push_back(std::make_tuple(row,\
    \ col));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto i : lst)\n        for(auto j : i)\n            if(j\
    \ == x)\n                res.emplace_back(std::make_tuple(i, 0));\n    sort(res.begin(),\
    \ res.end(), [](const auto& lhs, const auto& rhs){ return rhs.get<0>() < lhs.get<0>();\
    \ });\n    res.clear();\n    for(auto i : lst)\n        for(auto j : i)\n    \
    \        if(j == x)\n                res.emplace_back(std::make_tuple(i, j.back()));\n\
    \    sort(res.begin(), res.end(), [](const auto& lhs, const auto& rhs){ return\
    \ rhs.get<1>() < lhs.get<1>(); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> results;\n\n    // First pass: Sort the lst by rows\n    for(auto& row\
    \ : lst)\n        std::sort(row.begin(), row.end());\n    // Second pass: Sort\
    \ the row by columns in descending order\n    for(auto& row : lst) {\n       \
    \ std::sort(row.rbegin(), row.rend());\n        for(auto& column : row) {\n  \
    \          auto pos = std::find(row.begin(), row.end(), column);\n           \
    \ if(pos == row.end()) {\n                results.emplace_back(row, column);\n\
    \            }\n        }\n    }\n    \n    return std::move(results);", "   \
    \ // write your code here\n    // using std::sort\n    std::vector<std::tuple<long,\
    \ long>> res;\n    // sort by columns\n    std::sort(lst.begin(), lst.end(), [](std::vector<long>\
    \ a, std::vector<long> b){\n        return a[0] < b[0];\n    });\n    // sort\
    \ by rows\n    std::sort(lst.begin(), lst.end(), [](std::vector<long> a, std::vector<long>\
    \ b){\n        return a[0] < b[0];\n    });\n    // print res\n    std::vector<std::tuple<long,\
    \ long>> temp;\n    for(auto it : lst){\n        long col = 0;\n        for(auto\
    \ it : it){\n            if(it == x){\n                temp.push_back(std::make_tuple(it\
    \ - 1, col));\n                break;\n            }\n            ++col;\n   \
    \     }\n    }\n    // sort by rows descending\n    std::sort(temp.begin(), temp.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b){\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    res.insert(res.end(), temp.begin(), temp.end());\n\
    \    return res;", "    if(lst.size() == 0){\n        return std::vector<std::tuple<long,\
    \ long>>();\n    }\n    if(x < 0 || x >= lst[0].size()) {\n        return std::vector<std::tuple<long,\
    \ long>>();\n    }\n\n    std::vector<std::tuple<long, long>> r;\n    for(auto\
    \ it1 = lst.begin(), it2 = it1; it2 != lst.end(); ++it1, ++it2){\n        if(it1->size()\
    \ == it2->size()) {\n            long max_value = *std::max_element(it1->begin(),\
    \ it1->end()) + 1;\n            long min_value = *std::min_element(it1->begin(),\
    \ it1->end()) + 1;\n            if((max_value - min_value) == 1) {\n         \
    \       auto l = get_row(it1, x);\n                if(l.size() > 0){\n       \
    \             for(auto it3 = l.begin(), it4 = it3; it4 != l.end(); ++it3, ++it4){\n\
    \                        r.push_back((*it2).at((*it3).first) + (*it4).first);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   return r;", "    std::vector<std::tuple<long, long>> ret;\n    ret.push_back(std::make_tuple(0,\
    \ 0));\n    ret.push_back(std::make_tuple(0, 0));\n    for (auto& row: lst) {\n\
    \        int r = 0, c = 0;\n        for (int i = 0; i < row.size(); i++) {\n \
    \           if (row[i] == x) {\n                ret.push_back(std::make_tuple(r,\
    \ c));\n                ret.push_back(std::make_tuple(r + 1, c + 1));\n      \
    \          break;\n            }\n            c += 1;\n            if (i == row.size()\
    \ - 1) {\n                ret.push_back(std::make_tuple(r + 1, c + 1));\n    \
    \        }\n        }\n        r += 1;\n    }\n    return ret;", "    if (lst.size()\
    \ == 0 || x == 0 || x == 1) {\n        return {};\n    }\n    // Sort the list\
    \ by column in descending order\n    // and by row in ascending order.\n    std::sort(lst.begin(),\
    \ lst.end(), [](const std::vector<long>& l, const std::vector<long>& r) {\n  \
    \          return l.size() != r.size();\n        });\n    std::vector<std::tuple<long,\
    \ long>> res;\n    std::sort(lst.begin(), lst.end(), [](const std::vector<long>&\
    \ l, const std::vector<long>& r) {\n            for (long i = 0; i < l.size();\
    \ i++) {\n                long x = l[i];\n                long y = r[i];\n   \
    \             if (x < y) {\n                    return true;\n               \
    \ }\n            }\n            return false;\n        });\n    // Add elements\
    \ with x == 0 to the result list.\n    std::vector<std::tuple<long, long>> row;\n\
    \    for (size_t i = 0; i < lst.size(); i++) {\n        if (lst[i][0] == x) {\n\
    \            row.push_back({x, 0});\n        }\n    }\n    res.insert(res.end(),\
    \ row.begin(), row.end());\n    return res;", "    long row = 0;\n    long col\
    \ = 0;\n    long max_row = 0, max_col = 0;\n    for (size_t i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i].size() > row) {\n            row = lst[i].size();\n\
    \        }\n        if (lst[i].size() > col) {\n            col = lst[i].size();\n\
    \        }\n    }\n    for (size_t i = 0; i < lst.size(); i++) {\n        std::sort(lst[i].begin(),\
    \ lst[i].end());\n        std::sort(lst[i].begin() + row, lst[i].end() - row);\n\
    \        std::sort(lst[i].begin() + col, lst[i].end() - col);\n        max_row\
    \ = std::max(max_row, row);\n        max_col = std::max(max_col, col);\n    }\n\
    \    std::vector<std::tuple<long, long>> res;\n    for (size_t i = 0; i < lst.size();\
    \ i++) {\n        res.push_back((std::make_tuple(i, std::find(lst[i].begin(),\
    \ lst[i].end(), x) - lst[i].begin()),\n                       std::find(lst[i].begin()\
    \ + row, lst[i].end() - row, x) - lst[i].begin() + max_row));\n        res.push_back((std::make_tuple(i,\
    \ std::find(lst[i].begin(), lst[i].end(), x) - lst[i].begin() + max_col),\n  \
    \                     std::find(lst[i].begin() + col, lst[i].end() - col, x) -\
    \ lst[i].begin() + max_col));\n    }\n    return res;", "    // Write your code\
    \ here.\n    std::sort(lst.begin(), lst.end(), [](const std::vector<long> &a,\
    \ const std::vector<long> &b) {\n        if (a.size() == 0) {\n            return\
    \ true;\n        }\n        if (a.size() != b.size()) {\n            return true;\n\
    \        }\n        long l = a.front();\n        long r = a.back();\n        return\
    \ l < r;\n    });\n    std::vector<std::tuple<long, long>> res;\n    for (const\
    \ auto &lst : lst) {\n        for (const auto &elem : lst) {\n            if (elem\
    \ == x) {\n                res.emplace_back(lst[0], lst.size() - 1);\n       \
    \         break;\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> ans;\n    ans.reserve(2 * (lst.size()\
    \ + 1));\n    for (size_t i = 0; i < (lst.size() + 1); ++i) {\n        ans.emplace_back(i,\
    \ 0);\n    }\n    for (size_t i = 0; i < lst.size(); ++i) {\n        std::vector<long>\
    \ row;\n        row.reserve(2 * lst.at(i).size());\n        for (size_t j = 0;\
    \ j < lst.at(i).size(); ++j) {\n            row.emplace_back(j + i * lst.at(i).size());\n\
    \        }\n        ans[2 * i] = std::make_tuple(i, 0);\n        std::partial_sort(row.begin(),\
    \ row.end(), row.begin(), [](long a, long b) { return a < b; });\n        for\
    \ (size_t j = 0; j < lst.at(i).size(); ++j) {\n            ans[2 * i + 1 + j]\
    \ = std::make_tuple(i, j);\n            std::partial_sort(row.begin(), row.end(),\
    \ row.begin(), [](long a, long b) { return a < b; });\n        }\n    }\n    for\
    \ (auto x : ans) {\n        assert(std::get<0>(x) == x);\n        assert(std::get<1>(x)\
    \ == 0);\n    }\n    return ans;", "    std::sort(lst.begin(), lst.end(), [](const\
    \ std::vector<long> &a, const std::vector<long> &b) { return a[0] > b[0]; });\n\
    \    long size = lst.size();\n    std::vector<std::tuple<long, long>> res;\n \
    \   std::vector<std::tuple<long, long>> temp;\n    long row = 0;\n    long col\
    \ = 0;\n    long xsize = std::accumulate(lst.begin(), lst.end(), 0ll, [](long\
    \ acc, const std::vector<long> &v) {\n        return acc + v.size();\n    });\n\
    \    xsize = std::max(xsize - 1, 0ll);\n    for (long i = 0; i < size; i++) {\n\
    \        row = std::get<0>(std::get<1>(lst[i])) + 1;\n        for (long j = 0;\
    \ j < std::get<0>(std::get<1>(lst[i])); j++) {\n            col = std::get<1>(std::get<1>(lst[i]))\
    \ - 1;\n            if (x == std::get<0>(std::get<1>(lst[i])) && row == std::get<1>(std::get<1>(lst[i])))\
    \ {\n                res.push_back(std::make_tuple(row, col));\n             \
    \   temp.push_back(std::make_tuple(row, col));\n                col--;\n     \
    \           x--;\n            }\n        }\n        if (x > 0 && xsize == size\
    \ - 1) {\n            row++;\n            col = 0;\n            x++;\n       \
    \ }\n    }\n    std::sort(temp.begin(), temp.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return a[1] > b[1]; });\n    temp\
    \ = temp + res;\n    std::sort(temp.begin(), temp.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return a[0] < b[0]; });\n    return\
    \ temp;", "    // write your code here\n    std::vector<std::tuple<long, long>>\
    \ res;\n    for(auto it=lst.begin(); it!=lst.end(); ++it)\n    {\n        for(auto\
    \ it2=it->begin(); it2!=it->end(); ++it2)\n        {\n            if((*it)[x]\
    \ == (*it2)[x])\n            {\n                std::pair<long, long> row;\n \
    \               row.first = *it;\n                row.second = *it2;\n       \
    \         res.push_back(row);\n            }\n        }\n    }\n    res.sort();\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    std::vector<long>\
    \ temp;\n    long tempRow = 0;\n    long tempCol = 0;\n    for (int i = 0; i <\
    \ lst.size(); i++) {\n        temp.clear();\n        for (int j = 0; j < lst[i].size();\
    \ j++) {\n            if (lst[i][j] == x) {\n                temp.push_back(j);\n\
    \            }\n        }\n        long tempRows = temp.size();\n        if (tempRows\
    \ > 0) {\n            for (long j = 0; j < tempRows; j++) {\n                tempCol\
    \ = temp[j];\n                tempRow += 1;\n                res.push_back(std::make_tuple(tempRow,\
    \ tempCol));\n            }\n            std::sort(res.begin(), res.end());\n\
    \            std::reverse(res.begin(), res.end());\n            return res;\n\
    \        }\n    }\n    return res;", "    assert(lst.size() == 2);\n    assert(lst[0].size()\
    \ == 6);\n    assert(lst[1].size() == 6);\n\n    // Use std::vector::at instead\
    \ of std::vector::operator [] because it\n    // allows the user to pass an index\
    \ by reference rather than by value.\n    std::vector<std::tuple<long, long>>\
    \ row;\n    for (size_t i = 0; i < 6; i++) {\n        row.push_back({i, x});\n\
    \    }\n\n    // Sort coordinate pairs by rows in ascending order.\n    std::stable_sort(row.begin(),\
    \ row.end(), [](const auto& a, const auto& b) -> bool {\n        return a.first\
    \ < b.first;\n    });\n\n    // Sort coordinate pairs by columns in descending\
    \ order.\n    std::stable_sort(row.begin(), row.end(), [](const auto& a, const\
    \ auto& b) -> bool {\n        return a.second > b.second;\n    });\n\n    return\
    \ row;", "    // TODO: Fill this in.\n    std::vector<std::tuple<long, long>>\
    \ rows;\n    return rows;", "    // code here\n    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<std::vector<long>>::iterator it;\n    for (it =\
    \ lst.begin(); it != lst.end(); it++) {\n        for (long y = 0; y < it->size();\
    \ y++) {\n            if (std::find(it->begin() + y, it->begin() + y + 1, x) !=\
    \ it->end()) {\n                res.push_back({y+1, it->at(y).at(x)});\n     \
    \       }\n        }\n    }\n    sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) -> bool {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n    sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) -> bool {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    return res;", "    // your code here\n    std::vector<std::tuple<long,\
    \ long>> lst2;\n    for (long i = 0; i < lst.size(); i++) {\n        lst2.push_back(std::make_tuple(i,\
    \ std::find(lst[i].begin(), lst[i].end(), x) - lst[i].begin()));\n    }\n    std::sort(lst2.begin(),\
    \ lst2.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(lst2.begin(),\
    \ lst2.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return lst2;",
  "    // Write your code here.\n    // Use sort() function to sort coordinates initially\
    \ by rows.\n    // Also use partial_sort_descending() function to sort coordinates\
    \ initially by rows.", "  std::sort(lst.begin(), lst.end());\n  std::vector<std::tuple<long,\
    \ long>> res;\n  res.reserve(lst.size());\n  for (auto row : lst)\n    if (std::find(row.begin(),\
    \ row.end(), x) != row.end())\n      res.emplace_back(std::tuple<long, long>{row.begin(),\
    \ row.end()});\n  return res;", '    // your code here', "    std::vector<std::tuple<long,\
    \ long>> res(lns.size());\n    for (auto it = lns.begin(); it != lns.end(); ++it)\
    \ {\n        for (auto it1 = it->begin(); it1 != it->end(); ++it1) {\n       \
    \     if (x == *it1) {\n                res[it->size()] = std::make_tuple(*it,\
    \ it->size() - 1);\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    //\
    \ Your code here\n    if(lst.empty())\n        return {};\n    auto rows = lst.size();\n\
    \    auto cols = lst[0].size();\n    auto result = std::make_pair(std::make_tuple(std::make_tuple(0,\
    \ 0), std::make_tuple(0, cols)),\n                                 std::make_tuple(std::make_tuple(0,\
    \ rows - 1), std::make_tuple(rows - 1, cols)));\n    for(auto i = 0; i <= rows\
    \ - 2; ++i) {\n        for(auto j = 0; j <= cols - 2; ++j) {\n            if(x\
    \ % rows == i)\n                return {std::make_tuple(std::make_tuple(i, j),\
    \ std::make_tuple(i - 1, j)),\n                        std::make_tuple(std::make_tuple(i,\
    \ j + 1), std::make_tuple(i - 1, j + 1))};\n            if(x % cols == j)\n  \
    \              return {std::make_tuple(std::make_tuple(i + 1, j), std::make_tuple(i,\
    \ j - 1)),\n                        std::make_tuple(std::make_tuple(i + 1, j +\
    \ 1), std::make_tuple(i, j - 1))};\n        }\n    }\n    return {};", "    if(lst.size()\
    \ == 0)\n        return {};\n    if(lst.size() == 1)\n        return { { 0, lst[0][0]\
    \ } };\n    std::vector<std::vector<long>> mat(lst.size(), std::vector<long>(lst[0].size()\
    \ + 1));\n    for(long i = 0; i < mat.size(); ++i)\n        mat[i][0] = i;\n \
    \   for(long i = 0; i < mat[0].size(); ++i)\n        mat[0][i] = 0;\n    for(long\
    \ i = 0; i < lst.size(); ++i) {\n        for(long j = 0; j < lst[i].size(); ++j)\
    \ {\n            mat[i][j + 1] = lst[i][j];\n            mat[i][i + 1] = mat[i][j];\n\
    \        }\n    }\n    std::vector<std::tuple<long, long>> res;\n    for(long\
    \ i = 0; i < mat[0].size(); ++i) {\n        for(long j = 0; j < mat[0].size();\
    \ ++j) {\n            auto itr = std::find(mat.begin(), mat.end(), std::make_tuple(i,\
    \ j));\n            if(itr != mat.end()) {\n                res.push_back({mat[0][i],\
    \ mat[0][j]});\n                mat[0][j] = itr->second;\n                mat[0][i]\
    \ = itr->first;\n            }\n        }\n    }\n    std::vector<std::tuple<long,\
    \ long>> resSorted(res.begin(), res.end());\n    std::sort(resSorted.begin(),\
    \ resSorted.end(), [](const std::tuple<long, long>& a, const std::tuple<long,\
    \ long>& b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::vector<std::tuple<long,\
    \ long>> resSortedRow;\n    std::vector<std::tuple<long, long>> resSortedColumn;\n\
    \    for(auto& t: resSorted)\n        if(std::get<0>(t) != 0)\n            resSortedRow.push_back(t);\n\
    \        for(auto& t: resSorted)\n            if(std::get<1>(t) != 0)\n      \
    \          resSortedColumn.push_back(t);\n    return resSortedRow;", "    // Your\
    \ code here\n    std::vector<std::tuple<long, long>> res;\n    if (lst.size()\
    \ == 0)\n        return res;\n    std::vector<long> row_nums(lst.size());\n  \
    \  long row_idx = 0, col_idx = 0;\n    for (auto it = lst.begin(); it != lst.end();\
    \ ++it) {\n        row_nums[row_idx++] = (*it).size();\n    }\n    for (long i\
    \ = 0; i < row_nums.size(); i++) {\n        if (row_nums[i] > col_idx)\n     \
    \       std::swap(row_nums[i], col_idx);\n    }\n    std::sort(row_nums.begin(),\
    \ row_nums.end());\n    std::reverse(row_nums.begin(), row_nums.end());\n    for\
    \ (long i = 0; i < row_nums.size(); i++) {\n        std::sort(row_nums.begin(),\
    \ row_nums.end(), [&col_idx, &i, &row_nums] (const long &a, const long &b) mutable\
    \ {\n            return a > b ? b - a : a - b;\n        });\n        for (long\
    \ j = 0; j < row_nums[i]; j++) {\n            res.push_back(std::make_tuple(row_idx\
    \ + i, col_idx + j));\n        }\n    }\n    return res;", "    // Your code here\n\
    \    std::sort(lst.begin(), lst.end(), [](const std::vector<long>& r1, const std::vector<long>&\
    \ r2) {\n        return r1.size() == r2.size() &&\n            std::lexicographical_compare(r1.begin(),\
    \ r1.end(), r2.begin(), r2.end());\n    });\n    std::vector<std::tuple<long,\
    \ long>> res;\n    long current_row, current_col, current_row, current_col;\n\
    \    for (size_t i = 0; i < lst.size(); i++) {\n        if (lst[i].size() == x)\
    \ {\n            res.emplace_back(i, 0);\n        }\n    }\n    for (size_t i\
    \ = 0; i < lst.size(); i++) {\n        if (lst[i].size() >= x) {\n           \
    \ current_row = i;\n            for (size_t j = x; j < lst[i].size(); j++) {\n\
    \                for (current_col = 0; current_col < x; current_col++) {\n   \
    \                 res.emplace_back(std::make_tuple(current_row, current_col));\n\
    \                }\n                current_col += 1;\n            }\n       \
    \     current_col = 0;\n            for (size_t j = x; j < lst[i].size(); j++)\
    \ {\n                for (current_row = 0; current_row < x; current_row++) {\n\
    \                    res.emplace_back(std::make_tuple(current_row, current_col));\n\
    \                }\n                current_row += 1;\n            }\n       \
    \ }\n    }\n    return res;", "    long n = lst.size();\n    std::vector<std::tuple<long,\
    \ long>> res;\n    if (n == 0) {\n        return res;\n    }\n    if (n == 1)\
    \ {\n        for (long i = 0; i < x; ++i) {\n            res.push_back({0, i});\n\
    \        }\n        return res;\n    }\n    long m = (n + 1) >> 1;\n    std::vector<std::tuple<long,\
    \ long>> m_res(m, std::make_tuple(0, 0));\n    std::vector<std::vector<long>>\
    \ m(m);\n    for (long i = 0; i < m; ++i) {\n        long ni = i;\n        for\
    \ (long j = 0; j < n; ++j) {\n            if (lst[j][ni] < x) {\n            \
    \    m_res[i] += std::make_tuple(j, ni);\n            }\n        }\n    }\n  \
    \  std::sort(m_res.begin(), m_res.end(), [](const std::tuple<long, long>& a, const\
    \ std::tuple<long, long>& b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    for (long i = 0; i < m; ++i) {\n        m_res[i].sort();\n    }\n\
    \    std::sort(m_res[0].begin(), m_res[0].end(), [](const std::tuple<long, long>&\
    \ a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) > std::get<0>(b);\n\
    \    });\n    for (long i = 0; i < n; ++i) {\n        auto it = m_res[0][i].end();\n\
    \        for (long j = 0; j < m_res.size(); ++j) {\n            if (it != m_res[j][i].begin())\
    \ {\n                it = std::next(it);\n            }\n        }\n        for\
    \ (long j = 0; j < m; ++j) {\n            if (it != m_res[j][i].begin()) {\n \
    \               it = std::next(it);\n            }\n        }\n        for (long\
    \ j = 0; j < m; ++j) {\n            if (it != m_res[j][i].begin()) {\n       \
    \         it = std::next(it);\n            }\n        }\n        auto end = it;\n\
    \        while (!std::equal(m_res[j].begin(), m_res[j].end(), it)) {\n       \
    \     it = end;\n            ++it;\n        }\n        for (long j = n; j > i;\
    \ --j) {\n            auto it = std::next(m_res[j][i].end());\n            for\
    \ (long k = i; k >= 0; --k) {\n                if (it != m_res[k][i].end()) {\n\
    \                    it = std::next(it);\n                }\n            }\n \
    \           std::reverse(m_res[j][i].begin(), m_res[j][i].end());\n        }\n\
    \        for (long j = i; j < n; ++j) {\n            std::reverse(m_res[j][i].begin(),\
    \ m_res[j][i].end());\n        }\n        std::reverse(m_res[i].begin(), m_res[i].end());\n\
    \        res.emplace_back(std::get<0>(m_res[i]), std::get<", "    // Your code\
    \ here\n    std::vector<std::tuple<long, long>> ret;\n    for (auto& l : lst)\
    \ {\n        for (int i = 0; i < l.size(); i++) {\n            if (l[i] == x)\
    \ {\n                std::make_tuple(i, l.size() - 1)\n                    .swap(std::make_tuple(0,\
    \ l.size() - 1));\n                ret.push_back(std::make_tuple(i, l.size() -\
    \ 1));\n                break;\n            }\n        }\n    }\n    std::sort(ret.begin(),\
    \ ret.end(), [](const std::tuple<long, long> a, const std::tuple<long, long> b)\
    \ -> bool {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::reverse(ret.begin(),\
    \ ret.end());\n    return ret;", "    // write your code here\n    std::vector<std::tuple<long,\
    \ long>> output;\n    for(size_t i = 0; i < lst.size(); i++) {\n        for(size_t\
    \ j = 0; j < lst[i].size(); j++) {\n            if(lst[i][j] == x)\n         \
    \       output.push_back(std::make_tuple(i, j));\n        }\n    }\n    std::sort(output.begin(),\
    \ output.end(), [](const std::tuple<long, long>& a, const std::tuple<long, long>&\
    \ b) -> bool{return std::get<0>(a) < std::get<0>(b);});\n    std::reverse(output.begin(),\
    \ output.end());\n    for(size_t i = 0; i < output.size(); i++) {\n        std::swap(output[i],\
    \ output[std::get<1>(output[i])]);\n    }\n    for(size_t i = 0; i < output.size();\
    \ i++) {\n        std::reverse(std::get<1>(output[i]).begin(), std::get<1>(output[i]).end());\n\
    \    }\n    return output;", "    std::vector<std::tuple<long, long>> res;\n \
    \   if(lst.empty())\n        return res;\n    res.reserve(lst.size());\n    for(auto\
    \ &el : lst) {\n        res.emplace_back(std::make_tuple(el[0], el[lst.size()\
    \ - 1]));\n    }\n    std::sort(res.begin(), res.end(), [](auto &e1, auto &e2)\
    \ {\n        return std::get<0>(e1) < std::get<0>(e2);\n    });\n    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &el : res) {\n        auto pos = std::find(res.begin(),\
    \ res.end(), el);\n        if(pos != res.end())\n            res.erase(pos);\n\
    \        else\n            res.emplace_back(std::make_tuple(0, std::get<1>(el)));\n\
    \    }\n    res.emplace_back(std::make_tuple(0, 0));\n    for(auto &el : res)\
    \ {\n        if(std::get<0>(el) == x)\n            return res;\n    }\n    return\
    \ {};", "    // Your code goes here\n    std::vector<std::tuple<long, long>> ans;\n\
    \    long max = 0;\n    for (long i = 0; i < lst.size(); i++) {\n        for (long\
    \ j = 0; j < lst[i].size(); j++) {\n            if (max < lst[i][j]) {\n     \
    \           max = lst[i][j];\n            }\n        }\n    }\n    for (long i\
    \ = 0; i < lst.size(); i++) {\n        long temp = 0;\n        for (long j = 0;\
    \ j < lst[i].size(); j++) {\n            if (lst[i][j] == x) {\n             \
    \   temp++;\n            }\n        }\n        if (temp == max) {\n          \
    \  ans.push_back({i, max});\n            max = max - 1;\n        }\n    }\n  \
    \  for (long i = 0; i < lst.size(); i++) {\n        long temp = 0;\n        for\
    \ (long j = 0; j < lst[i].size(); j++) {\n            if (lst[i][j] == max) {\n\
    \                temp++;\n            }\n        }\n        ans.push_back({0,\
    \ temp});\n        max = temp;\n    }\n    std::sort(ans.begin(), ans.end(), [](const\
    \ std::tuple<long, long> & t1, const std::tuple<long, long> & t2) {\n        return\
    \ std::get<0>(t1) < std::get<0>(t2);\n    });\n    for (auto it=ans.begin(); it!=ans.end();\
    \ ++it) {\n        std::swap(std::get<0>(*it), std::get<0>(*(it-1)));\n      \
    \  std::swap(std::get<1>(*it), std::get<1>(*(it-1)));\n    }\n    return ans;",
  "    std::vector<std::tuple<long, long>> res;\n    // Iterate through each row of\
    \ lst.\n    for (auto &row : lst) {\n        // For each row, sort the coordinates\
    \ initially by row\n        std::sort(row.begin(), row.end());\n        // Iterate\
    \ through each coordinate of this row.\n        for (auto &coord : row) {\n  \
    \          // If the coordinate is larger than x, ignore it.\n            if (coord\
    \ > x) {\n                continue;\n            }\n            // Else, return\
    \ all coordinates with same row and column value.\n            // The coordinates\
    \ are ordered by ascending rows in ascending order,\n            // while rows\
    \ are ordered by descending columns in descending order.\n            auto end\
    \ = std::find(row.begin(), row.end(), coord);\n            auto start = std::find(row.begin(),\
    \ row.end(), coord - 1);\n            // If the coordinate is not found, ignore.\n\
    \            if (end == row.end() || start == row.end()) {\n                continue;\n\
    \            }\n            auto i = std::distance(row.begin(), start);\n    \
    \        auto j = std::distance(row.begin(), end);\n            // Return the\
    \ tuple with the coordinates.\n            res.emplace_back(i, j);\n        }\n\
    \    }\n    return res;", "    if (lst.empty()) return std::vector<std::tuple<long,\
    \ long>>();\n    std::vector<std::tuple<long, long>> res;\n    for (auto r : lst)\
    \ {\n        // sort columns in descending order\n        std::sort(r.begin(),\
    \ r.end(), [](long a, long b){return b < a; });\n        auto row_res = get_row(r,\
    \ x);\n        if (row_res.size() > 0) {\n            for (auto r : row_res) {\n\
    \                res.emplace_back(r.first, r.second);\n            }\n       \
    \ }\n    }\n    return res;", "    assert(lst.size() > 0);\n    assert(lst.size()\
    \ <= INT_MAX);\n    auto ret = std::make_tuple(0, 0);\n    auto cur = std::make_tuple(0,\
    \ 0);\n    for (auto it=lst.begin();it!=lst.end();it++,cur=ret) {\n        cur\
    \ = std::make_tuple(it->size(), it->back());\n        ret = std::make_tuple(std::min(std::min(std::get<0>(cur),\
    \ std::get<1>(cur)), x), std::max(std::max(std::get<0>(cur), std::get<1>(cur)),\
    \ x));\n    }\n    return ret;", "  std::vector<std::tuple<long, long>> ret;\n\
    \  if (lst.size() == 0) {\n    return ret;\n  }\n  ret.reserve(lst.size());\n\
    \  for (auto &row : lst) {\n    ret.resize(row.size());\n    std::vector<long>\
    \ temp;\n    for (size_t i = 0; i < row.size(); ++i) {\n      temp.push_back(row[i]);\n\
    \    }\n    std::sort(temp.begin(), temp.end());\n    for (size_t i = 0; i < row.size();\
    \ ++i) {\n      ret[i] = std::make_tuple(row[i], temp[row.size() - i - 1]);\n\
    \    }\n  }\n  std::sort(ret.begin(), ret.end(), [](auto &a, auto &b) { return\
    \ a.second > b.second; });\n  std::vector<std::tuple<long, long>> temp;\n  for\
    \ (size_t i = 0; i < ret.size() / 2; ++i) {\n    temp.push_back(std::make_tuple(ret[ret.size()\
    \ - i - 1].second, ret[i].second));\n  }\n  ret.resize(temp.size());\n  return\
    \ ret;", "    // Your code here\n    if (lst.size() == 0) {\n        std::cout\
    \ << \"Error\";\n        return std::vector<std::tuple<long, long>>();\n    }\n\
    \n    std::vector<std::tuple<long, long>> ans;\n    for (auto row : lst) {\n \
    \       std::tuple<long, long> row_tuple = std::make_tuple(0, 0);\n        std::sort(row.begin(),\
    \ row.end(), [](auto a, auto b) {\n            return b < a;\n        });\n  \
    \      for (auto val : row) {\n            if (val == x) {\n                row_tuple\
    \ = std::make_tuple(row.size() - 1, row.size() - 1);\n                break;\n\
    \            } else if (val > x) {\n                row_tuple = std::make_tuple(row.size()\
    \ - 1, row.size());\n                break;\n            }\n        }\n      \
    \  ans.push_back(row_tuple);\n    }\n    std::sort(ans.begin(), ans.end(), [](auto\
    \ a, auto b) {\n        return std::get<0>(b) - std::get<0>(a) < std::get<1>(b)\
    \ - std::get<1>(a);\n    });\n    return ans;", '    // Your code goes here',
  "    // Your code here\n    long rows = 0;\n    long cols = 0;\n    for (std::vector<std::vector<long>>\
    \ row: lst) {\n        cols += row.size();\n    }\n    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<std::tuple<long, long>> res1;\n    for (std::vector<std::vector<long>>\
    \ row: lst) {\n        long start = 0;\n        for (long i = 0; i < row.size();\
    \ i++) {\n            if (i == rows.size()) {\n                res1.push_back(std::make_tuple(i\
    \ - rows, cols));\n                break;\n            } else if (i == 0) {\n\
    \                res1.push_back(std::make_tuple(i, cols));\n                start\
    \ = i;\n                break;\n            }\n            if (row[i] != x &&\
    \ row[i] == row[i - 1]) break;\n        }\n        for (int j = start; j < row.size();\
    \ j++) {\n            if (row[j] != x && row[j] == row[j - 1]) break;\n      \
    \      res1.push_back(std::make_tuple(j, cols));\n        }\n        res1.push_back(std::make_tuple(j,\
    \ cols));\n        rows++;\n        cols = 0;\n    }\n    std::sort(res1.begin(),\
    \ res1.end(), [](auto &t1, auto &t2) {\n        return std::get<0>(t1) < std::get<0>(t2);\n\
    \    });\n    for (auto &t: res1) {\n        res.push_back(std::make_tuple(std::get<0>(t),\
    \ std::get<1>(t)));\n    }\n    return res;", "    // Your code here\n    \n \
    \   long row = 0;\n    long col = 0;\n    std::vector<std::tuple<long, long>>\
    \ res;\n    for(auto v : lst) {\n        if(row == v.size()) {\n            row\
    \ = 0;\n            col++;\n        }\n        else if(col == v.size()) {\n  \
    \          row++;\n            col = 0;\n        }\n        if(v[x] != -1) {\n\
    \            res.push_back(std::make_tuple(row,col));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    \n    return\
    \ res;", "    // Write your code here\n    std::vector<std::tuple<long, long>>\
    \ temp;\n    if(lst.size() == 0)\n    {\n        return temp;\n    }\n    for(int\
    \ i = 0; i < lst.size(); i++)\n    {\n        for(int j = 0; j < lst[i].size();\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     temp.push_back(std::make_tuple(i, j));\n            }\n        }\n    }\n\
    \    return temp;", "    // Your code here\n    std::vector<std::tuple<long, long>>\
    \ ans;\n    for(auto & row: lst){\n        for(auto & val: row){\n           \
    \ if(x == val){\n                ans.emplace_back(row.size() - 1, row.size() -\
    \ 1);\n            }\n        }\n    }\n    return ans;", "    std::sort(\n  \
    \          lst.begin(),\n            lst.end(),\n            [](const std::vector<long>\
    \ &a, const std::vector<long> &b){\n                return a[1] < b[1];\n    \
    \        }\n        );\n    std::vector<std::tuple<long, long>> res;\n    // Using\
    \ 2D array (pointers) to store coordinates\n    std::vector<std::vector<long>>\
    \ row_by_cols;\n    std::vector<long> rows(lst.size());\n    // Get rows by columns\
    \ in reverse order as in sorting by columns\n    for (long i = 1; i < lst.size();\
    \ i++) {\n        std::reverse(\n                lst.begin() + i - 1,\n      \
    \          lst.begin() + i\n            );\n        std::vector<long> cols(i -\
    \ 1);\n        std::transform(\n                lst.begin() + i - 1,\n       \
    \         lst.begin() + i,\n                std::back_inserter(cols),\n      \
    \          [](const std::vector<long> &a) {\n                    return a[1];\n\
    \                }\n            );\n        std::sort(\n                cols.begin(),\n\
    \                cols.end(),\n                [](const std::vector<long> &a, const\
    \ std::vector<long> &b){\n                    return b < a;\n                }\n\
    \            );\n        row_by_cols.emplace_back(cols);\n    }\n    // Iterate\
    \ over all the rows\n    for (long i = 0; i < row_by_cols.size(); i++) {\n   \
    \     // Sort coordinates of each row by columns in ascending order\n        std::sort(\n\
    \                row_by_cols[i].begin(),\n                row_by_cols[i].end(),\n\
    \                [](const std::vector<long> &a, const std::vector<long> &b){\n\
    \                    return a[0] > b[0];\n                }\n        );\n    \
    \    auto iter = std::find(\n                row_by_cols[i].begin(),\n       \
    \         row_by_cols[i].end(),\n                x\n            );\n        //\
    \ If x is in current row, add it to result list\n        if (iter != row_by_cols[i].end())\
    \ {\n            res.emplace_back(std::make_tuple(i, std::distance(row_by_cols[i].begin(),\
    \ iter))); // Find index and length of current row, as in sorting\n        }\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    long\
    \ i = 0;\n    std::vector<long> row;\n    std::vector<long> col;\n    while (lst.size())\
    \ {\n        if (i == 0) {\n            row = lst;\n            col = lst;\n \
    \       } else {\n            row = lst;\n            col = lst;\n           \
    \ std::swap(row[row.size() - 1], row[0]);\n            std::swap(col[col.size()\
    \ - 1], col[0]);\n        }\n        bool found = false;\n        for (auto val\
    \ : row) {\n            if (val == x) {\n                res.emplace_back(std::make_tuple(i,\
    \ val));\n                found = true;\n                break;\n            }\n\
    \        }\n        if (!found) res.emplace_back(std::make_tuple(0, x));\n   \
    \     std::rotate(row.begin(), row.begin() + 1, row.end());\n        std::rotate(col.begin(),\
    \ col.begin() + 1, col.end());\n        i++;\n    }\n    std::sort(res.begin(),\
    \ res.end(),\n        [&](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) {\n            return std::get<0>(a) < std::get<0>(b);\n        });\n\
    \    for (auto &x : res) x = std::make_tuple(std::get<1>(x), std::get<0>(x));\n\
    \    return res;", "    if (lst.empty())\n        return {};\n    auto it = std::find_if(lst.begin(),\
    \ lst.end(), [&x](const std::vector<long> &row) -> bool {\n        for (long j\
    \ = 0; j < row.size(); j++)\n            if (row[j] == x)\n                return\
    \ true;\n        return false;\n    });\n    if (it == lst.end())\n        return\
    \ {};\n    auto rbegin = std::prev(it, lst.end());\n    for (auto i = std::next(it);\
    \ i != rbegin;) {\n        std::vector<std::tuple<long, long>> rows;\n       \
    \ auto j = std::next(i);\n        for (long k = 0; k < j->size(); k++) {\n   \
    \         long row = j->at(k);\n            long col = j->at(j->size() - 1 - k);\n\
    \            auto result = std::make_tuple(row, col);\n            rows.push_back(std::move(result));\n\
    \        }\n        std::sort(rows.begin(), rows.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) -> bool {\n            return std::get<0>(a)\
    \ > std::get<0>(b);\n        });\n        std::sort(rows.begin(), rows.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) -> bool\
    \ {\n            return std::get<1>(a) < std::get<1>(b);\n        });\n      \
    \  for (auto &row : rows)\n            lst.emplace_back(row);\n        i = j;\n\
    \    }\n    return lst;", "    long row = 0;\n    for (auto it1 = lst.begin();\
    \ it1 != lst.end(); it1++) {\n        long col = *it1 % x;\n        row = row\
    \ + col + (col >= x);\n    }\n    std::vector<std::tuple<long, long>> result;\n\
    \    for (long col = 0; col < x; col++) {\n        for (long row = 0; row < x;\
    \ row++) {\n            if (row + col < x) {\n                result.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(result.begin(), result.end(),\n\
    \              [](std::tuple<long, long> a, std::tuple<long, long> b)\n      \
    \        { return std::get<0>(a) < std::get<0>(b);}\n    );\n    std::sort(result.begin(),\
    \ result.end(),\n              [](std::tuple<long, long> a, std::tuple<long, long>\
    \ b)\n              { return std::get<1>(a) > std::get<1>(b);}\n    );\n    return\
    \ result;", "    std::vector<std::tuple<long, long>> res;\n    res.reserve(lst.size());\n\
    \    std::vector<long> row;\n    std::vector<std::tuple<long, long>> rows;\n \
    \   rows.reserve(lst.size());\n    for (auto &i : lst) {\n        row.clear();\n\
    \        for (int j = 0; j < i.size(); j++) {\n            row.push_back(i[j]);\n\
    \        }\n        rows.push_back(std::make_tuple(std::distance(row.begin(),\
    \ std::find(row.begin(), row.end(), x)), std::distance(row.begin(), std::find(row.begin(),\
    \ row.end(), x + 1))));\n    }\n    rows.sort();\n    for (auto &i : rows) {\n\
    \        res.push_back(i);\n    }\n    res.sort();\n    return res;", "    //\
    \ write your code here\n    std::vector<std::tuple<long, long>> result;\n    for(auto\
    \ it = lst.begin(); it != lst.end(); ++it) {\n        auto res = std::find(it->begin(),\
    \ it->end(), x);\n        if(res != it->end()) {\n            int row = std::distance(it.begin(),\
    \ res);\n            int column = std::distance(it->begin(), std::find(it->begin(),\
    \ it->end(), x));\n            result.emplace_back(row, column);\n        }\n\
    \    }\n    if(lst.empty())\n        return result;\n    result.sort([](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) -> bool {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    result.sort([](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) -> bool {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n\
    \    return result;", "    if (lst.size() == 0) {\n        return std::vector<std::tuple<long,\
    \ long>>();\n    }\n    // sort the list by first column of each row\n    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<std::vector<long>> temp(std::begin(lst), std::end(lst));\n\
    \    std::sort(\n        temp.begin(),\n        temp.end(),\n        [](std::vector<long>\
    \ a, std::vector<long> b) {\n            return std::get<0>(a) < std::get<0>(b);\n\
    \        });\n    // find x by row with binarysearch\n    long cur = 0;\n    for\
    \ (auto e : temp) {\n        cur = std::lower_bound(std::begin(e), std::end(e),\
    \ x) - std::begin(e);\n        res.push_back(std::make_tuple(cur, std::get<0>(e)));\n\
    \    }\n    // sort rows by columns in reverse order for descending order\n  \
    \  std::sort(\n        res.begin(),\n        res.end(),\n        [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n            return std::get<1>(b) > std::get<1>(a);\n\
    \        });\n    return res;", "    // write your code here\n    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<long> rows;\n    std::vector<long> columns;\n \
    \   for (long i = 0; i < lst.size(); i++) {\n        rows.emplace_back(lst[i][0]);\n\
    \        columns.emplace_back(lst[i][1]);\n    }\n    std::sort(rows.begin(),\
    \ rows.end());\n    std::sort(columns.begin(), columns.end());\n    for (long\
    \ i : rows) {\n        std::sort(columns.begin(), columns.end(), [&](long a, long\
    \ b) {\n            return b < a;\n        });\n        for (long j : columns)\
    \ {\n            if (i == j)\n                continue;\n            if (lst[i][j]\
    \ == x)\n                res.emplace_back(std::make_tuple(i, j));\n        }\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> retval;\n \
    \   // Write your code here\n    auto row_size = lst.size();\n    auto col_size\
    \ = lst[0].size();\n    long i = 0;\n    for (i = 0; i < row_size; i++) {\n  \
    \      auto it = std::find_if(lst[i].begin(), lst[i].end(), [=](auto elem){ return\
    \ elem == x; });\n        if (it != lst[i].end()) {\n            retval.push_back(std::make_tuple(i,\
    \ std::distance(lst[i].begin(), it)));\n        }\n    }\n    retval.sort([](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<0>(a) < std::get<0>(b);\
    \ });\n    for (auto& elem : retval) {\n        retval[std::get<0>(elem)].sort([](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<1>(a) > std::get<1>(b);\
    \ });\n    }\n    return retval;", "  std::vector<std::tuple<long, long>> res;\n\
    \  for (auto &row : lst) {\n    if (std::find(row.begin(), row.end(), x) != row.end())\
    \ {\n      res.push_back(std::make_tuple(std::distance(row.begin(), std::find(row.begin(),\
    \ row.end(), x)), std::find(row.begin(), row.end(), x).second - row.begin() +\
    \ 1));\n    }\n  }\n  std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n    return a.first < b.first;\n\
    \  });\n  std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) {\n    return a.second < b.second;\n  });\n\
    \  return res;", "    // write your code here\n    std::vector<std::tuple<long,\
    \ long>> result;\n    auto it_row = std::find(std::begin(lst), std::end(lst),\
    \ x);\n    if (it_row == std::end(lst))\n        return result;\n    result.emplace_back(std::make_tuple(0,\
    \ it_row - std::begin(lst)));\n    auto it_col = std::find(std::begin(lst[it_row]),\
    \ std::end(lst[it_row]), x);\n    if (it_col == std::end(lst[it_row]))\n     \
    \   return result;\n    for (auto it = std::next(it_row); it != std::end(lst);\
    \ ++it)\n        result.emplace_back(std::make_tuple(std::get<0>(*it) + 1, std::get<1>(*it)\
    \ - it_col - 1));\n    result.sort([](auto a, auto b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    for (auto it = std::next(result.end()); it != std::end(result);\
    \ --it)\n        result.emplace_back(std::make_tuple(std::get<0>(*it) + 1, std::get<1>(*it)));\n\
    \    result.sort([](auto a, auto b) { return std::get<1>(b) > std::get<1>(a);\
    \ });\n    return std::move(result);", "    auto l1 = st.size();\n    std::vector<std::tuple<long,\
    \ long>> res;\n    // sorting rows\n    std::sort(st.begin(), st.end(), [](const\
    \ std::vector<long> &a, const std::vector<long> &b){\n        return a.size()\
    \ > b.size();\n    });\n    for(int i = 0; i< l1; ++i){\n        auto r1 = st[i].size();\n\
    \        if(r1 != 1){\n            // sorting columns\n            std::sort(st[i].begin(),\
    \ st[i].end(), [](const long &a, const long &b){\n                return a > b;\n\
    \            });\n        }\n    }\n    // iterating over rows\n    for(size_t\
    \ i = 0; i< l1; ++i){\n        auto l2 = st[i].size();\n        for(size_t j =\
    \ 0; j< l2; ++j){\n            if(st[i][j] == x){\n                res.push_back({i,\
    \ j});\n            }\n        }\n    }\n    return res;", "    // Write your\
    \ code here\n    std::vector<std::tuple<long, long>> res;\n    if(lst.empty())\n\
    \        return res;\n    int row_len = lst[0].size();\n    assert(row_len ==\
    \ lst.size());\n    std::vector<long> temp_row;\n    long y = 0;\n    for(int\
    \ i = 0; i < row_len; i++) {\n        if(lst[i][0] == x) {\n            res.push_back(std::make_tuple(i,\
    \ y));\n            temp_row.push_back(lst[i][1]);\n        }\n        else if(temp_row.size()\
    \ > 0) {\n            std::sort(temp_row.begin(), temp_row.end(), [](long a, long\
    \ b){return b < a;});\n            res.push_back(std::make_tuple(i, std::accumulate(temp_row.begin(),\
    \ temp_row.end(), 0) - temp_row.back()));\n            temp_row.clear();\n   \
    \     }\n        y++;\n    }\n    if(temp_row.size() > 0)\n        res.push_back(std::make_tuple(row_len,\
    \ std::accumulate(temp_row.begin(), temp_row.end(), 0) - temp_row.back()));\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    std::vector<std::vector<long>>\
    \ tmp = lst;\n    long count = 0;\n    for (long i = 0; i < tmp.size(); ++i) {\n\
    \        long y = 0;\n        for (long j = 0; j < tmp[i].size(); ++j) {\n   \
    \         y += tmp[i][j];\n        }\n        if (y == x)\n        {\n       \
    \     std::tuple<long, long> t;\n            t.first = i;\n            t.second\
    \ = j;\n            res.push_back(t);\n        }\n        ++count;\n    }\n  \
    \  std::sort(res.begin(), res.end(), [](const std::tuple<long, long>& l, const\
    \ std::tuple<long, long>& r)\n    {\n        return (std::get<0>(l) < std::get<0>(r));\n\
    \    });\n    for (long i = 0; i < res.size(); ++i) {\n        res.at(i).second\
    \ = (std::get<1>(res.at(i)) > res.at(i).second) ? std::get<1>(res.at(i)) : res.at(i).second;\n\
    \    }\n    return res;", "    // Your code here\n    // lst.size()\n    // lst.size()\n\
    \    // lst.size()\n    std::vector<std::tuple<long, long>> res;\n    int i =\
    \ 0;\n    for (auto itr = lst.begin(); itr != lst.end(); ++itr) {\n        int\
    \ r = i;\n        for (int j = 0; j < itr->size(); j++) {\n            if (itr->at(j)\
    \ == x) {\n                res.push_back({r, i});\n                break;\n  \
    \          }\n        }\n        i++;\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) { return std::get<0>(a)\
    \ < std::get<0>(b); });\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<1>(a) < std::get<1>(b);\
    \ });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    if\
    \ (lst.empty()) return res;\n    // Sort the row by columns in descending order\n\
    \    std::sort(lst.begin(), lst.end(), [](const std::vector<long>& a, const std::vector<long>&\
    \ b) {\n        return std::tie(a[1], b[1]) > std::tie(b[1], a[1]);\n    });\n\
    \    // Sort the columns by rows in ascending order\n    std::sort(lst.begin(),\
    \ lst.end(), [](const std::vector<long>& a, const std::vector<long>& b) {\n  \
    \      return std::tie(a[0], b[0]) > std::tie(b[0], a[0]);\n    });\n    // Iterate\
    \ through each row of the matrix.\n    for (size_t i = 0; i < lst.size(); i++)\
    \ {\n        std::vector<long> curRow = lst[i];\n        // Iterate through each\
    \ element in the current row.\n        for (size_t j = 0; j < curRow.size(); j++)\
    \ {\n            // Check if element equals to the one we want to find\n     \
    \       if (curRow[j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n                break;\n            }\n        }\n    }\n    return res;",
  "    std::vector<std::tuple<long, long>> res;\n    res.reserve(lst[0].size());\n\
    \    for (auto &arr : lst) {\n        if (std::find(arr.begin(), arr.end(), x)\
    \ != arr.end()) {\n            std::sort(arr.begin(), arr.end(), [](long a, long\
    \ b){return a>b;});\n            std::sort(arr.begin() + arr.size() - 1, arr.end(),\
    \ [](long a, long b){return b<a;});\n            res.push_back( std::make_tuple(arr.size()\
    \ - 1, std::find(arr.begin(), arr.end(), x) - arr.begin()) );\n        }\n   \
    \ }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    std::sort(lst.begin(),\
    \ lst.end(), [](auto a, auto b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n\n    std::vector<std::tuple<long, long>> row;\n    for (auto elem :\
    \ lst) {\n        row.emplace_back(std::make_tuple(std::get<0>(elem), std::get<1>(elem)));\n\
    \    }\n\n    std::sort(row.begin(), row.end(), [](auto a, auto b) {\n       \
    \ return std::get<1>(a) > std::get<1>(b);\n    });\n\n    for (auto elem : row)\
    \ {\n        if (std::get<0>(elem) == x) {\n            res.push_back(elem);\n\
    \        }\n    }\n    return res;", "    assert(lst.size() > 0);\n    std::vector<std::tuple<long,\
    \ long>> ans;\n    ans.reserve(lst.size());\n    for (auto it = lst.begin(); it\
    \ != lst.end(); ++it) {\n        long row = *it;\n        long cols = *std::prev(it);\n\
    \        if (row == x || (row == x + cols && cols == 0)) {\n            ans.emplace_back(row,\
    \ cols);\n        }\n    }\n    std::sort(ans.begin(), ans.end(), [&](const auto&\
    \ lhs, const auto& rhs) {\n        return std::get<0>(lhs) < std::get<0>(rhs);\n\
    \    });\n    std::sort(ans.begin(), ans.end(), [&](const auto& lhs, const auto&\
    \ rhs) {\n        return std::get<1>(lhs) > std::get<1>(rhs);\n    });\n    return\
    \ ans;", "    // Write your code here.\n    // Sort coordinate by rows.\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    for(auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \    }\n    for(auto &row : lst) {\n        for(auto &ele : row) {\n         \
    \   ret.push_back(std::make_tuple(ele, 0));\n        }\n    }\n    std::sort(ret.begin(),\
    \ ret.end(), [](std::tuple<long, long> lhs, std::tuple<long, long> rhs) {\n  \
    \      if(std::get<0>(lhs) < std::get<0>(rhs))\n            return true;\n   \
    \     return false;\n    });\n    // Sort coordinate by columns.\n    std::vector<std::tuple<long,\
    \ long>> ret2;\n    for(auto &row : lst) {\n        std::sort(row.begin(), row.end(),\
    \ std::greater<long>());\n    }\n    for(auto &row : lst) {\n        for(auto\
    \ &ele : row) {\n            ret2.push_back(std::make_tuple(0, ele));\n      \
    \  }\n    }\n    std::sort(ret2.begin(), ret2.end(), [](std::tuple<long, long>\
    \ lhs, std::tuple<long, long> rhs) {\n        if(std::get<0>(lhs) < std::get<0>(rhs))\n\
    \            return true;\n        return false;\n    });\n\n    for(auto &row\
    \ : ret2) {\n        for(auto &ele : row) {\n            if(std::get<0>(ele) ==\
    \ x)\n                ret.push_back(std::make_tuple(std::get<0>(ele), std::get<1>(ele)));\n\
    \        }\n    }\n    return ret;", "    if (lst.size() == 0) {\n        return\
    \ {};\n    }\n    // initialize two vectors (row and col), one is sorted by rows,\
    \ another is sorted by cols\n    std::vector<std::tuple<long, long>> row;\n  \
    \  std::vector<std::tuple<long, long>> col;\n    // row is sorted initially, and\
    \ each element is sorted\n    std::sort(lst.begin(), lst.end(), [](std::vector<long>\
    \ a, std::vector<long> b) {\n        return a[0] < b[0];\n    });\n    // col\
    \ contains first col of each row\n    // each element is sorted initially, and\
    \ each element is sorted\n    std::sort(lst.begin(), lst.end(), [](std::vector<long>\
    \ a, std::vector<long> b) {\n        return a[1] < b[1];\n    });\n    for (long\
    \ i = 0; i < lst.size(); i++) {\n        // check x and lst row equal\n      \
    \  if (lst[i][0] == x) {\n            // initialize tuple\n            std::tuple<long,\
    \ long> tmp;\n            tmp.second = i;\n            // append tmp to row\n\
    \            row.emplace_back(std::move(tmp));\n            // for each col of\
    \ lst row\n            for (long j = 0; j < lst.at(i)[1]; j++) {\n           \
    \     // check lst and row equal\n                if (lst[lst[i][1]][j] == x)\
    \ {\n                    // initialize tuple\n                    std::tuple<long,\
    \ long> tmp;\n                    tmp.second = i;\n                    tmp.first\
    \ = j;\n                    // append tmp to col\n                    col.emplace_back(std::move(tmp));\n\
    \                }\n            }\n        }\n    }\n    // sort rows by cols\
    \ in descending order\n    std::sort(row.begin(), row.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<1>(b) < std::get<1>(a);\n\
    \    });\n    // sort rows by cols in ascending order\n    std::sort(col.begin(),\
    \ col.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n      \
    \  return std::get<1>(a) < std::get<1>(b);\n    });\n    // append (row, col)\
    \ to result vector\n    for (auto r : row) {\n        for (auto c : col) {\n \
    \           if (std::get<0>(r) == std::get<0>(c) && std::get<1>(r) == std::get<1>(c))\
    \ {\n                result.emplace_back(std::move(r));\n                result.emplace_back(std::move(c));\n\
    \                break;\n            }\n        }\n    }\n    return result;",
  "  // Write your code here\n  long ans=0;\n  long row=0;\n  long col=0;\n  for(auto\
    \ i:lst)\n  {\n      for(long j:i)\n      {\n          if(j==x)\n          {\n\
    \              return std::vector<std::tuple<long, long>>(std::make_tuple(row,col));\n\
    \          }\n          else if(j>x)\n          {\n              row++;\n    \
    \          col=0;\n          }\n          col++;\n      }\n      row++;\n  }\n\
    \  return std::vector<std::tuple<long, long>>();", "    // write your code here\n\
    \    long n = lst.size();\n    long m = lst[0].size();\n    std::vector<std::tuple<long,\
    \ long>> res;\n    long i, j;\n    for (i = 0; i < n; i++) {\n        long count\
    \ = 0;\n        for (j = 0; j < m; j++) {\n            if (j != i) {\n       \
    \         long temp = lst[i][j];\n                if (temp == x) {\n         \
    \           count++;\n                }\n            }\n        }\n        if\
    \ (count >= 2) {\n            res.push_back(std::make_tuple(i, count));\n    \
    \    }\n    }\n    sort(res.begin(), res.end(), [](const std::tuple<long, long>&\
    \ a, const std::tuple<long, long>& b) {\n        return std::get<0>(a) > std::get<0>(b);\n\
    \    });\n    long temp_x = -1;\n    std::vector<std::tuple<long, long>> temp_res;\n\
    \    for (long i = 0; i < n; i++) {\n        long count = 0;\n        for (long\
    \ j = 0; j < m; j++) {\n            if (j != i) {\n                long temp =\
    \ lst[i][j];\n                if (temp == x) {\n                    count++;\n\
    \                    if (count > 2) {\n                        temp_x = temp;\n\
    \                        temp_res.clear();\n                        break;\n \
    \                   }\n                }\n            }\n        }\n        if\
    \ (count == 2) {\n            temp_res.push_back(std::make_tuple(i, count));\n\
    \        }\n    }\n    sort(temp_res.begin(), temp_res.end(), [](const std::tuple<long,\
    \ long>& a, const std::tuple<long, long>& b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    std::vector<std::tuple<long, long>> temp_res1\
    \ = get_row(temp_res, x);\n    std::vector<std::tuple<long, long>> temp;\n   \
    \ if (temp_res1.size() == temp_res.size()) {\n        temp.resize(temp_res1.size());\n\
    \        for (long i = 0; i < temp_res1.size(); i++) {\n            temp[i] =\
    \ temp_res1[i];\n        }\n    }\n    else {\n        temp.clear();\n    }\n\
    \    return temp;", "    // write your code here\n    assert(lst.size() > 0);\n\
    \    long rows;\n    long cols;\n    if (lst[0].size() <= x) {\n        rows =\
    \ 1;\n        cols = lst[0].size();\n    } else {\n        rows = std::count(lst.begin(),\
    \ lst.end(), x, [](int n){return n<0;});\n        cols = std::count(lst.begin(),\
    \ lst.end(), x, [](int n){return n<0;}) + 1;\n    }\n    std::vector<std::tuple<long,\
    \ long>> res;\n    for (int i = 0; i < rows; i++) {\n        std::vector<long>\
    \ lst1;\n        lst1.reserve(cols);\n        for (int j = 0; j < cols; ++j) {\n\
    \            if (i == 0 || j == 0) {\n                lst1.push_back(lst[0][j]);\n\
    \            } else {\n                if (lst[i][j] == x) {\n               \
    \     lst1.push_back(lst[i][j]);\n                }\n            }\n        }\n\
    \        res.push_back(std::make_tuple(i, std::count(lst1.begin(), lst1.end(),\
    \ x)));\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long>\
    \ a, std::tuple<long, long> b){return std::get<0>(a) < std::get<0>(b);});\n  \
    \  std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b){return std::get<1>(a) < std::get<1>(b);});\n    return res;", '    //
    Your code here', "  std::vector<std::tuple<long, long>> coordinates;\n  std::tuple<long,\
    \ long> coord;\n  for (size_t i = 0; i < lst.size(); i++) {\n    for (size_t j\
    \ = 0; j < lst[i].size(); j++) {\n      if (x == lst[i][j]) {\n        coord =\
    \ std::make_tuple(i, j);\n        coordinates.push_back(coord);\n      }\n   \
    \ }\n  }\n  std::sort(coordinates.begin(), coordinates.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n    return std::get<0>(a) > std::get<0>(b);\n\
    \  });\n  for (size_t i = 0; i < coordinates.size(); i++) {\n    std::swap(coordinates[i],\
    \ coordinates[coordinates.size() - 1]);\n  }\n  std::vector<std::tuple<long, long>>\
    \ reverseCoordinates;\n  for (size_t i = 0; i < coordinates.size(); i++) {\n \
    \   reverseCoordinates.push_back(std::make_tuple(coordinates[std::get<1>(coordinates[i])],\
    \ std::get<0>(coordinates[i])));\n  }\n  std::sort(reverseCoordinates.begin(),\
    \ reverseCoordinates.end(), [](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) {\n    return std::get<1>(a) > std::get<1>(b);\n  });\n  for (size_t\
    \ i = 0; i < reverseCoordinates.size(); i++) {\n    std::swap(reverseCoordinates[i],\
    \ reverseCoordinates[reverseCoordinates.size() - 1]);\n  }\n  return reverseCoordinates;",
  "  std::vector<std::tuple<long, long>> res;\n  assert(lst.size() == 1 && lst[0].size()\
    \ >= x);\n  res.push_back(std::make_tuple(0, x));\n  auto row = res[res.size()\
    \ - 1];\n  for (int i = 0, j = x - 1; i < lst[0].size() && j < x; ++i) {\n   \
    \ std::swap(row[0], std::get<0>(res[res.size() - 1]));\n    std::swap(row[1],\
    \ std::get<1>(res[res.size() - 1]));\n    res.push_back(std::make_tuple(i, j));\n\
    \  }\n  std::sort(res.begin(), res.end());\n  for (auto& it : res)\n    std::sort(std::get<0>(it),\
    \ std::get<1>(it));\n  return res;", "    // Your code goes here\n    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto const &row:lst)\n    {\n        for(auto const &n:row)\n\
    \        {\n            if(n == x)\n            {\n                res.push_back(std::make_tuple(0,row.size()));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a,\n                                        const std::tuple<long,\
    \ long> &b){\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a,\n                           \
    \             const std::tuple<long, long> &b){\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    if (lst.size() == 0 || x\
    \ == 0) {\n        return std::vector<std::tuple<long, long>>();\n    }\n    std::vector<std::tuple<long,\
    \ long>> retval;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        std::tuple<long,\
    \ long> ret = std::make_tuple(i, 0);\n        retval.push_back(ret);\n       \
    \ for (size_t j = 0; j < lst[i].size(); ++j) {\n            std::tuple<long, long>\
    \ row = std::make_tuple(i, j);\n            std::tuple<long, long> col = std::make_tuple(0,\
    \ j);\n            if (x == lst[i][j]) {\n                retval.push_back(row);\n\
    \                retval.push_back(col);\n            }\n            if (x < lst[i][j])\
    \ {\n                retval.push_back(row);\n            }\n            if (x\
    \ > lst[i][j]) {\n                retval.push_back(col);\n            }\n    \
    \    }\n    }\n    retval.sort([](std::tuple<long, long> a, std::tuple<long, long>\
    \ b) {\n        long va = std::get<0>(a);\n        long vb = std::get<0>(b);\n\
    \        long vc = std::get<1>(a);\n        long vd = std::get<1>(b);\n      \
    \  return (va < vb) ? -1 : ((va > vb) ? 1 : 0);\n    });\n    return retval;",
  "    std::priority_queue<std::tuple<std::pair<long, long>, std::vector<long> > >\
    \ queue;\n    std::vector<std::tuple<std::pair<long, long>, std::vector<long>\
    \ > > ret;\n    std::vector<std::pair<long, long> > point;\n    std::queue<std::pair<long,\
    \ long>> q;\n    for (auto row : lst) {\n        for (auto val : row) {\n    \
    \        if (val == x) {\n                point.push_back(std::make_pair(row,\
    \ val));\n            }\n        }\n    }\n    std::sort(point.begin(), point.end(),\
    \ [](const std::pair<long, long>& p1, const std::pair<long, long>& p2) {\n   \
    \     return p1.first < p2.first;\n    });\n    std::reverse(point.begin(), point.end());\n\
    \    for (auto val : point) {\n        q.emplace(val.first, val.second);\n   \
    \ }\n    while (q.size() > 0) {\n        auto val = q.front();\n        queue.pop();\n\
    \        if (queue.size() == 0) {\n            for (auto val2 : point) {\n   \
    \             ret.emplace_back(std::make_tuple(val.first, val2.second));\n   \
    \         }\n        }\n        std::reverse((queue.front()).second.begin(), (queue.front()).second.end());\n\
    \        for (auto val2 : point) {\n            auto row = (queue.front()).first;\n\
    \            if (row == val2.first) {\n                queue.front().second.insert(val2.second.begin(),\
    \ val2.second.end());\n            }\n        }\n        std::swap(q.front(),\
    \ q.back());\n    }\n    return ret;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    if(lst.size() == 0) {\n        return res;\n    }\n    auto it1 =\
    \ lst.begin();\n    auto it2 = it1;\n    auto it3 = it1;\n    long row, col;\n\
    \    long index = 0;\n    while(it1 != lst.end()) {\n        row = *it1;\n   \
    \     if(row == x) {\n            break;\n        }\n        it3++;\n        if(*it3\
    \ == x) {\n            col = *it2;\n            it2++;\n            if(*it2 ==\
    \ x) {\n                res.push_back(std::make_tuple(index, col));\n        \
    \        it1++;\n                if(it1 == lst.end()) {\n                    break;\n\
    \                }\n                index++;\n                it3 = it1;\n   \
    \             it2 = it1;\n            }\n            else {\n                col\
    \ = *it2;\n                it2++;\n                if(*it2 == x) {\n         \
    \           res.push_back(std::make_tuple(index, col));\n                    it1++;\n\
    \                    if(it1 == lst.end()) {\n                        break;\n\
    \                    }\n                    index++;\n                    it3\
    \ = it1;\n                }\n                else {\n                    col =\
    \ *it2;\n                    it2++;\n                }\n            }\n      \
    \  }\n        else {\n            col = *it2;\n            it2++;\n        }\n\
    \    }\n    return res;", "    // Your code here\n    std::vector<std::tuple<long,\
    \ long>> res;\n    int i, j, k, l;\n    for (i = 0; i < (int)lst.size(); i++)\
    \ {\n        for (j = 0; j < (int)lst[i].size(); j++) {\n            for (k =\
    \ 0; k < (int)lst[i].size(); k++) {\n                for (l = 0; l < (int)lst[i].size();\
    \ l++) {\n                    if (x == lst[i][j][k]) {\n                     \
    \   res.push_back(std::make_tuple(i, j));\n                        res.push_back(std::make_tuple(i,\
    \ k));\n                        res.push_back(std::make_tuple(i, l));\n      \
    \                  res.push_back(std::make_tuple(j, k));\n                   \
    \     res.push_back(std::make_tuple(j, l));\n                        res.push_back(std::make_tuple(k,\
    \ l));\n                        res.push_back(std::make_tuple(l, i));\n      \
    \                  break;\n                    }\n                }\n        \
    \    }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto a, auto\
    \ b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin()\
    \ + res.size() / 2, res.end(), [](auto a, auto b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    // Write your code here\n\
    \    std::vector<std::tuple<long, long>> res;\n    std::sort(lst.begin(), lst.end(),\
    \ [](std::vector<long> a, std::vector<long> b){\n        if(a.size() != b.size()){\n\
    \            return a.size() < b.size();\n        }\n        for(int i = 0; i\
    \ < a.size(); ++i){\n            if(a[i] < b[i]){\n                return true;\n\
    \            }\n            if(a[i] > b[i]){\n                return false;\n\
    \            }\n        }\n        return true;\n    });\n    for(auto i : lst){\n\
    \        std::sort(i.begin(), i.end(), [](long a, long b){\n            return\
    \ b < a;\n        });\n    }\n    for(auto i : lst){\n        for(auto j : i){\n\
    \            if(i.size() == 2 && j == x){\n                res.emplace_back(i\
    \ - 1, j - 1);\n            }\n        }\n    }\n    res.push_back(std::make_tuple(0,\
    \ lst.size() - 1));\n    return res;", "    if (lst.size() == 0) {\n        return\
    \ {};\n    }\n    std::vector<std::tuple<long, long>> res;\n    std::vector<std::tuple<long,\
    \ long>> temp;\n    std::vector<long> temp2;\n    long temp3 = 0;\n    for (auto\
    \ &x : lst) {\n        temp3.clear();\n        temp3 = get_column_max(x, temp3)\
    \ * get_column_max(x, 0) + get_column_min(x, 0);\n        temp.push_back(std::make_tuple(temp3,\
    \ x));\n    }\n    bool sorted = true;\n    while (sorted) {\n        sorted =\
    \ false;\n        for (auto &x : temp) {\n            if (std::get<0>(x) > 0)\
    \ {\n                sorted = true;\n                std::reverse(std::begin(x),\
    \ std::end(x));\n                break;\n            }\n        }\n    }\n   \
    \ temp.erase(std::remove_if(temp.begin(), temp.end(), [](const auto &x){\n   \
    \     return std::get<1>(x) == 0;\n    }), temp.end());\n    long temp4 = 0;\n\
    \    for (auto &x : temp) {\n        temp4 += std::get<0>(x) * std::get<1>(x);\n\
    \    }\n    if (temp4 > 0) {\n        temp.push_back({temp4, 0});\n    }\n   \
    \ for (auto &x : temp) {\n        if (std::get<0>(x) > 0) {\n            std::reverse(std::begin(x),\
    \ std::end(x));\n        }\n    }\n    for (auto &x : temp) {\n        res.push_back(x);\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    if(lst.size()\
    \ == 0)\n        return res;\n    auto itr = lst.begin();\n    long y = 0;\n \
    \   for(; itr != lst.end(); ++itr, ++y) {\n        if(std::find(itr->begin(),\
    \ itr->end(), x) != itr->end()) {\n            long x = itr->begin();\n      \
    \      for(; x != itr->end(); ++x) \n                res.emplace_back(y - 1, *x);\n\
    \            break;\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    // Write your code here\n    assert(lst.size() == 3);\n   \
    \ assert(lst[0].size() == lst[1].size());\n    assert(lst[0].size() == lst[2].size());\n\
    \    for (int i = 0; i < lst[0].size(); i++) {\n        if (lst[0][i] == x)\n\
    \        {\n            for (int j = 0; j < lst[1].size(); j++)\n            {\n\
    \                if (lst[1][j] == x)\n                {\n                    for\
    \ (int k = 0; k < lst[2].size(); k++)\n                    {\n               \
    \         if (lst[2][k] == x)\n                        {\n                   \
    \         res.push_back(std::make_tuple(i, j));\n                            res.push_back(std::make_tuple(k,\
    \ j));\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    return res;", "    // Write your code here\n\
    \    if (lst.empty()) {\n        return std::vector<std::tuple<long, long>>();\n\
    \    }\n    if (lst[0].size() == 0) {\n        return std::vector<std::tuple<long,\
    \ long>>();\n    }\n    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ row: lst) {\n        for (auto v: row) {\n            if (v == x) {\n      \
    \          res.emplace_back(row, row.size() - 1);\n            }\n        }\n\
    \    }\n    std::sort(res.begin(), res.end());\n    for (auto r: res) {\n    \
    \    std::sort(r.begin(), r.end(), [](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) -> bool {\n            return std::get<0>(a) < std::get<0>(b);\n \
    \       });\n    }\n    return res;", "\tassert(lst.size() > 0);\n\tassert(x !=\
    \ 0 && \"Cannot find the element 0\");\n\tstd::vector<std::tuple<long, long>>\
    \ result;\n\tstd::sort(std::begin(lst), std::end(lst), [&](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return std::get<0>(a) < std::get<0>(b);\
    \ });\n\tstd::sort(std::begin(lst), std::end(lst), [&](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return std::get<1>(b) < std::get<1>(a);\
    \ });\n\tstd::unordered_map<long, long> lookup;\n\tlong row = 0;\n\tfor(auto it\
    \ = std::begin(lst); it != std::end(lst); ++it) {\n\t\tfor(auto it2 = std::begin(it);\
    \ it2 != std::end(it); ++it2) {\n\t\t\tif(lookup.count(std::get<0>(it2)) == 0)\
    \ {\n\t\t\t\tlookup[std::get<0>(it2)] = row;\n\t\t\t\tresult.push_back(std::make_tuple(row,\
    \ std::get<1>(it2)));\n\t\t\t}\n\t\t}\n\t\t++row;\n\t}\n\tstd::sort(std::begin(result),\
    \ std::end(result), [&](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) { return std::get<0>(a) > std::get<0>(b); });\n\tstd::sort(std::begin(result),\
    \ std::end(result), [&](const std::tuple<long, long> &a, const std::tuple<long,\
    \ long> &b) { return std::get<1>(b) > std::get<1>(a); });\n\treturn result;",
  "    std::vector<std::tuple<long, long>> result;\n    for(auto &row : lst) {\n \
    \       std::vector<std::tuple<long, long>> rowResult;\n        for(auto &e :\
    \ row) {\n            if(x == e) {\n                rowResult.push_back((row.size(),\
    \ row.size() - 1));\n                break;\n            }\n            if(x ==\
    \ e) {\n                rowResult.push_back((row.size(), row.size() - 1));\n \
    \               break;\n            }\n        }\n        result.push_back(std::make_tuple(rowResult.begin(),\
    \ rowResult.end()));\n    }\n    std::sort(result.begin(), result.end(), [](auto\
    \ &a, auto &b) {\n        return a.first > b.first;\n    });\n    for(auto &x\
    \ : result) {\n        std::sort(x.second, x.second+2);\n    }\n    return result;",
  "    // Your code here\n    int row_size = lst.size();\n    int col_size = lst[0].size();\n\
    \    std::vector<std::tuple<long, long>> res(row_size);\n    for(int i = 0; i\
    \ < row_size; i++) {\n        res[i] = std::make_tuple(i, x);\n    }\n    int\
    \ row, col;\n    for(int i = 0; i < row_size; i++) {\n        row = i;\n     \
    \   col = x;\n        while(col > 0) {\n            res[i].second = res[i].second\
    \ * 10 + col;\n            col--;\n            if((row+1) == row_size) {\n   \
    \             row = 0;\n                col++;\n            } else {\n       \
    \         row++;\n                col--;\n            }\n        }\n    }\n  \
    \  std::sort(res.begin(), res.end());\n    for(int i = 0; i < row_size; i++) {\n\
    \        std::rotate(res.begin()+i, res.begin()+row_size-1, res.end()-1);\n  \
    \      std::rotate(res.begin()+row_size-1, res.begin()+i, res.end()-1);\n    }\n\
    \    return res;", "  // Write your code here\n  int rowsize = lst.size();\n \
    \ assert(rowsize >= 1);\n  assert(rowsize >= 2);\n  for (int r = 0; r < rowsize;\
    \ ++r) {\n    assert(lst[r].size() > 0);\n  }\n  std::sort(lst.begin(), lst.end(),\
    \ [](const auto& l, const auto& r) {\n    return l.size() > r.size();\n  });\n\
    \  long rowlength = lst.back().size();\n  assert(rowlength > 0);\n  std::sort(lst.begin()\
    \ + rowsize, lst.end(), [](const auto& l, const auto& r) {\n    return r.size()\
    \ > l.size();\n  });\n  std::vector<std::tuple<long, long>> ret;\n  for (int r\
    \ = 0; r < rowsize; ++r) {\n    ret.resize((r + 1) * rowlength);\n    int columncount\
    \ = 0;\n    for (int c = 0; c < rowlength; ++c) {\n      long left = lst[r].begin()\
    \ + c;\n      long right = lst[r].begin() + c + 1;\n      ret[c] = std::make_tuple(r,\
    \ c);\n      while (left < lst.back().end()) {\n        long mid = (left + right)\
    \ / 2;\n        if (*mid <= x && *mid != *left) {\n          left = mid;\n   \
    \     } else {\n          right = mid;\n        }\n      }\n      while (right\
    \ > lst[r].begin()) {\n        long mid = (left + right) / 2;\n        if (*right\
    \ <= x && *right != *right) {\n          right = mid;\n        } else {\n    \
    \      left = mid;\n        }\n      }\n    }\n    std::sort(ret.begin(), ret.end(),\
    \ [](const auto& l, const auto& r) {\n      return std::get<1>(l) < std::get<1>(r);\n\
    \    });\n  }\n  return ret;", "    std::vector<std::tuple<long, long>> result;\n\
    \    assert(lst.size() == 0 || lst[0].size() == x);\n    if (lst.size() == 0)\n\
    \        return result;\n    std::vector<long> temp;\n    for (auto it = lst.begin();\
    \ it != lst.end(); ++it) {\n        auto it = std::find(*it, x, std::greater<long>());\n\
    \        if (it != lst.end()) {\n            auto temp = *it;\n            for\
    \ (int i = 0; i != x; ++i)\n                temp.push_back(0);\n            result.push_back(std::make_tuple(0,\
    \ temp));\n        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    for (auto it = result.rbegin(); it != result.rend(); ++it) {\n \
    \       std::tuple<long, long> temp = std::get<1>(*it);\n        std::vector<long>\
    \ temp2 = temp;\n        temp2.erase(std::remove(temp2.begin(), temp2.end(), 0),\
    \ temp2.end());\n        auto it = std::find(temp2.begin(), temp2.end(), x);\n\
    \        if (it != temp2.end()) {\n            std::get<0>(*it) = (std::get<0>(*it)\
    \ + temp2.size() - 1) / temp2.size();\n            std::get<1>(*it) = it - result.begin();\n\
    \        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return result;", "    // Write your code here\n    std::vector<std::tuple<long,\
    \ long>> res;\n    std::sort(lst.begin(), lst.end(), [](std::vector<long> &v1,\
    \ std::vector<long> &v2){\n        if(v1[0] > v2[0])\n            return true;\n\
    \        else\n            return false;\n    });\n    for(auto row : lst)\n \
    \   {\n        std::sort(row.begin(), row.end(), [](long &v1, long &v2){\n   \
    \         if(v1 > v2)\n                return true;\n            else\n      \
    \          return false;\n        });\n    }\n    for(auto row : lst)\n    {\n\
    \        std::reverse(row.begin(), row.end());\n        for(auto v : row)\n  \
    \      {\n            if(!std::find(lst.begin(), lst.end(), v) != lst.end())\n\
    \                continue;\n            else\n            {\n                res.emplace_back(std::make_tuple(row\
    \ - lst.begin(), v - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> &t1, std::tuple<long, long> &t2){\n   \
    \     if(std::get<0>(t1) > std::get<0>(t2))\n            return true;\n      \
    \  else\n            return false;\n    });\n    for(auto t : res)\n    {\n  \
    \      if(std::get<0>(t) != std::get<0>(res.back()))\n        {\n            res.push_back(t);\n\
    \        }\n    }\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    auto it = std::find_if(lst.begin(), lst.end(), [&x](const std::vector<long>\
    \ &v) {\n        return std::equal(v.begin(), v.end(), x);\n    });\n    if (it\
    \ != lst.end()) {\n        for (long i = 0; i < it->size(); i++) {\n         \
    \   for (long j = i; j < it->size(); j++) {\n                if (it->at(i) !=\
    \ it->at(j))\n                    break;\n                res.emplace_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n        auto it2 = std::find_if(res.rbegin(),\
    \ res.rend(), [&x](const std::tuple<long, long> &v) {\n            return std::get<0>(v)\
    \ < x;\n        });\n        auto it3 = std::find_if(res.rbegin(), res.rend(),\
    \ [&x](const std::tuple<long, long> &v) {\n            return std::get<1>(v) <\
    \ x;\n        });\n        while (it2 != res.rend() && it3 != res.rend()) {\n\
    \            if (std::get<0>(it2) < std::get<0>(it3))\n                it2 = res.erase(it2);\n\
    \            else\n                it3 = res.erase(it3);\n        }\n    }\n \
    \   return res;", "    // Your code here\n    std::vector<std::tuple<long, long>>\
    \ res;\n    auto it = std::find_if(lst.begin(), lst.end(),\n                 \
    \          [&x](const std::tuple<long, long>& elem) { return get<0>(elem) == x;\
    \ });\n    if (it == lst.end()) {\n        return res;\n    }\n\n    auto row\
    \ = it->second;\n    auto col_it = std::find_if(row.begin(), row.end(),\n    \
    \                           [&x](const std::tuple<long, long>& elem) { return\
    \ get<1>(elem) == x; });\n    if (col_it == row.end()) {\n        return res;\n\
    \    }\n\n    auto col = col_it->second;\n    for (long i = 0; i < (long)col.size();\
    \ ++i) {\n        for (long j = (long)row.size(); j > i; --j) {\n            std::swap(col[j],\
    \ col[j - 1]);\n        }\n        res.emplace_back(get<0>(row[i - 1]), get<1>(col[i\
    \ - 1]));\n        std::swap(row[i], row[i-1]);\n        std::swap(col[i], col[i-1]);\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    res.reserve(lst[0].size());\n\
    \    long min_row = 0, max_row = 0, min_col = 0, max_col = 0;\n    for (long i\
    \ = 0; i < lst[0].size(); ++i) {\n        if (lst[0][i] < x) continue;\n     \
    \   if (lst[0][i] > x) break;\n        long cur_row = i;\n        long cur_col\
    \ = x - lst[0][i];\n        long cur_row_inv = cur_row * x;\n        long cur_col_inv\
    \ = cur_col * x;\n        if (max_row < cur_row) max_row = cur_row;\n        if\
    \ (min_row > cur_row) min_row = cur_row;\n        if (max_col < cur_col) max_col\
    \ = cur_col;\n        if (min_col > cur_col) min_col = cur_col;\n        if (cur_row_inv\
    \ < cur_row) cur_row = cur_row_inv;\n        if (cur_col_inv < cur_col) cur_col\
    \ = cur_col_inv;\n        res.emplace_back(std::make_tuple(cur_row, cur_col));\n\
    \    }\n    if (max_row > min_row) {\n        std::vector<std::tuple<long, long>>\
    \ res2;\n        res2.reserve(max_row - min_row + 1);\n        for (long i = 0;\
    \ i <= max_row - min_row + 1; ++i) {\n            res2.emplace_back(std::make_tuple(min_row\
    \ + i, min_col));\n        }\n        res.insert(res.end(), res2.begin(), res2.end());\n\
    \    }\n    if (max_col > min_col) {\n        std::vector<std::tuple<long, long>>\
    \ res3;\n        res3.reserve(max_col - min_col + 1);\n        for (long i = 0;\
    \ i <= max_col - min_col + 1; ++i) {\n            res3.emplace_back(std::make_tuple(min_row,\
    \ min_col + i));\n        }\n        res.insert(res.end(), res3.begin(), res3.end());\n\
    \    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        if (a.first < b.first) return true;\n        if (a.first\
    \ > b.first) return false;\n        if (a.second < b.second) return true;\n  \
    \      if (a.second > b.second) return false;\n        return 0;\n    });\n  \
    \  return res;", "    if(lst.size() == 0)\n        return {};\n    if(lst[0].size()\
    \ == 0)\n        return {};\n    std::vector<std::tuple<long, long>> res;\n  \
    \  for(int r = 0; r < lst.size(); r++) {\n        for(auto it = std::next(lst.begin(),\
    \ r), end = std::next(lst.begin(), r + 1); it != end; it++) {\n            auto\
    \ value = *it;\n            if((value % x) == 0) {\n                res.push_back({r\
    \ + 1, it - lst.begin() + 1});\n                res.push_back({r + 1, it - lst.begin()\
    \ + 2});\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        if(a.f0 <\
    \ b.f0)\n            return true;\n        if(a.f0 > b.f0)\n            return\
    \ false;\n        if(a.f1 < b.f1)\n            return true;\n        if(a.f1 >\
    \ b.f1)\n            return false;\n        return a.get<1>() < b.get<1>();\n\
    \    });\n    return res;", "    // Your code here\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    std::sort(lst.begin(), lst.end(), [](std::vector<long> a, std::vector<long>\
    \ b){\n        return a.size() == b.size() ? std::make_tuple(a.front(), a.back())\
    \ < std::make_tuple(b.front(), b.back()) : std::make_tuple(a.front(), a.back())\
    \ > std::make_tuple(b.front(), b.back());\n    });\n    for (std::vector<long>\
    \ row: lst) {\n        std::sort(row.begin(), row.end(), [](long a, long b){\n\
    \            return b < a;\n        });\n        long row_size = row.size();\n\
    \        long cols = std::min_element(row.begin(), row.end()) - row.begin();\n\
    \        if (row_size == cols && std::find(row.begin(), row.end(), x) != row.end())\
    \ {\n            ret.push_back(std::make_tuple(std::distance(row.begin(), std::find(row.begin(),\
    \ row.end(), x)), std::distance(row.begin(), row.end())));\n        }\n    }\n\
    \    std::vector<std::tuple<long, long>> sorted_ret;\n    for (auto tup : ret)\
    \ {\n        sorted_ret.push_back(tup);\n    }\n    std::sort(sorted_ret.begin(),\
    \ sorted_ret.end(), [](std::tuple<long, long> a, std::tuple<long, long> b){\n\
    \        return std::get<0>(a) < std::get<0>(b);\n    });\n    return sorted_ret;",
  "    std::vector<std::tuple<long, long>> result;\n    bool flag = false;\n    for\
    \ (auto row: lst) {\n        flag = false;\n        for (auto val: row) {\n  \
    \          if (val == x) {\n                flag = true;\n                break;\n\
    \            }\n        }\n        if (!flag) {\n            result.emplace_back(std::make_tuple(x,\
    \ 0));\n        }\n    }\n    std::sort(result.begin(), result.end(), [](std::tuple<long,\
    \ long> x, std::tuple<long, long> y) {\n        return std::get<0>(x) < std::get<0>(y);\n\
    \    });\n    for (auto row: result) {\n        std::sort(std::get<1>(row).rbegin(),\
    \ std::get<1>(row).rend(), [](long x, long y) {\n            return x > y;\n \
    \       });\n    }\n    return result;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    // Write your code here\n    return res;", "    int rows = lst.size();\n\
    \    int cols = lst[0].size();\n    std::vector<std::tuple<long, long>> result;\n\
    \    // TODO: your solution here", '    // Your code here', "    if (lst.empty())\n\
    \        return {};\n    std::vector<std::tuple<long, long>> res;\n    std::vector<long>\
    \ r;\n    r.reserve(lst.size());\n    for (auto i : lst)\n        r.push_back(i.size());\n\
    \    std::sort(r.begin(), r.end());\n    // sort rows by columns in descending\
    \ order\n    for (auto i : r) {\n        std::sort(i.rbegin(), i.rend());\n  \
    \      res.emplace_back(std::get<0>(i), std::get<1>(i));\n    }\n    // sort columns\
    \ by rows in ascending order\n    // std::sort returns void\n    std::sort(res.begin(),\
    \ res.end());\n    long i = std::find(r.begin(), r.end(), x) - r.begin();\n  \
    \  res.emplace_back(i, x);\n    return res;", "    if(lst.size() == 0)\n     \
    \   return std::vector<std::tuple<long, long>>();\n    std::vector<std::tuple<long,\
    \ long>> ret;\n    std::vector<long> xs(lst.size(), x);\n    std::sort(xs.begin(),\
    \ xs.end());\n    std::sort(lst.begin(), lst.end(), [&](std::vector<long> const&\
    \ a, std::vector<long> const& b) {\n        return std::make_tuple(std::get<0>(a),\
    \ std::get<1>(a)) < std::make_tuple(std::get<0>(b), std::get<1>(b));\n    });\n\
    \n    for(long i = 0; i < lst.size(); i++) {\n        ret.emplace_back(std::make_tuple(i,\
    \ std::count(lst.begin() + i, lst.begin() + i + 1, xs[i])));\n    }\n    std::sort(ret.begin(),\
    \ ret.end(), [](std::tuple<long, long> const& t1, std::tuple<long, long> const&\
    \ t2) {\n        return std::get<0>(t1) < std::get<0>(t2);\n    });\n    for(long\
    \ i = 0; i < ret.size(); i++) {\n        ret[i] = std::make_tuple(ret[i][0], std::get<1>(ret[i])-1);\n\
    \    }\n    return ret;", "  if (lst.size() == 0) {\n    return {};\n  }\n  std::vector<std::vector<long>>\
    \ sorted_row = lst;\n  std::sort(sorted_row.begin(), sorted_row.end(), [](std::vector<long>&\
    \ a, std::vector<long>& b) {\n    return a.size() < b.size();\n  });\n\n  // Sort\
    \ the row by the second column in descending order\n  std::sort(sorted_row.begin(),\
    \ sorted_row.end(), [](std::vector<long>& a, std::vector<long>& b) {\n    return\
    \ a[1] < b[1];\n  });\n\n  // Sort the row by the first column in ascending order\n\
    \  std::sort(sorted_row.begin(), sorted_row.end(), [](std::vector<long>& a, std::vector<long>&\
    \ b) {\n    return a[0] < b[0];\n  });\n\n  auto row_index = 0;\n  auto col_index\
    \ = 1;\n  std::vector<std::tuple<long, long>> results;\n  while (sorted_row[row_index].size()\
    \ > 0) {\n    results.emplace_back(std::make_tuple(row_index, col_index));\n \
    \   long row_x = sorted_row[row_index][0]; // the coordinate of x-th column\n\
    \    col_index--;\n    row_index++;\n    while (sorted_row[row_index].size() >\
    \ 0 && sorted_row[row_index][0] < row_x) {\n      row_x = sorted_row[row_index][0];\
    \ // the coordinate of x-th column\n      col_index++;\n      row_index++;\n \
    \   }\n  }\n\n  return results;", "    // Write your code here\n    \n    std::vector<std::tuple<long,\
    \ long>> res;\n    for(long i = 0; i < lst.size(); i++){\n        std::vector<long>\
    \ cols = lst[i];\n        for(long j = 0; j < cols.size(); j++){\n           \
    \ if(cols[j] == x){\n                res.push_back(std::make_tuple(i, j));\n \
    \               break;\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long>& lhs, const std::tuple<long, long>&\
    \ rhs){\n        return std::get<0>(lhs) < std::get<0>(rhs) || (std::get<0>(lhs)\
    \ == std::get<0>(rhs) && (std::get<1>(lhs) > std::get<1>(rhs)));\n    });\n  \
    \  std::sort(res.begin(), res.end(), [](const std::tuple<long, long>& lhs, const\
    \ std::tuple<long, long>& rhs){\n        return std::get<1>(lhs) < std::get<1>(rhs)\
    \ || (std::get<1>(lhs) == std::get<1>(rhs) && (std::get<0>(lhs) > std::get<0>(rhs)));\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> ret;\n  \
    \  if(lst.empty()){\n        return ret;\n    }\n    if(lst[0].empty()){\n   \
    \     ret.push_back(std::make_tuple(0, 0));\n        return ret;\n    }\n    long\
    \ min_col = 0;\n    long max_col = lst[0].size() - 1;\n    while(max_col >= min_col){\n\
    \        long min_row = min_col;\n        long max_row = max_col;\n        if(min_row\
    \ + 1 < max_row){\n            auto first_row = lst.at(min_row);\n           \
    \ auto second_row = lst.at(max_row);\n            for(long i = 0; i <= second_row.size();\
    \ i++){\n                if(second_row[i] == x){\n                    for(long\
    \ j = min_col; j <= max_col; j++){\n                        auto new_coord = std::make_tuple(min_row,\
    \ j);\n                        if(ret.find(new_coord) == ret.end()){\n       \
    \                     ret.insert(new_coord);\n                        }\n    \
    \                }\n                }\n            }\n        }\n        else\
    \ if(min_row > max_row){\n            auto first_row = lst.at(max_row);\n    \
    \        for(long i = 0; i <= first_row.size(); i++){\n                if(first_row[i]\
    \ == x){\n                    for(long j = min_col; j <= max_col; j++){\n    \
    \                    auto new_coord = std::make_tuple(max_row, j);\n         \
    \               if(ret.find(new_coord) == ret.end()){\n                      \
    \      ret.insert(new_coord);\n                        }\n                   \
    \ }\n                }\n            }\n        }\n        min_col++;\n       \
    \ max_col--;\n    }\n    return ret;", "    std::vector<std::tuple<long, long>>\
    \ result;\n    \n    if (lst.size() == 0) return result;\n    \n    // initialize\
    \ min and max of first column\n    long min_col = std::numeric_limits<long>::max();\n\
    \    long max_col = std::numeric_limits<long>::min();\n    for (auto row : lst)\
    \ {\n        if (row.size() > 0)\n            min_col = std::min(min_col, row[0]);\n\
    \            max_col = std::max(max_col, row[0]);\n    }\n    \n    // initialize\
    \ mins and maxes of each row\n    std::vector<long> min_row;\n    std::vector<long>\
    \ max_row;\n    for (auto row : lst) {\n        min_row.push_back(std::numeric_limits<long>::max());\n\
    \        max_row.push_back(std::numeric_limits<long>::min());\n        for (auto\
    \ x : row) {\n            min_row.push_back(std::min(min_row[x], x));\n      \
    \      max_row.push_back(std::max(max_row[x], x));\n        }\n    }\n    \n \
    \   // initialize mins and maxes of columns of each row\n    std::vector<std::vector<long>>\
    \ min_col;\n    std::vector<std::vector<long>> max_col;\n    for (auto row : lst)\
    \ {\n        min_col.push_back(std::vector<long>(max_row.size()));\n        max_col.push_back(std::vector<long>(min_row.size()));\n\
    \        for (auto x : row) {\n            min_col.back()[max_row.size() - 1 -\
    \ x].push_back(x);\n            max_col.back()[min_row.size() - 1 - x].push_back(x);\n\
    \        }\n    }\n    \n    // initialize min and max of x in row\n    long min_row\
    \ = std::numeric_limits<long>::max();\n    long max_row = std::numeric_limits<long>::min();\n\
    \    for (auto row : lst) {\n        if (row.size() > 0)\n            min_row\
    \ = std::min(min_row, row[0]);\n            max_row = std::max(max_row, row[0]);\n\
    \    }\n    \n    // initialize mins and maxes of columns of x\n    std::vector<long>\
    \ min_rowx;\n    std::vector<long> max_rowx;\n    for (auto row : lst) {\n   \
    \     min_rowx.push_back(std::numeric_limits<long>::max());\n        max_rowx.push_back(std::numeric_limits<long>::min());\n\
    \        for (auto x : row) {\n            min_rowx.push_back(std::min(min_rowx[x],\
    \ x));\n            max_rowx.push_back(std::max(max_rowx[x], x));\n        }\n\
    \    }\n    \n    // initialize mins and maxes of columns of y\n    std::vector<std::vector<long>>\
    \ min_colx;\n    std::vector<std::vector<long>> max_colx;\n    for (auto row :\
    \ lst) {\n        min_colx.push_back(std::vector<long>(max_rowx.size()));\n  \
    \      max_colx.push_back(std::vector<long>(min_", "    long y = x;\n    std::vector<std::tuple<long,\
    \ long>> ans;\n    std::vector<std::tuple<long, long>> result;\n    for (auto\
    \ &row : lst) {\n        if (x == row[0]) {\n            ans.push_back({y, std::tuple<long,\
    \ long>(row[0], std::tuple<long, long>(row[1], row[2]))});\n        } else {\n\
    \            result.push_back({y, std::tuple<long, long>(x, y)});\n          \
    \  y = row[0];\n            ans.push_back({y, std::tuple<long, long>(row[0], std::tuple<long,\
    \ long>(row[1], row[2]))});\n        }\n    }\n    std::sort(ans.begin(), ans.end());\n\
    \    std::sort(result.begin(), result.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) { return a.first < b.first; });\n    for (auto &ans : ans) {\n    \
    \    std::reverse(ans.second, ans.second);\n    }\n    for (auto &ans : result)\
    \ {\n        std::reverse(ans.second, ans.second);\n    }\n    return ans;", " \
    \   std::vector<std::tuple<long, long>> res;\n    // Your code goes here\n   \
    \ for(auto &row: lst) {\n        for(auto &column: row) {\n            if(x ==\
    \ column) {\n                res.push_back(std::make_tuple(row.size(), column.size()));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) -> bool {\n    \
    \    return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) -> bool {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n  \
    \  return res;", "    std::vector<std::tuple<long, long>> res;\n    // Your code\
    \ here\n    for(auto i:lst){\n        for(auto j:i){\n            if(j==x)\n \
    \               res.push_back(std::make_tuple(i, j));\n        }\n    }\n    res.sort();\n\
    \    std::sort(res.begin(), res.end(),\n              [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) -> bool {\n                  return\
    \ std::get<0>(a) < std::get<0>(b);\n              });\n    std::reverse(res.begin(),\
    \ res.end());\n    return res;", "  if(lst.empty())\n    return {};\n  // sort\
    \ coordinates initially by rows in ascending order\n  std::vector<std::pair<long,\
    \ long>> coordinates;\n  for(auto i = 0; i < lst.size(); ++i)\n    coordinates.push_back(std::make_pair(i,\
    \ 0));\n  std::sort(coordinates.begin(), coordinates.end(), [](const std::pair<long,\
    \ long>& a, const std::pair<long, long>& b) {\n    return a.first < b.first;\n\
    \  });\n  std::vector<std::tuple<long, long>> res(coordinates.size());\n  // iterate\
    \ through coordinates, sorting them by rows in descending order\n  for(auto i\
    \ = 0; i < coordinates.size(); ++i) {\n    auto row = coordinates[i].first;\n\
    \    std::sort(coordinates.begin() + row, coordinates.begin() + row + 1, [](const\
    \ std::pair<long, long>& a, const std::pair<long, long>& b) {\n      return a.second\
    \ > b.second;\n    });\n    res[row - coordinates.begin()] = std::make_tuple(coordinates[i].second,\
    \ row);\n  }\n  // iterate through rows to find x\n  std::vector<std::tuple<long,\
    \ long>> row;\n  for(auto i = 0; i < res.size(); ++i) {\n    long row = res[i].second;\n\
    \    if(row == x)\n      row.push_back(i);\n  }\n  return row;", "    std::vector<std::tuple<long,\
    \ long>> result;\n    for (auto itr : lst) {\n        result.push_back(std::make_tuple(itr.begin(),\
    \ itr.end()));\n    }\n\n    for (auto itr : result) {\n        for (auto c :\
    \ itr) {\n            if (c == x) {\n                std::cout << \"Found \" <<\
    \ x << \"\\n\";\n                return result;\n            }\n        }\n  \
    \  }\n\n    std::cout << \"not found\\n\";\n    return result;", "    // Write\
    \ your code here.\n    std::sort(lst.begin(), lst.end());\n    std::sort(lst.begin(),\
    \ lst.end(), [&x](const std::vector<long> &a, const std::vector<long> &b) {\n\
    \        return *std::max_element(a.begin(), a.end()) < *std::max_element(b.begin(),\
    \ b.end()); });\n    std::vector<std::tuple<long, long>> res;\n    res.reserve(lst[0].size());\n\
    \    for (auto &row : lst) {\n        std::vector<std::tuple<long, long>> lst2;\n\
    \        lst2.reserve(row.size());\n        for (auto &el : row) {\n         \
    \   if (std::find(lst.begin(), lst.end(), el) == lst.end()) {\n              \
    \  lst2.push_back(std::make_tuple(std::numeric_limits<long>::max(), std::numeric_limits<long>::max()));\n\
    \            }\n            else {\n                long y1 = std::distance(std::begin(lst),\
    \ std::find(lst.begin(), lst.end(), el));\n                long y2 = std::distance(std::begin(lst),\
    \ std::find(lst.begin(), lst.end(), el) - 1);\n                long x1 = std::distance(std::begin(lst)\
    \ - 1, std::find(lst.begin(), lst.end(), el));\n                long x2 = std::distance(std::begin(lst)\
    \ - 1, std::find(lst.begin(), lst.end(), el) - 1);\n                lst2.push_back(std::make_tuple(x1,\
    \ y1));\n                lst2.push_back(std::make_tuple(x2, y2));\n          \
    \  }\n        }\n        res.push_back(std::make_tuple(std::distance(std::begin(lst),\
    \ std::max_element(lst.begin(), lst.end())),\n                               \
    \     std::distance(std::begin(lst), std::min_element(lst.begin(), lst.end()))));\n\
    \        res.push_back(std::make_tuple(std::distance(std::begin(lst), std::max_element(lst.begin(),\
    \ lst.end())),\n                                    std::distance(std::begin(lst),\
    \ std::min_element(lst.begin(), lst.end()))));\n    }\n    std::sort(res.begin(),\
    \ res.end(), [&](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    return\
    \ res;", "    if (lst.size() < 1) return std::vector<std::tuple<long, long>>();\n\
    \    std::vector<std::tuple<long, long>> res;\n    long row = 0;\n    long col\
    \ = 0;\n    while (row < lst.size()) {\n        long sum = 0;\n        long last_row\
    \ = row;\n        std::vector<long> columns;\n        while (col < lst[row].size())\
    \ {\n            sum += lst[row][col];\n            if (sum == x) break;\n   \
    \         columns.push_back(lst[row][col]);\n            last_row = row;\n   \
    \         col++;\n        }\n        if (col == lst[row].size()) row++;\n    \
    \    res.emplace_back(std::make_tuple(last_row, columns.size()));\n        row\
    \ = row + 1;\n    }\n    std::sort(res.begin(), res.end(), [](auto a, auto b)\
    \ { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(), res.end(),\
    \ [](auto a, auto b) { return std::get<1>(a) < std::get<1>(b); });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    std::vector<std::vector<long>>\
    \ mat(lst[0].size(), std::vector<long>());\n    for (size_t i = 0; i < mat.size()\
    \ - 1; ++i) {\n        for (size_t j = i + 1; j < mat.size(); ++j) {\n       \
    \     if (mat[i][j] == x) {\n                for (size_t k = 0; k < mat.size()\
    \ - i; ++k) {\n                    if (mat[k][j] < mat[k + 1][j])\n          \
    \              std::swap(mat[k][j], mat[k + 1][j]);\n                    std::swap(mat[k\
    \ + 1][j], mat[k][j]);\n                }\n                res.emplace_back(i,\
    \ j);\n                for (size_t k = 0; k < mat.size() - i; ++k) {\n       \
    \             for (size_t l = 0; l < mat[k + 1].size(); ++l)\n               \
    \         mat[k][l] = mat[k + 1][l];\n                }\n                mat[i][j]\
    \ = mat[i + 1][j];\n                mat[i + 1][j] = x;\n            }\n      \
    \  }\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a,\
    \ std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    auto helper = [&lst,\
    \ &res](int i, int j) {\n        auto it = lst.begin();\n        for (int k =\
    \ i; k < lst.size(); ++k) {\n            it++;\n            if (std::find(it,\
    \ (it + 1), x) != lst.end()) {\n                auto temp = (*it).begin();\n \
    \               for (int l = j; l < it->size(); ++l) {\n                    temp++;\n\
    \                    if (*temp == x) {\n                        res.push_back(std::make_tuple(i,\
    \ j));\n                        break;\n                    }\n              \
    \  }\n            }\n        }\n    };\n    for (int i = 0; i < lst.size(); ++i)\
    \ {\n        helper(i, 0);\n        helper(i, lst.size() - 1);\n    }\n    std::sort(res.begin(),\
    \ res.end());\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::vector<std::tuple<long, long>> result;\n\
    \    for (auto &tup : res) {\n        result.push_back(tup);\n    }\n    return\
    \ result;", "    std::vector<std::tuple<long, long>> out;\n    std::vector<long>\
    \ row;\n    // Get row of lst that contains x.\n    for (auto i : lst) {\n   \
    \     if (std::find(i.begin(), i.end(), x) != i.end()) row.push_back(i);\n   \
    \ }\n    assert(row.size() > 0 && \"No row of lst contains x.\");\n    long max_row\
    \ = row.size() - 1;\n    // Get row of lst, starting from max_row.\n    for (long\
    \ row = max_row; row >= 0; row--) {\n        out.push_back(std::make_tuple(row,\
    \ row[row - 1]));\n    }\n    // Sort coordinates initially by rows in ascending\
    \ order.\n    std::sort(out.begin(), out.end(), [](std::tuple<long, long> const\
    \ &x, std::tuple<long, long> const &y){\n        return std::get<0>(x) < std::get<0>(y);\n\
    \    });\n    // Sort coordinates of the row by columns in descending order.\n\
    \    std::sort(out.begin(), out.end(), [](std::tuple<long, long> const &x, std::tuple<long,\
    \ long> const &y){\n        return std::get<1>(x) < std::get<1>(y);\n    });\n\
    \    return out;"]
stop_tokens:
- "\n}"
