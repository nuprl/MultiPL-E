name: HumanEval_58_common
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return sorted unique common\
  \ elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
  \ 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\n\
  std::vector<long> common(std::vector<long> l1, std::vector<long> l2) {\n"
tests: "}\nint main() {\n    auto candidate = common;\n    assert(candidate((std::vector<long>({1,\
  \ 4, 3, 34, 653, 2, 5})), (std::vector<long>({5, 7, 1, 5, 9, 653, 121}))) == (std::vector<long>({1,\
  \ 5, 653})));\n    assert(candidate((std::vector<long>({5, 3, 2, 8})), (std::vector<long>({3,\
  \ 2}))) == (std::vector<long>({2, 3})));\n    assert(candidate((std::vector<long>({4,\
  \ 3, 2, 8})), (std::vector<long>({3, 2, 4}))) == (std::vector<long>({2, 3, 4})));\n\
  \    assert(candidate((std::vector<long>({4, 3, 2, 8})), (std::vector<long>()))\
  \ == (std::vector<long>()));\n}\n"
completions: ["    // Sorting lists for binary search and find common elements.\n\
    \    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    \n    auto it = std::set_intersection(l1.begin(), l1.end(),\n           \
    \                         l2.begin(), l2.end(),\n                            \
    \        std::back_inserter(common));\n    \n    // Avoid duplicate elements.\n\
    \    l1.erase(std::unique(l1.begin(), l1.end()), l1.end());\n    l2.erase(std::unique(l2.begin(),\
    \ l2.end()), l2.end());\n    \n    return common;", "    std::vector<long> result;\n\
    \    std::set_union(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n\
    \    return std::move(result);", "    std::vector<long> res;\n    std::set<long>\
    \ s1;\n    std::set<long> s2;\n    std::vector<long> temp;\n    // O(n*logn) time\
    \ and O(n) space\n    for (long i : l1) {\n        s1.insert(i);\n    }\n    for\
    \ (long i : l2) {\n        s2.insert(i);\n    }\n    std::set_intersection(s1.begin(),\
    \ s1.end(), s2.begin(), s2.end(), back_inserter(temp));\n    // O(n) time and\
    \ O(1) space\n    for (long i : temp) {\n        res.push_back(i);\n    }\n  \
    \  return res;", "  std::vector<long> common;\n  std::vector<long>::iterator iter,\
    \ l1i, l2i, it;\n  // Iterate over both lists.\n  for (iter=l1.begin(); iter!=l1.end();\
    \ ++iter) {\n    for (l2i=l2.begin(); l2i!=l2.end(); ++l2i) {\n      it = (*iter\
    \ == *l2i);\n      if (it) break;\n    }\n    if (it == l2.end()) common.push_back(*iter);\n\
    \  }\n  // Iterate over l2 again and compare with l1.\n  for (iter=l2.begin();\
    \ iter!=l2.end(); ++iter) {\n    for (l1i=l1.begin(); l1i!=l1.end(); ++l1i) {\n\
    \      it = (*iter == *l1i);\n      if (it) break;\n    }\n    if (it == l1.end())\
    \ common.push_back(*iter);\n  }\n  return common;", "  std::sort(l1.begin(), l1.end());\n\
    \  std::sort(l2.begin(), l2.end());\n  std::vector<long> v;\n  for (long i = 0;\
    \ i < std::min(l1.size(), l2.size()); i++) {\n    if (l1[i] == l2[i]) {\n    \
    \  v.push_back(l1[i]);\n    }\n  }\n  return v;", "    if (l1.size() < l2.size())\
    \ {\n        auto it = std::find_if(l1.begin(), l1.end(), [&l2](long x) { return\
    \ l2.find(x) != l2.end(); });\n        l2.erase(it);\n    }\n    if (l2.size()\
    \ < l1.size()) {\n        auto it = std::find_if(l2.begin(), l2.end(), [&l1](long\
    \ x) { return l1.find(x) != l1.end(); });\n        l1.erase(it);\n    }\n    std::vector<long>\
    \ common(l1);\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(common));\n    return common;", "  long result = 0;\n  for\
    \ (int i = 0; i != l1.size() && i != l2.size(); i++) {\n    if (l1.at(i) == l2.at(i))\
    \ {\n      result = l1.at(i);\n    }\n  }\n  std::vector<long> result;\n  result.reserve(l1.size());\n\
    \  for (int i = 0; i != l1.size(); i++) {\n    if (l1.at(i) == result) {\n   \
    \   result.push_back(l1.at(i));\n    }\n  }\n  for (int i = 0; i != l2.size();\
    \ i++) {\n    if (l2.at(i) == result) {\n      result.push_back(l2.at(i));\n \
    \   }\n  }\n  return result;", "    long ans = 0;\n    for (long i = 0; i < l1.size();\
    \ i++) {\n        long j = i;\n        for (++j; j < l2.size(); j++) {\n     \
    \       if (l1[i] == l2[j]) {\n                ans += 1;\n                break;\n\
    \            }\n        }\n    }\n    std::vector<long> res(ans);\n    for (long\
    \ i = 0; i < ans; i++)\n        res[i] = l1[i];\n    return res;", "    // Use\
    \ set for faster lookup.\n    std::set<long> s;\n    l1.insert(l1.begin(), l2.begin(),\
    \ l2.end());\n    for (auto i : l1) {\n        s.insert(i);\n    }\n    std::vector<long>\
    \ ret;\n    for (auto i : l2) {\n        if (s.find(i) == s.end()) {\n       \
    \     ret.push_back(i);\n        }\n    }\n    return ret;", "    std::vector<long>\
    \ result;\n    std::vector<long>::iterator it1, it2;\n    it1 = l1.begin();\n\
    \    it2 = l2.begin();\n    long commonVal = 0;\n    while (it1 != l1.end() &&\
    \ it2 != l2.end()) {\n        if (*it1 == *it2) {\n            commonVal += 1;\n\
    \            it1 += 1;\n            it2 += 1;\n        } else if (*it1 < *it2)\
    \ {\n            result.push_back(*it1);\n            it1 += 1;\n        } else\
    \ {\n            result.push_back(*it2);\n            it2 += 1;\n        }\n \
    \   }\n    std::sort(result.begin(), result.end());\n    if (result.size() > 0)\
    \ {\n        result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    }\n    return result;", "  assert(l1.size() == l2.size());\n  long a = 0;\n\
    \  long b = 0;\n  std::vector<long> ans;\n  for (int i = 0; i < l1.size(); i++)\
    \ {\n    if (l1.at(i) == l2.at(i)) {\n      a++;\n    } else {\n      b++;\n \
    \     if (a == b) {\n        ans.push_back(l1.at(i));\n        a = b;\n      }\n\
    \    }\n  }\n  return ans;", "\tstd::vector<long> results;\n\t// Create a set\
    \ to hold unique elements common to both lists.\n\tstd::set<long> set;\n\tfor\
    \ (long i : l1) {\n\t\tif (set.find(i) == set.end()) {\n\t\t\tset.insert(i);\n\
    \t\t\tresults.push_back(i);\n\t\t}\n\t}\n\tfor (long i : l2) {\n\t\tif (set.find(i)\
    \ == set.end()) {\n\t\t\tset.insert(i);\n\t\t\tresults.push_back(i);\n\t\t}\n\t\
    }\n\treturn results;", "  std::vector<long> ret;\n  for (size_t i = 0; i < l1.size();\
    \ ++i) {\n    for (size_t j = 0; j < l2.size(); ++j) {\n      if (l1[i] == l2[j])\
    \ ret.push_back(l1[i]);\n    }\n  }\n  return ret;", "    std::vector<long> tmp(l1.size()\
    \ + l2.size());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ tmp.begin());\n    return tmp;", "    std::vector<long> res;\n    // Sort both\
    \ lists to make the searching process faster.\n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n\n    // Iterate through two lists until\
    \ they stop intersecting or they have only 1 element.\n    for (long i = 0, j\
    \ = 0; i < l1.size(); i++, j++) {\n        while (j >= l2.size() || l1[i] == l2[j])\
    \ {\n            j = 0;\n        }\n        // If they are intersecting, add the\
    \ smaller element of l1 to res.\n        if (j != l2.size()) {\n            res.push_back(l1[i]);\n\
    \        }\n    }\n\n    return res;", "    std::vector<long> v;\n    int i,j;\n\
    \    for(i = 0; i < l1.size(); i++)\n        for(j = 0; j < l2.size(); j++) {\n\
    \            if(l1[i] == l2[j])\n                v.push_back(l1[i]);\n       \
    \ }\n    return v;", "  std::vector<long> common;\n  for (long i=0; i<l1.size();\
    \ i++) {\n    for (long j=0; j<l2.size(); j++) {\n      if (l1[i] == l2[j]) {\n\
    \        common.push_back(l1[i]);\n        break;\n      }\n    }\n  }\n  return\
    \ common;", "    std::vector<long> result;\n    long count{0};\n\n    l1.sort();\n\
    \    l2.sort();\n    std::set_intersection(l1.begin(), l1.end(),\n           \
    \              l2.begin(), l2.end(),\n                         std::back_inserter(result));\n\
    \    count = result.size();\n    std::sort(result.begin(), result.end());\n\n\
    \    std::vector<long>::iterator it;\n    for (it = result.begin(); it != result.end();\
    \ ++it) {\n        std::iter_swap(it++, it);\n    }\n    \n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n\n    std::sort(result.begin(), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\n\
    \    std::sort(result.begin(), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n\n    std::sort(result.begin(), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\n\
    \    std::sort(result.begin(), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n\n    std::sort(result.begin(), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\n\
    \    std::sort(result.begin(), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n    result.erase(std::unique(result.begin(),\
    \ result.end()), result.end());\n\n    std::sort(result.begin(), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.end()), result.end());\n\
    \    result.erase(std::unique(result.begin(), result.", "    if (l1.size() ==\
    \ 0 || l2.size() == 0)\n        return {};\n\n    std::vector<long> l3(l1.size());\n\
    \    std::vector<long>::iterator it;\n    for (it=l3.begin();it!=l3.end();++it){\n\
    \        long x = *it;\n        int cmp = l1.size() > l2.size() ? 1 : -1;\n  \
    \      for (int i=0;i<l1.size();++i){\n            if (l1[i] == x || l2[i] ==\
    \ x)\n                l3[i] = x;\n            else if (l1[i] > x || l2[i] > x)\n\
    \                l3[i] = std::min(l3[i], x);\n        }\n        if (l3.size()\
    \ == l1.size() + l2.size()) {\n            return l3;\n        }\n    }\n    return\
    \ {};", "  std::vector<long> ans;\n  ans.push_back(l1[0]);\n  for (int i=1; i<l1.size();\
    \ i++) {\n    long common = l1[0];\n    for (int j=0; j<l2.size(); j++) {\n  \
    \    if (l2[j] == common) {\n        ans.push_back(l1[i]);\n        break;\n \
    \     }\n    }\n  }\n  return ans;", "    std::vector<long> result;\n    long\
    \ min = std::numeric_limits<long>::min();\n    long max = std::numeric_limits<long>::max();\n\
    \    for (int i = 0; i < l1.size() && i < l2.size(); i++) {\n        if (l1[i]\
    \ < l2[i]) {\n            result.push_back(l1[i]);\n        } else {\n       \
    \     result.push_back(l2[i]);\n        }\n    }\n    for (int i = 0; i < result.size();\
    \ i++) {\n        if (result[i] < min) {\n            min = result[i];\n     \
    \   }\n        if (result[i] > max) {\n            max = result[i];\n        }\n\
    \    }\n    if (min > max) {\n        return result;\n    }\n    return std::vector<long>();",
  "    std::vector<long> v(l1.size());\n    for (long i = 0; i < l1.size(); ++i)\n\
    \        v[i] = l1[i];\n    for (long i = 0; i < l2.size(); ++i)\n        v[l1.size()+i]\
    \ = l2[i];\n    std::sort(v.begin(), v.end());\n    std::vector<long> v1;\n  \
    \  std::vector<long> v2;\n    long i, j, k;\n    for (k = i = j = 0; i < l1.size()\
    \ && j < l2.size(); ++i, ++j) {\n        if (v1[i] == v2[j])\n            continue;\n\
    \        if (v1[i] > v2[j])\n            v1.push_back(v1[i]);\n        else\n\
    \            v2.push_back(v2[j]);\n    }\n    return v1;", "    // Sort the lists.\
    \ Then their common elements will be adjacent.\n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    std::vector<long> result;\n    // If\
    \ length of l1 is smaller than length of l2, they have no common elements.\n \
    \   if (l1.size() < l2.size()) {\n        return result;\n    }\n    // If length\
    \ of l1 is larger than length of l2, first fit the smaller list.\n    // If length\
    \ is same, just consider the smaller list.\n    if (l1.size() > l2.size()) {\n\
    \        auto itr = std::find(l2.begin(), l2.end(), l1.back());\n        if (itr\
    \ != l2.end()) {\n            l2.pop_back();\n            l1.push_back(*itr);\n\
    \        }\n    }\n    // If their length is same, just consider the smaller list.\n\
    \    if (l1.size() == l2.size()) {\n        for (auto itr1 = l1.begin(); itr1\
    \ != l1.end(); ++itr1) {\n            auto itr2 = l2.begin();\n            while\
    \ (itr2 != l2.end() && *itr1 == *itr2) {\n                ++itr2;\n          \
    \  }\n            result.push_back(*itr1);\n            if (itr2 != l2.end())\
    \ {\n                l2.erase(itr2);\n            }\n        }\n    }\n    return\
    \ result;", "    if (l1.size() < l2.size()) {\n        std::swap(l1, l2);\n  \
    \  }\n    long result = 0;\n    for (auto i = 0; i < l1.size(); i++) {\n     \
    \   for (auto j = 0; j < l2.size(); j++) {\n            if (l1[i] == l2[j]) {\n\
    \                result++;\n            }\n        }\n    }\n    return {result};",
  "    // Sort the lists.\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    // Find the first element of l1 in l2.\n    auto it2 = std::find(l2.begin(),\
    \ l2.end(), l1.front());\n    if (it2 != l2.end()) {\n        // Remove the common\
    \ element from l2.\n        l2.erase(it2);\n    }\n    // Merge l1 and l2.\n \
    \   l1.insert(l1.end(), l2.begin(), l2.end());\n    // Return the result.\n  \
    \  return l1;", "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n\
    \  std::vector<long> result(l1.size());\n  for (auto i : l1) {\n    auto j = std::find(l2.begin(),\
    \ l2.end(), i);\n    if (j != l2.end()) {\n      result[j] = i;\n    }\n  }\n\
    \  return result;", "    // write your code here\n    std::vector<long> result;\n\
    \    for(auto it1 = l1.begin(); it1 != l1.end(); ++it1) {\n        for(auto it2\
    \ = l2.begin(); it2 != l2.end(); ++it2) {\n            if(*it1 == *it2) {\n  \
    \              result.push_back(*it1);\n            }\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "  std::vector<long> res;\n  std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                        std::back_inserter(res));\n\
    \  return res;", "    // Sort l1 first.\n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n\n    std::vector<long> result;\n    int\
    \ i = 0;\n    int j = 0;\n    while (i < l1.size() && j < l2.size()) {\n     \
    \   if (l1[i] == l2[j]) {\n            result.push_back(l1[i]);\n            i++;\n\
    \            j++;\n        } else if (l1[i] < l2[j]) {\n            j++;\n   \
    \     } else {\n            i++;\n        }\n    }\n\n    // Append unmatched\
    \ elements.\n    while (i < l1.size()) {\n        result.push_back(l1[i]);\n \
    \       i++;\n    }\n\n    while (j < l2.size()) {\n        result.push_back(l2[j]);\n\
    \        j++;\n    }\n\n    // Return result.\n    return result;", "    if (l1.size()\
    \ > l2.size()) {\n        std::swap(l1, l2);\n    }\n    std::vector<long> common;\n\
    \    for (auto i : l1) {\n        if (std::find(l2.begin(), l2.end(), i) == l2.end())\
    \ {\n            common.push_back(i);\n        }\n    }\n    std::sort(common.begin(),\
    \ common.end());\n    return common;", "    std::vector<long> common;\n    //\
    \ Use set to store unique elements\n    std::set<long> s1{l1.begin(), l1.end()};\n\
    \    std::set<long> s2{l2.begin(), l2.end()};\n\n    for (long i : s1) {\n   \
    \     if (s2.find(i) == s2.end())\n            common.push_back(i);\n    }\n \
    \   return common;", "    // Create a set to store unique elements\n    std::unordered_set<long>\
    \ u1;\n    u1.reserve(l1.size() + l2.size());\n    u1.insert(l1.begin(), l1.end());\n\
    \    u1.insert(l2.begin(), l2.end());\n    // Iterate through second list and\
    \ add only unique elements.\n    std::unordered_set<long> u2;\n    u2.reserve(l1.size()\
    \ + l2.size());\n    u2.insert(l1.begin(), l1.end());\n    u2.insert(l2.begin(),\
    \ l2.end());\n    // Find common elements\n    std::unordered_set<long> common_elem;\n\
    \    std::vector<long> result;\n    while (!u1.empty() || !u2.empty()) {\n   \
    \     // If either list has all unique elements then return it\n        if (u1.size()\
    \ == l1.size() + l2.size()) {\n            result.push_back(u1.size());\n    \
    \        break;\n        }\n        // If both lists have unique elements then\
    \ return it\n        if (u2.size() == l1.size() + l2.size()) {\n            result.push_back(u2.size());\n\
    \            break;\n        }\n        // If both lists have one unique element\
    \ then return it\n        if (u1.size() == l1.size() + 1 && u2.size() == l2.size()\
    \ + 1) {\n            result.push_back(u1.size());\n            result.push_back(u2.size());\n\
    \            break;\n        }\n        // If both lists have more than one unique\
    \ element then return it\n        if (u1.size() + u2.size() > l1.size() + l2.size())\
    \ {\n            result.push_back(u1.size());\n            result.push_back(u2.size());\n\
    \            break;\n        }\n        // If both lists have exactly one unique\
    \ element then return it\n        if (u1.size() == 1) {\n            result.push_back(u1.begin());\n\
    \            break;\n        }\n        if (u2.size() == 1) {\n            result.push_back(u2.begin());\n\
    \            break;\n        }\n        // If the first list has more than one\
    \ unique element then return it\n        if (u1.size() > l1.size()) {\n      \
    \      result.push_back(u1.begin());\n            break;\n        }\n        //\
    \ If the second list has more than one unique element then return it\n       \
    \ if (u2.size() > l2.size()) {\n            result.push_back(u2.begin());\n  \
    \          break;\n        }\n        // If both lists have exactly one unique\
    \ element then return the element\n        if (u1.size() == 1 && u2.size() ==\
    \ 1) {\n            result.push_back(u1.begin());\n            result.push_back(u2.begin());\n\
    \            break;\n        }\n    }\n    return result;", "    // Create a vector\
    \ to store unique common elements.\n    std::vector<long> u;\n    // Iterate through\
    \ both vectors to find unique common elements.\n    for (long i = 0; i < l1.size();\
    \ i++) {\n        for (long j = 0; j < l2.size(); j++) {\n            if (l1[i]\
    \ == l2[j]) {\n                u.push_back(l1[i]);\n                break;\n \
    \           }\n        }\n    }\n    return u;", "    // Sort the list to find\
    \ the first duplicates.\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::vector<long> result;\n    long count1 = 0;\n    long count2\
    \ = 0;\n    bool found = false;\n    for (long i = 0; i < l1.size(); i++) {\n\
    \        if (l1[i] == l2[i]) {\n            count1++;\n            count2++;\n\
    \            found = true;\n            if (count1 == l2.size() && !found) {\n\
    \                return result;\n            }\n        } else {\n           \
    \ result.push_back(l1[i]);\n            if (count1 > count2) {\n             \
    \   count2 = count1;\n            }\n            count1 = 1;\n            found\
    \ = false;\n        }\n    }\n    if (count1 == l1.size()) {\n        result.push_back(l1[l1.size()]);\n\
    \        if (count2 > count2) {\n            count2 = count1;\n        }\n   \
    \     count1 = 1;\n    }\n    if (count2 == l2.size()) {\n        result.push_back(l2[l2.size()]);\n\
    \    }\n    return result;", "    long result = std::numeric_limits<long>::max();\n\
    \    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n     \
    \                     [&](long a, long b) {\n                              return\
    \ a < b ? false : true;\n                          });\n    for (auto it : l1)\
    \ {\n        if (it == result) continue;\n        else l2.erase(std::remove(l2.begin(),\
    \ l2.end(), it), l2.end());\n    }\n    return l1;", "  std::vector<long> ans;\n\
    \  long temp;\n  for (long i : l1) {\n    for (long j : l2) {\n      temp = i;\n\
    \      if (temp == j)\n        continue;\n      if (ans.size() == 0 || temp <\
    \ ans.back())\n        ans.push_back(temp);\n    }\n  }\n  return ans;", "   \
    \ std::vector<long> v; // store unique elements of both lists\n    for(long x\
    \ : l1)\n        v.push_back(x);\n    for(long x : l2)\n        v.push_back(x);\n\
    \n    std::sort(v.begin(), v.end());\n\n    std::vector<long> result;\n    for(int\
    \ i = 0; i < v.size(); i++)\n        if(std::find(v2.begin(), v2.end(), v[i])\
    \ != v2.end())\n            result.push_back(v[i]);\n\n    return result;", " \
    \ std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  if (l1.size()\
    \ > l2.size()) {\n    return std::set_difference(l2.begin(), l2.end(), l1.begin(),\
    \ l1.end(), std::back_inserter(result));\n  } else if (l1.size() < l2.size())\
    \ {\n    return std::set_difference(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(result));\n  }\n\n  auto itr = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  while (itr !=\
    \ result.end()) {\n    auto element = *itr;\n    if (l1.find(element) == l1.end())\
    \ {\n      itr = result.erase(itr);\n    } else {\n      itr++;\n    }\n  }\n\
    \  return result;", "    std::vector<long> l3;\n    long cur, next;\n    for (long\
    \ i = 0; i < l1.size(); i++) {\n        cur = l1[i];\n        for (long j = 0;\
    \ j < l2.size(); j++) {\n            next = l2[j];\n            if (cur == next)\n\
    \                l3.push_back(cur);\n        }\n    }\n    l3.erase(l3.begin());\n\
    \    return l3;", "    std::vector<long> result;\n    l1.insert(l1.end(), l2.begin(),\
    \ l2.end());\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(), l2.end());\n\
    \n    std::vector<long>::iterator it;\n    for (it = l1.begin(); it != l1.end();\
    \ ++it) {\n        while (l2.end() != std::find(l2.begin(), l2.end(), *it)) {\n\
    \            l2.erase(std::find(l2.begin(), l2.end(), *it));\n        }\n    \
    \    result.push_back(*it);\n    }\n\n    return result;", "    std::vector<long>\
    \ l3;\n    for (long i : l1) {\n        for (long j : l2) {\n            if (i\
    \ == j) continue;\n            if (l3.find(j) == l3.end()) {\n               \
    \ l3.push_back(j);\n            }\n        }\n    }\n    return l3;", "  std::sort(l1.begin(),\
    \ l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::vector<long> common;\n\
    \  long size1 = l1.size();\n  long size2 = l2.size();\n  if (size1 < size2) return\
    \ common;\n  if (size1 == size2) return std::set<long>(l1).intersection(std::set<long>(l2));\n\
    \  for (long i = 0; i < size1; ++i) {\n    for (long j = 0; j < size2; ++j) {\n\
    \      if (l1[i] == l2[j]) common.push_back(l1[i]);\n    }\n  }\n  return common;",
  "\tstd::vector<long> res;\n\tres.reserve(l1.size() + l2.size());\n\tlong max = 0;\n\
    \t// Loop through l1 and l2 and maintain max to store maximum common element\n\
    \tfor (size_t i = 0; i < l1.size(); i++) {\n\t\tfor (size_t j = 0; j < l2.size();\
    \ j++) {\n\t\t\tif (l1[i] == l2[j]) {\n\t\t\t\tres.push_back(l1[i]);\n\t\t\t\t\
    if (max == 0) max = l1[i];\n\t\t\t} else if (l1[i] > max) {\n\t\t\t\tmax = l1[i];\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn res;", "    std::vector<long> common;\n    size_t\
    \ len = l1.size();\n    std::vector<long>::iterator it1 = l1.begin();\n    std::vector<long>::iterator\
    \ it2 = l2.begin();\n\n    while (it1 != l1.end() && it2 != l2.end())\n      \
    \  if (*it1 < *it2) {\n            common.push_back(*it1);\n            ++it1;\n\
    \        } else if (*it2 < *it1) {\n            common.push_back(*it2);\n    \
    \        ++it2;\n        } else {\n            ++it1;\n            ++it2;\n  \
    \      }\n    while (it1 != l1.end())\n        common.push_back(*it1);\n    while\
    \ (it2 != l2.end())\n        common.push_back(*it2);\n\n    return common;", " \
    \   std::vector<long> res(l1.size());\n    // If one list is empty, return other\
    \ list.\n    if (l1.empty() || l2.empty())\n        return l2;\n    // If both\
    \ lists are same size, return it.\n    if (l1.size() == l2.size())\n        return\
    \ l1;\n    // If one is sorted, other one must be sorted, else they can't be common.\n\
    \    if (l1[l1.size() - 1] < l2[0])\n        return l2;\n    if (l2[l2.size()\
    \ - 1] < l1[0])\n        return l1;\n    // Find the first element of first list.\n\
    \    auto it = std::find(l1.begin(), l1.end(), l1[0]);\n    long curr_idx = 0;\n\
    \    // Iterate over both lists until first common element is found.\n    while\
    \ (it != l1.end()) {\n        // Check if first list current element is same as\
    \ current element of second list.\n        if (l2[curr_idx] == *it) {\n      \
    \      ++curr_idx;\n        }\n        ++it;\n    }\n    // Return only unique\
    \ elements.\n    for (long i = curr_idx; i < l2.size(); ++i) {\n        res[i\
    \ - curr_idx] = l2[i];\n    }\n    return res;", "    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    auto it = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                                   std::back_inserter(common));\n\
    \    std::vector<long> res;\n    res.insert(res.end(), it.begin(), it.end());\n\
    \    return res;", "  if (l1.size() == 0)\n    return l2;\n  if (l2.size() ==\
    \ 0)\n    return l1;\n  std::vector<long> ans;\n  long max_common_ele = 0, max_common_ele_pos\
    \ = 0;\n  long i = 0;\n  for (; i < l1.size(); i++) {\n    if (l1[i] == l2[i])\
    \ continue;\n    int pos = i;\n    while (pos > 0 && l1[pos - 1] == l2[pos - 1])\
    \ pos--;\n    max_common_ele = l1[i];\n    max_common_ele_pos = pos;\n    for\
    \ (int j = i; j < l1.size(); j++) {\n      if (l1[j] == l2[j]) {\n        ans.push_back(l1[i]);\n\
    \        break;\n      }\n      if (l1[j] > l1[i]) {\n        ans.push_back(l1[j]);\n\
    \        break;\n      }\n    }\n  }\n  std::sort(ans.begin(), ans.end());\n \
    \ return ans;", "    std::vector<long> uniqueList;\n    std::vector<bool> isCommon(uniqueList.size(),\
    \ false);\n    // Set of elements that are common between both lists\n    std::vector<long>\
    \ commonElements;\n    // Iterate through each list and check whether current\
    \ element is\n    // common to both lists or not and mark it for further usage\n\
    \    for (long i = 0; i < l1.size(); i++) {\n        // Search the current element\
    \ if it exists in the first list\n        if (std::find(l1.begin(), l1.end(),\
    \ l1[i]) != l1.end()) {\n            // Mark it for further usage\n          \
    \  isCommon[i] = true;\n            // If found then, append it to the common\
    \ elements\n            commonElements.push_back(l1[i]);\n        }\n    }\n \
    \   // Iterate through each list and check whether current element is\n    //\
    \ common to both lists or not and mark it for further usage\n    for (long i =\
    \ 0; i < l2.size(); i++) {\n        // Search the current element if it exists\
    \ in the second list\n        if (std::find(l2.begin(), l2.end(), l2[i]) != l2.end())\
    \ {\n            // Mark it for further usage\n            isCommon[i] = true;\n\
    \            // If found then, append it to the common elements\n            commonElements.push_back(l2[i]);\n\
    \        }\n    }\n    // Iterate through each list and if current element is\
    \ common to both lists\n    // remove it\n    for (long i = 0; i < uniqueList.size();\
    \ i++) {\n        // Search the current element if it exists in the first list\n\
    \        if (std::find(commonElements.begin(), commonElements.end(),\n       \
    \               uniqueList[i]) != commonElements.end()) {\n            isCommon[i]\
    \ = true;\n            commonElements.erase(std::find(commonElements.begin(),\n\
    \                                          commonElements.end(), uniqueList[i]));\n\
    \        }\n    }\n    // Return sorted unique common elements for two lists\n\
    \    std::vector<long> newList;\n    for (long i = 0; i < isCommon.size(); i++)\
    \ {\n        if (!isCommon[i]) {\n            newList.push_back(uniqueList[i]);\n\
    \        }\n    }\n    // Return sorted unique common elements for two lists\n\
    \    return newList;", "    std::vector<long> common;\n    if (l1.size() > l2.size())\
    \ {\n        // First list is longer.\n        for (long i = 0; i < l2.size();\
    \ i++)\n            common.push_back(l2.at(i));\n    } else {\n        // Second\
    \ list is longer.\n        for (long i = 0; i < l1.size(); i++)\n            common.push_back(l1.at(i));\n\
    \    }\n    std::sort(common.begin(), common.end());\n    return common;", " \
    \   std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n \
    \   std::vector<long> ret;\n    for (auto i : l1) {\n        if (l1.find(i) !=\
    \ l2.end()) {\n            ret.push_back(i);\n        }\n    }\n    return ret;",
  "    // Sort the vectors in ascending order.\n    auto cmp = [](long l, long r){return\
    \ l<r;};\n    std::sort(l1.begin(), l1.end(), cmp);\n    std::sort(l2.begin(),\
    \ l2.end(), cmp);\n    // Merge them into a vector.\n    std::vector<long> common(std::min(l1.size(),\
    \ l2.size()), 0);\n    int i = 0; \n    for (; i < std::min(l1.size(), l2.size());\
    \ ++i) {\n        if(l1[i] == l2[i]) {\n            common[i] = l1[i];\n     \
    \   } else {\n            break;\n        }\n    }\n    // Return it.\n    return\
    \ common;", "    std::vector<long> result;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n    return result;",
  "  assert(l1.size() == l2.size());\n  std::vector<long> common;\n  for (int i =\
    \ 0; i < l1.size(); ++i) {\n    if (l1.at(i) == l2.at(i)) {\n      common.push_back(l1.at(i));\n\
    \    } else {\n      auto it = std::find(l1.begin(), l1.end(), l2.at(i));\n  \
    \    if (it != l1.end()) {\n        std::iter_swap(it, l1.end());\n      }\n \
    \   }\n  }\n  return common;", "    std::vector<long> l3;\n    l3.reserve(l1.size());\n\
    \    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(l3));\n\
    \    return l3;", "  assert(l1.size() == l2.size());\n  std::sort(l1.begin(),\
    \ l1.end());\n  std::sort(l2.begin(), l2.end());\n  auto end = std::set_intersection(l1.begin(),\
    \ l1.end(),\n                                  l2.begin(), l2.end(),\n       \
    \                           std::back_inserter(std::vector()));\n  return std::vector(end,\
    \ std::back_inserter(std::vector()));", "  long common_count = l1.size();\n  for\
    \ (auto val : l2) {\n    auto it = std::find(l1.begin(), l1.end(), val);\n   \
    \ if (it != l1.end()) {\n      l1.erase(it);\n      l1.push_back(val);\n     \
    \ common_count --;\n    }\n  }\n  return l1;", "    std::vector<long> l3;\n  \
    \  long n = 0;\n    long i = 0;\n    long j = 0;\n    for (; i < l1.size(); i++)\
    \ {\n        for (; j < l2.size(); j++) {\n            if (l1[i] == l2[j]) {\n\
    \                l3.push_back(l1[i]);\n                break;\n            }\n\
    \        }\n    }\n    return l3;", "    std::vector<long> result;\n    std::set<long>\
    \ l1(l1.begin(), l1.end());\n    std::set<long> l2(l2.begin(), l2.end());\n  \
    \  l1.erase(l2.begin(), l2.end());\n    l2.erase(l1.begin(), l1.end());\n    for\
    \ (long c : l1) {\n        if (l2.find(c) != l2.end()) {\n            result.push_back(c);\n\
    \        }\n    }\n    for (long c : l2) {\n        if (l1.find(c) != l1.end())\
    \ {\n            result.push_back(c);\n        }\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n    std::vector<long> result;\n    for\
    \ (std::size_t i = 0; i < std::min(l1.size(), l2.size()); ++i) {\n        if (l1[i]\
    \ == l2[i]) result.push_back(l1[i]);\n    }\n    return result;", "    // sort\
    \ the lists first\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    \n    // check for common elements\n    std::vector<long>::iterator\
    \ it;\n    for (it = std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end()).begin();\
    \ it != std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end()).end();\
    \ ++it) {\n        l1.erase(*it);\n    }\n    return l1;", "    // Check for equal\
    \ sizes\n    if (l1.size() != l2.size()) {\n        throw std::invalid_argument(\"\
    Cannot compare different sized vectors.\");\n    }\n    // Create a set using\
    \ O(n) worst case for insertion sort.\n    std::set<long> set1{l1.begin(), l1.end()};\n\
    \    std::set<long> set2{l2.begin(), l2.end()};\n    // Intersection of two sets\n\
    \    std::vector<long> intersection;\n    std::set_intersection(l1.begin(), l1.end(),\
    \ l2.begin(), l2.end(),\n                         std::inserter(intersection,\
    \ intersection.begin()));\n    return intersection;", "  std::vector<long> v;\n\
    \  assert(l1.size() == l2.size());\n  for (long i = 0; i < l1.size(); i++) {\n\
    \    bool flag = false;\n    for (long j = 0; j < l2.size(); j++) {\n      if\
    \ (l1[i] == l2[j]) {\n        flag = true;\n        break;\n      }\n    }\n \
    \   if (!flag) {\n      v.push_back(l1[i]);\n    }\n  }\n  return v;", "    //\
    \ Iterate through all elements of l1 and compare with all\n    // elements of\
    \ l2 from index 1 till length of l1.\n    // Return indices of common elements.\n\
    \    std::vector<long> temp;\n    long n1 = l1.size(), n2 = l2.size();\n    for\
    \ (long i = 1; i < n1; i++) {\n        // If element at index i of l1 is not in\
    \ l2\n        if (l1.at(i) == l2.at(i - 1)) {\n            // Add element at index\
    \ i to temp vector.\n            temp.push_back(temp.size() + i);\n        }\n\
    \    }\n    // Return indices of common elements.\n    return temp;", "    std::vector<long>\
    \ result(l1.size());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(result));\n    return result;", "    assert(l1.size()\
    \ == l2.size());\n    std::vector<long> ret(l1.size());\n    int i(0), j(0);\n\
    \    while (i < l1.size() && j < l2.size()) {\n        if (l1[i] == l2[j]) {\n\
    \            ret[i++] = l1[i++];\n            j++;\n        } else if (l1[i] <\
    \ l2[j]) {\n            ret[i++] = l1[i++];\n        } else {\n            ret[j++]\
    \ = l2[j++];\n        }\n    }\n    while (i < l1.size()) {\n        ret[i++]\
    \ = l1[i++];\n    }\n    while (j < l2.size()) {\n        ret[j++] = l2[j++];\n\
    \    }\n    return ret;", "    long result = 0, flag = 0;\n    int size = l1.size();\n\
    \    for (int i = 0; i < size; i++) {\n        for (int j = 0; j < size; j++)\
    \ {\n            if (l1[i] == l2[j] && i != j && flag == 1) {\n              \
    \  result = l1[i];\n                flag = 2;\n                break;\n      \
    \      }\n            if (l1[j] == l2[i] && i != j && flag == 2) {\n         \
    \       result = l1[j];\n                flag = 1;\n                break;\n \
    \           }\n        }\n        if (flag == 1) break;\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(result);\n    return result;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    if (l1.size() > l2.size())\
    \ return l1;\n    if (l1.size() < l2.size()) return l2;\n    return std::vector<long>(std::adjacent_find(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end()));", "    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n\n    std::vector<long> s;\n    while(l1.size()\
    \ && l2.size()) {\n        if (l1[0] == l2[0])\n            s.push_back(l1.back());\n\
    \        l1.erase(l1.begin());\n        l2.erase(l2.begin());\n    }\n    return\
    \ s;", "    std::vector<long> a;\n    l1.insert(l1.end(), l2.begin(), l2.end());\n\
    \    auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ back_inserter(a));\n    l1.erase(std::unique(l1.begin(), l1.end(), [&](long\
    \ e) { return std::find(l2.begin(), l2.end(), e) != l2.end(); }), l1.end());\n\
    \    return a;", "  std::vector<long> res;\n  if (l1.size() == 0 || l2.size()\
    \ == 0)\n    return res;\n  int i = 0;\n  int j = 0;\n  while (true) {\n    if\
    \ (l1[i] == l2[j]) {\n      res.push_back(l1[i]);\n      i++;\n      j++;\n  \
    \  } else if (l1[i] > l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n\
    \    if (i == l1.size() && j == l2.size())\n      break;\n  }\n  return res;",
  "    std::vector<long> temp;\n    long common_elem = 0;\n    long common_element_count\
    \ = 0;\n    long l = 0;\n    long r = 0;\n    for(int i = 0; i < l1.size(); i++)\
    \ {\n        common_elem = l1.at(i) ^ l2.at(i);\n        common_element_count\
    \ += common_elem != 0;\n        while(common_element_count > 0) {\n          \
    \  temp.push_back(l1.at(common_elem % l1.size()));\n            common_elem_count--;\n\
    \            common_elem /= l1.size();\n        }\n        while(common_element_count\
    \ > 0) {\n            temp.push_back(l2.at(common_elem % l2.size()));\n      \
    \      common_elem_count--;\n            common_elem /= l2.size();\n        }\n\
    \        std::sort(temp.begin(), temp.end());\n        for(int j = temp.size()\
    \ - 1; j >= 0; j--) {\n            if(temp.at(j) == temp.size() - 1) l++;\n  \
    \          else {\n                if(temp.at(j) == temp.at(j + 1)) r++;\n   \
    \             common_element_count -= (temp.at(j + 1) == temp.at(j));\n      \
    \          if(common_element_count == 0) break;\n            }\n        }\n  \
    \  }\n    std::vector<long> ans;\n    ans.push_back(l1);\n    ans.push_back(l2);\n\
    \    ans.push_back(r);\n    return ans;", "    std::vector<long> v;\n    std::set<long>\
    \ s;\n    for(int i=0;i<l1.size();i++) {\n        long a = l1[i];\n        for(int\
    \ j=0;j<l2.size();j++) {\n            long b = l2[j];\n            if(s.find(a)\
    \ == s.find(b))\n                v.push_back(b);\n            else\n         \
    \       s.insert(b);\n        }\n    }\n    return v;", "    // Write your code\
    \ here\n    std::vector<long> res;\n    for(size_t i = 0; i < l1.size(); i++)\
    \ {\n        for(size_t j = 0; j < l2.size(); j++) {\n            if(l1[i] ==\
    \ l2[j]) {\n                res.push_back(l1[i]);\n            }\n        }\n\
    \    }\n    return res;", "    std::vector<long> unique;\n    long temp = 0;\n\
    \    for (long i = 0; i < l1.size(); i++) {\n        if (l1.at(i) == l2.at(i))\n\
    \            continue;\n        for (long j = 0; j < l2.size(); j++) {\n     \
    \       if (l1.at(i) == l2.at(j)) {\n                if (i == j)\n           \
    \         unique.push_back(temp);\n                temp++;\n                break;\n\
    \            }\n        }\n    }\n    return unique;", "\tstd::vector<long> res;\n\
    \tfor (long i = 0; i < (l1.size() + l2.size()); ++i) {\n\t\tif (l1.size() <= i\
    \ || l2.size() <= i)\n\t\t\tbreak;\n\t\tif (l1[i] == l2[i])\n\t\t\tres.push_back(l1[i]);\n\
    \t}\n\treturn res;", "    std::vector<long> common;\n    std::vector<long> tmp(l1.size());\n\
    \    // sort both arrays\n    sort(l1.begin(), l1.end(), [](long a, long b) ->\
    \ bool {\n        return a < b;\n    });\n    sort(l2.begin(), l2.end(), [](long\
    \ a, long b) -> bool {\n        return a < b;\n    });\n    // go through both\
    \ arrays simultaneously\n    for (long i = 0; i < l1.size(); i++) {\n        for\
    \ (long j = 0; j < l2.size(); j++) {\n            if (l1[i] == l2[j]) {\n    \
    \            tmp[i] = tmp[j];\n            }\n        }\n    }\n    // remove\
    \ duplicates\n    tmp.erase(std::unique(\n        tmp.begin(), tmp.end()), tmp.end());\n\
    \    // remove sorted duplicated elements\n    tmp.erase(std::unique(\n      \
    \  tmp.begin(), tmp.end()), tmp.end());\n    // return sorted unique common elements\n\
    \    return tmp;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::vector<long> result;\n    for(long i = 0; i<l1.size();\
    \ i++) {\n        for(long j=i; j<l1.size(); j++) {\n            if (l1[i] < l2[j]\
    \ && l1[j] == l2[i]) {\n                result.push_back(l1[i]);\n           \
    \ }\n        }\n    }\n    std::sort(result.begin(), result.end());\n    return\
    \ result;", "    assert(l1.size() == l2.size());\n    std::vector<long> result(l1.size());\n\
    \    int j = 0;\n    for (auto i : l1) {\n        for (auto j : l2) {\n      \
    \      if (i == j) {\n                result[j] = i;\n                j++;\n \
    \           }\n        }\n    }\n    return std::unique(result);", "    long n1\
    \ = l1.size();\n    long n2 = l2.size();\n    long k1 = std::min(n1, n2);\n  \
    \  std::vector<long> kids(k1);\n\n    std::vector<long>::iterator it1 = l1.begin();\n\
    \    std::vector<long>::iterator it2 = l2.begin();\n\n    for (long i = 0; i <\
    \ k1; i++) {\n        if (it1 == l1.end() && it2 == l2.end()) {\n            kids[i]\
    \ = 0;\n        } else if (it1 == l1.end()) {\n            kids[i] = it2;\n  \
    \      } else if (it2 == l2.end()) {\n            kids[i] = it1;\n        } else\
    \ if (*it1 < *it2) {\n            kids[i] = it1;\n            it1++;\n       \
    \ } else {\n            kids[i] = it2;\n            it2++;\n        }\n    }\n\
    \    return kids;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n\
    \                         std::back_inserter(common_elements));\n    std::vector<long>\
    \ res;\n    for(const auto &e: common_elements) {\n        res.push_back(e);\n\
    \    }\n    return res;", "    // Create new vector with unique elements\n   \
    \ std::vector<long> u_list;\n    std::set_union(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(u_list));\n    return u_list;", "    std::vector<long>\
    \ l3;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    std::vector<bool> visited(l1.size(), false);\n    for (int i = 0; i < l1.size();\
    \ i++) {\n        if (visited[i]) {\n            continue;\n        }\n      \
    \  for (int j = 0; j < l2.size(); j++) {\n            if (l1[l1.size() - i - 1]\
    \ == l2[j]) {\n                l3.push_back(l1.size() - i - 1);\n            \
    \    visited[j] = true;\n            }\n        }\n    }\n    return l3;", " \
    \   // Your code here\n    std::vector<long> temp;\n    temp.push_back(l1[0]);\n\
    \    temp.push_back(l1[1]);\n    temp.push_back(l2[0]);\n    temp.push_back(l2[1]);\n\
    \n    for (int i=2; i<(min(l1.size(), l2.size())); i++) {\n        int c = 0;\n\
    \        while (temp[c]!=l1[i]) {\n            c++;\n        }\n        temp.push_back(l1[i]);\n\
    \    }\n\n    return temp;", "    std::vector<long> l3;\n    l3.reserve(l1.size()\
    \ + l2.size());\n    l3.insert(l3.begin(), l1.begin(), l1.end());\n    for (auto\
    \ i = l1.begin() + 1; i <= l1.end(); ++i) {\n        for (auto j = l2.begin()\
    \ + 1; j <= l2.end(); ++j) {\n            if (*i == *j) {\n                l3.push_back(*i);\n\
    \                ++i;\n                ++j;\n            }\n        }\n    }\n\
    \    return l3;", "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(),\
    \ l2.end());\n\n  std::vector<long> l3{l1.begin(), l1.end()};\n  std::set_union(l2.begin(),\
    \ l2.end(), l3.begin(), l3.end(), std::back_inserter(l3));\n  std::vector<long>\
    \ l4{l3.begin(), l3.end()};\n  std::sort(l4.begin(), l4.end());\n\n  return l4;",
  "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n  \
    \  std::vector<long> result;\n    for (auto it = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(result))\n             .begin();\
    \ it != std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(result))\n\
    \             .end(); ++it)\n        ;\n    return result;", "    std::vector<long>\
    \ l3;\n    for (long i = 0; i < (std::min)(l1.size(), l2.size()); i++) {\n   \
    \     if (l1[l1.size() - i - 1] == l2[l2.size() - i - 1]) l3.push_back(l1[l1.size()\
    \ - i - 1]);\n        else if (l2[l2.size() - i - 1] == l1[l1.size() - i - 1])\
    \ l3.push_back(l2[l2.size() - i - 1]);\n    }\n    return l3;", "  std::vector<long>\
    \ l;\n  int i=0;\n  int j=0;\n  int count=0;\n  while(i<l1.size() && j<l2.size()){\n\
    \    if(l1[i]==l2[j]){\n      l.push_back(l1[i]);\n      i++;\n      count++;\n\
    \      j++;\n      count++;\n      if(j==l2.size()){\n        i++;\n        count=1;\n\
    \      }\n    }\n    else if(l1[i]<l2[j]){\n      i++;\n      count=1;\n    }\n\
    \    else{\n      j++;\n      count=1;\n    }\n  }\n  return l;", "    // Create\
    \ a vector to store unique common elements.\n    std::vector<long> result;\n \
    \   // If the length of both lists is 0,\n    // return the empty vector.\n  \
    \  if (l1.size() == 0 || l2.size() == 0) {\n        return result;\n    }\n  \
    \  // If the first list is shorter than the second list,\n    // reverse it before\
    \ finding the common elements.\n    if (l1.size() < l2.size()) {\n        std::reverse(l2.begin(),\
    \ l2.end());\n    }\n    // Iterate over first list.\n    for (size_t i = 0; i\
    \ < l1.size(); i++) {\n        // If the current element is found in the second\
    \ list,\n        // add the element to result vector\n        if (std::find(l2.begin(),\
    \ l2.end(), l1[i]) != l2.end()) {\n            result.push_back(l1[i]);\n    \
    \    }\n    }\n    // If the second list is longer, reverse it again.\n    if\
    \ (l2.size() > l1.size()) {\n        std::reverse(l1.begin(), l1.end());\n   \
    \ }\n    // Iterate over the second list.\n    for (size_t i = 0; i < l2.size();\
    \ i++) {\n        // If the current element is found in the first list,\n    \
    \    // add it to the result vector\n        if (std::find(l1.begin(), l1.end(),\
    \ l2[i]) != l1.end()) {\n            result.push_back(l2[i]);\n        }\n   \
    \ }\n    // Return the result vector.\n    return result;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(res));\n    return res;",
  "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  return\
    \ std::unique(l1.begin(), l1.end(), l2.begin(), l2.end());", "    if (l1.size()\
    \ != l2.size()) {\n        throw \"Vectors cannot be of different size.\";\n \
    \   }\n    // Create a vector to store unique common elements\n    std::vector<long>\
    \ v;\n    // sort both lists to get an ordered array\n    sort(l1.begin(), l1.end());\n\
    \    sort(l2.begin(), l2.end());\n    // Check if each element of l1 is present\
    \ in l2\n    // if yes, add it to v\n    std::vector<bool> flag(l1.size(), false);\n\
    \    for (long i = 0; i < l1.size(); i++) {\n        flag[i] = (flag[i]) ? false\
    \ : true;\n    }\n    for (long i = 0; i < l2.size(); i++) {\n        if (flag[i]\
    \ == true) {\n            v.push_back(l1[i]);\n        }\n    }\n    return v;",
  "  std::vector<long> ans;\n  long cur=0;\n  long temp=l1.size();\n  long count=0;\n\
    \  while (temp) {\n    if (l1[temp]==l2[temp]) {\n      count++;\n      ans.push_back(l1[temp]);\n\
    \      temp--;\n    } else {\n      while(temp) {\n        if (l1[temp]>l2[temp])\
    \ {\n          ans.push_back(l1[temp--]);\n        } else {\n          ans.push_back(l2[temp--]);\n\
    \        }\n      }\n      count--;\n    }\n  }\n  return ans;", "  if (l1.size()\
    \ != l2.size()) \n    throw \"Size mismatch\";\n  std::vector<long> result;\n\
    \  // Find max size\n  // int maxSize = std::max(l1.size(), l2.size());\n  //\
    \ result.assign(maxSize, 0);\n  // std::iota(result.begin(), result.end(), 0);\n\
    \  // std::sort(result.begin(), result.end(), [&l1, &l2](int x, int y) {\n  //\
    \   return l1[x] < l2[y] ? -1 : l1[x] > l2[y] ? 1 : 0;\n  // });\n\n  // std::nth_element(result.begin(),\
    \ result.begin() + maxSize, result.end(), \n  //  [&l1, &l2](int x, int y) {\n\
    \  //  return l1[x] < l2[y] ? -1 : l1[x] > l2[y] ? 1 : 0;\n  // });\n\n  std::sort(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::greater<long>());\n  std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(result));\n  return result;",
  "\tstd::vector<long> res;\n\tstd::set<long> l3;\n\tstd::set<long> l4;\n\t// Sort\
    \ lists to get a stable result.\n\tstd::sort(l1.begin(), l1.end());\n\tstd::sort(l2.begin(),\
    \ l2.end());\n\n\tstd::set_intersection(l1.begin(), l1.end(),\n\t\t\t\t\t\t l2.begin(),\
    \ l2.end(),\n\t\t\t\t\t\t std::back_inserter(l3));\n\tstd::set_intersection(l2.begin(),\
    \ l2.end(),\n\t\t\t\t\t\t l1.begin(), l1.end(),\n\t\t\t\t\t\t std::back_inserter(l4));\n\
    \tstd::set_union(l3.begin(), l3.end(),\n\t\t\t\tl4.begin(), l4.end(),\n\t\t\t\t\
    std::back_inserter(res));\n\tstd::sort(res.begin(), res.end());\n\treturn res;",
  "    std::vector<long> result;\n    // Using map to improve the complexity of insertion.\n\
    \    std::map<long, long> map;\n    for (const auto &it : l1)\n        map[it]\
    \ = 1;\n    for (const auto &it : l2)\n        map[it] = 1;\n    for (auto it\
    \ = map.begin(); it != map.end(); ++it) {\n        long key = it->first;\n   \
    \     if (map.find(key) == map.end())\n            result.push_back(key);\n  \
    \  }\n    std::sort(result.begin(), result.end());\n    return result;", "  std::vector<long>\
    \ lc;\n  lc.reserve(l1.size() + l2.size());\n  auto it1 = l1.begin();\n  auto\
    \ it2 = l2.begin();\n  while (it1 != l1.end() && it2 != l2.end()) {\n    if (*it1\
    \ < *it2) {\n      lc.push_back(*it1);\n      ++it1;\n    } else if (*it2 < *it1)\
    \ {\n      lc.push_back(*it2);\n      ++it2;\n    } else {\n      ++it1;\n   \
    \   ++it2;\n    }\n  }\n  while (it1 != l1.end()) {\n    lc.push_back(*it1);\n\
    \    ++it1;\n  }\n  while (it2 != l2.end()) {\n    lc.push_back(*it2);\n    ++it2;\n\
    \  }\n  return lc;", "    std::vector<long> common;\n    auto it1 = l1.begin();\n\
    \    auto it2 = l2.begin();\n    auto it3 = common.begin();\n    while (it1 !=\
    \ l1.end() && it2 != l2.end()) {\n        if (*it1 < *it2) *it3++ = *it1++;\n\
    \        else if (*it2 < *it1) *it3++ = *it2++;\n        else it3++;\n    }\n\
    \    while (it1 != l1.end()) *it3++ = *it1++;\n    while (it2 != l2.end()) *it3++\
    \ = *it2++;\n    return common;", "  // create two maps to store the count of\
    \ each element in l1 and l2.\n  long map_l1[l1.size()], map_l2[l2.size()];\n \
    \ for (auto &e : l1) {\n    map_l1[e]++;\n  }\n  for (auto &e : l2) {\n    map_l2[e]++;\n\
    \  }\n  // create two vectors to store the results of each map lookup\n  std::vector<long>\
    \ res(l1.size() + l2.size());\n  // traverse each map in order\n  for (int i =\
    \ 0; i < l1.size(); i++) {\n    for (int j = 0; j < l2.size(); j++) {\n      if\
    \ (map_l1[i] == map_l2[j]) {\n        res[i + j] = map_l1[i];\n      }\n    }\n\
    \  }\n  return res;", "  std::vector<long> s;\n  std::sort(l1.begin(), l1.end());\n\
    \  std::sort(l2.begin(), l2.end());\n  while (l1.size() != 0 || l2.size() != 0)\
    \ {\n    if (l1.size() == 0 || l2.size() == 0) break;\n    if (l1[l1.size() -\
    \ 1] == l2[l2.size() - 1]) break;\n    s[s.size() + 1] = l1[l1.size() - 1];\n\
    \    l1.pop_back();\n    l2.pop_back();\n  }\n  return s;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::vector<long> common;\n\
    \    std::vector<long>::iterator it1 = l1.begin();\n    std::vector<long>::iterator\
    \ it2 = l2.begin();\n    while (it1 != l1.end() && it2 != l2.end()) {\n      \
    \  if (*it1 == *it2)\n            common.push_back(*it1);\n        it1++;\n  \
    \      it2++;\n    }\n    return common;", "    std::vector<long> a;\n    int\
    \ ls = l1.size();\n    int lt = l2.size();\n    // If lists are of different size,\
    \ return an empty list.\n    if (ls != lt) {\n        return a;\n    }\n    std::vector<long>\
    \ arr(ls);\n    int i = 0;\n    while (i < ls && l1.at(i) == l2.at(i)) {\n   \
    \     arr[i++] = l1.at(i);\n    }\n    for (; i < ls; ++i) {\n        arr[i++]\
    \ = l1.at(i);\n    }\n    for (; i < lt; ++i) {\n        arr[i++] = l2.at(i);\n\
    \    }\n    std::sort(arr.begin(), arr.end());\n    return arr;", "    std::vector<long>\
    \ res;\n    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(res));\n    return res;", "    std::vector<long> ret(l1.size());\n\
    \    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(), ret.begin());\n\
    \    return ret;", "    std::vector<long> temp;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(temp));\n    return temp;",
  "\tstd::vector<long> result; // store all common elements\n\tstd::unordered_set<long>\
    \ s1(l1.begin(), l1.end()); // Set of unique elements of l1 \n\tstd::unordered_set<long>\
    \ s2(l2.begin(), l2.end()); // Set of unique elements of l2 \n\t\n\tauto it1 =\
    \ s1.begin();\n\tauto it2 = s2.begin();\n\t\n\tlong count = 0;\n\twhile (it1 !=\
    \ s1.end() && it2 != s2.end()) {\n\t\tif (*it1 == *it2) {\n\t\t\tresult.push_back(*it1);\n\
    \t\t\t++it1;\n\t\t\t++it2;\n\t\t\t++count;\n\t\t} else if (*it1 > *it2) {\n\t\t\
    \t++it1;\n\t\t} else {\n\t\t\t++it2;\n\t\t}\n\t}\n\t\n\treturn result;", "   \
    \ std::vector<long> res(l1.size());\n    std::vector<int> idx(l2.size(), -1);\n\
    \    for (size_t i = 0; i < l1.size(); ++i) res[i] = l1[i];\n    for (size_t i\
    \ = 0; i < l2.size(); ++i) {\n        int pos = std::lower_bound(idx.begin(),\
    \ idx.end(), l2[i]) - idx.begin();\n        if (pos < 0 || res[pos] != l2[i])\
    \ res[i] = -1;\n        else res[i] = res[pos];\n        idx[i] = pos;\n    }\n\
    \    return res;", "    // Create a set to store unique common elements.\n   \
    \ std::set<long> s1;\n    for (long i : l1) s1.insert(i);\n    for (long i : l2)\
    \ s1.insert(i);\n    // Copy unique common elements.\n    std::vector<long> result;\n\
    \    std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n     \
    \                   std::back_inserter(result));\n    return result;", "  std::vector<long>\
    \ result;\n  for (auto v : l1) {\n    if (std::find(l2.begin(), l2.end(), v) !=\
    \ l2.end()) {\n      result.push_back(v);\n    }\n  }\n  return result;", "  \
    \  if (l1.size() == 0)\n        return l2;\n    if (l2.size() == 0)\n        return\
    \ l1;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \n    std::vector<long> l3;\n    std::vector<long>::iterator it, it2;\n    for\
    \ (it = l1.begin(), it2 = l2.begin(); it != l1.end(); ++it, ++it2)\n        if\
    \ (*it == *it2) l3.push_back(*it);\n    return l3;", "    std::vector<long> v1;\n\
    \    std::vector<long> v2;\n    v1 = l1;\n    v2 = l2;\n    std::sort(v1.begin(),\
    \ v1.end());\n    std::sort(v2.begin(), v2.end());\n    v1.erase(\n        std::unique(\n\
    \            v1.begin(), v1.end(),\n            [&](const long &n1, const long\
    \ &n2) -> bool {\n                return (n1 < n2);\n            }),\n       \
    \ v1.end());\n    v2.erase(\n        std::unique(\n            v2.begin(), v2.end(),\n\
    \            [&](const long &n1, const long &n2) -> bool {\n                return\
    \ (n1 < n2);\n            }),\n        v2.end());\n    return (v1.size() > v2.size()\
    \ ? v1 : v2);", "    std::vector<long> res(l1.size());\n    bool match = false;\n\
    \    for (int i = 0; i < l1.size(); i++) {\n        for (int j = 0; j < l2.size();\
    \ j++) {\n            if (l1[i] == l2[j]) {\n                match = true;\n \
    \           }\n        }\n        if (match) {\n            res[i] = l1[i];\n\
    \            match = false;\n        }\n    }\n    return res;", "    long common\
    \ = 0;\n    std::vector<long> commonList;\n    commonList.push_back(common);\n\
    \    std::vector<long>::iterator it;\n    for (it = l1.begin(); it != l1.end();\
    \ ++it)\n        for (std::vector<long>::iterator it2 = l2.begin(); it2 != l2.end();\
    \ ++it2) {\n            if (*it == *it2)\n                common++;\n        \
    \    else\n                break;\n        }\n    std::vector<long>::iterator\
    \ it2;\n    for (it2 = l2.begin(); it2 != l2.end(); ++it2)\n        for (std::vector<long>::iterator\
    \ it1 = l1.begin(); it1 != l1.end(); ++it1) {\n            if (*it2 == *it1)\n\
    \                common++;\n            else\n                break;\n       \
    \ }\n    if (common == 0)\n        return commonList;\n    for (it = l1.begin();\
    \ it != l1.end(); ++it)\n        for (std::vector<long>::iterator it2 = l2.begin();\
    \ it2 != l2.end(); ++it2) {\n            if (*it == *it2)\n                continue;\n\
    \            else\n                break;\n        }\n    it2 = l2.begin();\n\
    \    for (std::vector<long>::iterator it1 = l1.begin(); it1 != l1.end(); ++it1)\n\
    \        for (std::vector<long>::iterator it2 = l2.begin(); it2 != l2.end(); ++it2)\
    \ {\n            if (*it1 == *it2)\n                continue;\n            else\n\
    \                break;\n        }\n    commonList.push_back(common);\n    return\
    \ commonList;", "  if (l1.size() == 0 || l2.size() == 0) {\n    return {};\n \
    \ }\n  std::vector<long> l3(l1);\n  std::set_intersection(l1.begin(), l1.end(),\
    \ l2.begin(), l2.end(),\n                        std::back_inserter(l3));\n  return\
    \ l3;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    std::vector<long> common_elem;\n    long i = 0; long j = 0, k = 0;\n    while\
    \ (l1[i] != l1[j] && l2[j] != l2[k]) {\n        if (l1[i] == l2[j])\n        \
    \    common_elem.push_back(l1[i]);\n        i++;\n        j++;\n        k++;\n\
    \    }\n    if (l2[j] == l2[k])\n        common_elem.push_back(l2[j]);\n    return\
    \ common_elem;", "  std::vector<long> v(l1.size());\n  for (long i = 0; i < l1.size();\
    \ i++) {\n    long j = 0;\n    for (; j < l2.size(); j++) {\n      if (l1[i] ==\
    \ l2[j])\n        break;\n    }\n    v[i] = l1[i];\n  }\n  v.erase(std::unique(v.begin(),\
    \ v.end()), v.end());\n  return v;", "   //Sorting before checking common elements\
    \ \n   std::sort(l1.begin(), l1.end());\n   std::sort(l2.begin(), l2.end());\n\
    \n   std::vector<long> result;\n   auto it1 = l1.begin();\n   auto it2 = l2.begin();\n\
    \   while (it1 != l1.end() && it2 != l2.end()) {\n      if (*it1 == *it2) {\n\
    \          result.push_back(*it1);\n          ++it1;\n          ++it2;\n     \
    \ } else if (*it1 < *it2) {\n         ++it1;\n      } else {\n         ++it2;\n\
    \      }\n   }\n   return result;", "  std::vector<long> res;\n  res.reserve(l1.size());\n\
    \  std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\n       \
    \                std::back_inserter(res));\n  return res;", "  std::set<long>\
    \ s1(l1);\n  std::set<long> s2(l2);\n  std::set_intersection(s1.begin(), s1.end(),\
    \ s2.begin(), s2.end(),\n                        std::back_inserter(result));\n\
    \  return result;", "    std::vector<long> r;\n    auto itr1 = l1.begin(), itr2\
    \ = l2.begin();\n    while (true) {\n        if (itr1 == l1.end() && itr2 == l2.end())\
    \ {\n            break;\n        } else if (itr1 == l1.end()) {\n            r.push_back(*itr2);\n\
    \            ++itr2;\n        } else if (itr2 == l2.end()) {\n            r.push_back(*itr1);\n\
    \            ++itr1;\n        } else if (*itr1 < *itr2) {\n            r.push_back(*itr1);\n\
    \            ++itr1;\n        } else {\n            r.push_back(*itr2);\n    \
    \        ++itr2;\n        }\n    }\n    return r;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    auto it1 = std::find(l1.begin(),\
    \ l1.end(), l2.begin());\n    auto it2 = std::find(l2.begin(), l2.end(), l1.begin());\n\
    \    std::vector<long> ret;\n    while (it1 != l1.end() && it2 != l2.end()) {\n\
    \        if (*it1 < *it2) {\n            ret.push_back(*it1);\n            ++it1;\n\
    \        } else if (*it2 < *it1) {\n            ret.push_back(*it2);\n       \
    \     ++it2;\n        } else {\n            ++it1;\n            ++it2;\n     \
    \   }\n    }\n    if (it1 != l1.end())\n        ret.insert(ret.end(), l1.begin(),\
    \ it1);\n    if (it2 != l2.end())\n        ret.insert(ret.end(), it2, l2.end());\n\
    \    return ret;", "    long long commonElements = 0;\n    if (l1.size() > l2.size())\
    \ {\n        l1.swap(l2);\n        l2.swap(l1);\n    }\n    for (long i = 0; i\
    \ < l1.size(); i++) {\n        for (long j = 0; j < l2.size(); j++) {\n      \
    \      if (l1[i] == l2[j]) {\n                commonElements++;\n            \
    \    break;\n            }\n        }\n        if (commonElements > 0) {\n   \
    \         break;\n        }\n    }\n    return std::vector<long>(l1.begin(), l1.begin()\
    \ + commonElements);", "    // Sort the given lists by comparing first with second\
    \ element\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n\
    \    // Store the common elements in a hash set\n    std::unordered_set<long>\
    \ common;\n    std::vector<long> result;\n    // Compare first elements with all\
    \ remaining elements\n    // If same then add it in result vector\n    for(int\
    \ i=0; i<l1.size(); i++) {\n        for(int j=0; j<l2.size(); j++) {\n       \
    \     if(i == j) continue;\n            if(l1.at(i) == l2.at(j)) {\n         \
    \       common.insert(l1.at(i));\n            }\n        }\n    }\n    // Return\
    \ sorted unique common elements\n    std::vector<long>::iterator it;\n    std::sort(common.begin(),\
    \ common.end());\n    it = std::unique(common.begin(), common.end());\n    for(;\
    \ it != common.end(); it++) {\n        result.push_back(*it);\n    }\n    return\
    \ result;", "    std::vector<long> result;\n    if (l1.size() != l2.size()) {\n\
    \        return result;\n    }\n    sort(l1.begin(), l1.end());\n    sort(l2.begin(),\
    \ l2.end());\n    result.assign(l1.begin(), l1.end());\n    std::set_intersection(l1.begin(),\
    \ l1.end(),\n                         l2.begin(), l2.end(),\n                \
    \         std::back_inserter(result));\n    return result;", "    // Return sorted\
    \ unique common elements for two lists.\n    std::sort(l1.begin(), l1.end());\n\
    \    std::sort(l2.begin(), l2.end());\n\n    auto i1 = l1.begin();\n    auto i2\
    \ = l2.begin();\n    auto j1 = l1.end();\n    auto j2 = l2.end();\n\n    while\
    \ (i1 != j1 && i2 != j2) {\n        if (*i1 == *i2) {\n            ++i1;\n   \
    \         ++i2;\n        } else if (*i1 < *i2) {\n            ++i1;\n        }\
    \ else {\n            ++i2;\n        }\n    }\n\n    // When there are fewer elements\
    \ in l1 than in l2, the common elements\n    // have no common elements.\n   \
    \ if (i1 == l1.end() && i2 == l2.end()) {\n        return std::vector<long>();\n\
    \    }\n\n    std::vector<long> c;\n    for (; i1 != j1; ++i1, ++i2) {\n     \
    \   if (*i1 != *i2) {\n            c.push_back(*i1);\n        }\n    }\n\n   \
    \ return c;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    if (l1.size() < l2.size()) {\n        std::reverse(l2.begin(),\
    \ l2.end());\n    }\n    std::vector<long> res = {l1[0]};\n    long i = 1;\n \
    \   for (auto j : l2) {\n        while (res.end() != std::find(res.begin(), res.end(),\
    \ j)) {\n            i++;\n            res.push_back(i);\n        }\n        res.push_back(j);\n\
    \    }\n    return res;", "        std::vector<long> vec;\n        std::set_intersection(l1.begin(),\
    \ l1.end(),\n                             l2.begin(), l2.end(),\n            \
    \                 std::back_inserter(vec));\n        return vec;", "    std::vector<long>\
    \ res;\n    // Find the first element\n    auto it1 = l1.begin();\n    auto it2\
    \ = l2.begin();\n    long first = *it1++;\n    while (it1 != l1.end() && it2 !=\
    \ l2.end() && *it1 == *it2) {\n        first++;\n        it1++;\n        it2++;\n\
    \    }\n    // If we have an equal number of elements, then they are equal\n \
    \   if (it1 == l1.end() && it2 == l2.end()) {\n        return res;\n    }\n  \
    \  // Else there are more elements in the first list, so use the first list to\
    \ find the common elements\n    else if (it1 == l1.end()) {\n        while (it2\
    \ != l2.end() && *it2 != first) {\n            it2++;\n        }\n        res.push_back(first);\n\
    \    }\n    // Else there are more elements in the second list, so use the second\
    \ list to find the common elements\n    else {\n        while (it1 != l1.end()\
    \ && *it1 != first) {\n            it1++;\n        }\n        res.push_back(first);\n\
    \    }\n    // Add the rest of the elements\n    while (it1 != l1.end()) {\n \
    \       res.push_back(*it1++);\n    }\n    while (it2 != l2.end()) {\n       \
    \ res.push_back(*it2++);\n    }\n    return res;", "    long result = 0;\n   \
    \ std::vector<long>::iterator it1 = l1.begin(), it2 = l2.begin();\n    for (;\
    \ it1 != l1.end() && it2 != l2.end(); it1++, it2++) {\n        if (*it1 != *it2)\
    \ result++;\n    }\n    if (it1 != l1.end()) result = std::min(result, it1 - l1.begin());\n\
    \    if (it2 != l2.end()) result = std::min(result, it2 - l2.begin());\n    return\
    \ std::vector<long>(l1.begin() + result, l1.end());", "    std::vector<long> result;\n\
    \    result.push_back(l1.front());\n    for(long i = l1.begin()+1; i<l1.end();\
    \ i++ )\n    {\n        auto it=std::find(l2.begin(),l2.end(),l1[i]);\n      \
    \  if(it!=l2.end())\n        {\n            result.push_back(l1[i]);\n       \
    \     l1.erase(it);\n        }\n    }\n    return result;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n\n    std::vector<long> result;\n\
    \    result.push_back(l1[0]);\n    long i = 0;\n    while (i < l1.size() && i\
    \ < l2.size()) {\n        if (l1[i] == l2[i]) {\n            result.push_back(l1[i]);\n\
    \            ++i;\n            continue;\n        }\n        else if (l1[i] <\
    \ l2[i]) {\n            ++i;\n            continue;\n        }\n        else {\n\
    \            result.push_back(l2[i]);\n            ++i;\n        }\n    }\n  \
    \  return result;", "    // Sort lists in ascending order\n    std::vector<long>\
    \ l3 = l1;\n    std::sort(l3.begin(), l3.end());\n    std::vector<long> l4 = l2;\n\
    \    std::sort(l4.begin(), l4.end());\n    \n    // Sort the elements of both\
    \ lists\n    std::vector<long> l5 = l1;\n    std::vector<long> l6 = l2;\n    \n\
    \    for (size_t i = 0; i < l1.size(); i++) {\n        // Find the first element\
    \ which is different\n        size_t j = i + 1;\n        while (j < l5.size()\
    \ && l5[j] == l3[i]) {\n            ++j;\n        }\n        \n        // Find\
    \ the next element which is different\n        size_t k = j + 1;\n        while\
    \ (k <l6.size() && l6[k] == l4[i]) {\n            ++k;\n        }\n        \n\
    \        // If the two elements are different then\n        // append the larger\
    \ one to the result\n        if (j < k && j + 1 != l5.size()) {\n            l5.erase(l5.begin()\
    \ + j);\n        }\n        \n        if (k < l && k + 1 != l6.size()) {\n   \
    \         l6.erase(l6.begin() + k);\n        }\n    }\n    \n    // Return the\
    \ result \n    return l5;", "    std::vector<long> l3;\n    long i1 = 0, i2 =\
    \ 0;\n    long ans = 0;\n\n    while (i1 < l1.size() && i2 < l2.size()) {\n  \
    \      if (l1[i1] < l2[i2]) {\n            l3.push_back(l1[i1]);\n           \
    \ i1++;\n        } else {\n            l3.push_back(l2[i2]);\n            i2++;\n\
    \        }\n    }\n\n    while (i1 < l1.size()) {\n        l3.push_back(l1[i1]);\n\
    \        i1++;\n    }\n\n    while (i2 < l2.size()) {\n        l3.push_back(l2[i2]);\n\
    \        i2++;\n    }\n\n    for (long i = 0; i < l3.size(); i++) {\n        if\
    \ (l3[i] < ans)\n            ans = l3[i];\n    }\n    return l3;", "    assert(l1.size()\
    \ == l2.size());\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::vector<long> result(l1.size());\n    for (size_t i = 0;\
    \ i < l1.size(); ++i) {\n        if (l1[l1.size() - i - 1] == l2[i]) {\n     \
    \       result[l1.size() - i - 1] = l1[l1.size() - i - 1];\n        }\n    }\n\
    \    return result;", "    std::vector<long> result;\n    if (l1.size() == 0 ||\
    \ l2.size() == 0) return result;\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    auto itl1 = l1.begin();\n    auto itl2 = l2.begin();\n    std::set_intersection(l1.begin(),\
    \ l1.end(),\n                         l2.begin(), l2.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n    std::set_intersection(l2.begin(),\
    \ l2.end(),\n                         l1.begin(), l1.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it3 = l1.begin();\n    auto it4 = l2.begin();\n    std::set_intersection(l1.begin(),\
    \ l1.end(),\n                         l4.begin(), l4.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it4 = l1.begin();\n    auto it5 = l2.begin();\n    std::set_intersection(l4.begin(),\
    \ l4.end(),\n                         l1.begin(), l1.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it5 = l1.begin();\n    auto it6 = l2.begin();\n    std::set_intersection(l5.begin(),\
    \ l5.end(),\n                         l1.begin(), l1.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it6 = l1.begin();\n    auto it7 = l2.begin();\n    std::set_intersection(l6.begin(),\
    \ l6.end(),\n                         l1.begin(), l1.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it7 = l1.begin();\n    auto it8 = l2.begin();\n    std::set_intersection(l7.begin(),\
    \ l7.end(),\n                         l1.begin(), l1.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it8 = l1.begin();\n    auto it9 = l2.begin();\n    std::set_intersection(l8.begin(),\
    \ l8.end(),\n                         l1.begin(), l1.end(),\n                \
    \         std::back_inserter(result));\n    std::sort(result.begin(), result.end());\n\
    \    auto it9 = l1.begin();\n    auto it10 = l2.begin();\n    std::set_intersection(l9.begin(),\
    \ l9.end(),\n", "\tstd::vector<long> res;\n\tstd::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(res));\n\treturn res;", " \
    \ std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::vector<long>\
    \ common(l1.size());\n  std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(),\n      common.begin());\n  std::sort(common.begin(), common.end());\n\
    \  return common;", "  // TODO: write code here\n  return l1;", "    std::vector<long>\
    \ common;\n    std::set_union(l1.begin(), l1.end(), l2.begin(), l2.end(), std::back_inserter(common));\n\
    \    return common;", "  // Sort the lists to make them easier to compare\n  std::sort(l1.begin(),\
    \ l1.end());\n  std::sort(l2.begin(), l2.end());\n  // Find out unique elements\
    \ in both lists\n  auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(), std::back_inserter(std::back_inserter(result)));\n  // Return unique\
    \ elements only\n  return std::vector<long>(std::begin(it), std::end(it));", " \
    \   std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n \
    \   std::vector<long> result;\n    result.push_back(l1.front());\n    auto it_found\
    \ = std::find(l2.begin(), l2.end(), l1.front());\n    if (it_found != l2.end())\
    \ {\n        while (it_found != l2.end() && *it_found == l1.front()) {\n     \
    \       it_found = std::find(it_found + 1, l2.end(), l1.front());\n        }\n\
    \        result.push_back(*it_found);\n    }\n    return result;", "  std::set<long>\
    \ s1;\n  std::set<long> s2;\n  for (long i : l1) s1.insert(i);\n  for (long i\
    \ : l2) s2.insert(i);\n  return s1 & s2;", "    std::vector<long> v;\n    std::set_intersection(l1.begin(),\
    \ l1.end(),\n                         l2.begin(), l2.end(),\n                \
    \         std::back_inserter(v));\n    return v;", "  std::vector<long> ans;\n\
    \  int i = 0, j = 0, k = 0;\n  while (i<l1.size() && j<l2.size()) {\n    if (l1[i]\
    \ == l2[j]) {\n      ans.push_back(l1[i]);\n      i++;\n      j++;\n    } else\
    \ if (l1[i] < l2[j]) {\n      i++;\n    } else {\n      j++;\n    }\n  }\n  while\
    \ (i < l1.size()) {\n    ans.push_back(l1[i]);\n    i++;\n  }\n  while (j < l2.size())\
    \ {\n    ans.push_back(l2[j]);\n    j++;\n  }\n  return ans;", "  std::vector<long>\
    \ result;\n  if (l1.size() <= l2.size())\n    result = l1;\n  else\n    result\
    \ = l2;\n\n  std::sort(result.begin(), result.end());\n  std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n                        std::back_inserter(result));\n\
    \  std::sort(result.begin(), result.end());\n\n  return result;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    std::vector<long> result;\n\
    \    auto i1 = l1.begin(), i2 = l2.begin();\n    long common = 0;\n    while (i1\
    \ != l1.end() && i2 != l2.end() && *i1 == *i2) {\n        common++;\n        result.push_back(*i1++);\n\
    \        ++i2;\n    }\n    while (common) {\n        common--;\n        ++i1;\n\
    \        ++i2;\n    }\n    std::reverse(result.begin(), result.end());\n    return\
    \ result;", "    int i1=0;\n    int i2=0;\n    std::vector<long> ans;\n    while\
    \ (i1<l1.size() && i2<l2.size()) {\n        if (l1[i1] == l2[i2]) ans.push_back(l1[i1]);\n\
    \        i1++;\n        i2++;\n    }\n    return ans;", "    // Create a sorted\
    \ set from the first list.\n    std::vector<long> s1_l1;\n    for(auto e : l1)\
    \ s1_l1.push_back(e);\n    std::sort(s1_l1.begin(), s1_l1.end());\n    \n    //\
    \ Create a sorted set from the second list.\n    std::vector<long> s2_l2;\n  \
    \  for(auto e : l2) s2_l2.push_back(e);\n    std::sort(s2_l2.begin(), s2_l2.end());\n\
    \n    std::vector<long> common(s1_l1.size());\n    for(auto it = s1_l1.begin();\
    \ it != s1_l1.end(); ++it) {\n        for(auto it2 = s2_l2.begin(); it2 != s2_l2.end();\
    \ ++it2) {\n            if(*it == *it2) common[s1_l1.size() - 1 - it] = *it;\n\
    \        }\n    }\n\n    return common;", "  std::vector<long> result;\n  long\
    \ i = 0, j = 0;\n  long n1, n2;\n\n  while ((i < l1.size()) && (j < l2.size()))\
    \ {\n    n1 = l1[i];\n    n2 = l2[j];\n\n    if (n1 < n2) {\n      i++;\n    }\n\
    \    else {\n      j++;\n    }\n\n    if (i == l1.size()) {\n      result.push_back(n1);\n\
    \    }\n    else if (j == l2.size()) {\n      result.push_back(n2);\n    }\n \
    \   else {\n      while ((i < l1.size()) && (j < l2.size())) {\n        n1 = l1[i];\n\
    \        n2 = l2[j];\n\n        if (n1 < n2) {\n          i++;\n        }\n  \
    \      else {\n          j++;\n        }\n      }\n\n      if (i == l1.size())\
    \ {\n        result.push_back(n1);\n      }\n      else if (j == l2.size()) {\n\
    \        result.push_back(n2);\n      }\n      else {\n        // If n1 is greater\
    \ than n2, we do not add this number to result.\n        while ((i < l1.size())\
    \ && (j < l2.size())) {\n          n1 = l1[i];\n          n2 = l2[j];\n\n    \
    \      if (n1 == n2) {\n            result.push_back(n1);\n          }\n     \
    \     else if (n1 > n2) {\n            j++;\n          }\n          else {\n \
    \           i++;\n          }\n        }\n\n        if (i == l1.size()) {\n  \
    \        result.push_back(n1);\n        }\n        else if (j == l2.size()) {\n\
    \          result.push_back(n2);\n        }\n      }\n    }\n  }\n\n  // Return\
    \ unique elements of the result.\n  std::sort(result.begin(), result.end());\n\
    \  return result;", "  std::set<long> s1;\n  std::set<long> s2;\n  for (int i\
    \ = 0; i < l1.size(); i++) s1.insert(l1[i]);\n  for (int i = 0; i < l2.size();\
    \ i++) s2.insert(l2[i]);\n  return std::vector<long>(s1.begin(), s1.end()); ",
  "    std::vector<long> out;\n    out.insert(out.end(), l1.begin(), l1.end());\n\
    \    out.insert(out.end(), l2.begin(), l2.end());\n    std::sort(out.begin(),\
    \ out.end());\n    return out;", "    std::vector<long> common(l1.size() + l2.size());\n\
    \    int i = 0, j = 0;\n    // traverse through all elements in both lists\n \
    \   while (i < l1.size() && j < l2.size()) {\n        // if current element is\
    \ equal in both lists, then add it to the result list\n        if (l1[i] == l2[j])\
    \ {\n            common[i + j + 1] = l1[i];\n            i += 1;\n           \
    \ j += 1;\n        }\n        // if current element is not equal in both lists,\
    \ then move on to the next element\n        else {\n            i += 1;\n    \
    \        j += 1;\n        }\n    }\n    return common;", "    int i = 0;\n   \
    \ int j = 0;\n    int count = 0;\n    int len = l1.size();\n    // find common\
    \ elements until end of list1\n    while (i < len) {\n        for (j = 0; j <\
    \ len; j++) {\n            if (l1[i] == l2[j]) {\n                count++;\n \
    \               break;\n            }\n        }\n        i++;\n    }\n    int\
    \ i = 0;\n    len = l2.size();\n    // find common elements until end of list2\n\
    \    while (i < len) {\n        for (j = 0; j < len; j++) {\n            if (l1[i]\
    \ == l2[j]) {\n                count--;\n                break;\n            }\n\
    \        }\n        i++;\n    }\n    std::vector<long> result;\n    if (count\
    \ > 0) {\n        for (int i = 0; i < len; i++)\n            result.push_back(l1[i]);\n\
    \    } else if (count < 0) {\n        for (int i = 0; i < len; i++)\n        \
    \    result.push_back(l2[i]);\n    } else {\n        for (int i = 0; i < len;\
    \ i++)\n            result.push_back(l1[i]);\n    }\n    return result;", "  \
    \  std::vector<long> list;\n    auto it1 = l1.begin();\n    auto it2 = l2.begin();\n\
    \    while (it1 != l1.end() && it2 != l2.end()) {\n        if (*it1 == *it2) {\n\
    \            list.push_back(*it1);\n            ++it1;\n            ++it2;\n \
    \       } else if (*it1 < *it2) {\n            ++it1;\n        } else {\n    \
    \        ++it2;\n        }\n    }\n    return list;", "    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    long commonCount = 0;\n\
    \    long minCount = l1[0];\n    for (size_t i = 0; i < l1.size(); i++) {\n  \
    \      for (size_t j = 0; j < l2.size(); j++) {\n            if (l1[i] == l2[j])\
    \ {\n                commonCount++;\n                if (commonCount > minCount)\
    \ {\n                    minCount = commonCount;\n                }\n        \
    \    }\n        }\n    }\n    std::vector<long> result{minCount};\n    for (size_t\
    \ i = 0; i < l1.size(); i++) {\n        for (size_t j = 0; j < l2.size(); j++)\
    \ {\n            if (l1[i] == l2[j]) {\n                commonCount--;\n     \
    \           result.push_back(l1[i]);\n                break;\n            }\n\
    \        }\n    }\n    return result;", "    std::vector<long> vResult;\n    //\
    \ Find first item in list that isn't in other\n    auto it1= std::find_if(l1.begin(),l1.end(),[](long\
    \ i) { return std::find(l2.begin(),l2.end(),i)==l2.end(); });\n    // If l1 has\
    \ any item, find first in l2 that isn't in l1, and put in vResult\n    if (it1\
    \ != l1.end()) {\n        std::find_if(l2.begin(),l2.end(),[&](long i) { return\
    \ std::find(l1.begin(),l1.end(),i)==l1.end(); }).first;\n    }\n    // If no match,\
    \ return empty\n    if (it1==l1.end()) {\n        vResult.clear();\n    }\n  \
    \  // If no match found in l1, find l2 matches and add them\n    if (it1==l1.end())\
    \ vResult.insert(vResult.end(),l2.begin(),l2.end());\n    // If no match found\
    \ in l2, add them all\n    if (it1==l1.end()) vResult.insert(vResult.end(),l1.begin(),l1.end());\n\
    \    // Return unique common elements\n    return std::move(vResult);", "    std::vector<long>\
    \ temp;\n    // Create a vector of sorted unique elements.\n    std::sort(l1.begin(),\
    \ l1.end());\n    std::sort(l2.begin(), l2.end());\n    temp.assign(l1.size());\n\
    \    long i=0;\n    while (i<l1.size() && i<l2.size()) {\n        if (l1[i]==l2[i])\n\
    \            temp.push_back(l1[i]);\n        else if (l1[i]<l2[i])\n         \
    \   i++;\n        else\n            i++;\n    }\n    return temp;", "    std::vector<long>\
    \ result;\n    long size = l1.size();\n    // find common elements\n    for (int\
    \ i = 0; i < size; i++) {\n        long a = l1[i];\n        long b = l2[i];\n\
    \        while (a != b) {\n            if (a > b)\n                std::swap(a,\
    \ b);\n            else {\n                std::swap(a, result);\n           \
    \     a--;\n            }\n        }\n    }\n    return result.begin(), result.end();",
  "  std::sort(l1.begin(), l1.end());\n  std::sort(l2.begin(), l2.end());\n  std::vector<long>\
    \ r;\n  auto it1 = l1.begin();\n  auto it2 = l2.begin();\n  while (it1 != l1.end()\
    \ && it2 != l2.end()) {\n    if (*it1 != *it2) {\n      break;\n    }\n    r.push_back(*it1++);\n\
    \    it2++;\n  }\n  return r;", "    std::vector<long> retval;\n    if (l1.size()\
    \ != l2.size()) {\n        retval.clear();\n        return retval;\n    }\n  \
    \  auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(), l2.end(),\
    \ std::back_inserter(retval));\n    if (it == l1.end() && it == l2.end()) {\n\
    \        return retval;\n    } else {\n        return retval;\n    }", "    std::vector<long>\
    \ result;\n    l1.insert(l1.begin(), std::make_move_iterator(l2.begin()));\n \
    \   std::sort(l1.begin(), l1.end());\n    for (long l : l1) {\n        if (l1\
    \ != l2) {\n            long l3 = std::find(l2.begin(), l2.end(), l);\n      \
    \      if (l3 != l2.end())\n                l2.erase(l3);\n        }\n       \
    \ result.push_back(l);\n    }\n    return result;", "    // Create map of elements\
    \ and count.\n    std::map<long, long> map;\n    for (long i : l1) map[std::abs(i)]\
    \ += 1;\n    for (long i : l2) map[std::abs(i)] += 1;\n    // Sort based on count\
    \ and values.\n    std::map<long, std::vector<long> > sorted_map;\n    for (std::map<long,\
    \ long>::iterator it = map.begin(); it != map.end(); ++it) {\n        sorted_map[it->second].push_back(it->first);\n\
    \    }\n    // Copy into vector.\n    std::vector<long> res;\n    for (std::map<long,\
    \ std::vector<long> >::iterator it = sorted_map.begin(); it != sorted_map.end();\
    \ ++it) {\n        if (it->second.size() == 1) res.push_back(it->second.front());\n\
    \        else {\n            for (long j : it->second) {\n                std::swap(res[res.size()\
    \ - 1], res[res.size() - j + 1]);\n            }\n            res.resize(res.size()\
    \ / 2);\n        }\n    }\n    return res;", "    std::vector<long> ret;\n   \
    \ std::vector<long> tmp;\n    for (size_t i = 0; i < l1.size(); i++) {\n     \
    \   for (size_t j = 0; j < l2.size(); j++) {\n            if (l1[i] == l2[j])\
    \ {\n                if (tmp.size() == 0) {\n                    ret.push_back(l1[i]);\n\
    \                } else {\n                    if (ret.size() >= ret.back()) {\n\
    \                        ret.push_back(l1[i]);\n                    }\n      \
    \          }\n                break;\n            }\n        }\n    }\n    return\
    \ ret;", "    if (l1.size() < l2.size()) {\n        return common(l2, l1);\n \
    \   }\n    long mid = l1.size() / 2;\n    std::vector<long> l3 = common(l1, std::next(l1.begin(),\
    \ mid));\n    std::vector<long> l4 = common(std::next(l1.begin(), mid), l2);\n\
    \    l3.insert(l3.end(), l4.begin(), l4.end());\n    return l3;", "    std::vector<long>\
    \ result;\n    result.push_back(0);\n    result.push_back(l1[0]);\n    result.push_back(l2[0]);\n\
    \n    size_t mid = result.size() / 2;\n\n    for (size_t i = 1; i < mid; ++i)\n\
    \        if (l1[i] != l2[i])\n            result.push_back(l1[i]);\n\n    for\
    \ (size_t i = mid; i < result.size(); ++i)\n        if (l1[i] != l2[i])\n    \
    \        result.push_back(l1[i]);\n\n    result.push_back(l1[mid]);\n    result.push_back(l2[mid]);\n\
    \n    return result;", "  if (l1.size() != l2.size()) return std::vector<long>();\n\
    \  std::vector<long> v1(l1.size());\n  std::vector<long> v2(l2.size());\n  //\
    \ Using set data structure to find unique elements\n  for (long i = 0; i < l1.size();\
    \ i++) {\n    v1[i] = l1[i];\n  }\n  for (long i = 0; i < l2.size(); i++) {\n\
    \    v2[i] = l2[i];\n  }\n  std::set<long> v1set(v1.begin(), v1.end());\n  std::set<long>\
    \ v2set(v2.begin(), v2.end());\n  std::vector<long> common;\n  while (!v1set.empty()\
    \ && !v2set.empty()) {\n    if (v1set.find(v2set.begin()) == v1set.end()) {\n\
    \      common.push_back(v1set.front());\n      v1set.erase(v1set.begin());\n \
    \   } else {\n      common.push_back(v2set.front());\n      v2set.erase(v2set.begin());\n\
    \    }\n  }\n  return common;", "    assert(l1.size() == l2.size());\n    std::vector<long>\
    \ l3;\n    for (auto &i: l1) {\n        for (auto &j: l2) {\n            if (i\
    \ == j) {\n                l3.push_back(i);\n                break;\n        \
    \    }\n        }\n    }\n    return l3;", "  assert(l1.size() == l2.size());\n\
    \n  // Sort the lists.\n  auto it1 = l1.begin();\n  auto it2 = l2.begin();\n \
    \ sort(it1, it1 + l1.size());\n  sort(it2, it2 + l2.size());\n\n  std::vector<long>\
    \ l3;\n  while (it1 != l1.end() && it2 != l2.end()) {\n    if (*it1 == *it2) {\n\
    \      ++it1;\n      ++it2;\n    } else {\n      // Check if current element is\
    \ larger.\n      if (*it1 > *it2) {\n        l3.push_back(*it2);\n        it2++;\n\
    \      } else {\n        l3.push_back(*it1);\n        it1++;\n      }\n    }\n\
    \  }\n  return l3;", "    // Create a set for the first list, then add all the\
    \ elements of l1 to the set.\n    std::set<long> s1;\n    for(long i : l1)\n \
    \       s1.insert(i);\n\n    // Create a set for the second list, then add all\
    \ the elements of l2 to\n    // the set.\n    std::set<long> s2;\n    for(long\
    \ i : l2)\n        s2.insert(i);\n\n    // Get the elements common to both sets.\n\
    \    std::vector<long> common;\n    for(std::set<long>::iterator it1 = s1.begin();\
    \ it1 != s1.end(); it1++) {\n        std::set<long>::iterator it2 = s2.find(*it1);\n\
    \        if(it2 != s2.end())\n            common.push_back(*it1);\n    }\n   \
    \ return common;", "    std::vector<long> result(l1.size());\n    long k = 0;\n\
    \    long l = 0;\n    // If both lists have only one element then return that\
    \ element.\n    if (l1.size() == l2.size()) {\n        return result = {l1[0],\
    \ l2[0]};\n    }\n    // Go through both lists and compare elements. If common\
    \ element found then increment k and compare with next element.\n    for (size_t\
    \ i = 0; i < l1.size(); i++) {\n        if (l2[i] == l1[i]) {\n            k =\
    \ i;\n            l++;\n        } else {\n            // If the list contain more\
    \ elements than the size of the result then add the next element to result and\
    \ start comparison from the beginning.\n            if (l == result.size()) {\n\
    \                result.push_back(l1[i]);\n                result.push_back(l2[i]);\n\
    \                l = 1;\n                k = i;\n            } else {\n      \
    \          // If no common element found then add the elements to result and start\
    \ comparison from beginning of list.\n                while (l < result.size()\
    \ && result[l] < l1[i]) {\n                    result.push_back(l1[k]);\n    \
    \                l++;\n                    k++;\n                }\n         \
    \       while (l < result.size() && result[l] == l2[i]) {\n                  \
    \  l++;\n                }\n                result.push_back(l1[k]);\n       \
    \         result.push_back(l2[i]);\n                l++;\n                k =\
    \ i;\n            }\n        }\n    }\n    return result;", "    // Create a set\
    \ from l2 and then iterate over the elements in l1 adding them to the set.\n \
    \   std::set<long> set2 = l2;\n    std::vector<long> l3;\n    for (auto it = l1.begin();\
    \ it != l1.end(); ++it) {\n        if (set2.find(*it) == set2.end()) {\n     \
    \       l3.push_back(*it);\n        }\n    }\n    return l3;", "  std::vector<long>\
    \ common;\n  l1.insert(l1.begin(), 0);\n  l2.insert(l2.begin(), 0);\n  while (l1.size()\
    \ > 0 && l2.size() > 0) {\n    int m = (l1.size() < l2.size()) ? l1.size() : l2.size();\n\
    \    int t = (l1.size() < l2.size()) ? l1.size() : l2.size();\n    for (int i\
    \ = 0; i < m; i++) {\n      if (l1.at(i) == l2.at(i)) {\n        common.push_back(static_cast<long>(l1.at(i)));\n\
    \        l1.erase(l1.begin() + i);\n        l2.erase(l2.begin() + i);\n      \
    \  break;\n      }\n    }\n  }\n  while (l1.size() > 0) {\n    common.push_back(static_cast<long>(l1.at(l1.size()\
    \ - 1)));\n    l1.erase(l1.begin() + l1.size() - 1);\n  }\n  while (l2.size()\
    \ > 0) {\n    common.push_back(static_cast<long>(l2.at(l2.size() - 1)));\n   \
    \ l2.erase(l2.begin() + l2.size() - 1);\n  }\n  return common;", "    std::vector<long>\
    \ ans(l1.size());\n    std::set_intersection(l1.begin(), l1.end(),\n         \
    \                l2.begin(), l2.end(),\n                         std::back_inserter(ans));\n\
    \    return ans;", "    std::vector<long> v(l1.size() + l2.size());\n    int j\
    \ = 0;\n    for (int i = 0; i < l1.size(); ++i) v[i] = l1[i];\n    for (int i\
    \ = 0; i < l2.size(); ++i) v[i + l1.size()] = l2[i];\n    j = 0;\n    for (int\
    \ i = 0; i < v.size(); ++i) while (std::find(v.begin(), v.end(), v[i]) != v.end())\n\
    \        v[j++] = v[i];\n    return v;", "  std::vector<long> temp;\n  std::set<long>\
    \ s1;\n  std::set<long> s2;\n  for (long i : l1) {\n    s1.insert(i);\n  }\n \
    \ for (long i : l2) {\n    s2.insert(i);\n  }\n  for (long i : s1) {\n    temp.push_back(i);\n\
    \  }\n  for (long i : s2) {\n    temp.push_back(i);\n  }\n  std::sort(temp.begin(),\
    \ temp.end());\n  return temp;", "  std::vector<long> l3;\n  std::unordered_set<long>\
    \ h;\n  // find unique elements\n  for(long i : l1) h.insert(i);\n  for(long i\
    \ : l2) h.insert(i);\n  for(long i : h) l3.push_back(h.find(i));\n  return l3;",
  "    // Sort the lists.\n    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n\n    // Find which lists have nothing in common\n    // std::vector<bool>\
    \ empty(l1.size(), true);\n    // std::vector<bool> same(l1.size(), false);\n\
    \    std::vector<long> res = {0};\n    std::vector<long> same(l1.size(), 0);\n\
    \n    // Loop through the lists, comparing elements of the lists.\n    for(std::size_t\
    \ i = 0; i < l1.size(); i++) {\n        for(std::size_t j = 0; j < l2.size();\
    \ j++) {\n            if(l1[i] == l2[j]) {\n                // Same element\n\
    \                same[i] += 1;\n                break;\n            }\n      \
    \  }\n    }\n\n    // Add the common elements.\n    for(std::size_t i = 0; i <\
    \ same.size(); i++) {\n        if(same[i] > 0) {\n            res.push_back(l1[i]);\n\
    \        }\n    }\n\n    return res;", "  assert(l1.size() > 0 && l2.size() >\
    \ 0);\n  std::vector<long> res;\n  \n  // Sort the lists l1 and l2\n  auto it1\
    \ = l1.begin();\n  auto it2 = l2.begin();\n  while (it1 != l1.end() && it2 !=\
    \ l2.end()) {\n    if (*it2 < *it1) {\n      it2++;\n    } else {\n      res.push_back(*it1);\n\
    \      it1++;\n    }\n  }\n  while (it1 != l1.end()) {\n    res.push_back(*it1);\n\
    \    it1++;\n  }\n  while (it2 != l2.end()) {\n    res.push_back(*it2);\n    it2++;\n\
    \  }\n  return res;", "    std::vector<long> common;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(common));\n    return common;",
  "  std::vector<long> c;\n  // Find intersection of first and second list\n  for\
    \ (auto i : l1)\n    if (std::find(l2.begin(), l2.end(), i) != l2.end()) c.push_back(i);\n\
    \  return c;", "    std::vector<long> result;\n    for (long i: l1) {\n      \
    \  for (long j: l2) {\n            if (i == j) {\n                continue;\n\
    \            }\n            if (std::find(result.begin(), result.end(), j) ==\
    \ result.end()) {\n                result.push_back(j);\n            }\n     \
    \   }\n    }\n    return result;", "    std::vector<long> result;\n    if (l1.size()\
    \ == 0 || l2.size() == 0) {\n        return result;\n    }\n    auto l3 = std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(),\n            std::back_inserter(result));\n\
    \    auto l4 = std::set_difference(l3.begin(), l3.end(), l2.begin(), l2.end(),\n\
    \            std::back_inserter(result));\n    if (result.size() != l2.size())\
    \ {\n        std::set_difference(l1.begin(), l1.end(), l4.begin(), l4.end(),\n\
    \                std::back_inserter(result));\n    }\n    return result;", " \
    \   // Create a set to store common elements in.\n    std::set<long> s1;\n   \
    \ std::set<long> s2;\n    // Iterate through both lists.\n    for (long i : l1)\
    \ {\n        // If we haven't seen this element before, add it to our set.\n \
    \       if (!s1.count(i))\n            s1.insert(i);\n    }\n    for (long i :\
    \ l2) {\n        // If we haven't seen this element before, add it to our set.\n\
    \        if (!s2.count(i))\n            s2.insert(i);\n    }\n    // Return the\
    \ set as a vector.\n    return s1;", "    std::vector<long> u;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(u));\n    return u;", " \
    \   // TODO: Write code here.\n    long long int i=0,j=0;\n    std::vector<long>\
    \ result;\n    while(i<l1.size() && j<l2.size()) {\n        if(l1[i]==l2[j])\n\
    \            result.push_back(l1[i]);\n        i++;\n        j++;\n    }\n   \
    \ return result;", "    std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(),\
    \ l2.end());\n    std::vector<long> common;\n    long i = 0;\n    long j = 0;\n\
    \    while (l1.size() > 0 && l2.size() > 0){\n        if (l1[i] == l2[j]){\n \
    \           l1.erase(l1.begin()+i);\n            l2.erase(l2.begin()+j);\n   \
    \     } else if (l1[i] > l2[j]){\n            i++;\n        } else {\n       \
    \     j++;\n        }\n    }\n    return l1;", "    int n = l1.size();\n    auto\
    \ it1 = l1.begin(), it2 = l2.begin();\n    std::vector<long> res;\n    int m =\
    \ 0;\n    int k = 0;\n    while (it1 != l1.end() && it2 != l2.end()) {\n     \
    \   if (*it1 < *it2) k++;\n        else m++;\n        ++it1;\n        ++it2;\n\
    \    }\n    // If lists are of same size, find common elements\n    if (n == m)\
    \ {\n        std::vector<long>::iterator it;\n        for (it = l1.begin(); it\
    \ != l1.end(); ++it)\n            if (l2.find(*it) != l2.end()) res.push_back(*it);\n\
    \    }\n    return res;", "    std::vector<long> v1,v2;\n    long max1=std::numeric_limits<long>::min(),\n\
    \           min1=std::numeric_limits<long>::max();\n    // find max and min element\
    \ from lists\n    for(long i=0;i<l1.size();i++){\n        max1=max(max1,l1[i]);\n\
    \        min1=min(min1,l1[i]);\n    }\n    for(long i=0;i<l2.size();i++){\n  \
    \      max1=max(max1,l2[i]);\n        min1=min(min1,l2[i]);\n    }\n    long diff=max1-min1;\n\
    \    // sort list\n    for(long i=0;i<l1.size();i++){\n        v1.push_back(l1[i]-diff);\n\
    \    }\n    for(long i=0;i<l2.size();i++){\n        v2.push_back(l2[i]-diff);\n\
    \    }\n    // remove duplicates\n    v1.erase(std::unique(v1.begin(),v1.end()),v1.end());\n\
    \    v2.erase(std::unique(v2.begin(),v2.end()),v2.end());\n    return v1;", " \
    \   std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n \
    \   std::vector<long> u;\n    u.push_back(l1[0]);\n    for(size_t i = 1; i < l1.size();\
    \ i++) {\n        if(l1[i] != l1[i-1]) {\n            u.push_back(l1[i]);\n  \
    \      }\n    }\n    u.push_back(l2[0]);\n    for(size_t i = 1; i < l2.size();\
    \ i++) {\n        if(l2[i] != l2[i-1]) {\n            u.push_back(l2[i]);\n  \
    \      }\n    }\n    return u;", "    std::vector<long> res;\n    std::set_intersection(l1.begin(),\
    \ l1.end(), l2.begin(), l2.end(), std::back_inserter(res));\n    return res;",
  "  std::vector<long> result;\n  long n1 = l1.size();\n  long n2 = l2.size();\n \
    \ // If the lists are of different size return empty list.\n  if (n1 != n2) {\n\
    \    return result;\n  }\n  // Sort the lists and compare.\n  std::sort(l1.begin(),\
    \ l1.end());\n  std::sort(l2.begin(), l2.end());\n  long i = 0, j = 0;\n  while\
    \ (i < n1 && j < n2) {\n    if (l1[i] == l2[j])\n      result.push_back(l1[i]);\n\
    \    i++;\n    j++;\n  }\n  // If lists are of same size remove duplicated elements.\n\
    \  if (i == n1) {\n    auto itr = std::unique(l2.begin(), l2.end());\n    for\
    \ (; itr != l2.end(); ++itr)\n      result.push_back(*itr);\n  } else if (j ==\
    \ n2) {\n    auto itr = std::unique(l1.begin(), l1.end());\n    for (; itr !=\
    \ l1.end(); ++itr)\n      result.push_back(*itr);\n  }\n  return result;", " \
    \   std::sort(l1.begin(), l1.end());\n    std::sort(l2.begin(), l2.end());\n \
    \   std::vector<long> common;\n    long l1 = l1[0];\n    long l2 = l2[0];\n  \
    \  while(l1 != l2) {\n        common[l1++] = l2;\n        l1--;\n        l2--;\n\
    \    }\n    std::sort(common.begin(), common.end());\n    return common;", " \
    \   // Sort the two lists.\n    auto comp = [](long l, long r){ return (l < r);\
    \ };\n    std::sort(l1.begin(), l1.end(), comp);\n    std::sort(l2.begin(), l2.end(),\
    \ comp);\n\n    auto it = std::set_intersection(l1.begin(), l1.end(), l2.begin(),\
    \ l2.end(),\n                                    [](long l, long r){ return (l\
    \ < r); });\n    auto end = l1.end();\n    // Return unique common elements.\n\
    \    return std::vector<long>(it, end);", "        std::vector<long> result;\n\
    \        std::set<long> m1, m2;\n        for (int i = 0; i < l1.size(); i++)\n\
    \                m1.insert(l1[i]);\n        for (int i = 0; i < l2.size(); i++)\n\
    \                m2.insert(l2[i]);\n        for (auto it = m1.begin(); it != m1.end();\
    \ ++it)\n                if (m2.find(*it) != m2.end())\n                     \
    \   result.push_back(*it);\n        return result;", "    std::vector<long> res;\n\
    \    bool flag = false;\n    for (long &i : l1) {\n        flag = true;\n    \
    \    for (long &j : l2) {\n            if (i == j) res.push_back(i);\n       \
    \ }\n    }\n    if (flag) {\n        for (long &i : l2) {\n            flag =\
    \ false;\n            for (long &j : l1) {\n                if (i == j) res.push_back(i);\n\
    \            }\n        }\n    }\n    return res;", "    std::vector<long> res;\n\
    \    // Using set here\n    std::set<long> s1;\n    std::set<long> s2;\n    //\
    \ Adding all elements into set 1 and set 2\n    for (auto i : l1)\n        s1.insert(i);\n\
    \    for (auto i : l2)\n        s2.insert(i);\n    // Getting common elements\
    \ from set 1 and 2\n    std::vector<long> common = s1;\n    common.erase(s2.begin(),\
    \ s2.end());\n    res.reserve(common.size());\n    // Copying the common elements\
    \ into res vector\n    for (auto i : common)\n        res.push_back(i);\n    return\
    \ res;", "    int n1 = l1.size();\n    int n2 = l2.size();\n    std::vector<long>\
    \ res(n1);\n    for (int i = 0; i < n1; i++) {\n        if (l2.find(l1[i]) ==\
    \ l2.end()) {\n            res[i] = l1[i];\n        } else {\n            res[i]\
    \ = l2[i];\n        }\n    }\n    return res;", "    auto l1 = l1.begin();\n \
    \   auto l2 = l2.begin();\n    long common = 0;\n    while (l1 != l1.end() &&\
    \ l2 != l2.end()) {\n        if (*l1 < *l2) {\n            ++l1;\n        } else\
    \ if (*l2 < *l1) {\n            ++l2;\n        } else {\n            common +=\
    \ *l1;\n            ++l1;\n            ++l2;\n        }\n    }\n    auto res =\
    \ std::vector<long>(l1, l2);\n    l1 = res.begin();\n    l2 = res.begin();\n \
    \   while (l1 != res.end() && l2 != res.end()) {\n        if (*l1 < *l2) {\n \
    \           ++l1;\n        } else if (*l2 < *l1) {\n            ++l2;\n      \
    \  } else {\n            common += *l1;\n            ++l1;\n            ++l2;\n\
    \        }\n    }\n    return res;", "    std::vector<long> result;\n    // Initialize\
    \ an empty set.\n    std::set<long> set1;\n    std::set<long> set2;\n    // Fill\
    \ set with unique values of first list.\n    for (long i : l1) {\n        set1.insert(i);\n\
    \    }\n    // Fill set with unique values of second list.\n    for (long i :\
    \ l2) {\n        set2.insert(i);\n    }\n    // Iterate over elements in both\
    \ sets.\n    // Compare with set itself to make sure no duplicates.\n    // If\
    \ set1 and set2 are equal, then the element itself is included.\n    for (long\
    \ i : set1) {\n        if (set2.find(i) == set2.end()) {\n            result.push_back(i);\n\
    \        }\n    }\n    return result;", "  std::vector<long> common;\n  // O(n)\
    \ time, O(n) space\n  // O(n) time, O(1) space\n  std::set<long> l1set = l1;\n\
    \  std::set<long> l2set = l2;\n  \n  for (long item : l1set) {\n    if (l2set.find(item)\
    \ != l2set.end()) {\n      common.push_back(item);\n    }\n  }\n  return common;"]
stop_tokens:
- "\n}"
