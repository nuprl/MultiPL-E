name: HumanEval_26_remove_duplicates
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// From a list of integers,\
  \ remove all elements that occur more than once.\n// Keep order of elements left\
  \ the same as in the input.\n// >>> remove_duplicates([1, 2, 3, 2, 4])\n// [1, 3,\
  \ 4]\nstd::vector<long> remove_duplicates(std::vector<long> numbers) {\n"
tests: "}\nint main() {\n    auto candidate = remove_duplicates;\n    assert(candidate((std::vector<long>()))\
  \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({1, 2, 3,\
  \ 4}))) == (std::vector<long>({1, 2, 3, 4})));\n    assert(candidate((std::vector<long>({1,\
  \ 2, 3, 2, 4, 3, 5}))) == (std::vector<long>({1, 4, 5})));\n}\n"
completions: ["    std::vector<long> unique_numbers;\n    std::set<long> unique_numbers_set;\n\
    \n    // Keep track of duplicates\n    for (long number : numbers) {\n       \
    \ if (unique_numbers_set.count(number) == 0) {\n            unique_numbers_set.insert(number);\n\
    \            unique_numbers.push_back(number);\n        }\n    }\n\n    return\
    \ unique_numbers;", "    std::vector<long> result;\n    long count = 0;\n    for(long\
    \ i : numbers) {\n        if(!numbers.count(i)) {\n            result.push_back(i);\n\
    \        }\n        else {\n            count++;\n        }\n    }\n    if(count\
    \ != numbers.size()) return result;\n    long temp = numbers[0];\n    for(long\
    \ i = 1; i < numbers.size(); i++) {\n        if(numbers[i] != temp) {\n      \
    \      result.push_back(temp);\n            temp = numbers[i];\n        }\n  \
    \  }\n    return result;", "    std::sort(numbers.begin(), numbers.end());\n \
    \   std::vector<long> result;\n    long prevNumber = 0;\n    for (long number\
    \ : numbers) {\n        if (number != prevNumber) {\n            result.push_back(number);\n\
    \            prevNumber = number;\n        }\n    }\n    return result;", "  \
    \  std::vector<long> output;\n    for (auto i : numbers) {\n        if (output.count(i)\
    \ == 0)\n            output.push_back(i);\n    }\n    return output;", "    std::vector<long>\
    \ result;\n    std::unordered_set<long> numbers_set;\n    // The first number\
    \ in the set is the number that occurs first in the input\n    long first_number\
    \ = numbers.front();\n    // For each number in the input ...\n    for (const\
    \ auto& number : numbers) {\n        // ... check whether it is already in the\
    \ set, ...\n        if (numbers_set.find(number) != numbers_set.end()) {\n   \
    \         // ... if so, skip it\n            continue;\n        }\n        //\
    \ ... else, add it to the set and add it as the first number in the result vector\n\
    \        numbers_set.insert(number);\n        result.push_back(number);\n    }\n\
    \    // Now sort the numbers in the result vector\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "  \n    std::unordered_set<long> myset;\n\
    \    std::vector<long> ans;\n    for (auto i : numbers) {\n        if (myset.find(i)\
    \ == myset.end()) {\n            myset.insert(i);\n            ans.push_back(i);\n\
    \        }\n    }\n    return ans;", "    long result = 0;\n    std::vector<long>\
    \ temp;\n    for (const auto &it : numbers) {\n        if (temp.find(it) == temp.end())\
    \ {\n            temp.push_back(it);\n        } else {\n            temp.erase(temp.find(it));\n\
    \        }\n    }\n    std::sort(temp.begin(), temp.end());\n    for (auto it\
    \ = temp.begin(); it != temp.end(); ++it) {\n        result += *it;\n    }\n \
    \   std::vector<long> result;\n    for (auto it = temp.begin(); it != temp.end();\
    \ ++it) {\n        result.push_back(result);\n    }\n    return result;", "  \
    \  // write your code here\n    long count[numbers.size()];\n    long temp;\n\
    \    size_t count = 0;\n    for (long i = 0; i < numbers.size(); i++) {\n    \
    \    if (temp == numbers[i]) {\n            count[i] = count[i + 1] + 1;\n   \
    \     } else {\n            count[i] = 1;\n            temp = numbers[i];\n  \
    \      }\n    }\n    std::vector<long> results(numbers.size());\n    for (size_t\
    \ i = 0; i < numbers.size(); i++) {\n        if (count[i] > 1)\n            results[count[i]]\
    \ = numbers[i];\n    }\n    return results;", "    std::vector<long> output;\n\
    \    std::map<long, bool> seen;\n    // O(n) time, O(n) space, where n is the\
    \ number of elements in the input vector\n    for (const auto& num : numbers)\
    \ {\n        if (seen.count(num))\n            continue;\n        seen.insert({num,\
    \ true});\n        output.push_back(num);\n    }\n    return output;", "    std::vector<long>\
    \ unique_numbers;\n    // Go through the vector to find duplicates and store them\
    \ in another vector\n    for (long i : numbers)\n        for (long j : numbers)\n\
    \            if (i != j && i != j && i != j && i != j)\n                if (numbers[j]\
    \ == i) {\n                    unique_numbers.push_back(i);\n                \
    \    break;\n                }\n    return unique_numbers;", "    std::vector<long>\
    \ v;\n    std::sort(numbers.begin(), numbers.end());\n    for (auto it = numbers.begin();\
    \ it != numbers.end(); it++) {\n        auto it = std::find(v.begin(), v.end(),\
    \ *it);\n        if (it != v.end()) {\n            v.erase(it);\n        } else\
    \ {\n            v.push_back(*it);\n        }\n    }\n    return v;", "  std::unordered_set<long>\
    \ numberSet;\n  for (int i = 0; i < numbers.size(); ++i)\n    numberSet.insert(numbers[i]);\n\
    \  return std::vector<long>(numberSet.begin(), numberSet.end());", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> result(numbers.size(), 0);\n  for (size_t\
    \ i = 1; i < numbers.size(); i++)\n    if (numbers[i] != numbers[i - 1]) {\n \
    \     result[i - 1] = 1;\n      result.at(i) = numbers[i];\n    }\n  return result;",
  "    if (numbers.empty())\n        return numbers;\n    std::vector<long> result;\n\
    \    std::unordered_set<long> set;\n    std::sort(numbers.begin(), numbers.end());\n\
    \    for (long n : numbers)\n        if (set.find(n) == set.end())\n         \
    \   set.insert(n);\n        else\n            result.push_back(n);\n    return\
    \ result;", "    std::vector<long> res;\n    // Create a set for storing seen\
    \ elements already\n    std::vector<bool> seen(numbers.size(), false);\n    //\
    \ Iterate over the list of numbers\n    for (long i : numbers) {\n        // Check\
    \ if the number has been seen before and store it in result if not\n        if\
    \ (seen[i]) {\n            // Remember that the element has already been seen\n\
    \            res.push_back(i);\n            continue;\n        }\n        // Number\
    \ has not been seen before, add the number to the result list\n        res.push_back(i);\n\
    \        // Mark number as seen\n        seen[i] = true;\n    }\n    return res;",
  "    assert(numbers.empty() || numbers.size() <= 10);\n    std::vector<long> ret;\n\
    \    std::set<long> seen;\n    for (const auto num : numbers) {\n        if (seen.count(num)\
    \ == 0) {\n            ret.push_back(num);\n            seen.insert(num);\n  \
    \      }\n    }\n    return ret;", "    auto it = numbers.begin();\n    std::unordered_set<long>\
    \ unique;\n    std::vector<long> result;\n\n    while (it != numbers.end()) {\n\
    \        if (unique.count(*it)) {\n            result.push_back(*it);\n      \
    \  } else {\n            unique.insert(*it);\n        }\n        ++it;\n    }\n\
    \    return result;", "  // Step one: count the number of occurrences of each\
    \ value.\n  // This can be done by first creating a set with the values\n  //\
    \ and then counting the number of occurrences in the set (which\n  // will be\
    \ a constant time operation).\n  struct Counter {\n    long count;\n    bool operator<(const\
    \ Counter& other) const {\n      return count < other.count;\n    }\n  };\n  std::set<Counter>\
    \ counters;\n  counters.reserve(numbers.size());\n  for (long value : numbers)\
    \ {\n    counters.emplace(Counter{1, value});\n  }\n\n  // Step two: Remove the\
    \ values that appear more than once.\n  std::vector<long> output;\n  output.reserve(numbers.size());\n\
    \  for (const auto& counter : counters) {\n    if (counter.count == 1) {\n   \
    \   output.push_back(counter.first);\n    }\n  }\n\n  // Step three: Remove any\
    \ value that has only one occurrence.\n  output.erase(std::unique(output.begin(),\
    \ output.end()), output.end());\n\n  return output;", "    std::vector<long> results;\n\
    \    std::vector<long> seenNumbers;\n    results.reserve(numbers.size());\n  \
    \  for (long n : numbers) {\n        if (seenNumbers.find(n) != seenNumbers.end())\n\
    \            continue;\n        results.push_back(n);\n        seenNumbers.insert(n);\n\
    \    }\n    return results;", "  std::set<long> seen;\n  long result = 0;\n  for\
    \ (long i : numbers)\n    seen.insert(i);\n  for (long i : seen)\n    result +=\
    \ i;\n  std::vector<long> resultVec;\n  resultVec.reserve(numbers.size());\n \
    \ for (long i : numbers)\n    if (seen.count(i) == 1)\n      resultVec.push_back(i);\n\
    \  return resultVec;", "  // Copy input vector\n  std::vector<long> newVector(numbers);\n\
    \  std::sort(newVector.begin(), newVector.end()); // Sort the vector.\n  std::vector<long>\
    \ result;\n  std::size_t index = 0;\n  // Iterate over the vector, keeping track\
    \ of elements that have been\n  // seen and only outputting elements that haven't\
    \ been seen yet.\n  for (std::size_t i = 0; i < newVector.size(); ++i) {\n   \
    \ if (i == index) {\n      // No duplicates yet, move on to next element.\n  \
    \    index = newVector.size();\n      continue;\n    }\n    if (newVector[i] !=\
    \ newVector[index]) {\n      // New element encountered, add to output vector.\n\
    \      result.push_back(newVector[i]);\n      // Move on to next element.\n  \
    \    index = i;\n    }\n  }\n  return result;", "    assert(!numbers.empty());\n\
    \    long freq[numbers.size()];\n    std::fill(std::begin(freq), std::begin(freq)\
    \ + numbers.size(), 0);\n    for (long i : numbers)\n        freq[i]++;\n    std::vector<long>\
    \ output(numbers.size());\n    for (long i : numbers)\n        if (--freq[i] >\
    \ 0)\n            output[numbers.size() - i - 1] = i;\n    return output;", " \
    \ std::vector<long> v;\n  for (int i : numbers) {\n    std::set<long> s;\n   \
    \ s.insert(i);\n    while (s.size() > 0) {\n      v.push_back(s.begin()->second);\n\
    \      s.erase(s.begin());\n    }\n  }\n  return v;", "    // https://stackoverflow.com/questions/52213407/remove-duplicates-in-an-stdvector\n\
    \    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> nums(numbers.size());\n\
    \    for (long &elem : nums)\n        elem = numbers[numbers.find(elem) - numbers.begin()];\n\
    \    return nums;", "  std::sort(numbers.begin(), numbers.end());\n\n  std::vector<long>\
    \ result;\n  result.push_back(*numbers.begin());\n\n  for (int i = 1; i < numbers.size();\
    \ i++) {\n    if (numbers[i] != result[i - 1]) {\n      result.push_back(numbers[i]);\n\
    \    }\n  }\n\n  return result;", "    std::vector<long> result;\n    std::unordered_set<long>\
    \ s;\n    for (int &i : numbers)\n        if (s.count(i) == 0)\n            s.insert(i);\n\
    \        else\n            result.push_back(i);\n    return result;", "    assert(numbers.size()\
    \ > 0);\n    std::vector<long> output;\n    std::unordered_set<long> seen;\n \
    \   for (auto it : numbers) {\n        if (seen.find(it) == seen.end()) {\n  \
    \          seen.insert(it);\n            output.push_back(it);\n        }\n  \
    \  }\n    return output;", "    std::sort(numbers.begin(), numbers.end());\n \
    \   std::vector<long> unique_numbers;\n    for (long num : numbers) {\n      \
    \  if (std::binary_search(unique_numbers.begin(), unique_numbers.end(), num))\n\
    \            continue;\n        unique_numbers.push_back(num);\n    }\n    return\
    \ unique_numbers;", "  std::vector<long> result;\n  for(long number : numbers)\n\
    \  {\n    if(!result.empty() && result.back()==number)\n      result.back()++;\n\
    \    else\n      result.push_back(number);\n  }\n  return result;", "    std::vector<long>\
    \ output;\n    output.reserve(numbers.size());\n    std::size_t seen{0};\n   \
    \ for (const auto& num : numbers) {\n        if (seen < num) {\n            seen\
    \ = num;\n            output.push_back(num);\n        }\n    }\n    return output;",
  "    std::vector<long> new_numbers;\n    std::set<long> unique_numbers;\n    for(auto\
    \ const &n: numbers)\n        unique_numbers.insert(n);\n    for(auto const &n:\
    \ unique_numbers)\n        new_numbers.push_back(n);\n    return new_numbers;",
  "    long long int sum = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n  \
    \      if (numbers.at(i) != i) {\n            sum += numbers.at(i);\n        \
    \    numbers.erase(numbers.begin() + numbers.at(i));\n        }\n    }\n    return\
    \ numbers;", "    std::vector<long> new_numbers;\n    long curr = 0;\n    for\
    \ (long num: numbers) {\n        if (curr != num) {\n            new_numbers.push_back(curr);\n\
    \            curr = num;\n        }\n    }\n    new_numbers.push_back(curr);\n\
    \    return new_numbers;", "    std::sort(numbers.begin(), numbers.end());\n \
    \   std::vector<long> output;\n    long prev = numbers[0];\n    for (long num\
    \ : numbers) {\n        if (num != prev) {\n            output.push_back(prev);\n\
    \        }\n        prev = num;\n    }\n    return output;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> out;\n  // use set to remove duplicates\n\
    \  std::set<long> numbers_set(numbers.begin(), numbers.end());\n  for (auto number\
    \ : numbers_set) {\n    out.push_back(number);\n  }\n  return out;", "    std::set<long>\
    \ set;\n    std::vector<long> result;\n    for(long i : numbers) {\n        if(set.find(i)\
    \ == set.end()) {\n            set.insert(i);\n            result.push_back(i);\n\
    \        }\n    }\n    return result;", "  std::vector<long> result;\n  std::set<long>\
    \ number_set;\n\n  for (long i : numbers)\n    number_set.insert(i);\n\n  result.assign(number_set.begin(),\
    \ number_set.end());\n\n  return result;", "    std::vector<long> temp;\n    std::set<long>\
    \ seen;\n    for(long i : numbers) {\n        if(seen.find(i) == seen.end()) {\n\
    \            temp.push_back(i);\n            seen.insert(i);\n        }\n    }\n\
    \    return temp;", "  if(numbers.empty())\n    return numbers;\n\n  // We cannot\
    \ keep order for duplicates.\n  // Instead, store all the unique elements at the\
    \ end,\n  // and remove them when we output the result.\n  std::vector<long> results;\n\
    \  results.reserve(numbers.size());\n\n  // Get first unique element.\n  long\
    \ first = numbers[0];\n  // Keep track of duplicate numbers.\n  bool seen[numbers.size()];\n\
    \  // Keep track of non-duplicate numbers.\n  long unique = 0;\n  // Iterate through\
    \ the list and keep track of unique elements.\n  for(long i = 1;i < numbers.size();++i)\
    \ {\n    // If we've seen this element before, remove it.\n    if(seen[i]) {\n\
    \      // Remove this element from the array and decrement unique.\n      --unique;\n\
    \      continue;\n    }\n    // We haven't seen this element before, so add it.\n\
    \    seen[i] = true;\n    // Keep track of non-duplicate elements. Since we haven't\n\
    \    // seen this element before, unique is now 0.\n    ++unique;\n    // If unique\
    \ is less than or equal to the number of unique\n    // elements in the list,\
    \ add the element to the results.\n    if(unique <= results.size()) {\n      results.push_back(i);\n\
    \    }\n  }\n  return results;", "    std::vector<long> ret;\n    std::map<long,\
    \ bool> seen;\n    for (auto i : numbers) {\n        if (seen.find(i) == seen.end())\
    \ {\n            ret.push_back(i);\n            seen[i] = true;\n        }\n \
    \   }\n    return ret;", "    std::vector<long> result(numbers.begin(), numbers.end());\n\
    \    long uniqueCount = 1;\n    for (auto i : numbers) {\n        // Check if\
    \ this number has been seen already.\n        // If it has, then this number has\
    \ not been seen\n        // before and is still unique, so leave it as it is.\n\
    \        // If it hasn't, then it has been seen before, so\n        // remove\
    \ it from the result.\n        bool found = false;\n        for (int j = 0; j\
    \ < result.size(); j++) {\n            if (i == result[j]) {\n               \
    \ found = true;\n                break;\n            }\n        }\n        if\
    \ (!found) {\n            result[result.size() - 1]++;\n            uniqueCount++;\n\
    \        }\n    }\n    return std::vector<long>(result.begin(), result.begin()\
    \ + uniqueCount);", "    // Find number of duplicates\n    long numOfDuplicates\
    \ = 0;\n    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers.at(i)\
    \ != numbers.at(i-1)) {\n            numOfDuplicates++;\n        }\n    }\n  \
    \  std::vector<long> noDuplicates;\n    for (int i = 0; i < numbers.size(); i++)\
    \ {\n        if (i != numOfDuplicates) {\n            noDuplicates.push_back(numbers.at(i));\n\
    \        }\n    }\n    return noDuplicates;", "  // Build a map of seen elements,\
    \ and count how many times each element was seen.\n  std::unordered_map<long,\
    \ std::size_t> seen;\n  for (long i : numbers) {\n    auto inserted = seen.emplace(i,\
    \ 0);\n    assert(inserted.second); // element may already have been inserted\
    \ (hash collision)\n    seen[i] += inserted.first->second;\n  }\n  // Copy seen\
    \ elements into result vector.\n  std::vector<long> result;\n  for (const auto&\
    \ i : seen) {\n    if (i.second == 1) result.push_back(i.first);\n  }\n  return\
    \ result;", "    // Your code goes here\n    numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n    return numbers;", "  std::vector<long>\
    \ result;\n  // Using a set to keep track of unique elements.\n  std::set<long>\
    \ seen;\n  for(long num : numbers) {\n    if(seen.find(num) == seen.end()) {\n\
    \      seen.insert(num);\n      result.push_back(num);\n    }\n  }\n  return result;",
  "  assert(!numbers.empty());\n\n  std::vector<long> unique_nums;\n\n  for (long\
    \ number : numbers) {\n    if (unique_nums.find(number) == unique_nums.end())\
    \ {\n      unique_nums.push_back(number);\n    }\n  }\n\n  return unique_nums;",
  "  // Allocate space for result vector\n  std::vector<long> result;\n  std::unordered_map<long,\
    \ int> seen;\n  for (long &val : numbers) {\n    // If it's been seen before,\
    \ skip.\n    if (seen.count(val) > 0) {\n      continue;\n    }\n    // Otherwise,\
    \ add it to the result list\n    seen.insert({val, 0});\n    result.push_back(val);\n\
    \  }\n  return result;", "  std::vector<long> output;\n  std::unordered_set<long>\
    \ unique;\n\n  for (long num : numbers) {\n    if (unique.find(num) == unique.end())\
    \ {\n      unique.insert(num);\n      output.push_back(num);\n    }\n  }\n\n \
    \ return output;", "  std::sort(numbers.begin(), numbers.end()); // sort from\
    \ lowest to highest\n  long long int last_element = numbers[0];\n  std::vector<long>\
    \ result;\n  while (numbers.size()) {\n    if (numbers[0] == last_element) {\n\
    \      result.push_back(numbers[0]);\n      numbers.erase(numbers.begin());\n\
    \    } else {\n      last_element = numbers[0];\n    }\n  }\n  return result;",
  "    std::sort(numbers.begin(), numbers.end());\n    numbers.erase(\n          \
    \  std::unique(numbers.begin(), numbers.end()),\n            numbers.end());\n\
    \    return numbers;", "    // Your code goes here\n    std::vector<long> result;\n\
    \    std::sort(numbers.begin(), numbers.end());\n    for (auto n : numbers)\n\
    \    {\n        std::find_if(numbers.begin(), numbers.end(),\n            [&n](int\
    \ i) { return i == n; }).first;\n        result.push_back(n);\n    }\n    std::sort(result.begin(),\
    \ result.end());\n    return result;", "    assert(numbers.size() > 0);\n    std::map<long,\
    \ std::vector<long> > m;\n    for (long i : numbers) {\n        auto inserted\
    \ = m.emplace(i, {i, {}});\n        assert(inserted.second);\n        auto &vec\
    \ = inserted.first->second;\n        vec.push_back(i);\n    }\n    std::vector<long>\
    \ result(m.size());\n    for (auto i : m)\n        result.push_back(i.first);\n\
    \    return result;", "    std::vector<long> output;\n    std::set<long> set;\n\
    \n    for(long num : numbers) {\n        if (set.find(num) == set.end()) {\n \
    \           set.insert(num);\n            output.push_back(num);\n        }\n\
    \    }\n    return output;", "    std::vector<long> sorted_numbers(numbers.begin(),\
    \ numbers.end());\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\
    \    std::set_difference(sorted_numbers.begin(), sorted_numbers.end(),\n     \
    \                   sorted_numbers.begin(), sorted_numbers.end(),\n          \
    \              std::back_inserter(sorted_numbers));\n    return sorted_numbers;",
  "    // Initialize a set to hold duplicates.\n    std::set<long> dupes;\n\n    //\
    \ Go through each element in the list.\n    for(long i : numbers) {\n        //\
    \ If the set doesn't contain the current element, add it.\n        if(dupes.find(i)\
    \ == dupes.end()) {\n            dupes.insert(i);\n        }\n    }\n\n    //\
    \ Return all elements in the set in the order they were in the list.\n    return\
    \ dupes;", "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    result.reserve(numbers.size());\n\n    for (long i : numbers) {\n\
    \        if (result.size() == 0 || result.back() != i) {\n            result.push_back(i);\n\
    \        }\n    }\n    return result;", "  std::vector<long> duplicates;\n  for\
    \ (int i = 1; i < numbers.size(); i++) {\n    if (numbers.at(i) == numbers.at(i-1))\
    \ {\n      duplicates.push_back(numbers.at(i-1));\n      numbers.erase(numbers.begin()+i);\n\
    \    }\n  }\n  return duplicates;", "  assert(numbers.size() > 1);\n  // Use a\
    \ set to track duplicates.\n  std::set<long> numbers_to_remove;\n  for (long &number\
    \ : numbers) {\n    if (numbers_to_remove.count(number) == 0) {\n      numbers_to_remove.insert(number);\n\
    \    } else {\n      numbers.erase(std::remove(numbers.begin(), numbers.end(),\
    \ number), numbers.end());\n    }\n  }\n  return numbers;", "    std::vector<long>\
    \ result;\n    std::unordered_set<long> seen;\n    for (auto i : numbers) {\n\
    \        if (seen.find(i) == seen.end())\n            result.push_back(i);\n \
    \       seen.insert(i);\n    }\n    return result;", "    std::vector<long> sorted_numbers(numbers.size());\n\
    \    std::iota(sorted_numbers.begin(), sorted_numbers.end(), 0);\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end(), [&numbers](long a, long b) {\n        return numbers[a]\
    \ > numbers[b];\n    });\n    std::vector<long> final_numbers(sorted_numbers.size());\n\
    \    for (std::size_t i = 0; i < numbers.size(); ++i) {\n        for (std::size_t\
    \ j = i; j < sorted_numbers.size(); ++j) {\n            if (numbers[i] == sorted_numbers[j])\
    \ {\n                break;\n            }\n            if (numbers[j] < numbers[i])\
    \ {\n                final_numbers[j] = numbers[i];\n                break;\n\
    \            }\n        }\n    }\n    return final_numbers;", "  // sort the numbers\
    \ ascending\n  std::sort(numbers.begin(), numbers.end());\n  // mark already seen\
    \ numbers (set them)\n  std::vector<bool> seen(numbers.size(), false);\n  // construct\
    \ a new vector to hold numbers\n  std::vector<long> new_numbers;\n  for (auto\
    \ it : numbers) {\n    if (!seen[it]) {\n      new_numbers.push_back(it);\n  \
    \    seen[it] = true;\n    }\n  }\n  return new_numbers;", "    assert(numbers.size()\
    \ != 0);\n    std::vector<long> output;\n    std::map<long, int> seen;\n    for\
    \ (long i : numbers) {\n        auto inserted = seen.find(i);\n        if (inserted\
    \ == seen.end()) {\n            output.push_back(i);\n            seen[i] = 1;\n\
    \        } else {\n            seen[i]++;\n        }\n    }\n    return output;",
  "  std::vector<long> result;\n  for(long i=0;i<numbers.size();i++){\n    if(result.find(numbers[i])==result.end()){\n\
    \      result.push_back(numbers[i]);\n    }\n  }\n  return result;", "    std::vector<long>\
    \ result;\n    for (long i : numbers) {\n        if (std::find(result.begin(),\
    \ result.end(), i) == result.end())\n            result.push_back(i);\n    }\n\
    \    return result;", "  std::vector<long> tmp;\n  std::vector<long> nums_copy(numbers);\n\
    \  std::sort(nums_copy.begin(), nums_copy.end());\n  for (int i = 0; i < nums_copy.size();\
    \ ++i) {\n    int count = 0;\n    for (int j = 0; j < tmp.size() && tmp[j] ==\
    \ nums_copy[i]; ++j) {\n      ++count;\n    }\n    if (count > 1) {\n      for\
    \ (int j = tmp.size() - 1; j >= 0 && tmp[j] == nums_copy[i]; --j) {\n        tmp.erase(tmp.begin()\
    \ + j);\n      }\n    }\n    tmp.push_back(nums_copy[i]);\n  }\n  return tmp;",
  "    std::vector<long> result;\n    std::vector<long>::iterator it;\n    for(it\
    \ = numbers.begin(); it != numbers.end(); ++it) {\n        if(result.find(*it)\
    \ == result.end()) {\n            result.push_back(*it);\n        }\n    }\n \
    \   return result;", "  // Initialize vector with numbers without duplicates\n\
    \  std::vector<long> unique_numbers(numbers);\n  // Iterate over all elements\
    \ and remove all duplicates\n  for (size_t i = 0; i < unique_numbers.size(); ++i)\
    \ {\n    std::vector<long>::iterator iter = std::find(numbers.begin(), numbers.end(),\
    \ unique_numbers[i]);\n    if (iter != numbers.end()) {\n      numbers.erase(iter);\n\
    \    }\n  }\n  return numbers;", "  long long result = 0;\n  for (long long i\
    \ = 0; i < numbers.size(); i++) {\n    if (numbers.at(i) != numbers.at(--result))\
    \ {\n      numbers.push_back(i);\n    }\n  }\n  return numbers;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    numbers.erase(std::unique(numbers.begin(), numbers.end()),\
    \ numbers.end());\n    return numbers;", "  assert(numbers.size() > 0);\n  std::vector<long>\
    \ result(numbers.size());\n  std::sort(numbers.begin(), numbers.end());\n  std::unique(numbers.begin(),\
    \ numbers.end(), [&](long a, long b) {\n    return a < b;\n  });\n  return result;",
  "  std::sort(numbers.begin(), numbers.end());\n  std::vector<long> ans;\n  for (int\
    \ i = 0; i < numbers.size(); ++i) {\n    bool found = false;\n    for (int j =\
    \ 0; j < i; ++j) {\n      if (numbers[j] == numbers[i]) {\n        found = true;\n\
    \        break;\n      }\n    }\n    if (!found) {\n      ans.push_back(numbers[i]);\n\
    \    }\n  }\n  return ans;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> result;\n    result.push_back(numbers[0]);\n    for (long\
    \ i = 1;i < numbers.size(); ++i) {\n        if (numbers[i] != numbers[0]) {\n\
    \            result.push_back(numbers[i]);\n        }\n    }\n    return result;",
  "  std::sort(numbers.begin(), numbers.end());\n  numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n  return numbers;", "    std::vector<long>\
    \ output;\n    output.reserve(numbers.size());\n    for(long & n: numbers){\n\
    \        long count = 0;\n        for(long i : numbers)\n            if(i != n\
    \ && n == i)\n                count++;\n        output.push_back(n);\n       \
    \ if(count > 1)\n            n = -1;\n    }\n    return output;", "  assert(!numbers.empty());\n\
    \  std::vector<long> results;\n  std::set<long> seen;\n  for (long i : numbers)\
    \ {\n    if (seen.find(i) != seen.end()) {\n      continue;\n    }\n    results.push_back(i);\n\
    \    seen.insert(i);\n  }\n  return results;", "  std::sort(numbers.begin(), numbers.end());\n\
    \  std::vector<long> output;\n  for (long i : numbers)\n    if (std::find(output.begin(),\
    \ output.end(), i) == output.end())\n      output.push_back(i);\n  return output;",
  "    std::vector<long> output;\n    std::unordered_set<long> seen;\n    for (auto\
    \ x: numbers) {\n        if (seen.count(x) == 0) {\n            seen.insert(x);\n\
    \            output.push_back(x);\n        }\n    }\n    return output;", "  \
    \  std::vector<long> result;\n    long prev = numbers.front();\n    for(auto num:\
    \ numbers) {\n        if(num == prev) {\n            continue;\n        }\n  \
    \      prev = num;\n        result.push_back(num);\n    }\n    return result;",
  "    std::sort(numbers.begin(), numbers.end());\n\n    std::vector<long> result;\n\
    \    long last = numbers.front();\n    for (const long number : numbers) {\n \
    \       if (number == last) {\n            result.push_back(number);\n       \
    \     continue;\n        }\n        result.push_back(last);\n        result.push_back(number);\n\
    \        last = number;\n    }\n    return result;", "  std::vector<long> new_number;\n\
    \  std::vector<long> number_count(numbers.begin(), numbers.end());\n  new_number.reserve(number_count.size());\n\
    \  for (size_t i = 0; i < numbers.size(); ++i) {\n    if (number_count[numbers[i]]\
    \ == 0) {\n      new_number.push_back(numbers[i]);\n    }\n    number_count[numbers[i]]++;\n\
    \  }\n  return new_number;", "    // Create a set to hold the unique values.\n\
    \    std::set<long> seen;\n    // Create an empty array to hold duplicate values.\n\
    \    std::vector<long> result;\n    for (auto n : numbers) {\n        // If n\
    \ has not been seen yet, add n.\n        if (seen.find(n) == seen.end()) {\n \
    \           result.push_back(n);\n            seen.insert(n);\n        }\n   \
    \ }\n    return result;", "    std::vector<long> new_number;\n    for(std::size_t\
    \ i = 0; i < numbers.size(); ++i) {\n        long current = numbers[i];\n    \
    \    if(std::find(new_number.begin(), new_number.end(), current) == new_number.end())\
    \ {\n            new_number.push_back(current);\n        }\n    }\n    return\
    \ new_number;", "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    result.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size();\
    \ ++i) {\n        if (numbers[i] != numbers[i - 1]) {\n            result.push_back(numbers[i]);\n\
    \        }\n    }\n    return result;", "    // Create output vector, same size\
    \ as input.\n    std::vector<long> output;\n    output.reserve(numbers.size());\n\
    \    for (auto const& x : numbers) {\n        // If the number is already in the\
    \ output vector, ignore it\n        // This will ensure all elements are kept\
    \ in order.\n        if (std::find(output.begin(), output.end(), x) != output.end())\
    \ {\n            continue;\n        }\n        output.push_back(x);\n    }\n \
    \   return output;", "    std::vector<long> result;\n    result.insert(result.begin(),\
    \ numbers.begin(), numbers.end());\n    // for each integer x appearing more than\
    \ once, remove it from the list\n    std::vector<long>::iterator i = std::unique(result.begin(),\
    \ result.end());\n    result.erase(i, result.end());\n    return result;", " \
    \   std::vector<long> sorted_numbers;\n    for (auto &i : numbers) {\n       \
    \ std::find(sorted_numbers.begin(), sorted_numbers.end(), i)\n            == sorted_numbers.end()\n\
    \                ? sorted_numbers.push_back(i)\n                : std::find(sorted_numbers.begin(),\
    \ sorted_numbers.end(), i)\n                        != sorted_numbers.end()\n\
    \                            ? std::cout << \"Repeated element: \" << i << \"\
    \ appears more than once.\"\n                            : ;\n    }\n    return\
    \ sorted_numbers;", "  std::vector<long> result;\n  std::unordered_set<long> numberSet;\n\
    \  // Loop through all the numbers in the list.\n  for (auto i : numbers)\n  \
    \  if (numberSet.count(i) == 0)\n      numberSet.insert(i);\n  // Add all the\
    \ numbers we didn't find to the result.\n  for (auto i : numberSet)\n    if (result.count(i)\
    \ == 0)\n      result.push_back(i);\n  return result;", "    std::set<long> seen;\n\
    \    std::vector<long> ret;\n    ret.reserve(numbers.size());\n    for (long i\
    \ : numbers) {\n        if (seen.find(i) == seen.end()) {\n            ret.push_back(i);\n\
    \            seen.insert(i);\n        }\n    }\n    return ret;", "  std::vector<long>\
    \ output; // Empty vector to hold output\n\n  for (long number = 0; number < numbers.size();\
    \ ++number) {\n    if (numbers.count(number) > 1) {\n      output.push_back(number);\n\
    \    }\n  }\n\n  return output;", "  std::vector<long> result;\n  long last_number\
    \ = numbers[0];\n  for (auto number : numbers) {\n    if (number != last_number)\
    \ {\n      result.push_back(number);\n      last_number = number;\n    }\n  }\n\
    \  return result;", "    std::vector<long> result;\n    std::map<long, bool> seen;\n\
    \    for (auto& n: numbers)\n    {\n        if (!seen.count(n))\n            result.push_back(n);\n\
    \        seen[n] = true;\n    }\n    return result;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> result;\n    std::vector<int> seen;\n\
    \    for (long i = 0; i < numbers.size(); i++) {\n        if (seen.find(numbers[i])\
    \ == seen.end()) {\n            seen.push_back(numbers[i]);\n            result.push_back(numbers[i]);\n\
    \        } else {\n            result.push_back(numbers[i]);\n        }\n    }\n\
    \    return result;", "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    long prev=numbers.front();\n    long n=1;\n    for (std::vector<long>::iterator\
    \ itr=numbers.begin(); itr!=numbers.end(); ++itr) {\n        long cur=*itr;\n\
    \        if (prev!=cur) {\n            result.push_back(prev);\n            n=1;\n\
    \            prev=cur;\n        } else {\n            n++;\n        }\n    }\n\
    \    return std::vector<long>(result.begin(), result.end()-n);", "    // Build\
    \ a map of unique numbers and their frequencies\n    std::map<long, int> frequencies;\n\
    \    for (const auto& n : numbers) {\n        frequencies[n] += 1;\n    }\n  \
    \  // Loop over the map to build a new list while removing elements\n    std::vector<long>\
    \ output;\n    for (const auto& n : frequencies) {\n        if (frequencies[n]\
    \ == 1) {\n            output.push_back(n);\n        }\n    }\n    return output;",
  "    std::vector<long> result;\n    std::unordered_set<long> numberSet;\n\n    for\
    \ (const auto &i : numbers)\n        numberSet.insert(i);\n\n    for (const auto\
    \ &i : numberSet)\n        result.push_back(i);\n\n    return result;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> result;\n    result.insert(result.begin(),\
    \ numbers.begin(), numbers.end());\n    for(auto it = numbers.end() - 1; it >=\
    \ result.end(); --it)\n        if(numbers.at(it) == numbers.at(it - 1))\n    \
    \        numbers.erase(it);\n    return result;", "    std::vector<long> sorted_numbers;\n\
    \    std::vector<long> sorted_number_set;\n\n    std::vector<long>::iterator it\
    \ = numbers.begin();\n\n    sorted_numbers.reserve(numbers.size());\n    while\
    \ (it != numbers.end()) {\n        if (sorted_number_set.find(*it) == sorted_number_set.end())\
    \ {\n            sorted_numbers.push_back(*it);\n            sorted_number_set.insert(*it);\n\
    \        }\n        it++;\n    }\n\n    return sorted_numbers;", "    std::vector<long>\
    \ new_numbers;\n    for (long i : numbers) {\n        if (!std::binary_search(new_numbers.begin(),\
    \ new_numbers.end(), i)) {\n            new_numbers.push_back(i);\n        }\n\
    \    }\n    return new_numbers;", "    // Your code goes here\n    // Your code\
    \ goes here\n    // Your code goes here\n    // Your code goes here\n    // Your\
    \ code goes here\n    return numbers;", "    // Your code here\n    // Your code\
    \ here\n    std::vector<long> v;\n    std::sort(numbers.begin(), numbers.end());\n\
    \    long count = 0;\n    for (auto it = numbers.begin(); it != numbers.end();\
    \ ++it) {\n        if (it != numbers.begin()) {\n            auto temp = *it;\n\
    \            if (count >= 1 && temp != *it - 1) {\n                v.push_back(temp);\n\
    \                count--;\n            } else {\n                count++;\n  \
    \          }\n        }\n    }\n    return v;", "    std::set<long> unique;\n\
    \    for (long number : numbers) {\n        if (unique.find(number) == unique.end())\
    \ {\n            unique.insert(number);\n        }\n    }\n    return std::vector<long>(unique.begin(),\
    \ unique.end());", "    // Sorting numbers in ascending order.\n    numbers.sort();\n\
    \    // Keep track of previous element seen and current element seen.\n    std::vector<bool>\
    \ seen(numbers.size(), false);\n    std::vector<long> ans;\n    // While there\
    \ are elements to remove.\n    while (!numbers.empty()) {\n        // If current\
    \ number is different than previous element seen.\n        if (numbers[0] != seen[0])\
    \ {\n            // Remember current number seen and update seen elements.\n \
    \           ans.push_back(numbers[0]);\n            for (int i = 1; i < numbers.size();\
    \ i++) {\n                seen[i] = seen[i - 1];\n            }\n        }\n \
    \       // Remove first element seen from numbers to keep only unique elements.\n\
    \        numbers.erase(std::remove(numbers.begin(), numbers.end(), seen[0]),\n\
    \                     numbers.end());\n    }\n    return ans;", "    // Your code\
    \ goes here\n    std::vector<long> result;\n    std::map<long, bool> m;\n    for\
    \ (size_t i = 0; i < numbers.size(); i++)\n        if (m.find(numbers[i]) == m.end())\n\
    \            m.insert({ numbers[i], false });\n        else\n            m[numbers[i]]\
    \ = true;\n    for (auto i : m)\n        result.push_back(i.first);\n    return\
    \ result;", "    std::vector<long> res;\n    for (long i : numbers) {\n      \
    \  if (res.empty() || res.back() != i) {\n            res.push_back(i);\n    \
    \    }\n    }\n    return res;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> result;\n    result.push_back(numbers[0]);\n    for (auto\
    \ i : numbers) {\n        if (i != numbers[0]) {\n            result.push_back(i);\n\
    \        }\n    }\n    return result;", "  sort(numbers.begin(), numbers.end());\n\
    \  std::vector<long> result;\n  for (long i : numbers) {\n    if (!binary_search(result.begin(),\
    \ result.end(), i)) {\n      result.push_back(i);\n    }\n  }\n  return result;",
  "  std::vector<long> temp(numbers.begin(), numbers.end());\n  std::sort(temp.begin(),\
    \ temp.end());\n  std::sort(temp.begin(), temp.end(), [](long x, long y){ return\
    \ x < y; });\n  std::vector<long> output;\n  for (size_t i = 0; i < temp.size();\
    \ ++i) {\n    if (i != 0 && temp[i] == temp[i - 1]) {\n      output.push_back(temp[i]);\n\
    \    } else {\n      output.push_back(temp[i]);\n    }\n  }\n  return output;",
  "  std::vector<long> result;\n  std::set<long> numbers_set;\n  for (long number\
    \ : numbers) {\n    if (numbers_set.count(number) == 0) {\n      numbers_set.insert(number);\n\
    \      result.push_back(number);\n    }\n  }\n  return result;", "  std::vector<long>\
    \ result;\n  // Add elements to result only if they haven't been added yet.\n\
    \  for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n    auto inserted\
    \ = std::find(result.begin(), result.end(), *it);\n    if (inserted == result.end())\
    \ {\n      result.push_back(*it);\n    }\n  }\n  return result;", "    // Create\
    \ an empty vector to hold the elements that occur more than once.\n    std::vector<long>\
    \ duplicates;\n    // Loop through the list of numbers.\n    for (size_t i = 0;\
    \ i < numbers.size(); i++) {\n        // If the current element occurs more than\
    \ once, add it to the list of \n        // duplicates and remove it from the list.\n\
    \        if (duplicates.find(numbers[i]) != duplicates.end()) {\n            duplicates.erase(duplicates.find(numbers[i]));\n\
    \        } else {\n            // If the element does not occur, add it to the\
    \ list of duplicates.\n            duplicates.push_back(numbers[i]);\n       \
    \ }\n    }\n    // Return the list of numbers without the duplicates.\n    return\
    \ duplicates;", "  std::sort(numbers.begin(), numbers.end());\n  numbers.erase(\n\
    \      std::unique(numbers.begin(), numbers.end()),\n      numbers.end());\n\n\
    \  return numbers;", "    // Write your code here.\n    std::vector<long> ans(numbers.begin(),\
    \ numbers.end());\n    std::sort(ans.begin(), ans.end());\n    ans.erase(std::unique(ans.begin(),\
    \ ans.end()), ans.end());\n    return ans;", "    std::vector<long> result;\n\
    \    std::map<long, bool> dupes;\n    for (const auto& num : numbers) {\n    \
    \    if (dupes.count(num)) continue;\n        dupes[num] = true;\n        result.push_back(num);\n\
    \    }\n    return result;", "    // Write your code here.\n    std::vector<long>\
    \ ans;\n    std::set<long> nums;\n    for (long x: numbers)\n        nums.insert(x);\n\
    \    long last;\n    long size = nums.size();\n    while (nums.size() > 1) {\n\
    \        last = nums.end();\n        nums.erase(--last);\n        ans.push_back(last);\n\
    \        size = nums.size();\n    }\n    return ans;", "    // Sort for performance.\n\
    \    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> output;\n\
    \    output.push_back(numbers[0]);\n    for (long i : numbers) {\n        if (i\
    \ != numbers[numbers.size() - 1]) {\n            output.push_back(i);\n      \
    \  }\n    }\n    return output;", "  std::vector<long> numbers_no_dupes;\n  std::sort(numbers.begin(),\
    \ numbers.end());\n  int prev = 0;\n  for (int i = 0; i < numbers.size(); ++i)\
    \ {\n    if (numbers[i] != numbers[i - 1]) {\n      numbers_no_dupes.push_back(numbers[i]);\n\
    \      prev = numbers[i];\n    }\n  }\n  return numbers_no_dupes;", "  // Get\
    \ a vector of the numbers.\n  long long v[numbers.size()];\n  // Copy numbers\
    \ into v.\n  for (size_t i = 0; i < numbers.size(); ++i)\n    v[i] = numbers[i];\n\
    \  // Set up an index, which is incremented whenever the current number is encountered.\n\
    \  // If there is a number at index i, we know we've already encountered it at\
    \ index i-1.\n  long long index = 0;\n  // Iterate through the numbers copying\
    \ v into our result until we have copied all the numbers we need.\n  while (index\
    \ < numbers.size()) {\n    if (numbers[index] == numbers[index - 1]) continue;\n\
    \    numbers[index] = numbers[index - 1];\n    index++;\n  }\n  // Return a vector\
    \ of all our unique numbers.\n  return std::vector<long>(v, v + index);", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> result;\n  long prev = numbers[0];\n  for\
    \ (long n: numbers) {\n    if (n == prev) {\n      continue;\n    }\n    result.push_back(n);\n\
    \    prev = n;\n  }\n  return result;", "  std::vector<long> result;\n  std::set<long>\
    \ numbers_set;\n  std::copy(numbers.begin(), numbers.end(), std::inserter(numbers_set,\
    \ numbers_set.end()));\n  for (long number : numbers_set) {\n    if (result.size()\
    \ < numbers.size()) {\n      result.push_back(number);\n    }\n  }\n  return result;",
  "  std::vector<long> result;\n  long counts[numbers.size()];\n  for(size_t i = 0;\
    \ i < numbers.size(); i++) {\n    counts[i] = 0;\n  }\n  for(size_t i = 0; i <\
    \ numbers.size(); i++) {\n    counts[numbers[i]]++;\n  }\n  // Copy to a new vector:\n\
    \  std::transform(counts.begin(), counts.end(), std::back_inserter(result), [](long\
    \ count) {\n    return count;\n  });\n  return result;", "    assert(numbers.size()\
    \ >= 1);\n    std::vector<long> ans;\n    std::set<long> seen;\n    \n    for\
    \ (long i : numbers) {\n        if (seen.find(i) == seen.end()) {\n          \
    \  seen.insert(i);\n            ans.push_back(i);\n        }\n    }\n    return\
    \ ans;", "    std::vector<long> no_duplicates;\n    // Traverse the vector to\
    \ find duplicates\n    for (size_t i = 0; i < numbers.size(); ++i) {\n       \
    \ long x = numbers[i];\n        long count = no_duplicates.size();\n        long\
    \ index = 0;\n        // If x is not found yet, then add it.\n        while ((index\
    \ < count) && (no_duplicates[index] == x)) {\n            ++index;\n        }\n\
    \        // If x is already in the vector, ignore it.\n        if (index == count)\
    \ {\n            no_duplicates.push_back(x);\n        }\n    }\n    return no_duplicates;",
  "    std::vector<long> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(),\
    \ sorted_numbers.end());\n    std::vector<long> unique;\n    std::vector<long>\
    \ current_number;\n    for (long current_number : sorted_numbers) {\n        long\
    \ next_number = current_number;\n        bool flag = false;\n        for (long\
    \ number : sorted_numbers) {\n            if (number == next_number) {\n     \
    \           flag = true;\n                break;\n            }\n        }\n \
    \       if (flag == false) {\n            unique.push_back(current_number);\n\
    \        }\n    }\n    return unique;", "  assert(!numbers.empty());\n  std::set<long>\
    \ numbers_set;\n  for (const auto &number : numbers)\n    numbers_set.insert(number);\n\
    \  std::vector<long> result;\n  result.push_back(numbers.back());\n  for (const\
    \ auto &number : numbers)\n    if (numbers_set.count(number) == 0)\n      result.push_back(number);\n\
    \  return result;", "  // Initialize a result set to hold the unique numbers.\n\
    \  std::vector<long> result;\n  std::unordered_map<long, long> seen;\n  // Iterate\
    \ through all the numbers in input vector.\n  for (auto n : numbers) {\n    //\
    \ If key not found in seen, insert it with value n.\n    // If key in seen and\
    \ it's value is equal to n, discard it.\n    if (!seen.insert(std::make_pair(n,\
    \ 0)).second) {\n      result.push_back(n);\n    }\n  }\n  // Return result vector.\n\
    \  return result;", "    std::vector<long> output;\n    long last_value;\n   \
    \ for (int index = 0; index < numbers.size(); index++) {\n        if (numbers[index]\
    \ != last_value) {\n            output.push_back(numbers[index]);\n          \
    \  last_value = numbers[index];\n        }\n    }\n    return output;", "\tstd::sort(numbers.begin(),\
    \ numbers.end());\n\tstd::vector<long> result;\n\tlong prev = numbers[0];\n\t\
    for (long next : numbers) {\n\t\tif (prev == next) {\n\t\t\tcontinue;\n\t\t}\n\
    \t\tresult.push_back(prev);\n\t\tprev = next;\n\t}\n\tresult.push_back(prev);\n\
    \treturn result;", "  std::vector<long> uniqueNumbers;\n  long number = 0;\n \
    \ for (int i = 0; i < numbers.size(); i++) {\n    number += numbers[i];\n    while\
    \ (numbers[--i] == number) {\n      uniqueNumbers.push_back(numbers[i]);\n   \
    \ }\n  }\n  return uniqueNumbers;", "    // Start with an empty vector for output.\n\
    \    std::vector<long> out;\n    // Add each element of the input to out.\n  \
    \  for(long number : numbers) {\n        std::find(out.begin(), out.end(), number)\
    \ != out.end()\n            ? out.erase(std::find(out.begin(), out.end(), number))\n\
    \            : out.push_back(number);\n    }\n    return out;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> result(numbers.begin(), numbers.end());\n\
    \  std::size_t index = 0;\n  while (index < result.size()) {\n    if (result[index]\
    \ == numbers[index]) {\n      ++index;\n    } else {\n      result[index] = numbers[index];\n\
    \      ++index;\n    }\n  }\n  return result;", "  // Write your code here.\n\
    \  std::vector<long> temp;\n  for (int i = 0; i < numbers.size(); i++) {\n   \
    \ for (int j = 0; j < i; j++) {\n      if (numbers[j] == numbers[i]) {\n     \
    \   temp.push_back(numbers[i]);\n        break;\n      }\n    }\n  }\n  return\
    \ temp;", "  std::sort(numbers.begin(), numbers.end());\n  numbers.erase(\n  \
    \    std::unique(numbers.begin(), numbers.end(), [](long a, long b) {\n      \
    \  return a < b;\n      }),\n      numbers.end());\n  return numbers;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> output;\n    long count = 1;\n    for\
    \ (std::size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] != numbers[i\
    \ - 1]) {\n            count++;\n            output.push_back(numbers[i]);\n \
    \       }\n    }\n    return output;", "  std::vector<long> result;\n  std::unordered_set<long>\
    \ set;\n  for (long num : numbers)\n    if (set.find(num) == set.end())\n    \
    \  result.push_back(num);\n    set.insert(num);\n  return result;", "    std::vector<long>\
    \ sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n\
    \    std::vector<long> duplicate_nums;\n    long last_num = 0;\n    for (int i\
    \ = 0; i < sorted_numbers.size() - 1; i++) {\n        if (sorted_numbers[i + 1]\
    \ == last_num) {\n            continue;\n        }\n        duplicate_nums.push_back(sorted_numbers[i\
    \ + 1]);\n        last_num = sorted_numbers[i + 1];\n    }\n    return duplicate_nums;",
  "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> result;\n\
    \    result.reserve(numbers.size());\n    for (long number : numbers) {\n    \
    \    if (!result.empty() && result == numbers) {\n            numbers.erase(std::remove(numbers.begin(),\
    \ numbers.end(), number), numbers.end());\n        }\n        else\n         \
    \   result.push_back(number);\n    }\n    return result;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> sorted_numbers;\n  for (std::size_t i =\
    \ 0; i < numbers.size(); ++i) {\n    if (i > 0 && sorted_numbers[i - 1] == numbers[i])\
    \ {\n      continue;\n    }\n    sorted_numbers.push_back(numbers[i]);\n  }\n\
    \  return sorted_numbers;", "    // Create a map with each number as a key\n \
    \   std::unordered_map<long, std::size_t> counts;\n    for (long n : numbers)\
    \ {\n        counts[n]++;\n    }\n    // Now iterate over the map, copying each\
    \ value to the output if its\n    // count is greater than 1.\n    std::vector<long>\
    \ output;\n    for(auto const& count : counts) {\n        if(count.second > 1)\
    \ {\n            output.push_back(count.first);\n        }\n    }\n    return\
    \ output;", "  assert(!numbers.empty());\n\n  std::vector<long> result(numbers.begin(),\
    \ numbers.end());\n  std::sort(numbers.begin(), numbers.end());\n  for (long i\
    \ = 0; i < numbers.size(); ++i) {\n    if (result[i] == i) {\n      continue;\n\
    \    }\n    if (result[i] == numbers[i - 1]) {\n      result[i - 1] += 1;\n  \
    \    continue;\n    }\n    result[i] = numbers[i - 1] + 1;\n  }\n  return result;",
  "  std::vector<long> res;\n  for (long i : numbers) {\n    if (!res.count(i)) {\n\
    \      res.push_back(i);\n    }\n  }\n  return res;", "    std::vector<long> result;\n\
    \    std::sort(numbers.begin(), numbers.end());\n\n    for (std::size_t i = 1;\
    \ i < numbers.size(); ++i) {\n        if (numbers[i] == numbers[i - 1]) {\n  \
    \          continue;\n        }\n        result.push_back(numbers[i]);\n    }\n\
    \    return result;", "    std::vector<long> no_duplicates;\n    // Loop through\
    \ the original vector and for each element add\n    // to the no_duplicates vector\
    \ if that element does not occur\n    // yet.\n    for(std::size_t i = 0; i <\
    \ numbers.size(); i++) {\n        long current = numbers[i];\n        bool isSet\
    \ = false;\n        for(std::size_t j = 0; j < no_duplicates.size(); j++) {\n\
    \            if(no_duplicates[j] == current) {\n                isSet = true;\n\
    \            }\n        }\n        if(!isSet) {\n            no_duplicates.push_back(current);\n\
    \        }\n    }\n    return no_duplicates;", "    std::vector<long> v;\n   \
    \ std::map<long, bool> map;\n\n    for (auto i : numbers)\n        map[i] = false;\n\
    \n    for (auto i : numbers)\n        if (map[i])\n            v.push_back(i);\n\
    \n    return v;", "    std::vector<long> unique_elements;\n    std::vector<long>\
    \ seen_elements;\n    std::vector<long> output;\n\n    std::unordered_set<long>\
    \ seen;\n    for (long number : numbers)\n    {\n        if (!seen.insert(number).second)\n\
    \        {\n            unique_elements.push_back(number);\n        }\n      \
    \  else\n        {\n            seen_elements.push_back(number);\n        }\n\
    \    }\n\n    for (long element : unique_elements)\n    {\n        if (!seen_elements.empty())\n\
    \        {\n            long last_element = seen_elements.back();\n          \
    \  if (element == last_element)\n            {\n                seen_elements.pop_back();\n\
    \            }\n            else\n            {\n                output.push_back(element);\n\
    \            }\n        }\n        else\n        {\n            output.push_back(element);\n\
    \        }\n    }\n\n    return output;", "    long long ans = 0;\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    for (long long cur = 0; cur < numbers.size(); ++cur) {\n\
    \        while (cur + 1 < numbers.size() &&\n               numbers[cur] == numbers[cur\
    \ + 1]) {\n            ++cur;\n        }\n        ans += cur;\n    }\n    std::vector<long>\
    \ res(ans);\n    for (long long cur = 0; cur < ans; cur++) {\n        res[cur]\
    \ = numbers[cur];\n    }\n    return res;", "    std::vector<long> result;\n \
    \   std::set<long> seen;\n    for (long num : numbers) {\n        if (seen.find(num)\
    \ == seen.end())\n            seen.insert(num);\n        else\n            result.push_back(num);\n\
    \    }\n    return result;", "  assert(numbers.size()!=0);\n  long count=1;\n\
    \  long max_element=numbers[0];\n  for(long i=0;i<numbers.size();i++){\n    if(numbers[i]==max_element){\n\
    \      count+=1;\n    }else{\n      if(count!=1){\n        numbers[max_element-count]=numbers[i];\n\
    \      }\n      count=1;\n      max_element=numbers[i];\n    }\n  }\n  if(count!=1){\n\
    \    numbers[max_element-count]=numbers[i];\n  }\n  return numbers;", "    std::vector<long>\
    \ temp;\n    std::set<long> s;\n    for (long i : numbers) {\n        if (s.find(i)\
    \ == s.end()) {\n            s.insert(i);\n            temp.push_back(i);\n  \
    \      }\n    }\n    return temp;", "  assert(numbers.size() >= 2);\n  std::vector<long>\
    \ duplicates;\n  long first = numbers[0];\n  for (long num : numbers) {\n    if\
    \ (num == first) {\n      duplicates.push_back(num);\n    } else {\n      duplicates.push_back(first);\n\
    \      first = num;\n    }\n  }\n  return duplicates;", "  struct {\n    std::vector<long>\
    \ v;\n  } seen;\n  numbers.clear();\n  numbers.push_back(0);\n  numbers.push_back(0);\n\
    \  for (auto &i : numbers) {\n    if (seen.v.count(i)) {\n      numbers.erase(numbers.begin()\
    \ + seen.v[i]);\n    } else {\n      seen.v.push_back(i);\n    }\n  }\n  return\
    \ numbers;", "    std::vector<long> result;\n    std::unordered_set<long> set;\
    \ // set<long>\n    for (const auto &n : numbers)\n        set.insert(n);\n  \
    \  for (const auto &n : set)\n        result.push_back(n);\n    return result;",
  "    // Your code here\n    auto it = numbers.begin();\n    std::set<long> unique;\n\
    \    while (it != numbers.end()) {\n        if (unique.find(*it) == unique.end())\
    \ {\n            unique.insert(*it);\n        }\n        ++it;\n    }\n    return\
    \ unique;", "  if(numbers.empty())\n    return numbers;\n  long prev = numbers.back();\n\
    \  numbers.erase(std::remove_if(numbers.begin(), numbers.end(), [&prev](long n){\n\
    \    return n != prev;\n  }), numbers.end());\n  return numbers;", "  std::set<long>\
    \ seen;\n  std::vector<long> result;\n\n  for (long num : numbers) {\n    if (!seen.count(num))\
    \ {\n      result.push_back(num);\n      seen.insert(num);\n    }\n  }\n\n  return\
    \ result;", "    std::set<long> set;\n    for (const auto& num : numbers) {\n\
    \        set.insert(num);\n    }\n    std::vector<long> result;\n    result.insert(result.end(),\
    \ set.begin(), set.end());\n    return result;", "    // Write your code here.\n\
    \    std::map<long, int> m;\n    for (const auto &num : numbers)\n        m[num]\
    \ = 0;\n    for (auto &num : numbers)\n        m[num] += 1;\n    std::vector<long>\
    \ new_nums;\n    for (auto &num : numbers) {\n        if (m[num] == 1)\n     \
    \       new_nums.push_back(num);\n    }\n    return new_nums;", "    long num_unique\
    \ = 0;\n    std::vector<long> unique_numbers;\n    std::unordered_map<long, bool>\
    \ visited;\n    std::unordered_set<long> unique_nums;\n\n    for (long num: numbers)\
    \ {\n        if (visited[num] == false) {\n            visited[num] = true;\n\
    \            unique_nums.insert(num);\n            num_unique++;\n           \
    \ unique_numbers.push_back(unique_nums.begin());\n        } else {\n         \
    \   unique_nums.erase(unique_nums.find(num));\n        }\n    }\n\n    return\
    \ unique_numbers;", "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    for (long i : numbers) {\n        if (i == numbers.back()) {\n\
    \            result.pop_back();\n        } else {\n            result.push_back(i);\n\
    \        }\n    }\n    return result;", "  std::vector<long> result;\n  std::map<long,\
    \ bool> seen;\n  for (auto x : numbers) {\n    if (seen.find(x) == seen.end())\n\
    \      seen.insert({x, true});\n    else\n      result.push_back(x);\n  }\n  return\
    \ result;", "    if (numbers.empty()) {\n        return {};\n    }\n\n    std::vector<long>\
    \ result;\n    std::set<long> seen;\n    result.push_back(numbers.front());\n\
    \    seen.insert(result.back());\n\n    for (long i : numbers) {\n        if (seen.find(i)\
    \ == seen.end()) {\n            result.push_back(i);\n            seen.insert(i);\n\
    \        }\n    }\n\n    return result;", "    std::sort(numbers.begin(), numbers.end());\n\
    \    std::vector<long> result;\n    long temp = 0;\n    for (long &n: numbers)\
    \ {\n        if ( n == temp ) {\n            result.push_back(temp);\n       \
    \ }\n        temp = n;\n    }\n    return result;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    auto last = numbers.begin();\n    for (auto it = numbers.begin();\
    \ it != numbers.end(); ++it) {\n        if (it != last && *it == *last) {\n  \
    \          numbers.erase(last);\n            numbers.erase(it);\n        }\n \
    \       last++;\n    }\n    return numbers;", "   std::sort(numbers.begin(), numbers.end());\n\
    \   long long count = std::accumulate(numbers.begin(), numbers.end(), 0);\n  \
    \ std::vector<long> result(numbers.begin(), numbers.end());\n   std::for_each(numbers.begin(),\
    \ numbers.end(), [&](long long n) {\n      while (*numbers.find(n) != numbers.end())\
    \ {\n         ++n;\n      }\n      numbers.push_back(n);\n   });\n   std::sort(result.begin(),\
    \ result.end());\n   return result;", "    std::vector<long> output;\n    std::unordered_set<long>\
    \ set{};\n    output.push_back(numbers.front());\n    for (long i : numbers)\n\
    \        set.insert(i);\n    for (const auto & i : set)\n        output.push_back(i);\n\
    \    return output;", "    auto last = std::unique(numbers.begin(), numbers.end());\n\
    \    numbers.erase(last, numbers.end());\n    return numbers;", "    std::set<long>\
    \ numbers_set;\n    for (auto &element : numbers) {\n        numbers_set.insert(element);\n\
    \    }\n    numbers.clear();\n    for (auto &element : numbers_set) {\n      \
    \  numbers.push_back(element);\n    }\n    return numbers;", "  std::vector<long>\
    \ result;\n  for (long i : numbers) {\n    if (std::find(result.begin(), result.end(),\
    \ i) == result.end())\n      result.push_back(i);\n  }\n  return result;", "\t\
    std::sort(numbers.begin(), numbers.end());\n\tstd::vector<long> result;\n\tlong\
    \ prev = numbers[0];\n\tfor (long number : numbers) {\n\t\tif (number != prev)\
    \ {\n\t\t\tresult.push_back(number);\n\t\t\tprev = number;\n\t\t}\n\t}\n\treturn\
    \ result;", "  std::vector<long> result(numbers.size());\n  std::iota(result.begin(),\
    \ result.end(), 0);\n\n  // Use a set to remember what numbers we have already\
    \ seen\n  std::set<long> seen;\n\n  // Remove numbers that we have seen before\n\
    \  for (size_t i = 0; i < numbers.size(); i++) {\n    if (seen.find(numbers[i])\
    \ == seen.end()) {\n      result[i] = numbers[i];\n      seen.insert(numbers[i]);\n\
    \    }\n  }\n  return result;", "  std::vector<long> result;\n  result.push_back(numbers[0]);\n\
    \  for (long &i : numbers) {\n    if (i == result.back()) result.push_back(i);\n\
    \  }\n  return result;", "    std::vector<long> result;\n    long first = numbers[0];\n\
    \    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i] !=\
    \ first) {\n            result.push_back(first);\n            first = numbers[i];\n\
    \        }\n    }\n    return std::vector<long>(std::begin(result), std::end(result));",
  "    std::sort(numbers.begin(), numbers.end());\n    auto last = std::unique(numbers.begin(),\
    \ numbers.end());\n    numbers.erase(last, numbers.end());\n    return numbers;",
  "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> output;\n\
    \    for (int i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] != numbers[i\
    \ - 1]) {\n            output.push_back(numbers[i]);\n        }\n    }\n    return\
    \ output;", "  std::vector<long> result(numbers.size());\n  std::iota(result.begin(),\
    \ result.end(), 0);\n  std::sort(result.begin(), result.end());\n  return result;",
  "    std::unordered_map<long, bool> m;\n    std::vector<long> result;\n    for (auto\
    \ n: numbers)\n        m[n] = true;\n    for (auto it = m.begin(); it != m.end();\
    \ ++it)\n        if (!result.empty() && *it == it->first)\n            result.erase(result.begin());\n\
    \    else\n        result.push_back(*it);\n    return result;", "  std::sort(numbers.begin(),\
    \ numbers.end());\n  std::vector<long> result(numbers.size());\n  for (size_t\
    \ i = 0; i < numbers.size(); ++i) {\n    long current = numbers[i];\n    int j\
    \ = 0;\n    while (j < result.size() && current == result[j]) {\n      ++j;\n\
    \    }\n    result[j] = current;\n  }\n  return result;", "    // Write your code\
    \ here.\n    std::sort(numbers.begin(), numbers.end());\n    std::vector<long>\
    \ result;\n    long current_number = numbers[0];\n    for (long i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] == current_number) {\n            continue;\n\
    \        }\n        result.push_back(current_number);\n        current_number\
    \ = numbers[i];\n    }\n    result.push_back(current_number);\n    return result;",
  "    std::vector<long> result;\n    std::set<long> numsSet;\n    for (long num :\
    \ numbers) {\n        if (numsSet.find(num) == numsSet.end()) {\n            result.push_back(num);\n\
    \            numsSet.insert(num);\n        }\n    }\n    return std::move(result);",
  "    std::vector<long> unique_numbers;\n    for(auto i : numbers) {\n        if(unique_numbers.find(i)\
    \ == unique_numbers.end()) unique_numbers.push_back(i);\n    }\n    return unique_numbers;",
  "  std::vector<long> result;\n  std::set<long> values;\n  for (auto const &i : numbers)\
    \ {\n    values.insert(i);\n  }\n  for (auto const &i : values) {\n    result.push_back(i);\n\
    \  }\n  return result;", "    std::vector<long> unique_numbers;\n    unique_numbers.reserve(numbers.size());\n\
    \    for (auto x : numbers) {\n        if (unique_numbers.count(x)) {\n      \
    \      unique_numbers.erase(std::remove(unique_numbers.begin(), unique_numbers.end(),\
    \ x), unique_numbers.end());\n        } else {\n            unique_numbers.push_back(x);\n\
    \        }\n    }\n    return unique_numbers;", "    assert(!numbers.empty());\n\
    \    std::unordered_set<long> seen{numbers.begin(), numbers.end()};\n    std::vector<long>\
    \ out;\n    for (long num : numbers)\n        if (seen.count(num) == 0)\n    \
    \        out.push_back(num);\n    return out;", "    std::vector<long> result;\n\
    \    long lastNumber;\n    for (const auto &number : numbers) {\n        if (!number\
    \ || lastNumber == number) {\n            result.push_back(number);\n        }\
    \ else {\n            lastNumber = number;\n        }\n    }\n    return result;",
  "    std::sort(numbers.begin(), numbers.end());\n    std::vector<long> results(numbers.begin(),\
    \ numbers.end());\n    std::set<long> seen;\n    size_t pos = 0;\n    while ((pos\
    \ = results.size()) != numbers.size()) {\n        if (seen.find(numbers[pos])\
    \ != seen.end()) {\n            results.erase(results.begin() + pos);\n      \
    \  } else {\n            seen.insert(numbers[pos]);\n        }\n    }\n    return\
    \ results;", "  std::vector<long> output;\n  std::unordered_set<long> seen;\n\n\
    \  for (auto n : numbers) {\n    if (seen.count(n) == 0) {\n      output.push_back(n);\n\
    \      seen.insert(n);\n    }\n  }\n\n  return output;", "  long long ans = 0;\n\
    \  long long sum = 0;\n  for (auto x: numbers) {\n    sum = sum + x;\n    if (sum\
    \ == ans) {\n      std::cout << \"Sum is \" << sum << std::endl;\n      ans =\
    \ sum;\n      numbers.erase(numbers.begin() + numbers.find(x));\n    } else {\n\
    \      ans = sum;\n    }\n  }\n  return numbers;", "    std::sort(numbers.begin(),\
    \ numbers.end());\n    std::vector<long> result;\n    result.push_back(numbers[0]);\n\
    \    for (long i : numbers) {\n        for (long j : result) {\n            if\
    \ (j == i) {\n                break;\n            }\n            if (j < i) {\n\
    \                break;\n            }\n            result.push_back(j);\n   \
    \     }\n    }\n    return result;", "    // Create a vector to store the unique\
    \ numbers in.\n    std::vector<long> uniques(numbers.size());\n\n    // Iterate\
    \ over all elements of numbers and push them into the uniques vector.\n    for\
    \ (long number : numbers) {\n        int index = -1;\n        // Iterate over\
    \ the uniques vector to see if it's already been used.\n        for (auto &i :\
    \ uniques) {\n            // If the number at the current index equals the number\
    \ at the current index in the uniques vector,\n            // then we know that\
    \ we've found a duplicate.\n            if (number == i) {\n                index\
    \ = uniques.end();\n                break;\n            }\n        }\n\n     \
    \   // If we haven't found a duplicate yet, then push number into the uniques\
    \ vector.\n        if (index == -1)\n            uniques.push_back(number);\n\
    \    }\n\n    return uniques;", "    std::vector<long> res;\n    long count =\
    \ 1;\n    for (auto i : numbers) {\n        if (res.find(i) == res.end())\n  \
    \          res.push_back(i);\n        else\n            count = res.find(i) +\
    \ 1;\n    }\n    for (auto i : numbers) {\n        if (res.find(i) == res.end())\n\
    \            res.push_back(i);\n        else\n            res[count++] = i;\n\
    \    }\n    return res;", "    std::vector<long> unique_numbers;\n    for (long\
    \ &number: numbers) {\n        if (std::find(unique_numbers.begin(), unique_numbers.end(),\
    \ number) == unique_numbers.end()) {\n            unique_numbers.push_back(number);\n\
    \        }\n    }\n    return unique_numbers;", "  // Keep original order as in\
    \ the input.\n  std::sort(numbers.begin(), numbers.end());\n  std::vector<long>\
    \ new_numbers;\n  new_numbers.reserve(numbers.size());\n  long previous = numbers[0];\n\
    \  for (long i : numbers) {\n    if (i != previous) {\n      new_numbers.push_back(previous);\n\
    \    }\n    previous = i;\n  }\n  new_numbers.push_back(previous);\n  return new_numbers;",
  "    std::sort(numbers.begin(), numbers.end());\n    numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n    return numbers;", "  // create map of numbers\n\
    \  std::unordered_map<int, int> numbers_index;\n  for (long i = 0; i < numbers.size();\
    \ i++) {\n    numbers_index[numbers[i]] = i;\n  }\n\n  // create output vector\n\
    \  std::vector<long> output;\n\n  // iterate through numbers in input vector\n\
    \  for (long i = 0; i < numbers.size(); i++) {\n    // check if the current number\
    \ is in the output vector\n    if (numbers_index.find(numbers[i]) != numbers_index.end())\
    \ {\n      continue;\n    }\n    // add the current number to the output vector\n\
    \    output.push_back(numbers[i]);\n  }\n\n  // return the output vector\n  return\
    \ output;", "    std::vector<long> res;\n    long last_val = numbers[0];\n   \
    \ for (long i = 0; i < numbers.size(); i++) {\n        if (numbers[i] != last_val)\
    \ {\n            res.push_back(last_val);\n            last_val = numbers[i];\n\
    \        }\n    }\n    return res;", "    std::vector<long> ret;\n    \n    for(long\
    \ i : numbers)\n    {\n        long first = i;\n        for(long j : numbers)\n\
    \        {\n            if(first != j && i == j)\n            {\n            \
    \    break;\n            }\n        }\n        ret.push_back(first);\n    }\n\
    \    \n    return ret;", "    std::vector<long> uniques;\n    std::set<long> seen;\n\
    \    for (long elem : numbers) {\n        if (seen.find(elem) == seen.end()) {\n\
    \            uniques.push_back(elem);\n            seen.insert(elem);\n      \
    \  }\n    }\n    return uniques;", "    std::vector<long> new_numbers;\n    for(long\
    \ number: numbers) {\n        std::map<long, long>::iterator it = numbers.begin();\n\
    \        while(it != numbers.end() && it->second == number)\n            ++it;\n\
    \        if(it != numbers.end()) {\n            for(long k = number; k < it->second;\
    \ ++k)\n                new_numbers.push_back(k);\n            numbers.erase(it);\n\
    \        } else {\n            new_numbers.push_back(number);\n        }\n   \
    \ }\n    return new_numbers;", "  std::vector<long> result;\n  std::unordered_set<long>\
    \ seen;\n  for (auto i : numbers) {\n    if (seen.find(i) != seen.end())\n   \
    \   continue;\n    result.push_back(i);\n    seen.insert(i);\n  }\n  return result;",
  "  assert(!numbers.empty());\n  // Count the occurrences of each element (assume\
    \ it exists).\n  std::map<long, int> number_counts;\n  for (auto number : numbers)\
    \ {\n    auto it  = number_counts.find(number);\n    if (it == number_counts.end())\
    \ number_counts[number] = 0;\n    ++it->second;\n  }\n  std::vector<long> result;\n\
    \  // Add numbers with unique occurrences.\n  for (auto const &number_count :\
    \ number_counts) {\n    if (number_count.second == 1) result.push_back(number_count.first);\n\
    \  }\n  return result;", "    long n = numbers.size();\n    long cnt[MAXN];\n\
    \    for (int i = 0; i < n; ++i) {\n        cnt[numbers[i]]++;\n    }\n    std::vector<long>\
    \ new_nums(n), unique_nums(n);\n    for (long i = 0; i < n; ++i) {\n        if\
    \ (cnt[numbers[i]] == 1) {\n            unique_nums[i] = numbers[i];\n       \
    \ } else {\n            new_nums[cnt[numbers[i]]++] = numbers[i];\n        }\n\
    \    }\n    return new_nums;"]
stop_tokens:
- "\n}"
