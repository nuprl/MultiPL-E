name: HumanEval_16_count_distinct_characters
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out\
  \ how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters('xyzXYZ')\n\
  // 3\n// >>> count_distinct_characters('Jerry')\n// 4\nlong count_distinct_characters(std::string\
  \ string) {\n"
tests: "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\
  \")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"\
  abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n\
  \    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
completions: ["  long count = 0;\n  assert(!string.empty());\n  for (char c : string)\n\
    \    count = count + (string(c) - 'a' + 1);\n  return count;", "  long result\
    \ = 0;\n  for (char character : string) {\n    if (character <= 'Z' || character\
    \ >= 'z') {\n      result += 2;\n    } else {\n      result += 1;\n    }\n  }\n\
    \  return result;", "  // Write your code here\n  long sum = 0;\n  for (auto &c\
    \ : string)\n    sum += (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n  return\
    \ sum;", "    int count = 0; // count how many distinct characters are in the\
    \ string\n    for (int i = 0; i < string.length(); i++) {\n        std::transform(string.begin()\
    \ + i, string.begin() + i + 1, string.begin() + i, ::tolower);\n        std::string\
    \ temp;\n        for (char c : string) {\n            if (temp == \"\") {\n  \
    \              temp = c;\n            } else {\n                if (c == temp)\
    \ {\n                    temp += c;\n                } else {\n              \
    \      count++;\n                    temp = c;\n                }\n          \
    \  }\n        }\n    }\n    return count;", "    long num_distinct_characters\
    \ = 0;\n    int str_len = string.length();\n    for(int i = 0; i < str_len; i++){\n\
    \        std::string temp_str = string[i] + string[i+1];\n        if(find(string.begin(),\
    \ string.end(), temp_str) != string.end()){\n            string.erase(string.begin()\
    \ + i, 1);\n            str_len--;\n            num_distinct_characters++;\n \
    \       }\n    }\n    return num_distinct_characters;", "    // Create a map of\
    \ all the lowercase letters. We will use this map to compare each letter with\
    \ its\n    // counterpart\n    std::unordered_map<char, int> lowercase_map;\n\n\
    \    for (char i : string) {\n        // If we haven't seen this letter before,\
    \ increment its count by 1\n        if (lowercase_map.find(i) == lowercase_map.end())\
    \ {\n            lowercase_map[i] = 1;\n        } else {\n            // Else\
    \ increment its count by 1\n            ++(lowercase_map[i]);\n        }\n   \
    \ }\n\n    // Initialize a count variable to store the number of distinct characters\
    \ in the string\n    int count = 0;\n\n    // Loop through all the lowercase letters\
    \ in the map\n    for (auto i : lowercase_map) {\n        // If the counter variable\
    \ is bigger than the string length, that means that we have encountered\n    \
    \    // all the distinct characters in the string\n        if (i.second > string.length())\n\
    \            break;\n\n        // Increment count by 1\n        count += i.second;\n\
    \    }\n\n    return count;", "    long n = 1;\n    long temp = 1;\n    for (char\
    \ ch : string) {\n        temp = temp * 10;\n        temp += ch - 'a' + 1;\n \
    \   }\n    while (temp >= 10) {\n        n++;\n        temp = temp / 10;\n   \
    \ }\n    return n;", "    long count = 1;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        count += string.at(i) - 'A';\n    }\n    return count;", " \
    \   // Complete this function\n    int length = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] != string[0]) {\n            length = length -\
    \ 1;\n        }\n    }\n    return length;", "    long res = 0;\n    // We need\
    \ to convert the input string into lowercase\n    for (auto const &c: string)\n\
    \        c = tolower(c);\n    // Now, loop over every character in the string\n\
    \    for (int i = 0; i < string.length(); i++) {\n        // For each character\
    \ check if it is in the set already. If not, increment the counter\n        if\
    \ (find(string.begin(), string.end(), string[i]) == string.end())\n          \
    \  res++;\n    }\n    return res;", "    std::map<char, int> char_map;\n    for(char\
    \ c : string)\n        char_map[c]++;\n    return std::accumulate(char_map.begin(),\
    \ char_map.end(), 0, [&](long a, const std::pair<char, int>& b) {\n        return\
    \ a + b.second;\n    });", "    long count = 0;\n    long sum = 0;\n    for (long\
    \ i = 0; i <= string.length(); i++)\n        if (string[i] >= 'a' && string[i]\
    \ <= 'z')\n            count++;\n        else\n            sum++;\n    return\
    \ sum;", "    if (string.length() == 0)\n        return 0;\n    long count = 0;\n\
    \    for (int i = 0; i < string.length(); i++)\n        for (int j = i + 1; j\
    \ <= string.length(); j++) {\n            if (string[i] != string[j])\n      \
    \          break;\n            count++;\n        }\n    return count;", "    long\
    \ result = 0;\n    for (int i = 0; i < string.size(); i++) {\n        char ch\
    \ = string[i];\n        if (tolower(ch) == tolower(string[i - 1])) result++;\n\
    \        else result--;\n    }\n    return result;", "    long count = 0;\n  \
    \  for (auto &c : string) {\n        if (std::tolower(c) == c) count++;\n    }\n\
    \    return count;", "  // Use a hash map to store the count\n  std::unordered_map<char,\
    \ long> mp;\n  // Loop through the string and store the characters in hash map\
    \ with the character as the key\n  for (char ch : string) {\n    mp[ch]++;\n \
    \ }\n  // Loop through the hash map and get the count for each character and sum\
    \ the count\n  long ans = 0;\n  for (const auto& c : mp) {\n    ans += c.second;\n\
    \  }\n  // Return the result\n  return ans;", "    // Step 1: Declare an array\
    \ of size 26\n    long arr[21];\n    // Step 2: Fill up the array with values\
    \ 0, 1, 2... 25, 26\n    for (long i = 0; i < 21;) {\n        arr[i] = 2 * i +\
    \ 1;\n        i += 26;\n    }\n    // Step 3: Initialize a variable that stores\
    \ count of distinct characters\n    int count = 0;\n    // Step 4: Iterate over\
    \ the string and increment count for every different character\n    for (int i\
    \ = 0; i < string.length(); ++i) {\n        count += arr[string[i] - 'a']; //\
    \ Assuming all characters are lowercase.\n    }\n    return count;", "    long\
    \ result = 0;\n    // Loop to check if any character exists in the string\n  \
    \  for (char &i : string) {\n        switch (tolower(i)) {\n            // If\
    \ character is in lower case, increment the count by 1\n            case 'a':\n\
    \            case 'b':\n            case 'c':\n            case 'd':\n       \
    \     case 'e':\n            case 'f':\n            case 'g':\n            case\
    \ 'h':\n            case 'i':\n            case 'j':\n            case 'k':\n\
    \            case 'l':\n            case 'm':\n            case 'n':\n       \
    \     case 'o':\n            case 'p':\n            case 'q':\n            case\
    \ 'r':\n            case 's':\n            case 't':\n            case 'u':\n\
    \            case 'v':\n            case 'w':\n            case 'x':\n       \
    \     case 'y':\n            case 'z':\n                result += 1;\n       \
    \         break;\n            // If character is in upper case, increment the\
    \ count by 1\n            case 'A':\n            case 'B':\n            case 'C':\n\
    \            case 'D':\n            case 'E':\n            case 'F':\n       \
    \     case 'G':\n            case 'H':\n            case 'I':\n            case\
    \ 'J':\n            case 'K':\n            case 'L':\n            case 'M':\n\
    \            case 'N':\n            case 'O':\n            case 'P':\n       \
    \     case 'Q':\n            case 'R':\n            case 'S':\n            case\
    \ 'T':\n            case 'U':\n            case 'V':\n            case 'W':\n\
    \            case 'X':\n            case 'Y':\n            case 'Z':\n       \
    \         result += 1;\n                break;\n            // If character is\
    \ neither lower nor upper, increment the count by 1\n            default:\n  \
    \              result += 1;\n                break;\n        }\n    }\n    return\
    \ result;", "    long n = 1;\n    for (auto letter : string) {\n        std::transform(letter.begin(),\
    \ letter.end(), letter.begin(), ::toupper);\n        long count = std::count_if(string.begin(),\
    \ string.end(), [&letter](char c){ return c == letter; });\n        n += count;\n\
    \    }\n    return n;", "    long num_distinct = 0;\n    long prev = 0;\n    for\
    \ (long i = 0; i < string.length(); i++) {\n        prev = string[i];\n      \
    \  long curr = string[i];\n        for (long j = i + 1; j < string.length(); j++)\
    \ {\n            curr = ((curr == string[j]) ? prev : prev != string[j] ? string[j]\
    \ : prev);\n            num_distinct++;\n            prev = curr;\n        }\n\
    \    }\n    return num_distinct;", "    long count = 0;\n    for (char c : string)\
    \ {\n        if (string.find(c) != string::npos) {\n            ++count;\n   \
    \     }\n    }\n    return count;", "    long count = 0;\n    for (int i = 0;\
    \ i < string.size(); i++) {\n        if (string.at(i) >= 'A' && string.at(i) <=\
    \ 'Z') {\n            count++;\n        }\n    }\n    return count;", "    if\
    \ (string.empty())\n        return 0;\n    long ans = 0;\n    for (auto c: string)\
    \ {\n        if ('A' <= c && c <= 'Z')\n            ans += 1;\n        else if\
    \ (c != 'i')\n            ans += 2;\n    }\n    return ans;", "    long uniqueChar\
    \ = 0;\n    for (auto &i : string) {\n        uniqueChar++;\n    }\n    return\
    \ uniqueChar;", "    long count = 0;\n    for (char c : string) if (isalpha(c))\
    \ count++;\n    return count;", "  std::sort(string.begin(), string.end());\n\
    \  int length = string.length();\n  int prev = string[0];\n  long ans = 0;\n \
    \ for (int i = 0; i < length; i++) {\n    if (string[i] == prev) {\n      ans++;\n\
    \    } else {\n      prev = string[i];\n      ans = 1;\n    }\n  }\n  return ans;",
  "    long distinctCharacters = 0;\n    for (int i = 0; i < string.size(); i++) {\n\
    \        if (string[i] >= 65 && string[i] <= 90) {\n            distinctCharacters\
    \ += 1;\n        }\n    }\n    return distinctCharacters;", "    long distinctCount\
    \ = 0;\n    for (char c : string) {\n        distinctCount = (distinctCount +\
    \ 1) * (1 - (int)toupper(c) - (int)tolower(c));\n    }\n    return distinctCount;",
  "    long long int ans = 0;\n    unordered_map<char,int> map;\n    for(auto &c:string)\
    \ {\n        if(map.find(c)!=map.end()) {\n            ans += map[c];\n      \
    \  } else {\n            map[c]=1;\n            ans++;\n        }\n    }\n   \
    \ return ans;", "  int size = string.size();\n  long ans = 0;\n  for (int i =\
    \ 0; i < size; ++i) {\n    char ch = string[i];\n    if (ch >= 'A' && ch <= 'Z')\n\
    \      ans ++;\n    else if (ch >= 'a' && ch <= 'z')\n      ans ++;\n    else\
    \ if (ch >= '0' && ch <= '9')\n      ans ++;\n  }\n  return ans;", "    long cnt\
    \ = 0;\n    for (char c : string)\n        if (c == tolower(c)) cnt++;\n     \
    \   else cnt--;\n    return cnt;", "    std::map<char, long> char_counter;\n \
    \   for (char character : string)\n        char_counter[character]++;\n    return\
    \ char_counter.size();", "    long n_distinct = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        for (int j = 0; j < string.length(); j++) {\n            if\
    \ (i != j && string[i] == string[j]) { n_distinct++; }\n        }\n    }\n   \
    \ return n_distinct;", "    long ans = 0;\n    for(char c: string) {\n       \
    \ // Ignore case\n        if(!islower(c) && !isupper(c))\n            continue;\n\
    \n        ans++;\n    }\n    return ans;", "\t// your code goes here\n\tint result\
    \ = 0;\n\tint prev = 0;\n\tint current = 1;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] != prev && string[i] != current) {\n\t\t\tresult =\
    \ result + 1;\n\t\t\tcurrent = string[i];\n\t\t}\n\t\tprev = string[i];\n\t}\n\
    \treturn result;", "    long ans = 0;\n    for (long i = 0; i < string.length();\
    \ i++) {\n        long prev = i - 1;\n        if (string[i] == string[prev]) {\n\
    \            ans++;\n        }\n    }\n    return ans;", "\tlong count = 1;\n\t\
    for (char c : string)\n\t\tif (tolower(c) != c)\n\t\t\tcount++;\n\treturn count;",
  "    long number_of_characters = 0;\n    for (long i = 0; i <= string.length();\
    \ i++) {\n        long count = 0;\n        for (long j = i; j < string.length();\
    \ j++) {\n            if (string[j] == string[i]) {\n                count++;\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    number_of_characters += count;\n    }\n    return number_of_characters;",
  "    long result = 0;\n    for(char ch:string){\n        result ^= ch;\n    }\n\
    \    return result;", "    // unordered_set: it guarantees that the data structure\
    \ will not contain any duplicates\n    unordered_set<char> chars;\n\n    for(char\
    \ &c: string) {\n        c = toupper(c);\n        chars.insert(c);\n    }\n\n\
    \    return chars.size();", "    std::map<char, int> m;\n    for (char c : string)\
    \ {\n        if (m.find(c) == m.end()) {\n            m[c] = 1;\n        } else\
    \ {\n            m[c]++;\n        }\n    }\n    return m.size();", "    // initialize\
    \ a map of unique character and number of them\n    std::map<char, int> mymap;\n\
    \n    // iterate over all characters\n    for (char c : string) {\n        //\
    \ insert a new key-value pair in our map\n        mymap[c] = mymap[c] + 1;\n \
    \   }\n    // return the total number of the distinct characters\n    return mymap.size();",
  "  // Initialize a vector with 0\n  long distinct_characters = 0;\n  \n  for (auto\
    \ &character : string) {\n    // If the current character is not an alphabet\n\
    \    if (character >= 'A' && character <= 'Z') \n      distinct_characters++;\n\
    \  }\n  \n  return distinct_characters;", "    long count = 0;\n    for (int i\
    \ = 0; i < string.size(); i++)\n    {\n        // Count the number of times each\
    \ character occurs in string\n        for (int j = 0; j < string.size(); j++)\n\
    \        {\n            if (i == j)\n                continue;\n            if\
    \ (string[i] == string[j])\n            {\n                count++;\n        \
    \    }\n        }\n    }\n    return count;", "\tlong count = 0;\n\t// Count each\
    \ distinct character (regardless of case)\n\tfor (char c : string) {\n\t\tif (isupper(c))\
    \ count++;\n\t\telse if (!isupper(c)) count--;\n\t}\n\treturn count;", "    long\
    \ result = 0;\n    for (char c : string)\n        result += toupper(c) - toupper(tolower(c));\n\
    \    return result;", "\t// Write your code here\n\tlong count = 0;\n\tfor (auto\
    \ it = string.cbegin(); it != string.cend(); it++)\n\t{\n\t\tif (string[it] ==\
    \ string[it - 1])\n\t\t{\n\t\t\tcount++;\n\t\t}\n\t}\n\t\n\treturn count;", " \
    \   int n = string.size();\n    vector<int> arr(n,0);\n    for(int i=0; i<n; i++){\n\
    \        arr[ tolower(string[i]) ] += 1;\n    }\n    long ans = 0;\n    for(int\
    \ i=0; i<n; i++){\n        ans += arr[i];\n    }\n    return ans;", "    long\
    \ result = 0;\n    for (auto it = string.cbegin(); it != string.cend(); it++)\n\
    \    {\n        if (!std::islower(*it))\n        {\n            result += std::toupper(*it)\
    \ - 'A' + 1;\n        }\n        else\n        {\n            result += std::tolower(*it)\
    \ - 'a' + 1;\n        }\n    }\n    return result;", "    std::unordered_set<char>\
    \ char_set;\n    long ans = 0;\n    for (char c : string)\n        if (char_set.find(c)\
    \ == char_set.eof())\n            char_set.insert(c);\n        else\n        \
    \    ans++;\n    return ans;", "    int len = (int) string.length();\n    long\
    \ result = 0;\n    for (int i = 0; i < len; i++) {\n        result += (getCharCase(string[i])\
    \ - 'a');\n    }\n    return result;", "    long count = 0;\n    for (auto it\
    \ = string.begin(); it != string.end(); ++it) {\n        if (std::tolower(*it)\
    \ == std::tolower(*std::prev(it))) {\n            ++count;\n        }\n    }\n\
    \    return count;", "    long distinctCharacters = 0;\n    for(char character\
    \ : string) {\n        distinctCharacters++;\n    }\n    return distinctCharacters;",
  "    long count[26] = {0};\n    for (size_t i = 0; i < string.length(); i++) {\n\
    \        long l = (int)string[i] - 'a';\n        count[l]++;\n    }\n\n    for\
    \ (long i = 0; i < 26; i++) {\n        count[i] += count[i+26;];\n    }\n    return\
    \ count[26];", "  std::unordered_map<char, std::size_t> char_count;\n  for (char\
    \ c : string) {\n    char_count[c]++;\n  }\n\n  long result = 0;\n  for (std::unordered_map<char,\
    \ std::size_t>::const_iterator it = cent_count.begin();\n       it != cent_count.end();\n\
    \       ++it) {\n    result += it->second;\n  }\n\n  return result;", "  // Initialize\
    \ all the counts to 0\n  long counts[26] = {0};\n  for (size_t i = 0; i != string.size();\
    \ ++i) {\n    const auto &c = string[i];\n    counts[c] += 1;\n  }\n\n  // Find\
    \ the counts of all the characters in the string and return the sum\n  long sum\
    \ = 0;\n  for (long i = 0; i < 26; ++i) {\n    sum += counts[i];\n  }\n  return\
    \ sum;", "    long count = 0;\n    for (int i = 0; i < string.length(); i++) {\n\
    \        std::string letter = string.substr(i, 1);\n        count = count + (string.at(i\
    \ - 1) == letter);\n    }\n    return count;", "    // Write your code here\n\
    \    long ans = string.size();\n    for(long i=0;i<string.size();i++) {\n    \
    \    ans = ans - string[i];\n    }\n    return ans;", "   assert(string.size()\
    \ > 0);\n   long n = 1;\n   for (char c: string) {\n      if (string[n - 1] !=\
    \ c) {\n         n = n + 1;\n      }\n   }\n   return n;", "    long count = 0;\n\
    \    for (char c : string) if (tolower(c) == c) count++;\n    return count;",
  "\tlong ans = 0;\n\tlong last = 0;\n\tstd::sort(string.begin(), string.end());\n\
    \tfor (long i = 0; i < (long)string.size(); i++) {\n\t\tif (string[i] == string[last])\
    \ {\n\t\t\tans++;\n\t\t} else {\n\t\t\tans++;\n\t\t}\n\t\tlast = i;\n\t}\n\treturn\
    \ ans;", "    long count = 0;\n    long curr = 0;\n    for(auto c : string){\n\
    \        curr = (curr + c)/2;\n        if(curr > 0) count++;\n    }\n    return\
    \ count;", "    // Initialize a map to store the counts\n    std::map<char, long>\
    \ char_num_map;\n    // Iterate over each character in the string\n    for (char\
    \ &character : string) {\n        // Increment the count of character, if character\
    \ is not in the map\n        if (char_num_map.count(character) == 0) {\n     \
    \       char_num_map.insert(std::make_pair(character, 1));\n        } else {\n\
    \            // Increment the count of character, if character is already in the\
    \ map\n            char_num_map.at(character) += 1;\n        }\n    }\n    //\
    \ Return the count of distinct characters in the string\n    return char_num_map.size();",
  "    long ans = 0;\n    for (auto it = string.begin(); it != string.end(); ++it)\
    \ {\n        bool isalpha = std::isalpha(*it);\n        bool isupper = std::isupper(*it);\n\
    \        bool isdigit = std::isdigit(*it);\n        bool islower = std::islower(*it);\n\
    \        if (isalpha || isupper || isdigit || islower) {\n            ans++;\n\
    \        }\n    }\n    return ans;", "    std::sort(string.begin(), string.end(),\
    \ [](char a, char b) {\n        return std::tolower(a) == std::tolower(b);\n \
    \   });\n    int count = 1;\n    bool flag = true;\n    for (char c : string)\
    \ {\n        if (std::tolower(c) == std::tolower(string[count])) {\n         \
    \   if (flag) {\n                count++;\n            }\n            else {\n\
    \                count = 1;\n            }\n            flag = !flag;\n      \
    \  }\n    }\n    return count;", "    long count = 0;\n    for (auto itr = string.begin();\
    \ itr != string.end(); ++itr) {\n        if (std::tolower(*itr) != std::tolower(*itr\
    \ + 1)) ++count;\n    }\n    return count;", "    std::unordered_set<char> characters;\n\
    \    // Initialize an empty set for each character\n    for (char& c : string)\n\
    \        characters.insert(c);\n    long ans = 0;\n    // Add each element from\
    \ the set one by one\n    for (char c : characters)\n        ans += 1;\n    return\
    \ ans;", "    long count = 0;\n    for (char ch: str_chr(string, 'a')) {\n   \
    \     char lowerCaseCh = static_cast<char>(tolower(ch));\n        for (char ch2:\
    \ str_chr(string, 'a')) {\n            char upperCaseCh = static_cast<char>(toupper(ch2));\n\
    \            if ((tolower(ch) == tolower(ch2)) && (ch != upperCaseCh))\n     \
    \           count++;\n        }\n    }\n    return count;", "    // Write your\
    \ code here\n    long ans = 0;\n    long size = string.length();\n    long len\
    \ = 0, index = 0;\n    while (index < size) {\n        if (string[index] >= 'a'\
    \ && string[index] <= 'z')\n            len++;\n        index++;\n    }\n    ans\
    \ = len;\n    return ans;", "    long len = 1;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] != string[i - 1]) {\n            len++;\n    \
    \    }\n    }\n    return len;", "    // Scan through the string \n    long long\
    \ characters = 0;\n    for (auto character = string.begin(); character != string.end();\
    \ ++character) {\n        // Check if the character is lower case\n        if\
    \ ((*character >= 'a' && *character <= 'z') || (*character >= 'A' && *character\
    \ <= 'Z')) {\n            ++characters;\n        }\n    }\n    return characters;",
  "\tlong count = 0;\n\tfor (int i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ >= 'A' && string[i] <= 'Z')\n\t\t\tcount += 2; // lower case and upper case\n\
    \t\telse if (string[i] >= 'a' && string[i] <= 'z')\n\t\t\tcount += 3; // lower\
    \ case and upper case\n\t\telse if (string[i] >= '0' && string[i] <= '9')\n\t\t\
    \tcount += 1;\n\t}\n\treturn count;", "    long count = 0;\n    for (int i = 0;\
    \ i < string.length(); i++) {\n        char chr = string[i];\n        long current_count\
    \ = count(string.begin() + i + 1, string.end(), chr);\n        count = (current_count\
    \ == 1) ? count + 1 : count;\n    }\n    return count;", "    long ans = 0;\n\
    \    long size = string.length();\n    for (long i = 0; i < size; ++i) {\n   \
    \     long count = 0;\n        for (long j = 0; j < size; ++j) {\n           \
    \ if (i != j && string[i] == string[j]) {\n                ++count;\n        \
    \    }\n        }\n        if (count == 0) {\n            ++ans;\n        }\n\
    \    }\n    return ans;", "    // Using a hashmap to count the unique characters\
    \ in string\n    long count = 0; // Initialize count\n    std::unordered_map<char,\
    \ long> unique_characters;\n    for (auto &c: string) {\n        unique_characters.emplace(c,\
    \ 0); // Initialize each character with 0 count\n    }\n\n    for (auto &c: unique_characters)\
    \ {\n        count++; // Increment the count of unique character\n    }\n\n  \
    \  return count;", "  int n = string.length();\n  int res = 0;\n  for (int i =\
    \ 0; i < n; i++) {\n    if (string[i] >= 'A' && string[i] <= 'Z')\n      res +=\
    \ 26 - string[i] - 'A';\n    else if (string[i] >= 'a' && string[i] <= 'z')\n\
    \      res += 26 - string[i] - 'a';\n    else {\n      auto it = string.begin()\
    \ + i;\n      do {\n        it++;\n        if (it >= string.end())\n         \
    \ break;\n      } while (string[i] != *it);\n      res += 26 - (it - string.begin())\
    \ - 'A';\n    }\n  }\n  return res;", "    // Your code here\n    long count=0;\n\
    \    for (size_t i=0; i< string.length(); i++) {\n        bool found=false;\n\
    \        for (size_t j=0; j < count; j++) {\n            if (string[i]==string[j])\
    \ {\n                found = true;\n                break;\n            }\n  \
    \      }\n        if (found==false) {\n            count++;\n        }\n    }\n\
    \    return count;", "    // Convert to lower case\n    string lower_string =\
    \ std::tolower(string);\n    // Go through all the characters and count them\n\
    \    long count = 0;\n    for (auto character : lower_string) {\n        if (std::tolower(character)\
    \ == character) {\n            count++;\n        }\n    }\n    return count;",
  "    std::unordered_map<char, int> map;\n    \n    for (char c : string)\n     \
    \   map[c]++;\n    \n    long n = 0;\n    for (auto it = map.begin(); it != map.end();\
    \ ++it)\n    {\n        if (it->second > 1)\n            ++n;\n    }\n    return\
    \ n;", "  long num_distinct_chars = 0;\n  long index = 0;\n  for (char c : string)\
    \ {\n    if (index >= string.length()) {\n      break;\n    }\n    num_distinct_chars\
    \ += (index == 0) ? 0 : ((isupper(c)) || (islower(c))) ? 1 : 0;\n    ++index;\n\
    \  }\n  return num_distinct_chars;", "    long count = 0;\n    int i = 0, n =\
    \ string.size();\n\n    while (i < n) {\n        char c = string[i];\n       \
    \ for (; i < n && string[i] == c; ++i)\n            ;\n        if (i >= n)\n \
    \           break;\n        ++count;\n    }\n\n    return count;", "    if (string.size()\
    \ == 0)\n        return 0;\n\n    long count = 1;\n\n    for (size_t i = 0; i\
    \ < string.size(); i++) {\n        int index = string[i];\n\n        for(char\
    \ ch : string){\n            count += ch != index ? 1 : 0;\n        }\n    }\n\
    \n    return count;", "    long result = 0;\n    for (char c : string) {\n   \
    \     if (string[result] == c) {\n            result++;\n        } else {\n  \
    \          break;\n        }\n    }\n    return result;", "  long n = 0;\n  for\
    \ (char &c: string) ++n;\n  std::sort(string.begin(), string.end());\n  long sz\
    \ = string.size();\n  for (long i = 0; i < sz; ++i) n = std::count_if(string.begin(),\
    \ string.end(), [&](char &c) { return std::tolower(c) == std::tolower(string[i]);\
    \ });\n  return n;", "    long n = 0;\n    for (char &c : string) \n    {\n  \
    \      ++n;\n        c = tolower(c);\n    }\n    return n;", "   long count =\
    \ 0;\n   for (int i = 0; i < string.length(); i++) {\n      if (string[i] == 'z')\
    \ {\n         string[i] = 'Z';\n      }\n      for (int j = 1; j < string.length();\
    \ j++) {\n         if (string[i] != string[j]) {\n            string[i] = string[j];\n\
    \            count++;\n         }\n      }\n   }\n   return count;", "    long\
    \ count = 0;\n    for (char ch: string)\n        count += ch;\n    return count;",
  "    long counter = 0;\n    for (char c : string)\n        counter++;\n\n    return\
    \ counter;", "    // Use map instead of unordered_map as unordered_map doesn't\
    \ support <string>, only <unordered_map>\n    std::map<char, int> counts; // The\
    \ key is the character (char or int) and value is their count\n\n    for (char\
    \ c : string) {\n        counts[c]++; // count it\n    }\n\n    return counts.size();",
  "\tlong size = 0;\n\tstd::set<char> set{string};\n\tfor (char c : set) {\n\t\t++size;\n\
    \t}\n\treturn size;", "  // Complete this function\n  long res = 0;\n  for (int\
    \ i = 0; i < string.length(); i++) {\n    // If character is uppercase, add 1\
    \ to the counter\n    // If character is lowercase, add 2 to the counter\n   \
    \ // If character is digit, add 3 to the counter\n    // If character is punctuation,\
    \ add 4 to the counter\n    // Else, add 5 to the counter\n    if (string[i] >=\
    \ 'A' && string[i] <= 'Z') {\n      res++;\n    }\n  }\n  return res;", "    long\
    \ result = 0;\n    for(int i = 0;i<string.length();i++) {\n        if(string[i]>=65\
    \ && string[i]<=90) {\n            result++;\n        }\n    }\n    return result;",
  "    long result = 0;\n    unordered_set<char> hash;\n    for (char c : string)\n\
    \        if (hash[c])\n            ++result;\n        else hash[c] = 1;\n    return\
    \ result;", "    long ans = 0;\n    for (char ch : string) {\n        ans = ans\
    \ + (int)ch;\n    }\n    return ans;", "    if(string.length() <= 1) return 0;\n\
    \    int result = 0;\n    \n    for(int i = 0; i < string.length(); i++) {\n \
    \       // Use tolower() to ignore case\n        if(string[i] != string[i].tolower())\
    \ result += 1;\n    }\n    return result;", "  if (string.length() == 0) return\
    \ 0;\n  long count = 0;\n  for (int i = 0; i < string.length(); i++) {\n    char\
    \ ch = string[i];\n    count += tolower(ch) - tolower(string[0]);\n  }\n  return\
    \ count;", "    int count = 0;\n    for (auto it : string) {\n        count =\
    \ count + toupper(it) - toupper('Z');\n    }\n    return count;", "    long count\
    \ = 0;\n    for (char c : string) {\n        switch (c) {\n        case 'A': case\
    \ 'B': case 'C': case 'D': case 'E':\n        case 'F': case 'G': case 'H': case\
    \ 'I': case 'J':\n        case 'K': case 'L': case 'M': case 'N': case 'O':\n\
    \        case 'P': case 'Q': case 'R': case 'S': case 'T':\n        case 'U':\
    \ case 'V': case 'W': case 'X': case 'Y':\n        case 'Z': count++;\n      \
    \  }\n    }\n    return count;", "    // Declare a variable to hold the count\
    \ of distinct characters\n    int num_of_distinct_characters = 0;\n    // Iterate\
    \ through each character and keep track of how many distinct characters\n    //\
    \ are there in the current iteration\n    for(char c : string)\n        switch(c)\
    \ {\n        case 'a':\n        case 'A':\n        case 'b':\n        case 'B':\n\
    \        case 'c':\n        case 'C':\n        case 'd':\n        case 'D':\n\
    \        case 'e':\n        case 'E':\n        case 'f':\n        case 'F':\n\
    \        case 'g':\n        case 'G':\n        case 'h':\n        case 'H':\n\
    \        case 'i':\n        case 'I':\n        case 'j':\n        case 'J':\n\
    \        case 'k':\n        case 'K':\n        case 'l':\n        case 'L':\n\
    \        case 'm':\n        case 'M':\n        case 'n':\n        case 'N':\n\
    \        case 'o':\n        case 'O':\n        case 'p':\n        case 'P':\n\
    \        case 'q':\n        case 'Q':\n        case 'r':\n        case 'R':\n\
    \        case 's':\n        case 'S':\n        case 't':\n        case 'T':\n\
    \        case 'u':\n        case 'U':\n        case 'v':\n        case 'V':\n\
    \        case 'w':\n        case 'W':\n        case 'x':\n        case 'X':\n\
    \        case 'y':\n        case 'Y':\n        case 'z':\n        case 'Z':\n\
    \            num_of_distinct_characters++;\n            break;\n        default:\n\
    \            num_of_distinct_characters++;\n            break;\n        }\n  \
    \  return num_of_distinct_characters;", "    long n = 0;\n    for(int i = 0; i\
    \ < string.length(); i++) {\n        for(int j = i+1; j <= string.length(); j++)\
    \ {\n            if(string[i] == string[j]) {\n                n++;\n        \
    \    }\n        }\n    }\n    return n;", "  // Initialize number of distinct\
    \ characters count to zero\n  long distinct_char_count = 0;\n  // Iterate through\
    \ each character in the string\n  for (int i = 0; i < string.size(); i++) {\n\
    \    // If the character is lower case, increment the distinct character count\
    \ by one\n    if (string[i] == 'a' || string[i] == 'b' || string[i] == 'c' ||\
    \ string[i] == 'd' ||\n        string[i] == 'e' || string[i] == 'f' || string[i]\
    \ == 'g' || string[i] == 'h' ||\n        string[i] == 'i' || string[i] == 'j'\
    \ || string[i] == 'k' || string[i] == 'l' ||\n        string[i] == 'm' || string[i]\
    \ == 'n' || string[i] == 'o' || string[i] == 'p' ||\n        string[i] == 'q'\
    \ || string[i] == 'r' || string[i] == 's' || string[i] == 't' ||\n        string[i]\
    \ == 'u' || string[i] == 'v' || string[i] == 'w' || string[i] == 'x' ||\n    \
    \    string[i] == 'y' || string[i] == 'z') {\n      distinct_char_count += 1;\n\
    \    }\n  }\n  // Return the distinct character count\n  return distinct_char_count;",
  "    long num_of_distinct = 0;\n    string lowercase_string = string(string.begin(),\
    \ string.end());\n    sort(lowercase_string.begin(), lowercase_string.end());\n\
    \    for(const auto &c : lowercase_string) {\n        if (c != toupper(c)) {\n\
    \            num_of_distinct++;\n        }\n    }\n    return num_of_distinct;",
  "    long count = 0;\n    for (auto c : string) \n    {\n        count += ((int)c)\
    \ == c ? (int)c : (int)tolower(c) != c ? 1 : 0;\n    }\n    return count;", " \
    \   if (string == \"-\") {\n        return 0;\n    }\n    string lowercase = string.toLowerCase();\n\
    \    long result = 0;\n    for (auto &letter : lowercase) {\n        long count\
    \ = string.count(letter);\n        if (count == 0) {\n            ++result;\n\
    \        }\n    }\n    return result;", "    long count=0;\n    long size = string.size();\n\
    \    for (size_t i = 0; i < size; i++) {\n        long countChar = 0;\n      \
    \  for (size_t j = i; j < size; j++) {\n            if ((string[i]==string[j])\
    \ && (string[i] != ' ')) {\n                countChar++;\n            }\n    \
    \    }\n        count+=countChar;\n    }\n    return count;", "    long count=0;\n\
    \    for(int i=0;i<string.length();i++){\n        for(int j=i;j<string.length();j++){\n\
    \            if(tolower(string[i])==tolower(string[j])){\n                count=count+1;\n\
    \            }\n        }\n    }\n    return count;", "    long count = 0;\n \
    \   for (int i = 0; i < string.length(); i++) {\n        for (int j = i + 1; j\
    \ < string.length(); j++) {\n            char temp = string.at(i);\n         \
    \   string.at(i) = string.at(j);\n            string.at(j) = temp;\n         \
    \   if (temp != string[j] && string[j] != '\\0') {\n                count++;\n\
    \            }\n        }\n    }\n    return count;", "    int n = string.size();\n\
    \    long ans = 0;\n\n    for (int i = 0; i < n; ++i) {\n        ans ^= static_cast<long>(string[i]);\n\
    \        for (int j = i + 1; j < n; ++j) {\n            ans ^= static_cast<long>(string[i])\
    \ ^ static_cast<long>(string[j]);\n        }\n    }\n    return ans;", "    long\
    \ count = 0; // to store character count\n    for (char &c : string) ++count;\
    \ // to store character case count\n    return count;", "    long count = 1;\n\
    \    for (auto it = toupper(string).begin(); it != toupper(string).end(); ++it)\
    \ {\n        count += string[it - toupper(string).begin()] == tolower(string[it\
    \ - toupper(string).begin()]) ? 0 : 1;\n    }\n    return count;", "    long n\
    \ = 0;\n    // Iterate over every character, check if it's uppercase, lowercase\
    \ or digit\n    for (char &c : string) c = toupper(c);\n    for (char &c : string)\
    \ c = tolower(c);\n    for (char &c : string) c = toupper(c);\n    for (char &c\
    \ : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n    for\
    \ (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = toupper(c);\n\
    \    for (char &c : string) c = tolower(c);\n    for (char &c : string) c = to",
  "    // Your code here\n    long count = 0;\n    for(char &c:string)\n        if(c>='A'\
    \ && c<='Z')\n            count++;\n    return count;", "    if (string.size()\
    \ == 0)\n        return 0;\n\n    long ans = 0;\n    for (char c : string) {\n\
    \        ans += toupper(c) - toupper(tolower(c));\n    }\n    return ans;", "\t\
    long count = 0;\n\tfor (char ch: string) {\n\t\tif (tolower(ch) == ch) {\n\t\t\
    \tcount++;\n\t\t}\n\t}\n\treturn count;", "    long count = 0;\n    for (char\
    \ c : string) {\n        if (c == string[0])\n            count++;\n    }\n  \
    \  return count;", "  int length = string.size();\n  int count = 0;\n  for (int\
    \ i = 0; i < length; i++) {\n    int first = string[i];\n    for (int j = i +\
    \ 1; j < length; j++) {\n      if (string[j] == first) {\n        count++;\n \
    \     }\n    }\n  }\n  return count;", "    long count = 0;\n    for (char character\
    \ : string) {\n        count += (toupper(character) != toupper(character) ? 1\
    \ : 0);\n    }\n    return count;", "    assert(!string.empty());\n    long count\
    \ = 0;\n    char previous = 0;\n    for (char current : string.begin(); current\
    \ != string.end(); current++) {\n        if (previous == current) {\n        \
    \    ++count;\n        }\n        previous = current;\n    }\n    return count;",
  "    long distinctCharacters = 0;\n    for (int i = 0; i != string.length(); i++)\n\
    \        if (string[i] == string[i])\n            distinctCharacters++;\n    return\
    \ distinctCharacters;", "    long ans = 0;\n    for (char &i : string) {\n   \
    \     switch (tolower(i)) {\n        case 'a':\n            ans += 2;\n      \
    \      break;\n        case 'b':\n            ans += 1;\n            break;\n\
    \        case 'c':\n            ans += 1;\n            break;\n        case 'd':\n\
    \            ans += 1;\n            break;\n        case 'e':\n            ans\
    \ += 1;\n            break;\n        case 'f':\n            ans += 1;\n      \
    \      break;\n        case 'g':\n            ans += 1;\n            break;\n\
    \        case 'h':\n            ans += 1;\n            break;\n        case 'i':\n\
    \            ans += 1;\n            break;\n        case 'j':\n            ans\
    \ += 1;\n            break;\n        case 'k':\n            ans += 1;\n      \
    \      break;\n        case 'l':\n            ans += 1;\n            break;\n\
    \        case 'm':\n            ans += 1;\n            break;\n        case 'n':\n\
    \            ans += 1;\n            break;\n        case 'o':\n            ans\
    \ += 1;\n            break;\n        case 'p':\n            ans += 1;\n      \
    \      break;\n        case 'q':\n            ans += 1;\n            break;\n\
    \        case 'r':\n            ans += 1;\n            break;\n        case 's':\n\
    \            ans += 1;\n            break;\n        case 't':\n            ans\
    \ += 1;\n            break;\n        case 'u':\n            ans += 1;\n      \
    \      break;\n        case 'v':\n            ans += 1;\n            break;\n\
    \        case 'w':\n            ans += 1;\n            break;\n        case 'x':\n\
    \            ans += 1;\n            break;\n        case 'y':\n            ans\
    \ += 1;\n            break;\n        case 'z':\n            ans += 1;\n      \
    \      break;\n        default:\n            ans += 1;\n            break;\n \
    \       }\n    }\n    return ans;", "    long ans = 0;\n    char arr[26];\n  \
    \  for (char &i : arr) i = tolower(i);\n    for (auto &i : string) i = tolower(i);\n\
    \    for (auto &i : arr) ++ans;\n    return ans;", "    // code here\n    long\
    \ count = 0;\n    for(char c : string)\n    {\n        if(c == 'a' || c == 'A'\
    \ || c == 'b' || c == 'B' || c == 'c' || c == 'C' || c == 'd' || c == 'D' || c\
    \ == 'e' || c == 'E' || c == 'f' || c == 'F' || c == 'g' || c == 'G' || c == 'h'\
    \ || c == 'H' || c == 'i' || c == 'I' || c == 'j' || c == 'J' || c == 'k' || c\
    \ == 'K' || c == 'l' || c == 'L' || c == 'm' || c == 'M' || c == 'n' || c == 'N'\
    \ || c == 'o' || c == 'O' || c == 'p' || c == 'P' || c == 'q' || c == 'Q' || c\
    \ == 'r' || c == 'R' || c == 's' || c == 'S' || c == 't' || c == 'T' || c == 'u'\
    \ || c == 'U' || c == 'v' || c == 'V' || c == 'w' || c == 'W' || c == 'x' || c\
    \ == 'X' || c == 'y' || c == 'Y' || c == 'z' || c == 'Z' || c == 'A' || c == 'B'\
    \ || c == 'C' || c == 'D' || c == 'E' || c == 'F' || c == 'G' || c == 'H' || c\
    \ == 'I' || c == 'J' || c == 'K' || c == 'L' || c == 'M' || c == 'N' || c == 'O'\
    \ || c == 'P' || c == 'Q' || c == 'R' || c == 'S' || c == 'T' || c == 'U' || c\
    \ == 'V' || c == 'W' || c == 'X' || c == 'Y' || c == 'Z')\n        count++;\n\
    \    }\n    return count;", "  int freq[256] = {};\n  for (int i = 0; i < string.size();\
    \ i++) {\n    freq[string[i]] = freq[string[i]] + 1;\n  }\n  long ans = 0;\n \
    \ for (int i = 0; i < 256; i++) {\n    ans += freq[i];\n  }\n  return ans;", " \
    \ long counter = 0;\n  for (int i = 0; i < string.size(); i++) {\n    counter++;\n\
    \    for (int j = i + 1; j < string.size(); j++) {\n      if (string[i] == string[j])\n\
    \        counter--;\n    }\n  }\n  return counter;", "    std::sort(string.begin(),\
    \ string.end());\n    long long count{0};\n    \n    for(auto c : string) {\n\
    \        if(std::toupper(c) >= std::toupper(string[0])) {\n            count +=\
    \ 1;\n        }\n    }\n    \n    return count;", "    long long ans = 0;\n  \
    \  long long len = string.length();\n    for (long long i = 0; i < len; i++)\n\
    \    {\n        long long pos = i;\n        long long curr = 1;\n        while\
    \ (pos != 0 && string[pos - 1] == string[i])\n        {\n            curr = curr\
    \ * 2;\n            pos--;\n        }\n        ans += curr;\n    }\n    return\
    \ ans;", "  long number_of_unique_characters = 0;\n  int number_of_characters\
    \ = 0;\n  for (int i = 0; i < string.length(); ++i) {\n    if (string.at(i) >=\
    \ 65 && string.at(i) <= 90) {\n      number_of_characters += 2;\n    } else if\
    \ (string.at(i) >= 97 && string.at(i) <= 122) {\n      number_of_characters +=\
    \ 2;\n    } else if (string.at(i) >= 48 && string.at(i) <= 57) {\n      number_of_characters\
    \ += 1;\n    } else {\n      number_of_characters++;\n    }\n    if (number_of_characters\
    \ == 1) {\n      number_of_unique_characters += 1;\n    }\n  }\n  return number_of_unique_characters;",
  "  std::sort(string.begin(), string.end());\n  std::unordered_map<char, int> char_count_map;\n\
    \  // To store count of distinct characters in the string\n  int distinct_char_count\
    \ = 0;\n  for (char ch: string) {\n    ++char_count_map[ch];\n    // Increment\
    \ the count of distinct characters if character is different from previous\n \
    \   if (char_count_map[ch] != char_count_map[ch-1]) {\n      distinct_char_count++;\n\
    \    }\n  }\n  return distinct_char_count;", "    long ans = 0;\n    for (char\
    \ c : string)\n        ++ans;\n    return ans;", "    // Complete the code here\n\
    \    long result = 0;\n    for (auto &letter : string) {\n        if (std::toupper(letter)\
    \ == letter)\n            ++result;\n    }\n    return result;", "    long n =\
    \ 0;\n    long start = 0;\n    long end = 0;\n    while (start < string.length())\
    \ {\n        end = string.find('X', start);\n        if (end == std::string::npos)\
    \ {\n            end = string.length();\n        }\n        if (string[end] ==\
    \ 'X') {\n            n++;\n        }\n        start = end + 1;\n    }\n    return\
    \ n;", "    // If it consists of only 1 character, it only has 1 distinct character\n\
    \    if (string.length() == 0) {\n        return 1;\n    }\n    // Store the character's\
    \ unique ASCII code\n    std::vector<int> char_map(string.length());\n    // Traverse\
    \ the string\n    for (auto &c: str_chr(string, 'A')) {\n        char_map[c] =\
    \ char_map[c - 'A'] + 1;\n    }\n    return char_map.size();", "    long answer\
    \ = 0;\n    for(char ch : string)\n        answer += ch;\n    return answer;",
  "  long sum = 0;\n  for (int i = 0; i < string.length(); i++) {\n    sum += (string.at(i)\
    \ == 'X') + (string.at(i) == 'x') + (string.at(i) == 'y') + (string.at(i) == 'Y')\
    \ + (string.at(i) == 'y');\n  }\n  return sum;", "    // Write your code here\n\
    \    long result = 0;\n    for (auto ch:string) {\n        result ^= (ch - 32);\
    \ // xor each character with corresponding ASCII code of space and char\n    }\n\
    \    return result;", "    // code here\n    long count = 0;\n    for (auto it\
    \ = string.begin(); it != string.end(); ++it)\n    {\n        if (it == string.begin()\
    \ || *it != *it+1 || *it+1 != *it) \n            count++;\n    }\n    return count;",
  "    long count = 0;\n    for (auto & c: string) {\n        count = count + ((c\
    \ >= 'a') && (c <= 'z'));\n    }\n    return count;", "  long count = 0;\n  for\
    \ (char c: string) {\n    if (isupper(c)) count++;\n    else if (islower(c)) count++;\n\
    \  }\n  return count;", "    long res = 0;\n    size_t len = string.length();\n\
    \n    // Iterate through the whole string to find out how many times each character\
    \ appears\n    for (size_t i = 0; i < len; i++) {\n        // Use tolower() to\
    \ ignore case\n        auto cur_char = string[i];\n        string char_lowercase\
    \ = cur_char;\n        cur_char = tolower(cur_char);\n        if (string.find(cur_char)\
    \ == string::npos) {\n            std::cerr << \"'\" << cur_char << \"' is not\
    \ found in the string \" << string << \"\\n\";\n            exit(1);\n       \
    \ }\n\n        std::string cur_char_lowercase = cur_char;\n        cur_char_lowercase\
    \ = tolower(cur_char_lowercase);\n\n        if (cur_char_lowercase != char_lowercase)\
    \ {\n            std::cerr << \"'\" << cur_char_lowercase << \"' and '\" << char_lowercase\
    \ << \"' are not the same\\n\";\n            exit(1);\n        }\n        res++;\n\
    \    }\n\n    return res;", "    // Write your code here\n    long count[26];\n\
    \    for (long i = 0; i < 26; i++) {\n        count[i] = 0;\n    }\n    for (long\
    \ i = 0; i < string.length(); i++) {\n        int pos = string[i] - 'a';\n   \
    \     count[pos]++;\n    }\n    long ans = 0;\n    for (long i = 0; i < 26; i++)\
    \ {\n        ans += count[i];\n    }\n    return ans;", "    long n = 0;\n   \
    \ std::string s;\n    s.reserve(string.length());\n    for (size_t i = 0; i <\
    \ string.length(); i++) {\n        s += string[i];\n    }\n\n    // Convert string\
    \ to lower case\n    for (char c : s) {\n        c = tolower(c);\n        // check\
    \ if already counted this character\n        if (std::binary_search(cs, c + 1))\n\
    \            continue;\n        cs[c]++;\n        n++;\n    }\n    return n;",
  "    std::sort(string.begin(), string.end());\n    std::unordered_set<char> unordered_set;\n\
    \    for (std::size_t i = 0; i < string.size(); i++)\n        unordered_set.insert(string[i]);\n\
    \    return unordered_set.size();", "    long n = 0;\n    for (auto it = string.begin();\
    \ it != string.end(); ++it)\n    {\n        // Ignore case\n        long pos =\
    \ 0;\n        while ((pos = it - string.begin()) >= 0)\n        {\n          \
    \  if (string[pos] >= 'a' && string[pos] <= 'z')\n            {\n            \
    \    ++pos;\n            }\n            else\n            {\n                ++n;\n\
    \                break;\n            }\n        }\n    }\n    return n;", "  \
    \  int len = (int) string.size();\n    long ret = 0;\n    for (int i = 0; i <\
    \ len; i++) {\n        ret = ret + 1;\n        switch (string[i]) {\n        \
    \    case 'A':\n            case 'a':\n            case 'E':\n            case\
    \ 'e':\n            case 'I':\n            case 'i':\n            case 'O':\n\
    \            case 'o':\n            case 'U':\n            case 'u':\n       \
    \     case 'a':\n            case 'e':\n            case 'i':\n            case\
    \ 'o':\n            case 'u':\n            case 'A':\n            case 'E':\n\
    \            case 'I':\n            case 'O':\n            case 'U':\n       \
    \     case 'a':\n            case 'e':\n            case 'i':\n            case\
    \ 'o':\n            case 'u':\n            case 'b':\n            case 'p':\n\
    \            case 'R':\n            case 'r':\n            case '_':\n       \
    \     case 'B':\n            case 'p':\n            case 'R':\n            case\
    \ 'r':\n            case 's':\n            case 't':\n            case '_':\n\
    \            case 'F':\n            case 'f':\n            case 'g':\n       \
    \     case 'h':\n            case 'h':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case 'I':\n            case 'I':\n            case\
    \ 'I':\n            case 'I':\n            case 'I':\n            case 'I':\n\
    \            case 'I':\n            case 'I':\n            case 'I':\n       \
    \     case 'I':\n            case '", "    long count = 0;\n    for (int i = 0;\
    \ i < string.length(); i++) {\n        char character = string[i];\n        if\
    \ ('A' <= character && character <= 'Z' || 'a' <= character && character <= 'z')\
    \ {\n            count += 1;\n        }\n    }\n    return count;", "    // initialize\
    \ a vector of bools set to false and size to zero initially\n    std::vector<bool>\
    \ v(string.size(), false);\n    for (auto &ch : string) {\n        // for each\
    \ character, we check if it is true or false\n        // if it is true\n     \
    \   // then we add it to the vector of bools\n        if (v[ch] == false) v.push_back(false);\n\
    \        // else we add it to the vector of bools\n        else v.push_back(true);\n\
    \    }\n    // now we calculate the length of that vector of bools\n    return\
    \ v.size();", "    long count = 0;\n    for (char c : string) {\n        string\
    \ temp = string; temp += c; temp += c; temp += c; temp += c;\n        if (temp\
    \ == string) {\n            count++;\n        }\n    }\n    return count;", " \
    \   long count = 0;\n    for (char c : string) {\n        count += (((string).find(c)\
    \ != string::npos) ? 1 : 0);\n    }\n    return count;", "  // Your code here\n\
    \  long ans = 0;\n  for (int i = 0; i < string.size(); i++) {\n    for (int j\
    \ = i + 1; j < string.size(); j++) {\n      if (toupper(string[i]) == toupper(string[j]))\n\
    \        ans++;\n    }\n  }\n  return ans;", "    long count = 0;\n    for (int\
    \ i = 0; i <= string.length(); i++) {\n        std::string tmp = string; tmp[i]\
    \ = toupper(tmp[i]);\n        if (string.length() > i) {\n            while (string[i]\
    \ != tmp[i]) {\n                string += tmp;\n                count += 1;\n\
    \                tmp = string; tmp[i] = toupper(tmp[i]);\n            }\n    \
    \    }\n    }\n    return count;", "    int len = (int)string.size();\n    long\
    \ ans = 1;\n    int i = 0;\n    while(i < len) {\n        int flag = 0;\n    \
    \    char c = string[i];\n        for(int j = i+1; j< len; j++) {\n          \
    \  if(string[j] == c) {\n                flag++;\n                i = j;\n   \
    \             break;\n            }\n        }\n        if(flag == 0) {\n    \
    \        ans++;\n            i++;\n        }\n    }\n    return ans;", "    if\
    \ (string.length() <= 1) {\n        return 0;\n    }\n    map<char, int> m;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        char c = string[i];\n\
    \        if (m.find(c) == m.end()) {\n            m[c] = 1;\n        } else {\n\
    \            m[c] += 1;\n        }\n    }\n    return m.size();", "  // This solution\
    \ relies on the fact that strings in C++ are represented by arrays containing\
    \ the characters \n  // of the original string. Here we iterate over all characters\
    \ and add them to a hash map\n  unordered_map<char, int> m;\n  for (int i = 0;\
    \ i < string.size(); i++) {\n    if (m.find(string[i]) == m.end()) {\n      m[string[i]]\
    \ = 1;\n    } else {\n      m[string[i]] += 1;\n    }\n  }\n  // Now we can count\
    \ the number of distinct characters by iterating over the hash\n  int counter\
    \ = 0;\n  for (auto it = m.begin(); it != m.end(); ++it) {\n    counter += it->second;\n\
    \  }\n  return counter;", "    unordered_map<char,long> m;\n    long n = 0;\n\
    \    for(int i = 0; i < string.size(); i++) {\n        char c = string[i];\n \
    \       if( m.find(c) != m.end() ) {\n            m[c] = m[c] + 1;\n        }\
    \ else {\n            m[c] = 1;\n            n++;\n        }\n    }\n    return\
    \ n;", "    int char_array[50] = {0};\n    for (auto &c: string) {\n        char_array[tolower(c)]++;\n\
    \    }\n    long ans = 0;\n    for (auto &c: char_array) ans += c;\n    return\
    \ ans;", "    long distinct_characters = 0;\n    for (int i = 0; i != string.length();\
    \ ++i) {\n        const char curr_char = string[i];\n        for (int j = i +\
    \ 1; j <= string.length(); j++) {\n            const char prev_char = string[j];\n\
    \            if (tolower(curr_char) == tolower(prev_char)) distinct_characters++;\n\
    \        }\n    }\n    return distinct_characters;", "    long long ans = 0;\n\
    \    int len = string.length();\n    int counts[26] = {0};\n    for (int i = 0;\
    \ i < len; i++) {\n        int c = string[i];\n        if (c >= 'a' && c <= 'z')\
    \ {\n            ans += c - 'a' + 1;\n        } else if (c >= 'A' && c <= 'Z')\
    \ {\n            ans += c - 'A' + 1;\n        } else if (c >= '0' && c <= '9')\
    \ {\n            ans += c - '0' + 1;\n        } else {\n            assert(false);\n\
    \        }\n        counts[c - 'a']++;\n    }\n\n    // Iterate from left to right\
    \ and increase the counts array as you see any consecutive characters\n    //\
    \ If character count is 1 then increment the distinct character count\n    for\
    \ (int i = 0; i < 26; i++) {\n        if (counts[i] != 1 && counts[i + 1] == 1)\
    \ {\n            ans += counts[i] - 1;\n        }\n    }\n\n    return ans;",
  "    int count[26];\n    for (char &c: string) {\n        c = tolower(c);\n    \
    \    count[c - 'a']++;\n    }\n    return count_and_print(count, string);", " \
    \   long cnt = 0;\n    for (char c : string) {\n        std::transform(c.begin(),\
    \ c.end(), c.begin(), ::tolower);\n        std::unordered_set<char> chars{c};\n\
    \        cnt += chars.size();\n    }\n    return cnt;", "    long count = 0;\n\
    \    for (char ch : string) {\n        switch (ch) {\n            case 'A':\n\
    \            case 'B':\n            case 'C':\n            case 'D':\n       \
    \     case 'E':\n            case 'F':\n            case 'G':\n            case\
    \ 'H':\n            case 'I':\n            case 'J':\n            case 'K':\n\
    \            case 'L':\n            case 'M':\n            case 'N':\n       \
    \     case 'O':\n            case 'P':\n            case 'Q':\n            case\
    \ 'R':\n            case 'S':\n            case 'T':\n            case 'U':\n\
    \            case 'V':\n            case 'W':\n            case 'X':\n       \
    \     case 'Y':\n            case 'Z':\n                count++;\n        }\n\
    \    }\n    return count;", "  // Initialize count\n  long count = 0;\n  for (char\
    \ c : string) {\n    if (c == '\\0') break;\n    count++;\n  }\n\n  // Perform\
    \ counting\n  long count = 0;\n  for (char c : string) {\n    if (c == '\\0')\
    \ break;\n    if (c >= 'a' && c <= 'z') count++;\n    if (c >= 'A' && c <= 'Z')\
    \ count++;\n  }\n  return count;", "    if (string == \"\") {\n        return\
    \ 0;\n    }\n    int n = string.length();\n    int count = 0;\n    for (int i\
    \ = 0; i < n; i++) {\n        count = (count + tolower(string[i])) % 26;\n   \
    \ }\n    return count;", "    // Initialize all the elements as 0\n    int count\
    \ = 0;\n    // Go through the string once and increment the count if the character\
    \ is different\n    for (int i = 0; i < string.length(); i++) {\n        // If\
    \ this character is different from the previous one, increment it\n        if\
    \ (string[i] != string[i - 1]) {\n            count++;\n        }\n    }\n   \
    \ return count;", "    long count = 0;\n    for (auto el : string) {\n       \
    \ if (el == '\\0') return count;\n        ++count;\n    }\n    return count;",
  "    long result = 0;\n    for (char c : string) result += static_cast<long>(c);\n\
    \    return result;", "    long distinct_characters = 0;\n    for (auto character\
    \ : string) {\n        distinct_characters += std::tolower(character) - 'a';\n\
    \    }\n    return distinct_characters;", "    long count = 0;\n    for (char\
    \ c: string) {\n        if (islower(c)) count++;\n        else if (isupper(c))\
    \ count++;\n    }\n    return count;", "    // Create a map to keep track of char\
    \ frequency of each unique character\n    std::string char_map;\n    \n    //\
    \ Iterate through every string character and keep track of each unique character\n\
    \    for (int i = 0; i < string.length(); i++) {\n        // Check if the character\
    \ already exists in the map\n        if (!char_map.find(string[i]) != char_map.end())\
    \ {\n            // If the character already exists, increment the count by 1\n\
    \            char_map[string[i]]++;\n        } else {\n            // Otherwise,\
    \ add the character to the map and set its count to 1\n            char_map[string[i]]\
    \ = 1;\n        }\n    }\n    \n    // Return the number of unique characters\
    \ in the given string\n    return char_map.size();", "    long num_distinct =\
    \ 0;\n    for (char &c : string) {\n        switch (tolower(c)) {\n          \
    \  case 'a':\n            case 'b':\n            case 'c':\n            case 'd':\n\
    \            case 'e':\n            case 'f':\n            case 'g':\n       \
    \     case 'h':\n            case 'i':\n            case 'j':\n            case\
    \ 'k':\n            case 'l':\n            case 'm':\n            case 'n':\n\
    \            case 'o':\n            case 'p':\n            case 'q':\n       \
    \     case 'r':\n            case 's':\n            case 't':\n            case\
    \ 'u':\n            case 'v':\n            case 'w':\n            case 'x':\n\
    \            case 'y':\n            case 'z':\n                num_distinct++;\n\
    \        }\n    }\n    return num_distinct;", "    // Write your code here.\n\
    \    long ans = 0;\n    for(int i = 0; i < string.length(); i++) {\n        ans\
    \ += (int)((string[i] >= 'a' && string[i] <= 'z') ? 26 : (int)string[i]);\n  \
    \  }\n    return ans;", "    long answer = 0;\n    for (char i : string) {\n \
    \       // ignore case for distinction\n        if (i == tolower(i)) {\n     \
    \       answer++;\n        }\n    }\n    return answer;", "    if (string.empty())\
    \ {\n        return 0;\n    }\n    long count = 1;\n    for (char ch : string)\
    \ {\n        ++count;\n        if (count++ == string.size()) {\n            return\
    \ count;\n        }\n    }\n    return count;", "    long count = 0;\n    for\
    \ (int i = 0; i < string.length(); ++i) {\n        if (string[i] == string[i +\
    \ 1]) count++;\n    }\n    return count;", "    // Your code goes here\n    return\
    \ __builtin_popcount(string.length());", "    long unique_count = 0;\n    for\
    \ (auto &c : string) {\n        if (std::tolower(c) == c) ++unique_count;\n  \
    \  }\n    return unique_count;", "    int count = 0;\n    for (auto c : string)\
    \ {\n        if ('a' <= c && c <= 'z')\n            ++count;\n    }\n    return\
    \ count;", "    // Write your code here.\n    long distinct = 0;\n    for(auto\
    \ it = string.begin(); it != string.end(); ++it){\n        if(*it == *std::prev(it))\n\
    \            distinct++;\n    }\n    return distinct;", "    long size = 0;\n\
    \    for (long i = 0; i < string.length(); i++) {\n        long count = 0;\n \
    \       for (long j = i; j < string.length(); j++) {\n            if (string[i]\
    \ == string[j]) {\n                count++;\n                break;\n        \
    \    }\n        }\n        size = size + count;\n    }\n    return size;", " \
    \   long count = 0;\n    for (auto &ch: string) {\n        ++count;\n    }\n \
    \   return count;", "\tlong count = 0;\n\tstring temp = string;\n\tfor (int i\
    \ = 0; i < temp.length(); i++) {\n\t\tif (temp.at(i) == 'X' || temp.at(i) == 'Y'\
    \ || temp.at(i) == 'Z') {\n\t\t\tfor (int j = i; j < temp.length(); j++) {\n\t\
    \t\t\ttemp[j] = temp.at(j);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;",
  "\tlong ans = 0;\n\tfor (long i = 0; i < string.length(); i++) {\n\t\tif (string[i]\
    \ >= 'a' && string[i] <= 'z') {\n\t\t\tans ++;\n\t\t}\n\t\tif (string[i] >= 'A'\
    \ && string[i] <= 'Z') {\n\t\t\tans ++;\n\t\t}\n\t\tif (string[i] >= '0' && string[i]\
    \ <= '9') {\n\t\t\tans ++;\n\t\t}\n\t}\n\treturn ans;", "    // Write your code\
    \ here\n    long answer = 0;\n    for (char character : string) {\n        if\
    \ (std::toupper(character) == character) {\n            answer++;\n        }\n\
    \    }\n    return answer;", "    long count = 0;\n    for(char c: string) {\n\
    \        if(std::tolower(c) != std::tolower(string[string.size() - 1])) {\n  \
    \          count += 1;\n        }\n    }\n    return count;", "    long count\
    \ = 1;\n    for (auto &c : string) {\n        if (std::tolower(c) == c) {\n  \
    \          ++count;\n        }\n    }\n    return count;", "    // Initialize\
    \ count with 0 and an empty string\n    long count = 0;\n    std::string temp_string\
    \ = \"\";\n    for (auto c : string) {\n        // Check if the character is uppercase\n\
    \        if ('A' <= c && c <= 'Z') {\n            // If it is uppercase\n    \
    \        temp_string += c;\n            // If it is not uppercase, increment the\
    \ count\n            // by 1\n            count += temp_string.length();\n   \
    \         temp_string = \"\";\n        } else {\n            // If it is not uppercase\n\
    \            // add it to a temporary string and count it\n            temp_string\
    \ += c;\n            count += temp_string.length();\n        }\n    }\n    return\
    \ count;", "    long n = 1;\n    for (auto c : string) {\n        long previous_n\
    \ = n;\n        n = n * 26 + c - 'a' + 1;\n        if (n > previous_n) return\
    \ 0;\n    }\n    return n;", "  long cnt = 0;\n  for (char ch : string) {\n  \
    \  if (std::tolower(ch) == ch)\n      cnt++;\n  }\n  return cnt;", "  long ans\
    \ = 0;\n  for (int i = 0; i < string.length(); i++) {\n    long c = tolower(string[i]);\n\
    \    if (string[i - 1] >= 'A' && string[i - 1] <= 'Z')\n      c = c + 32;\n  \
    \  ans += c;\n  }\n  return ans;", "    std::unordered_map<char, long> m;\n  \
    \  for (char c: string) {\n        m[c] += 1;\n    }\n    return m.size();", " \
    \ // Your code here\n  \n  for (int i = 0; i < string.length(); i++) {\n    int\
    \ count = 0;\n    for (int j = i; j < string.length(); j++) {\n      if (string[i]\
    \ == string[j]) {\n        count++;\n      }\n    }\n    cout << count << endl;\n\
    \  }\n  // Your code here", "  // Write your code here.\n  std::map<char, int>\
    \ char_map;\n  for (auto ch : string) {\n    char_map[ch] = char_map.count(ch)\
    \ + 1;\n  }\n  return char_map.size();", "    // Write your code here\n    long\
    \ result = 0;\n    for(auto x : string){\n        auto it = string.find(x);\n\
    \        if(it!=string::npos){\n            result++;\n            string.erase(it,1);\n\
    \        }\n    }\n    return result;", "    long count = 0;\n    for (char c\
    \ : string)\n        if (c == 'a' || c == 'A' || c == 'b' || c == 'B' || c ==\
    \ 'c' || c == 'C' || c == 'd' || c == 'D' || c == 'e' || c == 'E' || c == 'f'\
    \ || c == 'F' || c == 'g' || c == 'G' || c == 'h' || c == 'H' || c == 'i' || c\
    \ == 'I' || c == 'j' || c == 'J' || c == 'k' || c == 'K' || c == 'l' || c == 'L'\
    \ || c == 'm' || c == 'M' || c == 'n' || c == 'N' || c == 'o' || c == 'O' || c\
    \ == 'p' || c == 'P' || c == 'q' || c == 'Q' || c == 'r' || c == 'R' || c == 's'\
    \ || c == 'S' || c == 't' || c == 'T' || c == 'u' || c == 'U' || c == 'v' || c\
    \ == 'V' || c == 'w' || c == 'W' || c == 'x' || c == 'X' || c == 'y' || c == 'Y'\
    \ || c == 'z' || c == 'Z')\n            count++;\n    return count;", "    //\
    \ Initialize count for first character\n    long count = 1;\n    // Iterate through\
    \ remaining characters, add 1 if character is different, otherwise increment count\n\
    \    for (auto i : string.begin() + (string.size() - 1)) { \n        if (string[i]\
    \ != string[i - 1]) { \n            count++; \n        } \n    } \n    return\
    \ count;", "    if (string.empty())\n        return 0;\n    int counter = 0;\n\
    \    for (auto c : string) {\n        ++counter;\n        if (string[counter]\
    \ >= 'a' && string[counter] <= 'z')\n            counter++;\n        if (string[counter]\
    \ >= 'A' && string[counter] <= 'Z')\n            counter++;\n    }\n    return\
    \ counter;", "    // Use a map to store the count of distinct characters\n   \
    \ std::map<char, int> map;\n    for(char c : string) {\n        ++map[c];\n  \
    \  }\n\n    // Return count\n    return map.size();", "    std::unordered_set<char>\
    \ chars;\n    for (auto &c: string) {\n        chars.insert(c);\n    }\n    return\
    \ chars.size();", "    // Write your code here\n    long number_of_uniques = 0;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string.at(i).isupper())\
    \ {\n            number_of_uniques += 1;\n        } else if (string.at(i).islower())\
    \ {\n            number_of_uniques += 1;\n        }\n    }\n    return number_of_uniques;",
  "    long count = 0;\n    for (auto x : string) {\n        count += (x == 'a' ||\
    \ x == 'A') + (x == 'b' || x == 'B') + (x == 'c' || x == 'C') + (x == 'd' || x\
    \ == 'D') + (x == 'e' || x == 'E') + (x == 'f' || x == 'F') + (x == 'g' || x ==\
    \ 'G') + (x == 'h' || x == 'H') + (x == 'i' || x == 'I') + (x == 'j' || x == 'J')\
    \ + (x == 'k' || x == 'K') + (x == 'l' || x == 'L') + (x == 'm' || x == 'M') +\
    \ (x == 'n' || x == 'N') + (x == 'o' || x == 'O') + (x == 'p' || x == 'P') + (x\
    \ == 'q' || x == 'Q') + (x == 'r' || x == 'R') + (x == 's' || x == 'S') + (x ==\
    \ 't' || x == 'T') + (x == 'u' || x == 'U') + (x == 'v' || x == 'V') + (x == 'w'\
    \ || x == 'W') + (x == 'x' || x == 'X') + (x == 'y' || x == 'Y') + (x == 'z' ||\
    \ x == 'Z');\n    }\n    return count;", "    // Using hash to count number of\
    \ distinct characters\n    long num_of_distinct_characters = 0;\n    long num_of_unique_characters\
    \ = 0;\n    for (char ch : string) {\n        num_of_distinct_characters += 1;\n\
    \        num_of_unique_characters += (ch - 'A' + 1);\n    }\n    return num_of_distinct_characters;"]
stop_tokens:
- "\n}"
