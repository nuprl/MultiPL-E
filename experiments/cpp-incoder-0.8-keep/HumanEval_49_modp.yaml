name: HumanEval_49_modp
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware\
  \ of numerics).\n// >>> modp(3, 5)\n// 3\n// >>> modp(1101, 101)\n// 2\n// >>> modp(0,\
  \ 101)\n// 1\n// >>> modp(3, 11)\n// 8\n// >>> modp(100, 101)\n// 1\nlong modp(long\
  \ n, long p) {\n"
tests: "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
  \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
  \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
  \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
  \ (5)) == (3));\n}\n"
completions: ["  assert(p != 0);\n  long q = (long) p / 2;\n  long r = p - q * 2;\n\
    \  long res = q * n + (r % p) * ((r - q * n % p) % p);\n  assert(res >= 0);\n\
    \  return res;", "    if (n >= p) {\n        return n;\n    }\n    long r = 1;\n\
    \    while ((n & 1) != 0) {\n        r = r * 2;\n        n >>= 1;\n    }\n   \
    \ return r % p;", "  long r = 0, t = n, m;\n  while (t > 0) {\n    m = (t + p)\
    \ % p;\n    t -= m;\n    r = r*m + n;\n  }\n  return r;", '    return ((n+1)%p)*(p+1)/(n+1);',
  "\tlong mod = 0;\n\tlong mask = -1;\n\twhile (p != 0) {\n\t\tmod = (mod * n) + ((p\
    \ & 1) ? p >> 1 : p);\n\t\tmask = mask * p + ((mask & 1) ? p >> 1 : p);\n\t\t\
    p = p >> 1;\n\t}\n\treturn ((mod * (mask + mask + 1)) >> 1) - mask;", "    if\
    \ (n < p) {\n        return modp(n % p, p) % p;\n    }\n    return n % p;", " \
    \   long x = n;\n    long mod = p;\n    while (x != 0) {\n        if (x & 1) {\n\
    \            mod += mod;\n        }\n        x = x / 2;\n    }\n    return mod;",
  "\t// If n is less than 0, return 0.\n\tif(n < 0) {\n\t\treturn 0;\n\t}\n\t// If\
    \ p is less than 0, return 0.\n\tif(p < 0) {\n\t\treturn 0;\n\t}\n\t// Initialize\
    \ MOD to 0.\n\tlong mod = 0;\n\t// Initialize remainder to 1.\n\tlong remainder\
    \ = 1;\n\t// Run loop until n is greater than 0.\n\twhile(n != 0) {\n\t\t// Divide\
    \ n by p.\n\t\tremainder = (n % p + remainder) % p;\n\t\t// Subtract n from p.\n\
    \t\tn = n / p;\n\t\t// Add 1 to mod.\n\t\tmod = mod + (remainder == 0 ? 1 : 0);\n\
    \t}\n\t// Return mod.\n\treturn mod;", "  // assert(n >= 0 && n <= p);\n  return\
    \ pow(LONG_MAX, n) % p;", "\tassert(p > 0 && n >= 0);\n\tassert(p > 0 && p <=\
    \ n);\n\tlong ret = n - (n%p);\n\tassert(0 <= ret && ret <= p);\n\treturn ret;",
  "  assert(n >= 0 && p > 0 && p < INT_MAX);\n  // Special case n==0.\n  if (n ==\
    \ 0) {\n    return 1;\n  }\n  // Special case p==1.\n  if (p == 1) {\n    return\
    \ n;\n  }\n  if (p == 0) {\n    return 1;\n  }\n  long result = 0;\n  // Special\
    \ case p==0.\n  if (p == 0) {\n    return 1;\n  }\n  // Divide by p until you\
    \ have reduced down to 1 mod p.\n  while (n > p) {\n    n /= p;\n    ++result;\n\
    \  }\n  // Multiply by 2^(result mod p) until you have reduced down to n.\n  while\
    \ (n > 1) {\n    result *= 2;\n    --n;\n  }\n  return result;", "    long res\
    \ = 1;\n    while (n) {\n        n &= n - 1;\n        res *= p;\n    }\n    return\
    \ res;", "    // If n is divisible by p, then n is odd and (p - 1) is even.\n\
    \    if (p & n) {\n        return (p - 1) & ~(p-1);\n    }\n    return n;", " \
    \   long res = n & -p;\n    while (n >> p)\n        n -= p;\n    return res +\
    \ p;", "\tif (p < 0)\n\t\treturn 0;\n\tlong a = p % n;\n\tlong b = n - p;\n\t\
    return (a * b + a) % n;", "  assert(p != 0 && p < p);\n  long d = 1;\n  for (int\
    \ i = 0; i < p; ++i) {\n    d = d * (n / p + 1);\n    n %= p;\n  }\n  return d;",
  "  long r = n;\n  while (n > p) {\n    r = r * p % 101;\n    n /= 101;\n  }\n  return\
    \ r;", "    long r=1, i;\n    for(i=1;i<=n;i++)\n        r=(r*p)%p+r;\n    return\
    \ r;", "  long res = 1;\n  while(n != 0) {\n    if(n&1)\n      res = (res*p +\
    \ n&1) %p;\n    n = (n-1)/2;\n    p = (p*p + 2*n%p) %p;\n  }\n  return res;",
  "    long r = n;\n    long m = 1;\n    long t;\n    // This should loop until it\
    \ reaches zero, but we need\n    // to make sure to stop before p reaches 2n-1\
    \ since the\n    // result would wrap back around to 1\n    while (r >= p) {\n\
    \        t =  r - p;\n        r = (r - t) % p;\n        m = (m * t) % p;\n   \
    \ }\n    return (m * p + r) % p;", "    long res = 1;\n    for (long i = 1; i\
    \ < p; ++i) {\n        res *= p;\n    }\n    return res % n;", "    long ans =\
    \ 1;\n    long temp = n;\n    while(temp != 0){\n        ans = temp%p;\n     \
    \   temp /= p;\n    }\n    return ans;", '    return n % p;', "    int d = n %\
    \ p;\n    return d * d % p + p - (d * d % p);", "    long reminder = 0;\n    while\
    \ (n > 0) {\n        reminder = (reminder * 10 + n % p) % p;\n        n /= p;\n\
    \    }\n    return reminder == 0 ? 1 : reminder;", "  assert(p == 0 || n >= p);\n\
    \  long q = p / p;\n  return n % q == 0 ? q : (n / q) + 1;", '    return (p^(n+p))%p;',
  "\tn = n % p;\n\tlong r = p % p - n;\n\twhile (p >= r) r = (r + p) % p;\n\treturn\
    \ r;", '  return n % p;', "  if (n <= p / 2)\n    return 2 * n;\n  return (p *\
    \ modp(n - p + 2, p) + p) % p;", "\treturn (p-1L) % (n+1L);", "   long a = n;\n\
    \   long t = p;\n   while( t > 0 ) {\n      long d = (a % t);\n      a = t;\n\
    \      t = d;\n   }\n   return a;", "\tlong q = p / n;\n\tlong r = p % n;\n\t\
    return (q * q * q + r * r) % p;", '    return ((n % p) + p) % p;', "    if (p\
    \ == 1) return 1;\n    if (n == p) return 2;\n    if (n % p == 0) return modp(n/p,\
    \ p) + 1;\n    return modp(n/p, p);", "    assert(n >= 0 && p >= 0);\n    if (n\
    \ == 0) return 1;\n    // If n is odd, we have |n| / |p| >= 2^(n-1). Since 2^n-1\
    \ == p-1, we can safely subtract p-1 from n.\n    long r1 = (n-1) % (p-1);\n \
    \   long r2 = (r1 * (r1+1)) % (p-1);\n    return r2 - (r1 * r1) / p;", "    if\
    \ (p == 0) {\n        return 1;\n    }\n    if (n % p == 0) {\n        return\
    \ modp(n / p, p);\n    }\n    return modp(n / p + 1, p) + 1;", "\tlong res = 0;\n\
    \twhile (n != 0) {\n\t\tres = (res * 31 + n % p);\n\t\tn = n / p;\n\t}\n\treturn\
    \ res;", "\tassert(n>0 && p>0);\n\t\n\tlong res = 1;\n\tlong x = 0;\n\tfor (;\
    \ n>0; n--) {\n\t\tlong a = x%p;\n\t\tx /= p;\n\t\tres = (res * a) % p;\n\t}\n\
    \treturn res;", "    long r = 0, x = 0, y;\n    while ((y = n / p) != 0) {\n \
    \       r = y * p;\n        r = ((x % p) + r) % p;\n        x = x;\n        n\
    \ = n;\n    }\n    return r;", "  assert(p > 0);\n  long q = n - p;\n  long r\
    \ = q % p;\n  return q + ((p * r) + p) % p;", "    long r = 1;\n    long m = 1;\n\
    \    long t = (p - 1) % p;\n    long u = 1;\n    long w;\n\n    while (p > 1)\
    \ {\n        w = (n + m) % p;\n        r = r * u % p;\n        m = m + (r * u\
    \ * t) % p;\n        u = u * t % p;\n        n = w;\n        t /= p;\n    }\n\
    \    return r;", "    if (p < 1)\n        return (n % p);\n    else if (p > 1)\n\
    \        return (n + (p / p) % p);\n    else\n        return n;", "  assert(n\
    \ >= 0);\n  assert(p >= 0);\n  // if (n == 0 || p == 0) return 1;\n  if (n ==\
    \ p) return 1;\n  if (n <= p) return n & (p - 1);\n  int t = modp(n - (p << 1),\
    \ p);\n  return p + (t < p);", "  assert(p != 0);\n  long m = p-1;\n  long t =\
    \ ((n%p) + m + 1) % p;\n  if (t != 0) return t;\n  while (m != 0) {\n    t = ((n%m)\
    \ + m + 1) % p;\n    if (t != 0) return t;\n    m--;\n  }\n  return n;", '  return
    n % p;', "    long r = n % (p - 1);\n    return (r < 0) ? r + p : r;", "    long\
    \ result = 0;\n    while (n) {\n        if (n % p) {\n            result += (n\
    \ - 1) / p;\n        }\n        n /= p;\n    }\n    return result;", "    long\
    \ mod = pow(n, (p + 1) >> 1) - 1;\n    return (n % mod) / mod;", "  assert(p >\
    \ 0);\n  long res = n >> 1;\n  while (res && !(res & p)) res >>= 1;\n  return\
    \ res;", "    if(!n)\n        return 1;\n    long r = 1;\n    for(int i = 5; i;\
    \ i--)\n        if((n&1) != (n&(p-2))) r += n>>(3-i)*i;\n    return r;", "   \
    \ long res = 1L;\n    while (n) {\n        if ((n & 1L) == 0)\n            res\
    \ = (res % p) + (p - 1L);\n        n >>= 1L;\n    }\n    return (res % p);", "\t\
    if (n >= p) \n\t\treturn n - p;\n\treturn n % p;", '    return n%p;', "    if(n==0)\
    \ return 0;\n    long ans = 1;\n    for(long i=1; i<=n; i++) {\n        if((i\
    \ % p) == 0) ans *= 2;\n        ans %= p;\n    }\n    return ans;", "    // Use\
    \ a signed integer type so that\n    // the remainder wraps around as needed.\n\
    \    typedef long long ll;\n    ll ans = 0;\n    while (n > p) ans <<= 1;\n  \
    \  ans %= p;\n    return ans;", "  long r = 1;\n  long m = 0;\n  while (n != 0)\
    \ {\n    if (n & 1)\n      r *= p;\n    m += 1;\n    n >>= 1;\n  }\n  return r\
    \ * powl(2.0, m);", "\tassert(n >= 0);\n\tassert(p >= 0);\n\treturn (((1ll <<\
    \ p) * n) >> p) % p;", "    long ans = 0;\n    while (n != 0) {\n        ans =\
    \ ans * 2 + n % p;\n        n = n / p;\n    }\n    return ans;", "    long res\
    \ = 1;\n    while (p & 1)\n        res = (res % p + n) % p;\n    return res;",
  "    long res = 1;\n    while(n != 0) {\n        if (n%2 == 1)\n            res\
    \ = (res * p)%p;\n        n = n/2;\n        p = (p*p)%p;\n    }\n    return res;",
  '    return n - (n % p);', "  if (n%p==0)\n    return n;\n  int rem = n%(p-1);\n\
    \  long ret = (rem*(p-1))+(p-1);\n  return ret;", '    return p - (((p * n) %
    p) + p) % p;', "    long ret = 1;\n    while (n>0) {\n        if (n%p != 0) {\n\
    \            ret *= p; // x^p\n        }\n        n /= p; // n/x\n        p /=\
    \ 2; // p/2\n    }\n    return ret;", "    if (p != 1) {\n        return ((n &\
    \ -p) ^ (p & -n)) % p;\n    }\n    return n & -p;", "    if (n < p) {\n      \
    \  return 1;\n    }\n    long res = n;\n    for(long i = 2; i < p; i++) {\n  \
    \      res = (res * res) % p;\n    }\n    return res;", "  assert(p != 0);\n \
    \ if (n < 0) {\n    n = (-n);\n    p = -p;\n  }\n  long result = n;\n  while (n\
    \ != 0) {\n    if (n % p == 0) {\n      result *= p;\n      result %= p;\n   \
    \ }\n    n /= p;\n  }\n  return result;", "    if (p == 0)\n        return n;\n\
    \    if (n % p == 0)\n        return n;\n    return (n + (p / p) % p);", "  //\
    \ Compute 2^n modulo p using exponentiation by squaring.\n  long ret = 1;\n  for\
    \ (int i = 0; i < n; i++) {\n    ret *= p;\n    ret %= p;\n  }\n  return ret;",
  "\tif (p == 0)\n\t\treturn 0;\n\tif (p < 0)\n\t\treturn modp(n, -p);\n\tif (n ==\
    \ 0)\n\t\treturn p;\n\tif (p % 2 == 0)\n\t\treturn n * modp(n / 2, p);\n\telse\n\
    \t\treturn ((n - 1) * modp(n, p - 1)) + 1;", "    long r = 1;\n    while (n) {\n\
    \        long m = n % p;\n        n = (n - m) % p;\n        r = (r * m % p + r)\
    \ % p;\n    }\n    return r;", "    assert(n >= p);\n    if (n == 0)\n       \
    \ return 1;\n    // If n is smaller than p, then n^(p-1) is the same as n.\n \
    \   if (n < p)\n        return n;\n    return n % p;", "\tif (n >= p) {\n\t\t\
    long r = n % p;\n\t\tlong m = p % n;\n\t\tif (m == 0)\n\t\t\treturn r;\n\t\telse\n\
    \t\t\treturn (r + (m + (n % p)));\n\t} else\n\t\treturn (n);", "  long ans = 1;\n\
    \  while (n) {\n    if (n % p == 0)\n      ans = (ans * (n - p)) / p;\n    p =\
    \ p / p;\n    n = n / p;\n  }\n  return ans;", '    return (((n & (p-1))) ? ((n+1)
    & -p) : (n & -p));', '    return (n % p + p) % p;', "    if (p == 0 || n == 0)\n\
    \        return 0;\n    if (n >= p)\n        return 1;\n    if (n == p)\n    \
    \    return n;\n    if (n < p)\n        return modp(n - p, p) + p;\n    // Not\
    \ possible.\n    long r = modp(n - p, p);\n    return (r * r + n) % p;", '    return
    (n + p + 1) % (p + 1);', "    if(p < 2)\n        return 1;\n    long m = (long)\
    \ n%p;\n    return m==0?1:m;", "    long ret = 1;\n    while (n) {\n        if\
    \ (n % p) {\n            ret *= p;\n            ret %= p;\n        }\n       \
    \ n /= p;\n    }\n    return ret;", "  // Use modular exponentiation as it is\
    \ very fast.\n  // http://www.hackersdelight.org/magic.htm\n  long res = 1;\n\
    \  while (p > 1) {\n    if (n % p) {\n      res = (res*p) % p;\n    }\n    p /=\
    \ 2;\n  }\n  return res;", "    long n1 = n % p;\n    long n2 = ((n1 - 1) // p)\
    \ + (n % p);\n    long n3 = (n2 % p) + p;\n    return (n3 // p);", "    if (p\
    \ % 2 == 0) {\n        return (n + 1) % (p - 1);\n    } else {\n        return\
    \ (n + p + 1) % (p - 1);\n    }", "    if(n == 1) return 1;\n    if(n == 2) return\
    \ p;\n    if(n%3 == 0) return modp(modp(n/3, p), p);\n    return (p*modp(n/3,\
    \ p)) % p;", "    int c = 0;\n    while (p) {\n        if ((p & 1) && n) {\n \
    \           c = (c + n) % p;\n        }\n        n >>= 1;\n        p >>= 1;\n\
    \    }\n    return c;", "    long r = 0, div = 0, mod = 0, t = 0, q;\n    q =\
    \ n / p;\n    mod = n % p;\n    div = q;\n    while (q > 0) {\n        r = r +\
    \ div;\n        div = div / p;\n        mod = mod % p;\n        q = q - 1;\n \
    \       t = t + mod;\n    }\n    return r % p;", "  if(n == 0) {\n    return 1;\n\
    \  }\n  \n  int res = 1;\n  \n  long modp = p % n;\n  \n  while(modp != 0) {\n\
    \    res *= n;\n    res %= modp;\n    \n    modp /= n;\n  }\n  \n  return res;",
  "  assert(p != 0);\n  n %= p;\n  long r = n - p * ((n / p) % p);\n  return r;",
  "  long mod = 1;\n  while(n != 0) {\n    if (n % p == 0) {\n      mod = 2 * mod;\n\
    \      n = (n / p) - 1;\n    } else {\n      mod = (mod * p) + 1;\n    }\n  }\n\
    \  return mod;", "    long ans = 1;\n    while (n > p) {\n        ans = (ans *\
    \ (n % p) + p) % p;\n        n /= p;\n    }\n    return ans % p;", "    if (n\
    \ >= p)\n        return 1;\n    int r = n % p;\n    return ((n * p + r - 1) /\
    \ (p + 1)) % p;", '    return (n + p-1) & -p;', '    return (n%p) + p;', '    return
    (n + p + 1) % p;', '    return n%p;', "    if (p < 0) return n;\n    if (p > n)\
    \ return 0;\n    if (p == 0) return 1;\n    if (p == 1) return n;\n    long d\
    \ = p / 2;\n    long r = n % d;\n    if (r == 0) return modp(n / d, p);\n    return\
    \ modp(n / d, p) * p + r;", "    long mod = p; // Use 'mod' since 'p' may be negative.\n\
    \    long result = 1;\n    while (n != 0) {\n        if (n % 2 == 1) {\n     \
    \       result *= mod;\n            mod *= p;\n        }\n        n /= 2;\n  \
    \      mod /= p;\n    }\n    return result;", '    return ((n % p) + p) % p;',
  "    long ans = 1;\n    long p = p%n;\n    for(int i=1; i<p; i++) {\n        ans\
    \ = ans*2;\n    }\n    return ans % n;", "  assert(n >= 0);\n  assert(p >= 0);\n\
    \  long c = 1;\n  long r = n;\n  while (r != 0) {\n    long t = r / p;\n    long\
    \ u = r - t * p;\n    r = t;\n    if (r > 0) {\n      c = c + u;\n    }\n  }\n\
    \  return c;", "    long res = 1L;\n    while (res < p) {\n        res = (res*2L)\
    \ % p;\n    }\n    return res;", "\t// Assert n is positive.\n\tassert(n > 0);\n\
    \t// If n is 1, return p.\n\tif (n == 1)\n\t\treturn p;\n\t// Find largest factor\
    \ <= p.\n\tlong m = p - 1;\n\twhile (m >= 2) {\n\t\tif (n % m == 0)\n\t\t\tbreak;\n\
    \t\tm /= 2;\n\t}\n\t// Compute n / m and reduce by one.\n\tlong r = n / m;\n\t\
    return (r * m) + 1;", "  assert(n > p);\n  long r = p - 1;\n  for (; n >= r; --r)\
    \ {\n    r = r * p + (n % r);\n  }\n  return r;", "  assert(p > 0);\n  assert(n\
    \ >= 0);\n  long r = 1;\n  for (long i = 0; i < p; i++) {\n    r = (r * n) % p;\n\
    \  }\n  return r;", "  assert(p != 1);\n  long result = 0;\n  while (n) {\n  \
    \  if (n & 1) {\n      result = result * p + (n % p); // result is odd, n is even\n\
    \    }\n    n /= p;\n    p /= 2;\n  }\n  return result;", "    long a = n >> 35;\
    \ // a is power of two with at most 35 trailing zeros.\n    if (a == 0) {\n  \
    \      return 1;\n    }\n    long b = 31; // b is power of two with at most 31\
    \ trailing zeros.\n    if (p == 0) {\n        return 0;\n    }\n    long c = p\
    \ >> 30; // c is power of two with at most 30 trailing zeros.\n    if (c == 0)\
    \ {\n        return 1;\n    }\n    long d = p >> 29; // d is power of two with\
    \ at most 29 trailing zeros.\n    if (d == 0) {\n        return 1;\n    }\n  \
    \  long r = p >> 28; // r is power of two with at most 28 trailing zeros.\n  \
    \  if (r == 0) {\n        return 1;\n    }\n    // We are interested in finding\
    \ r\n    // so r^2 + a^2 = n, with n odd and a^2 odd\n    // So we start with\
    \ a^2 > r^2 > 1\n    long s = 1;\n    while ((s << 1) <= n) {\n        s <<= 1;\n\
    \    }\n    if (s == n) {\n        // We are looking for r\n        // So r^2\
    \ + a^2 = n, with n odd and a^2 odd\n        // r^2 = s^2 - 2*s + 1, s = 2**(r-1)\n\
    \        // r^2 = 2*s*(1 + s^2) (mod p)\n        // r^2 = (2*s*s + s^2)(mod p)\n\
    \        // s = 2**(r-1) * 2^(r-1)\n        // s = s*(1 + s^2)\n        // s =\
    \ 2*s*(2*s+1)\n        // s = 2*(2*s+1)\n        // s = (2*s+1)*(2*s+1)\n    \
    \    // s = (2*s+1)*(2*s+1)\n        // s = 2*(3*s+1)*(2*s+1)\n        // s =\
    \ 2*(4*s+1)*(2*s+1)\n        // s = (2*s+2)*(2*s+1)\n        // s = 2*((3*s+2)*(2*s+1)\n\
    \        // s = (3*s+3)*(2*s+1)\n        // s = (3*s+3)*(2*s+1)\n        // s\
    \ = (3*s+3)*(2*s+1)\n        // s = 2*((5*s+3)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n\
    \        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s\
    \ = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n\
    \        // s = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*s+1)\n        // s\
    \ = (5*s+5)*(2*s+1)\n        // s = (5*s+5)*(2*", '    return (n % p + p) % p;',
  "  assert(p != 0 && p == p);\n  long res = 0;\n  while(n) {\n    if (n & 1)\n  \
    \    res = (res * p) + 1;\n    n >>= 1;\n    p <<= 1;\n  }\n  return res;", " \
    \ assert(p != 1);\n  long res = 1;\n  while (n >= p) {\n    res *= p;\n    n -=\
    \ p;\n  }\n  while (n > 1) {\n    res *= n;\n    n -= 1;\n  }\n  return res;",
  "\tassert(p >= 0);\n\tassert(p < 10);\n\tlong q = 0;\n\twhile (n > 0) {\n\t\tlong\
    \ t = n & -p;\n\t\tn = n;\n\t\tq ^= t;\n\t}\n\treturn q;", "    long r = n;\n\
    \    while (r != 0) {\n        r = r % p;\n    }\n    return r;", "    if(n >=\
    \ p) {\n        return n;\n    }\n    long a = n % p;\n    long rem = p % a;\n\
    \    if(rem == 0) {\n        return n;\n    }\n    if(rem < 0) {\n        return\
    \ n - p + 1;\n    }\n    return n - p;", "  if (n == 0) return 0;\n  if (p ==\
    \ 0) return 1;\n  long r = n & -p;\n  long t = modp(n ^ r, p);\n  return (r ^\
    \ t) ^ p;", "  long r = n % p;\n  return (r < 0) ? r + p : r;", "    // Return\
    \ 2^n modulo p.\n    long r = 1;\n    for (long i = n, d = 1; 1; ) {\n       \
    \ long t = r * n - d;\n        if (t > p) {\n            r = n - d;\n        }\n\
    \        else if (t < -p) {\n            d = r * n;\n        }\n        else {\n\
    \            break;\n        }\n    }\n    return r;", "    long r = n;\n    long\
    \ q = 1;\n    while (r > p) {\n        r = r - p;\n        q = q * 2;\n    }\n\
    \    return (r == 0 && q == 1) ? p : q;", "\tif (n == 0 || p == 0)\n\t\treturn\
    \ 0;\n\tlong x = 1;\n\twhile (p--) {\n\t\tx = x * n % p;\n\t\tn = (n / p);\n\t\
    }\n\treturn x;", "    long r = 1;\n    while (n > 0) {\n        if (n % p == 0)\
    \ {\n            n = n / p;\n            r *= p;\n        } else {\n         \
    \   n = n / p;\n            r *= p % p;\n        }\n    }\n    return r;", " \
    \   int i = 2;\n    while (i <= p) {\n        if (n % i == 0) {\n            return\
    \ n / i;\n        }\n        ++i;\n    }\n    return n;", "    if (n == 0 || n\
    \ == p)\n        return n;\n    if (p % 2 == 1)\n        return n - (n / p) *\
    \ p;\n    return n - ((n / p) % 2) * p;", "  assert(n % p == 0 || p % n == 0);\n\
    \  if (p > n) std::swap(n, p);\n  long r = 1;\n  while (n) r = ((n % p) != 0)\
    \ ? ((r * n) % p) : (r * n % p), (n *= 2);\n  return r;", "  assert(n >= 0 &&\
    \ p > 0);\n  long t = p + (n / p) % p;\n  return t;", "\tif(n == 0) return 1;\n\
    \tif(n == p) return n;\n\tif(n%p == 0) return modp(n/p, p);\n\treturn modp(n/p,\
    \ p) + p%p;", "  assert(n >= 0 && n % p == 0);\n  if (n == 0) return 1;\n  if\
    \ (n == p) return 2;\n  if (n % p == 0) return modp(n / p, p);\n  return modp(n\
    \ / p, p) + 1;", "    long res = 1LL;\n    while (p) {\n        if (n % p == 0)\
    \ {\n            res++;\n            n /= p;\n        }\n        else {\n    \
    \        res %= p;\n            p /= p;\n        }\n    }\n    return n;", " \
    \ assert(n > 0);\n  long r = n & -p;\n  n = n >> p;\n  long k = 1;\n  while (n)\
    \ {\n    if (n & 1) r += k;\n    k *= 10;\n    n >>= 1;\n  }\n  return r % p;",
  "\tlong ans = 1L;\n\twhile (p != 0) {\n\t\tans = (ans * n) % p;\n\t\tp--;\n\t}\n\
    \treturn ans;", "  if (p == 0)\n    return 1;\n  long q = (p - 1) / p;\n  return\
    \ (n * q + p) % p;", "    // https://stackoverflow.com/questions/11203057/modular-exponentiation-modpow-for-64-bit\n\
    \    long ret = 1;\n    long m = 3;\n    while(n){\n        // n & 1\n       \
    \ if(n&1){\n            ret *= m;\n        }\n        // n /= 2\n        n = n/2;\n\
    \        m *= m;\n    }\n    return ret;", "  assert(p > 0);\n  long ans = 1;\n\
    \  while (n >= p) {\n    ans = (ans * p + n) % p;\n    n /= p;\n  }\n  return\
    \ ans;", '    return (1 << (n & 0x1f)) - 1 + p;', "  assert(n >= 0 && p >= 0);\n\
    \  long ret = 0;\n  while (n > 1) {\n    if (n & 1) {\n      ret = 2 * ret + p;\n\
    \      p = p - 1;\n    }\n    n = n / 2;\n  }\n  return ret + p;", "    if(p==0){\n\
    \        return 1;\n    }\n    long res = 1;\n    while(n>0){\n        res *=\
    \ p;\n        res += (n&p)!=p? 1 : 0;\n        n /= p;\n    }\n    return res;",
  "\tassert(p > 0);\n\tlong q = n % p;\n\tlong r = p - (q * p);\n\treturn q + (r *\
    \ q);", "  if (p < 2)\n    return 1;\n  if (n >= p)\n    return modp(n, p / 2);\n\
    \  long res = 1L;\n  while (n > p) {\n    long next_res = modp(n, p);\n    if\
    \ (res + next_res > p)\n      return res;\n    res = next_res;\n    n--;\n  }\n\
    \  return res;", "    while ((n & 1) == 0)\n        n >>= 1;\n    for (long k\
    \ = p; n != 1; n >>= 1)\n        if (n & 1)\n            k %= p;\n        else\n\
    \            k %= p;\n    return k;", "    long sum = 0;\n    long t = 1;\n  \
    \  while (true) {\n        if (n & 1) sum += t;\n        n >>= 1;\n        if\
    \ (n == 0) {\n            return sum;\n        }\n        t *= p;\n    }", " \
    \   long q = n / p;\n    long r = n % p;\n    return (r + p * q + (q << 1) + q\
    \ * (p << 1)) % p;", "    if (n % p)\n        return 0;\n    else\n        return\
    \ n / p;", "\tlong r = 1;\n\tlong m = 0;\n\twhile (m <= p) {\n\t\tm = (r * n)\
    \ % p;\n\t\tr = (r * n) % p;\n\t}\n\treturn r;", "    // The last digit of the\
    \ power of p, plus 1.\n    long ret = p - 1;\n    // The remainder of the division\
    \ of n by p, plus 1.\n    while (n > 0)\n    {\n        ret = ret % p + 1;\n \
    \       n /= p;\n    }\n    return ret;", "    long res = 1;\n    \n    for (int\
    \ i = 0; i < p; i++) {\n        res = (res * n) % p;\n    }\n\n    return res;",
  "    if(!p)\n        return 0;\n    long r = n;\n    while(r % p)\n        r = r\
    \ * p % p;\n    return r / p;", '    return ((n & -p) | ((n & p) ^ ~n)) % p;',
  "  // assert(p < n);\n  // if (n == 0)\n  //   return 1;\n  // if (n == p)\n  //\
    \   return 1;\n  // return modp(n - p, p) + modp(n - p, p);\n  if (n == 0)\n \
    \   return 1;\n  if (n == p)\n    return 1;\n  return modp(n - p, p) + modp(n\
    \ - p, p);", '    return ((n - 1) * (p + 1) + (p + 1)) % p;', "    long res =\
    \ n;\n    \n    while (res >= p) res = (res%p) + p;\n    return res + 1;", " \
    \   if (n == 0)\n        return 1;\n    long res = modp(n/p, p);\n    return ((n\
    \ % p) < res)? res: (n % p);", "    assert(n > 0 && p > 0);\n    int res = 1;\n\
    \    for (int i = 2; i <= p; i <<= 1) {\n        if (n & i)\n            res =\
    \ (n - res + p) % p;\n    }\n    return res;", "  long ans = 1;\n  while (n >\
    \ p) {\n    ans *= n;\n    n -= p;\n  }\n  return ans;", '    return n % p;',
  "\tlong ans = n;\n\tfor (long i = 2; i <= p; i <<= 1) {\n\t\tif (n % i == 0) {\n\
    \t\t\tans += i;\n\t\t\tn /= i;\n\t\t}\n\t}\n\treturn ans;", "    assert(p%2 ==\
    \ 0);\n    long res = (n % p) / p;\n    if(res == 0) res = p;\n    return res;",
  "\tassert(p != 0);\n\tif (n == 0)\n\t\treturn 0;\n\tif (n == p || n == (p-1) )\n\
    \t\treturn n;\n\tlong rem = n % p;\n\tif (rem == 0)\n\t\treturn n;\n\treturn (p-rem)\
    \ + n;", "  long q = p / 2;\n  long r = p - q * 2;\n  r = q * (p - r + q);\n \
    \ r = q * (p - r + q);\n  r = q * (p - r + q);\n  return ((n - (n >> 1)) + q)\
    \ + r;", "  assert(p > 0);\n  long q = n / p;\n  long r = n % p;\n  long result\
    \ = 1;\n  while (result <= q) {\n    result *= p;\n  }\n  if (r == 0) {\n    return\
    \ 1;\n  }\n  return result;", "\tlong a = 1;\n\tlong b = 1;\n\tlong c = 1;\n\t\
    long n2 = n;\n\tlong p2 = p;\n\t\n\twhile (true) {\n\t\tlong a3 = a;\n\t\tlong\
    \ b3 = b;\n\t\t\n\t\tlong tmp = n2 / p2;\n\t\tlong q = tmp;\n\t\tlong r = n2 -\
    \ tmp * p2;\n\t\t\n\t\tif (r == 0) {\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tif (q\
    \ == 1) {\n\t\t\tlong u = (long)b;\n\t\t\tlong v = (long)b;\n\t\t\t\n\t\t\tif\
    \ (c < p) {\n\t\t\t\tb = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc *= 2;\n\t\t\t\t\
    b = (long)b;\n\t\t\t}\n\t\t\t\n\t\t\ta = a3 * u + v * c;\n\t\t\tn2 = tmp;\n\t\t\
    }\n\t\telse {\n\t\t\tlong v = (long)b3;\n\t\t\tlong u = (long)b3;\n\t\t\t\n\t\t\
    \tif (c < p2) {\n\t\t\t\tb3 = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc *= 2;\n\t\t\
    \t\tb1 = (long)b3;\n\t\t\t}\n\t\t\t\n\t\t\tb = b1 * u + v * c;\n\t\t\tn2 = q;\n\
    \t\t}\n\t}", "  long rem = n;\n  while (rem != 0) {\n    rem = (rem % p) + (rem\
    \ / p);\n  }\n  return rem;", '  return ((n & (p-1)) == 0) ? n+1 : modp(n >> 1,
    p);', "  assert(n > 0 && p > 0);\n  if (n == 0)\n    return 1;\n  long ret = n;\n\
    \  ret %= p;\n  assert(ret != 0 || p == 1);\n  if (ret != 0)\n    ret = (n - ret)\
    \ + p;\n  ret %= p;\n  return ret;", "    long r = 1;\n    while (p) {\n     \
    \   if (p & 1)\n            r = (r * n) % p;\n        n = ((n * n) + 1) %p;\n\
    \        p /= 2;\n    }\n    return r;", "    long res = 1;\n    while (p) {\n\
    \        if (p & 1) res *= n;\n        n >>= 1;\n        p >>= 1;\n    }\n   \
    \ return res;", "\tif (n % p == 0)\n\t\treturn n;\n\tlong r = n % p;\n\twhile\
    \ (n != 0) {\n\t\tif (n % p == 0)\n\t\t\treturn p * r + n;\n\t\tn /= p;\n\t\t\
    r *= p;\n\t}\n\treturn 0;", "    long q = 0;\n    long r = n % (p + q);\n    while\
    \ (r > p) {\n        q = q + 1;\n        r = r % p + q;\n    }\n    return q;",
  '    return (p == 1 || p == 2 || p == 3 || p == 4 || p == 5 || p == 6 || p == 7
    || p == 8) ? n : (n + modp(n / p, p)) * p;', "   long t = modpow(p, n);\n   if\
    \ (t == p)\n      return t;\n   long m = n - t;\n   n -= (m & -p);\n   long r\
    \ = modpow(p, m);\n   n = (n - t) * p + r;\n   return n;", "    long ans = 1;\n\
    \    while (p > 1)\n    {\n        if (n % p != 0)\n            ans *= p;\n  \
    \      n /= p;\n        p--;\n    }\n    return ans;", "  long res = 0;\n  while\
    \ (n) {\n    if (n%p == 0) res++;\n    n /= p;\n  }\n  return res;", '    return
    (n%p) + (n%(p*p))%p;', "    if (n < 0) \n        n += p;\n    long q = 0;\n  \
    \  long a = n;\n    long t = 1;\n    while (a != 0) {\n        a = a / 2;\n  \
    \      q += 1;\n        t = t * 2;\n    }\n    long t = modl(t, p);\n    t = modl(1,\
    \ p);\n    return q * t + n - t;", "    long ans = 1L;\n    for(; n > 0; n = n\
    \ / p)\n        ans = ans * p + n%p;\n    return ans;", "  assert(p != 0);\n \
    \ assert(n >= p);\n  long result = n;\n  for (int i = 1; i < p; ++i)\n    result\
    \ %= p;\n  return result;", "\tif (n == 0) return 1;\n\tlong r = modp(n >> 1,\
    \ p) % p;\n\treturn ((n % p) < r) ? r : n % p;", "  long ans = 0;\n  while (n)\
    \ {\n    ans += n % p;\n    n /= p;\n  }\n  return ans;", "    long result = 0;\n\
    \    for(long i=0; i<n; i++){\n        if(p%2 == 1)\n            result *= 2;\n\
    \        result *= p;\n        result %= p;\n    }\n    return result;", "  assert(n\
    \ > 0);\n  assert(p > 0);\n  assert(p < std::numeric_limits<long>::max() / 2);\n\
    \  long res = n & (p - 1);\n  n = n >> 1;\n  while (n > 0) {\n    if (n == 1)\n\
    \      res += p;\n    p += p;\n    n >>= 1;\n  }\n  return res;", "    long ret\
    \ = 0, shift = 0;\n    while(n > 0){\n        shift = n % p;\n        ret = ret\
    \ * 2 + shift;\n        n /= p;\n    }\n    return ret;", "    long result = 0;\n\
    \    while (n) {\n        int mod = n%p;\n        result += mod;\n        n /=\
    \ p;\n    }\n    return result + 1;", "    long q = 1;\n    long r = p % n;\n\
    \    while (p > r) {\n        q = q * 2 + n;\n        r = p % n;\n    }\n    return\
    \ q;", "  if (p < 0) {\n    n = -n;\n    p -= 1;\n  }\n  // return (n - 1) * (n\
    \ + p + 1) // see http://stackoverflow.com/a/14473057/106084\n  return (n * n\
    \ + p * p + 1) % (p + 1);", "  assert(n > p);\n  if (p % 2 == 0) {\n    return\
    \ n % p;\n  }\n  else {\n    return n - (n % p);\n  }", "  if (n == 0) return\
    \ 1;\n  if (p > 1) return modp(n, p-1);\n  long ans = 1;\n  while (p) {\n    if\
    \ (n % p) {\n      ans = (ans * p) % p;\n    }\n    p /= 2;\n  }\n  return ans;",
  "    if (n % p == 0) {\n        return n;\n    }\n    long r = n / p;\n    long\
    \ mod = r % p;\n    return r;", "  long ans = (n % p);\n  ans %= p;\n  return\
    \ ans;", "  assert(p >= 1 && p <= 10);\n  long ret = p + 1 - (n-1) * p;\n  assert(ret\
    \ >= 0 && ret < 10);\n  return ret;", "    long ret = 1;\n    long div = 0;\n\
    \    while (n >= p) {\n        div = div * p;\n        ret = ret + div;\n    \
    \    n -= p;\n    }\n    if (n > 0)\n        div = div * p;\n    return ret +\
    \ div;", "    long a = n % p;\n    long b = n / p;\n    long r = pow(a, b, p);\n\
    \    return r % p;", "\tif (n == 0 || p == 0) return n;\n\tn = n % p;\n\tif (n\
    \ < 0) n += p;\n\treturn n;", "    long result = 0;\n    for(; n >= 1; n--) result\
    \ = ((result << p) | result) % p;\n    return result;", "    if(p == 1)\n    \
    \    return n;\n    if(p == 0)\n        return 1;\n    long ans = 1;\n    for(long\
    \ dp = p; (dp * dp) % p != 0; dp /= 10)\n        ans *= 10;\n    if(n % p == 0)\n\
    \        ans %= p;\n    return ans;", "    long res = 1;\n    while (n) {\n  \
    \      if ((n % p) == 0) {\n            res = (res*2)%p;\n        }\n        n\
    \ = (n*2L)/p;\n    }\n    return res;", "  long mod;\n  if (n >= p) {\n    mod\
    \ = 1;\n    while (n >= p)\n      mod *= p;\n    mod %= p;\n  } else {\n    mod\
    \ = p;\n    while (n <= p)\n      mod %= p;\n  }\n  return mod;", "  long r =\
    \ 1;\n  long m = 0;\n  while (n) {\n    if (n&1)\n      r = (r << p) % p;\n  \
    \  m += p;\n    n >>= 1;\n  }\n  return (r + m) % p;", "\treturn n%p==0 ? n :\
    \ ((n%p)+p)%p;", "  long ret = 1;\n  for (long i = 1; i < p; i++) ret *= n;\n\
    \  return n % p + ret;", "  long ans = 1;\n  long tmp = 0;\n  while (n != 0) {\n\
    \    tmp += n % p;\n    ans = ans * tmp + n;\n    n /= p;\n  }\n  return ans;",
  '    return (n%p)*p+n%p;', "    if (n == 0)\n        return 0;\n    if (n == 1)\n\
    \        return p;\n    return n % p + ((n / p) % p);", "  assert(p%2==0);\n \
    \ if(n==0) return 1;\n  long res = 1;\n  for(long i=1;i<=n;i++) res=(res*p)%p;\n\
    \  return res;"]
stop_tokens:
- "\n}"
