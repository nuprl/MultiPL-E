name: HumanEval_158_find_max
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that accepts\
  \ a list of strings.\n// The list contains different words. Return the word with\
  \ maximum number\n// of unique characters. If multiple strings have maximum number\
  \ of unique\n// characters, return the one which comes first in lexicographical\
  \ order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"\
  name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"\
  ]) == \"\"aaaaaaa\"\nstd::string find_max(std::vector<std::string> words) {\n"
tests: "}\nint main() {\n    auto candidate = find_max;\n    assert(candidate((std::vector<std::string>({\"\
  name\", \"of\", \"string\"}))) == (\"string\"));\n    assert(candidate((std::vector<std::string>({\"\
  name\", \"enam\", \"game\"}))) == (\"enam\"));\n    assert(candidate((std::vector<std::string>({\"\
  aaaaaaa\", \"bb\", \"cc\"}))) == (\"aaaaaaa\"));\n    assert(candidate((std::vector<std::string>({\"\
  abc\", \"cba\"}))) == (\"abc\"));\n    assert(candidate((std::vector<std::string>({\"\
  play\", \"this\", \"game\", \"of\", \"footbott\"}))) == (\"footbott\"));\n    assert(candidate((std::vector<std::string>({\"\
  we\", \"are\", \"gonna\", \"rock\"}))) == (\"gonna\"));\n    assert(candidate((std::vector<std::string>({\"\
  we\", \"are\", \"a\", \"mad\", \"nation\"}))) == (\"nation\"));\n    assert(candidate((std::vector<std::string>({\"\
  this\", \"is\", \"a\", \"prrk\"}))) == (\"this\"));\n    assert(candidate((std::vector<std::string>({\"\
  b\"}))) == (\"b\"));\n    assert(candidate((std::vector<std::string>({\"play\",\
  \ \"play\", \"play\"}))) == (\"play\"));\n}\n"
completions: ["    std::sort(words.begin(), words.end(), std::greater<std::string>());\n\
    \    return words.back();", "  int n = words.size();\n  std::string maxWord =\
    \ \"\";\n  int maxCharCount = 0;\n  // count the characters\n  for (int i = 0;\
    \ i < n; ++i) {\n    size_t count = 0;\n    for (char &c : words[i]) {\n     \
    \ if (std::isalpha(c)) ++count;\n    }\n    maxCharCount = std::max(maxCharCount,\
    \ count);\n  }\n  // compare each word with each other word\n  for (int i = 1;\
    \ i < n; ++i) {\n    int commonCharCount = 0;\n    int commonWordIndex = 0;\n\
    \    std::string thisWord = words[i - 1];\n    for (int j = 0; j < i; ++j) {\n\
    \      int thisCharCount = 0;\n      std::string thisWord2 = words[j - 1];\n \
    \     for (int k = 0; k < n; ++k) {\n        char thisChar = words[k][j];\n  \
    \      if (thisChar == thisWord.at(k)) {\n          ++thisCharCount;\n       \
    \ }\n      }\n      if (thisCharCount > commonCharCount) {\n        commonCharCount\
    \ = thisCharCount;\n        commonWordIndex = j;\n      }\n    }\n    if (commonCharCount\
    \ == maxCharCount) {\n      maxCharCount = commonCharCount;\n      maxWord = thisWord;\n\
    \    }\n  }\n  return maxWord;", "    int m = std::numeric_limits<int>::min();\n\
    \    for (std::string & word : words) {\n        // If current word has same number\
    \ of unique characters as current maximum\n        // word then update maximum\n\
    \        if (std::count(word.begin(), word.end(), 0) == m) {\n            m =\
    \ std::count(word.begin(), word.end(), 0);\n            word = std::string(word.begin(),\
    \ word.end());\n        }\n    }\n    return word;", "    std::string word;\n\
    \    int count = 0;\n    for (auto it = words.begin(); it != words.end(); ++it)\n\
    \    {\n        std::sort(words.begin(), words.end());\n        int l = std::count_if(words.begin(),\
    \ words.end(),\n                              [&](const std::string& s) {\n  \
    \                                    return s.find(*it) != std::string::npos;\n\
    \                              });\n        if (l > count)\n        {\n      \
    \      word = *it;\n            count = l;\n        }\n    }\n    return word;",
  '    // code here', "  // your code goes here\n    std::string max;\n    int maxCount\
    \ = 0;\n    int curCount = 0;\n    for(auto &x: words)\n    {\n        for(auto\
    \ &y: words)\n        {\n            if (x == y)\n            {\n            \
    \    continue;\n            }\n            if (x.size() < y.size() )\n       \
    \     {\n                continue;\n            }\n            int cmp = std::stoi(x.c_str());\n\
    \            cmp = std::stoi(y.c_str());\n            if(cmp > 0)\n          \
    \  {\n                curCount++;\n            }\n            else\n         \
    \   {\n                curCount--;\n            }\n            if (curCount >\
    \ maxCount)\n            {\n                max = x;\n                maxCount\
    \ = curCount;\n            }\n        }\n    }\n    return max;", "    // Write\
    \ your code here\n    char buf[512] = {0};\n    std::string max;\n    int maxcount\
    \ = 0;\n    for(int i = 0; i < words.size(); i++){\n        for(int j = 0; j <\
    \ words[i].size(); j++){\n            for(int k = j + 1; k < words[i].size();\
    \ k++){\n                buf[512] = words[i][j];\n                buf[512] = words[i][k];\n\
    \                bool flag = true;\n                for(int l = 0; l < 512; l++){\n\
    \                    if(buf[l] == 0){\n                        break;\n      \
    \              }\n                    else{\n                        flag = false;\n\
    \                    }\n                }\n                if(flag){\n       \
    \             maxcount = max(maxcount, words[i].size() - 1);\n               \
    \     max = words[i].substr(0, j);\n                }\n            }\n       \
    \ }\n    }\n    return max;", "    std::string biggest_word = \"\";\n    int biggest_word_count\
    \ = 0;\n\n    for (int i = 0; i < words.size(); i++) {\n        int current_count\
    \ = words[i].size();\n        if (current_count > biggest_word_count) {\n    \
    \        biggest_word_count = current_count;\n            biggest_word = words[i];\n\
    \        }\n    }\n    return biggest_word;", "    // code here\n    std::string\
    \ result=\"\";\n    int max=0, count=0, size=0;\n    for(auto it=words.begin();\
    \ it!=words.end(); it++){\n        if(*it == result){\n            count++;\n\
    \        }\n        else {\n            count = 1;\n        }\n        if(count\
    \ > max){\n            max = count;\n        }\n        size += count;\n     \
    \   result = *it;\n    }\n    if(size > max){\n        return result;\n    }\n\
    \    else return \"\";", "    std::string result = \"\";\n    int counter = 0;\n\
    \    // sort words by number of unique characters\n    std::sort(words.begin(),\
    \ words.end(), std::greater<>());\n    // find out the maximum\n    for (auto\
    \ &word : words) {\n        counter += word.length();\n        // if counter >\
    \ length\n        if (counter > word.length()) {\n            result += word;\n\
    \        }\n    }\n    if (result == \"\")\n        return \"\";\n    if (result.length()\
    \ > words.size())\n        return words[0];\n    return result;", "    int res\
    \ = 0;\n    int max_len = 0, max_idx = 0;\n    for (const auto &word : words)\
    \ {\n        if (word.length() > max_len) {\n            max_len = word.length();\n\
    \            max_idx = res;\n        }\n        if (word.length() == max_len &&\
    \ std::count(word.begin(), word.end(), 'a') == 0) {\n            max_idx = res;\n\
    \        }\n        if (word.length() == max_len && std::count(word.begin(), word.end(),\
    \ 'e') == 0) {\n            max_idx = res;\n        }\n        if (word.length()\
    \ == max_len && std::count(word.begin(), word.end(), 'i') == 0) {\n          \
    \  max_idx = res;\n        }\n        if (word.length() == max_len && std::count(word.begin(),\
    \ word.end(), 'o') == 0) {\n            max_idx = res;\n        }\n        if\
    \ (word.length() == max_len && std::count(word.begin(), word.end(), 'u') == 0)\
    \ {\n            max_idx = res;\n        }\n        res = std::max(res, word.length());\n\
    \    }\n    return words[max_idx];", "    std::unordered_set<char> chars;\n  \
    \  std::string res;\n    for (auto &w : words) {\n        std::for_each(w.begin(),\
    \ w.end(), [&chars](char c) {\n            chars.insert(c);\n        });\n   \
    \     if (chars.size() > res.size()) {\n            res = w;\n        }\n    }\n\
    \    return res;", "    int n = words.size();\n    int max = 0;\n    std::string\
    \ word;\n    for (auto &w : words) {\n        int len = w.size();\n        int\
    \ count = 0;\n        for (int i = 0; i < len; i++) {\n            count += w[i];\n\
    \        }\n        if (count > max) {\n            word = w;\n            max\
    \ = count;\n        }\n    }\n    if (max == 0)\n        return \"\";\n    return\
    \ word;", "    std::map<unsigned int, std::string> hash;\n    for (std::string\
    \ word : words) {\n        hash.insert(std::pair<unsigned int, std::string>(word.length(),\
    \ word));\n    }\n    return hash[words.size() - 1]; // Return the string with\
    \ max length.", "  // Write your code here\n  std::string result = words[0];\n\
    \  for (size_t i = 1; i < words.size(); i++) {\n    if (words[i].size() > result.size())\
    \ {\n      result = words[i];\n    }\n  }\n  return result;", "    std::string\
    \ max_word = \"\";\n    std::string max_count = \"\";\n    int max_count = 0;\n\
    \    for (size_t i = 0; i < words.size(); i++) {\n        std::string temp_word\
    \ = words[i];\n        int temp_count = 0;\n        for (size_t j = 0; j < words.size();\
    \ j++) {\n            if (i != j) {\n                if (words[i].size() > words[j].size())\
    \ {\n                    temp_word = words[j];\n                }\n          \
    \  }\n        }\n        int count = 0; // count is used for counting unique characters\
    \ in temp_word\n        for (size_t j = 0; j < words.size(); j++) {\n        \
    \    if (words[j].size() == temp_word.size()) {\n                count++;\n  \
    \          }\n        }\n        if (count > max_count) {\n            max_count\
    \ = count;\n            max_word = temp_word;\n        }\n    }\n    return max_word;",
  "  // Write your code here\n  ", "    std::map<char,int> m;\n    for (std::string\
    \ word : words)\n    {\n        std::map<char,int>::iterator it = m.find(word[0]);\n\
    \        if (it == m.end())\n        {\n            it = m.insert(std::pair<char,int>(word[0],1)).first;\n\
    \        }\n        else\n        {\n            it->second++;\n        }\n  \
    \  }\n    std::string max = \"\";\n    for (std::map<char,int>::iterator it =\
    \ m.begin();\n         it != m.end(); ++it)\n    {\n        if (it->second > m.size()\
    \ && it->first != ' ')\n        {\n            max = it->first;\n            break;\n\
    \        }\n    }\n    return max;", "    if (words.empty()) {\n        return\
    \ \"\";\n    }\n    int n = words.size();\n    int m = n;\n    int cnt = 1;\n\
    \    std::string str = \"\";\n    for (int i = 1; i < n; ++i) {\n        if (words[i]\
    \ < words[i - 1]) {\n            ++m;\n        }\n    }\n    for (int i = 0; i\
    \ < n; ++i) {\n        str += words[i];\n        for (int j = i + 1; j < n; ++j)\
    \ {\n            if (words[j] < words[i]) {\n                std::swap(words[i],\
    \ words[j]);\n                ++cnt;\n            }\n        }\n        if (cnt\
    \ > m) {\n            m = cnt;\n            str = words[i];\n        }\n    }\n\
    \    return str;", "    std::map<char, int> max_map;\n    for (auto &str : words)\
    \ {\n        auto it = max_map.find(str[0]);\n        if (it == max_map.end())\
    \ {\n            max_map.insert(std::pair<char, int>(str[0], 1));\n        } else\
    \ {\n            it->second++;\n        }\n    }\n    for (auto &it : max_map)\
    \ {\n        if (it.second > 1) {\n            return it.first;\n        }\n \
    \   }\n    return \"\";", "    // your code goes here\n    int n = words.size();\n\
    \    int max = -1;\n    std::string res;\n    for (int i = 0; i < n; i++) {\n\
    \        int len = 0;\n        for (int j = 0; j < i; j++) {\n            len\
    \ += words[j].size();\n        }\n        if (len > max) {\n            max =\
    \ len;\n            res = words[i];\n        }\n    }\n    return res;", "   \
    \ // Write your code here\n    std::string max = \"\";\n    int count = 0;\n \
    \   for (size_t i = 0; i < words.size(); i++)\n    {\n        count += words[i].size();\n\
    \        if(count > words[i].size())\n        {\n            max = words[i];\n\
    \            count = words[i].size();\n        }\n    }\n    return max;", " \
    \   std::string max;\n    int cnt = 0;\n    for (auto &x : words) {\n        cnt\
    \ += x.size();\n        if (cnt > max.size()) {\n            max = x;\n      \
    \  }\n    }\n    return max;", "    // your code here\n    std::string max = \"\
    \";\n    for (auto it=words.begin(); it!=words.end(); ++it) {\n        int uc\
    \ = std::count_if(std::begin(*it), std::end(*it), [] (const std::string &x) {return\
    \ x.size() != x.find_first_not_of(' ');});\n        if (uc > max.size()) {\n \
    \           max = *it;\n        }\n    }\n    return max;", "    std::string result\
    \ = \"\";\n    int max_size = 0;\n    for(std::string word : words) {\n      \
    \  max_size = getMaxSize(word, max_size);\n        if(max_size > result.length())\
    \ {\n            result = word;\n        }\n    }\n    return result;", "  std::map<char,int>\
    \ map;\n  for (std::string &s: words) {\n    for (char &c: s) {\n      map[c]++;\n\
    \    }\n  }\n  for (char &c: map) {\n    int count = map.at(c);\n    if (count\
    \ > 1) {\n      return words[std::distance(words.begin(),\n                  \
    \              std::max_element(words.begin(), words.end()\n                 \
    \                                  ,\n                                       \
    \            [&](std::string &x, std::string &y){\n                          \
    \                            if (x.size() > y.size()) {\n                    \
    \                                    return true;\n                          \
    \                            } else {\n                                      \
    \                  return false;\n                                           \
    \           }\n                                                  }\n         \
    \                                         )\n                                \
    \     )];\n    }\n  }\n  return \"\";", "    std::string ans = \"\";\n    int\
    \ max_len = -1;\n    for (auto& word : words) {\n        int len = word.length();\n\
    \        if (max_len < len) {\n            max_len = len;\n            ans = word;\n\
    \        }\n    }\n    return ans;", "    // Your code goes here\n    std::string\
    \ maxWord = \"\";\n    int maxNum = 0;\n    \n    for (auto word : words){\n \
    \       int currentNum = 0;\n        for (auto c : word){\n            if (std::count(word.begin(),\
    \ word.end(), c) != 0)\n                currentNum++;\n        }\n        if (currentNum\
    \ > maxNum){\n            maxNum = currentNum;\n            maxWord = word;\n\
    \        }\n    }\n    return maxWord;", "  int count = 0, max = 0;\n  for (std::string\
    \ word : words) {\n    for (size_t i = 0; i < word.length(); i++) {\n      count[word[i]]++;\n\
    \      if (count[word[i]] > max) {\n        max = count[word[i]];\n      }\n \
    \   }\n  }\n  if (count == 0 && words.size() == 0) {\n    return \"\";\n  }\n\
    \  if (max == 0) {\n    return words[0];\n  }\n  for (size_t i = 0; i < words.size();\
    \ i++) {\n    if (count[words[i]] > max) {\n      return words[i];\n    }\n  }",
  "    // Write your code here\n    int unique_char = 0;\n    int index = 0;\n   \
    \ for (auto word : words) {\n        for (int i = 0; i < word.length(); ++i) {\n\
    \            if (unique_char < word[i])\n                unique_char = word[i];\n\
    \        }\n    }\n    index = words.size() - 1;\n    while (index >= 0) {\n \
    \       if (words[index].length() == unique_char)\n            return words[index];\n\
    \        index--;\n    }\n    return \"\";", "    std::sort(words.begin(), words.end());\n\
    \    std::map<char, size_t> m;\n    for (auto &w : words) {\n        for (auto\
    \ &c : w) {\n            auto it = m.find(c);\n            if (it != m.end())\n\
    \                it->second += 1;\n            else\n                m.insert(std::pair<char,\
    \ size_t>(c, 1));\n        }\n    }\n\n    std::string res = words[0];\n    for\
    \ (auto &w : words) {\n        auto it = m.find(w[0]);\n        if (it == m.end())\
    \ {\n            return res;\n        } else if (it->second > res.size())\n  \
    \          res = w;\n    }\n    return res;", "    std::sort(words.begin(), words.end(),\
    \ [](const std::string& a, const std::string& b) -> bool\n    {\n        return\
    \ a.length() < b.length();\n    });\n\n    std::string longest = words[0];\n\n\
    \    int max_chars = longest.length();\n\n    for (size_t i = 1; i < words.size();\
    \ i++)\n    {\n        if (max_chars < words[i].length())\n        {\n       \
    \     longest = words[i];\n            max_chars = longest.length();\n       \
    \ }\n    }\n\n    return longest;", "    std::set<std::string> uniqueCharacters;\n\
    \    std::string maxWord = \"\";\n    for (std::string word : words) {\n     \
    \   std::unordered_map<char, int> uniqueCharactersMap;\n        for (char character\
    \ : word) {\n            uniqueCharactersMap[character]++;\n        }\n      \
    \  std::string maxCharacter = \"\";\n        int maxCharacterCount = 0;\n    \
    \    for (char character : word) {\n            if (uniqueCharactersMap.find(character)\
    \ == uniqueCharactersMap.end()) {\n                maxCharacter = character;\n\
    \                maxCharacterCount = 0;\n            }\n            else {\n \
    \               if (uniqueCharactersMap[character] > maxCharacterCount) {\n  \
    \                  maxCharacter = character;\n                    maxCharacterCount\
    \ = uniqueCharactersMap[character];\n                }\n            }\n      \
    \  }\n        if (maxCharacter.length() > maxWord.length()) {\n            maxWord\
    \ = word;\n        }\n        uniqueCharacters.insert(maxCharacter);\n    }\n\
    \    return maxWord;", "  std::map<std::string, int> map;\n  int max = 0;\n  for\
    \ (auto &word : words) {\n    auto itr = map.find(word);\n    if (itr != map.end())\
    \ {\n      max = std::max(max, itr->second);\n    } else {\n      map.insert({word,\
    \ 1});\n    }\n  }\n  for (auto itr = map.begin(); itr != map.end(); itr++) {\n\
    \    if (itr->second == max) {\n      return itr->first;\n    }\n  }\n  return\
    \ \"\";", "  // your code goes here\n  assert(words.size() > 0);\n  std::map<char,\
    \ int> m;\n  for (const auto& word : words) {\n    size_t count = 0;\n    for\
    \ (char c : word) {\n      count += m[c];\n      m[c] = count;\n    }\n  }\n \
    \ auto it=m.begin();\n  std::string maxWord=\"\";\n  if (it != m.end() && it->second==words.size())\
    \ maxWord=it->first;\n  else maxWord=\"\";\n  for (const auto& word : words) {\n\
    \    size_t count = 0;\n    for (char c : word) {\n      count += m[c];\n    \
    \  m[c] = count;\n    }\n    if (count > maxWord.size()) maxWord=word;\n  }\n\
    \  return maxWord;", "  int max_count = words.front().size();\n  for (size_t i\
    \ = 0; i < words.size(); i++) {\n    size_t current_count = words[i].size();\n\
    \    if (current_count > max_count) {\n      max_count = current_count;\n    }\n\
    \  }\n\n  std::string result = words[0];\n  for (size_t i = 1; i < words.size();\
    \ i++) {\n    if (words[i].size() == max_count) {\n      result += words[i];\n\
    \    }\n  }\n\n  return result;", "    int numOfUniqueCharacters = 0;\n    std::string\
    \ maxWord = \"\";\n    // Write your code here\n    return 0;", "    // write\
    \ your code here\n    std::string word = \"\";\n    int max_count = -1;\n    for\
    \ (auto w : words) {\n        int count = 0;\n        for (auto c : w) {\n   \
    \         count += 1;\n            if (count > max_count) {\n                word\
    \ = w;\n                max_count = count;\n            }\n        }\n    }\n\
    \    if (max_count == 0)\n        return \"\";\n    return word;", "    std::string\
    \ result = \"\";\n    int max = 0;\n    for(auto word: words) {\n        auto\
    \ temp = std::count(word.begin(), word.end(), 'a');\n        max = temp > max\
    \ ? temp : max;\n        temp = std::count(word.begin(), word.end(), 'b');\n \
    \       max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'c');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'd');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'e');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'f');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'g');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'h');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'i');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'j');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'k');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'l');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'm');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'n');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'o');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'p');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'q');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'r');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 's');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 't');\n        max = temp > max ? temp : max;\n        temp = std::count(word.begin(),\
    \ word.end(), 'u');\n        max = ", "    // Write your code here\n    std::string\
    \ result = \"\";\n    std::map<char, int> charCount;\n    for (int i = 0; i <\
    \ words.size(); i++) {\n        for (int j = 0; j < words[i].length(); j++) {\n\
    \            char ch = words[i][j];\n            if (charCount.find(ch) == charCount.end())\
    \ {\n                charCount[ch] = 1;\n            }\n            else {\n \
    \               charCount[ch] += 1;\n            }\n        }\n    }\n    bool\
    \ found = false;\n    for (int i = 0; i < charCount.size(); i++) {\n        if\
    \ (charCount[i] > 1 && charCount[i] > charCount.at(result)) {\n            result\
    \ = i;\n            found = true;\n        }\n    }\n    if (!found) {\n     \
    \   result = 0;\n    }\n    return result;", "    std::string maxWord = \"\";\n\
    \    int maxChars = 0;\n    std::string word = \"\";\n    for (auto word : words)\
    \ {\n        int charCount = word.size();\n        if (charCount > maxChars) {\n\
    \            maxChars = charCount;\n            maxWord = word;\n        }\n \
    \   }\n    return maxWord;", "    std::map<char, int> m;\n    std::string max;\n\
    \    for (std::string word : words) {\n        for (char ch : word) {\n      \
    \      if (m.count(ch) == 0) {\n                m[ch] = 1;\n                max\
    \ = ch;\n            } else if (m[ch] > 1) {\n                max = ch;\n    \
    \        }\n        }\n    }\n    return max;", "    std::map<std::string, int>\
    \ m;\n    for (auto& w: words)\n        m[w]++;\n    if (m.size() == 1)\n    \
    \    return m.begin()->first;\n    for (auto& w: words) {\n        auto it = m[w];\n\
    \        for (auto j = it + 1; j < m.size(); j++)\n            m[w] = j;\n   \
    \ }\n    return m.begin()->first;", "  // code here\n  // your code goes here\n\
    \  std::sort(words.begin(), words.end());\n  int max_len = 0, cur = 0;\n  for\
    \ (const auto& word : words) {\n    auto len = word.size();\n    if (len > max_len)\
    \ {\n      max_len = len;\n      cur = len;\n    }\n  }\n  if (max_len == 0)\n\
    \    return \"\";\n  if (max_len > 0)\n    return words[cur];\n  else\n    return\
    \ \"\";", "    int m = 0, max_count = 1;\n    for (int i = 0; i < words.size();\
    \ i++) {\n        for (int j = 0; j < words[i].size(); j++) {\n            int\
    \ count = words[i][j].length();\n            if (count > max_count) {\n      \
    \          max_count = count;\n                m = i;\n            }\n       \
    \ }\n    }\n    if (m == 0) return \"\";\n    return words[m];", "    // write\
    \ your code here\n    std::string max_word = \"\";\n    int max_count = 0;\n \
    \   for (auto word: words) {\n        int cur_count = 0;\n        for (auto c\
    \ : word) {\n            if (std::count(word.begin(), word.end(), c) < cur_count)\
    \ {\n                max_word = word;\n                cur_count = std::count(word.begin(),\
    \ word.end(), c);\n            }\n        }\n        if (cur_count > max_count)\
    \ {\n            max_word = word;\n            max_count = cur_count;\n      \
    \  }\n    }\n    return max_word;", "    std::vector<std::string> temp;\n    int\
    \ max_count = 0;\n    std::string max_word = \"\";\n    for (std::string word\
    \ : words) {\n        int count = 0;\n        for (char ch : word) {\n       \
    \     count += 1;\n        }\n        if (count > max_count) {\n            max_count\
    \ = count;\n            max_word = word;\n        }\n        temp.push_back(word);\n\
    \    }\n    int count = 0;\n    for (std::string word : temp) {\n        for (char\
    \ ch : word) {\n            count += 1;\n        }\n        if (count > max_count)\
    \ {\n            max_count = count;\n            max_word = word;\n        }\n\
    \    }\n    return max_word;", "    std::vector<std::string> unique_words(words.size());\n\
    \    for (int i = 0; i < words.size(); i++)\n        std::sort(words[i].begin(),\
    \ words[i].end());\n    for (int i = 0; i < words.size(); i++)\n        for (int\
    \ j = i + 1; j < words.size(); j++)\n            if (words[i].size() == words[j].size())\
    \ {\n                for (int k = 0; k < words[i].size(); k++)\n             \
    \       if (words[i].at(k) == words[j].at(k)) {\n                        unique_words[k]\
    \ = words[j];\n                        words[j] = words[i];\n                \
    \        words[i] = \"\";\n                    }\n                if (words[i].size()\
    \ == unique_words[i].size())\n                    return unique_words[i];\n  \
    \          }\n    return \"\";", "    // code here\n    std::string result = \"\
    \";\n    int max_char = 0;\n    for (auto i : words) {\n        if (i.size() >\
    \ max_char) {\n            result = i;\n            max_char = i.size();\n   \
    \     }\n    }\n    return result;", "    auto maxCount = std::make_pair(std::numeric_limits<int>::max(),\
    \ \"\");\n    for (const auto& word : words) {\n        int count = std::count_if(word.begin(),\
    \ word.end(), [](char ch) {\n            return std::isalpha(ch);\n        });\n\
    \        if (maxCount.first < count) {\n            maxCount = std::make_pair(count,\
    \ word);\n        }\n    }\n    return maxCount.second;", "    std::string ans\
    \ = \"\";\n    char u = 0;\n    int l = 0;\n    bool ans_in_order = true;\n  \
    \  for (auto i : words)\n    {\n        std::string wr = i;\n        std::map<char,\
    \ int> m; //map\n        for (auto j : wr)\n        {\n            m[j]=m.size();\
    \ // initialize count\n        }\n        for (auto j : wr)\n        {\n     \
    \       ++m[std::tolower(j)]; // increment number of occurence\n        }\n  \
    \      for (auto j : wr)\n        {\n            int cnt = m[std::tolower(j)];\n\
    \            int cur = u;\n            if (cnt > l)\n            {\n         \
    \       ans_in_order = true;\n                l = cnt;\n                ans =\
    \ wr;\n            }\n            else if (cnt == l)\n            {\n        \
    \        ans_in_order = false;\n                ans = wr;\n            }\n   \
    \         else if (cnt < l && cur < j)\n            {\n                ans_in_order\
    \ = false;\n                ans = wr;\n            }\n            else\n     \
    \       {\n                ans_in_order = false;\n            }\n            u\
    \ = cur;\n        }\n    }\n    return ans_in_order ? ans : \"No such string\"\
    ;", "  // code here\n  if(words.size() == 0) return \"\";\n  std::map<int, std::string>\
    \ count;\n  std::string word;\n  for(auto i = words.begin(); i != words.end();\
    \ ++i){\n    int n = 1;\n    for(auto j = i; j != words.end(); ++j){\n      if(count[*j]\
    \ == 0){\n        count[*j] = *j;\n        break;\n      }\n      ++n;\n    }\n\
    \    word = (n == 1) ? i->second : count[*i];\n    if(count.size() > words.size()){\n\
    \      std::map<int, std::string>::iterator mi = count.begin();\n      while(words.size()\
    \ > words.size()){\n        mi++;\n        if(mi == count.end()) break;\n    \
    \  }\n      word = mi->second;\n    }\n  }\n  return word;", "    std::string\
    \ word;\n    long long int num_unique = 0;\n    for (size_t i = 0; i < words.size();\
    \ ++i) {\n        word.clear();\n        for (size_t j = 0; j < words[i].size();\
    \ ++j) {\n            if (word.find(words[i][j]) == std::string::npos) {\n   \
    \             word += words[i][j];\n                ++num_unique;\n          \
    \  }\n        }\n        if (num_unique > words.size() - 1) {\n            word\
    \ = words[i];\n        }\n    }\n    return word;", "    std::string maxword;\n\
    \    size_t maxlength = 0;\n    for (auto it = words.begin(); it != words.end();\
    \ ++it) {\n        size_t count = std::count_if(it->begin(), it->end(),\n    \
    \        [&](char c) { return std::isalpha(c); });\n        if (count > maxlength)\
    \ {\n            maxlength = count;\n            maxword = *it;\n        }\n \
    \   }\n    return maxword;", "    std::string res = \"\";\n    int max = 0;\n\
    \    for (auto &w : words) {\n        auto count = std::count_if(w.begin(), w.end(),\
    \ [](char c) {return !isalpha(c);});\n        if (count > max) {\n           \
    \ max = count;\n            res = w;\n        }\n    }\n    return res;", "  \
    \  // code here\n    std::vector<std::string> temp(words.size());\n    for(int\
    \ i=0;i<words.size();i++){\n        temp[i]=words[i];\n    }\n    std::string\
    \ word=temp[0];\n    for(int i=0;i<temp.size();i++){\n        for(int j=i+1;j<temp.size();j++){\n\
    \            if(temp[j].size()>temp[i].size()){\n                temp[i]=temp[j];\n\
    \            }\n        }\n    }\n    for(int i=0;i<temp.size();i++){\n      \
    \  if(temp[i].size()==word.size()){\n            word=temp[i];\n        }\n  \
    \  }\n    return word;", "    std::sort(words.begin(), words.end(), \n       \
    \ [](std::string x, std::string y){\n            return x.size() <= y.size();\n\
    \        });\n    auto res = \"\";\n    std::string curr = \"\";\n    for (auto&\
    \ word:words){\n        curr = word;\n        if(curr[0] == word[0] && curr[curr.size()-1]\
    \ == word[word.size()-1]){\n            curr = curr.substr(1, curr.size()-2);\n\
    \        }\n        \n        if(!res.empty()){\n            if(res.back() ==\
    \ curr){\n                curr = \"\";\n            }\n        }\n        res\
    \ += curr;\n    }\n    if(res.empty()){\n        return \"\";\n    }\n    return\
    \ res;", "    int n = words.size();\n    std::string temp;\n    int ucount = 0;\n\
    \    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++) {\n    \
    \        if (i != j) {\n                if (words[i].size() > words[j].size())\
    \ {\n                    temp = words[i];\n                    words[i] = words[j];\n\
    \                    words[j] = temp;\n                }\n                int\
    \ char_count = 0;\n                for (int k = 0; k < words[i].size(); k++) {\n\
    \                    char c = words[i][k];\n                    char_count = char_count\
    \ + std::count(words[j].begin() + k, words[j].end(), c);\n                }\n\
    \                if (char_count > ucount) {\n                    ucount = char_count;\n\
    \                    temp = words[i];\n                }\n            }\n    \
    \    }\n    return temp;", "  std::set<std::string> unique_chars;\n  for (const\
    \ auto& word : words) {\n    for (auto c : word) {\n      if (!unique_chars.count(c))\
    \ {\n        unique_chars.insert(c);\n      }\n    }\n  }\n  auto max_count =\
    \ std::max_element(unique_chars.begin(), unique_chars.end()) -\n             \
    \       unique_chars.begin();\n  return *std::max_element(unique_chars.begin(),\
    \ unique_chars.end()) -\n         unique_chars.begin() == max_count ? \"\" : words[unique_chars.rbegin()->size()\
    \ + 1];", "    std::string max_word = \"\";\n    // Write your code here.\n  \
    \  std::vector<std::vector<std::string> > freq;\n    for (std::vector<std::string>\
    \ word: words)\n    {\n        std::string curr_word = word[0];\n        for (auto\
    \ i: word)\n        {\n            freq.emplace_back(std::make_pair(curr_word,\
    \ i));\n            curr_word = i;\n        }\n    }\n    std::sort(freq.begin(),\
    \ freq.end());\n    if (freq.size() > 0) {\n        for (auto i: freq) {\n   \
    \         if (std::count(i.second.begin(), i.second.end()) <= 1) {\n         \
    \       max_word = i.first;\n            }\n        }\n    }\n    return max_word;",
  "    // Write your code here.\n    char temp[256];\n    int largest = 0;\n    int\
    \ current = 0;\n    int count = 0;\n    std::string word = \"\";\n    for (size_t\
    \ i = 0; i < words.size(); ++i) {\n        if (words[i][0] != '\\0') {\n     \
    \       std::strcpy(temp, words[i].c_str());\n            std::sort(temp);\n \
    \           if (std::strlen(temp) > largest) {\n                largest = std::strlen(temp);\n\
    \                word = words[i];\n            }\n            current = std::count(temp,\
    \ temp + largest, words[i][0]);\n            if (current > largest) {\n      \
    \          largest = current;\n                word = words[i];\n            }\n\
    \            count += largest;\n        }\n    }\n    return word;", '  // Your
    code goes here.', "\tstd::string word;\n\tint num = 0;\n\tint max = -1;\n\tfor\
    \ (auto x : words) {\n\t\tfor (auto &y : x) {\n\t\t\tif (y == word[0]) {\n\t\t\
    \t\tnum++;\n\t\t\t\tif (num > max) {\n\t\t\t\t\tmax = num;\n\t\t\t\t\tword = x;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (max != -1) {\n\t\tstd::cout << word[0] <<\
    \ \"\\n\";\n\t} else {\n\t\treturn \"\";\n\t}\n\treturn word;", "    std::string\
    \ word_max;\n    size_t max_count = 0;\n    for (auto &x : words)\n        if\
    \ (std::count(x.begin(), x.end(), x) > max_count)\n            word_max = x;\n\
    \        max_count = std::count(x.begin(), x.end(), x);\n    return word_max;",
  "  // Write your code here\n  int i, j, maxCount = 0;\n  std::string maxWord;\n\
    \  std::string word;\n  for (i = 0; i < words.size() - 1; i++) {\n    for (j =\
    \ i + 1; j < words.size(); j++) {\n      if (words[i].size() > words[j].size())\
    \ {\n        word = words[i];\n      } else {\n        word = words[j];\n    \
    \  }\n      int count = 0;\n      for (char ch : word) {\n        count++;\n \
    \       if (count > maxCount) {\n          maxCount = count;\n          maxWord\
    \ = word;\n        }\n      }\n    }\n  }\n  return maxWord;", "  std::string\
    \ max = \"\";\n  int char_count = 0, prev_char_count = 0, i = 0;\n  for (auto\
    \ x : words) {\n    char_count += x.size();\n    if (char_count > prev_char_count)\
    \ {\n      max = x;\n    }\n  }\n  return max;", '    // Write your code here',
  "  std::set<std::string> s;\n  for (const auto &w : words) {\n    s.insert(w);\n\
    \  }\n  for (const auto &w : s) {\n    if (s.size() == w.size()) {\n      return\
    \ w;\n    }\n  }\n  return \"\";", "    // Your code goes here\n    std::map<string,\
    \ size_t> mp;\n    for (auto& word : words) {\n        for (char ch: word) {\n\
    \            ++mp[ch];\n        }\n    }\n    auto maxcount = mp;\n    auto it\
    \ = maxcount.begin();\n    while (it != maxcount.end()) {\n        if (it->second\
    \ == 1)\n            return it->first;\n        ++it;\n    }\n    return \"\";",
  "  int maxcount = 1;\n  for (const auto& word : words) {\n    int charcount = 1;\n\
    \    for (char c : word) {\n      charcount += 1;\n    }\n    if (charcount >\
    \ maxcount) {\n      maxcount = charcount;\n    }\n  }\n  // Return \"\" if all\
    \ words have same max count of characters\n  if (maxcount == 1) {\n    return\
    \ \"\";\n  }\n  for (const auto& word : words) {\n    if (word[0] == words[words.size()-1][0])\
    \ {\n      return word;\n    }\n  }\n  return \"\";", "    std::string max_word\
    \ = words[0];\n    int max_word_length = words[0].size();\n    int n_unique =\
    \ 0;\n    for (size_t i = 1; i < words.size(); ++i) {\n        int unique = 0;\n\
    \        for (int j = 0; j < words[i].size(); ++j) {\n            if (words[i][j]\
    \ == max_word[j]) {\n                ++unique;\n            }\n        }\n   \
    \     if (unique > n_unique) {\n            max_word = words[i];\n           \
    \ max_word_length = words[i].size();\n            n_unique = unique;\n       \
    \ }\n    }\n    return max_word;", "    std::map<char, int> u;\n    for (std::string\
    \ &word : words) {\n        for (char c : word) {\n            u[c] += 1;\n  \
    \      }\n    }\n    std::string max_word = u.begin()->first;\n    int max_count\
    \ = u.begin()->second;\n    for (auto iter = u.begin(); iter != u.end(); ++iter)\
    \ {\n        if (iter->second > max_count) {\n            max_word = iter->first;\n\
    \            max_count = iter->second;\n        }\n    }\n    return max_word;",
  "    std::string result = \"\";\n    std::string max = words[0];\n    for (size_t\
    \ i = 1; i < words.size(); i++) {\n        int count = 0;\n        for (size_t\
    \ j = 0; j < words[i].length(); j++) {\n            if (words[i][j] == max[j])\
    \ {\n                count++;\n            }\n        }\n        if (count > words[i].length())\
    \ {\n            result = words[i];\n            max = words[i];\n        }\n\
    \    }\n    return result;", "  int max = 0;\n  std::string maxWord = \"\";\n\
    \  for (auto word : words) {\n    auto s = word.size();\n    if (max < s) {\n\
    \      max = s;\n      maxWord = word;\n    }\n  }\n  return maxWord;", "    std::map<char,\
    \ int> m;\n    for (auto &w : words) {\n        for (auto &c : w) {\n        \
    \    m[c] = m[c] + 1;\n        }\n    }\n    for (auto &p : m) {\n        if (p.second\
    \ > words.size())\n            return p.first;\n    }\n    return \"\";", "  \
    \  if (words.empty())\n        return \"\";\n    int max = 0;\n    for (auto &word\
    \ : words)\n        max = std::max(max, word.size());\n\n    std::vector<std::string>\
    \ wordVec;\n    for (auto &word : words)\n        wordVec.push_back(word);\n\n\
    \    std::vector<std::string> sortedWordVec;\n    std::sort(wordVec.begin(), wordVec.end(),\
    \ [&](const std::string &x, const std::string &y) {\n        return x.size() >\
    \ y.size();\n    });\n    for (auto &word : wordVec)\n        sortedWordVec.push_back(word);\n\
    \n    std::string result = \"\";\n    for (auto &word : sortedWordVec)\n     \
    \   result += word.substr(0, max);\n    return result;", "    std::string ans\
    \ = \"\";\n    size_t maxCount = 0;\n    for (auto & word : words) {\n       \
    \ size_t count = word.find_first_not_of(\" \");\n        ans = word.substr(count);\n\
    \        if (count > maxCount) {\n            maxCount = count;\n        }\n \
    \   }\n    return ans;", "    // Code here\n    int maximum = words.front().length();\n\
    \    for (auto & x: words) {\n        int counter = 0;\n        for (auto y: x)\n\
    \            counter += (int)y.length();\n        if (counter > maximum)\n   \
    \         maximum = counter;\n    }\n    int pos = 0;\n    for (auto & x: words)\n\
    \        if (maximum == x.length())\n            return x[pos++];\n    return\
    \ \"\";", "    std::set<std::string> s;\n    std::string result=\"Nothing\";\n\
    \    for (auto itr=words.begin(); itr!=words.end(); ++itr) {\n      s.insert(*itr);\n\
    \    }\n    if (s.size() > 1) {\n      result = *std::max_element(s.begin(), s.end());\
    \ \n    }\n    return result;", "  // Write your code here.\n  struct Counter\
    \ {\n    int count;\n    Counter(int c) : count(c) {}\n  };\n\n  struct CounterComparator\
    \ {\n    bool operator()(const std::pair<std::string, Counter>& a,\n         \
    \           const std::pair<std::string, Counter>& b) {\n      return a.second.count\
    \ > b.second.count;\n    }\n  };\n\n  Counter counter(words.size());\n  std::unordered_map<std::string,\
    \ Counter> counterMap;\n\n  for (size_t i = 0; i < words.size(); i++) {\n    std::pair<std::string,\
    \ Counter> p(words[i], counter);\n    std::unordered_map<std::string, Counter>::iterator\
    \ it = counterMap.find(p.first);\n    if (it == counterMap.end()) {\n      counterMap[p.first]\
    \ = p;\n    } else {\n      counterMap[p.first].second = counterMap[p.first].second\
    \ + 1;\n    }\n  }\n  std::unordered_map<std::string, Counter>::iterator max =\
    \ std::max_element(\n      counterMap.begin(), counterMap.end(), CounterComparator());\n\
    \  return max.first;", "    std::map<string, int> word_counter;\n\n    for (auto\
    \ const &word : words)\n        for (auto i : word)\n            if (word_counter.find(i)\
    \ == word_counter.end())\n                word_counter[i] += 1;\n\n    for (auto\
    \ const &word : word_counter) {\n        if (word.second > 1)\n            return\
    \ word.first;\n    }\n\n    return \"\";", "    std::string max_word = \"\";\n\
    \    int max_count = 0;\n    for (auto &w : words) {\n        int count_letter\
    \ = 0;\n        for (int i = 0; i < w.length(); i++) {\n            if (std::count(w.begin()\
    \ + i, w.end(), i)) {\n                count_letter += 1;\n            }\n   \
    \     }\n        if (count_letter > max_count) {\n            max_count = count_letter;\n\
    \            max_word = w;\n        }\n    }\n    return max_word;", "    // write\
    \ your code here\n    return 0;", "    auto max = words[0];\n    for (auto &item\
    \ : words)\n        if (std::count(item.begin(), item.end(), max) == std::count(item.begin(),\
    \ item.end(), max))\n            max = item;\n    return max;", "  std::string\
    \ word = \"\";\n  int max = 0;\n  for (int i = 0; i < words.size(); i++) {\n \
    \   if (words.size() <= max) {\n      word = words[i];\n      max = i;\n    }\n\
    \    for (int j = i + 1; j < words.size(); j++) {\n      if (words[i].size() +\
    \ words[j].size() >= max) {\n        string temp = words[i];\n        words[i]\
    \ = words[j];\n        words[j] = temp;\n      }\n    }\n  }\n  return word;",
  "    std::string result;\n    int max_count = 0;\n    int max_count2 = 0;\n    int\
    \ max_index = -1;\n    for(size_t i=0;i<words.size();i++){\n        int count\
    \ = 0;\n        for(size_t j=0;j<words[i].length();j++){\n            count++;\n\
    \        }\n        if(count > max_count){\n            max_count = count;\n \
    \           max_index = i;\n        }\n        count = 0;\n        for(size_t\
    \ j=0;j<words[i].length();j++){\n            count++;\n        }\n        if(count\
    \ > max_count2){\n            max_count2 = count;\n            max_index2 = i;\n\
    \        }\n    }\n    result = words[max_index];\n    return result;", "    std::string\
    \ max = \"\";\n    int max_count = 1;\n    for (std::string &w : words)\n    {\n\
    \        int count = std::count_if(w.begin(), w.end(), [&](char c) {\n       \
    \     int i = std::count(w.begin(), w.end(), c);\n            return i == 0;\n\
    \        });\n        if (count > max_count) {\n            max = w;\n       \
    \     max_count = count;\n        }\n    }\n    return max;", "    std::sort(words.begin(),\
    \ words.end(), [](std::string a, std::string b) -> bool {\n        return std::count_if(a.begin(),\
    \ a.end(), [](char x) {\n            return x == b;\n        }) > std::count_if(b.begin(),\
    \ b.end(), [](char x) {\n            return x == a;\n        });\n    });\n  \
    \  std::string ans = words[0];\n    for (size_t i = 1; i < words.size(); ++i)\
    \ {\n        ans = std::string(ans.rbegin(), ans.rend()) + words[i];\n    }\n\
    \    return ans;", "    int n = words.size();\n    int max = 0;\n    int max_index\
    \ = -1;\n    int index = 0;\n    std::string current = words[0];\n\n    for (auto\
    \ i : words) {\n        if (current.size() > max) {\n            max = current.size();\n\
    \            max_index = index;\n        }\n        if (i == current) {\n    \
    \        ++index;\n        }\n    }\n    return words[max_index];", "  std::map<char,\
    \ int> counter;\n  for (const auto& word : words) {\n    for (const auto& c :\
    \ word) {\n      counter[c] += 1;\n    }\n  }\n  for (const auto& item : counter)\
    \ {\n    if (item.second > 0) return item.first;\n  }\n  return \"\";", "    int\
    \ maximum = 0, index = 0;\n    for (int i = 0; i < words.size(); i++) {\n    \
    \    int counts[26] = {0};\n        for (int j = 0; j < words[i].size(); j++)\
    \ {\n            counts[words[i][j] - 'a']++;\n        }\n        maximum = counts[maximum];\n\
    \        index = i;\n    }\n    return words[index];", "    std::sort(words.begin(),\
    \ words.end());\n    std::string result = \"\";\n    auto it = std::max_element(words.begin(),\
    \ words.end(), \n                         [](const std::string& a, const std::string&\
    \ b){return a.size() < b.size();});\n    for (size_t i = 0; i < it.size(); i++)\
    \ {\n        result += it[i];\n    }\n    return result;", "    // write your\
    \ code here\n    int max;\n    std::string s = words[0];\n    for (int i = 1;\
    \ i < words.size(); i++) {\n        std::string cur = words[i];\n        if (cur.length()\
    \ > s.length()) {\n            max = cur.length();\n            s = cur;\n   \
    \     }\n    }\n    if (s.length() > max)\n        return s;\n    return \"\";",
  "  // Write your code here.\n  std::string max_word = \"\";\n  int max_len = 0;\n\
    \  for (int i = 0; i < words.size(); i++) {\n    int count = 0;\n    for (int\
    \ j = 0; j < words[i].length(); j++) {\n      for (int k = 0; k < words[j].length();\
    \ k++) {\n        if (words[i].at(i) == words[j].at(k)) {\n          count++;\n\
    \        }\n      }\n    }\n    if (count > max_len) {\n      max_len = count;\n\
    \      max_word = words[i];\n    }\n  }\n  return max_word;", "    // Your code\
    \ here\n    std::vector<std::string> words2;\n    for (auto word: words) {\n \
    \       if (words2.size() == 0 || words2.back().size() > word.size()) words2.emplace_back(word);\n\
    \        else words2.back() = word;\n    }\n    std::string maxWord = words2.back();\n\
    \    for (size_t i = 1; i < words2.size(); i++) {\n        if (words2[i].size()\
    \ >= maxWord.size()) {\n            maxWord = words2[i];\n        }\n    }\n \
    \   return maxWord;", "    std::string res = \"\";\n    int max = 1;\n    for\
    \ (auto& word : words) {\n        auto size = word.size();\n        if (max <\
    \ size) {\n            max = size;\n            res = word;\n        }\n    }\n\
    \    return res;", "    // Code here \n    std::string max;\n    int max_count\
    \ = 0;\n    std::string current = \"\";\n    std::string word;\n    for (int i\
    \ = 0; i < words.size(); i++) {\n        word = words[i];\n        for (int j\
    \ = 0; j < word.length(); j++) {\n            current = current + word[j];\n \
    \           int count = 0;\n            for (int k = 0; k < words.length; k++)\
    \ {\n                if (words[k] == current) {\n                    count++;\n\
    \                }\n            }\n            if (count > max_count) {\n    \
    \            max = current;\n                max_count = count;\n            }\n\
    \        }\n        current = \"\";\n    }\n    return max;", "    int counter[256]\
    \ = {0};\n    std::string ans = \"\";\n    for (auto &w: words) {\n        for\
    \ (auto &c: w) {\n            if (counter[c] == 0) {\n                counter[c]\
    \ = 1;\n                ans = c;\n            } else {\n                counter[c]\
    \ += 1;\n            }\n        }\n    }\n    return ans;", "  std::set<std::string>\
    \ unique_chars;\n  std::string max = words[0];\n  for (int i = 1; i < words.size();\
    \ i++) {\n    std::string word = words[i];\n    for (auto c : word) {\n      if\
    \ (unique_chars.find(c) == unique_chars.end())\n        unique_chars.insert(c);\n\
    \    }\n    if (unique_chars.size() > max.length())\n      max = word;\n  }\n\
    \  return max;", "    // code here\n    std::string s = \"\";\n    unordered_set<char>\
    \ s(words.begin(), words.end());\n    unordered_set<char>::iterator i;\n    unordered_set<char>::iterator\
    \ j;\n    for (j = s.begin(); j != s.end(); j++) {\n        i = 0;\n        while\
    \ (i != words.size() && *j != words[i][0]) {\n            i++;\n        }\n  \
    \      if (i == words.size()) {\n            s += *j;\n        }\n    }\n    return\
    \ s;", "    int maxCnt = 0;\n    std::string temp;\n    for (const auto &w : words)\
    \ {\n        int count = 0;\n        for (const auto &c : w) {\n            count\
    \ += (temp.find(c) == std::string::npos)?1:0;\n        }\n        if (count >\
    \ maxCnt) {\n            maxCnt = count;\n            temp = w;\n        }\n \
    \   }\n    return maxCnt>maxCnt?temp:\"\";", "    std::map<char, int> counter;\n\
    \    std::string maxWord = \"\";\n    for (auto& word : words)\n        for (auto\
    \ c : word) {\n            if (counter.find(c) == counter.end())\n           \
    \     counter[c] = 1;\n            else\n                counter[c]++;\n     \
    \       if (counter[c] > 1) {\n                if (maxWord.size() == 0) {\n  \
    \                  maxWord = word;\n                } else {\n               \
    \     if (maxWord.size() < word.size())\n                        maxWord = word;\n\
    \                }\n            } else if (maxWord.size() == 0) {\n          \
    \      maxWord = word;\n            } else if (maxWord.size() < word.size()) {\n\
    \                maxWord = word;\n            }\n        }\n    return maxWord;",
  "    // Write your code here\n    int max = 0;\n    std::string word = \"\";\n \
    \   for (const auto& word : words) {\n        int count = 0;\n        for (const\
    \ auto& c : word) {\n            if (++count > max) {\n                max = count;\n\
    \                word = c;\n            }\n        }\n    }\n    return word;",
  "    // Your code here\n    std::string max = \"\";\n    int count = 0;\n    for\
    \ (auto &x : words)\n    {\n        if (x.size() > count) max = x;\n        else\
    \ if (x.size() == count) x.erase(x.begin());\n        else count = x.size();\n\
    \    }\n    return max;", "    // Your code goes here\n    int max = 0;\n    int\
    \ len = words.size();\n    for (int i = 0; i < len; i++) {\n        int count\
    \ = words[i].size();\n        if (count > max) {\n            max = count;\n \
    \       }\n    }\n    if (max > 0) {\n        for (int i = 0; i < len; i++) {\n\
    \            int count = words[i].size();\n            if (count <= max) {\n \
    \               continue;\n            }\n            for (int j = 0; j < len;\
    \ j++) {\n                if (words[j].size() == count) {\n                  \
    \  if (words[i].size() > words[j].size()) {\n                        return words[i];\n\
    \                    }\n                    else {\n                        return\
    \ words[j];\n                    }\n                }\n            }\n       \
    \ }\n    }\n    return \"\";", "    std::sort(words.begin(), words.end(), std::greater<std::string>());\n\
    \    return words[0];", "    std::unordered_map<char, int> umap;\n    std::string\
    \ word = \"\";\n    std::string word1 = \"\";\n    int count = 0;\n    for (auto&\
    \ x : words)\n    {\n        std::unordered_map<char, int>::iterator itr = umap.find(x);\n\
    \        if (itr == umap.end()) {\n            umap[x] = 1;\n        } else {\n\
    \            umap[x] += 1;\n        }\n    }\n    for (auto& x : umap) {\n   \
    \     if (x.second > count) {\n            count = x.second;\n            word\
    \ = x.first;\n        }\n    }\n    if (count > 0) {\n        std::cout << word\
    \ << \" has \" << count << \" unique characters.\" << std::endl;\n        return\
    \ word;\n    } else {\n        std::cout << word << \" has no characters in common.\"\
    \ << std::endl;\n        return \"\";\n    }", "    int max = 0;\n    std::string\
    \ maxString;\n    for (auto word : words) {\n        auto count = std::count_if(word.begin(),\
    \ word.end(), [](char c) {\n            return std::isalpha(c);\n        });\n\
    \        if (count > max) {\n            maxString = word;\n            max =\
    \ count;\n        } else if (count < max) {\n            maxString = word;\n \
    \           max = count;\n        }\n    }\n    return maxString;", "    int m\
    \ = 0;\n    for (auto &word : words)\n        if (word.length() > m)\n       \
    \     m = word.length();\n    for (int i = 0; i < words.size(); i++) {\n     \
    \   if (words[i].length() == m)\n            return words[i];\n    }\n    return\
    \ \"\";", "\tstd::map<int,std::string> m;\n\tstd::string ans = \"\";\n\tstd::string\
    \ temp;\n\tfor(int i = 0; i < words.size(); i++){\n\t\tint count = 0;\n\t\tfor(int\
    \ j = 0; j < words.size(); j++){\n\t\t\tif(words[i] == words[j]){\n\t\t\t\tcount++;\n\
    \t\t\t}\n\t\t}\n\t\tif(count > m[count]){\n\t\t\tans = words[i];\n\t\t\tm[count]\
    \ = ans;\n\t\t}\n\t}\n\tif(ans.empty()){\n\t\treturn \"\";\n\t}\n\tstd::map<int,std::string>::iterator\
    \ it = m.begin();\n\tstd::map<int,std::string>::iterator it1 = m.end();\n\twhile(it\
    \ != it1){\n\t\tif((it->second) < ans.capacity()){\n\t\t\tans = it->second;\n\t\
    \t}\n\t\tit++;\n\t}\n\treturn ans;", "  // Write your solution here\n  std::map<char,\
    \ int> m;\n  for (auto word : words) {\n    for (auto ch : word) {\n      m[ch]++;\n\
    \    }\n  }\n  auto it = m.begin();\n  while (it != m.end()) {\n    if (it->second\
    \ > 1) {\n      it = m.erase(it);\n    } else {\n      it++;\n    }\n  }\n  auto\
    \ it2 = m.begin();\n  while (it2 != m.end()) {\n    if (it2->second == 1) {\n\
    \      return it2->first;\n    }\n    it2++;\n  }\n  return \"\";", "    size_t\
    \ max_length = 0;\n    std::string result = \"\";\n    for (std::string word :\
    \ words) {\n        if (word.length() > max_length) {\n            max_length\
    \ = word.length();\n            result = word;\n        }\n    }\n    return result;",
  "    // Your code goes here\n    std::string word = words[0];\n    for (size_t i\
    \ = 0; i < words.size(); i++) {\n        if (words[i].size() > word.size()) {\n\
    \            word = words[i];\n        }\n    }\n    return word;", "  std::set<std::string>\
    \ unique_characters;\n  for (const auto& word : words) {\n    for (const auto&\
    \ character : word) {\n      if (unique_characters.count(character) == 0) {\n\
    \        unique_characters.insert(character);\n      }\n    }\n  }\n  return unique_characters.size()\
    \ == 0 ? words[0] : unique_characters.rbegin()->c_str();", "    int n = words.size();\n\
    \    for (int i = 0; i < n; ++i) {\n        unordered_set<char> s;\n        std::string\
    \ temp = words[i];\n        for (int j = i; j < n; ++j) {\n            if (s.find(temp[j\
    \ - i]) > 0) {\n                temp = temp[j - i];\n                for (int\
    \ k = i; k >= j && k > 0; ++k) {\n                    s.erase(temp[k]);\n    \
    \            }\n            }\n        }\n        if (s.empty())\n           \
    \ return words[i];\n    }\n    return \"\";", "    std::vector<std::string> unique_words;\n\
    \    std::string max_word;\n    std::string max_word_character;\n\n    std::sort(words.begin(),\
    \ words.end());\n\n    for (int i = 0; i < words.size(); i++) {\n        unique_words.push_back(words[i]);\n\
    \    }\n\n    unique_words.erase(unique_words.begin()); // erase first element\
    \ as its is empty\n\n    // Find out maximum number word of unique characters\n\
    \    int count_unique_characters = 0;\n    for (auto word : unique_words) {\n\
    \        int count = word.length();\n        for (auto character : word) {\n \
    \           count -= character;\n        }\n        if (count_unique_characters\
    \ < count) {\n            count_unique_characters = count;\n            max_word\
    \ = word;\n            max_word_character = word[0];\n        }\n    }\n\n   \
    \ // If max character found then return max word\n    if (max_word_character ==\
    \ unique_words[0][0]) {\n        return max_word;\n    }\n\n    return \"\";",
  "    // Your code goes here\n    std::string ans = \"\";\n    unsigned int n = words.size();\n\
    \    std::string max = \"\";\n    int cnt[26];\n    for (int i = 0; i < n; i++)\n\
    \    {\n        cnt[words[i].size()]++;\n        if (words[i].size() > max.size())\n\
    \        {\n            max = words[i];\n        }\n    }\n    for (int i = 0;\
    \ i < 26; i++)\n    {\n        if (cnt[i] > 1)\n        {\n            ans +=\
    \ max[i];\n        }\n    }\n    return ans;", "    // Write your code here.\n\
    \    // The code should contain following functions:\n    // 1. bool word_unique(std::vector<std::string>\
    \ words)\n    // 2. std::string find_max(std::vector<std::string> words)\n   \
    \ // The function find_max should return maximum word in the list.\n    // For\
    \ example, if the list is [\"a\", \"b\", \"ab\", \"c\", \"ab\", \"a\"]\n    //\
    \ The function will return \"ab\" since it has 2 unique characters\n    // The\
    \ function word_unique should return true if all words have same number of unique\
    \ characters and false otherwise.\n    // For example [\"aaaaaaa\", \"bb\" ,\"\
    cc\"] is false.\n    // So the function should return true if the word is unique\
    \ or false otherwise.\n    assert(words.size() > 1);\n    int max_count = words[0].length();\n\
    \    for (int i = 1; i < words.size(); i++) {\n        int count = words[i].length();\n\
    \        if (max_count < count) max_count = count;\n    }\n    if (words[0].length()\
    \ == max_count) {\n        return words[0];\n    }\n    for (int i = 1; i < words.size();\
    \ i++) {\n        if (words[i].length() == max_count) {\n            return words[i];\n\
    \        }\n    }\n    return \"\";", "    auto max_count = std::count_if(words.begin(),\
    \ words.end(), [&](const auto &s) { return s.size(); });\n    \n    if (max_count\
    \ == 0) {\n        return \"\";\n    } else if (max_count == 1) {\n        return\
    \ words[0];\n    }\n\n    std::string max_word = *std::max_element(words.begin(),\
    \ words.end(), [](const auto &a, const auto &b) { return a.size() < b.size();\
    \ });\n\n    return max_word;", "    // Write your code here\n    std::string\
    \ answer;\n    for (auto &i : words)\n    {\n        std::unordered_set<char>\
    \ unique;\n        for (auto &j : i)\n        {\n            unique.insert(j);\n\
    \        }\n        if (unique.size() > answer.size()) {\n            answer =\
    \ i;\n        }\n    }\n    return answer;", "  std::map<std::string, int> counter;\n\
    \  for (const auto& word : words) {\n    int freq = 0;\n    for (const auto& letter\
    \ : word) {\n      freq += counter.at(letter);\n    }\n    if (freq > counter.size())\
    \ {\n      counter[word] = 1;\n    } else {\n      counter[word] += 1;\n    }\n\
    \  }\n  // get rid of invalid words (the words whose count is 0)\n  for (const\
    \ auto& pair : counter) {\n    if (pair.second != 0) {\n      return pair.first;\n\
    \    }\n  }\n  // all characters have frequency of 1, the empty string is the\
    \ worst case\n  return \"\";", "    // Your code goes here\n    std::set<std::string>\
    \ s;\n    for (auto const& i : words) {\n        std::set<std::string> tmp = s;\n\
    \        for (const auto &j : i){\n            tmp.insert(j);\n        }\n   \
    \     if (s.empty()){\n            return i;\n        }else{\n            s.clear();\n\
    \            s = tmp;\n        }\n    }\n\n    return \"\";", "    //code here\n\
    \    std::string result=\"\";\n    for(auto w: words)\n    {\n        std::set<char>\
    \ unique_char;\n        std::size_t count=0;\n        for(char c: w)\n       \
    \ {\n            unique_char.insert(c);\n            count++;\n        }\n   \
    \     if(count > result.size())\n        {\n            result=w;\n        }\n\
    \    }\n    return result;", "  int n = words.size();\n  int max_char = 0;\n \
    \ int cur = 0, prev_char = 0;\n  for (int i = 0; i < n; ++i) {\n    cur = words[i].length();\n\
    \    if (cur > max_char) {\n      max_char = cur;\n      prev_char = cur;\n  \
    \  }\n  }\n  for (int i = 0; i < n; ++i) {\n    cur = words[i].length();\n   \
    \ if (cur > max_char && prev_char > max_char) {\n      return words[i];\n    }\n\
    \  }\n  return \"\";", "  std::unordered_map<char,int> char_map;\n  std::string\
    \ max_str = \"\";\n  // Find the maximum string and its size\n  for (auto const\
    \ &s : words) {\n    auto it = char_map.find(s[0]);\n    int max_chars = 0;\n\
    \    if (it != char_map.end())\n      max_chars = it->second;\n    for (const\
    \ auto &c : s) {\n      if (char_map[c] >= max_chars) {\n        char_map[c]++;\n\
    \        if (max_chars < char_map[c])\n          max_str = s;\n      }\n    }\n\
    \  }\n  return max_str;", "    if (words.size() < 2)\n        return \"\";\n \
    \   std::string w;\n    int uc = 0, lc = 0;\n    std::string maxw = words[0];\n\
    \    for (auto &w : words) {\n        uc += w.size();\n        lc = w.size();\n\
    \        if (uc > lc) w = maxw;\n        maxw = w;\n    }\n    return maxw;",
  "    std::string result=\"\";\n    int char_count= 0;\n    for(auto x:words){\n\
    \        char_count = std::count_if(words.begin(), words.end(), [&x]\n       \
    \     { return x.find(x) != std::string::npos; });\n        if(char_count >=1){\n\
    \            result = x;\n            break;\n        }\n    }\n    return result;",
  "    // Your code goes here\n    \n    std::string max;\n    for(auto word:words){\n\
    \        std::unordered_map<char,unsigned int> freq;\n        for(auto letter:word){\n\
    \            freq[letter]++;\n        }\n        std::multiset<char> temp{freq.begin(),\
    \ freq.end()};\n        if(temp.size()>max.size()){\n            max = std::move(word);\n\
    \        }\n    }\n    \n    if(max.size()==words[0].size()){\n        return\
    \ words[0];\n    }\n    return max;", "  // Your code here\n  int num_unique =\
    \ 0; std::string curr_max = words[0]; \n  for (std::vector<std::string>::iterator\
    \ it=words.begin()+1; it!=words.end(); ++it){\n    if(curr_max.size()<it->size()\
    \ && curr_max!=\"\")\n    {\n      num_unique++;\n      curr_max = it->size()\
    \ > num_unique ? it->size() : num_unique;\n    }\n  }\n  if(curr_max.size()>words[0].size())\n\
    \    curr_max = words[0];\n  assert(curr_max.size()==words[0].size());\n  return\
    \ curr_max;", "    std::string maxWord = words[0];\n    unsigned int maxChar =\
    \ words[0].size();\n    for (int i = 1; i < words.size(); i++) {\n        int\
    \ curChar = words[i].size();\n        if (curChar > maxChar) {\n            maxChar\
    \ = curChar;\n            maxWord = words[i];\n        }\n    }\n    return maxWord;",
  "    // code here\n    int n = words.size();\n    int k = 0, j = 0;\n    int temp\
    \ = 1;\n    for (int i = 0; i < n; i++) {\n        if (words.at(i).size() >= temp)\
    \ {\n            k = j;\n            j = i;\n        }\n    }\n    for (int i\
    \ = k + 1; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (j == i && words[j].size() > words[i].size()) continue;\n            if (words[j].size()\
    \ > words[i].size()) std::swap(words[j], words[i]);\n            if (words.at(i).size()\
    \ > words[j].size()) {\n                std::swap(words[j], words[i]);\n     \
    \       }\n        }\n    }\n    std::sort(words.begin(), words.end());\n    return\
    \ words.front();", "    std::sort(words.begin(), words.end());\n    std::string\
    \ temp = \"\";\n    std::string max = \"\";\n    unsigned int counter = 0;\n \
    \   for (auto &s : words) {\n        temp = s + temp;\n        if (temp.empty())\
    \ continue;\n        if (counter > 1) break;\n        if (std::count(temp.begin(),\
    \ temp.end(), max) > 0) {\n            max = temp;\n        }\n        ++counter;\n\
    \    }\n    return max;", "    \n    std::string max_word;\n    int max_char_count\
    \ = -1;\n    \n    for (std::string word : words)\n    {\n        int char_count\
    \ = word.length();\n        \n        if (char_count > max_char_count)\n     \
    \   {\n            max_char = char_count;\n            max_word = word;\n    \
    \    }\n    }\n    \n    if (max_char_count > 0)\n    {\n        return max_word;\n\
    \    }\n    else\n    {\n        return \"\";\n    }", "    std::sort(words.begin(),\
    \ words.end()); // sort in lexicographical order\n    auto max_size = std::max_element(words.begin(),\
    \ words.end()) - words.begin();\n    auto it = words.begin();\n    for (auto el\
    \ : max_size)\n    {\n        it = std::find(it, words.end(), el);\n    }\n  \
    \  return *it;", "    std::vector<std::string>::iterator itr;\n    std::string\
    \ result = \"\";\n    for (size_t i = 0; i < words.size(); i++) {\n        std::sort(words.begin()\
    \ + i, words.end());\n        std::set<std::string> s;\n        std::for_each(words.begin(),\
    \ words.end(), [&](std::string& s) { s.push_back(words[i]); });\n        for(itr\
    \ = s.begin(); itr != s.end(); ++itr) {\n            if (s.size() > result.size())\
    \ {\n                result = *itr;\n            }\n        }\n    }\n    return\
    \ result;", "    // your code here\n    std::string max_word = \"\";\n    std::string\
    \ curr_word = \"\";\n    size_t max_count = 0;\n    for (size_t i = 0; i < words.size();\
    \ i++) {\n        if (curr_word == words[i])\n            continue;\n        size_t\
    \ count = 0;\n        for (size_t j = 0; j < words.size(); j++) {\n          \
    \  if (i == j)\n                continue;\n            count += std::count(words[i].begin(),\
    \ words[i].end(), words[j].begin(), words[j].end());\n        }\n        if (count\
    \ > max_count) {\n            max_word = words[i];\n            max_count = count;\n\
    \        }\n        curr_word = words[i];\n    }\n    return max_word;", "\tint\
    \ count = 0, maxCount = 0;\n\tstd::string result;\n\t// loop through all the words\n\
    \tfor (auto &word : words) {\n\t\tint count = 0;\n\t\t// loop through all the\
    \ chars in the word\n\t\tfor (char ch : word) {\n\t\t\tcount++;\n\t\t}\n\t\tif\
    \ (count > maxCount) {\n\t\t\tmaxCount = count;\n\t\t\tresult = word;\n\t\t}\n\
    \t}\n\treturn result;", "    std::string word_max = \"\";\n    int num_of_unique_chars\
    \ = 0;\n    \n    for (const auto& word : words)\n    {\n        for (auto c :\
    \ word)\n        {\n            if (num_of_unique_chars < c.size() && c == word_max)\n\
    \            {\n                num_of_unique_chars++;\n                word_max\
    \ = c;\n            }\n        }\n    }\n    \n    return word_max;", "    //\
    \ Write your code here\n    int max = 0;\n    int n = 0;\n    for (int i = 0;\
    \ i < words.size(); i++) {\n        for (int j = i + 1; j < words.size(); j++)\
    \ {\n            n = std::count_if(words[i].begin(), words[i].end(), [j](char\
    \ c) { return std::tolower(c) == std::tolower(words[j].at(0)); });\n         \
    \   if (n > max) {\n                max = n;\n            }\n        }\n    }\n\
    \    if (max == 0) return \"\";\n    return words[std::distance(words.begin(),\
    \ std::max_element(words.begin(), words.begin() + max))];", "    // Your code\
    \ goes here\n    std::string result = \"\";\n    char maxChar = 0;\n    \n   \
    \ for(unsigned int i = 0; i < words.size(); i++){\n        \n        for(unsigned\
    \ int j = 0; j < words[i].size(); j++){\n            if(maxChar < words[i][j]){\n\
    \                maxChar = words[i][j];\n                result =words[i]; \n\
    \            }\n            \n        }\n    }\n    return result;", "    std::map<int,\
    \ std::string> m;\n    for (const auto &word : words) {\n        int count = 0;\n\
    \        for (const auto &ch : word) {\n            count += m[ch]++;\n      \
    \  }\n        if (count > m.size()) {\n            m.assign(count, word);\n  \
    \      }\n    }\n\n    auto it = m.begin();\n    return it->second + it->first\
    \ - 'a';", "    std::string result = \"\";\n    std::string word = \"\";\n   \
    \ int count = 0;\n    for (auto &i : words) {\n        if (i.size() > word.size())\
    \ {\n            word = i;\n            count = 1;\n        } else if (i.size()\
    \ == word.size()) {\n            count = count + 1;\n        }\n    }\n    if\
    \ (count > 1) {\n        result = word;\n    }\n    return result + (words.rbegin()->size()\
    \ == 0 ? \"\" : word);", "    int count = 0, max = 0, idx = 0;\n    for (std::string\
    \ word : words) {\n        ++count;\n        if (word.length() >= max) max = word.length();\n\
    \    }\n    for (std::string word : words) {\n        if (word.length() == max)\
    \ {\n            if (word.compare(words[idx], max)) idx++;\n            else break;\n\
    \        }\n    }\n    return words[idx] == \"\" ? words[0] : words[idx];", " \
    \   int count = 0, max_count = 0;\n    for (int i = 0; i < words.size(); ++i)\
    \ {\n        if (words[i].size() > max_count) {\n            max_count = words[i].size();\n\
    \            count = 0;\n        }\n        for (int j = 0; j < words[i].size();\
    \ ++j) {\n            count += words[i][j] == words[i][j];\n        }\n      \
    \  if (count > max_count) {\n            max_count = count;\n        }\n     \
    \   count = 0;\n    }\n    if (words.size() > max_count) {\n        return \"\"\
    ;\n    } else {\n        return words[max_count - 1];\n    }", "    int max_num\
    \ = 0, max_num_index = 0;\n    for (int i = 0; i < words.size(); i++) {\n    \
    \    int count = 0;\n        for (int j = 0; j < words[i].size(); j++) {\n   \
    \         count++;\n        }\n        if (count > max_num) {\n            max_num\
    \ = count;\n            max_num_index = i;\n        }\n    }\n    return words[max_num_index];",
  "    std::string max;\n    int count = 0;\n    for(size_t i=0; i<words.size(); i++){\n\
    \        for(size_t j=0; j<words[i].size(); j++){\n            if(words[i][j]\
    \ == '\\0'){\n                count++;\n            }\n            if(count >\
    \ words[i].size()){\n                max = words[i];\n            }\n        }\n\
    \    }\n    return max;", "    std::string max_word = \"\";\n    int max_word_count\
    \ = 0;\n    for (auto word : words) {\n        size_t word_count = 0;\n      \
    \  for (auto char : word) {\n            word_count += !std::count(word.begin(),\
    \ word.end(), char);\n        }\n        if (word_count > max_word_count) {\n\
    \            max_word = word;\n            max_word_count = word_count;\n    \
    \    }\n    }\n    if (max_word_count == words.size()) {\n        return max_word;\n\
    \    }\n    return max_word;", "  std::string answer;\n  int answerChars = 0;\n\
    \  for (auto i : words) {\n    answerChars = std::count_if(std::begin(i), std::end(i),\
    \ [&answerChars](char ch) {\n      return answerChars == 0;\n    });\n    if (answerChars\
    \ > 0) {\n      answer = i;\n      break;\n    }\n  }\n  return answer;", "  \
    \  // Your code goes here\n    std::string result = \"\";\n    for(std::string\
    \ word: words)\n    {\n        int count=0;\n        for(char c: word)\n     \
    \   {\n            if(c==' ')\n            {\n                count++;\n     \
    \       }\n        }\n        if(count>result.size())\n        {\n           \
    \ result=word;\n        }\n    }\n    return result;", "    // write your code\
    \ here\n    size_t len = words.size();\n    if(len == 0)\n        return \"\"\
    ;\n    std::string result = \"\";\n    for(size_t i = 0; i < (len - 1); i++) {\n\
    \        std::string s1 = words[i];\n        std::string s2 = words[i + 1];\n\
    \        size_t n = s1.size();\n        size_t m = s2.size();\n        if(n ==\
    \ m)\n            continue;\n        bool flag = false;\n        for (size_t j\
    \ = 0; j < n; j++) {\n            size_t k = 0;\n            for (size_t l = 0;\
    \ l < m; l++) {\n                if(s1[j] == s2[l])\n                    k++;\n\
    \            }\n            if(flag == false || k < m)\n                flag =\
    \ true;\n        }\n        if(flag == true)\n            result = s2;\n    }\n\
    \    for(size_t i = 0; i < words.size(); i++) {\n        std::string s1 = words[i];\n\
    \        size_t n = s1.size();\n        if(n == result.size())\n            return\
    \ words[i];\n    }\n    return \"\";", "  assert(words.size() > 0);\n  int unique_count\
    \ = 0, max_length = INT_MIN;\n  for (auto& word : words) {\n    unique_count +=\
    \ std::count(word.begin(), word.end(), 'a');\n    if (unique_count > max_length)\
    \ {\n      max_length = unique_count;\n    }\n  }\n  for (auto& word : words)\
    \ {\n    unique_count += std::count(word.begin(), word.end(), 'a');\n  }\n  if\
    \ (unique_count == max_length) return words[0];\n  else {\n    for (auto& word\
    \ : words) {\n      if (std::count(word.begin(), word.end(), 'a') == max_length)\
    \ {\n        return word;\n      }\n    }\n    return \"\";\n  }", "    int max_chars\
    \ = 0;\n    int max_count = 0;\n    for (int i = 0; i < words.size(); i++) {\n\
    \        char characters[128] = {0};\n        for (int j = 0; j < words[i].size();\
    \ j++) {\n            if (characters[words[i][j]]) {\n                characters[words[i][j]]\
    \ += 1;\n            } else {\n                characters[words[i][j]] = 1;\n\
    \            }\n            if (characters[words[i][j]] > max_count) {\n     \
    \           max_count = characters[words[i][j]];\n                max_chars =\
    \ words[i][j];\n            }\n        }\n    }\n    return words[max_chars];",
  "    std::string max;\n    bool isMax = false;\n    for (auto &word : words) {\n\
    \        std::set<char> charSet;\n        for (auto &c : word) {\n           \
    \ charSet.insert(c);\n        }\n        if (!isMax) {\n            isMax = true;\n\
    \            max = word;\n        } else {\n            if (charSet.count(max)\
    \ > charSet.count(word)) {\n                max = word;\n            }\n     \
    \   }\n    }\n    return max;", "    std::string ret = \"\";\n    if (words.empty())\
    \ {\n        return ret;\n    }\n    // Keep track of the number of unique characters\
    \ in each string.\n    int char_count[words.size()];\n    for (int i = 0; i <\
    \ words.size(); i++) {\n        // Only count unique characters in words[i].\n\
    \        char_count[i] = words[i].size();\n    }\n    // Sort the word list according\
    \ to the number of unique characters\n    // and print the first word whose number\
    \ of unique characters is\n    // maximized.\n    int max_char_count = std::max_element(char_count\
    \ + 1,\n                                          char_count + words.size());\n\
    \    for (int i = 0; i < words.size(); i++) {\n        if (char_count[i] == max_char_count)\
    \ {\n            ret = words[i];\n            break;\n        }\n    }\n    return\
    \ ret;", "    // Your code goes here\n    std::string max = \"\";\n    int counter\
    \ = 0;\n    for (auto i : words)\n        for (auto j : i)\n            if (std::find(words.begin(),\
    \ words.end(), j) == words.end())\n                counter++;\n    if (counter\
    \ > 0)\n        for (auto i : words)\n            if (i == max && std::find(words.begin(),\
    \ words.end(), i) == words.end())\n                max = i;\n    return max;",
  "  // write your code here\n  std::sort(words.begin(), words.end());\n  return words[words.size()-1];",
  "  int max = 0;\n  int index = 0;\n  int count = 0;\n  for (int i = 0; i < words.size();\
    \ i++) {\n    if (words[i].size() > max) {\n      max = words[i].size();\n   \
    \   index = i;\n    }\n  }\n  for (int i = 0; i < words.size(); i++) {\n    for\
    \ (int j = i; j < words.size(); j++) {\n      if (words[i].compare(words[j]) ==\
    \ 0) {\n        count++;\n      }\n    }\n  }\n  if (count > max) {\n    return\
    \ words[index];\n  }\n  return \"\";", "    // code here\n    std::string res\
    \ = \"\";\n    std::string word = \"\";\n    int count = 0;\n    for (int i =\
    \ 0; i < words.size(); i++) {\n        if (words[i] == word) {\n            count++;\n\
    \        } else {\n            if (count > 0 && count > words[i].size()) {\n \
    \               count = words[i].size();\n                res = words[i];\n  \
    \          }\n            count = 1;\n            word = words[i];\n        }\n\
    \    }\n    return res;", "    int n = words.size();\n    int max = 0;\n    std::string\
    \ s = words[0];\n    for (int i = 1; i < n; i++) {\n        int cmp = std::count(s.begin(),\
    \ s.end(), words[i]);\n        if (cmp > max) {\n            max = cmp;\n    \
    \        s = words[i];\n        }\n    }\n    return s;", "  int count = 0;\n\
    \  for (const auto& word: words) {\n    int len = word.length();\n    count +=\
    \ len;\n  }\n\n  std::string ans = words[0];\n  for (int i = 1; i < words.size();\
    \ i++) {\n    int current = count;\n    std::string word = words[i];\n    for\
    \ (int j = 0; j < word.length(); j++) {\n      current += word[j];\n      if (current\
    \ > ans.length()) {\n        ans = word;\n      }\n    }\n  }\n  return ans;",
  "    int maxCount = 0;\n    std::string maxWord = words[0];\n    for (int i = 1;\
    \ i < words.size(); ++i) {\n        auto it = std::count_if(words.begin(), words.end(),\
    \ [&](const std::string &s) {\n            return s.find(maxWord) == std::string::npos;\n\
    \        });\n        if (it > maxCount) {\n            maxCount = it;\n     \
    \       maxWord = words[i];\n        }\n    }\n    return maxWord;", "  // your\
    \ code goes here\n  sort(words.begin(), words.end());\n  int maxcount = 0;\n \
    \ for (int i = 0; i < words.size(); i++) {\n    if (words[i].size() > maxcount)\
    \ {\n      maxcount = words[i].size();\n    }\n  }\n  int index = 0;\n  for (int\
    \ i = 0; i < words.size(); i++) {\n    if (words[i].size() == maxcount) {\n  \
    \    if (words[i] != words[index]) {\n        std::cout << words[i] << std::endl;\n\
    \      }\n      index++;\n    }\n  }\n  if (words.size() > index) {\n    return\
    \ words[index];\n  }\n  return words[words.size() - 1];", "    // code here\n\
    \    std::string maxWord;\n    int maxChar = 0;\n    bool found = false;\n   \
    \ for (auto word : words) {\n        int charCount = 0;\n        bool exist =\
    \ false;\n        for (auto char : word) {\n            charCount++;\n       \
    \     if (charCount == maxChar) {\n                exist = true;\n           \
    \     break;\n            }\n        }\n        if (!exist) {\n            maxChar\
    \ = charCount;\n            maxWord = word;\n            found = true;\n     \
    \   }\n    }\n    return maxWord;", "  // Your code here\n  int n = 0;\n  int\
    \ max = 0;\n  for (auto it = words.begin(); it != words.end(); it++) {\n    if\
    \ (n[(*it)[max]] < (*it)[max]) n[(*it)[max]] += 1;\n    else max = (*it).size()\
    \ - 1;\n  }\n  return *std::max_element(words.begin(), words.end(), [n](const\
    \ std::string & a, const std::string & b) { return n[a] < n[b]; }).c_str();",
  "    int m = 1;\n    std::string word;\n    for (const auto& word : words) {\n \
    \       // If the current word has same number of unique chars with\n        //\
    \ the previous word, return previous word\n        if (word.length() > m) {\n\
    \            m = word.length();\n            word = words[words.size()-1];\n \
    \       } else if (word.length() == m) {\n            if (words.size() > 1) {\n\
    \                // If there is only one word in the list, return the\n      \
    \          // word with longest lexicographical order\n                word =\
    \ words[words.size()-2];\n            }\n        }\n    }\n    return word;",
  "    int max_num_char = std::max_element(words.begin(), words.end()) -words.begin();\n\
    \    if(max_num_char == 0){\n        return \"\";\n    }\n    int max_char = 0;\n\
    \    for(int i = 0; i < words.size(); i++){\n        if(words[i].size() == max_num_char){\n\
    \            int char_counter = 0;\n            for(int j=0; j < words[i].size();\
    \ j++){\n                if(words[i][j] == max_char){\n                    char_counter++;\n\
    \                }\n            }\n            if(char_counter > max_char){\n\
    \                max_char = char_counter;\n            }\n        }\n    }\n \
    \   return words[max_char];", "    // Write your code here.\n    int max = 0;\n\
    \    std::string result;\n    for(auto const &x:words){\n        auto it = std::count(x.begin(),\
    \ x.end(), 'a');\n        if(it>max){\n            max = it;\n            result\
    \ = x;\n        }\n    }\n    return result;", "    std::map<int, std::string>\
    \ m;\n    std::string result;\n    int size = words.size();\n    for (size_t i\
    \ = 0; i < size; i++) {\n        if (m.find(words[i].size()) != m.end()) {\n \
    \           if (m[words[i].size()] > words[i].size()) {\n                result\
    \ = words[i];\n            }\n        } else {\n            m[words[i].size()]\
    \ = words[i];\n        }\n    }\n    return result;", "    std::string res = \"\
    \";\n    size_t max = 0;\n    for (size_t i = 0; i < words.size(); ++i) {\n  \
    \      int c = std::count_if(words.begin(), words.end(),\n            [i = i](const\
    \ std::string& s) -> bool { return s.find_first_of(i) == i; });\n        if (c\
    \ == words[i].length()) {\n            if (c > max) {\n                max = c;\n\
    \                res = words[i];\n            }\n        }\n    }\n    return\
    \ res;", "    assert(words.size() > 0);\n    std::string biggest(words[0]);\n\
    \    int max_size = words[0].length();\n    for (auto &w : words) {\n        if\
    \ (w.length() > max_size) {\n            biggest = w;\n            max_size =\
    \ w.length();\n        }\n    }\n    return biggest;", "    // Write your code\
    \ here\n    int max_word=words.size();\n    std::string max_words;\n    int counter=0;\n\
    \    for(int i=0;i<words.size();i++){\n        for(int j=0;j<words.size();j++){\n\
    \            if(max_word<words.size()){\n                counter=0;\n        \
    \        for(int k=0;k<words.size();k++){\n                    if(words[k]==words[i]){\n\
    \                        counter++;\n                    }\n                }\n\
    \                if(counter>max_word){\n                    max_words=words[i];\n\
    \                    max_word=counter;\n                }\n            }\n   \
    \     }\n    }\n    return max_words;", "    // Your code goes here\n    unordered_set<char>\
    \ uni;\n    string ans;\n    int max = 0;\n    for (auto &word: words){\n    \
    \    unordered_set<char> uni;\n        for (auto &ch: word)\n            uni.insert(ch);\n\
    \        uni.erase(' ');\n        max = max(max, uni.size());\n    }\n    ans\
    \ = \"\";\n    for (auto &word: words)\n        if (word.size() == max)\n    \
    \        ans = word;\n    return ans;", "    // Declare a map to store the max\
    \ frequency of each word\n    std::map<std::string, int> freq;\n    // Declare\
    \ a vector to store the string with maximum number of chars\n    std::vector<std::string>\
    \ max_word;\n    // Loop through the array\n    for (int i = 0; i < words.size();\
    \ i++) {\n        // If the current word has a higher frequency, save it in the\
    \ vector\n        if (freq.find(words[i]) == freq.end()) {\n            freq[words[i]]\
    \ = 1;\n        }\n        else {\n            freq[words[i]]++;\n        }\n\
    \    }\n    // Loop through the map\n    for (auto it = freq.begin(); it != freq.end();\
    \ ++it) {\n        // If the max word has less frequency than the current word,\
    \ save it\n        if (it->second < max_word.size()) max_word.push_back(it->first);\n\
    \    }\n    // If the length of vector is zero, return empty string\n    if (max_word.size()\
    \ == 0) {\n        return \"\";\n    }\n    // Return the max word with max frequency\n\
    \    return max_word[max_word.size() - 1];", "    int count = std::count_if(words.begin(),\
    \ words.end(), [&](const std::string & str) {\n        return str.size() <= 10;\
    \ // replace this with your own criteria\n    });\n    if(count > 1) {\n     \
    \   return std::string(words[words.size()-1]);\n    }\n    if(count == 1) {\n\
    \        return words[words.size()-1];\n    }\n    return \"\"; // replace this\
    \ with your own criteria", "    std::string max = \"\";\n    int max_count = -1;\n\
    \    for(int i=0; i<words.size(); ++i) {\n        if(words[i].size() > max_count)\
    \ {\n            max_count = words[i].size();\n            max = words[i];\n \
    \       }\n    }\n    return max;", '    // code here', "    // Write your code\
    \ here\n    std::sort(words.begin(), words.end(), ::compare);\n    int maxUniqueCharCount\
    \ = 0;\n    int maxIndex = 0;\n    std::string maxWord = words[0];\n    for (size_t\
    \ i = 0; i < words.size(); i++) {\n        auto it = std::unique(words[i].begin(),\
    \ words[i].end());\n        if (it != words[i].end()) {\n            maxUniqueCharCount\
    \ += static_cast<int>(words[i].size() - it);\n            maxIndex = i;\n    \
    \        maxWord = words[i];\n        }\n    }\n    if (maxIndex == 0) {\n   \
    \     return maxWord;\n    }\n    return maxWord;", "    // Write your code here\n\
    \    int m = std::numeric_limits<int>::min();\n    int max = 0;\n    int index\
    \ = 0;\n    for (size_t i = 0; i < words.size(); ++i) {\n        auto n = words[i].size();\n\
    \        if (n > max) {\n            max = n;\n            index = i;\n      \
    \  }\n    }\n    assert(max != std::numeric_limits<int>::min());\n    assert(max\
    \ != 0);\n    return words[index];", "    std::string max = \"\";\n    int maxCount\
    \ = 1;\n    int index = 0;\n    // Loop through all strings\n    for (auto const\
    \ & word : words) {\n        // Increase count for given word\n        for (auto\
    \ const & c : word) {\n            count[c]++;\n        }\n\n        // Update\
    \ max\n        if (count[max] >= maxCount) {\n            max = word;\n      \
    \      maxCount = count[max];\n        }\n\n        // If max is empty, return\
    \ empty string\n        if (max.empty()) {\n            break;\n        }\n\n\
    \        // Check all letters of current word are already in max word\n      \
    \  for (auto const & c : word) {\n            if (count[c] == maxCount) {\n  \
    \              break;\n            }\n        }\n\n        // Increase index\n\
    \        index++;\n    }\n\n    // Return max string\n    return max;", "    std::string\
    \ max = \"\";\n    int max_count = 0;\n    for (auto& x : words) {\n        if\
    \ (x.size() > max_count) {\n            max = x;\n            max_count = x.size();\n\
    \        }\n    }\n    return max;", "  // code here\n  if(words.size() == 0)\n\
    \    return \"\";\n  std::string largest = words[0];\n  int uniques = 0;\n  for(auto\
    \ s : words)\n  {\n    for(auto c : s)\n    {\n      if(c != largest.back())\n\
    \      {\n        uniques++;\n      }\n    }\n  }\n  if(uniques > words.size())\n\
    \    return words[0];\n  else\n  {\n    for(auto s : words)\n    {\n      if(s.find(largest)\
    \ != std::string::npos)\n      {\n        largest = s;\n        break;\n     \
    \ }\n    }\n    return largest;\n  }", "    int n = words.size();\n    int max\
    \ = 1;\n    for (int i = 0; i < n; i++) {\n        int unique = 0;\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i != j && words[i] == words[j]) {\n\
    \                unique += 1;\n            }\n        }\n        if (unique >\
    \ max) {\n            max = unique;\n        }\n    }\n    if (max == 1) return\
    \ words[0];\n    std::string word = \"\";\n    for (int i = 0; i < n; i++) {\n\
    \        word += words[i];\n        if (i == (n - 1) || words[i + 1] != word)\
    \ {\n            word += \"a\";\n        }\n    }\n    return word;", "  int maxSize\
    \ = 0, index = -1;\n  for (int i = 0; i < words.size(); i++) {\n    int count\
    \ = 0;\n    for (int j = 0; j < words[i].size(); j++) {\n      count += 1;\n \
    \     if (count > maxSize) {\n        maxSize = count;\n        index = i;\n \
    \     }\n    }\n  }\n  if (maxSize == 0) return \"\";\n  else {\n    std::string\
    \ ret = words[index];\n    int maxCount = 0, maxIndex = 0;\n    for (int i = 0;\
    \ i < words.size(); i++) {\n      if (i == index) continue;\n      int count =\
    \ 0;\n      for (int j = 0; j < words[i].size(); j++) {\n        count += 1;\n\
    \        if (count > maxCount) {\n          maxCount = count;\n          maxIndex\
    \ = i;\n        }\n      }\n    }\n    return ret;\n  }", "    std::vector<std::string>\
    \ chars;\n    std::vector<std::string> max_chars;\n    std::vector<std::string>\
    \ sorted_words;\n    for (std::string word: words) {\n        std::set<char> unique;\n\
    \        std::sort(word.begin(), word.end());\n        std::set_difference(word.begin(),\
    \ word.end(), unique.begin(), unique.end(), std::back_inserter(sorted_words));\n\
    \        std::sort(sorted_words.begin(), sorted_words.end());\n    }\n    std::set_intersection(sorted_words.begin(),\
    \ sorted_words.end(), chars.begin(), chars.end(), std::back_inserter(max_chars));\n\
    \    std::string longest;\n    std::sort(max_chars.begin(), max_chars.end());\n\
    \    for (auto i: max_chars) {\n        longest = i;\n    }\n    return longest;",
  "    std::sort(words.begin(), words.end());\n    std::string result = words[0];\n\
    \    int len = words.size();\n    for (int i = 1; i < len; i++) {\n        if\
    \ (words[i].size() == result.size()) {\n            if (std::equal(words[i].begin(),\
    \ words[i].end(), result.begin())) {\n                continue;\n            }\n\
    \        }\n        result = words[i];\n    }\n    return words[0] == result ?\
    \ words[0] : \"\";", "    int max_length = 0;\n    std::string max;\n    for (auto\
    \ word : words) {\n        max_length = std::max(max_length, word.length());\n\
    \        max = std::max(max, word);\n    }\n    return max;", "    std::vector<std::string>\
    \ uniq_chars;\n    std::string max_word = words[0];\n    for (size_t i = 0; i\
    \ < words.size(); i++) {\n        std::string curr_word = words[i];\n        int\
    \ curr_word_size = curr_word.length();\n        for (int j = 0; j < curr_word_size;\
    \ j++) {\n            if (std::find(uniq_chars.begin(), uniq_chars.end(), curr_word[j])\
    \ ==\n                uniq_chars.end()) {\n                uniq_chars.push_back(curr_word[j]);\n\
    \            }\n        }\n        int curr_word_size = curr_word.length();\n\
    \        if (curr_word_size > max_word.length()) {\n            max_word = curr_word;\n\
    \        }\n    }\n    return max_word;", "    // Your code goes here\n    auto\
    \ max_counter = [&](const std::string &word) {\n        std::unordered_map<char,\
    \ int> m;\n        for (const auto &w : word) {\n            m[w]++;\n       \
    \ }\n        int max = 0;\n        for (const auto &kv : m) {\n            if\
    \ (kv.second > max) {\n                max = kv.second;\n            }\n     \
    \   }\n        return max;\n    };\n    auto max_word = max_counter(words[0]);\n\
    \    for (size_t i = 1; i < words.size(); i++) {\n        int word_count = max_counter(words[i]);\n\
    \        if (word_count > max_word) {\n            max_word = word_count;\n  \
    \      }\n    }\n    return max_word;", "  // Your code goes here\n  std::string\
    \ word = \"\";\n  int chars = 0;\n  for (auto it = words.begin(); it != words.end();\
    \ ++it)\n  {\n    chars += *it;\n  }\n  if(chars > word.length())\n    word =\
    \ word;\n  else\n  {\n    for(auto it = words.begin(); it != words.end(); ++it)\n\
    \    {\n      if(it->length() > word.length())\n        word = *it;\n    }\n \
    \ }\n  return word;", "    // Your code here\n    std::string max=\"\";\n    std::string\
    \ temp=\"\";\n    std::string maxCount=\"\";\n    for(int i=0;i<words.size();i++){\n\
    \        for(int j=i+1;j<words.size();j++){\n            if(words[i].length()>words[j].length()){\n\
    \                temp = words[i];\n                words[i]=words[j];\n      \
    \          words[j]=temp;\n            }\n            int nChars = words[i].length();\n\
    \            int counts[256];\n            for(int k=0;k<256;k++){\n         \
    \       counts[k]=0;\n            }\n            for(int k=0;k<words[i].length();k++){\n\
    \                counts[words[i].at(k)]+=1;\n            }\n            for(int\
    \ k=0;k<256;k++){\n                if(counts[k]==nChars){\n                  \
    \  maxCount+=words[i].substr(k,1);\n                    break;\n             \
    \   }\n            }\n        }\n        if(maxCount.length()==0){\n         \
    \   max = words[0];\n        }\n        else if(maxCount.length()<words[i].length()){\n\
    \            max = maxCount;\n            maxCount=words[i];\n        }\n    }\n\
    \    if(max.length()==0){\n        max=words[0];\n    }\n    return max;", " \
    \   std::string max_word;\n    int max_word_length = std::numeric_limits<int>::max();\n\
    \    int count_max_word = -1;\n    for (auto word : words) {\n        int length\
    \ = word.length();\n        if (length == max_word_length) {\n            if (count_max_word\
    \ == -1 || length < count_max_word)\n                max_word = word;\n      \
    \      count_max_word = length;\n        }\n        else\n            max_word_length\
    \ = length;\n    }\n    return max_word;", "    std::sort(words.begin(), words.end(),\
    \ std::greater<std::string>());\n    std::ostringstream oss;\n    oss << words[0];\n\
    \    int uniq_char = 0;\n    for (size_t i = 1; i < words.size(); i++) {\n   \
    \     if (words[i] < words[i - 1]) {\n            oss << words[i];\n        }\n\
    \        else {\n            if (words[i].size() > uniq_char) {\n            \
    \    uniq_char = words[i].size();\n            }\n        }\n    }\n    return\
    \ oss.str();", "    std::string max_val = words[0];\n    int max_index = 0;\n\
    \    int count = 0;\n    for (auto i : words) {\n        if (i != max_val) {\n\
    \            count++;\n            if (count > max_index) {\n                max_index\
    \ = count;\n                max_val = i;\n            }\n        } else if (i\
    \ == max_val) {\n            count++;\n        }\n    }\n    return max_val;",
  "  int unique_char = 0;\n  std::string res = \"\";\n  // Write your code here\n\
    \  for (auto &x : words) {\n    for (auto &y : words) {\n      if (x == y) {\n\
    \        continue;\n      }\n      for (auto &z : words) {\n        if (z == y)\
    \ {\n          continue;\n        }\n        int x = 0, y = 0, z = 0;\n      \
    \  for (auto &c : words) {\n          if (c == y) {\n            x++;\n      \
    \    }\n          if (c == z) {\n            y++;\n          }\n          if (c\
    \ == x) {\n            z++;\n          }\n        }\n        if (x == y) {\n \
    \         continue;\n        }\n        if (x == z) {\n          continue;\n \
    \       }\n        if (y == z) {\n          continue;\n        }\n        if (x\
    \ == unique_char) {\n          continue;\n        }\n        if (y == unique_char)\
    \ {\n          continue;\n        }\n        if (z == unique_char) {\n       \
    \   continue;\n        }\n        if (x == unique_char) {\n          unique_char++;\n\
    \          res = x;\n          continue;\n        }\n        if (y == unique_char)\
    \ {\n          unique_char++;\n          res = y;\n          continue;\n     \
    \   }\n        if (z == unique_char) {\n          unique_char++;\n          res\
    \ = z;\n          continue;\n        }\n      }\n    }\n  }\n  return res;", " \
    \   std::sort(words.begin(), words.end());\n    int max = 0;\n    int index =\
    \ 0;\n    for (std::size_t i = 0; i < words.size(); i++) {\n        int counter\
    \ = 0;\n        for (int j = 0; j < words[i].size(); j++) {\n            counter++;\n\
    \        }\n        if (counter > max) {\n            max = counter;\n       \
    \     index = i;\n        }\n    }\n    if (max > 0) {\n        return words[index];\n\
    \    }\n    return \"\";", "  // code here\n  int max_char = 0;\n  for (int i\
    \ = 0; i < words.size(); i++) {\n    int c = 0;\n    for (int j = 0; j < words[i].length();\
    \ j++)\n      for (int k = 0; k < max_char; k++)\n        if (words[i].at(j) ==\
    \ words[i][k])\n          c++;\n    if (c == max_char)\n      continue;\n    else\
    \ if (c > max_char)\n      max_char = c;\n  }\n  return words[max_char];", " \
    \   std::sort(words.begin(), words.end());\n    int count = 0;\n    std::string\
    \ maxStr;\n    for (int i = 0; i < words.size(); ++i) {\n        if (words[i].size()\
    \ > count) {\n            maxStr = words[i];\n            count = words[i].size();\n\
    \        }\n    }\n    return maxStr;", "    int max_count[256] = {0};\n    for\
    \ (auto &word: words) {\n        for(auto &c: word) {\n            int count =\
    \ ++max_count[c];\n            if(count > 1) {\n                break;\n     \
    \       }\n        }\n    }\n    int max_chars[256] = {0};\n    std::string res\
    \ = \"\";\n    for (int i = 0; i < 256; i++) {\n        if(max_count[i] > 0 &&\
    \ max_chars[max_count[i]-1] == 0) {\n            max_chars[max_count[i]-1] = i;\n\
    \        }\n        if(max_count[i] > 1) {\n            break;\n        }\n  \
    \  }\n    for(auto &word: words) {\n        for(auto &c: word) {\n           \
    \ int count = ++max_count[c];\n            if(count == max_count[i]) {\n     \
    \           if(c == max_chars[max_count[i]-1]) {\n                    res += c;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return res;", "    std::map<char, size_t> count;\n    for (auto &word\
    \ : words) {\n        auto key = word.front();\n        auto val = count.find(key);\n\
    \        if (val == count.end())\n            count[key] = word.size();\n    \
    \    else\n            count[key] = val->second + word.size();\n    }\n    return\
    \ count.rbegin()->first;", "  // code here\n  std::string max;\n  max = \"\";\n\
    \  int cnt = 0;\n  for (int i = 0; i < words.size(); ++i) {\n    if (words[i].size()\
    \ > cnt) {\n      max = words[i];\n      cnt = words[i].size();\n    }\n  }\n\
    \  return max;"]
stop_tokens:
- "\n}"
