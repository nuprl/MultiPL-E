language: cpp
name: HumanEval_117_select_words
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    \n    // Complete this\
    \ function\n    \n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_in7nul5: /tmp/tmp_in7nul5.cpp:23: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    // write your code here\n\
    \    for (int i = 0; i < s.length(); ++i) {\n        if (s[i] == 'a' || s[i] ==\
    \ 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            words.push_back(s.substr(i,\
    \ i + n));\n        }\n    }\n    return words;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpps8g5x3y: /tmp/tmpps8g5x3y.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141123
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code here\n    std::vector<std::string> res;\n   \
    \ std::string tmp = \"\";\n    for(auto i : s){\n        if(std::isalpha(i)){\n\
    \            tmp += i;\n            if(std::isspace(i)){\n                if(tmp.empty()){\n\
    \                    res.clear();\n                    res.push_back(tmp);\n \
    \                   tmp = \"\";\n                }else{\n                    if(tmp\
    \ == \" \"){\n                        res.push_back(tmp);\n                  \
    \      tmp = \"\";\n                    }else{\n                        if(tmp.empty()){\n\
    \                            res.push_back(tmp);\n                           \
    \ tmp = \"\";\n                        }else{\n                            if(tmp\
    \ == \" \"){\n                                res.push_back(tmp);\n          \
    \                      tmp = \"\";\n                            }\n          \
    \              }\n                    }\n                }\n            }\n  \
    \      }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmptfmdblaq: /tmp/tmptfmdblaq.cpp:49: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141124
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(s.empty()) return res;\n\
    \    for(size_t i = 0; i <= s.length(); i++) {\n        if(s.at(i).isspace())\
    \ continue;\n        for(size_t j = 0; j <= s.length(); j++) {\n            if(i\
    \ == j) continue;\n            if(s.at(j).isspace()) continue;\n            if(s.at(j)\
    \ == '_' || s.at(j) == ' ') continue;\n            if(n == 1) break;\n       \
    \     if(s.at(j) - s.at(i) == n) res.push_back(s.substr(i, j + 1));\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpesko33za.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpesko33za.cpp:18:20: error:\
    \ request for member \u2018isspace\u2019 in \u2018s.std::__cxx11::basic_string<char>::at(i)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   18 |         if(s.at(i).isspace())\
    \ continue;\n      |                    ^~~~~~~\n/tmp/tmpesko33za.cpp:21:24: error:\
    \ request for member \u2018isspace\u2019 in \u2018s.std::__cxx11::basic_string<char>::at(j)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   21 |             if(s.at(j).isspace())\
    \ continue;\n      |                        ^~~~~~~\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    size_t idx = 0, s_size\
    \ = s.size();\n    for (; idx < s_size; idx++) {\n        if (s[idx] != '\\0')\
    \ {\n            std::string word = s.substr(idx, 1);\n            if (select_consonant_counts(word,\
    \ n, words) != 1) {\n                words.push_back(word);\n            }\n \
    \       }\n    }\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi0xkvp2_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpi0xkvp2_.cpp:20:17: error:\
    \ \u2018select_consonant_counts\u2019 was not declared in this scope\n   20 |\
    \             if (select_consonant_counts(word, n, words) != 1) {\n      |   \
    \              ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end());\n    std::vector<std::string>\
    \ res;\n    std::vector<std::string>::iterator it = s.begin();\n    while (n--\
    \ > 0 && it != s.end()) {\n        if (*it == 'a' || *it == 'e' || *it == 'i'\
    \ || *it == 'o' || *it == 'u' || *it == 'A' || *it == 'E' || *it == 'I' || *it\
    \ == 'O' || *it == 'U') {\n            it = s.erase(it);\n        } else {\n \
    \           it++;\n        }\n    }\n    res.push_back(s);\n    return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdb36u2ck.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpdb36u2ck.cpp:17:52: error:\
    \ conversion from \u2018__normal_iterator<char*,std::__cxx11::basic_string<char>>\u2019\
    \ to non-scalar type \u2018__normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\u2019 requested\n   17 |     std::vector<std::string>::iterator it = s.begin();\n\
    \      |                                             ~~~~~~~^~\n/tmp/tmpdb36u2ck.cpp:18:26:\
    \ error: no match for \u2018operator!=\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   18 |     while (n-- > 0 && it != s.end()) {\n      |         \
    \              ~~ ^~ ~~~~~~~\n      |                       |          |\n   \
    \   |                       |          __normal_iterator<char*,std::__cxx11::basic_string<char>>\n\
    \      |                       __normal_iterator<std::__cxx11::basic_string<char>*,std::vector<std::__cxx11::basic_string<char>\
    \ >>\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n     \
    \            from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpdb36u2ck.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution f"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> list;\n    \n    std::string w;\n\
    \    \n    for (auto &i: s)\n    {\n        switch (i)\n        {\n        case\
    \ 'a':\n        case 'e':\n        case 'i':\n        case 'o':\n        case\
    \ 'u':\n            w = i;\n            break;\n        default:\n           \
    \ w = \"\";\n        }\n        \n        if (w.size() >= n)\n            list.push_back(w);\n\
    \    }\n    \n    return list;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp0q96yt33: /tmp/tmp0q96yt33.cpp:42: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141123
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n        std::vector<std::string> words;\n        std::vector<std::string>\
    \ split_strs;\n        long int len = s.length();\n        \n        if (n ==\
    \ 0)\n            return words;\n        // To split s by the delimiter space\
    \ and store the result in a vector\n        split_strs = split_string(s, \" \"\
    );\n        // To get all unique words\n        std::sort(split_strs.begin(),\
    \ split_strs.end());\n        std::unique_copy(split_strs.begin(), split_strs.end(),\
    \ std::back_inserter(words));\n        \n        // return words.size();\n   \
    \     return words;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq91d2qw9.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpq91d2qw9.cpp:22:22: error:\
    \ \u2018split_string\u2019 was not declared in this scope; did you mean \u2018\
    split_strs\u2019?\n   22 |         split_strs = split_string(s, \" \");\n    \
    \  |                      ^~~~~~~~~~~~\n      |                      split_strs\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.empty()) return {};\n    std::vector<std::string> res;\n\
    \    auto first = s.begin();\n    auto last = s.begin() + s.size();\n    for(long\
    \ i = 0; i < n && first != last; ++first, ++i) {\n        while(i != n && !std::isspace(first[i\
    \ - 1])) --i;\n        if(i != n) break;\n        if(first == last) break;\n \
    \       res.emplace_back(std::string(first, last));\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> retval;\n    \n    for(auto it=s.begin();it!=s.end();++it){\n\
    \        long cnt = 0;\n        for(char c : s){\n            if(c == *it){\n\
    \                ++cnt;\n            }\n        }\n        if(cnt == n){\n   \
    \         retval.push_back(std::string(it,s.end()));\n        }\n    }\n    return\
    \ retval;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpa84r52_t: /tmp/tmpa84r52_t.cpp:32: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141124
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    for (std::size_t i = 0; i\
    \ < s.size(); ++i) {\n        std::size_t count = 0;\n        std::size_t next_index\
    \ = 0;\n        \n        for (std::size_t j = i; j < s.size(); ++j) {\n     \
    \       if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z') || (s[i]\
    \ >= '0' && s[i] <= '9')) {\n                ++count;\n            }\n       \
    \     \n            if (count == n) {\n                if (s[i] == ' ') {\n  \
    \                  v.push_back(s.substr(next_index, i - next_index));\n      \
    \              next_index = i + 1;\n                }\n            }\n       \
    \ }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7b9in8og: /tmp/tmp7b9in8og.cpp:37: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141124
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> v;\n  if (s.size() == 0) {\n    return\
    \ v;\n  }\n  \n  std::string words[s.size() / 2]; // O(logN) \n  \n  for (int\
    \ i = 0; i < s.size(); i++) {\n    words[i / 2].push_back(s[i]);\n  }\n  \n  //\
    \ O(N)\n  for (int i = 0; i < s.size(); i += 2) {\n    if (words[i / 2].size()\
    \ >= n && words[i / 2][0] == s[i + 1]) {\n      v.push_back(words[i / 2]);\n \
    \     words[i / 2].clear();\n    }\n  }\n  \n  return v;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp6olqrkyq: /tmp/tmp6olqrkyq.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141123
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    v.push_back(\"\");\n    if\
    \ (n == 0)\n        return v;\n    if (s.size() == 0) {\n        return v;\n \
    \   }\n    if (s.size() > n) {\n        return v;\n    }\n    vector<string> ret;\n\
    \    for (auto it = s.begin(); it != s.end(); ++it) {\n        for (char c : *it)\
    \ {\n            if (std::find({\"a\",\"e\",\"i\",\"o\",\"u\"}.begin(), {\"a\"\
    ,\"e\",\"i\",\"o\",\"u\"}.end(), c) == s.end() &&\n                std::find({\"\
    A\",\"E\",\"I\",\"O\",\"U\"}.begin(), {\"A\",\"E\",\"I\",\"O\",\"U\"}.end(), c)\
    \ == s.end() &&\n                std::find({\"b\",\"c\",\"d\",\"f\",\"g\",\"h\"\
    ,\"j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\"\
    ,\"y\",\"z\"}.begin(), {\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\"\
    ,\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"y\",\"z\"}.end(),\
    \ c) == s.end() &&\n                std::find({\"B\",\"C\",\"D\",\"F\",\"G\",\"\
    H\",\"J\",\"K\",\"L\",\"M\",\"N\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"V\",\"W\",\"\
    X\",\"Y\",\"Z\"}.begin(), {\"B\",\"C\",\"D\",\"F\",\"G\",\"H\",\"J\",\"K\",\"\
    L\",\"M\",\"N\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"V\",\"W\",\"X\",\"Y\",\"Z\"}.end(),\
    \ c) == s.end() &&\n                std::find({\"1\",\"2\",\"3\",\"4\",\"5\",\"\
    6\",\"7\",\"8\",\"9\"}.begin(), {\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"\
    8\",\"9\"}.end(), c) == s.end() &&\n                std::find({\"!\",\"@\",\"\
    #\",\"$\",\"%\",\"^\",\"&\",\"*\",\"(\",\")\",\"-\",\"_\",\"=\",\"~\",\"`\",\"\
    '\",\"<\",\"[\",\"]\",\"{\",\"}\",\",\",\"<\",\">\",\"/\",\"|\"}.begin(), {\"\
    !\",\"@\",\"#\",\"$\",\"%\",\"^\",\"&\",\"*\",\"(\",\")\",\"-\",\"_\",\"=\",\"\
    ~\",\"`\",\"'\",\"<\",\"[\",\"]\",\"{\",\"}\",\",\",\"<\",\">\",\"/\",\"|\"}.end(),\
    \ c) == \n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwulhz5sf.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpwulhz5sf.cpp:25:5: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   25 |     vector<string>\
    \ ret;\n      |     ^~~~~~\n/tmp/tmpwulhz5sf.cpp:25:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwulhz5sf.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwulhz5sf.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpwulhz5sf.cpp:25:12:\
    \ error: \u2018string\u2019 was not declared in this scope\n   25 |     vector<string>\
    \ ret;\n      |            ^~~~~~\n/tmp/tmpwulhz5sf.cpp:25:12: note: suggested\
    \ alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwulhz5sf.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \  "
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // code here\n  \n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvoccxydi: /tmp/tmpvoccxydi.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if(!s.length()){\n \
    \       return result;\n    }\n    bool flag = false;\n    for(char c:s){\n  \
    \      if(c==' '){\n            flag = false;\n        }\n        else if(flag){\n\
    \            if(c>='a' && c<='z'){\n                flag = false;\n          \
    \  }\n            else{\n                result.push_back(std::string(1, c));\n\
    \                flag = true;\n            }\n        }\n    }\n    for(auto &i:result){\n\
    \        if(i.length()==n){\n            return result;\n        }\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmploldeeas: /tmp/tmploldeeas.cpp:43: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if (s.empty()){\n       \
    \ return v;\n    }\n\n    long count = 0;\n    int i = 0;\n    while (s[i] !=\
    \ '\\0'){\n        if (s[i] == ' ' || s[i] == '\\t' || s[i] == '\\n'){\n     \
    \       continue;\n        }\n        else if (s[i] >= 'A' && s[i] <= 'Z' || s[i]\
    \ >= 'a' && s[i] <= 'z'){\n            i++;\n            continue;\n        }\n\
    \        else if (s[i] == 'W'){\n            v.push_back(s.substr(0, i+1));\n\
    \            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\0'){\n  \
    \              i++;\n            }\n            continue;\n        }\n       \
    \ else if (s[i] == 'B'){\n            v.push_back(s.substr(0, i+1));\n       \
    \     i += 2;\n            while (s[i] != '\\n' && s[i] != '\\0'){\n         \
    \       i++;\n            }\n            count++;\n            continue;\n   \
    \     }\n        else if (s[i] == 'C'){\n            v.push_back(s.substr(0, i+1));\n\
    \            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\0'){\n  \
    \              i++;\n            }\n            count += 2;\n            continue;\n\
    \        }\n        else if (s[i] == 'D'){\n            v.push_back(s.substr(0,\
    \ i+1));\n            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\\
    0'){\n                i++;\n            }\n            count += 3;\n         \
    \   continue;\n        }\n        else if (s[i] == 'F'){\n            v.push_back(s.substr(0,\
    \ i+1));\n            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\\
    0'){\n                i++;\n            }\n            count += 4;\n         \
    \   continue;\n        }\n        else if (s[i] == 'S'){\n            v.push_back(s.substr(0,\
    \ i+1));\n            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\\
    0'){\n                i++;\n            }\n            count += 5;\n         \
    \   continue;\n        }\n        else if (s[i] == 'T'){\n            v.push_back(s.substr(0,\
    \ i+1));\n            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\\
    0'){\n                i++;\n            }\n            count += 6;\n         \
    \   continue;\n        }\n        else if (s[i] == 'H'){\n            v.push_back(s.substr(0,\
    \ i+1));\n            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\\
    0'){\n                i++;\n            }\n            count += 7;\n         \
    \   continue;\n        }\n        else if (s[i] == 'V'){\n            v.push_back(s.substr(0,\
    \ i+1));\n            i += 2;\n            while (s[i] != '\\n' && s[i] != '\\\
    0'){\n                i++;\n            }\n            count += 8;\n         \
    \   continue;\n        }\n        else if (s[i] == 'L')\n}\nint main() {\n   \
    \ auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjui5jjbx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpjui5jjbx.cpp:111:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n  111 | }\n      | ^\n\
    /tmp/tmpjui5jjbx.cpp:112:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  112 | int main() {\n      |            ^\n/tmp/tmpjui5jjbx.cpp:121:1:\
    \ error: expected \u2018}\u2019 at end of input\n  121 | }\n      | ^\n/tmp/tmpjui5jjbx.cpp:14:62:\
    \ note: to match this \u2018{\u2019\n   14 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmpjui5jjbx.cpp:121:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n  121 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if (s.size() == 0) {\n  \
    \      return v;\n    }\n    std::vector<bool> v(s.size(), false);\n    for (char\
    \ c: s) {\n        v.push_back(c);\n    }\n    \n    // first pass to check n\n\
    \    long curr_idx = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if\
    \ (!v[i]) {\n            curr_idx = i;\n            break;\n        }\n    }\n\
    \    if (curr_idx == s.size()) return v;\n\n    curr_idx = 0;\n    std::string\
    \ word = \"\";\n    for (int i = 0; i < s.size(); i++) {\n        if (!v[i] &&\
    \ i != curr_idx) {\n            v.push_back(word);\n            curr_idx = i;\n\
    \            word = \"\";\n        }\n        \n        word += s[i];\n    }\n\
    \    v.push_back(word);\n    return v;\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppqhp1phu.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppqhp1phu.cpp:19:23: error:\
    \ conflicting declaration \u2018std::vector<bool> v\u2019\n   19 |     std::vector<bool>\
    \ v(s.size(), false);\n      |                       ^\n/tmp/tmppqhp1phu.cpp:15:30:\
    \ note: previous declaration as \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > v\u2019\n   15 |     std::vector<std::string> v;\n      |                \
    \              ^\n/tmp/tmppqhp1phu.cpp:21:22: error: no matching function for\
    \ call to \u2018std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\
    \n   21 |         v.push_back(c);\n      |                      ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppqhp1phu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back"
  stdout: ''
  timestamp: 1660141121
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.length() == 0) return {};\n    \n    std::unordered_set<char>\
    \ set;\n    for(auto& c: s) \n        set[c] = true;\n    \n    std::vector<std::string>\
    \ res;\n    for(auto &c: s) \n        if(set.count(c) == n) res.push_back(c);\n\
    \    return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_xz1zgy0.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp_xz1zgy0.cpp:19:12: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::unordered_set<char>\u2019\
    \ and \u2018char\u2019)\n   19 |         set[c] = true;\n      |            ^\n\
    /tmp/tmp_xz1zgy0.cpp:23:46: error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   23 |         if(set.count(c) == n) res.push_back(c);\n\
    \      |                                              ^\nIn file included from\
    \ /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xz1zgy0.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argumen"
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> res;\n    std::string\
    \ temp = \"\";\n    int i = 0;\n    for (int i = 0; i < s.length(); i++) {\n \
    \       if (s[i] != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' &&\n    \
    \        s[i] != 'u') {\n            temp += s[i];\n        }\n        if (i ==\
    \ (s.length() - 1) || i == s.length() - 2 && s[i] != 'a' &&\n            s[i]\
    \ != 'e' && s[i] != 'i' && s[i] != 'o' && s[i] != 'u') {\n            if (!temp.empty())\
    \ {\n                if (n == 0) {\n                    res.push_back(temp);\n\
    \                } else {\n                    long n1 = (temp.length() + n) /\
    \ 2;\n                    long n2 = n - n1;\n                    std::vector<string>\
    \ temp1 = select_words(temp, n1);\n                    std::vector<string> temp2\
    \ = select_words(temp, n2);\n                    res.insert(res.end(), temp1.begin(),\
    \ temp1.end());\n                    res.insert(res.end(), temp2.begin(), temp2.end());\n\
    \                }\n                temp.clear();\n            }\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprqbowik1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmprqbowik1.cpp:32:33: error:\
    \ \u2018string\u2019 was not declared in this scope\n   32 |                 \
    \    std::vector<string> temp1 = select_words(temp, n1);\n      |            \
    \                     ^~~~~~\n/tmp/tmprqbowik1.cpp:32:33: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprqbowik1.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmprqbowik1.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmprqbowik1.cpp:32:39: error: template argument 1 is invalid\n   32 |   \
    \                  std::vector<string> temp1 = select_words(temp, n1);\n     \
    \ |                                       ^\n/tmp/tmprqbowik1.cpp:32:39: error:\
    \ template argument 2 is invalid\n/tmp/tmprqbowik1.cpp:32:61: error: cannot convert\
    \ \u2018std::vector<std::__cxx11::basic_string<char> >\u2019 to \u2018int\u2019\
    \ in initialization\n   32 |        "
  stdout: ''
  timestamp: 1660141121
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::ifstream fin(s);\n    std::string str;\n    if (fin)\n\
    \    {\n        while (!fin.eof())\n        {\n            getline(fin, str);\n\
    \        }\n    }\n    else\n    {\n        return {};\n    }\n\n    std::vector<std::string>\
    \ ans;\n    for (auto & i : str)\n    {\n        if ((i.size() >= n) && (std::all_of(i.begin(),\
    \ i.end(), std::isalpha)))\n        {\n            ans.emplace_back(i);\n    \
    \    }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8lvgq6uy.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp8lvgq6uy.cpp:32:16: error:\
    \ request for member \u2018size\u2019 in \u2018i\u2019, which is of non-class\
    \ type \u2018char\u2019\n   32 |         if ((i.size() >= n) && (std::all_of(i.begin(),\
    \ i.end(), std::isalpha)))\n      |                ^~~~\n/tmp/tmp8lvgq6uy.cpp:32:47:\
    \ error: request for member \u2018begin\u2019 in \u2018i\u2019, which is of non-class\
    \ type \u2018char\u2019\n   32 |         if ((i.size() >= n) && (std::all_of(i.begin(),\
    \ i.end(), std::isalpha)))\n      |                                          \
    \     ^~~~~\n/tmp/tmp8lvgq6uy.cpp:32:58: error: request for member \u2018end\u2019\
    \ in \u2018i\u2019, which is of non-class type \u2018char\u2019\n   32 |     \
    \    if ((i.size() >= n) && (std::all_of(i.begin(), i.end(), std::isalpha)))\n\
    \      |                                                          ^~~\nIn file\
    \ included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp8lvgq6uy.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h: In instantiation\
    \ of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with\
    \ _Up = std::__cxx11::basic_string<char>; _Args = {char&}; _Tp = std::__cxx11::basic_string<char>]\u2019\
    :\n/usr/include/c++/9/bits/alloc_traits.h:483:4:   required from \u2018static\
    \ void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT>\
    \ >::allocator_type&, _Up*, _Args&& ."
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.empty()) return {};\n    // write your code here\n  \
    \  return {}; \n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpkp7ps0ts: /tmp/tmpkp7ps0ts.cpp:21: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> vec;\n    if (s.empty()) {\n    \
    \    return vec;\n    }\n    \n    // For this problem, we only care about consonants.\n\
    \    char consonants[] = { 'b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n',\
    \ 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'z' };\n    int n = s.size();\n    int\
    \ nConsonants = n;\n    long n = n;\n    \n    for (int i = 0; i < n; i++) {\n\
    \        std::string ss = s.substr(i, 1);\n        // if ss has a consonant at\
    \ position i, add it to vec, then increase n by 1.\n        if (ss.size() > 1)\
    \ {\n            \n            for (int j = 1; j < ss.size(); j++) {\n       \
    \         if (consonants[(int)ss[j] - 'a'] == 1) {\n                    vec.push_back(ss);\n\
    \                    nConsonants++;\n                    n--;\n              \
    \      break;\n                }\n            }\n        }\n    }\n    if (nConsonants\
    \ == n) {\n        return vec;\n    }\n    \n    return vec;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpofveasf1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpofveasf1.cpp:22:9: error:\
    \ declaration of \u2018int n\u2019 shadows a parameter\n   22 |     int n = s.size();\n\
    \      |         ^\n/tmp/tmpofveasf1.cpp:24:10: error: conflicting declaration\
    \ \u2018long int n\u2019\n   24 |     long n = n;\n      |          ^\n/tmp/tmpofveasf1.cpp:22:9:\
    \ note: previous declaration as \u2018int n\u2019\n   22 |     int n = s.size();\n\
    \      |         ^\n"
  stdout: ''
  timestamp: 1660141121
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) return {};\n    std::vector<std::string> v;\n\
    \    for (auto c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u') {\n            v.push_back(c);\n        }\n    }\n    std::vector<std::string>\
    \ v;\n    for (auto c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' || c == 'y') {\n            v.push_back(c);\n        }\n\
    \    }\n    std::vector<std::string> v;\n    for (auto c : s) {\n        if (c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' || c == 's')\
    \ {\n            v.push_back(c);\n        }\n    }\n    std::vector<std::string>\
    \ v;\n    for (auto c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' || c == 'y' || c == 's' || c == 'h' || c == 'l' || c ==\
    \ 'm' || c == 'n' || c == 't' || c == 'w' || c == 'd' || c == 'k' || c == 'b'\
    \ || c == 'e' || c == 'r') {\n            v.push_back(c);\n        }\n    }\n\
    \    std::vector<std::string> v;\n    for (auto c : s) {\n        if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' || c == 's' || c\
    \ == 'h' || c == 'l' || c == 'm' || c == 'n' || c == 't' || c == 'w' || c == 'd'\
    \ || c == 'k' || c == 'b' || c == 'e' || c == 'r' || c == 'n' || c == 'g' || c\
    \ == 'h' || c == 'l' || c == 'm' || c == 'n' || c == 't' || c == 'w' || c == 'd'\
    \ || c == 'k' || c == 'b' || c == 'e' || c == 'r' || c == 'n' || c == 'g') {\n\
    \            v.push_back(c);\n        }\n    }\n    std::vector<std::string> v;\n\
    \    for (auto c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y' || c == 's' || c == 'h' || c == 'l' || c == 'm'\
    \ || c == 'n' || c == 't' || c == 'w' || c == 'd' || c == 'k' || c == 'b' || c\
    \ == 'e' || c == 'r' || c == 'n' || c == 'g' || c == 'h' || c == 'l' || c == 'm'\
    \ || c == 'n' || c == 't' || c == 'w' || c == 'd\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmajfqkpr.cpp:48:330: warning: missing terminating ' character\n\
    \   48 |         if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y' || c == 's' || c == 'h' || c == 'l' || c == 'm' || c == 'n' || c\
    \ == 't' || c == 'w' || c == 'd' || c == 'k' || c == 'b' || c == 'e' || c == 'r'\
    \ || c == 'n' || c == 'g' || c == 'h' || c == 'l' || c == 'm' || c == 'n' || c\
    \ == 't' || c == 'w' || c == 'd\n      |                                     \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                 ^\n/tmp/tmpmajfqkpr.cpp:48:330:\
    \ error: missing terminating ' character\n   48 |         if (c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y' || c == 's' || c == 'h'\
    \ || c == 'l' || c == 'm' || c == 'n' || c == 't' || c == 'w' || c == 'd' || c\
    \ == 'k' || c == 'b' || c == 'e' || c == 'r' || c == 'n' || c == 'g' || c == 'h'\
    \ || c == 'l' || c == 'm' || c == 'n' || c == 't' || c == 'w' || c == 'd\n   \
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                              ^~\n/tmp/tmpmajfqkpr.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpmajfqkpr.cpp:19:26: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   19 |             v.push_back(c);\n      |    \
    \                      ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c+"
  stdout: ''
  timestamp: 1660141122
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    // Write your code here\n\
    \    if(!s.empty()) {\n        std::string new_word = \"\";\n        for(char\
    \ c : s) {\n            if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n                new_word += c;\n            }\n        }\n        if(new_word\
    \ == s) {\n            words.push_back(new_word);\n        }\n        for(char\
    \ c : s) {\n            if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u') {\n                while(new_word != s) {\n                    if(!s.empty())\
    \ {\n                        if(s.front() != 'a' && s.front() != 'e' && s.front()\
    \ != 'i' && s.front() != 'o' && s.front() != 'u') {\n                        \
    \    new_word += c;\n                        }\n                    }\n      \
    \              else {\n                        words.push_back(new_word);\n  \
    \                  }\n                    if(!s.empty()) {\n                 \
    \       if(s.front() != 'a' && s.front() != 'e' && s.front() != 'i' && s.front()\
    \ != 'o' && s.front() != 'u') {\n                            new_word += c;\n\
    \                        }\n                    }\n                    else {\n\
    \                        words.push_back(new_word);\n                    }\n \
    \               }\n            }\n        }\n    }\n    words.clear();\n    return\
    \ words;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    long max = 0;\n    for(auto\
    \ i : s) {\n        if(isalpha(i)) {\n            max = i;\n            max =\
    \ max > n ? max : n;\n        } else {\n            v.push_back(\"\");\n     \
    \   }\n    }\n    if(s.empty()) {\n        return v;\n    }\n    v.push_back(\"\
    \");\n    for(auto i : s) {\n        if(isalpha(i) && i > 0) {\n            v.push_back(s);\
    \ \n            max = i;\n        }\n    }\n    return v;\n}\nint main() {\n \
    \   auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpl46jz47i: /tmp/tmpl46jz47i.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141123
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    // 1. convert the string to lowercase\
    \ \n    // 2. split the string by space \n    // 3. create an empty vector to\
    \ store words that are repeated in s \n    // 4. traverse the string and store\
    \ the words in vector if they are repeated more than n times \n    // 5. return\
    \ vector \n    std::vector<std::string> ans;\n    std::transform(s.begin(), s.end(),\
    \ s.begin(), ::tolower);\n    std::istringstream str(s);\n    std::string word;\n\
    \    while (std::getline(str, word, ' ')) {\n        std::transform(word.begin(),\
    \ word.end(), word.begin(), ::tolower);\n        if (ans.find(word) == ans.end())\
    \ {\n            ans.push_back(word);\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmc8ta6zf.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpmc8ta6zf.cpp:27:17: error:\
    \ \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member\
    \ named \u2018find\u2019\n   27 |         if (ans.find(word) == ans.end()) {\n\
    \      |                 ^~~~\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end());\n    std::map<char, int> m;\n\
    \    for(auto &c: s) {\n        if(m.find(c) != m.end()) {\n            m[c] +=\
    \ 1;\n        } else {\n            m[c] = 1;\n        }\n    }\n    std::vector<std::string>\
    \ res;\n    for(auto &c: m) {\n        if(c[1] == n) {\n            res.push_back(std::to_string(c[0]));\n\
    \        }\n    }\n    if(res.size() == 0) {\n        return std::vector<std::string>();\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplr_cauge.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmplr_cauge.cpp:26:13: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::pair<const\
    \ char, int>\u2019 and \u2018int\u2019)\n   26 |         if(c[1] == n) {\n   \
    \   |             ^\n/tmp/tmplr_cauge.cpp:27:43: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::pair<const char, int>\u2019 and \u2018int\u2019\
    )\n   27 |             res.push_back(std::to_string(c[0]));\n      |         \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code here\n    std::vector<std::string> v;\n    std::string\
    \ temp;\n    for (auto &it=s.begin();it!=s.end();++it){\n        if(it==s.begin()){\n\
    \            v.push_back(temp);\n            temp=*it;\n        }\n        if(temp.size()==n){\n\
    \            v.push_back(temp);\n            temp=*it;\n        }\n        if(temp.size()==0){\n\
    \            v.push_back(temp);\n            temp=*it;\n        }\n    }\n   \
    \ return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdjw20ll6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpdjw20ll6.cpp:18:26: error:\
    \ cannot bind non-const lvalue reference of type \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >&\u2019 to an rvalue of type \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019}\n   18 |     for (auto &it=s.begin();it!=s.end();++it){\n      |  \
    \                 ~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    assert(s.length() > 0);\n    // Write your code here.\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpzz83j5rr: /tmp/tmpzz83j5rr.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141123
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  \n    std::vector<std::string> result;\n    long len = s.length();\n\
    \    long cnt = 0;\n    long i = 0;\n    while (i+n <= len) {\n      cnt = 0;\n\
    \      long j = 0;\n      while (j <= n-cnt) {\n        if (s[i+j] != 'a' && s[i+j]\
    \ != 'e' && s[i+j] != 'i' && s[i+j] != 'o' && s[i+j] != 'u') {\n          cnt++;\n\
    \          j++;\n        } else {\n          j++;\n        }\n      }\n      if\
    \ (cnt == n) {\n        result.push_back(s.substr(i,n));\n      }\n      i +=\
    \ n;\n    }\n    return result;\n  }\n</code>\n<|/ a tags=string,algorithm,c++\
    \ |>\n<| c |>\nThank you for taking the time to write such a detailed answer.\
    \ Unfortunately it is not exactly what I am looking for. I am looking for a method\
    \ that does not use `vector` but `string` instead. My code above was actually\
    \ not using `vector` but `string`, but I just wanted to write it as a simple example\
    \ for my question. Thanks again.\n<|/ c |>\n<| c |>\nAs the requirements state,\
    \ \"You have been tasked to implement a function that returns a list of all words\
    \ from string s that contain exactly n consonants, in order these words appear\
    \ in the string s.\" - it seems like a reasonable implementation would be to not\
    \ use a `vector` but rather a `string` if you wanted to stick to that data type.\
    \  If you really want to use a `vector` then you could use `vector::reserve()`\
    \ before you start adding items to it, but you would have to `push_back()` the\
    \ items into the vector afterwards.\n<|/ c |>\n<| c |>\nI have edited my answer.\
    \ I hope it helps. I hope you learn something.\n<|/ c |>\n<| a tags=string,algorithm,c++\
    \ dscore=0 |>\nYou can use vector to hold all words and use back_inserter to insert\
    \ elements into vector:\n<code>\n#include <iostream>\n#include <string>\n#include\
    \ <vector>\n#include <iterator>\n\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n\n    std::vector<std::string> vec;\n\n    long len = s.length();\n\
    \    long cnt = 0;\n    long i = 0;\n    while (i+n <= len) {\n        cnt = 0;\n\
    \        long j = 0;\n        while (j <= n-cnt) {\n            if (s[i+j] !=\
    \ 'a' && s[i+j] != 'e' && s[i+j] != 'i' && s[i+j] != 'o' && s[i+j] != 'u') {\n\
    \                cnt++;\n                j++;\n            } else {\n        \
    \        j++;\n            }\n        }\n        if (cnt == n) {\n           \
    \ \n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdavpztm7.cpp:41:163: error: stray \u2018`\u2019 in program\n  \
    \ 41 | Thank you for taking the time to write such a detailed answer. Unfortunately\
    \ it is not exactly what I am looking for. I am looking for a method that does\
    \ not use `vector` but `string` instead. My code above was actually not using\
    \ `vector` but `string`, but I just wanted to write it as a simple example for\
    \ my question. Thanks again.\n      |                                        \
    \                                                                            \
    \                                               ^\n/tmp/tmpdavpztm7.cpp:41:170:\
    \ error: stray \u2018`\u2019 in program\n   41 | Thank you for taking the time\
    \ to write such a detailed answer. Unfortunately it is not exactly what I am looking\
    \ for. I am looking for a method that does not use `vector` but `string` instead.\
    \ My code above was actually not using `vector` but `string`, but I just wanted\
    \ to write it as a simple example for my question. Thanks again.\n      |    \
    \                                                                            \
    \                                                                            \
    \              ^\n/tmp/tmpdavpztm7.cpp:41:176: error: stray \u2018`\u2019 in program\n\
    \   41 | Thank you for taking the time to write such a detailed answer. Unfortunately\
    \ it is not exactly what I am looking for. I am looking for a method that does\
    \ not use `vector` but `string` instead. My code above was actually not using\
    \ `vector` but `string`, but I just wanted to write it as a simple example for\
    \ my question. Thanks again.\n      |                                        \
    \                                                                            \
    \                                                            ^\n/tmp/tmpdavpztm7.cpp:41:183:\
    \ error: stray \u2018`\u2019 in program\n   41 | Thank you for taking the time\
    \ to write such a detailed answer. Unfortunately it is not exactly what I am looking\
    \ for. I am looking for a method that does not use `vector` but `string` instead.\
    \ My code above was actually not using `vec"
  stdout: ''
  timestamp: 1660141121
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    int k = s.length();\n    if(k == 0)\n        return {};\n\
    \    std::vector<string> res;\n    stack<string> stack;\n    stack.push(s);\n\
    \    while(k > 0) {\n        if(s.at(0) != ' ')\n            s.push(s.at(0));\n\
    \        else {\n            string tmp = s.at(1);\n            s.pop();\n   \
    \         if(!stack.empty() && stack.top() == tmp)\n                res.push_back(tmp);\n\
    \            else if(stack.size() > 0)\n                stack.push(tmp);\n   \
    \         else {\n                res.push_back(tmp);\n                res.push_back(tmp\
    \ + \" \" + s.at(1));\n                s.pop();\n            }\n        }\n  \
    \      --k;\n    }\n    while(!stack.empty())\n        res.push_back(stack.top());\n\
    \    return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp42zd72b_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp42zd72b_.cpp:18:17: error:\
    \ \u2018string\u2019 was not declared in this scope\n   18 |     std::vector<string>\
    \ res;\n      |                 ^~~~~~\n/tmp/tmp42zd72b_.cpp:18:17: note: suggested\
    \ alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp42zd72b_.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp42zd72b_.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmp42zd72b_.cpp:18:23: error: template argument 1 is invalid\n   18 |   \
    \  std::vector<string> res;\n      |                       ^\n/tmp/tmp42zd72b_.cpp:18:23:\
    \ error: template argument 2 is invalid\n/tmp/tmp42zd72b_.cpp:19:5: error: \u2018\
    stack\u2019 was not declared in this scope; did you mean \u2018std::stack\u2019\
    ?\n   19 |     stack<string> stack;\n      |     ^~~~~\n      |     std::stack\n\
    In file included from /usr/include/c++/9/stack:61,\n                 from /usr/includ"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n   std::vector<std::string> v;\n   std::stack<std::string> st;\n\
    \   v.push_back(\"\");\n   while(!st.empty()) {\n       std::string word = \"\"\
    ;\n       std::string newStr = st.top();\n       st.pop();\n       int i = 0;\n\
    \       while (i<newStr.size()) {\n           if (newStr[i] == s[i]) {\n     \
    \          word = word + newStr[i];\n               i++;\n           } else {\n\
    \               if (word == \"\" && i<newStr.size() && newStr[i]!=' ') {\n   \
    \                word = newStr[i];\n                   i++;\n               }\n\
    \           }\n           i++;\n       }\n       if(word == \"\") {\n        \
    \   break;\n       }\n       v.push_back(word);\n   }\n   return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpjetb0fmx: /tmp/tmpjetb0fmx.cpp:44: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code here\n    std::vector<std::string> word_vec;\n\
    \    std::string word = \"\";\n    for(int i=0;i<s.length();i++){\n        if(s[i]\
    \ == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n      \
    \      word += s[i];\n        else\n            word += \"a\";\n        if(word.length()\
    \ == n && word[0] == 'a')\n            word_vec.push_back(word);\n    }\n    return\
    \ word_vec;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp3gdhkkt4: /tmp/tmp3gdhkkt4.cpp:30: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141124
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    vector<string> v;\n\
    \    for (auto x: s)\n        v.push_back(x);\n    sort(v.begin(), v.end());\n\
    \    if (v.size()==0) return result;\n    long long int t = 0;\n    for (auto\
    \ x: v)\n        t += x;\n    vector<string> temp;\n    for (auto x: v) \n   \
    \     if (t==n) temp.push_back(x);\n    if (temp.size()==0) return result;\n \
    \   for (auto x: temp) {\n        result.push_back(x);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0ghc16lp.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp0ghc16lp.cpp:16:5: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   16 |     vector<string>\
    \ v;\n      |     ^~~~~~\n/tmp/tmp0ghc16lp.cpp:16:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0ghc16lp.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0ghc16lp.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp0ghc16lp.cpp:16:12:\
    \ error: \u2018string\u2019 was not declared in this scope\n   16 |     vector<string>\
    \ v;\n      |            ^~~~~~\n/tmp/tmp0ghc16lp.cpp:16:12: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0ghc16lp.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> res;\n    std::string\
    \ temp;\n    int len = s.size();\n    for (int i = 0; i < len; i = i + n) {\n\
    \        for (int j = 0; j < n; j++)\n            if (s[i + j] == ' ') {\n   \
    \             res.push_back(temp);\n                temp.clear();\n          \
    \  }\n            temp += s[i];\n        if (temp.length() > 0)\n            res.push_back(temp);\n\
    \        temp.clear();\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp3ov2p1z0: /tmp/tmp3ov2p1z0.cpp:34: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141124
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code here\n    std::vector<std::string> result;\n\
    \    if (s.empty()) {\n        return result;\n    }\n    std::string current_word\
    \ = s;\n    while ((s.size()-1)%n != 0) {\n        current_word = s.substr(0,\
    \ s.size()-1);\n        result.push_back(current_word);\n    }\n    if (s.size()%n\
    \ != 0) {\n        std::vector<std::string> words = select_words(s, n);\n    \
    \    result.insert(result.end(), words.begin(), words.end());\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141128
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    return {};\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_5snm6lg: /tmp/tmp_5snm6lg.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> v;\n  v.reserve(s.size());\n  for (size_t\
    \ i = 0; i < s.size(); ++i) {\n    v.push_back(s.substr(i, n));\n  }\n  return\
    \ v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvnt18cei: /tmp/tmpvnt18cei.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    \n    // base case\n    if\
    \ ( s.empty() ) {\n        return v;\n    }\n    \n    // split string s into\
    \ word tokens\n    std::vector<std::string> ssplit(s.begin(), s.end(), ' ');\n\
    \    \n    // for each word token ssplit\n    for ( std::vector<std::string>::size_type\
    \ i = 0; i < ssplit.size(); ++i ) {\n        \n        // if current word token\
    \ is long enough, add it to list\n        if ( ssplit[i].size() >= n ) {\n   \
    \         v.push_back(ssplit[i]);\n        }\n    }\n    \n    return v;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvfyn5kmr.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpvfyn5kmr.cpp:23:60: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::vector(std::__cxx11::basic_string<char>::iterator, std::__cxx11::basic_string<char>::iterator,\
    \ char)\u2019\n   23 |     std::vector<std::string> ssplit(s.begin(), s.end(),\
    \ ' ');\n      |                                                            ^\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvfyn5kmr.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /usr/include/c++/9/bits/stl_vector.h:650:2: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpvfyn5kmr.cpp:23:57: note:   cannot convert \u2018' '\u2019\
    \ (type \u2018char\u2019) to type \u2018const allocator_type&\u2019 {aka \u2018\
    const std::allocator<std::__cxx11::basic_string<char> >&\u2019}\n   23 |     std::vector<std::string>\
    \ ssplit(s.begin(), s.end(), ' ');\n      |                                  \
    \                       ^~~\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvfyn5kmr.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:622:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>,\
    \ const allocator_type&) [with"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // Write your code here.\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpwkjt_j_i: /tmp/tmpwkjt_j_i.cpp:19: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141123
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ret;\n    if (s.size() == 0 || n\
    \ < 0) {\n        return ret;\n    }\n    std::string t;\n    size_t pos = 0;\n\
    \    while (pos < s.size()) {\n        t = s.substr(pos, 1);\n        pos = std::find(t.begin(),\
    \ t.end(), ' ');\n        if (pos == t.end()) {\n            ret.push_back(t);\n\
    \        }\n        pos = std::find(t.begin(), t.end(), '!');\n        if (pos\
    \ == t.end()) {\n            ret.push_back(t);\n        }\n        pos = std::find(t.begin(),\
    \ t.end(), '.');\n        if (pos == t.end()) {\n            ret.push_back(t);\n\
    \        }\n        pos = std::find(t.begin(), t.end(), ',');\n        if (pos\
    \ == t.end()) {\n            ret.push_back(t);\n        }\n        pos = std::find(t.begin(),\
    \ t.end(), ':');\n        if (pos == t.end()) {\n            ret.push_back(t);\n\
    \        }\n        pos = std::find(t.begin(), t.end(), ';');\n        if (pos\
    \ == t.end()) {\n            ret.push_back(t);\n        }\n        pos = std::find(t.begin(),\
    \ t.end(), '?');\n        if (pos == t.end()) {\n            ret.push_back(t);\n\
    \        }\n        pos = std::find(t.begin(), t.end(), '/');\n        if (pos\
    \ == t.end()) {\n            ret.push_back(t);\n        }\n        pos = std::find(t.begin(),\
    \ t.end(), ' ');\n        if (pos == t.end()) {\n            ret.push_back(t);\n\
    \        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxx7gyez1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpxx7gyez1.cpp:23:24: error:\
    \ cannot convert \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018size_t\u2019 {aka \u2018long unsigned int\u2019} in assignment\n\
    \   23 |         pos = std::find(t.begin(), t.end(), ' ');\n      |          \
    \     ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~\n      |                        |\n \
    \     |                        __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\n/tmp/tmpxx7gyez1.cpp:24:17: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018size_t\u2019 {aka \u2018long unsigned int\u2019} and \u2018\
    std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019})\n   24 |         if (pos == t.end())\
    \ {\n      |             ~~~ ^~ ~~~~~~~\n      |             |           |\n \
    \     |             |           std::__cxx11::basic_string<char>::iterator {aka\
    \ __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >}\n  \
    \    |             size_t {aka long unsigned int}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpxx7gyez1.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpxx7gyez1.cpp:24:26: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018size"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    // Write your code here\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpy_wbuvkz: /tmp/tmpy_wbuvkz.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if (!s.empty()) {\n     \
    \   v.push_back(s);\n        while (v.back().size() < n) {\n            v.back()\
    \ += v.back();\n        }\n        v.erase(v.begin(), v.end() - n);\n    }\n \
    \   return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    res.reserve(s.size());\n\
    \    // TODO:\n    // Implement the select_words function here\n    return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpawvrimh6: /tmp/tmpawvrimh6.cpp:23: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(!s.size()) {\n     \
    \   return res;\n    }\n    std::unordered_set<char> seen;\n    for(char c : s)\
    \ {\n        seen[c] = true;\n    }\n    for(char c : s) {\n        if(seen.count(c)\
    \ == n) {\n            std::string cur = std::to_string(c);\n            res.push_back(cur);\n\
    \            seen[c] = false;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxqc8kwyj.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpxqc8kwyj.cpp:21:13: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::unordered_set<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         seen[c] = true;\n      |            \
    \ ^\n/tmp/tmpxqc8kwyj.cpp:27:17: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::unordered_set<char>\u2019 and \u2018char\u2019)\n   27\
    \ |             seen[c] = false;\n      |                 ^\n"
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if (n == 0 || s == \"\
    \") return result;\n    \n    size_t pos = 0, end = s.size();\n    while (pos\
    \ < end) {\n        pos = s.find_first_not_of(\"aeiouAEIOU\", end);\n        if\
    \ (pos == std::string::npos)\n            break;\n        if (s[pos] == ' ' ||\
    \ s[pos] == '\\n' || s[pos] == '\\t') \n            break;\n        if (n <= end\
    \ - pos - 1)\n            result.push_back(s.substr(pos, end - pos));\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmphdqwchdu: /tmp/tmphdqwchdu.cpp:32: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // ++n;\n    // if(n < 0) {\n    //     return {};\n    //\
    \ }\n    // std::vector<std::string> ans;\n    // for(int i = 0; i < s.size();\
    \ i++) {\n    //     if(s[i] == ' ' || s[i] == '.' || s[i] == '!' || s[i] == '?'\
    \ || s[i] == '~')\n    //         continue;\n    //     for(int j = 0; j < n;\
    \ j++) {\n    //         if(s[i] == s[j]) {\n    //             ans.push_back(s.substr(i,\
    \ j+1));\n    //             break;\n    //         }\n    //     }\n    // }\n\
    \    std::vector<std::string> ans;\n    for(int i = 0; i < s.size(); i++) {\n\
    \        if(s[i] == ' ' || s[i] == '.' || s[i] == '!' || s[i] == '?' || s[i] ==\
    \ '~')\n            continue;\n        for(int j = 0; j < n; j++) {\n        \
    \    if(s[i] == s[j]) {\n                ans.push_back(s.substr(i, j+1));\n  \
    \              break;\n            }\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpuai0ycfm: /tmp/tmpuai0ycfm.cpp:45: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141126
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code goes here\n\tstd::vector<std::string> v;\n\t\
    if(s.empty())\n\t\treturn v;\n\t\n\tint i,j;\n\tfor(int i=0;i<s.size();i++){\n\
    \t\tfor(int j=i;j<s.size();j++){\n\t\t\tif(s[j]==' ')\n\t\t\t\ti++;\n\t\t\telse\
    \ if(s[i]=='s'&&s[j]=='a'&&s[j+1]=='m'&&s[j+2]=='y'){\n\t\t\t\tif(j+3<=s.size()&&s[j+3]=='a'){\n\
    \t\t\t\t\tif(j+4<=s.size()&&s[j+4]=='m'){\n\t\t\t\t\t\tif(j+5<=s.size()&&s[j+5]=='y'){\n\
    \t\t\t\t\t\t\tv.push_back(s+(i+1)+(j+1)+(i+2)+(j+2)+(i+3)+(j+3));\n\t\t\t\t\t\t\
    \ti+=2;\n\t\t\t\t\t\t\tj+=3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\
    v.push_back(s+(i+1)+(j+1)+(i+2)+(j+2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\
    else{\n\t\t\t\t\t\tv.push_back(s+(i+1)+(j+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\
    \telse{\n\t\t\t\t\tv.push_back(s+(i+1));\n\t\t\t\t}\n\t\t\t\tj+=2;\n\t\t\t}\n\t\
    \t\telse if(s[i]=='s'&&s[j]=='a'&&s[j+1]=='l'){\n\t\t\t\tif(j+2<=s.size()&&s[j+2]=='l'){\n\
    \t\t\t\t\tif(j+3<=s.size()&&s[j+3]=='e'){\n\t\t\t\t\t\tif(j+4<=s.size()&&s[j+4]=='d'){\n\
    \t\t\t\t\t\t\tv.push_back(s+(i+1)+(j+1)+(i+2)+(j+2)+(i+3)+(j+3));\n\t\t\t\t\t\t\
    \ti+=2;\n\t\t\t\t\t\t\tj+=4;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\
    v.push_back(s+(i+1)+(j+1)+(i+2)+(j+2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\
    else{\n\t\t\t\t\t\tv.push_back(s+(i+1)+(j+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\
    \telse{\n\t\t\t\t\tv.push_back(s+(i+1));\n\t\t\t\t}\n\t\t\t\tj+=2;\n\t\t\t}\n\t\
    \t\telse if(s[i]=='s'&&s[j]=='a'&&s[j+1]=='b'){\n\t\t\t\tif(j+2<=s.size()&&s[j+2]=='b'){\n\
    \t\t\t\t\tif(j+3<=s.size()&&s[j+3]=='a'){\n\t\t\t\t\t\tif(j+4<=s.size()&&s[j+4]=='m'){\n\
    \t\t\t\t\t\t\tif(j+5<=s.size()&&s[j+5]=='l'){\n\t\t\t\t\t\t\t\tif(j+6<=s.size()&&s[j+6]=='e'){\n\
    \t\t\t\t\t\t\t\t\tv.push_back(s+(i+1)+(j+1)+(i+2)+(j\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk2s92_cs.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpk2s92_cs.cpp:29:21: error:\
    \ no match for \u2018operator+\u2019 (operand types are \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} and \u2018int\u2019)\n  \
    \ 29 |        v.push_back(s+(i+1)+(j+1)+(i+2)+(j+2)+(i+3)+(j+3));\n      |   \
    \                 ~^~~~~~\n      |                    |   |\n      |         \
    \           |   int\n      |                    std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpk2s92_cs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpk2s92_cs.cpp:29:26:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   29 |        v.push_back(s+(i+1)+(j+1)+(i+2)+(j+2)+(i+3)+(j+3));\n\
    \      |                          ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpk2s92_cs.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL"
  stdout: ''
  timestamp: 1660141125
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    // Write your code here.\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpeef9wqj1: /tmp/tmpeef9wqj1.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    return {};\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpfaqpi3sk: /tmp/tmpfaqpi3sk.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141126
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) return {};\n    std::stack<std::string> res;\n\
    \    for (int i=0; i<s.size(); i++)\n    {\n        if (s[i] == ' ') continue;\n\
    \        for (char &c : s)\n        {\n            if (c != ' ' && s[i] == c)\n\
    \            {\n                res.push(s.substr(i,1));\n                break;\n\
    \            }\n        }\n    }\n    while (!res.empty())\n    {\n        std::string\
    \ a = res.top();\n        res.pop();\n        for (int i=0; i<a.size(); i++)\n\
    \        {\n            for (char &c : s)\n            {\n                if (c\
    \ != ' ' && a[i] == a[i])\n                {\n                    res.push(s.substr(i,1));\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return res.empty() ? {} : res;\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn1j8czz6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpn1j8czz6.cpp:45:26: error:\
    \ expected primary-expression before \u2018{\u2019 token\n   45 |     return res.empty()\
    \ ? {} : res;\n      |                          ^\n/tmp/tmpn1j8czz6.cpp:45:25:\
    \ error: expected \u2018:\u2019 before \u2018{\u2019 token\n   45 |     return\
    \ res.empty() ? {} : res;\n      |                         ^~\n      |       \
    \                  :\n/tmp/tmpn1j8czz6.cpp:45:26: error: expected primary-expression\
    \ before \u2018{\u2019 token\n   45 |     return res.empty() ? {} : res;\n   \
    \   |                          ^\n/tmp/tmpn1j8czz6.cpp:45:25: error: expected\
    \ \u2018;\u2019 before \u2018{\u2019 token\n   45 |     return res.empty() ? {}\
    \ : res;\n      |                         ^~\n      |                        \
    \ ;\n/tmp/tmpn1j8czz6.cpp:45:29: error: expected primary-expression before \u2018\
    :\u2019 token\n   45 |     return res.empty() ? {} : res;\n      |           \
    \                  ^\n"
  stdout: ''
  timestamp: 1660141125
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> res;\n  if (s.empty())\n    return\
    \ res;\n  for (size_t i = 0; i < s.size(); i++) {\n    if (s.at(i) == '(') {\n\
    \      std::string s = s.substr(0, i);\n      res.push_back(select_words(s, n));\n\
    \    }\n    else if (s.at(i) == ')') {\n      res.push_back(select_words(s.substr(i\
    \ + 1), n));\n    }\n    else if (s.at(i) == ' ') {\n      if (s.size() == 1 ||\
    \ s.at(0) != ' ')\n        res.push_back(select_words(s.substr(i + 1), n));\n\
    \    }\n    else {\n      std::set<char> vowels{'a', 'e', 'i', 'o', 'u'};\n  \
    \    if (vowels.count(s.at(i))) {\n        if (s.size() == 1 || s.at(0) != ' ')\n\
    \          res.push_back(select_words(s.substr(i + 1), n));\n      }\n    }\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4s218sx0.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp4s218sx0.cpp:21:39: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::vector<std::__cxx11::basic_string<char> >)\u2019\n   21 |\
    \       res.push_back(select_words(s, n));\n      |                          \
    \             ^\nIn file included from /usr/include/c++/9/vector:67,\n       \
    \          from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmp4s218sx0.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >"
  stdout: ''
  timestamp: 1660141125
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    std::string word;\n   \
    \ if (s.size() == 0) {\n        return ans;\n    }\n    for (auto &c: s) {\n \
    \       word = word + c;\n        if (c == ' ' || c == '-' || c == '.' || c ==\
    \ '(' || c == ')' || c == '$' || c == '!') {\n            ans.push_back(word);\n\
    \            word = std::string();\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpj44butun: /tmp/tmpj44butun.cpp:31: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(s.empty()) {\n     \
    \   return res;\n    }\n    for(char c:s) {\n        \n        if(c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u')\n            continue;\n     \
    \   if(c == 'b')\n            continue;\n        if(c == 'p')\n            continue;\n\
    \        if(c == 'm')\n            continue;\n        if(c == 'l' || c == 'r'\
    \ || c == 't')\n            continue;\n        if(c == 'n')\n            continue;\n\
    \        if(c == 's')\n            continue;\n        if(c == 'd')\n         \
    \   continue;\n        if(c == 'g')\n            continue;\n        if(c == 'h')\n\
    \            continue;\n        if(c == 'v')\n            continue;\n        if(c\
    \ == 'z')\n            continue;\n        \n        for(int i = 0; i < s.find(c);\
    \ i++) {\n            if(n == s.find(c, i+1)) {\n                res.push_back(s.substr(0,\
    \ i) + s.substr(i+1, s.size()));\n                break;\n            }\n    \
    \    }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpt7py6q1k: /tmp/tmpt7py6q1k.cpp:57: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> result;\n  \n  if(s == \"\") {\n  \
    \  return result;\n  }\n  \n  // Initialize a map with the consonants in the input\
    \ string\n  std::unordered_map<char, bool> c_map;\n  for(char &c : s) {\n    c_map[c]\
    \ = true;\n  }\n\n  // Initialize a map with the words found in string\n  std::unordered_set<std::string>\
    \ s_words;\n  \n  // Traverse through the string\n  for(char &c : s) {\n    if(c_map.count(c)\
    \ == 0) {\n      s_words.insert(c);\n    }\n    else {\n      c_map[c] = false;\n\
    \    }\n  }\n  \n  // Initialize a map to keep track of how many consecutive consonants\
    \ are found\n  std::unordered_map<char, int> c_counter;\n  c_counter[s[0]] = 1;\n\
    \  \n  // Traverse through the string\n  for(char &c : s) {\n    if(c_counter[s][c]\
    \ == n) {\n      result.push_back(s);\n    }\n    else {\n      c_counter[s][c]\
    \ += 1;\n    }\n  }\n  \n  return result;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp64utw_y_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp64utw_y_.cpp:33:23: error:\
    \ no matching function for call to \u2018std::unordered_set<std::__cxx11::basic_string<char>\
    \ >::insert(char&)\u2019\n   33 |       s_words.insert(c);\n      |          \
    \             ^\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp64utw_y_.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:421:7:\
    \ note: candidate: \u2018std::pair<typename std::_Hashtable<_Value, _Value, _Alloc,\
    \ std::__detail::_Identity, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash,\
    \ std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>,\
    \ std::__is_nothrow_invocable<const _Hash&, const _Tp&> > >::value, true, true>\
    \ >::iterator, bool> std::unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(const\
    \ value_type&) [with _Value = std::__cxx11::basic_string<char>; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _Pred = std::equal_to<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; typename std::_Hashtable<_Value, _Value, _Alloc, std::__detail::_Identity,\
    \ _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash,\
    \ std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>,\
    \ std::__is_nothrow_invocable<const _Hash&, const _Tp&> > >::value, true, true>\
    \ >::iterator = std::__detail::_Node_iterator<std::__cxx11::basic_string<char>,\
    \ true, true>; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::value_type =\
    \ std::__cxx11::basic_string<char>]\u2019\n  421 |       insert(const value_type&\
    \ __x)\n      |       ^~~~~~\n/usr/include/c++/9/bits/unordered_set.h:421:32:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::b"
  stdout: ''
  timestamp: 1660141125
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    std::string temp;\n    //\
    \ code here\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpbkzdq2wz: /tmp/tmpbkzdq2wz.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    //your code here\n    if(s.empty()){\n        return {};\n\
    \    }\n    std::vector<std::string> res;\n    auto start = find_if(s.begin(),\
    \ s.end(), isspace);\n    auto end = find_if(s.begin(), s.end(), isspace)[s.size()-1];\n\
    \    auto n = s.size();\n    for(auto it = s.begin(); it != s.end() && it != start;\
    \ it ++){\n        if(*it == 'a' || *it == 'e' || *it == 'i' || *it == 'o' ||\
    \ *it == 'u'){\n            if(end - it == n){\n                res.emplace_back(std::string(it,\
    \ end));\n            }\n            else{\n                it = s.begin();\n\
    \            }\n        }\n        else if(*it == 's' || *it == 't' || *it ==\
    \ 'a' || *it == 'e' || *it == 'i' || *it == 'o' || *it == 'u'){\n            if(end\
    \ - it == n){\n                res.emplace_back(std::string(it, end));\n     \
    \       }\n            else{\n                it = s.begin();\n            }\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9c9qr5u4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp9c9qr5u4.cpp:22:10: error:\
    \ declaration of \u2018auto n\u2019 shadows a parameter\n   22 |     auto n =\
    \ s.size();\n      |          ^\n/tmp/tmp9c9qr5u4.cpp:25:20: error: no match for\
    \ \u2018operator-\u2019 (operand types are \u2018char\u2019 and \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019)\n   25 |             if(end - it ==\
    \ n){\n      |                ~~~ ^ ~~\n      |                |     |\n     \
    \ |                char  __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n      \
    \           from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp9c9qr5u4.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:974:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ decltype ((__lhs.base() - __rhs.base())) __gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\
    \n  974 |     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\
    \      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:974:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp9c9qr5u4.cpp:25:22: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n   25 |             if(end - it == n){\n      |      \
    \                ^~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp9c9qr5u4.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:986:5:\
    \ note: candidate: \u2018template<class _Iterator,"
  stdout: ''
  timestamp: 1660141125
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    // your code goes here\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmps62asuso: /tmp/tmps62asuso.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end());\n    std::vector<std::string>\
    \ ans;\n    size_t len = 0;\n    for(size_t i = 0; i < s.length(); i++) {\n  \
    \      len = s.find_first_of(\"aeiou\", i);\n        if(len != std::string::npos)\
    \ {\n            ans.push_back(s.substr(i, len));\n            i += len;\n   \
    \     }\n        else if(len == std::string::npos && i == s.length() - 1) {\n\
    \            ans.push_back(s.substr(i));\n        }\n        else if(len > 0)\
    \ {\n            ans.push_back(s.substr(i, len));\n            i += len;\n   \
    \     }\n    }\n    if(ans.size() == 1 && ans[0] == \"\") {\n        ans.clear();\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvbue_pgi: /tmp/tmpvbue_pgi.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n\tstd::vector<std::string> res;\n\t\n\tstd::sort(s.begin(), s.end());\n\
    \tif (s.empty()) {\n\t\treturn res;\n\t}\n\t\n\tstd::string word;\n\tfor (auto\
    \ &letter : s) {\n\t\tif (letter != 'a' && letter != 'e' && letter != 'i' && letter\
    \ != 'o' && letter != 'u') {\n\t\t\tif (word.length() == 0) {\n\t\t\t\tres.push_back(word);\n\
    \t\t\t}\n\t\t\t\n\t\t\tword += letter;\n\t\t}\n\t}\n\t\n\tif (word.length() ==\
    \ 0) {\n\t\treturn res;\n\t}\n\t\n\tres.push_back(word);\n\t\n\tfor (auto &letter\
    \ : s) {\n\t\tif (letter != 'a' && letter != 'e' && letter != 'i' && letter !=\
    \ 'o' && letter != 'u') {\n\t\t\tword += letter;\n\t\t}\n\t}\n\t\n\tres.push_back(word);\n\
    \t\n\tstd::sort(res.begin(), res.end());\n\t\n\tfor (auto &word : res) {\n\t\t\
    if (word.length() >= n) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\treturn res;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvaq60x6g: /tmp/tmpvaq60x6g.cpp:59: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> s;\n    if(s.length()\
    \ == 0)\n        return s;\n    s.resize(0);\n    for(auto &c : s)\n        if(c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n            s.push_back(c);\n    if(s.size()\
    \ == 0)\n        return s;\n    std::vector<int> count(s.size(), 0);\n    for(auto\
    \ &c : s)\n        if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n\
    \            count[0]++;\n        else\n            count[toupper(c) - 'A']++;\n\
    \    std::vector<bool> flag(s.size(), false);\n    for(auto &c : s)\n        if(count[toupper(c)\
    \ - 'A'] == n)\n            flag[tolower(c)] = true;\n    for(auto &c : s) {\n\
    \        if(flag[tolower(c)]) {\n            s.push_back(c);\n        }\n    }\n\
    \    sort(s.begin(), s.end());\n    return s;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpic02i_1n.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpic02i_1n.cpp:16:30: error:\
    \ declaration of \u2018std::vector<std::__cxx11::basic_string<char> > s\u2019\
    \ shadows a parameter\n   16 |     std::vector<std::string> s;\n      |      \
    \                        ^\n/tmp/tmpic02i_1n.cpp:17:10: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018length\u2019\n   17 |     if(s.length() ==\
    \ 0)\n      |          ^~~~~~\n/tmp/tmpic02i_1n.cpp:21:14: error: no match for\
    \ \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   21 |         if(c == 'A' || c == 'E' || c == 'I' ||\
    \ c == 'O' || c == 'U' || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u')\n      |            ~ ^~ ~~~\n      |            |    |\n      |      \
    \      |    char\n      |            std::__cxx11::basic_string<char>\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpic02i_1n.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpic02i_1n.cpp:21:17:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   21 |         if(c == 'A' || c\
    \ == 'E' || c == 'I' || c == 'O' || c == 'U' || c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u')\n      |                 ^~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpic02i_1n.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018templat"
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    v.push_back(\"\");\n    v.push_back(s);\n\
    \    for (size_t i = 1; i < s.size(); i++) {\n        v.push_back(s.substr(0,\
    \ i));\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4k3l87fp: /tmp/tmp4k3l87fp.cpp:25: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> retval;\n    retval.push_back(s);\n\
    \    std::stack<std::string> s;\n    for(long i=0;i<s.size();i++){\n        if(s.empty())\
    \ break;\n        if(s[i]==' '){\n            s.pop();\n            continue;\n\
    \        }\n        if(s[i]!='a' &&s[i]!='e' &&s[i]!='i' &&s[i]!='o' &&s[i]!='u'\
    \ &&s[i]!='A' &&s[i]!='E' &&s[i]!='I' &&s[i]!='O' &&s[i]!='U') s.push(s[i]);\n\
    \        else if(s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u'\
    \ || s[i]=='A' || s[i]=='E' || s[i]=='I' || s[i]=='O' || s[i]=='U'){\n       \
    \     if(s.size()>n) retval.push_back(s.top());\n            s.pop();\n      \
    \  }\n        else{\n            s.pop();\n        }\n    }\n    if(s.size()>n)\
    \ retval.push_back(s.top());\n    return retval;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpde4sru4h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpde4sru4h.cpp:17:29: error:\
    \ declaration of \u2018std::stack<std::__cxx11::basic_string<char> > s\u2019 shadows\
    \ a parameter\n   17 |     std::stack<std::string> s;\n      |               \
    \              ^\n/tmp/tmpde4sru4h.cpp:20:13: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::stack<std::__cxx11::basic_string<char> >\u2019\
    \ and \u2018long int\u2019)\n   20 |         if(s[i]==' '){\n      |         \
    \    ^\n/tmp/tmpde4sru4h.cpp:24:13: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::stack<std::__cxx11::basic_string<char> >\u2019\
    \ and \u2018long int\u2019)\n   24 |         if(s[i]!='a' &&s[i]!='e' &&s[i]!='i'\
    \ &&s[i]!='o' &&s[i]!='u' &&s[i]!='A' &&s[i]!='E' &&s[i]!='I' &&s[i]!='O' &&s[i]!='U')\
    \ s.push(s[i]);\n      |             ^\n/tmp/tmpde4sru4h.cpp:24:25: error: no\
    \ match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018long int\u2019)\n   24 |         if(s[i]!='a' &&s[i]!='e'\
    \ &&s[i]!='i' &&s[i]!='o' &&s[i]!='u' &&s[i]!='A' &&s[i]!='E' &&s[i]!='I' &&s[i]!='O'\
    \ &&s[i]!='U') s.push(s[i]);\n      |                         ^\n/tmp/tmpde4sru4h.cpp:24:37:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018long int\u2019)\n   24 |         if(s[i]!='a' &&s[i]!='e'\
    \ &&s[i]!='i' &&s[i]!='o' &&s[i]!='u' &&s[i]!='A' &&s[i]!='E' &&s[i]!='I' &&s[i]!='O'\
    \ &&s[i]!='U') s.push(s[i]);\n      |                                     ^\n\
    /tmp/tmpde4sru4h.cpp:24:49: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::stack<std::__cxx11::basic_string<char> >\u2019 and \u2018\
    long int\u2019)\n   24 |         if(s[i]!='a' &&s[i]!='e' &&s[i]!='i' &&s[i]!='o'\
    \ &&s[i]!='u' &&s[i]!='A' &&s[i]!='E' &&s[i]!='I' &&s[i]!='O' &&s[i]!='U') s.push(s[i]);\n\
    \      |                                                 ^\n/tmp/tmpde4sru4h.cpp:24:61:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_stri"
  stdout: ''
  timestamp: 1660141125
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> ans;\n  if(s.size() == 0) return ans;\n\
    \  std::vector<std::string> vowels = { \"a\", \"e\", \"i\", \"o\", \"u\" };\n\
    \  std::vector<std::string> consonants = { \"b\", \"c\", \"d\", \"f\", \"g\",\
    \ \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"t\"\
    , \"v\", \"w\", \"x\", \"y\", \"z\" };\n  for(size_t i = 0; i < s.size(); ++i)\n\
    \  {\n    if(s[i] == ' ') continue;\n    for(size_t j = 0; j < vowels.size();\
    \ ++j)\n    {\n      if(s[i] == vowels[j])\n      {\n        ans.push_back(s.substr(i,\
    \ s.length()));\n        ans.push_back(s.substr(i + 1, s.length()));\n       \
    \ break;\n      }\n    }\n    for(size_t j = 0; j < consonants.size(); ++j)\n\
    \    {\n      if(s[i] == consonants[j])\n      {\n        ans.push_back(s.substr(i,\
    \ s.length()));\n        ans.push_back(s.substr(i + 1, s.length()));\n       \
    \ break;\n      }\n    }\n  }\n  ans.push_back(s.substr(0, s.length()));\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv7ukaybo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpv7ukaybo.cpp:24:15: error:\
    \ no match for \u2018operator==\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} and \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   24 |       if(s[i] == vowels[j])\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpv7ukaybo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpv7ukaybo.cpp:24:26:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   24 |       if(s[i] == vowels[j])\n      |       \
    \                   ^\nIn file included from /usr/include/c++/9/regex:62,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpv7ukaybo.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpv7ukaybo.cpp:24:26: note:   mismatched typ"
  stdout: ''
  timestamp: 1660141125
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    string temp;\n    for\
    \ (auto c : s) {\n        if (n >= temp.size()) {\n            words.push_back(temp);\n\
    \            temp = \"\";\n        }\n        temp += c;\n    }\n    if (temp.empty())\
    \ {\n        return words;\n    }\n    words.push_back(temp);\n    return words;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnaxlpq1a.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpnaxlpq1a.cpp:16:5: error:\
    \ \u2018string\u2019 was not declared in this scope\n   16 |     string temp;\n\
    \      |     ^~~~~~\n/tmp/tmpnaxlpq1a.cpp:16:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpnaxlpq1a.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpnaxlpq1a.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpnaxlpq1a.cpp:18:18: error: \u2018temp\u2019 was not declared in this scope\n\
    \   18 |         if (n >= temp.size()) {\n      |                  ^~~~\n/tmp/tmpnaxlpq1a.cpp:22:9:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   22 |         temp\
    \ += c;\n      |         ^~~~\n/tmp/tmpnaxlpq1a.cpp:24:9: error: \u2018temp\u2019\
    \ was not declared in this scope\n   24 |     if (temp.empty()) {\n      |   \
    \      ^~~~\n/tmp/tmpnaxlpq1a.cpp:27:21: error: \u2018temp\u2019 was not declared\
    \ in this scope\n   27 |     words"
  stdout: ''
  timestamp: 1660141125
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    for (long i=0; i<s.length();\
    \ i++) {\n        bool cont=false;\n        for (long j=0; j<s.length(); j++)\
    \ {\n            if ((s[i]==s[j])&&(j==s.length()-1))\n                cont=true;\n\
    \        }\n        if (cont==true)\n            ans.push_back(s.substr(i, s.length()-i));\
    \ // return all words that contain 'n' consonants\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvv6rl59q: /tmp/tmpvv6rl59q.cpp:29: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n// Write your code here\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp8ehs7bzt: /tmp/tmp8ehs7bzt.cpp:19: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    int i, j;\n    for(i\
    \ = 0, j = 0; i < s.length(); i++) {\n        if(s[i] == \" \") {\n          \
    \  if(i == j) words.push_back(s.substr(j));\n            j = 0;\n        } else\
    \ {\n            j++;\n            if(j == n) {\n                words.push_back(s.substr(i));\n\
    \            }\n        }\n    }\n    return words;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqi9okxfb.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpqi9okxfb.cpp:18:20: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   18\
    \ |         if(s[i] == \" \") {\n      |                    ^~~\n"
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    // Your code here\n   \
    \ if(s.empty()) {\n        return res;\n    }\n    \n    while(n > 0) {\n    \
    \    if(s.find('a', 0) == std::string::npos) {\n            n--;\n        } else\
    \ {\n            res.push_back(s.substr(0, s.find('a', 0)));\n            s =\
    \ s.substr(s.find('a', 0) + 1, s.size());\n            n--;\n        }\n    }\n\
    \    \n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpfc23zk5z: /tmp/tmpfc23zk5z.cpp:35: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    if (s.empty()) {\n  \
    \      return words;\n    }\n    std::string word;\n    for (size_t i = 0; i <\
    \ s.length(); i++) {\n        // check consonant\n        char c = s[i];\n   \
    \     if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            word\
    \ = word + c;\n        } else {\n            // if char not consonant add to current\
    \ word\n            if (!word.empty()) {\n                words.push_back(word);\n\
    \                word = \"\";\n            }\n            // check vowel\n   \
    \         char vowel = s[i - 2];\n            if (vowel == 'a' || vowel == 'e'\
    \ || vowel == 'i' || vowel == 'o' || vowel == 'u') {\n                word = word\
    \ + s[i];\n            }\n        }\n    }\n    // add last word\n    if (!word.empty())\
    \ {\n        words.push_back(word);\n    }\n    return words;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvom_bk_b: /tmp/tmpvom_bk_b.cpp:46: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // your code here\n    std::vector<std::string> v;\n    \n\
    \    if(s.empty()) return v;\n    \n    for(auto & c : s)\n    {\n        if(isspace(c)\
    \ || c == '-' || c == '_' || c == '.' || c == '?' || c == '!' || c == '#' || c\
    \ == '-' || c == '_')\n            continue;\n        for(long i = 0; i < n; i++)\n\
    \        {\n            if(c == 'a')\n            {\n                v.push_back(\"\
    Apple\");\n                v.push_back(\"Ball\");\n            }\n           \
    \ else if(c == 'e')\n            {\n                v.push_back(\"Elephant\");\n\
    \                v.push_back(\"Fish\");\n            }\n            else if(c\
    \ == 'i')\n            {\n                v.push_back(\"Iron\");\n           \
    \     v.push_back(\"Jelly\");\n            }\n            else if(c == 'o')\n\
    \            {\n                v.push_back(\"Orange\");\n                v.push_back(\"\
    Pear\");\n            }\n            else if(c == 'u')\n            {\n      \
    \          v.push_back(\"Uranus\");\n                v.push_back(\"Scorpion\"\
    );\n            }\n            else if(c == 'y')\n            {\n            \
    \    v.push_back(\"Yellow\");\n                v.push_back(\"Bear\");\n      \
    \      }\n        }\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpij6sx13g: /tmp/tmpij6sx13g.cpp:62: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    if (s.empty())\n    {\n\
    \        return ans;\n    }\n    \n    for (int i=0; i < s.size() && i+n <= s.length();\
    \ i++)\n    {\n        std::string word = s.substr(i, n);\n        if (std::count(word.begin(),\
    \ word.end()) == n)\n        {\n            ans.push_back(word);\n        }\n\
    \    }\n    \n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaf7i71fc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpaf7i71fc.cpp:24:48: error:\
    \ no matching function for call to \u2018count(std::__cxx11::basic_string<char>::iterator,\
    \ std::__cxx11::basic_string<char>::iterator)\u2019\n   24 |         if (std::count(word.begin(),\
    \ word.end()) == n)\n      |                                                ^\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpaf7i71fc.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:4113:5: note: candidate:\
    \ \u2018template<class _IIter, class _Tp> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::count(_IIter, _IIter, const _Tp&)\u2019\n 4113 |     count(_InputIterator\
    \ __first, _InputIterator __last, const _Tp& __value)\n      |     ^~~~~\n/usr/include/c++/9/bits/stl_algo.h:4113:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpaf7i71fc.cpp:24:48:\
    \ note:   candidate expects 3 arguments, 2 provided\n   24 |         if (std::count(word.begin(),\
    \ word.end()) == n)\n      |                                                ^\n\
    In file included from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpaf7i71fc.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:101:1:\
    \ note: candidate: \u2018template<class _ExecutionPolicy, class _ForwardIterator,\
    \ class _Tp> __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\
    \ typename std::iterator_traits<_II>::difference_type> std::count(_ExecutionPolicy&&,\
    \ _ForwardIterator, _ForwardIterator, const _Tp&)\u2019\n  101 | count(_ExecutionPolicy&&\
    \ __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n\
    \      | ^~~~~\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:101:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpaf7i71fc.cpp:24:48: note: \
    \  candidate expects 4 arguments, 2 provided\n   24 |         if (std::c"
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // write your code in C++11/C++14 style\n  // You can use string\
    \ methods to solve this problem\n  // you can use std::unordered_set\n  std::vector<std::string>\
    \ res;\n  \n  // write your code here\n  \n  // Do not modify below this line\n\
    \  return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpnyaii9yv: /tmp/tmpnyaii9yv.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    std::vector<std::string> words;\n\
    \    if (s.empty())\n    {\n        return words;\n    }\n    size_t index = 0;\n\
    \    while (index < s.size())\n    {\n        if (s[index] == ' ')\n        {\n\
    \            while (index < s.size() && s[index] == ' ')\n                index++;\n\
    \            while (index < s.size())\n            {\n                if (s[index]\
    \ == ' ' && s[index + 1] != ' ' && s[index + 1] != '\\n' \n                  \
    \      && s[index + 1] != '\\r' && s[index + 1] != '\\t' && s[index + 1] != '\\\
    v' \n                        && s[index + 1] != '\\f')\n                {\n  \
    \                  words.push_back(s.substr(index, s.size()));\n             \
    \       index++;\n                }\n                else\n                {\n\
    \                    break;\n                }\n            }\n        }\n   \
    \     else\n        {\n            index++;\n        }\n    }\n    if (index <\
    \ s.size())\n    {\n        words.push_back(s.substr(index, s.size()));\n    }\n\
    \    return words;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmptfparffr: /tmp/tmptfparffr.cpp:56: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> v;\n  \n  v.push_back(s);\n  for(auto\
    \ &x: v)\n    if(x.size() == n)\n      return v;\n  \n  if(s.size() == 0)\n  \
    \  return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size() >= n)\n\
    \      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size() >=\
    \ 2 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 3 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 4 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 5 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 6 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 7 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 8 * n)\n      return v;\n  \n  v.push_back(s);\n  for(auto &x: v)\n    if(x.size()\
    \ >= 9 * n)\n      return v;\n  \n  return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqqg8t6e9: /tmp/tmpqqg8t6e9.cpp:74: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    \n    if (s.size() == 0)\n\
    \        return res;\n    \n    // Your code here\n    std::vector<string> v;\n\
    \    \n    for(int i = 0; i < s.size(); ++i)\n    {\n        std::string temp\
    \ = s[i];\n        \n        for(int j = 0; j < temp.size(); ++j)\n        {\n\
    \            if(temp[j] != '\\0')\n            {\n                v.push_back(temp);\n\
    \            }\n        }\n    }\n    \n    int count = 0;\n    \n    for(int\
    \ i = 0; i < s.size(); ++i)\n    {\n        for(int j = 0; j < v.size(); ++j)\n\
    \        {\n            if(s[i] == v[j][count])\n            {\n             \
    \   ++count;\n            }\n        }\n    }\n    \n    for(auto i : v)\n   \
    \ {\n        if(count == n)\n        {\n            res[res.size()-1] += \" \"\
    \ + i;\n        }\n    }\n    \n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppvmbnybw.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppvmbnybw.cpp:21:17: error:\
    \ \u2018string\u2019 was not declared in this scope\n   21 |     std::vector<string>\
    \ v;\n      |                 ^~~~~~\n/tmp/tmppvmbnybw.cpp:21:17: note: suggested\
    \ alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmppvmbnybw.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmppvmbnybw.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmppvmbnybw.cpp:21:23: error: template argument 1 is invalid\n   21 |   \
    \  std::vector<string> v;\n      |                       ^\n/tmp/tmppvmbnybw.cpp:21:23:\
    \ error: template argument 2 is invalid\n/tmp/tmppvmbnybw.cpp:25:31: error: conversion\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} requested\n   25 |         std::string\
    \ temp = s[i]"
  stdout: ''
  timestamp: 1660141126
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> result;\n  if(s.empty()) return result;\n\
    \  if(s.length() == 1) return select_words(s, n);\n  if(s.length() > n) return\
    \ result;\n  if(isVowel(s[0]) == false && isVowel(s[s.length()-1]) == false &&\
    \ isConsonant(s[0]) == false && isConsonant(s[s.length()-1]) == false) \n  {\n\
    \    if(s[0] != s[s.length()-1]) return result;\n  }\n  std::string sStr = s;\n\
    \  while(true) {\n    bool stop = false;\n    if(sStr.length() == 0) {\n     \
    \ stop = true;\n      break;\n    }\n    if(sStr.find(\"n\") == sStr.size()-1)\
    \ {\n      stop = true;\n      break;\n    }\n    if(sStr.find(\"N\") == sStr.size()-1)\
    \ {\n      stop = true;\n      break;\n    }\n    if(sStr.find(\"n\") == 0) {\n\
    \      stop = true;\n      break;\n    }\n    if(sStr.find(\"N\") == 0) {\n  \
    \    stop = true;\n      break;\n    }\n    if(sStr.find(\" \") != std::string::npos)\
    \ {\n      stop = true;\n      break;\n    }\n    if(sStr.find(\"  \") != std::string::npos)\
    \ {\n      stop = true;\n      break;\n    }\n    \n    if(stop) break;\n    result.push_back(sStr);\n\
    \    sStr.erase(0, 1);\n    sStr.erase(sStr.find(\"n\"));\n    sStr.erase(sStr.find(\"\
    N\"));\n    sStr.erase(0, 1);\n    sStr.erase(sStr.find(\" \"));\n    sStr.erase(sStr.find(\"\
    \  \"));\n  }\n  if(sStr.length() != 0) result.push_back(sStr);\n  for(auto &str\
    \ : result) {\n    for(auto &letter : str) \n      if(letter == \" \") \n    \
    \    str.erase(str.begin()+1);\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmvn9c689.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpmvn9c689.cpp:19:6: error:\
    \ \u2018isVowel\u2019 was not declared in this scope; did you mean \u2018islower\u2019\
    ?\n   19 |   if(isVowel(s[0]) == false && isVowel(s[s.length()-1]) == false &&\
    \ isConsonant(s[0]) == false && isConsonant(s[s.length()-1]) == false)\n     \
    \ |      ^~~~~~~\n      |      islower\n/tmp/tmpmvn9c689.cpp:19:69: error: \u2018\
    isConsonant\u2019 was not declared in this scope\n   19 |   if(isVowel(s[0]) ==\
    \ false && isVowel(s[s.length()-1]) == false && isConsonant(s[0]) == false &&\
    \ isConsonant(s[s.length()-1]) == false)\n      |                            \
    \                                         ^~~~~~~~~~~\n/tmp/tmpmvn9c689.cpp:67:20:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   67 |       if(letter == \" \")\n      |                    ^~~\n"
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    // ...\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmplzg2u2gm: /tmp/tmplzg2u2gm.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    int index = 0;\n    std::vector<std::string> list;\n    std::string\
    \ tmp = s;\n    std::map<char, int> m;\n    while (index < tmp.size()) \n    {\n\
    \        m[tmp[index]] = m.get(tmp[index], 0) + 1;\n        index++;\n    }\n\
    \    for (auto &it : m)\n    {\n        if (it.second == n) list.push_back(tmp.substr(0,\
    \ it.first));\n    }\n    return list;\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi8b0ev77.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpi8b0ev77.cpp:21:27: error:\
    \ \u2018class std::map<char, int>\u2019 has no member named \u2018get\u2019\n\
    \   21 |         m[tmp[index]] = m.get(tmp[index], 0) + 1;\n      |          \
    \                 ^~~\n"
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    for(long i = 0; i <\
    \ s.length(); ++i) {\n        if(s[i] != 'a' && s[i] != 'e' && s[i] != 'i' &&\
    \ s[i] != 'o' &&\n                s[i] != 'u' && s[i] != 'A' && s[i] != 'E' &&\
    \ s[i] != 'I' &&\n                s[i] != 'O' && s[i] != 'U') {\n            result.push_back(s.substr(i,\
    \ 1));\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpooyh3ahh: /tmp/tmpooyh3ahh.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141127
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    for (auto &i: select_words(s))\n\
    \        v.push_back(i);\n    return v;\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt7qc23zu.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpt7qc23zu.cpp:16:33: error:\
    \ too few arguments to function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019\n   16 |     for (auto &i: select_words(s))\n\
    \      |                                 ^\n/tmp/tmpt7qc23zu.cpp:14:26: note:\
    \ declared here\n   14 | std::vector<std::string> select_words(std::string s,\
    \ long n) {\n      |                          ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    assert(n >= 0);\n    std::vector<std::string> res;\n    if\
    \ (s.empty()) {\n        return res;\n    }\n    auto iter = s.begin();\n    char\
    \ c = *iter;\n    auto end = s.end();\n    while (end != iter) {\n        if (*end\
    \ == c) {\n            iter++;\n        } else if (iter == end) {\n          \
    \  res.push_back(s);\n            break;\n        } else if (*end == '*' && *iter\
    \ == c) {\n            iter++;\n            while (iter != end) {\n          \
    \      c = *iter;\n                if (iter == end) {\n                    res.push_back(s);\n\
    \                    break;\n                } else if (*iter != c) {\n      \
    \              iter++;\n                    break;\n                }\n      \
    \          iter++;\n            }\n        } else {\n            iter++;\n   \
    \     }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqmj8i816: /tmp/tmpqmj8i816.cpp:50: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> v;\n    for(int\
    \ i = 0; i < s.length(); i++)\n    {\n        for(int j = 0; j < n; j++)\n   \
    \     {\n            if(s[i] != ' ')\n            {\n                v.push_back(s.substr(0,\
    \ i));\n                break;\n            }\n        }\n        if(v.size()\
    \ == n) break;\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpf_xox55e: /tmp/tmpf_xox55e.cpp:33: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    long count = 0;\n    //\
    \ Your code here\n    if (s.empty())\n        return res;\n    for (auto c: s)\
    \ {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            count++;\n            if (count == n) {\n                res.push_back(s.substr(s.find(c)\
    \ + 1));\n                count = 0;\n            }\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_gvh_qoq: /tmp/tmp_gvh_qoq.cpp:33: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) {\n        return {};\n    }\n    \n    std::vector<std::string>\
    \ ret;\n    \n    // Create a string with only n consonants\n    std::string consonants\
    \ = \"bcdfghjklmnpqrstvwxyz\";\n    std::string cons_string = consonants.substr(0,\
    \ n);\n    \n    // Create a list of all words\n    for (auto it = std::begin(s);\
    \ it != std::end(s); ++it) {\n        bool found = false;\n        for (auto it2\
    \ = std::begin(cons_string); it2 != std::end(cons_string); ++it2) {\n        \
    \    if (*it == *it2) {\n                found = true;\n                break;\n\
    \            }\n        }\n        if (found) {\n            ret.push_back(it);\n\
    \        }\n    }\n    \n    return ret;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9u868b8c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp9u868b8c.cpp:35:29: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >&)\u2019\n   35 |             ret.push_back(it);\n      |                 \
    \            ^\nIn file included from /usr/include/c++/9/vector:67,\n        \
    \         from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmp9u868b8c.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018const value_type&\u2019 {aka\
    \ \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019"
  stdout: ''
  timestamp: 1660141127
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    result.push_back(s);\n\
    \    // Complete this function\n    return result;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpp0_g4jqc: /tmp/tmpp0_g4jqc.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    std::vector<std::string> v;\n\
    \    std::string temp;\n    for(size_t i = 0; i < s.size(); i++) {\n        temp\
    \ = s[i];\n        for(size_t j = 0; j < temp.length(); j++) {\n            if(temp.at(j)\
    \ == ' ') {\n                temp.erase(j,1);\n            }\n        }\n    \
    \    v.push_back(temp);\n    }\n    sort(v.begin(), v.end());\n    if(v.size()\
    \ == 0) {\n        return v;\n    }\n    v.erase(unique(v.begin(), v.end()), v.end());\n\
    \    for(size_t i = 0; i < n; i++) {\n        v.erase(unique(v.begin(), v.end()),\
    \ v.end());\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpdpjioywv: /tmp/tmpdpjioywv.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    return { };\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp5zeaqu__: /tmp/tmp5zeaqu__.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    \n    // Write your\
    \ code here\n    \n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpj7j7k_f6: /tmp/tmpj7j7k_f6.cpp:23: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660140927
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    for (size_t i = 0; i <\
    \ s.size(); i++) {\n        if (s.at(i) == ' ' || s.at(i) == '-') {\n        \
    \    if (s.at(i) == ' ' && s.at(i - 1) != ' ') {\n                res.push_back(s.substr(0,\
    \ i));\n            } else {\n                res.push_back(s.substr(i));\n  \
    \          }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpmy7jgiai: /tmp/tmpmy7jgiai.cpp:29: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end());\n    std::vector<std::string>\
    \ ans;\n    for (auto i : s) {\n        if (i == ' ' || i == '\\0') continue;\n\
    \        ans.push_back(s);\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4bp7iq80: /tmp/tmp4bp7iq80.cpp:25: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141130
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> word_vec;\n    for (auto &c: s) {\n\
    \        if (std::isalpha(c) || std::isspace(c)) {\n            word_vec.push_back(s.substr(0,\
    \ s.find(c)));\n            s = s.substr(s.find(c) + 1);\n        }\n    }\n \
    \   if (s.size() == 0) {\n        return word_vec;\n    }\n    long num_consonants\
    \ = 0;\n    bool first_char = true;\n    std::string word;\n    for (auto &c:\
    \ s) {\n        if (std::isalpha(c)) {\n            word = c;\n            first_char\
    \ = true;\n            continue;\n        }\n        if (std::isspace(c)) {\n\
    \            std::cout << word;\n            if (std::find(word_vec.begin(), word_vec.end(),\
    \ word) == word_vec.end()) {\n                word_vec.push_back(word);\n    \
    \        }\n        }\n        else {\n            if (first_char) {\n       \
    \         if (std::find(word_vec.begin(), word_vec.end(), c) == word_vec.end())\
    \ {\n                    word_vec.push_back(c);\n                }\n         \
    \   }\n            else if (std::find(word_vec.begin(), word_vec.end(), c) ==\
    \ word_vec.end()) {\n                num_consonants += 1;\n            }\n   \
    \     }\n        first_char = false;\n    }\n    if (num_consonants == n) {\n\
    \        std::cout << word;\n        if (std::find(word_vec.begin(), word_vec.end(),\
    \ word) == word_vec.end()) {\n            word_vec.push_back(word);\n        }\n\
    \    }\n    return word_vec;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8w7il9pc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp8w7il9pc.cpp:43:41: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   43 |                     word_vec.push_back(c);\n\
    \      |                                         ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8w7il9pc.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |       "
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    \n    std::vector<std::string> v;\n    if (s.empty()) {\n\
    \        return v;\n    }\n    std::stack<std::string> s;\n    std::string word\
    \ = \"\";\n    char ch;\n    for (size_t i = 0; i < s.size(); i++) {\n       \
    \ ch = s[i];\n        if (!std::isalpha(ch) && !std::isspace(ch)) {\n        \
    \    if (word.empty()) {\n                word = word.append(ch);\n          \
    \  } else {\n                if (word.length() == n) {\n                    if\
    \ (s.size() > 0) {\n                        std::string ss = s.top();\n      \
    \                  s.pop();\n                        v.push_back(ss);\n      \
    \              }\n                } else {\n                    v.push_back(word);\n\
    \                    word = \"\";\n                }\n            }\n        }\n\
    \        else {\n            word.append(ch);\n        }\n    }\n    if (word.length()\
    \ > 0) {\n        v.push_back(word);\n    }\n    return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprwmkbiyd.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmprwmkbiyd.cpp:20:29: error:\
    \ declaration of \u2018std::stack<std::__cxx11::basic_string<char> > s\u2019 shadows\
    \ a parameter\n   20 |     std::stack<std::string> s;\n      |               \
    \              ^\n/tmp/tmprwmkbiyd.cpp:24:15: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::stack<std::__cxx11::basic_string<char> >\u2019\
    \ and \u2018size_t\u2019 {aka \u2018long unsigned int\u2019})\n   24 |       \
    \  ch = s[i];\n      |               ^\n/tmp/tmprwmkbiyd.cpp:27:38: error: no\
    \ matching function for call to \u2018std::__cxx11::basic_string<char>::append(char&)\u2019\
    \n   27 |                 word = word.append(ch);\n      |                   \
    \                   ^\nIn file included from /usr/include/c++/9/string:55,\n \
    \                from /usr/include/c++/9/bits/locale_classes.h:40,\n         \
    \        from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprwmkbiyd.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1267:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1267 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:1267:7: note:   conversion of argument\
    \ 1 would be ill-formed:\n/tmp/tmprwmkbiyd.cpp:27:36: error: invalid conversion\
    \ from \u2018char\u2019 to \u2018const char*\u2019 [-fpermissive]\n   27 |   \
    \              word = word.append(ch);\n      |                              \
    \      ^~\n      |                                    |\n   "
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    for(std::string word\
    \ : s){\n        if(std::count(word.begin(), word.end(), ' ')!= 0){\n        \
    \    words.push_back(word);\n        }\n        for(std::size_t i = 0; i <= word.length()\
    \ - n; ++i){\n            std::size_t count = 0;\n            std::size_t found\
    \ = 0;\n            for(std::size_t j = 0; j < word.length(); ++j){\n        \
    \        if(!isspace(word[j]))\n                    if(word[j] == word[i + count]){\n\
    \                        ++count;\n                        if(count == n)\n  \
    \                          found++;\n                    }\n            }\n  \
    \          if(found == n)\n                words.push_back(word.substr(i, count));\n\
    \        }\n    }\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4xznam8p.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp4xznam8p.cpp:16:28: error:\
    \ conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   16 |     for(std::string\
    \ word : s){\n      |                            ^\n"
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if(s.empty())\n        return\
    \ v;\n    // Add first word\n    v.push_back(s.substr(0, s.size() - 1));\n   \
    \ // Add words containing less than n consonants\n    for(auto itr = s.cbegin();\
    \ itr != s.cend() - 1; itr++) {\n        if((*itr == 'a') || (*itr == 'e') ||\
    \ (*itr == 'i') || (*itr == 'o') || (*itr == 'u')) {\n            v.push_back(s.substr(itr,\
    \ s.size() - 1));\n            itr = s.cend();\n        }\n    }\n    // Add last\
    \ word\n    v.push_back(s.substr(itr, s.size()));\n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp30odwtgu.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp30odwtgu.cpp:23:34: error:\
    \ cannot convert \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019}\n   23 |             v.push_back(s.substr(itr, s.size()\
    \ - 1));\n      |                                  ^~~\n      |              \
    \                    |\n      |                                  __gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp30odwtgu.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2838:24:\
    \ note:   initializing argument 1 of \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::substr(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2838 |       substr(size_type __pos = 0, size_type __n = npos)\
    \ const\n      |              ~~~~~~~~~~^~~~~~~~~\n/tmp/tmp30odwtgu.cpp:28:26:\
    \ error: \u2018itr\u2019 was not declared in this scope\n   28 |     v.push_back(s.substr(itr,\
    \ s.size()));\n      |                          ^~~\n"
  stdout: ''
  timestamp: 1660141128
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Do not write main() function.\n    // Do not read input,\
    \ instead use the arguments to the function.\n    // Do not print the output,\
    \ instead return values that you compute and print in main.\n    // Use only for\
    \ loops that iterate over a known number of items.\n    // The only library functions\
    \ you are allowed to use are those already written for you.\n    // Level up your\
    \ understanding of C++ by taking smaller steps.\n    std::vector< std::vector<std::string>\
    \ > v;\n    std::vector<std::string> temp;\n    for (int i = 0; i < s.length();\
    \ i++) {\n        for (int j = i; j < s.length(); j++) {\n            if (s[i]\
    \ != s[j]) {\n                if (s[j] == 'a' || s[j] == 'e' || s[j] == 'i' ||\
    \ s[j] == 'o' || s[j] == 'u' || s[j] == 'y') {\n                    for (int k\
    \ = i; k < s.length(); k++) {\n                        if (s[k] == s[j]) {\n \
    \                           // cout << s[i] << \" \" << s[j] << \" \" << k <<\
    \ endl;\n                            temp.push_back( s.substr(i, j) );\n     \
    \                       temp.push_back( s.substr(k, j+1) );\n                \
    \            // cout << temp.size() << \" \" << temp << endl;\n              \
    \              for (int l = k; l < s.length(); l++) {\n                      \
    \          // cout << s[k] << \" \" << l << \" \" << k << endl;\n            \
    \                    temp.push_back( s.substr(k, j+1) );\n                   \
    \             // cout << temp.size() << \" \" << temp << endl;\n             \
    \               }\n                            // cout << temp.size() << \" \"\
    \ << temp << endl;\n                            v.push_back(temp);\n         \
    \                   temp.clear();\n                            // cout << v.size()\
    \ << \" \" << v<< endl;\n                            break;\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \    }\n    // cout << v.size() << \" \" << v << endl;\n    return v;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpks6l8lmo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpks6l8lmo.cpp:50:12: error:\
    \ could not convert \u2018v\u2019 from \u2018vector<std::vector<std::__cxx11::basic_string<char>\
    \ >>\u2019 to \u2018vector<std::__cxx11::basic_string<char>>\u2019\n   50 |  \
    \   return v;\n      |            ^\n      |            |\n      |           \
    \ vector<std::vector<std::__cxx11::basic_string<char> >>\n"
  stdout: ''
  timestamp: 1660141128
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    std::vector<char> v(s.size());\n\
    \    for(size_t i = 0; i < s.size(); ++i) {\n        if('a' <= s[i] && s[i] <=\
    \ 'z')\n            v[i] = s[i] - 'a' + 'A';\n        else if(' ' <= s[i] && s[i]\
    \ <= 'z')\n            v[i] = s[i] - ' ' + 'A';\n        else if('!' <= s[i] &&\
    \ s[i] <= 'z')\n            v[i] = s[i] - '!' + 'A';\n        else if('?' <= s[i]\
    \ && s[i] <= 'z')\n            v[i] = s[i] - '?' + 'A';\n        else if(';' <=\
    \ s[i] && s[i] <= 'z')\n            v[i] = s[i] - ';' + 'A';\n        else if(';'\
    \ <= s[i] && s[i] <= 'z')\n            v[i] = s[i] - ';' + 'A';\n        else\
    \ if(':' <= s[i] && s[i] <= 'z')\n            v[i] = s[i] - ':' + 'A';\n     \
    \   else\n            v[i] = s[i] + 'A';\n    }\n    std::vector<bool> flags(v.size());\n\
    \    for(size_t i = 0; i < v.size(); ++i) {\n        if(n == 0)\n            break;\n\
    \        if(v[i] == v[v.size() - n - 1])\n            flags[i] = true;\n     \
    \   else\n            flags[i] = false;\n    }\n    for(size_t i = 0; i < s.size();\
    \ ++i) {\n        if(flags[i]) {\n            res.push_back(s);\n            break;\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmps7v1aa7s: /tmp/tmps7v1aa7s.cpp:54: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if (s.length() == 0)\
    \ {\n        return result;\n    }\n    \n    if (n <= 0) {\n        return result;\n\
    \    }\n    \n    std::vector<std::string> words;\n    for (auto &letter : s)\
    \ {\n        if (letter == ' ') {\n            words.emplace_back(\"\");\n   \
    \     } else {\n            words.emplace_back(letter);\n        }\n    }\n\n\
    \    long count = 1;\n    for (auto &word : words) {\n        if (count++ == n)\
    \ {\n            result.emplace_back(word);\n        }\n    }\n\n    return result;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpph7jkw4b.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h: In instantiation\
    \ of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with\
    \ _Up = std::__cxx11::basic_string<char>; _Args = {char&}; _Tp = std::__cxx11::basic_string<char>]\u2019\
    :\n/usr/include/c++/9/bits/alloc_traits.h:483:4:   required from \u2018static\
    \ void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT>\
    \ >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::__cxx11::basic_string<char>;\
    \ _Args = {char&}; _Tp = std::__cxx11::basic_string<char>; std::allocator_traits<std::allocator<_CharT>\
    \ >::allocator_type = std::allocator<std::__cxx11::basic_string<char> >]\u2019\
    \n/usr/include/c++/9/bits/vector.tcc:115:30:   required from \u2018std::vector<_Tp,\
    \ _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with\
    \ _Args = {char&}; _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::reference = std::__cxx11::basic_string<char>&]\u2019\
    \n/tmp/tmpph7jkw4b.cpp:29:38:   required from here\n/usr/include/c++/9/ext/new_allocator.h:146:4:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(char&)\u2019\
    \n  146 |  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n     \
    \ |    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.length()==0) {\n        return {};\n    }\n\n    std::vector<std::string>\
    \ words;\n\n    std::string word = \"\";\n    size_t word_size = 0;\n    for(size_t\
    \ i=0 ; i<s.length();i++) {\n        char c = s[i];\n        if(c>='a' && c<='z'\
    \ || c>='A' && c<='Z' || c>='0') {\n            if(word.length()>0) word+=' ';\n\
    \            word+=c;\n        } else {\n            word_size++;\n          \
    \  if(word_size==n) {\n                words.push_back(word);\n              \
    \  word_size=0;\n                word=\"\";\n            }\n        }\n    }\n\
    \    \n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpv5czust3: /tmp/tmpv5czust3.cpp:42: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141130
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if (s.empty()) return\
    \ result;\n    \n    // Write your code here\n    \n    return result;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpi02xjkgv: /tmp/tmpi02xjkgv.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141130
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    std::string::size_type pos\
    \ = 0, lastPos = 0, count = 1;\n    char ch;\n    // This loop searches for the\
    \ first occurrence of n in the string s\n    while(pos != std::string::npos) {\n\
    \        // Keep track of the position in the string where we stopped searching\n\
    \        lastPos = pos;\n        // Search for the next occurrence of n in the\
    \ string\n        pos = s.find_first_of(\" \", pos);\n        // If not found,\
    \ don't search any more\n        if(pos == std::string::npos) break;\n       \
    \ // Search for the next occurrence of n in the string\n        pos = s.find_first_of(\"\
    \ \", pos + 1);\n        // If not found, don't search any more\n        if(pos\
    \ == std::string::npos) break;\n        // If n appears again, increment the count\
    \ and store it\n        if(s[pos] == ' ') count++;\n        // If count matches\
    \ the required count for this word, add it to the vector\n        if(count ==\
    \ n) {\n            v.push_back(s.substr(lastPos, pos - lastPos));\n         \
    \   // Reset the count for the next word we encounter\n            count = 1;\n\
    \        }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp5uh3o72h: /tmp/tmp5uh3o72h.cpp:43: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141130
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    for (std::string::iterator\
    \ itr = s.begin(); itr != s.end(); ++itr) {\n        if (!isspace(*itr)) {\n \
    \           v.push_back(*itr);\n        }\n    }\n    std::sort(v.begin(), v.end());\n\
    \    v.erase(std::unique(v.begin(), v.end()), v.end());\n    v.erase(std::unique(v,\n\
    \        [] (const std::string &a, const std::string &b)\n        {\n        \
    \    return a.size() == b.size() && a.size() == n && a.find_first_not_of(\" \\\
    n\") != std::string::npos;\n        }), v.end());\n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpto846q__.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpto846q__.cpp:18:29: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   18 |             v.push_back(*itr);\n      | \
    \                            ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpto846q__.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^"
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    // Write your code here\n\
    \    return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp956rki8g: /tmp/tmp956rki8g.cpp:21: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.empty()) return {};\n    std::vector<std::string> ans;\n\
    \    auto f = [&s, &n](std::pair<const std::string, long long> &p) -> bool {\n\
    \        auto it = std::find(p.first.begin(), p.first.end(), s.front());\n   \
    \     if(it == p.first.end()) return true;\n        auto left = it + s.size();\n\
    \        if(left > p.second) return true;\n        auto right = left + n;\n  \
    \      if(right > p.second) return true;\n        ans.emplace_back(p.first);\n\
    \        if(p.second == right) {\n            while(p.second != right) {\n   \
    \             p.second += n;\n                ans.emplace_back(p.first);\n   \
    \         }\n        }\n        for(; left <= p.second; ++left) {\n          \
    \  ans.emplace_back(p.first);\n        }\n        return false;\n    };\n    for(std::pair<const\
    \ std::string, long long> p : std::partition(s.begin(), s.end(), f)) {\n     \
    \   for(; p.second != p.second+n; ++p.second) {\n            ans.emplace_back(p.first);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcgxr0ym1.cpp: In lambda function:\n/tmp/tmpcgxr0ym1.cpp:21:17:\
    \ error: no match for \u2018operator>\u2019 (operand types are \u2018__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >\u2019 and \u2018long long int\u2019\
    )\n   21 |         if(left > p.second) return true;\n      |            ~~~~ ^\
    \ ~~~~~~~~\n      |            |        |\n      |            |        long long\
    \ int\n      |            __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n      \
    \           from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpcgxr0ym1.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:926:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  926 |\
    \     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:926:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpcgxr0ym1.cpp:21:21: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorR, _Container>\u2019\
    \ and \u2018long long int\u2019\n   21 |         if(left > p.second) return true;\n\
    \      |                     ^~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpcgxr0ym1.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:933:5:\
    \ note: candidate: \u2018template<class _Iterator, class _Container> bool __gnu_cxx::operator>(const\
    \ __gnu_cxx::__normal_iterator<_Iterator, _Container>&, const __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>&)"
  stdout: ''
  timestamp: 1660141130
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> ans;\n    std::stack<std::string>\
    \ stack;\n    stack.pop_back();\n    for (char c : s) {\n        if (c == 'a')\
    \ \n            stack.push(\"ab\");\n        else if (c == 'e')\n            stack.push(\"\
    e\");\n        else if (c == 'i')\n            stack.push(\"i\");\n        else\
    \ if (c == 'o')\n            stack.push(\"o\");\n        else if (c == 'u')\n\
    \            stack.push(\"u\");\n        else if (c == 'y' && stack.size() ==\
    \ 3)\n            stack.push(\"u\");\n        else if (c == 'y')\n           \
    \ stack.push(\"u\");\n        else\n            stack.push(c);\n    }\n    while\
    \ (!stack.empty()) {\n        if (stack.size() == n) {\n            ans.push_back(stack.top());\n\
    \        }\n        else {\n            stack.pop();\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_14jle1v.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp_14jle1v.cpp:18:11: error:\
    \ \u2018class std::stack<std::__cxx11::basic_string<char> >\u2019 has no member\
    \ named \u2018pop_back\u2019\n   18 |     stack.pop_back();\n      |         \
    \  ^~~~~~~~\n/tmp/tmp_14jle1v.cpp:35:25: error: no matching function for call\
    \ to \u2018std::stack<std::__cxx11::basic_string<char> >::push(char&)\u2019\n\
    \   35 |             stack.push(c);\n      |                         ^\nIn file\
    \ included from /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp_14jle1v.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  233 |       push(const value_type&\
    \ __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_stack.h:233:30: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n  233 |       push(const\
    \ value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_stack.h:238:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp,\
    \ _Sequence>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Sequence\
    \ = std::deque<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char>\
    \ > >; std::stack<_Tp, _Sequence>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n  238 |       push(value_type&& __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \  238 |       push(value_type&& "
  stdout: ''
  timestamp: 1660141130
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    \n    if(s.empty()) {\n\
    \        return res;\n    }\n    \n    for(long i = 0; i <= s.size(); i++) {\n\
    \        if(s.at(i) == ' ') {\n            res.push_back(s.substr(0, i));\n  \
    \          s.erase(0, i);\n        }\n    }\n    \n    for(long i = 0; i < s.size();\
    \ i++) {\n        if(s.at(i) == 'a' || s.at(i) == 'e' || s.at(i) == 'i' || s.at(i)\
    \ == 'o' || s.at(i) == 'u') {\n            for(long j = i; j < s.size(); j++)\
    \ {\n                if(!s.at(j).isalpha()) {\n                    i = j;\n  \
    \                  break;\n                }\n            }\n        }\n    }\n\
    \    \n    while(s.size() != 0) {\n        if(s.size() >= n && s.at(n).isalpha())\
    \ {\n            res.push_back(s.substr(0, s.size() - n));\n            s.erase(0,\
    \ s.size() - n);\n        } else {\n            s.erase(0, 1);\n        }\n  \
    \  }\n    \n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi4_p3dn5.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpi4_p3dn5.cpp:31:29: error:\
    \ request for member \u2018isalpha\u2019 in \u2018s.std::__cxx11::basic_string<char>::at(((std::__cxx11::basic_string<char>::size_type)j))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   31 |                 if(!s.at(j).isalpha())\
    \ {\n      |                             ^~~~~~~\n/tmp/tmpi4_p3dn5.cpp:40:37:\
    \ error: request for member \u2018isalpha\u2019 in \u2018s.std::__cxx11::basic_string<char>::at(((std::__cxx11::basic_string<char>::size_type)n))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   40 |         if(s.size()\
    \ >= n && s.at(n).isalpha()) {\n      |                                     ^~~~~~~\n"
  stdout: ''
  timestamp: 1660141129
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    \n    std::vector<std::string> res;\n  \
    \  \n    \n    \n    return res;\n    \n    \n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7jxtnmr9: /tmp/tmp7jxtnmr9.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141132
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if(s.empty())\n    {\n  \
    \      v.emplace_back();\n        return v;\n    }\n    long pos = 0;\n    long\
    \ count = 1;\n    for(auto c: s)\n    {\n        if(c != s[pos] && c != s[pos+1])\n\
    \        {\n            pos++;\n            count = 1;\n        }\n        else\n\
    \        {\n            count++;\n        }\n        if(count == n)\n        {\n\
    \            v.emplace_back(std::string(pos, pos));\n            count = 1;\n\
    \        }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7p6mc0ef: /tmp/tmp7p6mc0ef.cpp:44: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    res.reserve(s.size());\n\
    \    std::vector<std::string> v;\n    \n    // base case\n    if (s.size() ==\
    \ 0) {\n        res.push_back(v);\n        return res;\n    }\n    \n    long\
    \ cnt = 0;\n    long len = 0;\n    \n    char last;\n    long cnt = s.size();\n\
    \    for (size_t i = 0; i < s.size(); i++) {\n        last = s[i];\n        \n\
    \        // find first consonant\n        for (size_t j = i; j < s.size(); j++)\
    \ {\n            char ch = s[j];\n            if (std::isupper(ch) || std::islower(ch)\
    \ || std::isspace(ch))\n                len = j - i;\n            if (cnt == n)\
    \ {\n                res.push_back(v);\n                v.clear();\n         \
    \       break;\n            }\n            else if (std::islower(ch) && std::isupper(ch))\n\
    \                break;\n            else if (cnt == 0) {\n                v.push_back(s.substr(i,\
    \ j-i+1));\n                i += j-i+1;\n                cnt = 1;\n          \
    \      break;\n            }\n        }\n        cnt = 0;\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvhioaj6c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpvhioaj6c.cpp:21:24: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::vector<std::__cxx11::basic_string<char> >&)\u2019\n   21 |\
    \         res.push_back(v);\n      |                        ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvhioaj6c.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >::value_type&&\u2019\
    \ {aka \u2018std"
  stdout: ''
  timestamp: 1660141130
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // code here\n  \n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvoccxydi: /tmp/tmpvoccxydi.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqsik896y: /tmp/tmpqsik896y.cpp:19: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660140929
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqsik896y: /tmp/tmpqsik896y.cpp:19: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660140929
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    std::string word;\n\
    \    if (s.empty()) {\n        return result;\n    }\n    for (std::string::iterator\
    \ it = s.begin(); it != s.end(); ++it) {\n        // Find the current character\n\
    \        std::string current_word;\n        std::string::iterator itr = it;\n\
    \        while (itr != s.end() && (*itr != ' ' && *itr != '\\t' && *itr != '\\\
    n')) {\n            current_word += *itr;\n            ++itr;\n        }\n   \
    \     \n        // Find the current word length after removing the current character\n\
    \        long word_length = current_word.size();\n        \n        // If the\
    \ current word length equals to n\n        if (word_length == n) {\n         \
    \   result.push_back(current_word);\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpe1i54i_a: /tmp/tmpe1i54i_a.cpp:41: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::list<std::string> res;\n    for (auto &c : s) {\n   \
    \     if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        \
    \    res.push_back(c);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjsmc6k_9.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpjsmc6k_9.cpp:18:28: error:\
    \ no matching function for call to \u2018std::__cxx11::list<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   18 |             res.push_back(c);\n      |  \
    \                          ^\nIn file included from /usr/include/c++/9/list:63,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:79,\n\
    \                 from /tmp/tmpjsmc6k_9.cpp:2:\n/usr/include/c++/9/bits/stl_list.h:1207:7:\
    \ note: candidate: \u2018void std::__cxx11::list<_Tp, _Alloc>::push_back(const\
    \ value_type&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::__cxx11::list<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1207 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1207:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1207 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_list.h:1212:7: note: candidate: \u2018void std::__cxx11::list<_Tp,\
    \ _Alloc>::push_back(std::__cxx11::list<_Tp, _Alloc>::value_type&&) [with _Tp\
    \ = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::__cxx11::list<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1212 |       push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_list.h:1212:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::__cxx11::list<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1212 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n\
    /tmp/tmpjsmc6k_9.cpp:20:12: error: could not convert \u2018res\u2019 from \u2018\
    std::__cxx11::list<std::__cxx11::basic_string<char> >\u2019 to \u2018std::vect"
  stdout: ''
  timestamp: 1660141130
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    // code here\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqiwzlb9p: /tmp/tmpqiwzlb9p.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141132
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::set<std::string> res;\n    for (int i = 0; i != s.size();\
    \ ++i) {\n        // find space\n        if (s[i] == ' ') {\n            std::string\
    \ word = s.substr(0, i);\n            // find n consonants\n            if (n\
    \ == 1) res.insert(word);\n            // find n vowels\n            else {\n\
    \                for (int j = 0; j < word.size(); ++j) {\n                   \
    \ if (std::count(word.begin(), word.end(), \n                                \
    \  (std::tolower(word[j]) - 'a' + 1)) == n) {\n                        res.insert(word);\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n        }\n        // find letter\n        else {\n            //\
    \ check vowels\n            for (int j = 0; j < s[i].size(); ++j) {\n        \
    \        if (std::count(s[i].begin(), s[i].end(), \n                         \
    \     (std::tolower(s[i]) - 'a' + 1)) == n) {\n                    res.insert(s.substr(0,\
    \ i));\n                    break;\n                }\n            }\n       \
    \ }\n    }\n    return std::move(res);\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdf06e5_b.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpdf06e5_b.cpp:36:38: error:\
    \ request for member \u2018size\u2019 in \u2018s.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   36 |             for (int\
    \ j = 0; j < s[i].size(); ++j) {\n      |                                    \
    \  ^~~~\n/tmp/tmpdf06e5_b.cpp:37:37: error: request for member \u2018begin\u2019\
    \ in \u2018s.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   37 |                 if (std::count(s[i].begin(),\
    \ s[i].end(),\n      |                                     ^~~~~\n/tmp/tmpdf06e5_b.cpp:37:51:\
    \ error: request for member \u2018end\u2019 in \u2018s.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   37 |                 if (std::count(s[i].begin(),\
    \ s[i].end(),\n      |                                                   ^~~\n\
    /tmp/tmpdf06e5_b.cpp:45:21: error: could not convert \u2018std::move<std::set<std::__cxx11::basic_string<char>\
    \ >&>(res)\u2019 from \u2018std::remove_reference<std::set<std::__cxx11::basic_string<char>\
    \ >&>::type\u2019 {aka \u2018std::set<std::__cxx11::basic_string<char> >\u2019\
    } to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   45 |     return\
    \ std::move(res);\n      |            ~~~~~~~~~^~~~~\n      |                \
    \     |\n      |                     std::remove_reference<std::set<std::__cxx11::basic_string<char>\
    \ >&>::type {aka std::set<std::__cxx11::basic_string<char> >}\n"
  stdout: ''
  timestamp: 1660141130
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if(!s.size())\n        return\
    \ v;\n    for(int i = 0; i<= s.size()-n; i++) {\n        for(int j=i+n; j < s.size();j++)\
    \ {\n            v.push_back(s.substr(i, j-i));\n        }\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4cga3h5z: /tmp/tmp4cga3h5z.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141132
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // Write your code here\n    std::vector<std::string> words;\n\
    \    std::string temp = s;\n    std::string vowels = \"aeiouy\";\n    std::string\
    \ consonants = \"bcdfghjklmnpqrstvwxyz\";\n    std::string::size_type vowel_count\
    \ = 0;\n    for (std::string::size_type i = 0; i < temp.length(); i++) {\n   \
    \     if (std::count(consonants.begin(), consonants.end(), temp[i]) == 0) {\n\
    \            words.push_back(temp);\n            temp = temp.substr(0, i) + temp.substr(i\
    \ + 1, temp.length());\n            i = i - 1;\n        }\n        else {\n  \
    \          if (std::count(vowels.begin(), vowels.end(), temp[i]) == 0) {\n   \
    \             vowel_count++;\n            }\n        }\n    }\n    if (vowel_count\
    \ == n) {\n        words.push_back(temp);\n    }\n    return words;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_erkbonp: /tmp/tmp_erkbonp.cpp:40: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141132
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if (s.empty()) \n     \
    \   return res;\n    std::stack<std::string> st;\n    st.push(s);\n    while (st.size())\
    \ {\n        std::string x = st.top();\n        st.pop();\n        for (char c\
    \ : x) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' || c == 'y') {\n                res.push_back(x);\n            }\n     \
    \       if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_') {\n    \
    \            st.push(x);\n            }\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> res;\n    // code\
    \ here\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpmzg1v0ae: /tmp/tmpmzg1v0ae.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141132
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqsik896y: /tmp/tmpqsik896y.cpp:19: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660140929
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if(s == \"\") return\
    \ result;\n    auto itr = std::find(s.begin(), s.end(), 'A');\n    if(itr != s.end())\
    \ itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr\
    \ != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n\
    \    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end())\
    \ itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr\
    \ != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n\
    \    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end())\
    \ itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr\
    \ != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n\
    \    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end())\
    \ itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr\
    \ != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n\
    \    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end())\
    \ itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr\
    \ != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n\
    \    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end())\
    \ itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr\
    \ != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n\
    \    if(itr != s.end()) itr++;\n    if(itr != s.end()) itr++;\n    if(itr != s.end())\
    \ \n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl5talt79.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpl5talt79.cpp:67:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   67 | }\n      | ^\n\
    /tmp/tmpl5talt79.cpp:67:1: warning: control reaches end of non-void function [-Wreturn-type]\n\
    \   67 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) {\n        return std::vector<std::string>();\n\
    \    }\n    std::vector<std::string> results;\n    size_t pos = 0, n = s.size();\n\
    \    while (pos < n) {\n        while (pos < n && s.at(pos) != '\\0') {\n    \
    \        if (s.at(pos) == ' ' || s.at(pos) == '\\0') {\n                if (pos\
    \ - n <= 1) {\n                    results.emplace_back(s.substr(pos, n - pos));\n\
    \                }\n                pos = n;\n                break;\n       \
    \     }\n            ++pos;\n        }\n        ++pos;\n    }\n    return results;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8_bgn3f_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp8_bgn3f_.cpp:19:21: error:\
    \ declaration of \u2018size_t n\u2019 shadows a parameter\n   19 |     size_t\
    \ pos = 0, n = s.size();\n      |                     ^\n"
  stdout: ''
  timestamp: 1660141131
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) {\n        return {};\n    }\n    std::vector<std::string>\
    \ words;\n    for (std::size_t i = 0; i < s.size(); ++i) {\n        if (s[i] ==\
    \ '\\'') {\n            if (s[i + 1] == '\\'') {\n                ++i;\n     \
    \       } else {\n                return {};\n            }\n        } else {\n\
    \            if (s[i] == ' ') {\n                if (s[i + 1] == ' ') {\n    \
    \                ++i;\n                } else {\n                    words.push_back(s.substr(0,\
    \ i));\n                    s.erase(0, i + 1);\n                }\n          \
    \  } else if (s[i] >= 'a' && s[i] <= 'z') {\n                if (s[i + 1] >= 'a'\
    \ && s[i + 1] <= 'z') {\n                    ++i;\n                } else {\n\
    \                    return {};\n                }\n            } else {\n   \
    \             return {};\n            }\n        }\n    }\n    if (n > 0) {\n\
    \        for (const auto& word : words) {\n            for (std::size_t i = 0;\
    \ i < n; ++i) {\n                if (word.find(s[i]) != std::string::npos) {\n\
    \                    words.push_back(word);\n                    break;\n    \
    \            }\n            }\n        }\n    }\n    return words;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpsd4tsytf: /tmp/tmpsd4tsytf.cpp:59: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141132
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    if(s.empty()) {\n   \
    \     return words;\n    }\n    \n    std::string temp = \"\", temp_ = \"\";\n\
    \    std::vector<std::string> temp_words;\n    \n    for(char c: s) {\n      \
    \  if(std::isalpha(c)) {\n            temp_ += c;\n        } else if(std::isspace(c))\
    \ {\n            temp_ += ' ';\n        } else {\n            temp_ += c;\n  \
    \      }\n        \n        if(temp_ == \"\") {\n            words.push(temp_words);\n\
    \            temp_words.clear();\n            temp_ = \"\";\n        }\n    }\n\
    \    \n    // temp_word has all words that contains exactly n consonants\n   \
    \ while(temp_words.size() > 0) {\n        for(size_t i = 0; i < temp_words.size();\
    \ i++) {\n            for(size_t j = 0; j < temp_words[i].size(); j++) {\n   \
    \             if(temp_words[i][j] == temp_ && std::count(temp_words.begin(), temp_words.end(),\
    \ temp_words[i]) == n) {\n                    temp_words.erase(temp_words.begin()\
    \ + i);\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    \n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl9_aiuf2.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpl9_aiuf2.cpp:33:19: error:\
    \ \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member\
    \ named \u2018push\u2019\n   33 |             words.push(temp_words);\n      |\
    \                   ^~~~\n/tmp/tmpl9_aiuf2.cpp:43:37: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} and \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019})\n   43 |                 if(temp_words[i][j]\
    \ == temp_ && std::count(temp_words.begin(), temp_words.end(), temp_words[i])\
    \ == n) {\nIn file included from /usr/include/c++/9/regex:62,\n              \
    \   from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n            \
    \     from /tmp/tmpl9_aiuf2.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \ candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpl9_aiuf2.cpp:43:40:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   43 |                 if(temp_words[i][j] == temp_\
    \ && std::count(temp_words.begin(), temp_words.end(), temp_words[i]) == n) {\n\
    \      |                                        ^~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpl9_aiuf2.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::"
  stdout: ''
  timestamp: 1660141131
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // your code here\n    std::vector<std::string> ans;\n   \
    \ \n    std::string str = s;\n    if (n == 0) return ans;\n    \n    while (n\
    \ > 0) {\n        int len = 0;\n        while (n < s.size() && s[n] == ' ') len++;\n\
    \        ans.push_back(s.substr(0, len));\n        s = s.substr(len);\n      \
    \  n--;\n    }\n    \n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141137
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    long begin = 0;\n    long\
    \ end = s.size();\n    long count = 0;\n    while(begin < end){\n        if(s.at(begin)\
    \ == ' ') begin++;\n        else if(s.at(begin) == 'a') begin++;\n        else\
    \ if(s.at(begin) == 'u' ) begin++;\n        else if(s.at(begin) == 'c' ) begin++;\n\
    \        else if(s.at(begin) == 'l' ) begin++;\n        else if(s.at(begin) ==\
    \ 'i' ) begin++;\n        else if(s.at(begin) == 's' ) begin++;\n        else\
    \ if(s.at(begin) == 'e' ) begin++;\n        else if(s.at(begin) == 'r' ) begin++;\n\
    \        else if(s.at(begin) == 'a' ) begin++;\n        else if(s.at(begin) ==\
    \ 'm' ) begin++;\n        else if(s.at(begin) == 'y' ) begin++;\n        else\
    \ if(s.at(begin) == 'k' ) begin++;\n        else if(s.at(begin) == 'e' ) begin++;\n\
    \        else if(s.at(begin) == 'd' ) begin++;\n        else if(s.at(begin) ==\
    \ 'o' ) begin++;\n        else if(s.at(begin) == 'w' ) begin++;\n        else\
    \ if(s.at(begin) == 'n' ) begin++;\n        else if(s.at(begin) == 't' ) begin++;\n\
    \        else if(s.at(begin) == 'l' ) begin++;\n        else if(s.at(begin) ==\
    \ 'p' ) begin++;\n        else if(s.at(begin) == 'r' ) begin++;\n        else\
    \ if(s.at(begin) == 'a' ) begin++;\n        else if(s.at(begin) == 'i' ) begin++;\n\
    \        else if(s.at(begin) == 's' ) begin++;\n        else if(s.at(begin) ==\
    \ 'o' ) begin++;\n        else if(s.at(begin) == 'r' ) begin++;\n        else\
    \ if(s.at(begin) == 'c' ) begin++;\n        else if(s.at(begin) == 'h' ) begin++;\n\
    \        else if(s.at(begin) == 'l' ) begin++;\n        else if(s.at(begin) ==\
    \ 'o' ) begin++;\n        else if(s.at(begin) == 'd' ) begin++;\n        else\
    \ if(s.at(begin) == 'w' ) begin++;\n        else if(s.at(begin) == 'n' ) begin++;\n\
    \        else if(s.at(begin) == 't' ) begin++;\n        else if(s.at(begin) ==\
    \ 'p' ) begin++;\n        else if(s.at(begin) == 'a' ) begin++;\n        else\
    \ if(s.at(begin) == 'u' ) begin++;\n        else if(s.at(begin) == 'f' ) begin++;\n\
    \        else if(s.at(begin) == 'i' ) begin++;\n        else if(s.at(begin) ==\
    \ 'v' ) \n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphk_kdvxn.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmphk_kdvxn.cpp:61:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   61 | }\n      | ^\n\
    /tmp/tmphk_kdvxn.cpp:62:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   62 | int main() {\n      |            ^\n/tmp/tmphk_kdvxn.cpp:71:1:\
    \ error: expected \u2018}\u2019 at end of input\n   71 | }\n      | ^\n/tmp/tmphk_kdvxn.cpp:14:62:\
    \ note: to match this \u2018{\u2019\n   14 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmphk_kdvxn.cpp:71:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   71 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::sort(s.begin(), s.end());\n  \n  std::vector<std::string>\
    \ res;\n  \n  for (auto &word : s)\n    \n    if (word == \" \") {\n      \n \
    \     if (res.empty())\n        \n        break;\n      \n      if (res.back()\
    \ == word)\n        \n        res.pop_back();\n      \n      else\n        \n\
    \        res.push_back(word);\n    }\n    \n  res.resize(res.capacity());\n  \n\
    \  std::vector<std::string> tmp;\n  \n  for (auto &word : s) {\n    \n    \n \
    \   bool inword = false;\n    \n    for (auto &x : tmp) {\n      \n      \n  \
    \    if (word == x) {\n        \n        inword = true;\n        break;\n    \
    \  }\n    }\n    \n    \n    if (!inword)\n      \n      tmp.push_back(word);\n\
    \    \n  }\n  \n  for (auto &x : tmp) {\n    \n    if (x.size() >= n)\n      \n\
    \      res.push_back(x);\n  }\n  \n  return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3eh0hd3r.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp3eh0hd3r.cpp:21:17: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   21\
    \ |     if (word == \" \") {\n      |                 ^~~\n/tmp/tmp3eh0hd3r.cpp:27:22:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   27 |       if (res.back() == word)\n      |      \
    \     ~~~~~~~~~~ ^~ ~~~~\n      |                   |     |\n      |         \
    \          |     char\n      |                   __gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3eh0hd3r.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp3eh0hd3r.cpp:27:25:\
    \ note:   \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   27\
    \ |       if (res.back() == word)\n      |                         ^~~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp3eh0hd3r.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note:"
  stdout: ''
  timestamp: 1660141131
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) {\n        return {};\n    }\n    if (n ==\
    \ 0) {\n        return {s};\n    }\n    std::vector<std::string> result;\n   \
    \ auto search = [&](size_t n) {\n        for (const auto& word : result) {\n \
    \           for (size_t i = 0; i < word.length() && i < n; ++i) {\n          \
    \      if (word[i] != s[i] && word[i] != '\\n') {\n                    return\
    \ false;\n                }\n            }\n            if (i == n) {\n      \
    \          result.push_back(word);\n                return true;\n           \
    \ }\n        }\n        return false;\n    };\n    auto inserted = [&](std::string\
    \ word) {\n        bool found = false;\n        for (auto& word : result) {\n\
    \            for (size_t i = 0; i < word.length(); ++i) {\n                if\
    \ (word[i] == ' ') {\n                    return false;\n                }\n \
    \           }\n            found = true;\n        }\n        result.push_back(word);\n\
    \        return found;\n    };\n    for (size_t i = 0; i < s.length(); ++i) {\n\
    \        if (s[i] == ' ') {\n            std::string word(s.begin() + i, s.end());\n\
    \            if (!insert(word)) {\n                result.push_back(word);\n \
    \           }\n        }\n    }\n    while (!result.empty()) {\n        if (search(n))\
    \ {\n            return result;\n        }\n        if (search(n + 1)) {\n   \
    \         break;\n        }\n        n += 1;\n    }\n    return {};\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmokhoy5i.cpp: In lambda function:\n/tmp/tmpmokhoy5i.cpp:29:17:\
    \ error: \u2018i\u2019 was not declared in this scope\n   29 |             if\
    \ (i == n) {\n      |                 ^\n/tmp/tmpmokhoy5i.cpp: In function \u2018\
    std::vector<std::__cxx11::basic_string<char> > select_words(std::string, long\
    \ int)\u2019:\n/tmp/tmpmokhoy5i.cpp:52:18: error: \u2018insert\u2019 was not declared\
    \ in this scope; did you mean \u2018inserted\u2019?\n   52 |             if (!insert(word))\
    \ {\n      |                  ^~~~~~\n      |                  inserted\n"
  stdout: ''
  timestamp: 1660141132
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> retVec;\n    if (s.size() <= 0) {\n\
    \        return retVec;\n    }\n    // Split s by space into a vector of words.\n\
    \    std::vector<std::string> words = std::split(s, \" \");\n    // Iterate over\
    \ the words in the vector.\n    for (std::vector<std::string>::iterator it = words.begin();\
    \ it != words.end(); ++it) {\n        bool flag = false;\n        // Iterate over\
    \ the consonants in word.\n        for (char c : *it) {\n            if (c ==\
    \ 'b') {\n                flag = true;\n            }\n        }\n        // If\
    \ word contains n consonants then add it to the vector.\n        if (flag) {\n\
    \            retVec.emplace_back(*it);\n        }\n    }\n    return retVec;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnk_nehxg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpnk_nehxg.cpp:20:43: error:\
    \ \u2018split\u2019 is not a member of \u2018std\u2019\n   20 |     std::vector<std::string>\
    \ words = std::split(s, \" \");\n      |                                     \
    \      ^~~~~\n"
  stdout: ''
  timestamp: 1660141132
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end());\n    auto it = std::unique(s.begin(),\
    \ s.end());\n    s.erase(it, s.end());\n    std::vector<std::string> result;\n\
    \    if (s.empty())\n        return result;\n    for (auto i : s) {\n        //\
    \ if the substring contains n consonants, the string is added to the result.\n\
    \        if (std::count(i.begin(), i.end(), N_CONSONANTS) == n)\n            result.push_back(i);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpprbyyita.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpprbyyita.cpp:23:26: error:\
    \ request for member \u2018begin\u2019 in \u2018i\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |         if (std::count(i.begin(), i.end(), N_CONSONANTS)\
    \ == n)\n      |                          ^~~~~\n/tmp/tmpprbyyita.cpp:23:37: error:\
    \ request for member \u2018end\u2019 in \u2018i\u2019, which is of non-class type\
    \ \u2018char\u2019\n   23 |         if (std::count(i.begin(), i.end(), N_CONSONANTS)\
    \ == n)\n      |                                     ^~~\n/tmp/tmpprbyyita.cpp:23:44:\
    \ error: \u2018N_CONSONANTS\u2019 was not declared in this scope\n   23 |    \
    \     if (std::count(i.begin(), i.end(), N_CONSONANTS) == n)\n      |        \
    \                                    ^~~~~~~~~~~~\n/tmp/tmpprbyyita.cpp:24:31:\
    \ error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   24 |             result.push_back(i);\n      |\
    \                               ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpprbyyita.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/"
  stdout: ''
  timestamp: 1660141131
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::vector<std::string> words;\n    //\
    \ code here\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpk7zxitae: /tmp/tmpk7zxitae.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141133
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    if (s.empty()) return ans;\n\
    \    long i = 0;\n    std::vector<bool> v(s.size(), false);\n    for(auto const\
    \ &c : s) {\n        if (!v[i]) {\n            ans.push_back({c});\n         \
    \   v[i] = true;\n        } else {\n            for (auto j=i;j<v.size()-1;j++)\
    \ {\n                if (v[j] && v[j+1]) break;\n            }\n            if\
    \ (v[j] && v[j+1]) {\n                ans.push_back({s.substr(i, j+1-i)});\n \
    \               i = j+1;\n                for (auto j=i;j<v.size()-1;j++) {\n\
    \                    v[j] = false;\n                }\n            }\n       \
    \ }\n    }\n    if (i < s.size())\n        ans.push_back({s.substr(i)});\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5fothol8.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5fothol8.cpp:27:19: error:\
    \ \u2018j\u2019 was not declared in this scope\n   27 |             if (v[j] &&\
    \ v[j+1]) {\n      |                   ^\n/tmp/tmp5fothol8.cpp:28:51: error: no\
    \ matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(<brace-enclosed initializer list>)\u2019\n   28 |             \
    \    ans.push_back({s.substr(i, j+1-i)});\n      |                           \
    \                        ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5fothol8.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no "
  stdout: ''
  timestamp: 1660141132
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if (s.empty()) {\n \
    \       return result;\n    }\n    \n    // Use n to store the count of each letter\
    \ \n    // and use n to store the last letter seen \n    std::vector<int> counts(n+1);\n\
    \    int last_index = n; \n    \n    for (char c : s) {\n        // Update counts\n\
    \        counts[c]++; \n        if (counts[c] == last_index) {\n            result.push_back(std::string(1,\
    \ c));\n        }\n        last_index = counts[c]; \n    }\n    \n    return result;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4sfjlr8m: /tmp/tmp4sfjlr8m.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141133
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    std::vector<std::string>\
    \ sub_list;\n    \n    res.push_back(\"\");\n    if(s.empty()) \n        return\
    \ res;\n    \n    for(char c : s) {\n        \n        if(c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n            if(n == 0) \n            \
    \    break;\n            else \n                if(n == 1)\n                 \
    \   res.push_back(s);\n                else {\n                    sub_list.push_back(s);\n\
    \                    n--;\n                    if(n == 0) \n                 \
    \       res.push_back(sub_list);\n                }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp12rxwv6b.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp12rxwv6b.cpp:34:47: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::vector<std::__cxx11::basic_string<char> >&)\u2019\n   34 |\
    \                         res.push_back(sub_list);\n      |                  \
    \                             ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp12rxwv6b.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::bas"
  stdout: ''
  timestamp: 1660141132
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::list<std::string> res;\n  if (s.length() == 0)\n    return\
    \ res;\n  if (n == 0) {\n    return res;\n  }\n  \n  long lenS = s.length();\n\
    \  long lenN = n;\n  if (lenS > lenN)\n    lenN = lenS;\n  \n  if (n % 2 == 0)\
    \ {\n    // even n - split on every other character\n    for (long i = 0, j =\
    \ 0, len = lenS; i < len; i += 2) {\n      std::string prefix = s.substr(i, j);\n\
    \      std::string suffix = s.substr(i + 1, j + 1);\n      if (suffix == prefix)\n\
    \        continue;\n      \n      res.push_back(prefix);\n      res.push_back(suffix);\n\
    \      j += 2;\n    }\n  }\n  else {\n    // odd n - split on every other word\
    \ but first and last words\n    for (long i = 0, j = 0, len = lenS; i < len; i\
    \ += 2) {\n      std::string prefix = s.substr(i, j);\n      std::string suffix\
    \ = s.substr(i + 1, j + 1);\n      \n      if (suffix == prefix)\n        continue;\n\
    \      \n      res.push_back(prefix);\n      res.push_back(suffix);\n      j +=\
    \ 2;\n    }\n  }\n  \n  return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2b_pbarl.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2b_pbarl.cpp:17:12: error:\
    \ could not convert \u2018res\u2019 from \u2018std::__cxx11::list<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   17\
    \ |     return res;\n      |            ^~~\n      |            |\n      |   \
    \         std::__cxx11::list<std::__cxx11::basic_string<char> >\n/tmp/tmp2b_pbarl.cpp:19:12:\
    \ error: could not convert \u2018res\u2019 from \u2018std::__cxx11::list<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   19\
    \ |     return res;\n      |            ^~~\n      |            |\n      |   \
    \         std::__cxx11::list<std::__cxx11::basic_string<char> >\n/tmp/tmp2b_pbarl.cpp:55:10:\
    \ error: could not convert \u2018res\u2019 from \u2018std::__cxx11::list<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   55\
    \ |   return res;\n      |          ^~~\n      |          |\n      |         \
    \ std::__cxx11::list<std::__cxx11::basic_string<char> >\n"
  stdout: ''
  timestamp: 1660141132
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> output;\n    std::set<std::string>\
    \ seen;\n    for (std::string word : s) {\n        std::set<std::string> words\
    \ = select_words(word, n, seen);\n        for (std::string word : words) {\n \
    \           if (seen.count(word) == 0) {\n                output.push_back(word);\n\
    \                seen.insert(word);\n            }\n        }\n    }\n    return\
    \ output;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwso1e4ev.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpwso1e4ev.cpp:17:29: error:\
    \ conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   17 |     for\
    \ (std::string word : s) {\n      |                             ^\n/tmp/tmpwso1e4ev.cpp:18:65:\
    \ error: too many arguments to function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019\n   18 |         std::set<std::string>\
    \ words = select_words(word, n, seen);\n      |                              \
    \                                   ^\n/tmp/tmpwso1e4ev.cpp:14:26: note: declared\
    \ here\n   14 | std::vector<std::string> select_words(std::string s, long n) {\n\
    \      |                          ^~~~~~~~~~~~\n/tmp/tmpwso1e4ev.cpp:18:51: error:\
    \ conversion from \u2018std::vector<std::__cxx11::basic_string<char> >\u2019 to\
    \ non-scalar type \u2018std::set<std::__cxx11::basic_string<char> >\u2019 requested\n\
    \   18 |         std::set<std::string> words = select_words(word, n, seen);\n\
    \      |                                       ~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141132
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    // your code goes here\n\
    \    res.push_back(\"\");\n    std::string temp;\n    int counter = 0;\n    long\
    \ counter2 = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] ==\
    \ ' ') {\n            counter++;\n        }\n        if (s[i] == 'a') {\n    \
    \        counter2++;\n        }\n    }\n    for (int i = 0; i < s.size(); i++)\
    \ {\n        if (s[i] == ' ') {\n            counter--;\n        }\n        if\
    \ (s[i] == 'a') {\n            counter2--;\n        }\n    }\n    while (counter\
    \ > 0 || counter2 > 0) {\n        if (counter > 0 && counter2 == 0) {\n      \
    \      temp = temp + \" \";\n        }\n        if (counter2 == 0 && counter >\
    \ 0) {\n            temp = temp + \" \";\n        }\n        if (counter == 0\
    \ && counter2 > 0) {\n            temp = temp + \" \";\n        }\n        if\
    \ (counter == 0 && counter < counter2) {\n            res.push_back(temp);\n \
    \           counter = 0;\n        }\n        if (counter > 0 && counter2 == counter)\
    \ {\n            res.push_back(temp);\n            counter = 0;\n        }\n \
    \       if (counter2 == 0 && counter < counter2) {\n            res.push_back(temp);\n\
    \            counter2 = 0;\n        }\n        if (counter > 0 && counter2 < counter)\
    \ {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n\
    \        if (counter2 < 0 && counter < counter2) {\n            res.push_back(temp);\n\
    \            counter2 = 0;\n        }\n        if (counter2 == 0 && counter2 <\
    \ counter) {\n            res.push_back(temp);\n            counter2 = 0;\n  \
    \      }\n        if (counter > 0 && counter2 < counter) {\n            res.push_back(temp);\n\
    \            counter2 = 0;\n        }\n        if (counter2 < 0 && counter < counter2)\
    \ {\n            res.push_back(temp);\n            counter2 = 0;\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_ho991g7: /tmp/tmp_ho991g7.cpp:84: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141134
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  assert(s.size() > 0);\n  long maxWordLength = s.size() - 1;\n\
    \  std::vector<std::string> v;\n  \n  for (int i = n; i < maxWordLength; i--)\
    \ {\n    if (s.at(i) == 'a' || s.at(i) == 'e' || s.at(i) == 'i' || s.at(i) ==\
    \ 'o' || s.at(i) == 'u') {\n      v.push_back(s.substr(0, i));\n    }\n  }\n \
    \ return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::at: __n (which is 18446744073709551615) >= this->size() (which\
    \ is 22)\n"
  stdout: ''
  timestamp: 1660141134
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s == \"\") {\n        return {};\n    }\n    \n    long\
    \ l = 0;\n    \n    for (auto& c : s) {\n        l += 1;\n    }\n\n    std::vector<std::string>\
    \ ret;\n    \n    if (l == 0) {\n        return ret;\n    }\n\n    std::vector<bool>\
    \ seen(n, true);\n    \n    for (auto i = 0; i < (s.size() - n); i++) {\n    \
    \    auto j = i;\n        for (auto k = i + 1; k < (s.size() - 1); k++) {\n  \
    \          auto c = s.at(i + k);\n            \n            if (seen[k] && c !=\
    \ ' ') {\n                ret.push_back(s.substr(i, j));\n                j =\
    \ k + 1;\n                break;\n            }\n        }\n    }\n    \n    return\
    \ ret;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::at: __n (which is 23) >= this->size() (which is 22)\n"
  stdout: ''
  timestamp: 1660141134
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> list;\n    std::stack<std::string>\
    \ st;\n    \n    for (int i = 0; i != s.length(); ++i) {\n        char c = s[i];\n\
    \        if (is_consonant(c)) {\n            if (!st.empty() && st.top() == c)\
    \ {\n                st.top() += c;\n            } else {\n                st.push(c);\n\
    \            }\n        } else {\n            if (st.empty()) \n             \
    \   list.push_back(s.substr(i));\n            if (st.top() == c)\n           \
    \     st.pop();\n        }\n    }\n    \n    return list;\n}\nint main() {\n \
    \   auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzu0ie7nc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpzu0ie7nc.cpp:20:13: error:\
    \ \u2018is_consonant\u2019 was not declared in this scope\n   20 |         if\
    \ (is_consonant(c)) {\n      |             ^~~~~~~~~~~~\n/tmp/tmpzu0ie7nc.cpp:21:41:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   21 |             if (!st.empty() && st.top() == c)\
    \ {\n      |                                ~~~~~~~~ ^~ ~\n      |           \
    \                           |     |\n      |                                 \
    \     |     char\n      |                                      __gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzu0ie7nc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpzu0ie7nc.cpp:21:44:\
    \ note:   \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   21\
    \ |             if (!st.empty() && st.top() == c) {\n      |                 \
    \                           ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gn"
  stdout: ''
  timestamp: 1660141133
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    return {};\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpfaqpi3sk: /tmp/tmpfaqpi3sk.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141126
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // your code goes here\n    std::vector<std::string> v;\n\
    \    long l=0;\n    for(int i=0;i<s.size();++i)\n    {\n        if(s[i]==' ')\n\
    \        {\n            v.push_back(s.substr(0,i));\n            l=i;\n      \
    \  }\n    }\n    \n    if(l==0)\n        return v;\n    \n    v.push_back(s.substr(0,l));\n\
    \    \n    for(auto j=l+1;j<s.size();++j)\n    {\n        if(s[j]==' ')\n    \
    \        continue;\n        if(s[l]==s[j])\n        {\n            v.push_back(s.substr(0,j));\n\
    \            break;\n        }\n        if(s[l]+s[j] == s[n])\n        {\n   \
    \         v.push_back(s.substr(0,j));\n            break;\n        }\n    }\n\
    \    return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvbf7teta: /tmp/tmpvbf7teta.cpp:51: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141134
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(s.length()==0) {\n \
    \       return res;\n    }\n    // Use a std::map to store unique words (with\
    \ frequency value) and sort them by frequency\n    std::map<std::string, int>\
    \ word_counts;\n    for (std::size_t i = 0; i < s.length(); i++) {\n        char\
    \ c = s[i];\n        if(isalpha(c)) {\n            if(!word_counts.count(c)) {\n\
    \                word_counts[c] = 0;\n            }\n            word_counts[c]++;\n\
    \        }\n    }\n    std::map<std::string, int>::iterator it;\n    it=word_counts.begin();\n\
    \    while(it!=word_counts.end()) {\n        std::string word=it->first;\n   \
    \     int freq=it->second;\n        if(word_counts[word]==n) {\n            res.push_back(word);\n\
    \            word_counts.erase(it);\n        }\n        it++;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplo_lqhtt.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmplo_lqhtt.cpp:24:36: error:\
    \ no matching function for call to \u2018std::map<std::__cxx11::basic_string<char>,\
    \ int>::count(char&)\u2019\n   24 |             if(!word_counts.count(c)) {\n\
    \      |                                    ^\nIn file included from /usr/include/c++/9/map:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmplo_lqhtt.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:1214:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::size_type std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::count(const key_type&) const [with _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc =\
    \ std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::size_type = long unsigned int; std::map<_Key, _Tp, _Compare,\
    \ _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\n 1214 |       count(const\
    \ key_type& __x) const\n      |       ^~~~~\n/usr/include/c++/9/bits/stl_map.h:1214:29:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1214 |       count(const key_type& __x) const\n      |             ~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_map.h:1220:2: note: candidate: \u2018template<class\
    \ _Kt> decltype (((const std::map<_Key, _Tp, _Compare, _Alloc>*)this)->std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::_M_t._M_count_tr(__x)) std::map<_Key, _Tp, _Compare,\
    \ _Alloc>::count(const _Kt&) const [with _Kt = _Kt; _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc =\
    \ std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >]\u2019\
    \n 1220 |  count(const _Kt& __x) const -> decltype(_M_t._M_count_tr(__x))\n  \
    \    |  ^~~~~\n/usr/include/c++/9/bits/stl_map.h:1220:2: note:   template argument\
    \ deduction/substitutio"
  stdout: ''
  timestamp: 1660141133
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // Your code here\n  std::vector<std::string> v;\n  std::size_t\
    \ found = s.find_first_of(\"aeiou\");\n  for(std::size_t i = 0; found != std::string::npos;\
    \ i++) {\n    v.push_back(s.substr(found, i));\n    found = s.find_first_of(\"\
    aeiou\", found + 1);\n  }\n  for(std::size_t i = 0; i < v.size(); i++) {\n   \
    \ if (std::count(v[i].begin(), v[i].end(), ' ') >= n) {\n      v.erase(v.begin()\
    \ + i);\n    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp0jurvhh0: /tmp/tmp0jurvhh0.cpp:31: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141134
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(!s.empty()) {\n    \
    \    std::vector<std::string>::iterator it;\n        for(it = std::begin(s);it!=std::end(s);++it)\
    \ {\n            std::vector<std::string>::iterator it2;\n            for( it2\
    \ = std::begin(s);it2!=std::end(s);++it2) {\n                std::string str =\
    \ *it;\n                str.replace(str.begin(),str.end(),\"\");\n           \
    \     if(str.find(*it2)!=std::string::npos) {\n                    res.push_back(str);\n\
    \                }\n            }\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5gs_0d_g.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5gs_0d_g.cpp:18:30: error:\
    \ no match for \u2018operator=\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   18 |         for(it = std::begin(s);it!=std::end(s);++it) {\n\
    \      |                              ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5gs_0d_g.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note: candidate: \u2018constexpr __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >& __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >::operator=(const __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&)\u2019\n  784 |     class\
    \ __normal_iterator\n      |           ^~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018const __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&\u2019\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note: candidate: \u2018constexpr __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >& __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<"
  stdout: ''
  timestamp: 1660141133
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    int n = s.find_first_not_of(\" \");\n    s = s.substr(0, n);\n\
    \    // Write your code here\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcoh5ty37.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpcoh5ty37.cpp:15:9: error:\
    \ declaration of \u2018int n\u2019 shadows a parameter\n   15 |     int n = s.find_first_not_of(\"\
    \ \");\n      |         ^\n/tmp/tmpcoh5ty37.cpp:18:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   18 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141133
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n\tstd::vector<std::string> v;\n\tfor(int i=0;i<s.length();i++){\n\
    \t\tint j = i;\n\t\twhile(j<s.length()){\n\t\t\tif(s[j] == ' ' || s[j] == '.'){\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(s[j] == 'o' || s[j] == 'u' || s[j] == 'e' ||\
    \ s[j] == 'i' || s[j] == 'a'){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\
    \tv.push_back(string(\"Hello world\")[j]);\n\t}\n\treturn v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv0f0ac4h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpv0f0ac4h.cpp:27:15: error:\
    \ \u2018string\u2019 was not declared in this scope\n   27 |   v.push_back(string(\"\
    Hello world\")[j]);\n      |               ^~~~~~\n/tmp/tmpv0f0ac4h.cpp:27:15:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpv0f0ac4h.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpv0f0ac4h.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n"
  stdout: ''
  timestamp: 1660141133
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    \n    std::unordered_set<std::string> words;\n    std::vector<std::string>\
    \ wordVec;\n    \n    while(s.size()) {\n        std::string temp = s;\n     \
    \   std::replace(temp.begin(), temp.end(), ' ', '0');\n        \n        // Remove\
    \ space\n        temp = std::string(temp.begin(), temp.end());\n        std::transform(temp.begin(),\
    \ temp.end(), temp.begin(), ::tolower);\n        \n        // Remove digits\n\
    \        std::transform(temp.begin(), temp.end(), temp.begin(), ::tolower);\n\
    \        std::for_each(temp.begin(), temp.end(), ::isdigit);\n        std::sort(temp.begin(),\
    \ temp.end());\n        temp.resize(std::distance(temp.begin(), temp.end()));\n\
    \        \n        // Find first n consecutive letters\n        auto pos = 0;\n\
    \        for(; pos < temp.length(); ++pos) {\n            auto ch = temp[pos];\n\
    \            \n            if(ch == ' ')\n                pos = temp.length();\n\
    \            else if(ch == '0')\n                pos = temp.length();\n      \
    \      else if(ch != ' ' && words.find(ch) == words.end()) {\n               \
    \ words.insert(ch);\n            }\n        }\n        \n        // Remove first\
    \ n letters\n        if(words.size() > n)\n            words.erase(words.begin(),\
    \ words.begin() + n);\n        \n        // Add remaining letters\n        while(words.size()\
    \ < n) {\n            std::string w = \"\\0\";\n            std::cin >> w;\n \
    \           \n            std::replace(w.begin(), w.end(), ' ', '0');\n      \
    \      \n            // Remove space\n            w = std::string(w.begin(), w.end());\n\
    \            std::transform(w.begin(), w.end(), w.begin(), ::tolower);\n     \
    \       \n            // Remove digits\n            std::transform(w.begin(),\
    \ w.end(), w.begin(), ::tolower);\n            std::for_each(w.begin(), w.end(),\
    \ ::isdigit);\n            std::sort(w.begin(), w.end());\n            w.resize(std::distance(w.begin(),\
    \ w.end()));\n            \n            words.insert(w);\n        }\n        \n\
    \        // Insert into vector\n        wordVec.push_back(std::move(words));\n\
    \    }\n    \n    return wordVec;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpiq24hbzx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpiq24hbzx.cpp:42:47: error:\
    \ no matching function for call to \u2018std::unordered_set<std::__cxx11::basic_string<char>\
    \ >::find(char&)\u2019\n   42 |             else if(ch != ' ' && words.find(ch)\
    \ == words.end()) {\n      |                                               ^\n\
    In file included from /usr/include/c++/9/unordered_set:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n                 from\
    \ /tmp/tmpiq24hbzx.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:650:7: note:\
    \ candidate: \u2018std::unordered_set<_Value, _Hash, _Pred, _Alloc>::iterator\
    \ std::unordered_set<_Value, _Hash, _Pred, _Alloc>::find(const key_type&) [with\
    \ _Value = std::__cxx11::basic_string<char>; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _Pred = std::equal_to<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::iterator = std::__detail::_Node_iterator<std::__cxx11::basic_string<char>,\
    \ true, true>; std::unordered_set<_Value, _Hash, _Pred, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\
    \n  650 |       find(const key_type& __x)\n      |       ^~~~\n/usr/include/c++/9/bits/unordered_set.h:650:28:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  650 |       find(const key_type& __x)\n      |            ~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/unordered_set.h:654:7: note: candidate: \u2018std::unordered_set<_Value,\
    \ _Hash, _Pred, _Alloc>::const_iterator std::unordered_set<_Value, _Hash, _Pred,\
    \ _Alloc>::find(const key_type&) const [with _Value = std::__cxx11::basic_string<char>;\
    \ _Hash = std::hash<std::__cxx11::basic_string<char> >; _Pred = std::equal_to<std::__cxx11::basic_string<char>\
    \ >; _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::unordered_set<_Value,\
    \ _Hash, _Pred, _Alloc>::const_iterato"
  stdout: ''
  timestamp: 1660141133
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> ans;\n    \n    long cur = 0;\n \
    \   long curr = 0;\n    \n    for (int i = 0; i < s.size(); i++) {\n        if\
    \ (s[i] == '.' || s[i] == ' ') {\n            if (s[i+1] == '.' || s[i+1] == '\
    \ ') {\n                curr++;\n            } else {\n                curr =\
    \ 0;\n            }\n            \n            if (curr == n) {\n            \
    \    ans.push_back(s.substr(curr, i-curr));\n                curr = 0;\n     \
    \       }\n            \n            if (curr > 0) {\n                ans.push_back(s.substr(curr,\
    \ i-curr));\n                curr = 0;\n            }\n        } else if (s[i]\
    \ != ' ') {\n            if (curr == 0) {\n                ans.push_back(s.substr(curr,\
    \ i-curr));\n                curr = 0;\n            }\n            \n        \
    \    if (curr > 0) {\n                ans.push_back(s.substr(curr, i-curr));\n\
    \                curr = 0;\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpf7c22sf9: /tmp/tmpf7c22sf9.cpp:54: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    assert(s.length() != 0);\n    std::vector<std::string> result;\n\
    \    // TODO: implement me\n    return result;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpzkg5hbno: /tmp/tmpzkg5hbno.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141134
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end());\n    std::vector<std::string>\
    \ ret;\n    size_t count = 0;\n    for (auto i : s) {\n        if (count < n)\
    \ {\n            ret.push_back(i);\n            count++;\n        }\n        if\
    \ (count == n)\n            break;\n    }\n    return ret;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3z8kzj_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmph3z8kzj_.cpp:20:28: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   20 |             ret.push_back(i);\n      |  \
    \                          ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph3z8kzj_.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~"
  stdout: ''
  timestamp: 1660141134
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    if (s.empty())\n    \
    \    return words;\n    std::string temp;\n    for (auto i = s.begin(); i != s.end();\
    \ i++) {\n        if ((*i) != '-') {\n            words.push_back(i);\n      \
    \  }\n    }\n    for (auto i = words.begin(); i != words.end(); i++) {\n     \
    \   std::string str = *i;\n        if (str.size() == 1) {\n            temp.push_back(str);\n\
    \            continue;\n        }\n        for (auto j = str.begin(); j != str.end();\
    \ ++j) {\n            if (j != str.begin()) {\n                temp.push_back(*j);\n\
    \            }\n        }\n    }\n    long len = 0;\n    for (auto i = temp.begin();\
    \ i != temp.end(); i++) {\n        if (len == n) {\n            words.push_back(str);\n\
    \        }\n        len++;\n    }\n    return words;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu476qmvm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpu476qmvm.cpp:21:30: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >&)\u2019\n   21 |             words.push_back(i);\n      |                \
    \              ^\nIn file included from /usr/include/c++/9/vector:67,\n      \
    \           from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpu476qmvm.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018const value_type&\u2019 {aka\
    \ \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >"
  stdout: ''
  timestamp: 1660141134
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> res;\n  // code goes here\n  return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp1_ibvjyp: /tmp/tmp1_ibvjyp.cpp:21: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> ans;\n  std::string temp = \"\";\n\
    \  for (int i = 0; i < s.length(); i++) {\n    if (s.at(i) == ' ') {\n      temp.clear();\n\
    \      ans.push_back(temp);\n      temp.clear();\n      continue;\n    }\n   \
    \ for (int j = 0; j < s.length(); j++) {\n      if (s.at(j) == ' ') {\n      \
    \  temp.clear();\n        ans.push_back(temp);\n        temp.clear();\n      \
    \  continue;\n      }\n      if (s.at(j) == s.at(i)) {\n        temp += s.at(j);\n\
    \      }\n      if (temp.size() == n) {\n        ans.push_back(temp);\n      \
    \  temp.clear();\n      }\n    }\n  }\n  if (temp.size() > 0) {\n    ans.push_back(temp);\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpuh59i7po: /tmp/tmpuh59i7po.cpp:47: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.empty()) return {};\n    \n    std::vector<std::string>\
    \ word_vec;\n    \n    if(n >= s.size()) {\n        for(auto &c: s) {\n      \
    \      if((int)c == 'a' || (int)c == 'e' || (int)c == 'i' || (int)c == 'o' ||\
    \ (int)c == 'u') {\n                word_vec.push_back(c);\n            }\n  \
    \      }\n        return word_vec;\n    }\n    \n    for(auto &c: s) {\n     \
    \   if((int)c == 'a' || (int)c == 'e' || (int)c == 'i' || (int)c == 'o' || (int)c\
    \ == 'u') {\n            word_vec.push_back(c);\n        }\n    }\n    \n    for(auto\
    \ &c: s) {\n        if((int)c == 'a' || (int)c == 'e' || (int)c == 'i' || (int)c\
    \ == 'o' || (int)c == 'u') {\n            word_vec.push_back(c);\n        }\n\
    \    }\n    \n    for(auto &c: s) {\n        if((int)c == 'a' || (int)c == 'e'\
    \ || (int)c == 'i' || (int)c == 'o' || (int)c == 'u') {\n            word_vec.push_back(c);\n\
    \        }\n    }\n    \n    for(auto &c: s) {\n        if((int)c == 'a' || (int)c\
    \ == 'e' || (int)c == 'i' || (int)c == 'o' || (int)c == 'u') {\n            word_vec.push_back(c);\n\
    \        }\n    }\n    \n    for(auto &c: s) {\n        if((int)c == 'a' || (int)c\
    \ == 'e' || (int)c == 'i' || (int)c == 'o' || (int)c == 'u') {\n            word_vec.push_back(c);\n\
    \        }\n    }\n    \n    return word_vec;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpokflu98x.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpokflu98x.cpp:22:37: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   22 |                 word_vec.push_back(c);\n\
    \      |                                     ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpokflu98x.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |               "
  stdout: ''
  timestamp: 1660141134
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    \n    if(s.length() > 0)\
    \ {\n        if(s.find(' ') != std::string::npos) {\n            res.push_back(s);\n\
    \        }\n        \n        int count = 0;\n        for(char c: s) {\n     \
    \       if(c == ' ') count++;\n            if(c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u') {\n                count--;\n            }\n      \
    \      if(count == n) res.push_back(s);\n        }\n    }\n    \n    return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpnoeespys: /tmp/tmpnoeespys.cpp:36: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code goes here\n    std::vector<std::string> list;\n\
    \    std::string sub = \"\";\n    int count = 0;\n    for (int i = 0; i < s.length();\
    \ i++) {\n        if (s[i] == ' ') {\n            count += 1;\n            list.push_back(sub);\n\
    \            sub = \"\";\n        } else {\n            sub += s[i];\n       \
    \     if (count > n) {\n                list.push_back(sub);\n               \
    \ count = 0;\n            }\n        }\n    }\n    if (sub != \"\")\n        list.push_back(sub);\n\
    \    return list;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpkn6uh6tr: /tmp/tmpkn6uh6tr.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if(s.empty())\n        return\
    \ v;\n    for(auto &c : s)\n    {\n        if(std::count(s.begin(), s.end(), c)\
    \ == n)\n            v.emplace_back(std::to_string(c));\n    }\n    return v;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp3pz6e37x: /tmp/tmp3pz6e37x.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) {\n        return {};\n    }\n    std::vector<std::string>\
    \ res;\n    if (n == 1) {\n        res.push_back(s);\n    } else {\n        std::vector<std::string>\
    \ temp;\n        for (int i = 0; i < s.size(); i++) {\n            for (int j\
    \ = 0; j < i; j++) {\n                if (s[j] == s[i]) {\n                  \
    \  res.push_back(s);\n                }\n            }\n        }\n    }\n   \
    \ return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmppwqjdu7u: /tmp/tmppwqjdu7u.cpp:35: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // Write your code here\n  \n  return std::vector<std::string>{};\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpg5jqoucp: /tmp/tmpg5jqoucp.cpp:21: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::set<std::string> set;\n  std::vector<std::string> res;\n\
    \  // implement here\n  return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqcin0nr3: /tmp/tmpqcin0nr3.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    std::vector<std::string> v;\n\
    \    bool flag = true;\n    for(long i = 0; i < s.length(); i++) {\n        if(s[i]\
    \ == '\\0' || flag == true) {\n            v.emplace_back(\"\");\n           \
    \ flag = false;\n            continue;\n        }\n        if((s[i] != ' ') &&\
    \ (s[i] != '\\0')) {\n            flag = true;\n            v.emplace_back(s.substr(i,\
    \ 1));\n        }\n    }\n    if(v.length() >= n) {\n        return v;\n    }\
    \ else {\n        return {};\n    }\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7t7nj4fh.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp7t7nj4fh.cpp:29:10: error:\
    \ \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has no member\
    \ named \u2018length\u2019\n   29 |     if(v.length() >= n) {\n      |       \
    \   ^~~~~~\n/tmp/tmp7t7nj4fh.cpp:34:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   34 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // code here\n  assert(s.size() != 0);\n  std::vector<std::string>\
    \ ans;\n  std::string tmp = s;\n  int nLen = n;\n  for(auto it=tmp.begin(); it!=tmp.end();\
    \ it++){\n    std::string word = \"\";\n    while(n != 0){\n      std::string\
    \ tmp2 = \"\";\n      while(nLen != 0){\n        tmp2 += *it;\n        if(*it\
    \ == ' '){\n          break;\n        }\n        ++it;\n        --nLen;\n    \
    \  }\n      if(tmp2 != \"\"){\n        word += tmp2;\n      }\n      --n;\n  \
    \    if(n == 0){\n        break;\n      }\n      ++it;\n      --nLen;\n    }\n\
    \    if(word != \"\"){\n      ans.push_back(word);\n    }\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp461o6sdb: /tmp/tmp461o6sdb.cpp:50: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(s.empty()) {\n     \
    \   return res;\n    }\n    unordered_set<char> vowels{'a','e','i','o','u'};\n\
    \    // if n is 0 then return empty list\n    if(n == 0) {\n        return res;\n\
    \    }\n    // if n is 1 then return the first word\n    if(n == 1) {\n      \
    \  auto begin = s.begin();\n        while(begin != s.end()) {\n            if(vowels.find(*begin)\
    \ != vowels.end()) {\n                res.push_back((*begin));\n            }\n\
    \            begin++;\n        }\n        return res;\n    }\n    // for each\
    \ word in s remove all vowels and then add it to list res\n    for(auto word :\
    \ s) {\n        word = remove_vowels(word);\n        res.push_back(word);\n  \
    \  }\n    // return list res\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp75oie37s.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp75oie37s.cpp:19:5: error:\
    \ \u2018unordered_set\u2019 was not declared in this scope\n   19 |     unordered_set<char>\
    \ vowels{'a','e','i','o','u'};\n      |     ^~~~~~~~~~~~~\n/tmp/tmp75oie37s.cpp:19:5:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp75oie37s.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:97:11:\
    \ note:   \u2018std::unordered_set\u2019\n   97 |     class unordered_set\n  \
    \    |           ^~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmp75oie37s.cpp:2:\n/usr/include/c++/9/unordered_set:68:13:\
    \ note:   \u2018std::pmr::unordered_set\u2019\n   68 |       using unordered_set\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmp75oie37s.cpp:19:19: error: expected\
    \ primary-expression before \u2018char\u2019\n   19 |     unordered_set<char>\
    \ vowels{'a','e','i','o','u'};\n      |                   ^~~~\n/tmp/tmp75oie37s.cpp:28:16:\
    \ error: \u2018vowels\u2019 was not declared in this scope\n   28 |          \
    \   if(vowels.find(*begin) != vowels.end()) {\n      |                ^~~~~~\n\
    /tmp/tmp75oie37s.cpp:29:39: error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   29 |                 res.push_back((*begin));\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp75oie37s.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string"
  stdout: ''
  timestamp: 1660141135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Your code here\n    std::vector<std::string> res;\n   \
    \ if(s.empty())\n        return res;\n    long count = 0;\n    for(auto c : s)\n\
    \        for(char x : {'a','e','i','o','u','A','E','I','O','U'})\n        {\n\
    \            if(c==x)\n            {\n                count++;\n             \
    \   if(count==n)\n                {\n                    res.push_back(c);\n \
    \                   break;\n                }\n            }\n        }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphlti74zg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmphlti74zg.cpp:28:36: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   28 |                     res.push_back(c);\n \
    \     |                                    ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphlti74zg.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 "
  stdout: ''
  timestamp: 1660141135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // your code goes here\n  if(s.length()==0)\n    return std::vector<std::string>();\n\
    \  std::string temp=s.substr(0,s.length()-n+1);\n  std::vector<std::string> words;\n\
    \  for(auto &i: temp)\n  {\n    if(std::count(i.begin(),i.end(),'a')>0 || std::count(i.begin(),i.end(),'e')>0\
    \ || std::count(i.begin(),i.end(),'i')>0 || std::count(i.begin(),i.end(),'o')>0\
    \ || std::count(i.begin(),i.end(),'u')>0)\n    {\n        words.push_back(i);\n\
    \    }\n  }\n  return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwifs77op.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpwifs77op.cpp:22:21: error:\
    \ request for member \u2018begin\u2019 in \u2018i\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |     if(std::count(i.begin(),i.end(),'a')>0 ||\
    \ std::count(i.begin(),i.end(),'e')>0 || std::count(i.begin(),i.end(),'i')>0 ||\
    \ std::count(i.begin(),i.end(),'o')>0 || std::count(i.begin(),i.end(),'u')>0)\n\
    \      |                     ^~~~~\n/tmp/tmpwifs77op.cpp:22:31: error: request\
    \ for member \u2018end\u2019 in \u2018i\u2019, which is of non-class type \u2018\
    char\u2019\n   22 |     if(std::count(i.begin(),i.end(),'a')>0 || std::count(i.begin(),i.end(),'e')>0\
    \ || std::count(i.begin(),i.end(),'i')>0 || std::count(i.begin(),i.end(),'o')>0\
    \ || std::count(i.begin(),i.end(),'u')>0)\n      |                           \
    \    ^~~\n/tmp/tmpwifs77op.cpp:22:60: error: request for member \u2018begin\u2019\
    \ in \u2018i\u2019, which is of non-class type \u2018char\u2019\n   22 |     if(std::count(i.begin(),i.end(),'a')>0\
    \ || std::count(i.begin(),i.end(),'e')>0 || std::count(i.begin(),i.end(),'i')>0\
    \ || std::count(i.begin(),i.end(),'o')>0 || std::count(i.begin(),i.end(),'u')>0)\n\
    \      |                                                            ^~~~~\n/tmp/tmpwifs77op.cpp:22:70:\
    \ error: request for member \u2018end\u2019 in \u2018i\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |     if(std::count(i.begin(),i.end(),'a')>0 ||\
    \ std::count(i.begin(),i.end(),'e')>0 || std::count(i.begin(),i.end(),'i')>0 ||\
    \ std::count(i.begin(),i.end(),'o')>0 || std::count(i.begin(),i.end(),'u')>0)\n\
    \      |                                                                     \
    \ ^~~\n/tmp/tmpwifs77op.cpp:22:99: error: request for member \u2018begin\u2019\
    \ in \u2018i\u2019, which is of non-class type \u2018char\u2019\n   22 |     if(std::count(i.begin(),i.end(),'a')>0\
    \ || std::count(i.begin(),i.end(),'e')>0 || std::count(i.begin(),i.end(),'i')>0\
    \ || std::count(i.begin(),i.end(),'o')>0 || std::count(i.begin(),i.end(),'u')>0)\n\
    \      |                                                                     \
    \  "
  stdout: ''
  timestamp: 1660141135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::set<std::string> words;\n    for (auto &c : s)\n    \
    \    if (c == ' ' || c == '.' || c == '!' || c == '?' || c == '(' || c == ')'\
    \ || c == ':' || c == '-' || c == '=' || c == ' ' || c == ',' || c == '<' || c\
    \ == '>' || c == '/' || c == '\\\\' || c == '_' || c == '@' || c == '#' || c ==\
    \ '$' || c == '%' || c == '&' || c == '|' || c == '~' || c == '^' || c == '~'\
    \ || c == '_' || c == '*' || c == '+' || c == '=' || c == '&' || c == '%' || c\
    \ == '|' || c == '?' || c == '#' || c == '$' || c == '<' || c == '>' || c == '('\
    \ || c == ')' || c == '!' || c == '.' || c == '?' || c == '-' || c == '/' || c\
    \ == '\\\\' || c == '_' || c == '@' || c == '#' || c == '$' || c == '%' || c ==\
    \ '&' || c == '|' || c == '~' || c == '^' || c == '~' || c == '_' || c == '*'\
    \ || c == '+' || c == '=' || c == '&' || c == '%' || c == '|' || c == '?' || c\
    \ == '#' || c == '$' || c == '<' || c == '>' || c == '(' || c == ')' || c == '!'\
    \ || c == '.' || c == '?' || c == '-' || c == '/' || c == '\\\\' || c == '_' ||\
    \ c == '@' || c == '#' || c == '$' || c == '%' || c == '&' || c == '|' || c ==\
    \ '~' || c == '^' || c == '~' || c == '_' || c == '*' || c == '+' || c == '='\
    \ || c == '&' || c == '%' || c == '|' || c == '?' || c == '#' || c == '$' || c\
    \ == '<' || c == '>' || c == '(' || c == ')' || c == '!' || c == '.' || c == '?'\
    \ || c == '-' || c == '/' || c == '\\\\' || c == '_' || c == '@' || c == '#' ||\
    \ c == '$' || c == '%' || c == '&' || c == '|' || c == '~' || c == '^' || c ==\
    \ '~' || c == '_' || c == '*' || c == '+' || c == '=' || c == '&' || c == '%'\
    \ || c == '|' || c == '?' || c == '#' || c == '$' || c == '<\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq8cgdkw0.cpp:17:1522: warning: missing terminating ' character\n\
    \   17 |         if (c == ' ' || c == '.' || c == '!' || c == '?' || c == '('\
    \ || c == ')' || c == ':' || c == '-' || c == '=' || c == ' ' || c == ',' || c\
    \ == '<' || c == '>' || c == '/' || c == '\\\\' || c == '_' || c == '@' || c ==\
    \ '#' || c == '$' || c == '%' || c == '&' || c == '|' || c == '~' || c == '^'\
    \ || c == '~' || c == '_' || c == '*' || c == '+' || c == '=' || c == '&' || c\
    \ == '%' || c == '|' || c == '?' || c == '#' || c == '$' || c == '<' || c == '>'\
    \ || c == '(' || c == ')' || c == '!' || c == '.' || c == '?' || c == '-' || c\
    \ == '/' || c == '\\\\' || c == '_' || c == '@' || c == '#' || c == '$' || c ==\
    \ '%' || c == '&' || c == '|' || c == '~' || c == '^' || c == '~' || c == '_'\
    \ || c == '*' || c == '+' || c == '=' || c == '&' || c == '%' || c == '|' || c\
    \ == '?' || c == '#' || c == '$' || c == '<' || c == '>' || c == '(' || c == ')'\
    \ || c == '!' || c == '.' || c == '?' || c == '-' || c == '/' || c == '\\\\' ||\
    \ c == '_' || c == '@' || c == '#' || c == '$' || c == '%' || c == '&' || c ==\
    \ '|' || c == '~' || c == '^' || c == '~' || c == '_' || c == '*' || c == '+'\
    \ || c == '=' || c == '&' || c == '%' || c == '|' || c == '?' || c == '#' || c\
    \ == '$' || c == '<' || c == '>' || c == '(' || c == ')' || c == '!' || c == '.'\
    \ || c == '?' || c == '-' || c == '/' || c == '\\\\' || c == '_' || c == '@' ||\
    \ c == '#' || c == '$' || c == '%' || c == '&' || c == '|' || c == '~' || c ==\
    \ '^' || c == '~' || c == '_' || c == '*' || c == '+' || c == '=' || c == '&'\
    \ || c == '%' || c == '|' || c == '?' || c == '#' || c == '$' || c == '<\n   \
    \   |                                                                        \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                              "
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.empty()) {\n        return {};\n    }\n    // TODO\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpzsq1e2xo: /tmp/tmpzsq1e2xo.cpp:22: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> res;\n  long start = 0;\n  long pos\
    \ = 0;\n  while(pos != std::string::npos) {\n    pos = s.find(\" \", start);\n\
    \    if(pos != std::string::npos) {\n      res.push_back(s.substr(start, pos-start));\n\
    \    }\n    pos = s.find(\"a\", pos);\n    if(pos != std::string::npos) {\n  \
    \    res.push_back(s.substr(pos, pos-pos));\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"b\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    c\", pos);\n    if(pos != std::string::npos) {\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"d\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    e\", pos);\n    if(pos != std::string::npos) {\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"f\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    g\", pos);\n    if(pos != std::string::npos) {\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"h\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    i\", pos);\n    if(pos != std::string::npos) {\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"j\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    k\", pos);\n    if(pos != std::string::npos) {\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"l\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    m\", pos);\n    if(pos != std::string::npos) {\n      res.push_back(s.substr(pos,\
    \ pos-pos));\n    }\n    pos = s.find(\"n\", pos);\n    if(pos != std::string::npos)\
    \ {\n      res.push_back(s.substr(pos, pos-pos));\n    }\n    pos = s.find(\"\
    o\", pos);\n    if(pos != std::string::\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6q0kmtpj.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp6q0kmtpj.cpp:82:1: error:\
    \ expected unqualified-id before \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp6q0kmtpj.cpp:81:18:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   81 |     if(pos\
    \ != std::string::\n      |       ~          ^\n      |                  )\n \
    \  82 | }\n      | ~                 \n/tmp/tmp6q0kmtpj.cpp:82:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp6q0kmtpj.cpp:83:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   83 | int main() {\n      |            ^\n/tmp/tmp6q0kmtpj.cpp:92:1: error:\
    \ expected \u2018}\u2019 at end of input\n   92 | }\n      | ^\n/tmp/tmp6q0kmtpj.cpp:14:62:\
    \ note: to match this \u2018{\u2019\n   14 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmp6q0kmtpj.cpp:92:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   92 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141135
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqsik896y: /tmp/tmpqsik896y.cpp:19: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660140929
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> res;\n  if (s.empty())\n    return\
    \ res;\n  \n  \n  // use map to store all unique words with certain number of\
    \ consonants\n  unordered_set<string> unique_words{ s.size()};\n  for (auto &word\
    \ : unique_words)\n    unique_words.insert(word);\n\n  unordered_set<string> unique_words_with_given_n;\n\
    \  // for each unique word, check if it contains n consonants\n  for (auto &word\
    \ : unique_words)\n    if (word.size() >= n)\n      unique_words_with_given_n.insert(word);\n\
    \  \n  \n  // for each unique word with n consonants, keep only those words\n\
    \  for (auto &word : unique_words_with_given_n) {\n    // remove all words that\
    \ have same prefix with new word\n    // for example, for input \"uncle sam\"\
    , we only want to keep \"uncle\"\n    bool same = true;\n    while (same && s.size()\
    \ > word.size())\n      same = s.substr(0, word.size()).compare(0, word.size(),\
    \ word) == 0;\n    if (same)\n      res.push_back(word);\n  }\n  return res;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwru469lk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpwru469lk.cpp:21:3: error:\
    \ \u2018unordered_set\u2019 was not declared in this scope\n   21 |   unordered_set<string>\
    \ unique_words{ s.size()};\n      |   ^~~~~~~~~~~~~\n/tmp/tmpwru469lk.cpp:21:3:\
    \ note: suggested alternatives:\nIn file included from /usr/include/c++/9/unordered_set:47,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpwru469lk.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:97:11:\
    \ note:   \u2018std::unordered_set\u2019\n   97 |     class unordered_set\n  \
    \    |           ^~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpwru469lk.cpp:2:\n/usr/include/c++/9/unordered_set:68:13:\
    \ note:   \u2018std::pmr::unordered_set\u2019\n   68 |       using unordered_set\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmpwru469lk.cpp:21:17: error: \u2018\
    string\u2019 was not declared in this scope\n   21 |   unordered_set<string> unique_words{\
    \ s.size()};\n      |                 ^~~~~~\n/tmp/tmpwru469lk.cpp:21:17: note:\
    \ suggested alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n\
    \                 from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpwru469lk.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \     |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38"
  stdout: ''
  timestamp: 1660141135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> v;\n  if (s.empty()) {\n    return\
    \ v;\n  }\n  v.push_back(s);\n  bool flag = false;\n  for (auto &i : v) {\n  \
    \  flag = false;\n    for (auto &j : i) {\n      if (j != ' ') {\n        flag\
    \ = true;\n        break;\n      }\n    }\n    if (flag == true) {\n      if (i.size()\
    \ < n) {\n        v.erase(std::remove(i.begin(), i.end(), ' '), i.end());\n  \
    \    } else {\n        v.push_back(i);\n      }\n    }\n  }\n  return v;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe9qjm88x.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpe9qjm88x.cpp:31:62: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::erase(__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char>::iterator)\u2019\n   31 |         v.erase(std::remove(i.begin(),\
    \ i.end(), ' '), i.end());\n      |                                          \
    \                    ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpe9qjm88x.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1427:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::erase(std::vector<_Tp,\
    \ _Alloc>::const_iterator) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; typename std::_Vector_base<_Tp, _Alloc>::pointer = std::__cxx11::basic_string<char>*;\
    \ std::vector<_Tp, _Alloc>::const_iterator = __gnu_cxx::__normal_iterator<const\
    \ std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; typename __gnu_cxx::__alloc_traits<typename std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type>::const_pointer\
    \ = const std::__cxx11::basic_string<char>*]\u2019\n 1427 |       erase(const_iterator\
    \ __position)\n      |       ^~~~~\n/usr/include/c++/9/bits/stl_vector.h:1427:7:\
    \ note:   candidate expects 1 argument, 2 provided\n/usr/include/c++/9/bits/stl_vector.h:1454:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::erase(std::vector<_Tp,\
    \ _Alloc>::const_iterator, std::vector<"
  stdout: ''
  timestamp: 1660141135
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> result;\n    if(s.empty()) {\n  \
    \      return result;\n    }\n    unordered_map<char, int> char_count;\n    \n\
    \    for (char c : s) {\n        ++char_count[c];\n    }\n\n    std::vector<char>\
    \ sorted_chars;\n    \n    for (auto it  = char_count.begin(); it != char_count.end();\
    \ it++) {\n        if (it->second == n) {\n            sorted_chars.push_back(it->first);\n\
    \        }\n    }\n\n    result.push_back(std::string(sorted_chars.begin(), sorted_chars.end()));\n\
    \    return result;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2mckblu3.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2mckblu3.cpp:19:5: error:\
    \ \u2018unordered_map\u2019 was not declared in this scope\n   19 |     unordered_map<char,\
    \ int> char_count;\n      |     ^~~~~~~~~~~~~\n/tmp/tmp2mckblu3.cpp:19:5: note:\
    \ suggested alternatives:\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/c++/9/functional:61,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2mckblu3.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:102:11:\
    \ note:   \u2018std::unordered_map\u2019\n  102 |     class unordered_map\n  \
    \    |           ^~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/functional:61,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2mckblu3.cpp:2:\n/usr/include/c++/9/unordered_map:68:13:\
    \ note:   \u2018std::pmr::unordered_map\u2019\n   68 |       using unordered_map\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmp2mckblu3.cpp:19:19: error: expected\
    \ primary-expression before \u2018char\u2019\n   19 |     unordered_map<char,\
    \ int> char_count;\n      |                   ^~~~\n/tmp/tmp2mckblu3.cpp:22:11:\
    \ error: \u2018char_count\u2019 was not declared in this scope\n   22 |      \
    \   ++char_count[c];\n      |           ^~~~~~~~~~\n/tmp/tmp2mckblu3.cpp:27:21:\
    \ error: \u2018char_count\u2019 was not declared in this scope\n   27 |     for\
    \ (auto it  = char_count.begin(); it != char_count.end(); it++) {\n      |   \
    \                  ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    int n = s.length();\n    if(n == 0){\n        return {};\n\
    \    }\n    auto start = s.begin();\n    auto end = s.end();\n    std::stack<std::string>\
    \ s;\n    std::string word;\n    while(start < end && n != 0){\n        std::string\
    \ word_temp = s.top();\n        s.pop();\n        if(word_temp.size()==n){\n \
    \           s.push(word_temp);\n            word+=word_temp;\n            n--;\n\
    \        }\n        else{\n            if(!s.empty()){\n                s.top()+=word_temp;\n\
    \            }\n            start = std::search(start, end,word_temp.begin(),\
    \ word_temp.end(), [](char c1, char c2) {\n                return std::toupper(c1)\
    \ == std::toupper(c2);\n            });\n        }\n    }\n    return s.empty()\
    \ ? {} : std::vector<std::string>{ word };\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb5yb9led.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpb5yb9led.cpp:15:9: error:\
    \ declaration of \u2018int n\u2019 shadows a parameter\n   15 |     int n = s.length();\n\
    \      |         ^\n/tmp/tmpb5yb9led.cpp:21:29: error: declaration of \u2018std::stack<std::__cxx11::basic_string<char>\
    \ > s\u2019 shadows a parameter\n   21 |     std::stack<std::string> s;\n    \
    \  |                             ^\n/tmp/tmpb5yb9led.cpp:40:24: error: expected\
    \ primary-expression before \u2018{\u2019 token\n   40 |     return s.empty()\
    \ ? {} : std::vector<std::string>{ word };\n      |                        ^\n\
    /tmp/tmpb5yb9led.cpp:40:23: error: expected \u2018:\u2019 before \u2018{\u2019\
    \ token\n   40 |     return s.empty() ? {} : std::vector<std::string>{ word };\n\
    \      |                       ^~\n      |                       :\n/tmp/tmpb5yb9led.cpp:40:24:\
    \ error: expected primary-expression before \u2018{\u2019 token\n   40 |     return\
    \ s.empty() ? {} : std::vector<std::string>{ word };\n      |                \
    \        ^\n/tmp/tmpb5yb9led.cpp:40:23: error: expected \u2018;\u2019 before \u2018\
    {\u2019 token\n   40 |     return s.empty() ? {} : std::vector<std::string>{ word\
    \ };\n      |                       ^~\n      |                       ;\n/tmp/tmpb5yb9led.cpp:40:27:\
    \ error: expected primary-expression before \u2018:\u2019 token\n   40 |     return\
    \ s.empty() ? {} : std::vector<std::string>{ word };\n      |                \
    \           ^\n"
  stdout: ''
  timestamp: 1660141136
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n\tstd::vector<std::string> v;\n\tassert(!s.empty()); // the question\
    \ does not require empty words\n\tv.push_back(s); // the first word is already\
    \ in the list\n\tif (s.size() <= n) {\n\t\treturn v;\n\t}\n\tlong count[n + 1]\
    \ = {0};\n\t\n\tfor (long i = 0; i < s.size(); i++) {\n\t\tcount[s[i] - 'a']++;\n\
    \t}\n\tfor (long i = 0; i <= 'z'; i++) {\n\t\tif (count[i] > n) {\n\t\t\tv.push_back(\"\
    \"); // too much words\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (long i = 'a'; i <= 'z';\
    \ i++) {\n\t\tif (count[i] > n) {\n\t\t\tv.push_back(\"\"); // too much words\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\tv.erase(v.end() - n + 1, v.end()); // drop the words\
    \ we don't need\n\t\n\treturn v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n   std::vector<std::string> s;\n   if(s.empty())\n      return\
    \ s;\n   std::unordered_set<char> h;\n   for(auto &x:s)\n      h.insert(x);\n\
    \   std::unordered_set<std::string> v;\n   for(auto &x:s)\n      if(h.find(x)\
    \ != h.end())\n         v.emplace_back(x);\n   v.erase(v.begin());\n   long count\
    \ = 0;\n   for(auto &x:v)\n      if(x.size()==n)\n         count++;\n   std::vector<std::string>\
    \ ret;\n   while(count != n && v.size() > 0)\n   {\n      ret.emplace_back(v.pop_back());\n\
    \      count++;\n   }\n   return ret;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplg70snsh.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmplg70snsh.cpp:15:29: error:\
    \ declaration of \u2018std::vector<std::__cxx11::basic_string<char> > s\u2019\
    \ shadows a parameter\n   15 |    std::vector<std::string> s;\n      |       \
    \                      ^\n/tmp/tmplg70snsh.cpp:20:17: error: no matching function\
    \ for call to \u2018std::unordered_set<char>::insert(std::__cxx11::basic_string<char>&)\u2019\
    \n   20 |       h.insert(x);\n      |                 ^\nIn file included from\
    \ /usr/include/c++/9/unordered_set:47,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmplg70snsh.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:421:7:\
    \ note: candidate: \u2018std::pair<typename std::_Hashtable<_Value, _Value, _Alloc,\
    \ std::__detail::_Identity, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash,\
    \ std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>,\
    \ std::__is_nothrow_invocable<const _Hash&, const _Tp&> > >::value, true, true>\
    \ >::iterator, bool> std::unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(const\
    \ value_type&) [with _Value = char; _Hash = std::hash<char>; _Pred = std::equal_to<char>;\
    \ _Alloc = std::allocator<char>; typename std::_Hashtable<_Value, _Value, _Alloc,\
    \ std::__detail::_Identity, _Pred, _Hash, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash,\
    \ std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<std::__not_<std::__and_<std::__is_fast_hash<_Hash>,\
    \ std::__is_nothrow_invocable<const _Hash&, const _Tp&> > >::value, true, true>\
    \ >::iterator = std::__detail::_Node_iterator<char, true, false>; std::unordered_set<_Value,\
    \ _Hash, _Pred, _Alloc>::value_type = char]\u2019\n  421 |       insert(const\
    \ value_type& __x)\n      |       ^~~~~~\n/usr/include/c++/9/bits/unordered_set.h:421:32:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>\u2019\
    \ to \u2018con"
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> v;\n  v.push_back(s);\n  return v;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp67lpwdpg: /tmp/tmp67lpwdpg.cpp:21: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // write your code here\n  std::vector<std::string> ret;\n \
    \ std::string temp = \"\";\n  std::map<char,std::string>::iterator it;\n  for\
    \ (it = s.begin(); it!=s.end(); ++it) {\n    if(isalnum(*it)){\n      temp = temp+*it;\n\
    \    }\n  }\n  for(unsigned int i=0; i<temp.size(); ++i){\n    if(temp.at(i)=='a'){\n\
    \      temp[i]='A';\n    }\n    if(temp.at(i)=='e'){\n      temp[i]='E';\n   \
    \ }\n    if(temp.at(i)=='i'){\n      temp[i]='I';\n    }\n    if(temp.at(i)=='o'){\n\
    \      temp[i]='O';\n    }\n    if(temp.at(i)=='u'){\n      temp[i]='U';\n   \
    \ }\n    if(temp.at(i)=='y'){\n      temp[i]='Y';\n    }\n    if(temp.at(i)=='u'){\n\
    \      temp[i]='U';\n    }\n    if(temp.at(i)=='o'){\n      temp[i]='O';\n   \
    \ }\n    if(temp.at(i)=='i'){\n      temp[i]='I';\n    }\n    if(temp.at(i)=='a'){\n\
    \      temp[i]='A';\n    }\n    if(temp.at(i)=='a'){\n      temp[i]='a';\n   \
    \ }\n    if(temp.at(i)=='a'){\n      temp[i]='a';\n    }\n    if(temp.at(i)=='a'){\n\
    \      temp[i]='a';\n    }\n    if(temp.at(i)=='a'){\n      temp[i]='a';\n   \
    \ }\n  }\n  if(temp==\"\"){\n    return ret;\n  }\n  if(temp.size()<n){\n    ret.push_back(temp);\n\
    \  }\n  else{\n    while(temp.size()>n){\n      temp=temp.substr(0,temp.size()-n);\n\
    \      ret.push_back(temp);\n    }\n  }\n  return ret;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplz79u6ro.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmplz79u6ro.cpp:19:21: error:\
    \ no match for \u2018operator=\u2019 (operand types are \u2018std::map<char, std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018std::_Rb_tree_iterator<std::pair<const char, std::__cxx11::basic_string<char>\
    \ > >\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018\
    __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019})\n\
    \   19 |   for (it = s.begin(); it!=s.end(); ++it) {\n      |                \
    \     ^\nIn file included from /usr/include/c++/9/map:60,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n                 from\
    \ /tmp/tmplz79u6ro.cpp:2:\n/usr/include/c++/9/bits/stl_tree.h:256:12: note: candidate:\
    \ \u2018constexpr std::_Rb_tree_iterator<std::pair<const char, std::__cxx11::basic_string<char>\
    \ > >& std::_Rb_tree_iterator<std::pair<const char, std::__cxx11::basic_string<char>\
    \ > >::operator=(const std::_Rb_tree_iterator<std::pair<const char, std::__cxx11::basic_string<char>\
    \ > >&)\u2019\n  256 |     struct _Rb_tree_iterator\n      |            ^~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/stl_tree.h:256:12: note:   no known conversion for argument\
    \ 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019} to \u2018const std::_Rb_tree_iterator<std::pair<const\
    \ char, std::__cxx11::basic_string<char> > >&\u2019\n/usr/include/c++/9/bits/stl_tree.h:256:12:\
    \ note: candidate: \u2018constexpr std::_Rb_tree_iterator<std::pair<const char,\
    \ std::__cxx11::basic_string<char> > >& std::_Rb_tree_iterator<std::pair<const\
    \ char, std::__cxx11::basic_string<char> > >::operator=(std::_Rb_tree_iterator<std::pair<const\
    \ char, std::__cxx11::basic_string<char> > >&&)\u2019\n/usr/include/c++/9/bits/stl_tree.h:256:12:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> "
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.empty()) \n        return {};\n\n    std::string words\
    \ = \"\";\n    for(auto &c: s) {\n        if(isalpha(c)) \n            words +=\
    \ c;\n    }\n    \n    std::vector<std::string> res;\n    for(auto &c: words)\
    \ {\n        if(std::count(words.begin(), words.end(), c) == n)\n            res.push_back(words);\n\
    \        \n        words += c;\n    }\n    \n    return res;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmppg7jh9fl: /tmp/tmppg7jh9fl.cpp:36: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> v;\n    if (s.empty()) return v;\n\
    \n    v.push_back(s);\n    std::string ss = s;\n    for (auto i = 0; i < n; i++)\n\
    \    {\n        ss += s[i];\n        for (auto j = i; j < ss.size(); j++)\n  \
    \      {\n            if (ss.at(j) == ' ' || ss.at(j) == ',' || ss.at(j) == '.'\
    \ || ss.at(j) == '?' || ss.at(j) == '!' || ss.at(j) == '@' || ss.at(j) == '#'\
    \ || ss.at(j) == '$' || ss.at(j) == '%' || ss.at(j) == '^' || ss.at(j) == '&'\
    \ || ss.at(j) == '*' || ss.at(j) == '(' || ss.at(j) == ')' || ss.at(j) == '-'\
    \ || ss.at(j) == '_' || ss.at(j) == '[' || ss.at(j) == ']' || ss.at(j) == '|'\
    \ || ss.at(j) == '{' || ss.at(j) == '}' || ss.at(j) == '~')\n            {\n \
    \               v.push_back(ss.substr(i, j + 1));\n                break;\n  \
    \          }\n        }\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmphkgmf_f0: /tmp/tmphkgmf_f0.cpp:36: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if (s.size() < 1) return {};\n    std::vector<std::string>\
    \ res;\n    if (n == 1)\n        for (size_t i = 0; i != s.size(); ++i)\n    \
    \        if (s[i] != 'z' && (s[i] != 'Z' && s[i] != 'Y' && s[i] != 'y'))\n   \
    \             res.push_back(s.substr(i, 1));\n    else\n        for (size_t i\
    \ = 0; i != s.size(); ++i) {\n            long flag = 0;\n            int l =\
    \ 0;\n            while (l < n) {\n                if ((s[i] == 'z' && s[l + 1]\
    \ == 'z') || (s[i] == 'Z' && s[l + 1] == 'Z') || (s[i] == 'y' && s[l + 1] == 'y')\
    \ || (s[i] == 'Y' && s[l + 1] == 'Y'))\n                    flag++;\n        \
    \        else if (!(s[i] == 'z' && s[l + 1] == 'y') && !(s[i] == 'Z' && s[l +\
    \ 1] == 'y') && !(s[i] == 'y' && s[l + 1] == 'z') && !(s[i] == 'Y' && s[l + 1]\
    \ == 'z'))\n                    break;\n                l++;\n            }\n\
    \            if (flag == n)\n                res.push_back(s.substr(i, 1));\n\
    \        }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpdyeewfx0: /tmp/tmpdyeewfx0.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::sort(s.begin(), s.end()); //sort characters by alphabetic\
    \ order\n    std::vector<std::string> v;\n    if(s.size() == 0){\n        return\
    \ v;\n    }\n    for(auto c: s){\n        if(c == 'a'|| c == 'e'|| c == 'i'||\
    \ c == 'o'|| c == 'u'){\n            continue;\n        }\n        std::size_t\
    \ count = 0;\n        std::string currentWord;\n        for(auto w: s){\n    \
    \        if(w == c){\n                count++;\n            }\n        }\n   \
    \     if(count > n){\n            currentWord = std::to_string(c);\n        }\n\
    \        v.push_back(currentWord);\n    }\n    return v;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpyakj2cj8: /tmp/tmpyakj2cj8.cpp:40: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // code here\n  \n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpvoccxydi: /tmp/tmpvoccxydi.cpp:20: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141122
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    int pos = 0;\n    bool\
    \ flag = false;\n    while((pos = s.find(\"  \", pos)) != std::string::npos){\n\
    \        flag = true;\n        res.push_back(s.substr(0, pos+2));\n        s =\
    \ s.substr(pos+2);\n        pos = 0;\n    }\n    if (s.empty())\n        return\
    \ res;\n    // find the first occurrence of n\n    while((pos = s.find(\" \"))\
    \ != std::string::npos){\n        if (s.substr(pos+1, n).find(n) != std::string::npos){\n\
    \            flag = true;\n            res.push_back(s.substr(0, pos+1));\n  \
    \          s = s.substr(pos+1);\n        } else {\n            break;\n      \
    \  }\n        pos = 0;\n    }\n    if (flag)\n        res.push_back(s);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp3y580msn: /tmp/tmp3y580msn.cpp:43: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    if(s.empty()) return res;\n\
    \    \n    \n    for (std::size_t i = 0; i != s.length(); ++i) {\n        if(s[i]\
    \ == 'z' || s[i] == 'Z') {\n            std::size_t end = i + 1;\n           \
    \ while(end != s.length() && (s[end] >= 'A' && s[end] <= 'Z')) {\n           \
    \     ++end;\n            }\n            while(i != end && end != s.length() &&\
    \ (s[end] >= 'a' && s[end] <= 'z')) {\n                res.push_back(s.substr(i,\
    \ end - i));\n                i = end + 1;\n            }\n        }\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmphexvrosp: /tmp/tmphexvrosp.cpp:35: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // write your code here\n    std::vector<std::string> v;\n\
    \    for(unsigned int i=0;i<s.size();i++){\n        if(s[i]=='a' || s[i]=='e'\
    \ || s[i]=='i' || s[i]=='o' || s[i]=='u' || s[i]==' ')\n        {\n          \
    \  v.push_back(s.substr(i,1));\n            v.push_back(s.substr(i+1,1));\n  \
    \          i+=1;\n        }\n    }\n    \n    return v;\n}\nint main() {\n   \
    \ auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpcdetac9k: /tmp/tmpcdetac9k.cpp:30: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    std::vector<std::string> ans;\n\
    \    if(s.empty()) return ans;\n    long sz = s.size();\n    vector<string> v;\n\
    \    for(long i=0; i<sz; ++i){\n        string str = s.substr(i, 1);\n       \
    \ for(long j=0; j<str.length(); ++j){\n            if(str[j] != 'a' && str[j]\
    \ != 'e' && str[j] != 'i' && str[j] != 'o' && str[j] != 'u'){\n              \
    \  v.push_back(str);\n                break;\n            }\n        }\n    }\n\
    \    sort(v.begin(), v.end());\n    for(long i=0; i<v.size(); ++i){\n        if(n\
    \ == v[i].size()){\n            ans.push_back(v[i]);\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1ht60rjp.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp1ht60rjp.cpp:19:5: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   19 |     vector<string>\
    \ v;\n      |     ^~~~~~\n/tmp/tmp1ht60rjp.cpp:19:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1ht60rjp.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1ht60rjp.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp1ht60rjp.cpp:19:12:\
    \ error: \u2018string\u2019 was not declared in this scope\n   19 |     vector<string>\
    \ v;\n      |            ^~~~~~\n/tmp/tmp1ht60rjp.cpp:19:12: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp1ht60rjp.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |"
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // Write your code here\n    std::vector<std::string> res;\n\
    \    std::string temp;\n    int i, j, k;\n    for (i = 0; i < s.length(); i++)\n\
    \    {\n        for (j = 0; j < s.length(); j++)\n        {\n            for (k\
    \ = 0; k < s.length(); k++)\n            {\n                if (s[j] == s[k])\n\
    \                {\n                    temp = temp + \" \" + s.substr(i, j);\n\
    \                    res.push_back(temp);\n                    break;\n      \
    \          }\n            }\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpf48kthv_: /tmp/tmpf48kthv_.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.empty()) return {};\n    \n    std::vector<std::string>\
    \ results;\n    auto it = s.begin(), itEnd = s.end(), itEnd = std::find_if(it,\
    \ itEnd, is_vowel);\n    auto itEnd = s.end(), itEnd = std::find_if(itEnd, itEnd,\
    \ is_consonant);\n    \n    while(it!=itEnd){\n        if(std::count(it, itEnd,\
    \ is_consonant) == n)\n        results.emplace_back(std::string(it, itEnd));\n\
    \        it++;\n        itEnd = std::find_if(it, itEnd, is_vowel);\n        itEnd\
    \ = s.end(), itEnd = std::find_if(itEnd, itEnd, is_consonant);\n    }\n    return\
    \ results;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2oddz7y6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2oddz7y6.cpp:18:43: error:\
    \ conflicting declaration \u2018auto itEnd\u2019\n   18 |     auto it = s.begin(),\
    \ itEnd = s.end(), itEnd = std::find_if(it, itEnd, is_vowel);\n      |       \
    \                                    ^~~~~\n/tmp/tmp2oddz7y6.cpp:18:26: note:\
    \ previous declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > itEnd\u2019\n   18 |     auto it = s.begin(), itEnd = s.end(), itEnd = std::find_if(it,\
    \ itEnd, is_vowel);\n      |                          ^~~~~\n/tmp/tmp2oddz7y6.cpp:18:75:\
    \ error: \u2018is_vowel\u2019 was not declared in this scope\n   18 |     auto\
    \ it = s.begin(), itEnd = s.end(), itEnd = std::find_if(it, itEnd, is_vowel);\n\
    \      |                                                                     \
    \      ^~~~~~~~\n/tmp/tmp2oddz7y6.cpp:18:5: error: inconsistent deduction for\
    \ \u2018auto\u2019: \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 and then \u2018<type error>\u2019\n   18 |     auto it = s.begin(),\
    \ itEnd = s.end(), itEnd = std::find_if(it, itEnd, is_vowel);\n      |     ^~~~\n\
    /tmp/tmp2oddz7y6.cpp:19:10: error: conflicting declaration \u2018auto itEnd\u2019\
    \n   19 |     auto itEnd = s.end(), itEnd = std::find_if(itEnd, itEnd, is_consonant);\n\
    \      |          ^~~~~\n/tmp/tmp2oddz7y6.cpp:18:26: note: previous declaration\
    \ as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > itEnd\u2019\n   18 |     auto it = s.begin(), itEnd = s.end(), itEnd = std::find_if(it,\
    \ itEnd, is_vowel);\n      |                          ^~~~~\n/tmp/tmp2oddz7y6.cpp:19:27:\
    \ error: conflicting declaration \u2018auto itEnd\u2019\n   19 |     auto itEnd\
    \ = s.end(), itEnd = std::find_if(itEnd, itEnd, is_consonant);\n      |      \
    \                     ^~~~~\n/tmp/tmp2oddz7y6.cpp:18:26: note: previous declaration\
    \ as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > itEnd\u2019\n   18 |     auto it = s.begin(), itEnd = s.end(), itEnd = std::find_if(it,\
    \ i"
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  // your code here\n  std::ifstream in(s);\n  std::string word;\n\
    \  std::vector<std::string> v;\n  while (std::getline(in, word, ' ')) {\n    for\
    \ (auto c : word) {\n      if (std::isalpha(c)) {\n        if (c == ' ')\n   \
    \       v.push_back(word);\n        if (c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u') {\n          if (v.size() == 0)\n            v.push_back(word);\n\
    \          if (v.size() >= n)\n            v.push_back(word);\n        }\n   \
    \   }\n    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmprkpdxlwb: /tmp/tmprkpdxlwb.cpp:37: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::map<char, std::pair<int, int>> m;\n  for (char c: s) {\n\
    \    m[c] = { 1, 0 };\n  }\n  \n  std::string word = \"\";\n  \n  for (char c:\
    \ s) {\n    if (m[c].first > n) continue;\n    \n    if (m[c].first == n) word\
    \ += c;\n    \n    m[c].first -= 1;\n    m[c].second = 1;\n  }\n  return { word\
    \ };\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n\
    \    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp1prvpyc5: /tmp/tmp1prvpyc5.cpp:34: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    // code here\n    std::unordered_set<char> vowels;\n    std::string\
    \ word = \"\";\n    if (s.empty()) return {};\n    for (char ch : s) {\n     \
    \   if (vowels.count(ch)) {\n            word += ch;\n        } else {\n     \
    \       word += \" \";\n        }\n    }\n    return {};\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp0ug_lub2: /tmp/tmp0ug_lub2.cpp:30: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    \n    // code here\n    \n    return 0;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr2o3zto6.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpr2o3zto6.cpp:18:12: error:\
    \ could not convert \u20180\u2019 from \u2018int\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   18 |     return 0;\n      |            ^\n      |            |\n\
    \      |            int\n"
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    auto it = s.begin(),\
    \ end = s.end();\n    \n    while (it != end) {\n        if (*it == 'a')\n   \
    \         words.push_back(*it);\n        if (*it == 'e')\n            words.push_back(*it);\n\
    \        if (*it == 'i')\n            words.push_back(*it);\n        if (*it ==\
    \ 'o')\n            words.push_back(*it);\n        if (*it == 'u')\n         \
    \   words.push_back(*it);\n        if (*it == 'A')\n            words.push_back(*it);\n\
    \        if (*it == 'E')\n            words.push_back(*it);\n        if (*it ==\
    \ 'I')\n            words.push_back(*it);\n        if (*it == 'O')\n         \
    \   words.push_back(*it);\n        if (*it == 'U')\n            words.push_back(*it);\n\
    \        it++;\n    }\n    return words;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl4okuf9u.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpl4okuf9u.cpp:20:32: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   20 |             words.push_back(*it);\n     \
    \ |                                ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl4okuf9u.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~"
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> words;\n    std::string vowels =\
    \ \"aeiou\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    if\
    \ (s == \"\") {\n        return words;\n    }\n    for (auto it = s.begin(); it\
    \ != s.end(); ++it) {\n        if (vowels.find(*it) != -1) {\n            if (words.empty())\
    \ {\n                words.push_back(*it);\n            }\n            if (n ==\
    \ words.back().size()) {\n                words.push_back(*it);\n            }\n\
    \        }\n        if (consonants.find(*it) != -1) {\n            if (words.empty())\
    \ {\n                words.push_back(*it);\n            }\n            if (n ==\
    \ words.back().size()) {\n                words.push_back(*it);\n            }\n\
    \        }\n    }\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"\
    Mary\", \"lamb\"})));\n    assert(candidate((\"simple white space\"), (2)) ==\
    \ (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"), (4))\
    \ == (std::vector<std::string>({\"world\"})));\n    assert(candidate((\"Uncle\
    \ sam\"), (3)) == (std::vector<std::string>({\"Uncle\"})));\n    assert(candidate((\"\
    \"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"a b c d e\
    \ f\"), (1)) == (std::vector<std::string>({\"b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnqc46zac.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpnqc46zac.cpp:24:36: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   24 |                 words.push_back(*it);\n \
    \     |                                    ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnqc46zac.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 "
  stdout: ''
  timestamp: 1660141136
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    std::vector<std::string> res;\n    long curr = 0;\n    if\
    \ (s.empty())\n        return res;\n    std::vector<std::string> v;\n    for (int\
    \ i = 0; i <= s.size(); i++) {\n        if (s[i] == ' ')\n            v.push_back(s);\n\
    \        else {\n            v.push_back(s.substr(curr, i - curr));\n        \
    \    v.push_back(s.substr(i, 1));\n            curr = i + 1;\n        }\n    \
    \    if (v.size() >= n) {\n            std::sort(v.begin(), v.end());\n      \
    \      v.erase(std::unique(v.begin(), v.end()), v.end());\n            res.push_back(std::string(v.begin(),\
    \ v.end()));\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"})));\n\
    \    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpiszaplbh.cpp:2:\n/usr/include/c++/9/bits/basic_string.h: In instantiation\
    \ of \u2018static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*,\
    \ _Iterator, _Iterator) [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019:\n/usr/include/c++/9/bits/basic_string.tcc:225:6:\
    \   required from \u2018void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator,\
    \ _InIterator, std::forward_iterator_tag) [with _FwdIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n/usr/include/c++/9/bits/basic_string.h:251:11:\
    \   required from \u2018void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator,\
    \ _InIterator, std::__false_type) [with _InIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n/usr/include/c++/9/bits/basic_string.h:270:4:\
    \   required from \u2018void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator,\
    \ _InIterator) [with _InIterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_strin"
  stdout: ''
  timestamp: 1660141137
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> v;\n  if (s == \"\") {\n    return\
    \ v;\n  }\n  v.push_back(\"\"); // initialize an empty string\n  if (n > 0) {\n\
    \    // split on space and consonants \n    auto words = s.split(\" \");\n   \
    \ \n    for (auto &w : words) {\n      // remove consonants from word\n      auto\
    \ s = w.to_lower();\n      for (auto &i : s) {\n        if (i != 'a' && i != 'e'\
    \ && i != 'i' && i != 'o' && i != 'u') {\n          w.erase(i);\n        }\n \
    \     }\n      if (w == \"\") {\n        continue;\n      }\n      \n      //\
    \ remove duplicate word\n      if (find(v.begin(), v.end(), w) == v.end()) {\n\
    \        v.push_back(w);\n      }\n    }\n  }\n  return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp65lwvirz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp65lwvirz.cpp:22:20: error:\
    \ \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018split\u2019\n   22 |     auto words = s.split(\" \"\
    );\n      |                    ^~~~~\n"
  stdout: ''
  timestamp: 1660141137
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n    if(s.length() == 0) return {};\n    std::vector<std::string>\
    \ res;\n    res.push_back(\"empty\");\n    for(long i = 0; i < s.length(); i++)\n\
    \    {\n        if(s[i] == \" \" && i == s.length()-1)\n        {\n          \
    \  res.push_back(\"space\");\n        }\n        else\n        {\n           \
    \ if(i+1 == s.length())\n            {\n                if((s[i] == s[0]) || (s[i]\
    \ == s[s.length()-1]))\n                {\n                    res.push_back(s[i]);\n\
    \                }\n            }\n            else\n            {\n         \
    \       if((s[i] == s[0]) || (s[i] == s[s.length()-1]) || (s[i] == s[i+1]))\n\
    \                {\n                    res.push_back(s[i]);\n               \
    \ }\n            }\n        }\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpaz4rzzzg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpaz4rzzzg.cpp:20:20: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   20\
    \ |         if(s[i] == \" \" && i == s.length()-1)\n      |                  \
    \  ^~~\n/tmp/tmpaz4rzzzg.cpp:30:39: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type&)\u2019\n   30 |                     res.push_back(s[i]);\n\
    \      |                                       ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpaz4rzzzg.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_b"
  stdout: ''
  timestamp: 1660141136
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a list of all words from string s that contain exactly \n// n consonants, in\
    \ order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty list.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary\
    \ had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little\
    \ lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\"\
    , 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"\
    Uncle sam\", 3) ==> [\"Uncle\"]\nstd::vector<std::string> select_words(std::string\
    \ s, long n) {\n  std::vector<std::string> res;\n  assert(!s.empty());\n  if (n\
    \ <= 0)\n    return res;\n  \n  std::string word = \"\";\n  for(int i = 0; i<s.size();\
    \ i++){\n    if(s.at(i) == ' ' || s.at(i) == '\\0') {\n      if(word != \"\")\
    \ {\n        res.push_back(word);\n        word = \"\";\n      }\n    }\n    else{\n\
    \      word += s.at(i);\n    }\n  }\n\n  return res;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({\"Mary\", \"lamb\"\
    })));\n    assert(candidate((\"simple white space\"), (2)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"Hello world\"), (4)) == (std::vector<std::string>({\"\
    world\"})));\n    assert(candidate((\"Uncle sam\"), (3)) == (std::vector<std::string>({\"\
    Uncle\"})));\n    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n\
    \    assert(candidate((\"a b c d e f\"), (1)) == (std::vector<std::string>({\"\
    b\", \"c\", \"d\", \"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpoctkrodk: /tmp/tmpoctkrodk.cpp:37: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({"little"}))'' failed.

    '
  stdout: ''
  timestamp: 1660141137
