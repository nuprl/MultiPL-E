name: HumanEval_47_median
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements\
  \ in the list l.\n// >>> median([3, 1, 2, 4, 5])\n// 3\n// >>> median([-10, 4, 6,\
  \ 1000, 10, 20])\n// 15.0\nfloat median(std::vector<long> l) {\n"
tests: "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({3,\
  \ 1, 2, 4, 5}))) == (float(3)));\n    assert(candidate((std::vector<long>({-10,\
  \ 4, 6, 1000, 10, 20}))) == (8.0));\n    assert(candidate((std::vector<long>({5})))\
  \ == (float(5)));\n    assert(candidate((std::vector<long>({6, 5}))) == (5.5));\n\
  \    assert(candidate((std::vector<long>({8, 1, 3, 9, 9, 2, 7}))) == (float(7)));\n\
  }\n"
completions: ["    auto it = l.begin();\n    float mid = (*it) + 1;\n    float count\
    \ = 0;\n    for (; it != l.end(); ++it) {\n        count += (*it);\n        if\
    \ (count > mid)\n            mid = count;\n    }\n    return mid;", "    float\
    \ median = l.front();\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i]\
    \ < median) {\n            median = l.front();\n        }\n        else if (l[i]\
    \ > median) {\n            median = l.back();\n        }\n        else {\n   \
    \         break;\n        }\n    }\n    return median;", "    // Sort the vector\n\
    \    sort(l.begin(), l.end());\n    // Return the middle index\n    return l[l.size()/2];",
  "    long size = l.size();\n    if (size == 0)\n        return 0;\n    std::sort(l.begin(),\
    \ l.end());\n    float mid = (size * 1.0) / 2.0;\n    return l[(int)((size * 1.0)\
    \ / 2.0)];", "    long long mid = floor(l.size()/2);\n    if(l.size()%2 == 1)\
    \ mid++;\n    if(mid>l.size()/2) mid = mid-1;\n    return l[mid];", "    assert(l.size()\
    \ > 0);\n    long long ll = 0;\n    float f = 0.0;\n    for (long long i = 0;\
    \ i < l.size(); i++) ll += l[i];\n    f = ll * (ll + 1) / 2;\n    return f;",
  "    float low = 0;\n    float high = l.back();\n    long mid = 0;\n    while(low\
    \ < high) {\n        mid = (low+high)/2;\n        if(l[mid] > mid) {\n       \
    \     low = mid + 1;\n        } else {\n            high = mid;\n        }\n \
    \   }\n    return low;", "\tif (l.size() == 0)\n\t\tthrow std::out_of_range(\"\
    List is empty\");\n\tstd::sort(l.begin(), l.end());\n\tint mid = l.size() / 2;\n\
    \tif (l.size() % 2 == 0)\n\t\treturn (l[mid] + l[mid-1]) / 2;\n\telse\n\t\treturn\
    \ l[mid];", "    long l = std::min(l.size(), l.size() / 2);\n    long mid = l.size()\
    \ / 2;\n    long count = 0;\n    float res = 0.0;\n\n    for (long i = 0; i <\
    \ l; i++) {\n        if (i == mid)\n            mid++;\n        count += 1;\n\
    \        if (count > 2) {\n            res = l[mid];\n            break;\n   \
    \     }\n    }\n    return res;", "    std::nth_element(l.begin(), l.begin() +\
    \ l.size()/2, l.end());\n    return *l.begin();", "    std::sort(l.begin(), l.end());\n\
    \    if (l.size() % 2 == 0)\n        return (l.at(l.size() / 2) - l.at(l.size()\
    \ / 2 - 1)) / 2.0;\n    else\n        return (l.at(l.size() / 2)) / 2.0;", " \
    \   int n = l.size();\n    long int k = n/2;\n    long int m = k == 0 ? 0 : (n-1)\
    \ / k;\n    while (k != 0) {\n        if (l[k] < l[m]) {\n            swap(l[k],\
    \ l[m]);\n        }\n        k--;\n        m++;\n    }\n    return l[m];", " \
    \   auto median = l.begin();\n    std::nth_element(l.begin(), l.begin() + l.size()\
    \ / 2, l.end());\n    auto middle = l.begin() + l.size() / 2;\n    std::nth_element(middle,\
    \ l.end(), median);\n    return *median;", "    long mid = static_cast<long>(l.size()/2);\n\
    \    if(l.size()%2) return l[mid];\n    return ((l[mid] + l[mid-1])/2); ", " \
    \ if (l.size() == 0)\n    throw std::runtime_error(\"median requires at least\
    \ one element\");\n  long mid = l.size() / 2;\n  std::vector<long> midlist;\n\
    \  midlist.reserve(mid);\n  for (int i = 0; i < mid; ++i)\n    midlist.push_back(l.at(i));\n\
    \  std::nth_element(midlist.begin(), midlist.begin() + mid, midlist.end());\n\
    \  midlist.erase(midlist.begin() + mid, midlist.end());\n  return static_cast<float>(midlist.at(0));",
  "    long long medianVal = 0;\n    \n    for(long i = 0; i < l.size(); i++) {\n\
    \        if(l[i] < medianVal) {\n            medianVal = l[i];\n        }\n  \
    \  }\n    \n    return medianVal;", "    long n = l.size();\n    if (n % 2 ==\
    \ 0) {\n        return l[n / 2];\n    }\n    float m = (l[n / 2] + l[n / 2 - 1])\
    \ / 2;\n    return m;", "    float x=0, y=0;\n    std::sort(l.begin(), l.end());\n\
    \    int length = l.size();\n    float sum = 0;\n    for (int i = 0; i < length\
    \ / 2; i++) {\n        sum += l[i];\n        x = sum / 2;\n    }\n    for (int\
    \ i = length / 2; i < length; i++) {\n        sum += l[i];\n        y = sum /\
    \ 2;\n    }\n    return y;", "    long long middle = l.size() / 2;\n    long long\
    \ largest = middle; // largest is just half the length\n    long long smaller\
    \ = middle - 1; // smaller is just one less than the length\n    if (l.size()\
    \ % 2 == 1) {\n        std::swap(smaller, largest);\n    }\n    float med = 0.f;\n\
    \    if (largest >= 1 && smallest <= l.size() - 1) {\n        float largest1 =\
    \ l[largest];\n        float smaller1 = l[smaller];\n        if (largest1 < smaller1)\n\
    \            std::swap(largest1, smaller1);\n        float x = (largest1 + smaller1)\
    \ / 2;\n        float y = (largest + smaller) / 2;\n        float z = (largest1\
    \ + smaller1 + largest) / 4;\n        float w = (largest + smaller1 + largest1\
    \ + smaller) / 8;\n        float med1 = median([y, x, z, w]);\n        float med2\
    \ = median([z, w, x, y, z]);\n        float med3 = median([x, z, y, w, x]);\n\
    \        float med4 = median([y, z, x, z, w]);\n        float med5 = median([z,\
    \ w, z, y, x]);\n        float med6 = median([w, z, x, z, y]);\n        float\
    \ med7 = median([z, y, x, z, w]);\n        float med8 = median([y, x, z, y, w]);\n\
    \        float med9 = median([z, w, y, x, z]);\n        float med10 = median([w,\
    \ z, y, x, w]);\n        float med11 = median([z, y, x, z, y]);\n        float\
    \ med12 = median([y, x, z, y, w]);\n        float med13 = median([z, w, y, z,\
    \ x]);\n        float med14 = median([w, z, y, z, w]);\n        float med15 =\
    \ median([z, y, z, y, w]);\n        float med16 = median([y, z, z, y, x]);\n \
    \       float med17 = median([z, w, z, z, y]);\n        float med18 = median([w,\
    \ z, z, z, w]);\n        float med19 = median([z, y, z, z, x]);\n        float\
    \ med20 = median([y, z, z, y, x]);\n        float med21 = median([z, w, y, z,\
    \ y]);\n        float med22 = median([w, z, y, z, w]);\n        float med23 =\
    \ median([z, y, z, y, w]);\n        float med24 = median([y, z, z, y, x]);\n \
    \       float med25 = median([z, w, y, z, z]);\n        float ", "    int size\
    \ = l.size();\n    float mid = size / 2.0f;\n    // Sort list\n    std::sort(l.begin(),\
    \ l.end());\n    if (size % 2 == 1) {\n        return (l[mid] + l[mid-1]) / 2.f;\n\
    \    } else {\n        return l[mid];\n    }", "  assert(l.size() > 0);\n  long\
    \ n = 0;\n  for (auto& x : l)\n    n += x;\n  return float(n) / l.size();", " \
    \   std::nth_element(l.begin(), l.begin() + l.size()/2, l.end());\n    float median\
    \ = (l.size() % 2 == 0) ? (l[l.size()/2-1] + l[l.size()/2]) / 2.0f : l[l.size()/2];\n\
    \    return median;", "    // Your code goes here\n    long long a = (l[0]+l[l.size()-1])/2;\n\
    \    for(long i=0;i<l.size();i++)\n    {\n        if(l[i]<a)\n        {\n    \
    \        a = l[i];\n        }\n    }\n    return a;", "    if (l.size() == 0)\n\
    \        return 0;\n    long mid = l.size() / 2;\n    std::vector<long> l1 = l.begin()\
    \ + mid, l2 = l.begin() + mid + 1;\n    if (l2 == l.end())\n        return l[0];\n\
    \    if (l1[1] == l2[0])\n        return 0.5 * (l1[0] + l2[0]);\n    if (l1[l1.size()\
    \ - 1] < l2[0])\n        return median(l1);\n    return median(l2);", "    long\
    \ low = 0;\n    long high = l.size()-1;\n    float mid = l[low];\n    if(l.size()\
    \ == 0) return mid;\n    while(low < high) {\n        // mid = ((low+high)/2)\n\
    \        if(l[low] > l[high]) {\n            float mid = ((low+high)/2);\n   \
    \         low = mid+1;\n        }\n        else if(l[low] < l[high]) {\n     \
    \       float mid = ((low+high)/2);\n            high = mid-1;\n        }\n  \
    \      else {\n            low = low+1;\n            high = high-1;\n        }\n\
    \        // mid = l[low]\n        mid = (l[low]+l[high])/2.0;\n    }\n    return\
    \ mid;", "        long n = (l.size());\n        assert(n>0);\n        long half\
    \ = n/2;\n        if(n < 3) return l[0];\n        if(n < 5) return l[n/2] + l[n/2+1];\n\
    \        float mid = (l[n/2+1] + l[n/2-1])/2;\n        return (l[n/2-1] + half)\
    \ * (mid+1);", "    // If list l is empty, return 0.\n    if (l.size() == 0) {\n\
    \        return 0;\n    }\n    // Sort list l with qsort algorithm from C standard\n\
    \    qsort (l.begin(), l.end(), sizeof(long), long_cmp);\n    // If all elements\
    \ are equal, return 0.\n    if (l[0] == l[1]) {\n        return 0;\n    }\n  \
    \  // Return median (middle element) of list l.\n    return (l[l.size()/2]);",
  "    long n = l.size();\n    sort(l.begin(), l.end());\n    float s = 0.0f;\n  \
    \  long mid = n / 2;\n    if (n % 2 == 0) {\n        mid = n - mid;\n        s\
    \ = l[mid];\n    }\n    return s;", "    long long mid = l.size() / 2;\n    float\
    \ median = l[mid];\n    for (long i=mid; i>0; --i) if (l[i] < median) median =\
    \ l[i];\n    return median;", "    sort(l.begin(), l.end());\n    if (l.size()\
    \ % 2 == 1) {\n        l.insert(l.begin(), 0);\n    }\n    if (l.size() == 2)\
    \ {\n        return l[0];\n    }\n    // middle point of data\n    int mid = (l.size()\
    \ - 1) / 2;\n    float midVal = median(l);\n    if (midVal <= l[mid]) {\n    \
    \    return midVal;\n    }\n    return l[mid];", "    long long l1 = l.size();\n\
    \    long long mid = l1 / 2;\n    if (l1 % 2 == 0) {\n        return ((l[mid-1]\
    \ + l[mid]) / 2.0);\n    } else {\n        return ((l[mid-1] + l[mid]) / 2.0);\n\
    \    }", "    long long n = l.size();\n    assert(n >= 2);\n    long long mid\
    \ = n / 2;\n    float med = l[mid];\n    for (long long i = 1; i < mid; i++)\n\
    \        med = std::max(med, l[i]);\n    return med;", "    // write your code\
    \ here\n    ", "  assert(l.size() != 0);\n  std::nth_element(l.begin(), l.begin()\
    \ + l.size() / 2, l.end());\n  return *std::max_element(l.begin(), l.begin() +\
    \ l.size() / 2);", "  // Write your code in Python 2.7.\n  assert(l.size() > 0);\n\
    \  long mid = l.size() / 2;\n  if (l.size() == 1) {\n    return l[0];\n  }\n \
    \ if (l.size() == 2) {\n    if (l[mid] > l[mid + 1]) {\n      return l[mid];\n\
    \    } else {\n      return l[mid + 1];\n    }\n  }\n  float res = l[mid];\n \
    \ for (long i = mid + 1; i < l.size(); ++i) {\n    if (l[i] < res) {\n      res\
    \ = l[i];\n    }\n  }\n  return res;", "  long n = l.size();\n  if (n % 2)\n \
    \   return std::nth_element(l.begin(), l.begin() + n / 2, l.end()) -\n       \
    \    l.begin() +\n           n / 2;\n  else\n    return std::nth_element(l.begin(),\
    \ l.begin() + n / 2, l.end());", "    l.sort(std::greater<long>());\n    float\
    \ mid = l[l.size()/2]; //Sort list in ascending order\n    return mid;", "   \
    \ long size = l.size();\n    // Sort list.\n    std::sort(l.begin(), l.end());\n\
    \n    // If size is even, return middle element.\n    if ((size % 2) == 0)\n \
    \       return l[(size / 2)];\n\n    // If size is odd, return average of middle\
    \ 2 elements.\n    float mid = l[(size / 2)];\n    return (mid + l[(size / 2)\
    \ - 1]) / 2.0;", "    std::nth_element(l.begin(), l.begin() + l.size()/2, l.end());\n\
    \    long median = (l[l.size()/2-1] + l[l.size()/2])/2;\n    return median;",
  "\tsort(l.begin(),l.end());\n\tlong n1=l.size()/2;\n\tif(l.size()%2==0) return l[n1];\n\
    \treturn ((l[n1] + l[n1-1])/2);", "    long a=0, b=l.size()-1;\n    float m =\
    \ (float(a+b)/2.0);\n    long m1 = l, m2 = l;\n    while (m1 > 0 || m2 > 0) //\
    \ while(m1>0 || m2>0)\n    {\n        if(m1 < 0) // m1<0\n        {\n        \
    \    std::swap(m1, m2);\n            std::swap(a, b);\n        }\n        if(m2\
    \ < 0)\n        {\n            std::swap(m1, m2);\n            std::swap(a, b);\n\
    \        }\n        if(m1 < m2) {\n            long c = m1;\n            m1 =\
    \ m2;\n            m2 = c;\n        }\n        if(m1 >  m2)\n        {\n     \
    \       long c = m1;\n            m1 = m2;\n            m2 = c;\n        }\n \
    \   }\n    return m;", "    // Find median by sorting the list\n    std::sort(l.begin(),\
    \ l.end());\n    long mid = l.size() / 2;\n    long l = l[mid];\n    return l;",
  "    int len = l.size();\n    if (len % 2 == 0)\n        return median(l, 0, len\
    \ / 2);\n    return median(l, len / 2, len - 1);", "    l.sort(std::greater<long>());\n\
    \    long mid = l[1] / 2;\n    std::vector<long>::iterator it = std::partition(l.begin(),\
    \ l.end(),\n            std::bind2nd(std::greater<long>(), mid));\n    return\
    \ std::distance(l.begin(), it);", "    long long int n;\n    int mid;\n    float\
    \ median;\n\n    // Sort the array.\n    std::sort(l.begin(), l.end());\n\n  \
    \  // Get the length of the sorted array.\n    n = l.size();\n\n    // Get the\
    \ mid index.\n    mid = n / 2;\n\n    // Calculate median.\n    median = (float)\
    \ l.at(mid);\n\n    return median;", "// sort input in ascending order\nstd::sort(l.begin(),\
    \ l.end());\n// Find number of elements.\nint n = l.size();\n// Compute median,\
    \ middle element\nfloat m = (n + 1.0) / 2.0;\n// If number of elements is odd\
    \ then return middle element as median.\nreturn (n % 2) ? m : (n + 1) / 2.0;",
  "  // O(NlogN) time and O(1) space\n  // Write your code in Java.\n  std::sort(l.begin(),\
    \ l.end());\n  l.erase(l.begin()+l.size()/2, l.end());\n  return l[(l.size()/2)];",
  "    if (l.size() == 0) return 0;\n    l.sort();\n    return l[l.size() / 2];",
  "    long long ll=l[0];\n    int size=l.size();\n    assert(size>1);\n    for(int\
    \ i=1;i<size;i++)\n    {\n        ll=std::min(ll,l[i]);\n    }\n    return ll/size;",
  "  if (l.size() == 0) \n    return 0;\n  std::nth_element(l.begin(), l.begin()+1,\
    \ l.end()); // select median element\n  return l[0]; // return median", "  std::nth_element(l.begin(),\
    \ l.begin() + l.size() / 2, l.end());\n  if (l.size() % 2 == 1) {\n    return\
    \ l[l.size() / 2];\n  }\n  return (l.end() - l.begin()) / 2.0;", "  std::sort(l.begin(),\
    \ l.end());\n  return l[l.size() / 2];", "\tassert(l.size() >= 2);\n\tlong low\
    \ = l[0], high = l[0];\n\tfor(size_t i = 1; i < l.size(); i++) {\n\t\tlow = std::min(low,\
    \ l[i]);\n\t\thigh = std::max(high, l[i]);\n\t}\n\treturn (high + low) / 2;",
  "\t// Sort list\n\tstd::sort(l.begin(), l.end());\n\t// Middle value\n\tfloat m\
    \ = 0.0;\n\t// If list is not even length\n\tif (l.size() % 2 == 1) {\n\t\t//\
    \ Select middle value\n\t\tm = (l.begin()[l.size() / 2] + l.begin()[l.size() /\
    \ 2 - 1]) / 2.0;\n\t\t// Check if list has even length\n\t\tif (l.size() % 2 ==\
    \ 0) {\n\t\t\t// Return the median value\n\t\t\treturn m;\n\t\t}\n\t}\n\telse\
    \ {\n\t\tm = (l.begin()[l.size() / 2] + l.begin()[l.size() / 2 - 1]) / 2.0;\n\t\
    }\n\treturn m;", "    std::sort(l.begin(), l.end());\n    l.erase(std::unique(l.begin(),\
    \ l.end()), l.end());\n    return l.size() >= 2 ? (l[l.size() / 2] + l[l.size()\
    \ / 2 - 1]) / 2.0 : l[0];", "    long int size = l.size();\n    long int mid =\
    \ size / 2;\n    if (size % 2)\n        return l[mid];\n    else\n        return\
    \ (l[mid] + l[mid+1])/2.0;", "    std::sort(l.begin(), l.end());\n    long mid\
    \ = l.size() / 2;\n    if (l.size() % 2 == 0) {\n        return l[mid];\n    }\
    \ else {\n        return (l[mid] + l[mid + 1]) / 2.0;\n    }", "    assert(l.size()\
    \ != 0);\n    long mid = l.size() / 2;\n    if (l.size() % 2 == 0) return (l[mid]\
    \ + l[mid]) / 2.0;\n    else return l[mid];", "    if (l.size() % 2 == 1) {\n\
    \        return l[l.size()/2];\n    } else {\n        float a = l[l.size()/2];\n\
    \        float b = l[l.size()/2-1];\n        return ((a > b) ? a : b);\n    }",
  "  // Check for empty list.\n  if (l.empty()) {\n    return std::numeric_limits<float>::max();\n\
    \  }\n\n  // Define median as midpoint between first and last element\n  // of\
    \ the list. Also define median of first two elements\n  // as average of those\
    \ two.\n  const int middle = l.size() / 2;\n  const long first = l[0];\n  const\
    \ long last = l[middle - 1];\n  return std::min(first, last) / std::max(first,\
    \ last);", "    // Sort the list into ascending order\n    std::sort(l.begin(),\
    \ l.end());\n    long mid = (l.begin() + l.end())/2;\n    float median = (*l.begin()+*mid)/2;\n\
    \    if (l.size()%2) {\n        median = (*l.begin()+*l.end())/2;\n    }\n   \
    \ return median;", "\t// Find length of list\n\tsize_t n = l.size();\n\tif (n\
    \ <= 1)\n\t\treturn l[0];\n\t// Find middle of list\n\tsize_t m = n >> 1;\n\t\
    if (n % 2 == 0)\n\t\tm++;\n\t// Find median of middle elements\n\tfloat m1 = l[m];\n\
    \tfloat m2 = (n - m) * l[m - 1];\n\treturn 0.5 * (m1 + m2);", "    assert(l.size()\
    \ != 0);\n    long mid = l.size()/2;\n    int pos = 0;\n    float midval = l[mid];\n\
    \n    // If the mid value is greater than\n    // the middle value, then return\
    \ the \n    // middle value.\n    if (midval > l[pos])\n        return midval;\n\
    \    // If midval is smaller, then return the \n    // smaller value.\n    else\
    \ if ((midval < l[pos]) && (pos < l.size()-1))\n        return l[pos];\n    //\
    \ If midval is equal or larger than the \n    // \n    if (pos == l.size()-1)\n\
    \        return l[pos];\n    // If midval is smaller than the \n    // middle\
    \ value, then return the \n    // middle value.\n    else\n        return midval;",
  "    long mid = l.size() / 2;\n    if (l.size() % 2 == 1)\n        return l[mid];\n\
    \    else\n        return 0.5 * (l[mid] + l[mid+1]);", "    // Sort vector with\
    \ quick sort algorithm\n    // Sort the vector with quick sort algorithm\n   \
    \ // Sort vector with quick sort algorithm\n    long n = l.size();\n    int pivotIndex\
    \ = (n-1)/2;\n    long pivotValue = l[pivotIndex];\n    for (long i=0; i<n; i++){\n\
    \        if (l[i] < pivotValue) {\n            std::swap(l[i], l[pivotIndex]);\n\
    \            std::swap(l[pivotIndex], l[i]);\n        }\n    }\n    return l[pivotIndex];",
  "    assert(l.size() >= 2);\n    float xlower = l[0];\n    float xupper = l[0];\n\
    \    float ylower = l[0];\n    float yupper = l[0];\n    for (auto it = l.begin()\
    \ + 1; it != l.end(); it++) {\n        xlower = std::max(xlower, *it);\n     \
    \   xupper = std::min(xupper, *it);\n        ylower = std::max(ylower, *it);\n\
    \        yupper = std::min(yupper, *it);\n    }\n    return (xlower + xupper)\
    \ / 2.0f;", "  int n = l.size();\n  float x[n+1];\n  for (int i = 0; i <= n; i++)\
    \ {\n    x[i] = l[i];\n  }\n  sort(x, x + n); // Sort the array from small to\
    \ large\n  int m = (n + 1) >> 1;\n  // Find the pivot element.\n  // This loop\
    \ assumes there exist at least one element in x.\n  int i = 1;\n  for (; i < n;\
    \ i++) {\n    if (x[i] < x[m]) {\n      m = i;\n    }\n  }\n  // Swap the pivot\
    \ element with the first element of x.\n  if (m != 0) {\n    float tmp;\n    tmp\
    \ = x[m];\n    x[m] = x[n - 1];\n    x[n - 1] = tmp;\n  }\n  // Return middle\
    \ element.\n  return x[m];", "  if (l.size() % 2 == 0) {\n    return (static_cast<float>(l.at((l.size()\
    \ - 1) / 2)) +\n            static_cast<float>(l.at((l.size() - 1) / 2 + 1)))\
    \ / 2;\n  }\n\n  return static_cast<float>(l.at((l.size() - 1) / 2));", "    sort(l.begin(),\
    \ l.end());\n    if (l.size() == 0)\n        return 0;\n    else if (l.size()\
    \ == 1)\n        return l[0];\n    else {\n        float mid = (l[0] + l[l.size()\
    \ / 2]) / 2;\n        return mid;\n    }", "    // Initialize to the first element.\n\
    \    long l = l[0];\n    float res = 0.0;\n\n    // Search for median of first\
    \ and second halves.\n    for (size_t i = 0; i < l.size() - 1; ++i) {\n      \
    \  if (l[i] > l[i + 1]) {\n            res = l[i];\n            break;\n     \
    \   }\n    }\n\n    // If there are two elements, return average.\n    if (l.size()\
    \ % 2 == 0) {\n        if (res < l[l.size() / 2]) {\n            res = l[l.size()\
    \ / 2];\n        }\n    }\n\n    // Return median.\n    return res;", "  long\
    \ long size = l.size();\n  if (size % 2 == 0) {\n    return (float(l[size / 2\
    \ - 1] + l[size / 2]) / 2);\n  } else {\n    return (float(l[size / 2 - 1] + l[size\
    \ / 2 - 1]) / 2.0);\n  }", "    float n = float(l.size());\n    assert(n > 0);\
    \ // handle empty list\n    std::vector<long>::iterator middle = std::partition(l.begin(),\
    \ l.end(), [](long x) { return x >= n/2; });\n    return (n.*middle)/(n/2); //\
    \ floating point division is expensive, especially for large n", "    assert(l.size()\
    \ > 1);\n    sort(l.begin(), l.end());\n    return l[(l.size() - 1) /2]; ", "\t\
    long n = l.size();\n\tif (n == 0)\n\t\treturn -1;\n\tsort(l.begin(), l.end());\n\
    \tif (n % 2 == 0)\n\t\treturn l[n/2];\n\telse {\n\t\tint m = (n+1)/2;\n\t\treturn\
    \ l[m];\n\t}", "    // Sort the vector l first\n    std::sort(l.begin(), l.end());\n\
    \    long half = (l.size()) / 2;\n    if (l.size() % 2 == 1) {\n        return\
    \ l[half];\n    } else {\n        return 0.5 * (l[half - 1] + l[half]);\n    }",
  "  // Sort list to find median quickly.\n  std::sort(l.begin(), l.end());\n\n  //\
    \ Store the median.\n  float m = (l.size() % 2) ? l/2.0 + 0.5 : l[(l.size()-1)/2];\n\
    \n  // Return the median.\n  return m;", "    long n = l.size();\n    if (n %\
    \ 2 == 0)\n        return (l[n/2-1] + l[n/2]) / 2;\n    return l[(n-1)/2];", " \
    \   auto it = std::nth_element(l.begin(), l.begin() + l.size()/2, l.end());\n\
    \    return *it;", "    long a = l[0];\n    long b = l[l.size()/2];\n    if (l.size()\
    \ % 2)\n        return (b + a) / 2.0;\n    else\n        return (b - a) / 2.0;",
  "  assert(l.size() > 1);\n  std::nth_element(l.begin(), l.begin() + l.size() / 2,\
    \ l.end());\n  return l[l.size() / 2];", "    std::nth_element(l.begin(), l.begin()+l.size()/2,\
    \ l.end());\n    return (float(l.size()/2) - l.at(l.size()/2))/l.size()*2.0;",
  "    std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n    return\
    \ (*(l.begin() + l.size() / 2));", "    float ans = l[0];\n    long mid = 0;\n\
    \    long cnt = 0;\n    for (long i = 0; i < l.size(); i++) {\n        if (l[i]\
    \ > ans)\n            ans = l[i];\n        if (cnt == l.size() / 2) {\n      \
    \      mid = i;\n            cnt++;\n        }\n    }\n    mid++;\n    return\
    \ ans + (float)(mid - ans) / 2.0;", "    // Your code here\n    float sum = 0;\n\
    \    int count = 0;\n    for (std::vector<long>::iterator it = l.begin(); it !=\
    \ l.end(); ++it) {\n        sum += *it;\n        count++;\n    }\n    float median\
    \ = sum / count;\n    return median;", "    long long mid = (l.size() / 2);\n\
    \    float a = l[mid];\n    float b = l[mid+1];\n    return (a + b) / 2;", '  //
    TODO', "    long size = l.size();\n    if (size % 2 == 0) {\n        long mid\
    \ = size / 2;\n        long lo = l[mid];\n        long hi = l[mid+1];\n      \
    \  return (lo + hi) / 2.0;\n    }\n    else {\n        long mid = size / 2;\n\
    \        long lo = l[mid];\n        long hi = l[mid-1];\n        return (lo +\
    \ hi) / 2.0;\n    }", "    if (l.size() % 2 == 0)\n        return l[(l.size()\
    \ / 2)]; //odd length\n    return ((l[(l.size() / 2)-1]+l[(l.size() / 2)+1])/2);",
  "  int length = l.size();\n  if (length == 0) {\n    throw std::invalid_argument(\"\
    Empty list!\");\n  }\n  long minimum = *std::min_element(l.begin(), l.end());\n\
    \  long maximum = *std::max_element(l.begin(), l.end());\n  float average = (minimum\
    \ + maximum) / 2.0f;\n  if (length > 1) {\n    int mid = (length / 2);\n    float\
    \ median = ((float)(l[mid] + l[length - 1]) / 2.0f);\n    return median;\n  }\
    \ else {\n    return average;\n  }", "    float mid, lo, hi, sum;\n    int n =\
    \ l.size();\n    lo = l[0];\n    hi = l[n - 1];\n    for (int i = 1; i < n; ++i)\
    \ {\n        mid = lo + (hi - lo) / 2.0;\n        sum = mid;\n        for (int\
    \ j = 0; j < i; ++j)\n            sum += l[j];\n        if (sum < 0)\n       \
    \     hi = mid;\n        else if (sum > 0)\n            lo = mid;\n        else\n\
    \            return mid;\n    }\n    return lo;", "  auto it = std::cbegin(l);\n\
    \  auto beg = std::lower_bound(it, std::cend(l), l.begin());\n  auto end = std::cend(l)-1;\n\
    \  if (beg <= end) mid = beg;\n  else mid = std::upper_bound(it, end, l.end());\n\
    \  return *mid;", "\tauto it = l.begin();\n\tif (it == l.end()) {\n\t\treturn\
    \ 0.0;\n\t}\n\tauto mid = it + l.size() / 2;\n\tassert(l.size() > 1);\n\twhile\
    \ (it < mid) {\n\t\t++it;\n\t}\n\tif (it == l.end()) {\n\t\treturn l[mid];\n\t\
    }\n\twhile (it > mid) {\n\t\t--it;\n\t}\n\treturn std::min(l[mid], l[it]);", " \
    \   std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n    return\
    \ *std::max_element(l.begin(), l.begin() + l.size() / 2);", "  long x = 0;\n \
    \ long y = 0;\n  long count = 0;\n  for (auto it = l.begin(); it != l.end(); ++it)\
    \ {\n    if ((*it < 0) || (*it > 25)) {\n      x += (*it);\n    } else {\n   \
    \   y += (*it);\n      ++count;\n    }\n  }\n  // If there are equally many numbers,\
    \ use average\n  float sum = ((float) count) / (float)l.size();\n  if (l.size()\
    \ % 2 == 0) {\n    // If the list size is an odd number, use average of first\
    \ and last\n    return (l.size() > 1) ? sum : ((sum * l.front() + l.back()) /\
    \ 2);\n  } else {\n    // If the list size is an even number, use average of middle\
    \ two number\n    return (l.size() > 1) ? (sum * l.begin() + l.begin() + l.back())\
    \ / 2 : sum;\n  }", "  int n = l.size();\n  if (n <= 1) return l[0];\n  long mid\
    \ = n / 2;\n  int m = (int) mid;\n  std::vector<long>::iterator itr = l.begin();\n\
    \  while (itr != l.end()){\n    if (itr < l.begin() || (itr + mid) < itr) {\n\
    \      itr++;\n    } else {\n      itr += mid;\n    }\n  }\n  return l[m];", " \
    \   std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end()); // Sort the\
    \ elements in ascending order.\n    float med = l.at(l.size() / 2);\n    return\
    \ med;", "    long low = 0;\n    long high = l.size()-1;\n    float mid = l[low]\
    \ + (l[high] - l[low]) / 2.0f;\n    float mid2 = (l[high] - l[low]) / 2.0f;\n\
    \    bool found;\n    while ((found = std::find(l.begin(), l.end(), mid)) !=\n\
    \            l.end()) {\n        if (mid != l[found]) {\n            mid = (mid\
    \ + mid2) / 2;\n        }\n        high--;\n        mid2 = mid;\n    }\n    return\
    \ mid;", "    long temp=l.size();\n    assert(temp%2==0);\n    temp=temp/2;\n\
    \    float avg=static_cast<float>(l);\n    avg=(avg+avg)/2;\n    return avg;",
  "  if (l.size() % 2 == 1) {\n    return ((l[l.size()/2-1] + l[l.size()/2])/2);\n\
    \  } else {\n    return std::median(l.begin(), l.end());\n  }", "    size_t mid\
    \ = l.size() / 2;\n    if (l.size() % 2 == 0)\n        return l[mid];\n    else\n\
    \        return (l[mid] + l[mid-1]) / 2.0;", "\t// return l[l.size()/2];\n\t//\
    \ return l[l[0]+l[l].size()/2];\n\t// return std::inner_product(l.begin(), l.end(),\
    \ l.begin(), 0);\n\t// return std::accumulate(l.begin(), l.end(), 0) / l.size();\n\
    \t// return std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n\t\
    // return l[std::distance(l) / 2];\n\treturn (std::accumulate(l.begin(), l.end(),\
    \ 0) / l.size()) / 2;", "  long long mid = (l.size() + 1) / 2;\n  float left_med\
    \ = float((l.begin() + mid) / 2);\n  float right_med = float((l.rbegin() + mid)\
    \ / 2);\n  return left_med + right_med;", "    std::nth_element(l.begin(), l.begin()\
    \ + l.size() / 2, l.end());\n    return l[l.size() / 2];", "  if (l.size() % 2\
    \ == 1) {\n    int median = (l.begin() + l.size() / 2) - 1;\n    return l[median];\n\
    \  }\n  else {\n    float x = (l.begin() + l.size() / 2);\n    return (x[1] +\
    \ x[l.size() / 2]) / 2;\n  }", "    float midPoint = std::accumulate(l.begin(),\
    \ l.end(), 0.0) / l.size();\n    std::nth_element(l.begin(), l.begin() + l.size()\
    \ / 2, l.end());\n    std::vector<int> nums(l.begin(), l.begin() + l.size() /\
    \ 2);\n    float mean = std::accumulate(nums.begin(), nums.end(), 0.0) / nums.size();\n\
    \    return (midPoint + mean);", "    long size = (int) l.size();\n    assert(size\
    \ % 2 == 0);\n    if (size == 0) return 0;\n    int mid = size / 2;\n    return\
    \ (l[mid] + l[size/2]) / 2.0;", "    int size = l.size();\n    if (size == 0)\n\
    \        throw std::runtime_error(\"Empty list.\");\n    std::vector<long>::iterator\
    \ it;\n    int mid = size / 2;\n    if (size == 1)\n        return l[0];\n   \
    \ if (l[mid] < l[0])\n        it = (l.begin() + 0);\n    else\n        it = (l.begin()\
    \ + mid);\n    std::vector<long> v(it, l.end());\n    std::nth_element(v.begin(),\
    \ v.begin() + mid, v.end());\n    return v[mid];", "  // Write your code here\n\
    \  long size = l.size();\n  if(size % 2 == 0)\n    return l[size/2] + (l[size/2-1]\
    \ + l[size/2+1])/2;\n  else\n    return l[size/2-1];", "\tassert(l.size() != 0);\n\
    \tlong n = 0;\n\tfloat maxVal = std::numeric_limits<float>::min();\n\tfor (auto\
    \ &el : l)\n\t\tmaxVal = (std::max)(maxVal, el);\n\tfor (auto &el : l)\n\t\tif\
    \ (el == maxVal)\n\t\t\tn++;\n\tfloat medianVal = (float)(n + 1) / 2.0;\n\treturn\
    \ medianVal;", "  long n = l.size();\n  assert(n != 0);\n  long mid = n / 2;\n\
    \  long ret = 0;\n  \n  while (true) {\n    if (m[mid] < 0) return ret;\n    long\
    \ left = std::min(mid + 1, n);\n    long right = std::max(mid - 1, 0);\n    \n\
    \    if (left >= right) break;\n    \n    long mid2 = mid + right + 1;\n    ret\
    \ = std::max(ret, mid - (mid & 1)*((left - mid) + mid * right));\n    mid += right\
    \ + 1;\n    n = left;\n  }\n  return ret;", "    std::sort(l.begin(), l.end());\n\
    \    int mid = l.size() / 2;\n    if (l.size() % 2 == 1)\n        return l[mid];\n\
    \    else\n        return ((l[mid] + l[mid]) / 2);", "    long n = l.size();\n\
    \    if (n & 1)\n        return l[n/2];\n    else\n        return std::median(l.begin(),\
    \ l.begin() + n/2-1);", "    long mid = l.size() / 2;\n    if (l.size() % 2 ==\
    \ 0)\n        return median(l, mid);\n    float a = (l[mid] + l[mid-1]) / 2;\n\
    \    return median(l, mid - 1); ", "    assert(!l.empty());\n    float m = std::accumulate(l.begin(),\
    \ l.end(), 0.0) / static_cast<float>(l.size());\n    return m;", "    // Write\
    \ your code here.\n    long long sum = 0;\n    int len = l.size();\n    if(len%2!=0){\n\
    \        return -1;\n    }\n    int mid = (len+1)/2;\n    for(int i=0;i<mid;i++){\n\
    \        sum += l[i];\n    }\n    int index = mid - 1;\n    while(index>=0 &&\
    \ sum>0){\n        sum += l[index];\n        index--;\n    }\n    return sum/((double)mid);",
  "  std::nth_element(l.begin(), l.begin()+l.size() / 2, l.end());\n  return *(l.begin()\
    \ + l.size() / 2);", "    std::nth_element(l.begin(), l.begin() + l.size() / 2,\
    \ l.end()); // nth element median is of index l/2\n    return static_cast<float>(l[l.size()\
    \ / 2]);", "    auto s = l.size();\n    if(s == 0) {\n        return 0;\n    }\n\
    \    long mid = s >> 1;\n    long l = l[mid];\n    if(s == 1 || l < l[mid]) {\n\
    \        return l; // l is median\n    }\n    if(s == 2) {\n        return std::max(l[mid],\
    \ l[mid]); // l is median\n    }\n    while(true) {\n        mid = (mid + 1) >>\
    \ 1;\n        if((mid & 1) == 0) {\n            if(l[mid] > l[mid + 1]) {\n  \
    \              return l[mid];\n            }\n            return l[mid + 1];\n\
    \        }\n        if(l[mid] > l[mid - 1]) {\n            return l[mid];\n  \
    \      }\n        return l[mid - 1];\n    }", "    // code here\n    int n = l.size();\n\
    \    if(n < 2)\n        return 0;\n    long mid = n/2;\n    std::nth_element(l.begin(),\
    \ l.begin() + mid, l.end());\n    return std::median(l.begin(), l.begin() + mid);",
  "    float med = l[0];\n    for (int i = 0; i < l.size(); i++) {\n        if (l[i]\
    \ > med) {\n            med = l[i];\n        }\n    }\n    return med;", "  std::sort(l.begin(),\
    \ l.end());\n  return std::distance(l.begin(), std::unique(l.begin(), l.end()));",
  "    long mid = l.size() / 2;\n    if (l.size() % 2 == 0) {\n        if (l[mid]\
    \ > l[mid+1]) std::swap(l[mid], l[mid+1]);\n        float x = (l[mid] + l[mid+1])\
    \ / 2;\n        return x;\n    }\n    if (l[mid] > l[mid - 1]) std::swap(l[mid],\
    \ l[mid - 1]);\n    float x = (l[mid] + l[mid - 1]) / 2;\n    return x;", "  \
    \  // Sort the list l.\n    std::sort(l.begin(), l.end());\n    // Return median\
    \ of list l.\n    return (l.size() / 2) + l[l.size() / 2];", "    assert(l.size()\
    \ > 0);\n    long mid = l.size() / 2;\n    float a = l[mid];\n    long b = mid;\n\
    \    while (b < l.size() - 1 && l[b + 1] < a) {\n        b++;\n    }\n    if (b\
    \ == l.size() - 1) {\n        return a;\n    }\n    else {\n        return 0.5\
    \ * (a + l[b]);\n    }", "    // Check size of vector.\n    if (l.size() == 0)\
    \ {\n        return 0;\n    }\n\n    long mid = l.size() / 2;\n    float left\
    \ = l[mid];\n\n    for (long i = mid + 1; i < l.size(); i++) {\n        float\
    \ right = l[i];\n        if (right < left) {\n            left = right;\n    \
    \    }\n    }\n\n    return left;", "    float med;\n    long count = 0;\n\n \
    \   for (int i = 0; i < l.size(); i++)\n        count += l[i];\n\n    med = (float)\
    \ l.size() / (float) count;\n\n    if (med == (float) 0.0)\n        med = 0.5;\n\
    \n    return med;", "    float min = std::numeric_limits<float>::min();\n    float\
    \ max = std::numeric_limits<float>::max();\n    float median = std::numeric_limits<float>::min();\n\
    \    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) {\n \
    \           min = l[i];\n        }\n        if (l[i] < l[i - 1]) {\n         \
    \   max = l[i];\n        }\n    }\n    float mid = min + (max - min) / 2;\n  \
    \  if (l.size() % 2 == 0) {\n        median = mid;\n    } else {\n        if (mid\
    \ - l[l.size() / 2] < l[l.size() / 2 - 1] - mid) {\n            median = mid;\n\
    \        } else {\n            median = l[l.size() / 2];\n        }\n    }\n \
    \   return median;", "    assert(l.size() >= 2);\n    float m = l[0];\n    int\
    \ s = l.size();\n    for (int i = 1; i < s; ++i) {\n        if (l[i] < m)\n  \
    \          m = l[i];\n    }\n    return m;", "  // Find median of first two elements.\n\
    \  long mid1 = l[0] + l[1] >> 1;\n  long mid2 = l[0] + l[1] >> 1;\n  assert(mid1\
    \ != mid2);\n  // If even, median is mid.\n  long mid = mid1;\n  if (l[1] & 1)\n\
    \    mid = mid2;\n  // If odd, median is (mid-1) + 1.\n  else\n    mid = (mid1\
    \ - 1) + 1;\n  // Return average of middle two elements.\n  float result = (mid\
    \ * mid) >> 1;\n  // If there are an even number of elements, median is the mean\
    \ of the two.\n  if (l[1] & 1)\n    return result + (l[2] / 2);\n  return result;",
  "    // Write your code here.\n    float total = 0;\n    int n = l.size();\n   \
    \ for (int i = 0; i < n; i++)\n        total += l[i];\n    float mid = total /\
    \ n;\n    float left_sum = 0;\n    int left_count = 0;\n    int right_count =\
    \ 0;\n    for (int i = 0; i < n; i++)\n        if (l[i] <= mid)\n            left_sum\
    \ += l[i];\n        else\n            right_count += 1;\n    int count = 0;\n\
    \    while (left_count < n && right_count < n)\n        if (l[count] < mid)\n\
    \            left_sum += l[count++];\n        else\n            right_count +=\
    \ 1;\n    if (left_count == n)\n        return mid;\n    else if (right_count\
    \ == n)\n        return l[n - 1];\n    else if (left_sum / left_count > mid /\
    \ right_count)\n        return l[n - 1];\n    else\n        return mid;", "  \
    \  if (l.size() == 0)\n        throw std::runtime_error(\"No data\");\n    long\
    \ mid = l.size() / 2;\n    std::nth_element(l.begin(), l.begin() + mid, l.end());\n\
    \    return l[mid];", "    assert(l.size() > 0);\n    std::vector<int> ids(l.size());\n\
    \    std::iota(ids.begin(), ids.end(), 0);\n    // sort based on first value\n\
    \    std::sort(ids.begin(), ids.end(),\n      [&l] (int x, int y) {\n        \
    \  return l[x] > l[y];\n    });\n    std::vector<long> medians;\n    long median_id\
    \ = 0;\n    for (long x : ids) {\n        medians.push_back(l.at(x));\n      \
    \  if (x != median_id) {\n            median_id = x;\n        }\n    }\n    long\
    \ center = median(medians);\n    return l.at(median_id);", "    int n = l.size();\n\
    \    float x[n];\n    float sum = 0;\n    for (int i = 0; i < n; ++i) {\n    \
    \    x[i] = l[i];\n        sum += x[i];\n    }\n    return sum / n;", "    auto\
    \ it = std::begin(l);\n    auto it2 = std::next(it, l.size() / 2);\n    std::nth_element(it,\
    \ it2, it);\n    return *it;", "    long n = l.size();\n    assert(n != 0); //\
    \ if n is 0, median is undefined\n    long mid = n%2 ? (n-1)/2 : (n./2)-1;\n \
    \   if (n == 1 || n == 0 || n == mid)\n        return l[0];\n    else {\n    \
    \    float f = l[mid - 1];\n        for (long i = mid; i <= n; i++)\n        \
    \    f += l[i];\n        return f / n;\n    }", "  sort(l.begin(), l.end());\n\
    \  size_t mid = (l.size() - 1) / 2;\n  return ((l[mid] + (l[mid + 1] + l[mid +\
    \ 2])) / 3.0);", "    sort(l.begin(), l.end());\n    return l.size() > 1 ? l[(l.size()\
    \ - 1) / 2] : l[0];", "    auto it = std::nth_element(l.begin(), l.begin() + l.size()\
    \ / 2, l.end());\n    return std::distance(l.begin(), it);", "    assert(l.size()\
    \ > 0);\n    long long med = l[0];\n    for (long long i = 1; i < l.size(); ++i)\n\
    \        med = l[i] > med ? l[i] : med;\n    return med;", "    if (l.size() ==\
    \ 0)\n        return 0;\n    long long s = std::accumulate(l.begin(), l.end(),\
    \ 0);\n    float x = (s - 1) / l.size();\n    return x;", "  // Sort list l.\n\
    \  std::sort(l.begin(), l.end());\n  // Return median.\n  return l[l.size() /\
    \ 2];", "\tassert(l.size() > 1);\n\tauto begin = l.begin();\n\tauto end = l.end();\n\
    \tstd::nth_element(begin, begin+l.size() / 2, end);\n\tassert(l.size() > l.size()\
    \ / 2);\n\treturn *begin + (begin+l.size() / 2)/2;", "    if (l.size() == 0)\n\
    \        return 0;\n    std::nth_element(l.begin(), l.begin() + l.size() / 2,\
    \ l.end()); // Sort list to order descending based on its size.\n    return l[l.size()\
    \ / 2]; // Return middle element of sorted list.", "    long i, mid;\n    float\
    \ x;\n\n    mid = (long)(l.size() / 2.0);\n    x = l[mid];\n    for (i = mid;\
    \ i < l.size(); i++) {\n        if (l[i] < x) {\n            x = l[i];\n     \
    \   }\n    }\n    return x;", "    sort(l.begin(), l.end());\n    long mid = l.size()\
    \ / 2;\n    if (l.size() % 2 == 0) return l[mid];\n    else return (l[mid] + l[mid-1])\
    \ / 2.0;", "    long mid=l.size();\n    if(mid%2==0) mid=mid/2;\n    else mid=mid-1;\n\
    \    float x=(float)l[mid]; //left element\n    float y=(float)l[mid-1]; //right\
    \ element\n    float z=x+y;\n    if(z==x) return x;\n    else if(z<x) return x;\n\
    \    else return z;", "    assert(l.size() >= 2);\n\n    // Sort in ascending\
    \ order\n    std::sort(l.begin(), l.end());\n\n    // If the size of the list\
    \ is even, the median is the mean of the two middle values.\n    // If the size\
    \ of the list is odd, the median is the mean of the middle value and the sum of\
    \ the two middle values (rounded up to the next even number).\n    if (l.size()\
    \ % 2 == 0) {\n        return static_cast<float>((l[0] + l[l.size()/2]) / 2.0);\n\
    \    } else {\n        return static_cast<float>((l[l.size()/2] + l[l.size()/2-1])\
    \ / 2.0);\n    }", "    std::sort(l.begin(), l.end());\n    return l[(l.size()+1)/2];",
  "    // Sort the array from greatest to least to preserve the original order.\n\
    \    sort(l.begin(), l.end());\n    // Return greatest element of list if it is\
    \ odd, otherwise return least element.\n    if (l.size() % 2 == 1) {\n       \
    \ return l[l.size() / 2];\n    }\n    else {\n        return -l[l.size() / 2];\n\
    \    }", "    // code here\n    // vector<int> l={2,3,5};\n    // for(int i=0;i<l.size();i++){\n\
    \    //     if(l[i]>l[i+1]){\n    //         l[i]=l[i+1];\n    //         l[i+1]=l[i];\n\
    \    //     }\n    // }\n    // return l[ls.size()/2];\n    \n    int n=l.size();\n\
    \    // cout << \"n=\" << n << endl;\n    if (n%2 == 1)\n        return l[n/2];\
    \ // odd number of elements\n    else // n is even\n        return (l[n/2] + l[n/2\
    \ - 1])/2.0;", "    std::nth_element(l.begin(), l.begin() + l.size()/2, l.end());\n\
    \    return l.at(l.size()/2-1);", "  assert(l.size() >= 2);\n  long l = static_cast<long>(l.size());\n\
    \  long middle = l / 2;\n  long a = (l-1) / 2;\n  float b = a / 2.0F;\n  float\
    \ c = l + 0.5F;\n  float ans = (a+b+c) / 2.0F;\n  return ans;", "    sort(l.begin(),\
    \ l.end());\n    return l[(l.size()+1)/2-1];", "  int n = l.size();\n  long long\
    \ sum = 0;\n  for (int i = 0; i < n; i++) {\n    sum += l[i];\n  }\n  float result\
    \ = sum / n;\n  return result;", "    assert(l.size() > 0);\n    long mid = l.size()\
    \ / 2;\n    float left = l[mid];\n    float right = l[mid];\n    for (size_t i\
    \ = 0; i < l.size(); i++) {\n        if (i < mid) {\n            if (l[i] > right)\
    \ {\n                right = l[i];\n            }\n        } else if (i > mid)\
    \ {\n            if (l[i] < left) {\n                left = l[i];\n          \
    \  }\n        }\n    }\n    return (left + right) / 2.0;", "    // sort input\
    \ vector first\n    std::sort(l.begin(), l.end());\n    // get middle element\
    \ (middle of the sorted vector)\n    auto middle = l.size() / 2;\n    // if size\
    \ is even middle is median\n    if (l.size() % 2 == 0) {\n        // if median\
    \ is less than first element\n        if (l[middle] < l[0]) {\n            //\
    \ return it\n            return l[middle];\n        }\n        // else median\
    \ is greater than first element\n        // check if middle element is greater\
    \ than first element\n        if (l[middle - 1] > l[middle]) {\n            //\
    \ return middle element\n            return l[middle];\n        }\n        //\
    \ else median is greater than first element and less than second element\n   \
    \     else {\n            // return middle element\n            return l[middle\
    \ - 1];\n        }\n    }\n    // if size is odd middle is median\n    else {\n\
    \        // if median is greater than first element\n        if (l[middle] > l[0])\
    \ {\n            // return it\n            return l[middle];\n        }\n    \
    \    // else median is less than first element\n        // check if middle element\
    \ is greater than first element\n        if (l[middle - 1] < l[middle]) {\n  \
    \          // return middle element\n            return l[middle];\n        }\n\
    \        // else median is greater than first element and less than second element\n\
    \        else {\n            // return middle element\n            return l[middle\
    \ - 1];\n        }\n    }", "    int size = l.size();\n    if (size % 2 == 0)\
    \ // Odd length list.\n        return l[(size / 2)];\n    else // Even length\
    \ list.\n        return (l[(size / 2) - 1] + l[(size / 2)]) / 2.0;", "\t// Sort\
    \ l first. O(n log n).\n\tstd::sort(l.begin(), l.end());\n\tint mid = l.size()\
    \ / 2;\n\tif (mid == 0)\n\t\treturn l[0];\n\tif (l.size() % 2 == 1)\n\t\treturn\
    \ l[mid - 1];\n\telse\n\t\treturn ((l[mid] + l[mid - 1]) / 2);", "    // Sort\n\
    \    std::sort(l.begin(), l.end());\n    // find length\n    int length = l.size();\n\
    \    \n    if (length % 2 == 0) {\n        return (l[length / 2 - 1] + l[length\
    \ / 2]) / 2.0;\n    } else {\n        return l[length / 2];\n    }", "  // Sort\
    \ elements by their value.\n  std::sort(l.begin(), l.end());\n  \n  // Get median.\n\
    \  float median = 0;\n  if (l.size() % 2 == 0) {\n    int mid = l.size() / 2;\n\
    \    median = (l[mid] + l[mid - 1]) / 2;\n  }\n  else {\n    median = l[(l.size()\
    \ / 2)];\n  }\n  return median;", "    // your code here\n    int n = l.size();\n\
    \    if (n % 2 == 0){\n        return (float(l[n / 2] + l[n / 2 - 1])/2.0);\n\
    \    } else {\n        return (float(l[n / 2] + l[n / 2 - 1]));\n    }", "  long\
    \ long temp = 0;\n  long long n = l.size();\n  if (n & 1) return l[(n / 2) - 1];\n\
    \  for (int i = 0; i < n / 2; i++) temp = l[i];\n  int count = 0;\n  int max =\
    \ 0;\n  for (int i = 0; i < n; i++) {\n    temp += l[i];\n    if (temp > max)\
    \ {\n      max = temp;\n      count = 1;\n    } else if (temp == max) count++;\n\
    \  }\n  return count % 2 == 0 ? l[((n / 2) - 1)] : l[((n / 2) - 2) - 1] + l[((n\
    \ / 2) - 1)];", "    long long median_value = (llong) 0;\n    long long number_of_elements\
    \ = l.size();\n    long long max_value = number_of_elements - 1;\n    // If number\
    \ of elements is odd, then return middle element.\n    if (number_of_elements\
    \ % 2 == 0) {\n        return l[max_value / 2];\n    }\n    // Find the middle\
    \ of the list.\n    long long half_number = (max_value / 2) + 1;\n    // If list\
    \ contains even number of elements, then median is the middle element.\n    if\
    \ (max_value % 2 == 0) {\n        return l[half_number];\n    }\n    // If list\
    \ contains odd number of elements, then the median is middle - 1. \n    return\
    \ l[half_number - 1];", "  // Sort list l.\n  // >>> median([3, 1, 2, 4, 5])\n\
    \  // 3\n  // >>> median([-10, 4, 6, 1000, 10, 20])\n  // 15.0\n  l.sort([](long\
    \ a, long b) {return (a > b);});\n  // Find median.\n  // >>> median([3, 1, 2,\
    \ 4, 5])\n  // 3.0\n  // >>> median([-10, 4, 6, 1000, 10, 20])\n  // 15.0\n  long\
    \ mid = l.size() / 2;\n  assert(mid > 0);\n  return (l.at(mid) + l.at(mid)) /\
    \ 2;", "    // Sort the list l.\n    sort(l.begin(), l.end());\n    // Return\
    \ element with index 0.\n    return l[0];", "  long n = l.size();\n  long mid\
    \ = (n + 1) >> 1;\n  if (n == 0)\n    return 0.0f;\n  long sum = 0;\n  for (long\
    \ i = 0; i < mid; i++) {\n    sum += l[i];\n  }\n  return sum / mid;", "    long\
    \ mid = l.size() / 2;\n    if (l.size() % 2 == 0)\n        mid++;\n    long largest\
    \ = std::max(l[mid], l[0]);\n    if (largest == l[0])\n        return l[0];\n\
    \    long smallest = std::min(l[mid], l[0]);\n    if (largest == l[0])\n     \
    \   return l[0];\n    if (smallest == l[mid])\n        return l[mid];\n    return\
    \ (largest + smallest) / 2.0;", "    sort(l.begin(), l.end());\n    float mid\
    \ = l.size() / 2;\n    return float (l[mid]);", "    long mid = l.size() / 2;\n\
    \    float f = ((l[mid] + l[mid-1]) / 2.0f);\n    return f;", "    // Your code\
    \ here\n    assert(l.size() >= 2);\n    std::nth_element(l.begin(), l.begin()\
    \ + l.size() / 2, l.end());\n    return l[l.size() / 2];", "    // Number of elements\
    \ in list l.\n    int n = l.size();\n    if (n <= 1)\n        return l[0];\n \
    \   // Sort the list l.\n    std::sort(l.begin(), l.end());\n    // Return median.\n\
    \    return (float) n / 2;", "    long long int a = (long long int)(l.size()/2);\n\
    \    long long int b = l.size() - a;\n    float mid = a;\n    mid = (float)(mid);\n\
    \    float x = 0;\n    if (b > 0) {\n        x = ((float)(a+b))/2;\n    }\n  \
    \  else x = ((float)(a))/2;\n    return (mid-x);", "    std::sort(l.begin(), l.end());\n\
    \    return l[l.size() / 2];", "  std::vector<long> arr(l.size());\n  for (std::size_t\
    \ i = 0; i < l.size(); i++)\n    arr[i] = l[i];\n  // Compute median by partitioning\
    \ array around median.\n  // Median = (left + right) / 2.\n  long lo = arr[0]\
    \ / 2;\n  long hi = arr[-1] / 2;\n  long mid = (lo + hi) / 2;\n  // If (lo + hi)\
    \ / 2 overflows, partition\n  // lo to (hi + lo) instead.\n  while (lo < hi) {\n\
    \    // mid = partition(arr, lo, hi);\n    if (arr[mid] < mid)\n      lo = mid\
    \ + 1;\n    else\n      hi = mid - 1;\n    mid = (lo + hi) / 2;\n  }\n  return\
    \ mid;", "    assert(l.size() > 0);\n    long mid = l.size() / 2;\n    float midVal\
    \ = l[mid];\n    float leftMedian = median(l, mid - 1, mid);\n    float rightMedian\
    \ = median(l, mid + 1, l.size() - 1);\n    return leftMedian + rightMedian;",
  "    long mid = l.size() / 2;\n    long leftI = 0;\n    long rightI = mid;\n   \
    \ while (leftI < rightI) {\n        if (l[leftI] < l[rightI]) {\n            ++leftI;\n\
    \        } else {\n            ++rightI;\n        }\n    }\n    return l[rightI];",
  "    long long sum = 0;\n    for (long long i = 0; i < l.size(); i++)\n        sum\
    \ += l[i];\n\n    float x = 0;\n    if (l.size() % 2 == 1) {\n        float median\
    \ = (l[l.size() / 2] + l[l.size() / 2 - 1]) / 2.0;\n        x = median;\n    }\n\
    \n    float a = 0, b = 0, c;\n    for (long long i = 0; i < l.size(); i++)\n \
    \       sum += l[i];\n\n    float median = sum / l.size();\n    for (long long\
    \ i = 0; i < l.size(); i++)\n        if (l[i] < median) {\n            median\
    \ = l[i];\n            a = b + 1;\n        }\n        else\n            b = i;\n\
    \    c = b + 1 - a;\n    if (c < 0)\n        c = 0;\n    median = (b + a + c)\
    \ / 2;\n    return median;", "    // initialize median as first element of l.\n\
    \    float mid = l[0];\n    // sort list l, place the largest number at the\n\
    \    // beginning of l.\n    std::sort(l.begin(), l.end());\n    // if there are\
    \ more than two elements, return the\n    // average of the two numbers\n    if\
    \ (l.size() > 2) {\n        mid = static_cast<float>(l.size()) / 2;\n    }\n \
    \   // return the median of the list\n    return mid;", "  // Sort list l.\n \
    \ std::sort(l.begin(), l.end());\n  // Return median of elements in the list l.\n\
    \  long size = l.size();\n  float pivot = l.at(size / 2);\n  float total = pivot;\n\
    \  for (int i = 0; i < size; i++)\n    if (pivot > l[i])\n      total -= l[i];\n\
    \    else if (pivot < l[i])\n      total += l[i];\n  return total;", "  std::sort(l.begin(),\
    \ l.end());\n  return l.size() == 0 || l.size() == 1 ? l[0] : (l.size() % 2 ==\
    \ 0) ?\n      ((l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0) : (l[l.size() /\
    \ 2] + l[l.size() / 2 - 1]) / 2.0;", "    // Find half of list length.\n    size_t\
    \ half_size = l.size() / 2;\n    // Check if list is even or odd.\n    if (l.size()\
    \ % 2 == 0)\n        return l[half_size];\n\n    // If even, recurse on even half,\
    \ otherwise on odd half.\n    return median(l.begin() + half_size, l.begin() +\
    \ half_size, l.end());", "    if (l.size() == 0)\n        return 0.0f;\n    long\
    \ m = l[l.size()/2];\n    for (size_t i = l.size()/2; i < l.size(); i++)\n   \
    \     m = std::max(m, l[i]);\n    return m/2.0f;", "  long mid = (long) l.size()\
    \ / 2;\n  std::nth_element(l.begin(), l.begin() + mid, l.end());\n  long left\
    \ = mid;\n  long right = mid;\n  while (left <= right) {\n    if (l[left] <= l[right])\
    \ left++;\n    else right--;\n  }\n  return l[right];", "    long mid = l.size()\
    \ / 2;\n    if (l.size() % 2)\n        return l[mid];\n    float p1 = median(l.substr(0,\
    \ mid));\n    float p2 = median(l.substr(mid));\n    return (p1 + p2) / 2;", "\t\
    std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n\tlong mid =\
    \ l.size() / 2;\n\tif (l.size() % 2 != 0)\n\t\treturn l[mid];\n\telse\n\t\treturn\
    \ (float) (l[mid] + l[mid-1]);", "  std::nth_element(l.begin(), l.begin() + l.size()\
    \ / 2, l.end());\n  return *std::max_element(l.begin(), l.begin() + l.size() /\
    \ 2);", "  // If vector is empty, return 0\n  if (l.empty()) {\n    return 0.0;\n\
    \  }\n  // Find the midpoint\n  long mid = l.size() / 2;\n  // If the midpoint\
    \ is odd, return the average of the middle two\n  if (mid % 2 == 1) {\n    return\
    \ l[mid/2];\n  }\n  // Otherwise, return the middle element\n  return l[mid];",
  "    int mid = (l.size() + 1) / 2;\n    if (l.size() % 2)\n        return l[mid];\n\
    \    else return l[mid] - l[mid - 1] / 2;", "  // Write your code here.\n  //\
    \ std::vector<long double> l_copy;\n  // for(long double i:l)\n  //     l_copy.push_back(i);\n\
    \  // sort(l_copy.begin(), l_copy.end());\n  // return l_copy[l_copy.size() /\
    \ 2];\n  \n  // Time Complexity\n  //     Time complexity O(N)\n  //     Space\
    \ complexity O(N)\n  // In above code, N denotes the number of elements in given\
    \ list\n  // To sort a list, we have to traverse through all the elements of the\
    \ list, that\n  // takes O(N) time. Thus total time complexity becomes O(N^2)\
    \ and space complexity becomes O(N)\n  \n  // Alternative solution\n  \n  // Write\
    \ your code here.\n  \n  \n  // Time Complexity\n  //     Time complexity O(N.log(N))\n\
    \  //     Space complexity O(1)\n  // In above code, N denotes the number of elements\
    \ in given list\n  // To sort a list, we have to traverse through all the elements\
    \ of the list, that\n  // takes O(N.log(N)) time. Thus total time complexity becomes\
    \ O(N.log(N)) and space complexity becomes O(1)\n  \n  // Alternative solution\n\
    \  \n  // Write your code here.\n  \n  \n  // Time Complexity\n  //     Time complexity\
    \ O(Nlog(N))\n  //     Space complexity O(1)\n  // In above code, N denotes the\
    \ number of elements in given list\n  // To sort a list, we have to traverse through\
    \ all the elements of the list, that\n  // takes O(Nlog(N)) time. Thus total time\
    \ complexity becomes O(Nlog(N)) and space complexity becomes O(1)\n  \n  // Alternative\
    \ solution\n  \n  // Write your code here.\n  \n  \n  // Time Complexity\n  //\
    \     Time complexity O(NlogN)\n  //     Space complexity O(1)\n  // In above\
    \ code, N denotes the number of elements in given list\n  // To sort a list, we\
    \ have to traverse through all the elements of the list, that\n  // takes O(NlogN)\
    \ time. Thus total time complexity becomes O(NlogN) and space complexity becomes\
    \ O(1)\n  \n  // Alternative solution\n  \n  // Write your code here.\n  \n  \n\
    \  // Time Complexity\n  //     Time complexity O(NlogN)\n  //     Space complexity\
    \ O(1)\n  // In above code, N denotes the number of elements in given list\n \
    \ // To sort a list, we have to traverse through all the elements of the list,\
    \ that\n  // takes O(NlogN) time. Thus ", "\tassert(l.size() >= 2);\n\tlong mid\
    \ = l.size() / 2;\n\tlong a1 = l[mid];\n\tlong a2 = l[mid+1];\n\tif (l.size()\
    \ % 2 == 1)\n\t\treturn a2;\n\telse\n\t\treturn (static_cast<float>(a1) + static_cast<float>(a2))\
    \ / 2.0;", "    auto middle = (l.size() / 2) + 1;\n    // Sort list\n    sort(l.begin(),\
    \ l.end());\n    if (middle == l.size()) return l[0];\n    if (middle > l.size())\
    \ return l.front();\n    long sum = 0;\n    for (int i = 0; i < middle; ++i) {\n\
    \        sum += l[i];\n    }\n    return (float(sum) / middle);", "    sort(l.begin(),\
    \ l.end());\n    long l = l.size() / 2;\n    return l[l % l.size()];", "    assert(l.size()\
    \ > 2);\n    long x = l.front();\n    for (std::vector<long>::const_iterator it\
    \ = l.begin() + 1; it != l.end(); ++it) {\n        if (x < *it) {\n          \
    \  x = *it;\n        }\n    }\n    return x;", "    float x = 0;\n    float y\
    \ = 0;\n    float avg = 0;\n\n    for (int i = 0; i < l.size(); i++) {\n     \
    \   x = x + l[i];\n        y = y + i;\n    }\n    avg = x/y;\n    return avg;",
  "    long n = l.size();\n    if (n <= 1) {\n        return l[0];\n    }\n\n    std::vector<long>\
    \ med;\n    std::nth_element(l.begin(), l.begin() + n-1, l.end());\n    med.push_back(l[n-1]);\n\
    \n    if (n % 2 == 1) {\n        return std::min(med[1], med[n/2]);\n    }\n \
    \   return med[n/2];", "    std::nth_element(l.begin(), l.begin() + l.size()/2,\
    \ l.end()); \n    return l[l.size()/2];", "    float mid = l.size() / 2;\n   \
    \ if (l.size() == 0)\n        return -1;\n    else if (l.size() == 1)\n      \
    \  return l[0];\n    else if (l.size() % 2 == 0) {\n        return std::max<long>(l[mid],\
    \ l[l.size()/2 - 1]);\n    }\n    else {\n        std::vector<long> l2 = l;\n\
    \        l2.insert(l2.begin() + mid, 0);\n        l2.insert(l2.begin() + mid,\
    \ 0);\n        return std::max<long>(l[mid], std::max<long>(l2[mid], l[l.size()/2\
    \ - 1]));\n    }", "    assert(l.size() >= 2);\n    long mid = l.size() / 2;\n\
    \    float midVal = l[mid];\n    return midVal == l[mid-1] ? midVal : (midVal+l[mid])/2.f;",
  "    int l = l.size();\n    assert(l % 2 == 0);\n    if (l == 0)\n        return\
    \ 0;\n    int mid = (l - 1) / 2;\n    if (l%2 == 1)\n        return l[mid + 1];\n\
    \    return ((l[mid + 1] + l[mid]) / 2.0);", "    // write your code here\n  \
    \  long size = l.size();\n    if(size%2==0){\n        return l[size/2];\n    }else{\n\
    \        return (l[size/2] + l[size/2-1])/2.0;\n    }"]
stop_tokens:
- "\n}"
