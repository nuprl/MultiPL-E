name: HumanEval_68_pluck
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    int size = arr.size();\n    int minIndex\
    \ = size;\n    int minVal = arr[minIndex];\n    long smalest_value = minVal;\n\
    \    \n    for (int i = 0; i < size; i++) {\n        int curVal = arr[i];\n  \
    \      if (curVal % 2 == 0) {\n            if (curVal < smalest_value) {\n   \
    \             minIndex = i;\n                minVal = curVal;\n              \
    \  smalest_value = curVal;\n            }\n        } else if (curVal == smalest_value)\
    \ {\n            minIndex++;\n            smalest_value = arr[minIndex];\n   \
    \     }\n    }\n    \n    ans.push_back(smalest_value);\n    ans.push_back(minIndex);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // code here\n  std::vector<long> arr2 = arr;\n  int count[10000];\n\
    \  for (int i = 0; i < arr.size(); i++) {\n    count[arr[i]] += 1;\n  }\n  std::vector<long>\
    \ result;\n  int smallest = 0;\n  for (int i = 0; i < arr.size(); i++) {\n   \
    \ if (count[i] > 1) {\n      if (smallest != 0 && count[smallest] > 1) {\n   \
    \     int index = arr2.size();\n        while (index > 0 && count[index] == 1)\
    \ {\n          index--;\n        }\n        int smaller_index = index;\n     \
    \   while (smaller_index > 0 && count[smaller_index] == 1) {\n          smaller_index--;\n\
    \        }\n        result.push_back(arr2[smallest]);\n        result.push_back(smaller_index);\n\
    \        break;\n      }\n      if (count[i] > count[smallest]) {\n        smallest\
    \ = i;\n      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp3ha6vy3k: /tmp/tmp3ha6vy3k.cpp:61: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long low = 0, high = arr.size()-1;\n    std::vector<long>\
    \ v;\n    long smalest_value = arr[0];\n    int index = -1;\n    while ( low <=\
    \ high){\n        int mid = low+((high-low)/2);\n        if( arr[mid] % 2 == 0){\n\
    \            smalest_value = arr[mid];\n            index = mid;\n           \
    \ low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n \
    \   }\n    v.push_back(smalest_value);\n    v.push_back(index);\n    return v;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_value = arr[0];\n    long smallest_index = 0;\n\
    \    std::map<long, long> nodes;\n    std::vector<long> answer;\n    std::for_each(arr.begin()\
    \ + 1, arr.end(), [&](long &val) {\n        auto it = nodes.find(val);\n     \
    \   if (nodes.end() != it) {\n            if (smallest_even_value == val) {\n\
    \                smallest_even_value = smallest_even_value * 2;\n            \
    \    smallest_index = it->second;\n            }\n            nodes[val] = it->second;\n\
    \        } else {\n            nodes[val] = arr.size();\n        }\n    });\n\
    \    if (smallest_even_value == 0) return answer;\n    std::vector<long> index_to_ret(smallest_index\
    \ + 1);\n    index_to_ret[0] = smallest_index;\n    for (auto it = nodes.begin();\
    \ it != nodes.end(); ++it) {\n        index_to_ret[it->second] = it->first;\n\
    \    }\n    return index_to_ret;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpir5xs3wx: /tmp/tmpir5xs3wx.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::iota(arr.begin(), arr.end(), 0);\n  std::sort(arr.begin(), arr.end(),\
    \ [&arr](int a, int b){ return (arr[a] % 2 == 0) - (arr[b] % 2 == 0); });\n  std::size_t\
    \ index = std::distance(arr.begin(), std::min_element(arr.begin(), arr.end(),\
    \ [&arr](int a, int b){ return (arr[a] % 2 == 0) - (arr[b] % 2 == 0); }));\n \
    \ return std::vector{arr[index], index};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4zrrrulq.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4zrrrulq.cpp:32:21: error: missing template arguments\
    \ before \u2018{\u2019 token\n   32 |   return std::vector{arr[index], index};\n\
    \      |                     ^\n/tmp/tmp4zrrrulq.cpp:32:21: error: expected \u2018\
    ;\u2019 before \u2018{\u2019 token\n   32 |   return std::vector{arr[index], index};\n\
    \      |                     ^\n      |                     ;\n/tmp/tmp4zrrrulq.cpp:32:39:\
    \ error: expected \u2018;\u2019 before \u2018}\u2019 token\n   32 |   return std::vector{arr[index],\
    \ index};\n      |                                       ^\n      |          \
    \                             ;\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> v;\n    int n=arr.size();\n    // \"pick\" will\
    \ keep track of the smallest even value\n    long pick = arr[0];\n    int smallestEven\
    \ = 0;\n    // \"index\" will keep track of the smallest index\n    int smallestIndex\
    \ = 0;\n    \n    // \"loop\" will iterate over all the nodes\n    // and pick\
    \ the smallest even and smallest index\n    // for each node.\n    for (int i=1;\
    \ i<n; i++){\n        \n        if(pick%2==0){\n            smallestEven=arr[i];\n\
    \            smallestIndex=i;\n        }else{\n            if(arr[i]<smallestEven){\n\
    \                smallestEven=arr[i];\n                smallestIndex=i;\n    \
    \        }\n        }\n        pick=smallestEven;\n    }\n    \n    // return\
    \ the vector [ smallest even value, its index ]\n    v.push_back(smallestEven);\n\
    \    v.push_back(smallestIndex);\n    \n    return v;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfot61l2s: /tmp/tmpfot61l2s.cpp:62: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    \n    std::vector<long> result;\n \
    \   long smallestValue = arr[0];\n    long smallestIndex = 0;\n    for(int i =\
    \ 1; i < arr.size(); i++){\n        if(arr[i] < smallestValue){\n            smallestValue\
    \ = arr[i];\n            smallestIndex = i;\n        }\n    }\n    result.push_back(smallestValue);\n\
    \    result.push_back(smallestIndex);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp77ohnlwq: /tmp/tmp77ohnlwq.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = INT_MIN;\n    long index = INT_MIN;\n\n  \
    \  for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i]\
    \ < smallest_value) {\n            smallest_value = arr[i];\n            index\
    \ = i;\n        }\n    }\n    std::vector<long> output = {smallest_value, index};\n\
    \    return output;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpltxa3in_: /tmp/tmpltxa3in_.cpp:43: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long temp=arr[0];\n    int i=0;\n    std::vector<long> ret={temp,i};\n\
    \    for(int j=1;j<arr.size();j++) {\n        if(arr[j]%2==0){\n            temp=arr[j];\n\
    \            ret[i]=temp;\n            i=i+1;\n        }\n    }\n    return ret;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpg1zahslh: /tmp/tmpg1zahslh.cpp:43: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> index;\n\tlong result = arr[0];\n\tfor (long i :\
    \ arr) {\n\t\tif (i % 2 == 0) {\n\t\t\tresult = i;\n\t\t\tindex.push_back(i);\n\
    \t\t}\n\t}\n\treturn index;\n}\nint main() {\n    auto candidate = pluck;\n  \
    \  assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp5rcxe9pg: /tmp/tmp5rcxe9pg.cpp:41: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  int min_even_val = INT_MAX;\n  int index = 0;\n  for (int i = 0; i\
    \ < arr.size(); i++) {\n    if (arr[i] % 2 == 0) {\n      if (arr[i] < min_even_val)\
    \ {\n        index = i;\n        min_even_val = arr[i];\n      }\n    }\n  }\n\
    \  return std::vector<long>{min_even_val, index};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpkii9qp93: /tmp/tmpkii9qp93.cpp:45: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::vector<long>())' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  assert(arr.size() != 0);\n  std::vector<long> result;\n  bool flag\
    \ = false;\n  long minimum = 0;\n  long index = -1;\n  long i = 0;\n  while (i\
    \ < arr.size()) {\n    if (flag) {\n      if (arr[i] < minimum) {\n        flag\
    \ = false;\n      }\n      if (minimum == 0 && arr[i] == 0) {\n        result.push_back(arr[i]);\n\
    \      } else {\n        result.push_back(minimum);\n        index = i;\n    \
    \  }\n    } else {\n      if (arr[i] == 0) {\n        result.push_back(arr[i]);\n\
    \        flag = true;\n      } else if (arr[i] < minimum) {\n        flag = true;\n\
    \        minimum = arr[i];\n        index = i;\n      }\n    }\n    i++;\n  }\n\
    \  result.push_back(minimum);\n  result.push_back(index);\n  return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpxijvhujl: /tmp/tmpxijvhujl.cpp:64: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_val = INT_MIN;\n    std::vector<long> res;\n\
    \    long min_value = arr[0];\n    long index = 0;\n    for (long i : arr) {\n\
    \        long even_val = i % 2;\n        if (even_val > smallest_even_val) {\n\
    \            smallest_even_val = even_val;\n            min_value = i;\n     \
    \   }\n    }\n    res.push_back(min_value);\n    res.push_back(index);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpbq5gvefd: /tmp/tmpbq5gvefd.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::iota(arr.begin(), arr.end(), 0);\n    std::sort(arr.begin(),\
    \ arr.end(), [&](long x, long y) {\n        return x % 2 == y % 2;\n    });\n\
    \    auto last = arr.end() - 1;\n    if (arr.front() == 0) {\n        arr.erase(arr.begin());\n\
    \        last--;\n    }\n    if (arr.back() == 0) {\n        arr.erase(last);\n\
    \    }\n    return arr;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp3dy4h_jk: /tmp/tmp3dy4h_jk.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::set<long> even;\n    std::vector<std::pair<long, long>> values;\n\
    \    for (auto it=arr.begin();it!=arr.end();++it) {\n        if (even.find(*it)==even.end())\n\
    \            even.insert(*it);\n        else\n            values.push_back({ std::min(even.find(*it),\
    \ even.end()), *it });\n    }\n    if (values.empty())\n        return std::vector<long>();\n\
    \    long smalest_value = *values.rbegin();\n    long smalest_index = values.size();\n\
    \    for (int i=0;i<values.size();i++) {\n        if (values[i].first == smalest_value)\
    \ {\n            smalest_index = i;\n            break;\n        }\n    }\n  \
    \  std::vector<long> even_indices;\n    std::set<long> index;\n    for (auto it=even.begin();it!=even.end();++it)\
    \ {\n        if (index.find(*it)==index.end()) {\n            even_indices.push_back(*it);\n\
    \            index.insert(*it);\n        }\n    }\n    return std::vector<long>({\n\
    \        values[smalest_index].second,\n        smalest_index});\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpior0yx19.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpior0yx19.cpp:35:75: error: no matching function for call\
    \ to \u2018std::vector<std::pair<long int, long int> >::push_back(<brace-enclosed\
    \ initializer list>)\u2019\n   35 |             values.push_back({ std::min(even.find(*it),\
    \ even.end()), *it });\n      |                                              \
    \                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpior0yx19.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::pair<long int, long int>; _Alloc = std::allocator<std::pair<long\
    \ int, long int> >; std::vector<_Tp, _Alloc>::value_type = std::pair<long int,\
    \ long int>]\u2019\n 1184 |       push_back(const value_type& __x)\n      |  \
    \     ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::pair<long\
    \ int, long int>&\u2019}\n 1184 |       push_back(const value_type& __x)\n   \
    \   |                 ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::pair<long int, long int>; _Alloc = std::allocator<std::pair<long\
    \ int, long int> >; std::vector<_Tp, _Alloc>::value_type = std::pair<long int,\
    \ long int>]\u2019\n 1200 |       push_back(value_type&& __x)\n      |       ^~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() != 0);\n    std::vector<long> vec;\n    long minValue\
    \ = *std::min_element(arr.begin(), arr.end());\n    int minIdx = 0;\n    for (long\
    \ i : arr) {\n        if ((i % 2) == 0) {\n            if (minValue == i) {\n\
    \                minIdx++;\n            } else {\n                vec.push_back(minValue);\n\
    \                minValue = i;\n                minIdx = 1;\n            }\n \
    \       }\n    }\n    vec.push_back(minValue);\n    return vec;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpi6i252s4: /tmp/tmpi6i252s4.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int size = arr.size();\n    int smallest_value = 0;\n    int smallest_index\
    \ = 0;\n    for (int i = 0; i < size; i++) {\n        int curr = arr[i];\n   \
    \     if (curr > smallest_value) {\n            smallest_value = curr;\n     \
    \       smallest_index = i;\n        }\n    }\n    if (smallest_value == 0) {\n\
    \        smallest_value = arr[0];\n        smallest_index = 0;\n    }\n    std::vector<long>\
    \ result;\n    for (int i = 0; i < size; i++) {\n        int curr = arr[i];\n\
    \        if (curr == smallest_value) {\n            result.push_back(smallest_index);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp8293naeb: /tmp/tmp8293naeb.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest = 0;\n    long index;\n    bool found = false;\n \
    \   \n    // sort by even values\n    std::sort(arr.begin(), arr.end(), \n   \
    \     [](long a, long b){\n            return a % 2 == 0 && b % 2 == 0;\n    \
    \    }\n    );\n    \n    std::vector<long> ans;\n    \n    // search for the\
    \ smallest even value\n    // if multiple values are equal\n    for (long &i :\
    \ arr) {\n        if (i % 2 == 0 && i != 0) {\n            found = true;\n   \
    \         index = i;\n            break;\n        }\n    }\n    \n    // if there\
    \ is no even values, return empty array\n    if (!found)\n        return ans;\n\
    \    \n    // if we found an even value but it's the smallest value, \n    //\
    \ we return only the smallest index\n    if (smallest == 0)\n        index = index;\n\
    \    \n    // if this is the smallest index, add it to the result array\n    if\
    \ (index == smallest)\n        ans.push_back(smallest);\n    \n    // if the smallest\
    \ value is the last value, add it to the result array\n    // this is what we\
    \ want\n    else if (index == arr.back())\n        ans.push_back(index);\n   \
    \ \n    // else search for the smallest index\n    else{\n        // loop through\
    \ the remaining values\n        for (long &i : arr) {\n            \n        \
    \    // if the remaining value is smaller\n            if (i < smallest) {\n \
    \               \n                // update the smallest value \n            \
    \    smallest = i;\n                \n                // set the index to what\
    \ we found\n                index = i;\n                \n                // we\
    \ found what we needed so stop the loop\n                break;\n            }\n\
    \        }\n    }\n    \n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp5l51hg_n: /tmp/tmp5l51hg_n.cpp:94: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n        long smalest_value,smallest_index;\n        std::vector<long>\
    \ res;\n        for(long i=0;i<arr.size();i++){\n            if(arr[i]%2==0){\n\
    \                smalest_value=arr[i];\n                smallest_index=i;\n  \
    \          }\n        }\n        if(arr.size()==0){\n            return res;\n\
    \        }\n        for(long i=0;i<arr.size();i++){\n            if(arr[i]%2==0){\n\
    \                if(arr[i]>smalest_value){\n                    smalest_value=arr[i];\n\
    \                    smallest_index=i;\n                }\n            }\n   \
    \     }\n        res.push_back(smalest_value);\n        res.push_back(smallest_index);\n\
    \        return res;\n    }\n\n// \"Given an array representing a branch of a\
    \ tree that has non-negative integer nodes\n// your task is to pluck one of the\
    \ nodes and return it.\n// The plucked node should be the node with the smallest\
    \ odd value.\n// If multiple nodes with the same smallest odd value are found\
    \ return the node that has smallest index.\n// The plucked node should be returned\
    \ in a list, [ smalest_value, its index ],\n// If there are no odd values or the\
    \ given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n// Output:\
    \ [2, 1]\n// Explanation: 2 has the smallest odd value, and 2 has the smallest\
    \ index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest odd value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck2(std::vector<long>\
    \ arr) {\n        long smalest_value,smallest_index;\n        std::vector<long>\
    \ res;\n        for(long i=0;i<arr.size();i++){\n            if(arr[i]%2==1){\n\
    \                smalest_value=arr[i];\n                smallest_index=i;\n  \
    \          }\n        }\n        if(arr.size()==0){\n            return res;\n\
    \        }\n        for(long i=0;i<arr.size();i++){\n            if(arr[i]%2==1){\n\
    \                if(arr[i]>smalest_value){\n                    smalest_value=arr[i];\n\
    \                    smallest_index=i;\n                }\n            }\n   \
    \     }\n        res.push_back(smalest_value);\n        res.push_back(smallest_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd8zgz8v9.cpp: In function \u2018std::vector<long int> pluck2(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpd8zgz8v9.cpp:99:23: error: \u2018smallest_\u2019 was not\
    \ declared in this scope; did you mean \u2018smallest_index\u2019?\n   99 |  \
    \       res.push_back(smallest_\n      |                       ^~~~~~~~~\n   \
    \   |                       smallest_index\n/tmp/tmpd8zgz8v9.cpp:100:1: warning:\
    \ control reaches end of non-void function [-Wreturn-type]\n  100 | }\n      |\
    \ ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    std::sort(arr.begin(), arr.end(), std::greater<long>());\n\
    \    auto it=std::find_if(arr.begin(), arr.end(), [](int n){return n%2==0;});\n\
    \    if(it!=arr.end()){\n        std::vector<long> res; \n        res.push_back(arr[it]);\n\
    \        long index=0;\n        for(auto i=it+1; i<arr.size(); i++){\n       \
    \     if(arr[i]%2==0){\n                res.push_back(arr[i]);\n             \
    \   index=i;\n                break;\n            }\n        }\n        if(index>res.size()){\n\
    \            res.resize(index);\n        }\n        return res;\n    }\n    return\
    \ std::vector<long>();\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkgo0k7pp.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkgo0k7pp.cpp:34:26: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::vector<long int>\u2019 and \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019)\n   34 |         res.push_back(arr[it]);\n\
    \      |                          ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpkgo0k7pp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = long int;\
    \ _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::reference = long\
    \ int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n 1040\
    \ |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:28:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019 to \u2018std::vector<long int>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 1040 |       operator[](size_type __n)\
    \ _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1058:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const [with _Tp = long\
    \ int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::const_reference\
    \ = const long int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\
    \n 1058 |       operator[](size_type __n) const _GLIBCXX_NOEXCEPT\n      |   \
    \    ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1058:28:\
    \ note:   no known c"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::multiset<long> s;\n  for (auto &el : arr)\n    s.insert(el);\n\
    \  auto itr = s.begin();\n  std::vector<long> ret;\n  std::set<long> pos;\n  while\
    \ (itr != s.end()) {\n    if (*itr % 2 == 0) {\n      auto val = *itr;\n     \
    \ itr++;\n      if (pos.find(val) == pos.end()) {\n        ret.emplace_back(val);\n\
    \        pos.emplace(val);\n      }\n    } else {\n      itr++;\n    }\n  }\n\
    \  if (ret.empty())\n    return {};\n  if (ret.size() > 1) {\n    auto it = ret.begin();\n\
    \    for (auto &el : ret) {\n      if (it == ret.end()) {\n        break;\n  \
    \    }\n      if (it - ret.begin() > 1) {\n        break;\n      }\n    }\n  \
    \  ret.erase(std::next(it, ret.end()));\n  }\n  return ret;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpivyf1pr6.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpivyf1pr6.cpp:59:36: error: cannot convert \u2018std::vector<long\
    \ int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >\u2019} to \u2018std::__iterator_traits<__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >, void>::difference_type\u2019 {aka \u2018long\
    \ int\u2019}\n   59 |     ret.erase(std::next(it, ret.end()));\n      |      \
    \                       ~~~~~~~^~\n      |                                   \
    \ |\n      |                                    std::vector<long int>::iterator\
    \ {aka __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >}\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:66,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpivyf1pr6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:214:52:\
    \ note:   initializing argument 2 of \u2018_InputIterator std::next(_InputIterator,\
    \ typename std::iterator_traits<_Iter>::difference_type) [with _InputIterator\
    \ = __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >; typename\
    \ std::iterator_traits<_Iter>::difference_type = long int]\u2019\n  213 |    \
    \ next(_InputIterator __x, typename\n      |                              ~~~~~~~~\
    \               \n  214 |   iterator_traits<_InputIterator>::difference_type __n\
    \ = 1)\n      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long max_value = arr.back();\n    int node_size = arr.size();\n\
    \    std::bitset<sizeof(max_value) * 8> bitset(max_value);\n    std::vector<long>\
    \ ans(0, 0);\n    int counter = 0;\n    for (int i = 0; i < node_size; i++) {\n\
    \        bitset >>= 1;\n        if (!bitset) break;\n        counter++;\n    \
    \    ans.push_back(arr[i]);\n    }\n    std::sort(ans.begin(), ans.end());\n \
    \   if (counter > 1) {\n        return ans;\n    }\n    return {};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpasz9s3c7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpasz9s3c7.cpp:36:13: error: no match for \u2018operator!\u2019\
    \ (operand type is \u2018std::bitset<64>\u2019)\n   36 |         if (!bitset)\
    \ break;\n      |             ^~~~~~~\n/tmp/tmpasz9s3c7.cpp:36:13: note: candidate:\
    \ \u2018operator!(bool)\u2019 <built-in>\n/tmp/tmpasz9s3c7.cpp:36:13: note:  \
    \ no known conversion for argument 1 from \u2018std::bitset<64>\u2019 to \u2018\
    bool\u2019\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long min = std::numeric_limits<long>::max();\n    long index = 0;\n\
    \    for (auto &v : arr)\n        if (v < min)\n            min = v;\n       \
    \ if (v == min)\n            index++;\n    if (arr.empty())\n        return std::vector<long>();\n\
    \    else if (arr.size() == 1)\n        return std::vector<long>(1, min);\n  \
    \  std::sort(arr.begin(), arr.end());\n    if (arr[arr.size()-1] % 2 == 0)\n \
    \       return std::vector<long>(1, min);\n    return std::vector<long>{min, index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyl9doy15.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpyl9doy15.cpp:34:13: error: \u2018v\u2019 was not declared\
    \ in this scope\n   34 |         if (v == min)\n      |             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    result.push_back(arr[0]);\n    for(size_t\
    \ i = 1; i < arr.size(); ++i){\n        for(size_t j = 0; j <= i; ++j){\n    \
    \        if(arr[i] % arr[j] == 0){\n                long tmp = arr[i];\n     \
    \           arr[i] = arr[j];\n                arr[j] = tmp;\n            }\n \
    \       }\n        if(arr[i] % 2 == 0){\n            long tmp = arr[i];\n    \
    \        arr[i] = arr[i+1];\n            arr[i+1] = tmp;\n            result.push_back(arr[i]);\n\
    \        }\n    }\n    result.push_back(arr[arr.size()-1]);\n    for(int i = 1;\
    \ i < arr.size()/2; ++i){\n        if(arr[i] % 2 == 0){\n            result.push_back(arr[i]);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpvdt44f9t: /tmp/tmpvdt44f9t.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n*** Error in `/tmp/tmpvdt44f9t':\
    \ corrupted size vs. prev_size: 0x0000000001ceac2f ***\n======= Backtrace: =========\n\
    /lib64/libc.so.6(+0x80824)[0x2b086a287824]\n/lib64/libc.so.6(+0x8120e)[0x2b086a28820e]\n\
    /lib64/libc.so.6(+0x2f1a1)[0x2b086a2361a1]\n/lib64/libc.so.6(+0x2f252)[0x2b086a236252]\n\
    /tmp/tmpvdt44f9t[0x400e80]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b086a229555]\n\
    /tmp/tmpvdt44f9t[0x4009e9]\n======= Memory map: ========\n00400000-00405000 r-xp\
    \ 00000000 08:02 1207222                            /tmp/tmpvdt44f9t\n00604000-00605000\
    \ r--p 00004000 08:02 1207222                            /tmp/tmpvdt44f9t\n00605000-00606000\
    \ rw-p 00005000 08:02 1207222                            /tmp/tmpvdt44f9t\n01cd9000-01d0b000\
    \ rw-p 00000000 00:00 0                                  [heap]\n2b08696f0000-2b0869712000\
    \ r-xp 00000000 08:01 50332393                   /usr/lib64/ld-2.17.so\n2b0869712000-2b0869714000\
    \ r-xp 00000000 00:00 0                          [vdso]\n2b0869714000-2b0869716000\
    \ rw-p 00000000 00:00 0 \n2b0869717000-2b0869718000 rw-p 00000000 00:00 0 \n2b086972f000-2b0869734000\
    \ rw-p 00000000 00:00 0 \n2b0869911000-2b0869912000 r--p 00021000 08:01 50332393\
    \                   /usr/lib64/ld-2.17.so\n2b0869912000-2b0869913000 rw-p 00022000\
    \ 08:01 50332393                   /usr/lib64/ld-2.17.so\n2b0869913000-2b0869914000\
    \ rw-p 00000000 00:00 0 \n2b0869914000-2b0869add000 r-xp 00000000 00:29 1475687066821932785\
    \        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n2b0869add000-2b0869cdc000\
    \ ---p 001c9000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b0869cdc000-2b0869ce7000 r--p 001c8000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b0869ce7000-2b0869cea000 rw-p 001d3000 00:29 1475687066821932785        /shared/centos7/clang/10.0.1/lib/libstdc++.so.6.0.27\n\
    2b0869cea000-2b0869ced000 rw-p 00000000 00:00 0 \n2b0869ced000-2"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here.\n    std::vector<long> result;\n    long\
    \ smallest = 0;\n    long smallest_index;\n    long smallest_even = 0;\n    for(long\
    \ i = 0; i < arr.size(); i++) {\n        smallest = i;\n        for(long j = i+1;\
    \ j < arr.size(); j++) {\n            if(arr[j] % 2 == 0 && arr[j] < arr[smallest])\
    \ {\n                smallest = j;\n                smallest_even = arr[j];\n\
    \            }\n        }\n        result.push_back(arr[smallest]);\n        result.push_back(smallest);\n\
    \        for(long j = smallest_even; j < arr[smallest_even+1]; j++) {\n      \
    \      if(arr[j] % 2 == 0) {\n                smallest_even = j;\n           \
    \     smallest_index = j;\n            }\n        }\n        if(smallest_even\
    \ == 0) {\n            break;\n        }\n    }\n    return result ;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpx2sjdw8x: /tmp/tmpx2sjdw8x.cpp:58: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> index;\n    long smalest_even = arr[0];\n    int\
    \ smalest_index = 0;\n    int size = arr.size();\n    for(int i = 1 ; i < size\
    \ ; i++){\n        if(arr[i] < smalest_even){\n            smalest_even = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    index.push_back(smalest_index);\n\
    \    index.push_back(smalest_index);\n    return index;\n}\nint main() {\n   \
    \ auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpnf9igk06: /tmp/tmpnf9igk06.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long min = 0, max = 0, index = 0;\n    for (long i = 0; i < arr.size();\
    \ ++i) {\n        if (arr[i] > 0) {\n            min += arr[i];\n            if\
    \ (max < min)\n                max = min;\n            index++;\n        }\n \
    \   }\n    if (max == 0)\n        return std::vector<long>();\n    std::vector<long>\
    \ ret;\n    long mid = (max + min) / 2;\n    if (arr.size() % 2 == 0) {\n    \
    \    min = mid;\n        for (long i = 0; i < arr.size(); ++i) {\n           \
    \ if (arr[i] > 0) {\n                if (arr[i] == mid)\n                    ret.push_back(index);\n\
    \                else {\n                    min = mid;\n                    break;\n\
    \                }\n            }\n        }\n    } else {\n        max = mid;\n\
    \        for (long i = 0; i < arr.size(); ++i) {\n            if (arr[i] > 0)\
    \ {\n                if (arr[i] >= mid)\n                    ret.push_back(index);\n\
    \                else {\n                    max = mid;\n                    break;\n\
    \                }\n            }\n        }\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp4bt6o8st: /tmp/tmp4bt6o8st.cpp:71: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    std::vector<long> result;\n    long smallest_value;\n\
    \    int smallest_index;\n    for (auto i : arr) {\n        if ((i % 2) == 0)\
    \ {\n            if (smallest_value != 0) {\n                if (smallest_value\
    \ < i) {\n                    smallest_value = i;\n                    smallest_index\
    \ = arr.size() - 1;\n                }\n            } else {\n               \
    \ smallest_value = i;\n                smallest_index = arr.size() - 1;\n    \
    \        }\n        } else {\n            if (smallest_value == 0) {\n       \
    \         smallest_value = i;\n                smallest_index = arr.size() - 1;\n\
    \            } else {\n                if (smallest_value < i) {\n           \
    \         smallest_value = i;\n                    smallest_index = arr.size()\
    \ - 1;\n                }\n            }\n        }\n    }\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp5ky8d_qc: /tmp/tmp5ky8d_qc.cpp:62: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    std::set<long> s;\n    for(long &i\
    \ : arr){\n        s.insert(i);\n    }\n    if(s.empty()){\n        return std::vector<long>();\n\
    \    }\n    auto i = std::min_element(s.begin(), s.end());\n    return std::vector<long>{\
    \ i, s.lower_bound(i) };\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkeazy21d.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkeazy21d.cpp:38:49: error: no matching function for call\
    \ to \u2018std::set<long int>::lower_bound(std::_Rb_tree_const_iterator<long int>&)\u2019\
    \n   38 |     return std::vector<long>{ i, s.lower_bound(i) };\n      |      \
    \                                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/set:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:87,\n\
    \                 from /tmp/tmpkeazy21d.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:829:7:\
    \ note: candidate: \u2018std::set<_Key, _Compare, _Alloc>::iterator std::set<_Key,\
    \ _Compare, _Alloc>::lower_bound(const key_type&) [with _Key = long int; _Compare\
    \ = std::less<long int>; _Alloc = std::allocator<long int>; std::set<_Key, _Compare,\
    \ _Alloc>::iterator = std::_Rb_tree_const_iterator<long int>; std::set<_Key, _Compare,\
    \ _Alloc>::key_type = long int]\u2019\n  829 |       lower_bound(const key_type&\
    \ __x)\n      |       ^~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:829:35:\
    \ note:   no known conversion for argument 1 from \u2018std::_Rb_tree_const_iterator<long\
    \ int>\u2019 to \u2018const key_type&\u2019 {aka \u2018const long int&\u2019}\n\
    \  829 |       lower_bound(const key_type& __x)\n      |                   ~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:833:7: note:\
    \ candidate: \u2018std::set<_Key, _Compare, _Alloc>::const_iterator std::set<_Key,\
    \ _Compare, _Alloc>::lower_bound(const key_type&) const [with _Key = long int;\
    \ _Compare = std::less<long int>; _Alloc = std::allocator<long int>; std::set<_Key,\
    \ _Compare, _Alloc>::const_iterator = std::_Rb_tree_const_iterator<long int>;\
    \ std::set<_Key, _Compare, _Alloc>::key_type = long int]\u2019\n  833 |      \
    \ lower_bound(const key_type& __x) const\n      |       ^~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_set.h:833:35:\
    \ note:   no known conversion for argument 1 from \u2018std:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long index = 0;\n    int max_even =\
    \ -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0)\
    \ {\n            index++;\n            if (max_even < 0 || max_even < arr[i])\
    \ {\n                max_even = arr[i];\n            }\n        } else if (max_even\
    \ == -1) {\n            index++;\n        }\n    }\n    std::vector<long> res;\n\
    \    res.push_back(max_even);\n    res.push_back(index);\n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpnf6bk40z: /tmp/tmpnf6bk40z.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.empty()) return {};\n    long smallest = *std::min_element(arr.begin(),\
    \ arr.end());\n    long index = 0;\n    long value = arr[smallest];\n    for(auto\
    \ it = std::next(arr.begin()); it != arr.end(); ++it) {\n        if(*it == value\
    \ || *it == (value + (*it < value ? 1 : 0))) {\n            index = *it - value;\n\
    \            break;\n        }\n    }\n    return {value, index};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmplr0gpzqe: /tmp/tmplr0gpzqe.cpp:43: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long min_value = 0;\n    long smallest_index = 0;\n    for(long\
    \ i=0;i<arr.size();i++){\n        if(arr[i]%2 ==0 && arr[i]>=min_value){\n   \
    \         min_value = arr[i];\n            smallest_index = i;\n        }\n  \
    \  }\n    std::vector<long> arr1;\n    for(long i=0;i<arr.size();i++){\n     \
    \   if(arr[i]%2 ==0 && arr[i]>=min_value){\n            arr1.push_back(arr[i]);\n\
    \        }\n    }\n    long min_element;\n    long min_value;\n    long min_index;\n\
    \    std::sort(arr1.begin(),arr1.end(),[&min_element,&min_value,&min_index](long\
    \ a, long b){\n        if(a < min_element){\n            min_element = a;\n  \
    \          min_value = a;\n            min_index= 0;\n        }\n        if(b<min_element){\n\
    \            min_element = b;\n            min_value = b;\n            min_index=\
    \ 1;\n        }\n        return min_element-min_value;\n    });\n    if(arr1.size()==1){\n\
    \        std::vector<long> ans;\n        ans.push_back(min_element);\n       \
    \ ans.push_back(min_index);\n        return ans;\n    }else{\n        std::vector<long>\
    \ ans;\n        ans.push_back(min_element);\n        ans.push_back(min_index);\n\
    \        return ans;\n    }\n}\nint main() {\n    auto candidate = pluck;\n  \
    \  assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp80odzj_y.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp80odzj_y.cpp:44:10: error: redeclaration of \u2018long\
    \ int min_value\u2019\n   44 |     long min_value;\n      |          ^~~~~~~~~\n\
    /tmp/tmp80odzj_y.cpp:29:10: note: \u2018long int min_value\u2019 previously declared\
    \ here\n   29 |     long min_value = 0;\n      |          ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> vec;\n  bool flag = true;\n  for (long i : arr)\
    \ {\n    if (flag) {\n      flag = false;\n      vec.push_back(i);\n    } else\
    \ {\n      long k = i;\n      for (long j : vec) {\n        if (j == i) {\n  \
    \        k++;\n        }\n      }\n      vec.push_back(k);\n    }\n  }\n  std::vector<long>\
    \ ans;\n  for (long i : vec) {\n    long ans_val = i;\n    long ans_index = 0;\n\
    \    for (long j : vec) {\n      if (j == i) {\n        if (j < ans_val) {\n \
    \         ans_val = j;\n          ans_index = j;\n        }\n      }\n    }\n\
    \    if (ans_val % 2 == 0) {\n      ans.push_back(ans_val);\n      ans.push_back(ans_index);\n\
    \    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpv3ra0roa: /tmp/tmpv3ra0roa.cpp:66: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long smallest_value = arr[0];\n \
    \   long smallest_index = arr[0];\n    for(auto i=0;i<arr.size();i++) {\n    \
    \    if(arr[i] != smallest_value && arr[i] % 2 == 0) {\n            smallest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n    }\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::set<long> evens;\n    long smalest_value = 0;\n    for (auto\
    \ const& v : arr) evens.insert(v % 2 == 0);\n    if (evens.size() == 0) return\
    \ {};\n    for (auto const& v : arr) smalest_value = std::min(smalest_value, v\
    \ % 2 == 0 ? v : v % 2 + 1);\n    std::vector<long> v;\n    for (auto const& v\
    \ : arr) if (v % 2 == 0) v.push_back(v % 2 == 0);\n    if (v.size() == 0) return\
    \ {};\n    for (auto it = v.begin(); it != v.end(); ++it) std::sort(it);\n   \
    \ std::vector<long>::iterator i = v.begin();\n    while (i != v.end()) if (*i\
    \ < (*i + 1)/2) ++i;\n    return std::move(v);\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpduky6ijy.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpduky6ijy.cpp:35:49: error: request for member \u2018push_back\u2019\
    \ in \u2018v\u2019, which is of non-class type \u2018const long int\u2019\n  \
    \ 35 |     for (auto const& v : arr) if (v % 2 == 0) v.push_back(v % 2 == 0);\n\
    \      |                                                 ^~~~~~~~~\n/tmp/tmpduky6ijy.cpp:37:64:\
    \ error: no matching function for call to \u2018sort(__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >&)\u2019\n   37 |     for (auto it = v.begin();\
    \ it != v.end(); ++it) std::sort(it);\n      |                               \
    \                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpduky6ijy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:4818:5:\
    \ note: candidate: \u2018template<class _RAIter> void std::sort(_RAIter, _RAIter)\u2019\
    \n 4818 |     sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n\
    \      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:4818:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpduky6ijy.cpp:37:64:\
    \ note:   candidate expects 2 arguments, 1 provided\n   37 |     for (auto it\
    \ = v.begin(); it != v.end(); ++it) std::sort(it);\n      |                  \
    \                                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpduky6ijy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:4848:5:\
    \ note: candidate: \u2018template<class _RAIter, class _Compare> void std::sort(_RAIter,\
    \ _RAIter, _Compare)\u2019\n 4848 |     sort(_RandomAccessIterator __first, _RandomAccessIterator\
    \ __last,\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/inclu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::sort(arr.begin(), arr.end(), std::greater<long>());\n  std::vector<long>\
    \ index;\n  std::vector<long> result;\n  // find first even value\n  // if not\
    \ even then just return the arr\n  if (arr.size() % 2 == 0) {\n    int i = 0;\n\
    \    long min_even = arr[i] % 2;\n    int size = arr.size();\n    for (; i < size;\
    \ i += 2) {\n      if (arr[i] < min_even && arr[i + 1] < min_even) {\n       \
    \ break;\n      }\n      min_even = arr[i] % 2;\n    }\n    if (i == size) {\n\
    \      return arr;\n    }\n    index = {i, i + 1};\n    return arr;\n  }\n  long\
    \ min_even = arr[0] % 2;\n  int size = arr.size();\n  for (int i = 1; i < size;\
    \ i += 2) {\n    if (arr[i] < min_even && arr[i + 1] < min_even) {\n      break;\n\
    \    }\n    min_even = arr[i] % 2;\n  }\n  if (i == size) {\n    return arr;\n\
    \  }\n  index = {i, i + 1};\n  return arr;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpgvj0dxvv.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpgvj0dxvv.cpp:58:7: error: \u2018i\u2019 was not declared\
    \ in this scope\n   58 |   if (i == size) {\n      |       ^\n/tmp/tmpgvj0dxvv.cpp:61:12:\
    \ error: \u2018i\u2019 was not declared in this scope\n   61 |   index = {i, i\
    \ + 1};\n      |            ^\n/tmp/tmpgvj0dxvv.cpp:61:20: error: no match for\
    \ \u2018operator=\u2019 (operand types are \u2018std::vector<long int>\u2019 and\
    \ \u2018<brace-enclosed initializer list>\u2019)\n   61 |   index = {i, i + 1};\n\
    \      |                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:72,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpgvj0dxvv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:198:5:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const\
    \ std::vector<_Tp, _Alloc>&) [with _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n  198 |     vector<_Tp, _Alloc>::\n      |     ^~~~~~~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:199:42: note:\
    \   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018const std::vector<long int>&\u2019\n  199 |     operator=(const\
    \ vector<_Tp, _Alloc>& __x)\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpgvj0dxvv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:706:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::vector<_Tp,\
    \ _Alloc>&&) [with _Tp = long int; _Alloc = std::allocator<long int>]\u2019\n\
    \  706 |       "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_value = INT_MIN;\n    long smallest_index = INT_MAX;\n\
    \    long value;\n\n    for (long i : arr) {\n        value = i;\n        if (value\
    \ % 2 == 0) {\n            smallest_even_value = value;\n            smallest_index\
    \ = i;\n        } else {\n            if (value < smallest_even_value) {\n   \
    \             smallest_even_value = value;\n                smallest_index = i;\n\
    \            }\n        }\n    }\n\n    std::vector<long> vec;\n    vec.push_back(smallest_even_value);\n\
    \    vec.push_back(smallest_index);\n\n    return vec;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpdbbjgnn8: /tmp/tmpdbbjgnn8.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() <= 10000);\n    assert(arr.size() == arr.at(0)\
    \ || arr.at(1) == 0);\n    std::vector<long> res;\n    res.push_back(0);\n   \
    \ long min_val = arr.at(0);\n    for (long i = 1; i < arr.size(); i++) {\n   \
    \     if (arr.at(i) % 2 == 0) {\n            if (min_val > arr.at(i)) {\n    \
    \            res.push_back(min_val);\n                res.push_back(i);\n    \
    \        }\n            min_val = arr.at(i);\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp3ko_oceb: /tmp/tmp3ko_oceb.cpp:30: std::vector<long int> pluck(std::vector<long\
    \ int>): Assertion `arr.size() == arr.at(0) || arr.at(1) == 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long temp_val = 0;\n    std::vector<long> index;\n    for (long i\
    \ = 0; i < arr.size(); i++) {\n        temp_val = arr[i];\n        if (temp_val\
    \ % 2 == 0) {\n            for (long j = 0; j < arr.size(); j++) {\n         \
    \       if (arr[j] > temp_val && arr[j] % 2 == 0) {\n                    temp_val\
    \ = arr[j];\n                    smallest_value = temp_val;\n                \
    \    smallest_index = j;\n                }\n            }\n        } else {\n\
    \            for (long j = 0; j < arr.size(); j++) {\n                if (arr[j]\
    \ > temp_val && arr[j] % 2 != 0) {\n                    temp_val = arr[j];\n \
    \                   smallest_value = temp_val;\n                    smallest_index\
    \ = j;\n                }\n            }\n        }\n        if (smallest_value\
    \ != 0) {\n            if (smallest_value == smallest_value) {\n             \
    \   index.push_back(smallest_index);\n            }\n        }\n    }\n    return\
    \ index;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpbmqilfpa: /tmp/tmpbmqilfpa.cpp:63: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    long smalest_value = 0;\n    long smalest_index = 0;\n    for (auto\
    \ iter = arr.begin();iter!=arr.end(); ++iter) {\n        if(*iter<smallest_value)\
    \ {\n            smallest_value = *iter;\n            smallest_index = iter -\
    \ arr.begin();\n        }\n        if (*iter == smallest_value){\n           \
    \ smalest_value = *iter;\n            smalest_index = iter - arr.begin();\n  \
    \      }\n    }\n\n    std::vector<long> answer;\n    answer.push_back(smalest_value);\n\
    \    answer.push_back(smalest_index);\n    return answer;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpswg63u4c: /tmp/tmpswg63u4c.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> results;\n    long smallest_even_value = std::numeric_limits<long>::max();\n\
    \    long smallest_index = 0;\n    for (size_t i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value)\
    \ {\n                smallest_even_value = arr[i];\n                smallest_index\
    \ = i;\n            }\n        } else if (arr[i] == smallest_even_value) {\n \
    \           smallest_index = i;\n        }\n    }\n    results.push_back(smallest_even_value);\n\
    \    results.push_back(smallest_index);\n    return results;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp40runapn: /tmp/tmp40runapn.cpp:50: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::vector<long>())' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    std::vector<long> result;\n    int min=INT_MAX;\n\
    \    for(auto i:arr)\n    {\n        i=i%2==0?i:(i + (i%2));\n        if(i<min)\n\
    \        {\n            result.emplace_back(i);\n            min=i;\n        }\n\
    \    }\n    if(result.size()==0)\n    {\n        result.emplace_back(0);\n   \
    \     result.emplace_back(-1);\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpcmx99ibm: /tmp/tmpcmx99ibm.cpp:50: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    int n = arr.size();\n    if (n == 0)\n  \
    \      return {};\n\n    std::map<long, int> index_map;\n\n    for (int i = 0;\
    \ i <= n; i++) {\n        int curr = arr[i];\n        if (index_map.find(curr)\
    \ == index_map.end())\n            index_map[curr] = i;\n        else if (index_map[curr]\
    \ != i) {\n            int curr = arr[index_map[curr]];\n            int smaller\
    \ = curr;\n            int smaller_index = index_map[curr];\n\n            for\
    \ (int j = i; j < n; j++) {\n                int curr = arr[j];\n            \
    \    int smaller2 = curr;\n                if (index_map.find(smaller2) == index_map.end())\
    \ {\n                    index_map[smaller2] = smaller_index;\n              \
    \      break;\n                }\n                if (smaller2 > smaller) {\n\
    \                    smaller = smaller2;\n                    smaller_index =\
    \ smaller_index;\n                }\n            }\n            index_map[smaller]\
    \ = smaller_index;\n        }\n    }\n\n    std::vector<long> smalest_value(index_map.begin(),\
    \ index_map.end());\n    std::sort(smalest_value.begin(), smalest_value.end());\n\
    \    return smalest_value;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_tempbuf.h:60,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj2ej77b3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_construct.h:\
    \ In instantiation of \u2018void std::_Construct(_T1*, _Args&& ...) [with _T1\
    \ = long int; _Args = {std::pair<const long int, int>&}]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_uninitialized.h:83:18:\
    \   required from \u2018static _ForwardIterator std::__uninitialized_copy<_TrivialValueTypes>::__uninit_copy(_InputIterator,\
    \ _InputIterator, _ForwardIterator) [with _InputIterator = std::_Rb_tree_iterator<std::pair<const\
    \ long int, int> >; _ForwardIterator = long int*; bool _TrivialValueTypes = false]\u2019\
    \n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_uninitialized.h:134:15:\
    \   required from \u2018_ForwardIterator std::uninitialized_copy(_InputIterator,\
    \ _InputIterator, _ForwardIterator) [with _InputIterator = std::_Rb_tree_iterator<std::pair<const\
    \ long int, int> >; _ForwardIterator = long int*]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_uninitialized.h:289:37:\
    \   required from \u2018_ForwardIterator std::__uninitialized_copy_a(_InputIterator,\
    \ _InputIterator, _ForwardIterator, std::allocator<_Tp>&) [with _InputIterator\
    \ = std::_Rb_tree_iterator<std::pair<const long int, int> >; _ForwardIterator\
    \ = long int*; _Tp = long int]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1582:33:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::_M_range_initialize(_ForwardIterator,\
    \ _ForwardIterator, std::forward_iterator_tag) [with _ForwardIterator = std::_Rb_tree_iterator<std::pair<const\
    \ long int, int> >; _Tp = long int; _Alloc = std::allocator<long int>]\u2019\n\
    /shared/centos7/gcc/9.2.0-skylake/i"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    auto it = std::min_element(arr.begin(),\
    \ arr.end());\n    return std::vector<long>{*it, std::distance(arr.begin(), it)};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp33pig8yh: /tmp/tmp33pig8yh.cpp:36: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\t// code here\n    long maxIndex = 0;\n    long maxValue = arr[0];\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] > maxValue) {\n\
    \            maxValue = arr[i];\n            maxIndex = i;\n        }\n    }\n\
    \    std::vector<long> out;\n    out.push_back(maxValue);\n    out.push_back(maxIndex);\n\
    \    return out;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpdxork5gy: /tmp/tmpdxork5gy.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    int length = arr.size();\n    std::vector<long>\
    \ value;\n    std::vector<long> index;\n    long smallest_value = arr[0];\n  \
    \  int smallest_index = 0;\n    for (int i = 0; i < length; i++) {\n        if\
    \ (arr[i] < smallest_value) {\n            smallest_value = arr[i];\n        \
    \    smallest_index = i;\n        } else if (arr[i] == smallest_value) {\n   \
    \         if (arr[i] % 2 == 0) {\n                index.push_back(smallest_index);\n\
    \                index.push_back(arr.size() - i - 1);\n            }\n       \
    \ }\n    }\n    return index;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpsgl8659a: /tmp/tmpsgl8659a.cpp:50: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() > 0 && arr.size() <= 10000);\n    std::vector<long>\
    \ ans;\n    // int val = 0;\n    long smallest_value = 0, smallest_index = 0;\n\
    \    // int index = 0;\n    for (long x : arr) {\n        if (x%2 == 0) {\n  \
    \          smallest_value = x;\n            smallest_index = arr.size();\n   \
    \         // std::cout << \"smallest value: \" << smallest_value << std::endl;\n\
    \            // std::cout << \"smallest index: \" << smallest_index << std::endl;\n\
    \            break;\n        }\n    }\n    ans.push_back(smallest_value);\n  \
    \  ans.push_back(smallest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp63btcerh: /tmp/tmp63btcerh.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    long smalest_val = INT_MAX;\n    long\
    \ smalest_idx = -1;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]%2==0){\n\
    \            if(smalest_val==arr[i]){\n                smalest_val=INT_MAX;\n\
    \                smalest_idx=-1;\n            }\n            else if(arr[i]<smalest_val){\n\
    \                smalest_val=arr[i];\n                smalest_idx=i;\n       \
    \     }\n        }\n    }\n    if(smalest_val==INT_MAX){\n        return ans;\n\
    \    }\n    ans.push_back(smalest_val);\n    ans.push_back(smalest_idx);\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp38va5tr7: /tmp/tmp38va5tr7.cpp:56: int main(): Assertion `candidate((std::vector<long>({5,\
    \ 0, 3, 0, 4, 2}))) == (std::vector<long>({0, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::sort(arr.begin(), arr.end(), std::greater<>());\n    long long\
    \ min_even_val = *std::min_element(arr.begin(), arr.end(), [](long long i, long\
    \ long j) {\n        return i % 2 == 0 && j % 2 == 0;\n    });\n    std::vector<long>\
    \ res(arr.size(), 0);\n    for (auto i = arr.begin(); i != arr.end(); i++) {\n\
    \        long long val_even_val = *i;\n        if (val_even_val == min_even_val)\
    \ {\n            res[val_even_val / 2] += 1;\n        } else {\n            res[val_even_val\
    \ / 2] = 1;\n        }\n    }\n    if (res.empty()) {\n        return {};\n  \
    \  } else {\n        return res;\n    }\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpuok7f6qm: /tmp/tmpuok7f6qm.cpp:50: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::sort(arr.begin(), arr.end(), [&](int a,int b){\n    return (a%2)==(b%2);\n\
    \  });\n  std::map<int, std::vector<long> > m;\n  for (auto n : arr) {\n    auto\
    \ it = m[n];\n    if (!it) it = std::vector<long>{n};\n    else it = std::min(it,\
    \ std::vector<long>{n});\n    m[n] = it;\n  }\n  std::vector<long> ans;\n  auto\
    \ it = m.begin();\n  while (it != m.end()) {\n    ans.push_back(it->second[0]);\n\
    \    it++;\n  }\n  return ans;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpexhm4w3q.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpexhm4w3q.cpp:35:9: error: no match for \u2018operator!\u2019\
    \ (operand type is \u2018std::vector<long int>\u2019)\n   35 |     if (!it) it\
    \ = std::vector<long>{n};\n      |         ^~~\n/tmp/tmpexhm4w3q.cpp:35:9: note:\
    \ candidate: \u2018operator!(bool)\u2019 <built-in>\n/tmp/tmpexhm4w3q.cpp:35:9:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018bool\u2019\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto less = [](long a, long b) { return a<b; };\n    auto greater\
    \ = [](long a, long b) { return a>b; };\n    auto equal_to = [](long a, long b)\
    \ { return a==b; };\n    std::sort(arr.begin(), arr.end(), less);\n    auto it\
    \ = std::find_if(arr.begin(), arr.end(), equal_to);\n    if (it == arr.end() )\
    \ return {};\n    auto index = std::distance(arr.begin(), it);\n    return { arr[std::distance(arr.begin(),\
    \ it)], index };\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpwi8zc_d7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >; _Predicate = pluck(std::vector<long int>)::<lambda(long int, long int)>]\u2019\
    :\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >; _Predicate\
    \ = __gnu_cxx::__ops::_Iter_pred<pluck(std::vector<long int>)::<lambda(long int,\
    \ long int)> >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_pred<pluck(std::vector<long int>)::<lambda(long\
    \ int, long int)> >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3924:28:\
    \   required from \u2018_IIter std::find_if(_IIter, _IIter, _Predicate) [with\
    \ _IIter = __gnu_cxx::__normal_iterato"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> ans;\n\tstd::set<long> indices;\n\tstd::set<long>::iterator\
    \ it;\n\tlong smallest = -1;\n\tlong smallest_index = -1;\n\tfor(std::vector<long>::iterator\
    \ i=arr.begin();i!=arr.end();++i) {\n\t\tif((*i)%2==0) {\n\t\t\tif((*i)<smallest)\
    \ {\n\t\t\t\tsmallest = (*i);\n\t\t\t\tsmallest_index = indices.begin();\n\t\t\
    \t}\n\t\t\telse {\n\t\t\t\tif((*i)>smallest) {\n\t\t\t\t\tsmallest = (*i);\n\t\
    \t\t\t\tsmallest_index = *i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindices.insert(*i);\n\t\
    \t}\n\t}\n\tif(smallest!=-1) {\n\t\tans.push_back(smallest);\n\t\tans.push_back(smallest_index);\n\
    \t}\n\treturn ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplro8k_re.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmplro8k_re.cpp:38:35: error: cannot convert \u2018std::set<long\
    \ int>::iterator\u2019 {aka \u2018std::_Rb_tree_const_iterator<long int>\u2019\
    } to \u2018long int\u2019 in assignment\n   38 |     smallest_index = indices.begin();\n\
    \      |                      ~~~~~~~~~~~~~^~\n      |                       \
    \            |\n      |                                   std::set<long int>::iterator\
    \ {aka std::_Rb_tree_const_iterator<long int>}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    int result[n + 1];\n    int smallest;\n\
    \    for (int i = 0; i < (n + 1) ; i++) {\n        result[i] = i;\n    }\n   \
    \ for (int i = 1; i < n; i++) {\n        if (arr[i] % 2 == 0) {\n            result[arr[i]]\
    \ = i;\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        if (result[i]\
    \ == -1) {\n            result[i] = 0;\n        }\n    }\n    smallest = result[0];\n\
    \    for (int i = 1; i < n; i++) {\n        if (result[i] != -1 && result[i] <\
    \ smallest) {\n            smallest = result[i];\n        }\n    }\n    for (int\
    \ i = 0; i < n; i++) {\n        if (result[i] != -1 && result[i] == smallest)\
    \ {\n            return { result[i], i };\n        }\n    }\n    return {};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmptel5hqif: /tmp/tmptel5hqif.cpp:60: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = INT_MAX, smallest_index = -1;\n    for (long\
    \ i : arr)\n        if (i % 2 == 0 && i > smallest_value)\n        {\n       \
    \     smallest_value = i;\n            smallest_index = arr.size() - i - 1;\n\
    \        }\n    std::vector<long> result;\n    if (arr.size() != 0)\n    {\n \
    \       result.emplace_back(smallest_value, smallest_index);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h:33,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/allocator.h:46,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr3vvuo6b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ext/new_allocator.h:\
    \ In instantiation of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*,\
    \ _Args&& ...) [with _Up = long int; _Args = {long int&, long int&}; _Tp = long\
    \ int]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/alloc_traits.h:482:2:\
    \   required from \u2018static void std::allocator_traits<std::allocator<_CharT>\
    \ >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&,\
    \ _Up*, _Args&& ...) [with _Up = long int; _Args = {long int&, long int&}; _Tp\
    \ = long int; std::allocator_traits<std::allocator<_CharT> >::allocator_type =\
    \ std::allocator<long int>]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:115:30:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...)\
    \ [with _Args = {long int&, long int&}; _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n/tmp/tmpr3vvuo6b.cpp:39:59:   required from here\n/shared/centos7/gcc/9.2.0-skylake/inclu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res(arr.size());\n    long min_value = 0;\n  \
    \  long idx = 0;\n    for (long i : arr) {\n        assert(i != 0);\n        if\
    \ (min_value == 0) {\n            min_value = i;\n            idx = -1;\n    \
    \    } else if (i == min_value) {\n            idx = i;\n        }\n    }\n  \
    \  if (min_value == 0) {\n        return res;\n    }\n\n    long index = min_value;\n\
    \    for (long i : arr) {\n        if (i != min_value) {\n            assert(i\
    \ != 0);\n            if (i > min_value) {\n                res[index] = min_value;\n\
    \                index = i;\n                min_value = i;\n            } else\
    \ {\n                res[index] = i;\n                index = i;\n           \
    \ }\n        }\n    }\n\n    res.push_back(min_value);\n    res.push_back(idx);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp9u_dtuv0: /tmp/tmp9u_dtuv0.cpp:66: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    int smallestEvenValue = 0, smallestIndex\
    \ = 0;\n    for (long i : arr) {\n        if (i % 2 == 0) {\n            if (smallestEvenValue\
    \ < i) {\n                smallestEvenValue = i;\n                smallestIndex\
    \ = i;\n            }\n        } else {\n            if (smallestEvenValue ==\
    \ i) {\n                if (smallestIndex != i) {\n                    smallestIndex\
    \ = i;\n                }\n            }\n        }\n    }\n    if (smallestEvenValue\
    \ != 0) {\n        result.push_back(smallestEvenValue);\n        result.push_back(smallestIndex);\n\
    \    } else {\n        result.push_back(-1);\n        result.push_back(-1);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpaukj2706: /tmp/tmpaukj2706.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // write your code here\n  long ans = 0;\n  int index = 0;\n  long\
    \ smallest_even = 0;\n  \n  for (int i = 0; i < arr.size(); i++) {\n    if(arr[i]%2==0){\n\
    \      if(arr[i]<smallest_even){\n        smallest_even = arr[i];\n        index\
    \ = i;\n      }\n      ans += arr[i]*i;\n    }\n  }\n  ans += smallest_even;\n\
    \  return std::vector<long>{ans, index};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpntl16yo4: /tmp/tmpntl16yo4.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> vs;\n    long smalest_value = arr[0];\n    int\
    \ smallest_index = 0;\n    for(long i : arr)\n    {\n        if (i == 0)\n   \
    \         smallest_index = 0;\n        else if (i == smalest_value)\n        {\n\
    \            if (smallest_index == arr.size() - 1)\n                vs.push_back(i);\n\
    \            else if (smallest_index == 0)\n                vs.push_back(i);\n\
    \        }\n        else if (i != smalest_value)\n        {\n            smallest_index++;\n\
    \        }\n        smalest_value = i;\n    }\n    if (vs.empty())\n        return\
    \ {};\n    return vs;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmplyim18_n: /tmp/tmplyim18_n.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long max_value = *std::max_element(arr.begin(), arr.end());\n  long\
    \ min_value = *std::min_element(arr.begin(), arr.end());\n\n  auto it = std::find_if(arr.begin(),\
    \ arr.end(), [&](long val) {\n    return val == min_value || val == max_value;\n\
    \  });\n\n  long min_index = 0;\n  long min_even_val = min_value;\n  if (it !=\
    \ arr.end()) {\n    min_index = *std::min_element(std::next(arr.begin()), it);\n\
    \    min_even_val = *it;\n  }\n\n  std::vector<long> result;\n  result.push_back(min_even_val);\n\
    \  result.push_back(min_index);\n\n  return result;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::map<long, std::pair<long, int> > index_to_value;\n    for (auto\
    \ i = 0; i < arr.size(); i++) {\n        index_to_value[arr[i]].first = arr[i];\n\
    \        index_to_value[arr[i]].second = i;\n    }\n\n    // initialize min_value\n\
    \    auto it = index_to_value.begin();\n    long min_value = it->first;\n    int\
    \ min_index = it->second;\n\n    std::vector<long> res;\n    std::pair<long, int>\
    \ temp;\n\n    // find the minimum value\n    it = index_to_value.find(min_value);\n\
    \    if (it != index_to_value.end()) {\n        temp = it->second;\n        min_index\
    \ = temp.second;\n        min_value = temp.first;\n    }\n    res.push_back(min_value);\n\
    \    res.push_back(min_index);\n\n    // sort the index list\n    std::sort(res.begin(),\
    \ res.end());\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0j8w0e8u.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp0j8w0e8u.cpp:38:25: error: cannot convert \u2018std::pair<long\
    \ int, int>\u2019 to \u2018int\u2019 in initialization\n   38 |     int min_index\
    \ = it->second;\n      |                     ~~~~^~~~~~\n      |             \
    \            |\n      |                         std::pair<long int, int>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int N = arr.size();\n    if (N == 0)\n        return {};\n    std::vector<std::pair<long,\
    \ int> > min_index;\n    std::pair<long, int> smallest;\n    for (int i = 0; i\
    \ < N; i++) {\n        if (arr[i] % 2 != 0)\n            continue;\n        min\
    \ = i;\n        min_index = std::make_pair(min, i);\n        for (int j = i +\
    \ 1; j < N; j++) {\n            if (arr[j] % 2 != 0)\n                continue;\n\
    \            if (arr[j] < arr[min]) {\n                min = j;\n            \
    \    min_index = std::make_pair(min, j);\n            }\n        }\n        smallest\
    \ = min_index;\n    }\n    if (smallest.first == 0)\n        return {};\n    return\
    \ std::list<long>({ smallest.second, smallest.first });\n}\nint main() {\n   \
    \ auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz3w8f5ii.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpz3w8f5ii.cpp:37:9: error: \u2018min\u2019 was not declared\
    \ in this scope; did you mean \u2018std::min\u2019?\n   37 |         min = i;\n\
    \      |         ^~~\n      |         std::min\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz3w8f5ii.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmpz3w8f5ii.cpp:47:20: error: no\
    \ match for \u2018operator=\u2019 (operand types are \u2018std::pair<long int,\
    \ int>\u2019 and \u2018std::vector<std::pair<long int, int> >\u2019)\n   47 |\
    \         smallest = min_index;\n      |                    ^~~~~~~~~\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:64,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpz3w8f5ii.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_pair.h:378:7:\
    \ note: candidate: \u2018std::pair<_T1, _T2>& std::pair<_T1, _T2>::operator=(typename\
    \ std::conditional<std::__and_<std::is_copy_assignable<_T1>, std::is_copy_assignable<_T2>\
    \ >::value, const std::pair<_T1, _T2>&, const std::__nonesuch_no_braces&>::type)\
    \ [with _T1 = long int; _T2 = int; typ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.empty())\n        return {};\n    std::vector<long> res;\n\
    \    long smalest_value = 0;\n    long min_index = LONG_MAX;\n    int min_even\
    \ = -1;\n    for(size_t i=0; i<arr.size(); i++) {\n        if(arr[i] % 2 != 0)\n\
    \            continue;\n        if(arr[i] < min_index && arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            min_even = i;\n        \
    \    min_index = arr[i];\n        } else if(arr[i] == min_index && arr[i] < smalest_value)\
    \ {\n            min_index = arr[i];\n        }\n    }\n    if(min_index == LONG_MAX)\n\
    \        return {};\n    res.push_back(smalest_value);\n    res.push_back(min_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmprgx4lrkj: /tmp/tmprgx4lrkj.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = arr[0];\n    std::vector<long> v;\n    for\
    \ (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] > smallest_value)\
    \ {\n            smallest_value = arr[i];\n            v.push_back(arr[i]);\n\
    \        }\n        if (arr[i] == smallest_value && arr[i] % 2 == 0) {\n     \
    \       v.push_back(i);\n        }\n    }\n    if (v.size() == 0) return v;\n\
    \    else return v[std::min_element(v.begin(), v.end()) - v.begin()];\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsgjyfpma.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpsgjyfpma.cpp:41:67: error: could not convert \u2018v.std::vector<long\
    \ int>::operator[](((std::vector<long int>::size_type)__gnu_cxx::operator-<long\
    \ int*, std::vector<long int> >(std::min_element<__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> > >(v.std::vector<long int>::begin(), v.std::vector<long\
    \ int>::end()), v.std::vector<long int>::begin())))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019} to \u2018std::vector<long\
    \ int>\u2019\n   41 |     else return v[std::min_element(v.begin(), v.end()) -\
    \ v.begin()];\n      |                                                       \
    \            ^\n      |                                                      \
    \             |\n      |                                                     \
    \              __gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\
    \ {aka long int}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto it = min_element(arr.begin(), arr.end());\n    auto size =\
    \ arr.size();\n    if (it == arr.end()) {\n        return {};\n    }\n    auto\
    \ curr = it;\n    std::advance(it, 2);\n    auto min_val = *curr;\n    std::vector<long>\
    \ ans;\n    ans.push_back(min_val);\n    ans.push_back(curr - arr.begin());\n\
    \    size_t ind = 0;\n    for (size_t i = 0; i < size - 1; i++) {\n        if\
    \ (arr[i] != min_val) {\n            std::advance(it, 1);\n            curr =\
    \ it;\n            ans.push_back(*curr );\n            ans.push_back(ind - i);\n\
    \            ind = i;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp12vkhjfe: /tmp/tmp12vkhjfe.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here.\n    if(arr.empty())\n        return {};\n\
    \    long min_even_val = 0;\n    long min_even_val_pos_index = 0;\n    long min_even_val_pos_index\
    \ = arr.size();\n    for (auto itr = arr.begin(); itr != arr.end(); ++itr)\n \
    \   {\n        long val = itr->value;\n        if (val % 2 == 0 && val < min_even_val)\n\
    \        {\n            min_even_val = val;\n            min_even_val_pos_index\
    \ = itr - arr.begin();\n        }\n    }\n    if (min_even_val == 0)\n       \
    \ return {};\n    return std::vector<long>{min_even_val, min_even_val_pos_index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0c94xle9.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp0c94xle9.cpp:34:10: error: redeclaration of \u2018long\
    \ int min_even_val_pos_index\u2019\n   34 |     long min_even_val_pos_index =\
    \ arr.size();\n      |          ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0c94xle9.cpp:33:10:\
    \ note: \u2018long int min_even_val_pos_index\u2019 previously declared here\n\
    \   33 |     long min_even_val_pos_index = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0c94xle9.cpp:37:25: error: request for member \u2018value\u2019 in \u2018\
    * itr.__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >::operator->()\u2019\
    , which is of non-class type \u2018long int\u2019\n   37 |         long val =\
    \ itr->value;\n      |                         ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    sort(arr.begin(), arr.end());\n    std::vector<long> res(arr.size(),\
    \ 0);\n    long smalest_value, smalest_index;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        smalest_value = i;\n        smalest_index = 0;\n        for\
    \ (int j = i + 1; j < arr.size(); j++) {\n            if (arr[j] % 2 == 0) {\n\
    \                if (smalest_value > arr[j]) {\n                    smalest_value\
    \ = arr[j];\n                    smalest_index = j;\n                }\n     \
    \       }\n        }\n        res[smalest_index] = smalest_value;\n    }\n   \
    \ return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp49i0x56h: /tmp/tmp49i0x56h.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n        long smallest_value = 0, smallest_index = -1;\n        long\
    \ min_odd_value = 0;\n        for(long n : arr){\n                if(n % 2 ==\
    \ 1) min_odd_value = n;\n                if(n<smallest_value){\n             \
    \           smallest_value = n;\n                        smallest_index = arr.find(n);\n\
    \                }\n        }\n        if(smallest_value == 0) return std::vector<long>();\n\
    \        std::vector<long> res;\n        res.push_back(smallest_value);\n    \
    \    res.push_back(smallest_index);\n        res.push_back(min_odd_value);\n \
    \       return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp97s4gdmz.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp97s4gdmz.cpp:35:46: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018find\u2019\n   35 |                   \
    \      smallest_index = arr.find(n);\n      |                                \
    \              ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    ans.reserve(arr.size());\n\n    auto\
    \ it = arr.begin();\n    long long ans = 0;\n\n    while (it != arr.end()) {\n\
    \        if (*it % 2 == 0) {\n            ans += *it;\n        }\n        ++it;\n\
    \    }\n    ans.push_back(ans);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9hzxy24c.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp9hzxy24c.cpp:33:15: error: conflicting declaration \u2018\
    long long int ans\u2019\n   33 |     long long ans = 0;\n      |             \
    \  ^~~\n/tmp/tmp9hzxy24c.cpp:29:23: note: previous declaration as \u2018std::vector<long\
    \ int> ans\u2019\n   29 |     std::vector<long> ans;\n      |                \
    \       ^~~\n/tmp/tmp9hzxy24c.cpp:37:17: error: no match for \u2018operator+=\u2019\
    \ (operand types are \u2018std::vector<long int>\u2019 and \u2018long int\u2019\
    )\n   37 |             ans += *it;\n      |             ~~~~^~~~~~\n/tmp/tmp9hzxy24c.cpp:41:22:\
    \ error: no matching function for call to \u2018std::vector<long int>::push_back(std::vector<long\
    \ int>&)\u2019\n   41 |     ans.push_back(ans);\n      |                     \
    \ ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp9hzxy24c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |\
    \       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    long smalest_value = 0;\n    int smalest_index\
    \ = -1;\n    for (auto &i : arr)\n        if (i & 1)\n            smalest_value\
    \ = i;\n        else\n        {\n            if (smalest_value == 0)\n       \
    \         smalest_index = i;\n            else\n            {\n              \
    \  if (smalest_value < i)\n                {\n                    smalest_value\
    \ = i;\n                    smalest_index = i;\n                }\n          \
    \  }\n        }\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpm2lmhhha: /tmp/tmpm2lmhhha.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    if(arr.size() == 0)\n    {\n        return {};\n\
    \    }\n    long smallest = arr[0];\n    int index = 0;\n    for(int i = 1; i\
    \ < arr.size(); i++)\n    {\n        if(arr[i] < smallest)\n        {\n      \
    \      smallest = arr[i];\n            index = i;\n        }\n    }\n    std::vector<long>\
    \ vec;\n    vec.push_back(smallest);\n    vec.push_back(index);\n    return vec;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpucepfncm: /tmp/tmpucepfncm.cpp:52: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto result = std::list<long>{};\n    std::vector<bool> visited(arr.size(),\
    \ false);\n\n    for (auto i : arr) {\n        auto node = i;\n        visited[node]\
    \ = true;\n        auto curr = result;\n        while (!visited[curr->back()]\
    \ && curr->back() != node) {\n            curr->pop_front();\n        }\n    \
    \    visited[node] = false;\n        curr->push_back(node);\n    }\n    return\
    \ std::move(result);\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptflqy6kz.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmptflqy6kz.cpp:36:29: error: base operand of \u2018->\u2019\
    \ has non-pointer type \u2018std::__cxx11::list<long int>\u2019\n   36 |     \
    \    while (!visited[curr->back()] && curr->back() != node) {\n      |       \
    \                      ^~\n/tmp/tmptflqy6kz.cpp:36:46: error: base operand of\
    \ \u2018->\u2019 has non-pointer type \u2018std::__cxx11::list<long int>\u2019\
    \n   36 |         while (!visited[curr->back()] && curr->back() != node) {\n \
    \     |                                              ^~\n/tmp/tmptflqy6kz.cpp:37:17:\
    \ error: base operand of \u2018->\u2019 has non-pointer type \u2018std::__cxx11::list<long\
    \ int>\u2019\n   37 |             curr->pop_front();\n      |                \
    \ ^~\n/tmp/tmptflqy6kz.cpp:40:13: error: base operand of \u2018->\u2019 has non-pointer\
    \ type \u2018std::__cxx11::list<long int>\u2019\n   40 |         curr->push_back(node);\n\
    \      |             ^~\n/tmp/tmptflqy6kz.cpp:42:21: error: could not convert\
    \ \u2018std::move<std::__cxx11::list<long int>&>(result)\u2019 from \u2018std::remove_reference<std::__cxx11::list<long\
    \ int>&>::type\u2019 {aka \u2018std::__cxx11::list<long int>\u2019} to \u2018\
    std::vector<long int>\u2019\n   42 |     return std::move(result);\n      |  \
    \          ~~~~~~~~~^~~~~~~~\n      |                     |\n      |         \
    \            std::remove_reference<std::__cxx11::list<long int>&>::type {aka std::__cxx11::list<long\
    \ int>}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    int n = arr.size();\n    long smalest_value\
    \ = 0;\n    int smalest_index = 0;\n    int k = n;\n    long sum = 0;\n    std::vector<long>\
    \ v;\n    while (k > 1) {\n        sum = 0;\n        for (int i = 0; i < k; i++)\
    \ {\n            sum += arr[i];\n        }\n        if (sum % 2 == 0) {\n    \
    \        smalest_value = sum / 2;\n            smalest_index = i;\n        }\n\
    \        k--;\n    }\n    for (int i = 0; i < k; i++) {\n        if (arr[i] %\
    \ 2 == 0) {\n            v.push_back(arr[i]);\n        }\n    }\n    std::vector<long>\
    \ w;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] % 2 == 0) {\n    \
    \        w.push_back(arr[i]);\n        }\n    }\n    if (v.size() > 0) {\n   \
    \     w.push_back(v[0]);\n    }\n    return w;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4eltejsi.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4eltejsi.cpp:43:29: error: \u2018i\u2019 was not declared\
    \ in this scope\n   43 |             smalest_index = i;\n      |             \
    \                ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    long counter = 0;\n    long min_val = 0;\n\
    \    int min_idx = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        counter\
    \ += arr[i];\n        if (counter % 2 != 0){\n            min_val = counter;\n\
    \            min_idx = i;\n        }\n        counter /= 2;\n    }\n    std::vector<long>\
    \ v;\n    if (min_val == 0)\n        return v;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] == 0){\n            v.push_back(arr[min_idx]);\n\
    \        }\n    }\n    long counter = 1;\n    for (long i = 0; i < arr.size();\
    \ i++){\n        counter += arr[i];\n        if (counter % 2 != 0){\n        \
    \    v.push_back(counter);\n        }\n        counter /= 2;\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm5dl4xxe.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpm5dl4xxe.cpp:49:10: error: redeclaration of \u2018long\
    \ int counter\u2019\n   49 |     long counter = 1;\n      |          ^~~~~~~\n\
    /tmp/tmpm5dl4xxe.cpp:30:10: note: \u2018long int counter\u2019 previously declared\
    \ here\n   30 |     long counter = 0;\n      |          ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.size() == 0)\n        return {};\n    std::vector<std::pair<long,\
    \ long> > min;\n    long curr = 0, ans = 0, i = 0;\n    for(i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] < curr) {\n            curr = arr[i];\n          \
    \  ans = i;\n        }\n        else if(arr[i] == curr) {\n            min.push_back(std::make_pair(arr[i],\
    \ i));\n        }\n    }\n    if(min.size() <= 1) {\n        return std::vector<long>();\n\
    \    }\n    std::vector<long> answer;\n    for(size_t i = 0; i < min.size() -\
    \ 1; i++)\n        answer.push_back(min[i].first);\n    answer.push_back(min[min.size()\
    \ - 1].first);\n    return answer;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpafmrw77b: /tmp/tmpafmrw77b.cpp:53: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    \n    int min_value = INT_MAX;\n    int\
    \ index;\n    \n    for (int i = 0; i < n; i++) {\n        if (arr[i] % 2 != 0)\
    \ {\n            min_value = std::min(min_value, arr[i]);\n            index =\
    \ i;\n        }\n    }\n    \n    std::vector<long> res;\n    res.push_back((min_value));\n\
    \    res.push_back(index);\n    \n    return res;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5o92v4f2.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5o92v4f2.cpp:36:51: error: no matching function for call\
    \ to \u2018min(int&, __gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type&)\u2019\n   36 |             min_value = std::min(min_value,\
    \ arr[i]);\n      |                                                   ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5o92v4f2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp5o92v4f2.cpp:36:51:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019})\n   36 |             min_value = std::min(min_value,\
    \ arr[i]);\n      |                                                   ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-sk"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() != 0);\n    long maxValue = arr[0];\n    long\
    \ maxIndex = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        long current\
    \ = arr[i];\n        if (current > maxValue) {\n            maxValue = current;\n\
    \            maxIndex = i;\n        } else if (current == maxValue) {\n      \
    \      maxIndex = i;\n        }\n    }\n    std::vector<long> res;\n    if (maxValue\
    \ % 2 == 0) {\n        res.push_back(maxValue);\n        res.push_back(maxIndex);\n\
    \    } else {\n        res.push_back(maxIndex + 2);\n        res.push_back(minIndex\
    \ - 2);\n    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpykwyad3v.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpykwyad3v.cpp:47:23: error: \u2018minIndex\u2019 was not\
    \ declared in this scope; did you mean \u2018maxIndex\u2019?\n   47 |        \
    \ res.push_back(minIndex - 2);\n      |                       ^~~~~~~~\n     \
    \ |                       maxIndex\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long n = 0;\n    std::vector<long>\
    \ v;\n    for (long i : arr) {\n        if (i % 2 == 0 && n != 0) {\n        \
    \    v.push_back(n);\n        }\n        n = i;\n    }\n    if (v.size() == 0)\
    \ return v;\n    long long max = 0;\n    for (long i : v) {\n        if (i > max)\
    \ max = i;\n    }\n    v.clear();\n    for (long i : arr) {\n        if (i % 2\
    \ == 0 && n != 0) {\n            if (n % 2 == 0) {\n                v.push_back(i);\n\
    \            }\n            n /= 2;\n        }\n    }\n    if (v.size() == 0)\
    \ return v;\n    long long i = 0;\n    std::vector<long> res;\n    for (; i <\
    \ v.size(); i++) {\n        if (v[i] < max) {\n            break;\n        }\n\
    \    }\n    res.push_back(v[i]);\n    res.push_back(i);\n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpz2dj_nmj: /tmp/tmpz2dj_nmj.cpp:66: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long min = arr[0];\n    long index = arr[0];\n    bool flag = false;\n\
    \    for(long i: arr) {\n        if (i % 2 == 0) {\n            if (i == min)\
    \ {\n                flag = true;\n            }\n            if (flag == true)\
    \ {\n                min = i;\n                index = i;\n            }\n   \
    \     } else {\n            if (i == min) {\n                flag = true;\n  \
    \          }\n        }\n    }\n    if (flag == true) {\n        std::vector<long>\
    \ res;\n        res.push_back(min);\n        res.push_back(index);\n        return\
    \ res;\n    }\n    return std::vector<long>();\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpuh_135kg: /tmp/tmpuh_135kg.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int size = arr.size();\n    std::sort(arr.begin(), arr.end());\n\
    \    if (size == 0) {\n        return std::vector<long>();\n    }\n    std::vector<long>\
    \ result;\n    int index = 0;\n    int size = arr.size();\n    while (size > 0)\
    \ {\n        if (arr[size] % 2 != 0) {\n            result.push_back(arr[size]);\n\
    \            index++;\n            size--;\n        } else {\n            size--;\n\
    \        }\n    }\n    result.push_back(arr[0]);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvp2e2t48.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpvp2e2t48.cpp:36:9: error: redeclaration of \u2018int size\u2019\
    \n   36 |     int size = arr.size();\n      |         ^~~~\n/tmp/tmpvp2e2t48.cpp:29:9:\
    \ note: \u2018int size\u2019 previously declared here\n   29 |     int size =\
    \ arr.size();\n      |         ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long temp;\n    result.push_back(0);\n\
    \    long idx = 0;\n    // std::sort(arr.begin(), arr.end()); // not necessary\n\
    \    for (auto i : arr){\n        if (i % 2 == 0){\n            temp = i;\n  \
    \          while (idx != result.size() && result[idx] == 0){\n               \
    \ ++idx;\n            }\n            result.push_back(temp);\n            idx\
    \ = 0;\n        }\n        else {\n            ++idx;\n        }\n    }\n    if\
    \ (result.size() == 0)\n        return result;\n    if (result.size() == 1){\n\
    \        return result[0];\n    }\n    long min_value = result[0];\n    long min_idx\
    \ = 0;\n    for (long i = 1;i < result.size();++i){\n        if (result[i] < min_value){\n\
    \            min_value = result[i];\n            min_idx = i;\n        }\n   \
    \ }\n    result.erase(result.begin() + min_idx);\n    if (min_idx != 0)\n    \
    \    result.push_back(result[0]);\n    return result;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo3ylqbil.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpo3ylqbil.cpp:50:24: error: could not convert \u2018result.std::vector<long\
    \ int>::operator[](0)\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019} to \u2018std::vector<long\
    \ int>\u2019\n   50 |         return result[0];\n      |                     \
    \   ^\n      |                        |\n      |                        __gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type {aka long int}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long min_even_val = 0, min_even_val_sofar\
    \ = 0, min_even_val_index = 0;\n    long i = 0;\n    while (i + 1 < arr.size())\
    \ {\n        if (arr[i] < arr[i + 1]) {\n            i++;\n            continue;\n\
    \        } else if (arr[i] == arr[i + 1]) {\n            i++;\n            long\
    \ a = arr[i] % 2;\n            if (a < min_even_val) {\n                min_even_val\
    \ = a;\n                min_even_val_sofar = arr[i];\n                min_even_val_index\
    \ = i;\n            } else if (a > min_even_val) {\n                min_even_val_index\
    \ = i;\n            }\n            i++;\n        } else {\n            i++;\n\
    \        }\n    }\n\n    std::vector<long> ans;\n    if (min_even_val_index !=\
    \ arr.size() - 1) {\n        ans.push_back(min_even_val);\n        ans.push_back(min_even_val_index);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpea7qed16: /tmp/tmpea7qed16.cpp:61: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0], smalest_index = 0;\n    std::map<long,\
    \ int> m; \n    for (long i: arr) { m[i] = 1; }\n    for (auto i: m) { if (i.second)\
    \ smalest_value = i.first; smalest_index = i.second; }\n    std::vector<long>\
    \ res;\n    if (arr.size() == 0 || smalest_value % 2 == 0) {\n        return res;\n\
    \    }\n    for (long i = 0; i < arr.size(); ++i) {\n        if (m.count(arr[i])\
    \ && (m[i] == 0)) {\n            auto it = m.find(arr[i]);\n            if (it\
    \ != m.end() && it->second == 1) {\n                smalest_value = arr[i];\n\
    \                smalest_index = it->second;\n            } else {\n         \
    \       res.push_back(arr[i]);\n            }\n        } else {\n            res.push_back(arr[i]);\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpdz1wtdrp: /tmp/tmpdz1wtdrp.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    std::vector<long> v;\n    std::vector<long> smallest_values;\n\
    \    for (long i : arr) {\n        if (i.to_ulong() % 2 == 0) {\n            v.push_back(i);\n\
    \        }\n        else {\n            if (v.size() != 0) {\n               \
    \ if (v.back() % 2 == 0 && v[v.size() - 1] % 2 == 0) {\n                    if\
    \ (v.size() < smallest_values.size()) {\n                        smallest_values.resize(v.size());\n\
    \                    }\n                    smallest_values.push_back(v.back());\n\
    \                }\n            }\n        }\n    }\n    if (v.size() == 0) {\n\
    \        return v;\n    }\n    if (smallest_values.size() == 0) {\n        return\
    \ v;\n    }\n    long smallest_value = *std::min_element(smallest_values.begin(),\
    \ smallest_values.end());\n    auto it = smallest_values.begin();\n    for (size_t\
    \ i = 0; i < v.size(); i++) {\n        if (v[i].to_ulong() % 2 == 0 && smallest_value\
    \ % 2 == 0) {\n            assert(v[i] <= smallest_value);\n            assert(v[v.size()\
    \ - i - 1] <= smallest_value);\n            assert(v[v.size() - i - 1] <= v[i]);\n\
    \            smallest_value = v[i];\n            it = i;\n        }\n    }\n \
    \   assert(*it % 2 == 0);\n    return v;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpvgx9csyi.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpvgx9csyi.cpp:33:15: error: request for member \u2018to_ulong\u2019\
    \ in \u2018i\u2019, which is of non-class type \u2018long int\u2019\n   33 | \
    \        if (i.to_ulong() % 2 == 0) {\n      |               ^~~~~~~~\n/tmp/tmpvgx9csyi.cpp:56:18:\
    \ error: request for member \u2018to_ulong\u2019 in \u2018v.std::vector<long int>::operator[](i)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   56 |      \
    \   if (v[i].to_ulong() % 2 == 0 && smallest_value % 2 == 0) {\n      |      \
    \            ^~~~~~~~\n/tmp/tmpvgx9csyi.cpp:61:18: error: no match for \u2018\
    operator=\u2019 (operand types are \u2018__gnu_cxx::__normal_iterator<long int*,\
    \ std::vector<long int> >\u2019 and \u2018size_t\u2019 {aka \u2018long unsigned\
    \ int\u2019})\n   61 |             it = i;\n      |                  ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvgx9csyi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:787:11:\
    \ note: candidate: \u2018constexpr __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >& __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >::operator=(const\
    \ __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >&)\u2019\n  787\
    \ |     class __normal_iterator\n      |           ^~~~~~~~~~~~~~~~~\n/shared/centos7/gcc/9"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    std::stack<long> indexStack;\n    std::stack<long>\
    \ valueStack;\n    std::vector<long> result;\n    long index = 0;\n    long value\
    \ = arr[arr.size() - 1];\n    for (auto i = arr.begin(); i != arr.end(); ++i)\
    \ {\n        if (*i & 1 == 0 && value < arr[*i]) {\n            valueStack.push(value);\n\
    \            indexStack.push(index);\n            value = arr[*i];\n         \
    \   index = *i;\n        } else if (value == arr[*i]) {\n            valueStack.push(value);\n\
    \            indexStack.push(index);\n            value = arr[*i];\n         \
    \   index = *i;\n        } else {\n            if (valueStack.empty())\n     \
    \           break;\n            else\n                value = valueStack.top();\n\
    \            index = indexStack.top();\n            valueStack.pop();\n      \
    \      indexStack.pop();\n        }\n    }\n    if (!valueStack.empty()) {\n \
    \       value = valueStack.top();\n        index = indexStack.top();\n       \
    \ valueStack.pop();\n        indexStack.pop();\n    }\n    for (auto i = arr.begin();\
    \ i != arr.end(); ++i) {\n        if (*i & 1 == 0) {\n            result.push_back(value);\n\
    \            result.push_back(index);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpccb70nuv: /tmp/tmpccb70nuv.cpp:72: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    std::map<long, int> map;\n    std::set<int> value;\n\
    \    long smalest_value = 0, smalest_index = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        if (map.find(arr[i]) == map.end()) {\n            map[arr[i]]\
    \ = 1;\n            value.insert(arr[i]);\n        } else {\n            map[arr[i]]++;\n\
    \        }\n    }\n    for (auto it = map.begin(); it != map.end(); ++it) {\n\
    \        if (it->second > 1) {\n            smalest_value = it->first;\n     \
    \       smalest_index = it->second;\n        }\n    }\n    if (smalest_value ==\
    \ 0) {\n        return {};\n    }\n    std::vector<long> v;\n    v.push_back(smalest_value);\n\
    \    v.push_back(smalest_index);\n    return v;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpcli2rgeb: /tmp/tmpcli2rgeb.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if (arr.size() <= 0) {\n        return {};\n    }\n    auto smallest\
    \ = {}, index = {};\n    for (auto i : arr) {\n        if ((i % 2) != 0) {\n \
    \           if (smallest.second == 0) {\n                smallest.first = i;\n\
    \                smallest.second = i;\n                index.first = 0;\n    \
    \            index.second = 0;\n            }\n            else {\n          \
    \      if (smallest.second > i) {\n                    smallest.second = i;\n\
    \                    index.second = i;\n                }\n            }\n   \
    \     }\n        else {\n            if (index.first > i) {\n                index.first\
    \ = i;\n                index.second = i;\n            }\n        }\n    }\n \
    \   return {smallest.second, index.first};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkggrs1sw.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkggrs1sw.cpp:32:22: error: unable to deduce \u2018std::initializer_list<auto>\u2019\
    \ from \u2018<brace-enclosed initializer list>()\u2019\n   32 |     auto smallest\
    \ = {}, index = {};\n      |                      ^\n/tmp/tmpkggrs1sw.cpp:32:22:\
    \ note:   couldn\u2019t deduce template parameter \u2018auto\u2019\n/tmp/tmpkggrs1sw.cpp:32:34:\
    \ error: unable to deduce \u2018std::initializer_list<auto>\u2019 from \u2018\
    <brace-enclosed initializer list>()\u2019\n   32 |     auto smallest = {}, index\
    \ = {};\n      |                                  ^\n/tmp/tmpkggrs1sw.cpp:32:34:\
    \ note:   couldn\u2019t deduce template parameter \u2018auto\u2019\n/tmp/tmpkggrs1sw.cpp:55:41:\
    \ error: could not convert \u2018{<expression error>, <expression error>}\u2019\
    \ from \u2018<brace-enclosed initializer list>\u2019 to \u2018std::vector<long\
    \ int>\u2019\n   55 |     return {smallest.second, index.first};\n      |    \
    \                                     ^\n      |                             \
    \            |\n      |                                         <brace-enclosed\
    \ initializer list>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    std::vector<long> ans;\n    int smalest_val\
    \ = 0, smallest_idx = -1;\n    for (int i = 0; i < n; i++) {\n        int val\
    \ = arr[i];\n        if (val % 2 == 0) {\n            if (smalest_val < val) {\n\
    \                smalest_val = val;\n                smallest_idx = i;\n     \
    \       }\n        }\n    }\n    ans.push_back(smalest_val);\n    ans.push_back(smallest_idx);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpnscdxr_s: /tmp/tmpnscdxr_s.cpp:47: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    std::priority_queue<long> st;\n    int\
    \ ans = -1;\n    for (int i = 0; i < n; i++) {\n        st.push(arr[i]);\n   \
    \ }\n\n    while (!st.empty()) {\n        long val = st.top();\n        st.pop();\n\
    \        if (val % 2 == 0) {\n            ans++;\n        }\n        else {\n\
    \            ans--;\n        }\n        st.push(val);\n    }\n    std::vector<long>\
    \ res;\n    if (ans < 0) {\n        return res;\n    }\n    res.push_back(ans);\n\
    \    st.pop();\n    while (!st.empty()) {\n        long val = st.top();\n    \
    \    res.push_back(val);\n        st.pop();\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    assert(arr.size() != 0);\n    std::vector<long>\
    \ out;\n    long smallest_value;\n    long index = 0;\n    for (long i : arr)\
    \ {\n        if ((i % 2) == 0) {\n            smallest_value = i;\n          \
    \  index = 0;\n        }\n    }\n    std::set<long> seen;\n    out.push_back(smallest_value);\n\
    \    seen.insert(smallest_value);\n    std::vector<long> smallest_values;\n  \
    \  std::vector<long> index;\n    \n    for (long i : arr) {\n        if ((i %\
    \ 2) == 0) {\n            if (!seen.count(i)) {\n                seen.insert(i);\n\
    \                out.push_back(smallest_value);\n                index.push_back(index);\n\
    \                smallest_values.push_back(smallest_value);\n                smallest_values.push_back(index);\n\
    \            } else {\n                auto it=seen.find(i);\n               \
    \ smallest_values[index[0]] = i;\n                index[index[0]] = index;\n \
    \               seen.erase(it);\n            }\n        }\n    }\n    return out;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvzn5yg8i.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpvzn5yg8i.cpp:44:23: error: conflicting declaration \u2018\
    std::vector<long int> index\u2019\n   44 |     std::vector<long> index;\n    \
    \  |                       ^~~~~\n/tmp/tmpvzn5yg8i.cpp:33:10: note: previous declaration\
    \ as \u2018long int index\u2019\n   33 |     long index = 0;\n      |        \
    \  ^~~~~\n/tmp/tmpvzn5yg8i.cpp:51:23: error: request for member \u2018push_back\u2019\
    \ in \u2018index\u2019, which is of non-class type \u2018long int\u2019\n   51\
    \ |                 index.push_back(index);\n      |                       ^~~~~~~~~\n\
    /tmp/tmpvzn5yg8i.cpp:56:40: error: invalid types \u2018long int[int]\u2019 for\
    \ array subscript\n   56 |                 smallest_values[index[0]] = i;\n  \
    \    |                                        ^\n/tmp/tmpvzn5yg8i.cpp:57:30: error:\
    \ invalid types \u2018long int[int]\u2019 for array subscript\n   57 |       \
    \          index[index[0]] = index;\n      |                              ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value=0;\n    long index = 0;\n    long smalest_value_even\
    \ = 0;\n    long smalest_index_even = 0;\n    int n = arr.size();\n    for (int\
    \ i = 0; i < n; i++){\n        if(arr[i]%2==0){\n            if(arr[i]>smalest_value_even){\n\
    \                smalest_value_even=arr[i];\n                smalest_index_even\
    \ = i;\n            }\n        }\n        else{\n            if(arr[i]>smalest_value){\n\
    \                smalest_value=arr[i];\n                index=i;\n           \
    \ }\n        }\n    }\n    \n    return {smalest_value,index};\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpse4i_e_f: /tmp/tmpse4i_e_f.cpp:53: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long min_value = arr[0];\n    long\
    \ min_index = 0;\n    for (size_t i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ < min_value) {\n            min_value = arr[i];\n            min_index = i;\n\
    \        }\n    }\n    auto itr = std::min_element(arr.begin(), arr.end(), [&](long\
    \ a, long b){return a<b;});\n    result.push_back(min_value);\n    result.push_back(min_index);\n\
    \    std::reverse(arr.begin(), itr);\n    return result;\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp14i3qwq2: /tmp/tmp14i3qwq2.cpp:47: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    assert(arr.size() != 0);\n    long\
    \ smalest_value = 0;\n    long smalest_index = 0;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        smalest_value = std::min(smalest_value, arr[i]);\n        smalest_index\
    \ = i;\n    }\n    long smalest_value2 = arr[0];\n    long smalest_index2 = 0;\n\
    \    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] > smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \         smalest_value2 = arr[i];\n            smalest_index2 = i;\n        }\n\
    \    }\n    std::vector<long> result;\n    if (smalest_value == smalest_value2)\
    \ {\n        result.push_back(smalest_value2);\n        result.push_back(smalest_index2);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpsi8a8q71: /tmp/tmpsi8a8q71.cpp:59: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smalest_val = std::numeric_limits<long>::max();\n\
    \    int smalest_idx = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0 && arr[i] < smalest_val) {\n            smalest_val =\
    \ arr[i];\n            smalest_idx = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_idx != -1) {\n        result.push_back(smalest_val);\n\
    \        result.push_back(smalest_idx);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpz2ofru04: /tmp/tmpz2ofru04.cpp:49: int main(): Assertion `candidate((std::vector<long>()))\
    \ == (std::vector<long>())' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long max_val = *std::max_element(arr.begin(), arr.end()); // finds\
    \ the highest value\n    long min_val = *std::min_element(arr.begin(), arr.end());\
    \ // finds the lowest value\n\n    long max_even_index = -1;\n    long min_even_index\
    \ = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (arr[i] < min_val) {\n                min_val = arr[i];\n\
    \                min_even_index = i;\n            }\n            else if (arr[i]\
    \ > max_val) { // this ensures that the first even value we find is always the\
    \ smallest\n                max_even_index = i;\n                max_val = arr[i];\n\
    \            }\n        }\n    }\n    if (max_even_index == -1)\n        return\
    \ std::vector<long>();\n    else\n        return { max_val, max_even_index };\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0vb38kpy: /tmp/tmp0vb38kpy.cpp:53: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value;\n    long smalest_index;\n    long curr_index;\n\
    \    for (auto it1 = arr.begin(); it1 != arr.end(); ++it1){\n        curr_index\
    \ = it1 - arr.begin();\n        if (it1 % 2 == 0){\n            smalest_value\
    \ = *it1;\n            smalest_index = curr_index;\n        }\n    }\n    if (smalest_value\
    \ == 0){\n        return std::vector<long>{};\n    }\n    std::vector<long> ans\
    \ = {smalest_value, smalest_index};\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp61cumlu7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp61cumlu7.cpp:34:17: error: no match for \u2018operator%\u2019\
    \ (operand types are \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >\u2019 and \u2018int\u2019)\n   34 |         if (it1 % 2 == 0){\n    \
    \  |             ~~~ ^ ~\n      |             |     |\n      |             | \
    \    int\n      |             __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp61cumlu7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom1, class _Dom2> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Expr, _Dom1, _Dom2>, typename std::__fun<std::__modulus, typename\
    \ _Dom1::value_type>::result_type> std::operator%(const std::_Expr<_Dom1, typename\
    \ _Dom1::value_type>&, const std::_Expr<_Dom2, typename _Dom2::value_type>&)\u2019\
    \n  409 |     _DEFINE_EXPR_BINARY_OPERATOR(%, __modulus)\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp61cumlu7.cpp:34:19:\
    \ note:   \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >\u2019 is not derived from \u2018const std::_Expr<_Dom1, typename _Dom1::value_type>\u2019\
    \n   34 |         if (it1 % 2 == 0){\n      |                   ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:603,\n   \
    \              from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp61cumlu7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/valarray_after.h:409:5:\
    \ note: candidate: \u2018template<class _Dom> std::_Expr<std::__detail::_BinClos<std::__modulus,\
    \ std::_Expr, std::_Constant, _Dom, typ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    if (n == 0) {\n        return {};\n   \
    \ }\n    int min = arr[0];\n    std::vector<long> minindexes(n);\n    long minindex\
    \ = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < min) {\n     \
    \       min = arr[i];\n            minindex = i;\n        }\n    }\n    if (minindex\
    \ < (int) (n/2))\n        minindex = (int) (n/2);\n    std::vector<long> result;\n\
    \    for (int i = 0; i < n; i++) {\n        if (arr[i] == min) {\n           \
    \ result.push_back(i);\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpt_ypcw09: /tmp/tmpt_ypcw09.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0], index_of_smallest_value = -1, smallest_value_found_at\
    \ = -1;\n    for (long &node: arr) {\n        if (smallest_value_found_at < 0\
    \ || smallest_value_found_at > node) {\n            smallest_value_found_at =\
    \ node;\n            index_of_smallest_value = -1;\n        }\n        if (node\
    \ % 2 == 0) {\n            smallest_value_found_at = node;\n            index_of_smallest_value\
    \ = node;\n        }\n        if (node < smalest_value) smalest_value = node;\n\
    \    }\n    \n    std::vector<long> output = {smalest_value, index_of_smallest_value};\n\
    \    if (index_of_smallest_value == -1) return {0L, -1L};\n    if (index_of_smallest_value\
    \ > arr.size()) return output;\n    \n    return pluck(arr[index_of_smallest_value\
    \ + 1]) + output;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_gi9ni3v.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_gi9ni3v.cpp:46:50: error: could not convert \u2018arr.std::vector<long\
    \ int>::operator[](((std::vector<long int>::size_type)(index_of_smallest_value\
    \ + 1)))\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>,\
    \ long int>::value_type\u2019 {aka \u2018long int\u2019} to \u2018std::vector<long\
    \ int>\u2019\n   46 |     return pluck(arr[index_of_smallest_value + 1]) + output;\n\
    \      |                                                  ^\n      |         \
    \                                         |\n      |                         \
    \                         __gnu_cxx::__alloc_traits<std::allocator<long int>,\
    \ long int>::value_type {aka long int}\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long max_val = 0, index = 0, smalest_val = 0, smalest_index = 0;\n\
    \    std::vector<long> ret;\n    for (auto i : arr) {\n        if ((i % 2) ==\
    \ 0) {\n            if (max_val == 0 && i == 0) {\n                return ret;\n\
    \            }\n            if (max_val < i) {\n                max_val = i;\n\
    \                smalest_val = max_val;\n                smalest_index = index;\n\
    \            }\n        }\n        else {\n            index++;\n        }\n \
    \   }\n    if (max_val == 0) {\n        return ret;\n    }\n    ret.resize(1);\n\
    \    ret[0] = smalest_val;\n    ret[1] = smalest_index;\n    return ret;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpckmlq7e8: /tmp/tmpckmlq7e8.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto it=std::min_element(arr.begin(),arr.end());\n    std::sort(arr.begin(),arr.end());\n\
    \    auto it=std::min_element(arr.begin(),arr.end());\n    auto it1=std::find(arr.begin(),arr.end(),it);\n\
    \    long smalest_value=arr[it];\n    long smalest_index=it1;\n    return std::vector<long>{smalest_value,smalest_index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl4bzz_ny.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpl4bzz_ny.cpp:31:10: error: conflicting declaration \u2018\
    auto it\u2019\n   31 |     auto it=std::min_element(arr.begin(),arr.end());\n\
    \      |          ^~\n/tmp/tmpl4bzz_ny.cpp:29:10: note: previous declaration as\
    \ \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> > it\u2019\
    \n   29 |     auto it=std::min_element(arr.begin(),arr.end());\n      |      \
    \    ^~\n/tmp/tmpl4bzz_ny.cpp:33:27: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::vector<long int>\u2019 and \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019)\n   33 |     long smalest_value=arr[it];\n\
    \      |                           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmpl4bzz_ny.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = long int;\
    \ _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::reference = long\
    \ int&; std::vector<_Tp, _Alloc>::size_type = long unsigned int]\u2019\n 1040\
    \ |       operator[](size_type __n) _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1040:28:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019 to \u2018std::vector<long int>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 1040 |       operator[](size_type __n)\
    \ _GLIBCXX_NOEXCEPT\n      |                  ~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1058:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::const_reference std::vector<_Tp,\
    \ _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) const ["
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::map<long, std::vector<long> > even;\n    std::vector<long>\
    \ evenindex;\n    // Sort the array first so we can grab the smallest even value.\n\
    \    std::sort(arr.begin(), arr.end());\n    long smalest_value = arr.front();\n\
    \    even[smalest_value] = arr;\n    // Now we find our first even value\n   \
    \ for(long i = 1; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n    \
    \        even[arr[i]].push_back(i);\n        }\n    }\n    // If our even value\
    \ is not in the map, we are done\n    if(even.find(smalest_value) == even.end())\
    \ {\n        return even;\n    }\n    // Grab the first value in the map that\
    \ matches the smallest even value\n    std::vector<long> first_match;\n    for(auto\
    \ it = even.begin(); it != even.end(); ++it) {\n        if(it->second.size() ==\
    \ 0) {\n            return even;\n        }\n        if(it->second.front() ==\
    \ smalest_value) {\n            first_match = it->second;\n        }\n    }\n\
    \    // If there is no even value that matches the smallest even value, we return\
    \ an empty vector\n    if(first_match.size() == 0) {\n        return even;\n \
    \   }\n    // Now we need to find the smallest index in the list of indices of\
    \ our first value\n    for(long i = 0; i < first_match.size(); i++) {\n      \
    \  evenindex.push_back(first_match[i]);\n    }\n    // Now we need to loop through\
    \ the map to find the smallest value\n    for(auto it = even.begin(); it != even.end();\
    \ ++it) {\n        std::vector<long> second_match;\n        for(long j = 0; j\
    \ < it->second.size(); j++) {\n            if(evenindex.front() == it->second[j])\
    \ {\n                second_match.push_back(j);\n            }\n        }\n  \
    \      even.erase(it);\n        if(second_match.size() == 0) {\n            even[smalest_value]\
    \ = it->second;\n        } else {\n            even[smalest_value].insert(second_match.begin(),\
    \ second_match.end());\n        }\n    }\n    return even;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_ys0h_u7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp_ys0h_u7.cpp:43:16: error: could not convert \u2018even\u2019\
    \ from \u2018std::map<long int, std::vector<long int> >\u2019 to \u2018std::vector<long\
    \ int>\u2019\n   43 |         return even;\n      |                ^~~~\n    \
    \  |                |\n      |                std::map<long int, std::vector<long\
    \ int> >\n/tmp/tmp_ys0h_u7.cpp:49:20: error: could not convert \u2018even\u2019\
    \ from \u2018std::map<long int, std::vector<long int> >\u2019 to \u2018std::vector<long\
    \ int>\u2019\n   49 |             return even;\n      |                    ^~~~\n\
    \      |                    |\n      |                    std::map<long int, std::vector<long\
    \ int> >\n/tmp/tmp_ys0h_u7.cpp:57:16: error: could not convert \u2018even\u2019\
    \ from \u2018std::map<long int, std::vector<long int> >\u2019 to \u2018std::vector<long\
    \ int>\u2019\n   57 |         return even;\n      |                ^~~~\n    \
    \  |                |\n      |                std::map<long int, std::vector<long\
    \ int> >\n/tmp/tmp_ys0h_u7.cpp:75:80: error: no matching function for call to\
    \ \u2018std::vector<long int>::insert(std::vector<long int>::iterator, std::vector<long\
    \ int>::iterator)\u2019\n   75 |             even[smalest_value].insert(second_match.begin(),\
    \ second_match.end());\n      |                                              \
    \                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:72,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp_ys0h_u7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:130:5:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::insert(std::vector<_Tp,\
    \ _Alloc>::const_iterator, const value_type&) [with _Tp = long int; _Alloc = std::allocator<long\
    \ int>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >; typename std::_Vector_base<_Tp, _All"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    std::vector<long> out;\n    if(arr.size()\
    \ == 0 || arr.front() % 2 == 0) {\n        out.push_back(arr.front());\n     \
    \   out.push_back(arr.size());\n        return out;\n    }\n\n    int min = std::numeric_limits<int>::max();\n\
    \    long smallest = 0;\n    int index = 0;\n    for(int i = 0; i < arr.size();\
    \ i++) {\n        if(arr[i] % 2 == 0 && arr[i] < min) {\n            min = arr[i];\n\
    \            smallest = i;\n            index = i;\n        }\n    }\n\n    out.push_back(min);\n\
    \    out.push_back(index);\n    return out;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpscot_fu5: /tmp/tmpscot_fu5.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long k = 1;\n    long min = std::numeric_limits<long>::max();\n\
    \    long min_even = std::numeric_limits<long>::max();\n    int n = arr.size();\n\
    \    long min_index = 0;\n    \n    for(int i = 0; i < n; i++) {\n        if(arr[i]\
    \ % 2 == 0) {\n            k = k * arr[i] + arr[i];\n            if(k < min) {\n\
    \                min = k;\n                min_even = arr[i];\n              \
    \  min_index = i;\n            }\n            k /= 2;\n        }\n    }\n    \n\
    \    std::vector<long> arr1 = {min_even, min_index};\n    arr1.sort();\n    return\
    \ arr1;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg9q0t0rs.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpg9q0t0rs.cpp:48:10: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018sort\u2019\n   48 |     arr1.sort();\n\
    \      |          ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value;\n    int index = arr.size() - 1;\n    int min_pos\
    \ = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (i == min_pos) {\n                smalest_value = arr[i];\n\
    \                index = i;\n            }\n            if (arr[i] < smalest_value)\
    \ {\n                smalest_value = arr[i];\n                min_pos = i;\n \
    \           }\n        }\n    }\n    std::vector<long> result;\n    if (min_pos\
    \ != arr.size() - 1) {\n        result.push_back(smalest_value);\n        result.push_back(arr[min_pos]);\n\
    \    } else {\n        result.push_back(smalest_value);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpsgufgirp: /tmp/tmpsgufgirp.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long even = *std::min_element(arr.begin(), arr.end());\n    long\
    \ i = 0;\n    while (i < arr.size() && arr[i] % 2 == 0) {\n        even = arr[i];\n\
    \        i++;\n    }\n    if (i < arr.size() && arr[i] == even) {\n        //\
    \ arr[i] is the current node\n        std::list<long> result;\n        result.push_back(arr[i]);\n\
    \        while (i + 1 < arr.size() && arr[i + 1] % 2 == 0) {\n            result.push_back(arr[i\
    \ + 1]);\n            i++;\n        }\n        if (i < arr.size() && arr[i] ==\
    \ even) {\n            // arr[i] is the current node\n            result.push_back(arr[i]);\n\
    \        }\n        std::reverse(result.begin(), result.end());\n        return\
    \ result;\n    } else {\n        return {};\n    }\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6jciq1ar.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp6jciq1ar.cpp:48:16: error: could not convert \u2018result\u2019\
    \ from \u2018std::__cxx11::list<long int>\u2019 to \u2018std::vector<long int>\u2019\
    \n   48 |         return result;\n      |                ^~~~~~\n      |     \
    \           |\n      |                std::__cxx11::list<long int>\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    int smallest = -1;\n    for (int i\
    \ = 0; i < arr.size(); i++) {\n        if (arr[i] != 0 && smallest == -1 || arr[i]\
    \ < arr[smallest]) {\n            smallest = i;\n        }\n    }\n\n    if (smallest\
    \ == -1) {\n        return {};\n    }\n\n    std::vector<long> ans;\n    ans.push_back(arr[smallest]);\n\
    \    int count = smallest;\n    for (int i = smallest + 1; i < arr.size(); i++)\
    \ {\n        if (arr[i] != 0 && arr[count] % 2 == 0) {\n            ans.push_back(arr[i]);\n\
    \            count++;\n        }\n    }\n\n    return ans;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpxxzbwsc8: /tmp/tmpxxzbwsc8.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() > 0);\n    if (arr.empty()) return {0, 0};\n \
    \   long max_val = arr[0];\n    int max_index = 0;\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] > max_val) {\n            max_val = arr[i];\n   \
    \         max_index = i;\n        }\n    }\n    return {max_val, max_index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpx4f2o7te: /tmp/tmpx4f2o7te.cpp:43: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto sorted = arr;\n    std::sort(sorted.begin(), sorted.end());\n\
    \    long value = 0;\n    for (auto i : sorted) {\n        if (i%2 == 0) {\n \
    \           value = i;\n            break;\n        }\n    }\n    if (value ==\
    \ 0) return std::vector<long>();\n    auto found = std::lower_bound(sorted.begin(),\
    \ sorted.end(), value);\n    if (found != sorted.end()) {\n        std::vector<long>\
    \ res;\n        res.push_back(value - found);\n        res.push_back(std::distance(sorted.begin(),\
    \ found));\n        return res;\n    } else {\n        return std::vector<long>();\n\
    \    }\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyd7_ijby.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpyd7_ijby.cpp:42:29: error: no match for \u2018operator-\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019)\n   42 |         res.push_back(value -\
    \ found);\n      |                       ~~~~~ ^ ~~~~~\n      |              \
    \         |       |\n      |                       |       __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\n      |                       long int\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpyd7_ijby.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:977:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ decltype ((__lhs.base() - __rhs.base())) __gnu_cxx::operator-(const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>&, const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\
    \n  977 |     operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,\n\
    \      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:977:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpyd7_ijby.cpp:42:31:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>\u2019 and \u2018long int\u2019\n   42 |         res.push_back(value\
    \ - f"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  if(arr.empty())\n    return {};\n  long smallestEven = arr[0];\n \
    \ int smallestIndex = 0;\n  for(long i : arr)\n    if(i%2==0 && i<smallestEven)\n\
    \      smallestEven = i;\n    else if(i==smallestEven)\n      smallestIndex++;\n\
    \  std::vector<long> out;\n  out.push_back(smallestEven);\n  out.push_back(smallestIndex);\n\
    \  return out;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp6w7dfpb3: /tmp/tmp6w7dfpb3.cpp:46: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    long smalest_value = INT_MIN;\n    int\
    \ smalest_index = -1;\n    for (int i = 0; i < (int) arr.size(); ++i) {\n    \
    \    ans.push_back(arr[i]);\n        if (arr[i] < smalest_value) {\n         \
    \   smalest_value = arr[i];\n            smalest_index = i;\n        }\n    }\n\
    \    if (smalest_index >= 0) {\n        return ans;\n    }\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmph5xm9y6x: /tmp/tmph5xm9y6x.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    std::vector<long> result;\n    auto min_index\
    \ = std::min_element(arr.begin(), arr.end());\n    result.push_back(min_index->second);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqsw9rgsk.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpqsw9rgsk.cpp:32:33: error: request for member \u2018second\u2019\
    \ in \u2018* min_index.__gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >::operator->()\u2019, which is of non-class type \u2018long int\u2019\n\
    \   32 |     result.push_back(min_index->second);\n      |                   \
    \              ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if(arr.empty()) return {};\n    long smallest_even_val = std::numeric_limits<long>::max();\n\
    \    std::vector<long> res;\n    std::pair<long, long> smallest_pair = std::make_pair(std::numeric_limits<long>::max(),\
    \ -1);\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0\
    \ && arr[i] <= smallest_even_val) {\n            smallest_pair = std::make_pair(arr[i],\
    \ i);\n            smallest_even_val = arr[i];\n        } else if(arr[i] % 2 ==\
    \ 0 && arr[i] > smallest_even_val && arr[i] != 0) {\n            auto it = std::lower_bound(std::begin(arr),\
    \ std::end(arr), smallest_pair);\n            res.push_back(arr[i] - 2 * arr[i]\
    \ - arr[it - arr.begin()]);\n            smallest_pair = std::make_pair(arr[i],\
    \ it - arr.begin());\n            smallest_even_val = arr[i];\n        }\n   \
    \ }\n    if(smallest_even_val == 0) {\n        res.push_back(0);\n        smallest_pair\
    \ = std::make_pair(std::numeric_limits<long>::max(), -1);\n    }\n    res.push_back(smallest_even_val);\n\
    \    res.push_back(smallest_pair.second);\n    return res;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmphswxgn5w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_less_val::operator()(_Iterator,\
    \ _Value&) const [with _Iterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >; _Value = const std::pair<long int, long int>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:979:14:\
    \   required from \u2018_ForwardIterator std::__lower_bound(_ForwardIterator,\
    \ _ForwardIterator, const _Tp&, _Compare) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >; _Tp = std::pair<long int, long int>; _Compare\
    \ = __gnu_cxx::__ops::_Iter_less_val]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:1013:32:\
    \   required from \u2018_ForwardIterator std::lower_bound(_ForwardIterator, _ForwardIterator,\
    \ const _Tp&) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long int*,\
    \ std::vector<long int> >; _Tp = std::pair<long int, long int>]\u2019\n/tmp/tmphswxgn5w.cpp:38:85:\
    \   required from here\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:65:22:\
    \ error: no match for \u2018operator<\u2019 (operand types are \u2018long int\u2019\
    \ and \u2018const std::pair<long int, long int>\u2019)\n   65 |       { return\
    \ *__it < __val; }\n      |           "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> output;\n    std::vector<int> idx;\n    int sz\
    \ = arr.size();\n    int smallest = 0;\n    long smalest_val = arr[0];\n    long\
    \ smalest_idx = arr[0];\n    for (int i = 0; i < sz; i++) {\n        if (arr[i]\
    \ > arr[smallest] && arr[i] % 2 == 0) {\n            smallest = i;\n         \
    \   smalest_val = arr[i];\n        }\n    }\n    int curr_idx = 0;\n    while\
    \ (arr[curr_idx] != arr[smallest]) {\n        if (arr[curr_idx] % 2 != 0) {\n\
    \            output.push_back(arr[curr_idx]);\n            idx.push_back(curr_idx);\n\
    \        }\n        curr_idx++;\n    }\n    output.push_back(arr[smallest]);\n\
    \    idx.push_back(curr_idx - 1);\n    return output;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp06fov3mf: /tmp/tmp06fov3mf.cpp:55: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() != 0);\n    int size = arr.size();\n    int min_val\
    \ = arr[0];\n    int index = 0;\n    int min_index = -1;\n    int max_index;\n\
    \    int max_val;\n    for (int i = 0; i < size; i++) {\n        // Check if current\
    \ element is smaller then the current minimum\n        if (arr[i] < min_val) {\n\
    \            min_val = arr[i];\n            min_index = i;\n        }\n      \
    \  // Check if current element is smaller than the current minimum\n        if\
    \ (arr[i] > max_val) {\n            max_val = arr[i];\n            max_index =\
    \ i;\n        }\n    }\n    // If there is only one node\n    if (min_index ==\
    \ -1) {\n        std::vector<long> result;\n        result.push_back(min_val);\n\
    \        return result;\n    }\n    std::vector<long> result;\n    // If there\
    \ is no even value\n    if (min_val % 2 == 0) {\n        result.push_back(min_val);\n\
    \        return result;\n    }\n    if (arr.size() == 1) {\n        // If there\
    \ is only one node, just return the node\n        std::vector<long> result;\n\
    \        result.push_back(arr[0]);\n        return result;\n    }\n    // Find\
    \ the index of the smallest even node\n    int even_index = -1;\n    for (int\
    \ i = 0; i < size; i++) {\n        // If current element is even and smaller than\
    \ the current minimum\n        if (arr[i] % 2 == 0 && arr[i] < min_val) {\n  \
    \          even_index = i;\n            min_val = arr[i];\n        }\n    }\n\
    \    if (even_index == -1) {\n        // If there is no even values, return the\
    \ smallest node\n        result.push_back(min_val);\n        return result;\n\
    \    }\n    // If there is only one node in the array\n    if (arr.size() == 1)\
    \ {\n        // If there is only one node, just return the node\n        std::vector<long>\
    \ result;\n        result.push_back(arr[even_index]);\n        return result;\n\
    \    }\n    // If there is more than one node in the array\n    int smallest_value\
    \ = arr[0];\n    // Find the index of the smallest even value\n    int even_index\
    \ = -1;\n    for (int i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0 &&\
    \ arr[i] < smallest_value) {\n            even_index = i;\n            smallest_value\
    \ = arr[i];\n        }\n    }\n    // If there is no even values, return the smallest\
    \ node\n    if (even_index == -1) {\n        result.push_back(smallest_value);\n\
    \        return result;\n    }\n    result.push_back(arr[even_index]);\n    int\
    \ next_even_index;\n    for (int i = even_index + 1; i < size; i++) {\n      \
    \  if (arr[i] % 2 == 0 && arr[i] > min_val) {\n            smallest_value = arr[i];\n\
    \            even_index = i;\n        }\n    }\n    // If there is no even values\
    \ after finding the smallest even index\n    if (even_index == -1) {\n       \
    \ result.push_back(smallest_value);\n        return result;\n    }\n    // If\
    \ there are two nodes with the smallest even value\n    if (arr.size() == 2 &&\
    \ min_val == max_val) {\n        std::vector<long> result;\n        result.push_back(arr[0]);\n\
    \        result.push_back(arr[even_index]);\n        return result;\n    }\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaxeh0hbt.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpaxeh0hbt.cpp:90:9: error: redeclaration of \u2018int even_index\u2019\
    \n   90 |     int even_index = -1;\n      |         ^~~~~~~~~~\n/tmp/tmpaxeh0hbt.cpp:67:9:\
    \ note: \u2018int even_index\u2019 previously declared here\n   67 |     int even_index\
    \ = -1;\n      |         ^~~~~~~~~~\n/tmp/tmpaxeh0hbt.cpp:122:1: warning: control\
    \ reaches end of non-void function [-Wreturn-type]\n  122 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // arr: [0, 2, 4, 2, 4, 2, 4]\n    // smalest_value: [0, 2, 4, 2,\
    \ 4, 2, 4]\n    // smalest_index: [0, 2, 4, 2, 4, 2, 4]\n    // smalest_index[i]\
    \ is the index of smallest value in smalest_value\n    \n    // smalest_value:\
    \ [0, 2, 4, 2, 4, 2, 4]\n    // smalest_index: [0, 2, 4, 2, 4, 2, 4]\n    // smalest_index[i]\
    \ is the index of smallest value in smalest_value\n    \n    // smalest_value:\
    \ [0, 2, 4, 2, 4, 2, 4]\n    // smalest_index: [0, 2, 4, 2, 4, 2, 4]\n    // smalest_index[i]\
    \ is the index of smallest value in smalest_value\n    \n    std::vector<long>\
    \ result;\n    \n    \n    if (arr.empty()) {\n        return result;\n    }\n\
    \n    // smalest_value: [0, 2, 4, 2, 4, 2, 4]\n    // smalest_index: [0, 2, 4,\
    \ 2, 4, 2, 4]\n    // smalest_index[i] is the index of smallest value in smalest_value\n\
    \    // first we sort arr\n    std::sort(arr.begin(), arr.end());\n    \n    long\
    \ smalest_value = arr.front();\n    long smalest_index = 0;\n    \n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        \n        if (arr[i] < smalest_value)\
    \ {\n            \n            smalest_value = arr[i];\n            smalest_index\
    \ = i;\n        }\n    }\n    \n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    \n    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpjbb55i0a: /tmp/tmpjbb55i0a.cpp:74: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::sort(arr.begin(), arr.end());\n    if (arr.empty())\n     \
    \   return std::vector<long>();\n    long smalest_value = arr[0];\n    int smallst_index\
    \ = -1;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\n\
    \            smalest_value = arr[i];\n        if (arr[i] != smalest_value && arr[i]\
    \ % 2 == 0) {\n            if (smallst_index == -1)\n                smallst_index\
    \ = i;\n            else\n                smalest_value = arr[i];\n        }\n\
    \    }\n    if (smallst_index != -1) {\n        std::vector<long> res;\n     \
    \   res.push_back(smalest_value);\n        res.push_back(smallst_index);\n   \
    \     return res;\n    }\n    return std::vector<long>();\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmprmq91_du: /tmp/tmprmq91_du.cpp:54: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    std::vector<long> result;\n    long\
    \ smallest_even_value = 0;\n    long smallest_value_index = -1;\n    long value_index\
    \ = 0;\n    for (long i : arr) {\n        if (i % 2 == 0) {\n            smallest_even_value\
    \ = i;\n            smallest_value_index = value_index;\n        }\n        ++value_index;\n\
    \    }\n    if (smallest_even_value) {\n        auto it = std::lower_bound(arr.begin(),\
    \ arr.end(), smallest_even_value);\n        if (it == arr.end() || it->index()\
    \ != smallest_value_index)\n            it = arr.end();\n        result.emplace_back(it->value(),\
    \ it->index());\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpq63pg_7r.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpq63pg_7r.cpp:43:36: error: request for member \u2018index\u2019\
    \ in \u2018* it.__gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >::operator->()\u2019, which is of non-class type \u2018long int\u2019\n   43\
    \ |         if (it == arr.end() || it->index() != smallest_value_index)\n    \
    \  |                                    ^~~~~\n/tmp/tmpq63pg_7r.cpp:45:33: error:\
    \ request for member \u2018value\u2019 in \u2018* it.__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >::operator->()\u2019, which is of non-class type\
    \ \u2018long int\u2019\n   45 |         result.emplace_back(it->value(), it->index());\n\
    \      |                                 ^~~~~\n/tmp/tmpq63pg_7r.cpp:45:46: error:\
    \ request for member \u2018index\u2019 in \u2018* it.__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >::operator->()\u2019, which is of non-class type\
    \ \u2018long int\u2019\n   45 |         result.emplace_back(it->value(), it->index());\n\
    \      |                                              ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long even = 0, small, smallest = 0;\n    std::vector<long> res;\n\
    \    // write your code here\n    for (auto it : arr) {\n        if (it == 0)\
    \ {\n            smallest = it;\n            small = it;\n            even = it\
    \ * 2;\n        } else if (even < it) {\n            small = it;\n           \
    \ even = it * 2;\n            smallest = it;\n        }\n    }\n    res.push_back(small);\n\
    \    res.push_back(even);\n    res.push_back(smallest);\n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpysp0j44a: /tmp/tmpysp0j44a.cpp:50: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_value = std::numeric_limits<long>::max();\n \
    \   std::vector<long> sorted_arr(arr.size());\n    for (size_t i = 0; i < arr.size();\
    \ ++i) {\n        sorted_arr[i] = arr[i];\n    }\n    std::vector<long> even_values_arr(arr.size());\n\
    \    for (size_t i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n\
    \            even_values_arr[i] = arr[i];\n        }\n    }\n    std::vector<long>\
    \ smalest_value(arr.size());\n    std::vector<std::pair<long, size_t> > even_values_indexes(arr.size());\n\
    \    std::iota(even_values_indexes.begin(), even_values_indexes.end(), 0);\n \
    \   std::vector<long> result{};\n    for (size_t i = 0; i < arr.size(); ++i) {\n\
    \        auto it = std::lower_bound(sorted_arr.begin(), sorted_arr.end(), even_values_arr[i])\
    \ - sorted_arr.begin();\n        if (it == sorted_arr.end()) {\n            continue;\n\
    \        }\n        if (it - sorted_arr.begin() == even_values_arr[i]) {\n   \
    \         smalest_value[i] = *it;\n            even_values_indexes[i] = it - sorted_arr.begin();\n\
    \            continue;\n        }\n        smalest_value[i] = *it;\n        std::advance(it,\
    \ even_values_arr[i]);\n        while (it != sorted_arr.begin()) {\n         \
    \   if (*it == even_values_arr[i]) {\n                even_values_indexes[i] =\
    \ it - sorted_arr.begin();\n                break;\n            }\n          \
    \  std::advance(it, even_values_arr[i]);\n        }\n    }\n    std::sort(smalest_value.begin(),\
    \ smalest_value.end());\n    std::sort(even_values_indexes.begin(), even_values_indexes.end());\n\
    \    result.push_back(smalest_value[0]);\n    if (smalest_value.size() > 1) {\n\
    \        for (size_t i = 1; i < smalest_value.size(); ++i) {\n            if (smalest_value[i]\
    \ == smalest_value[i - 1]) {\n                result.push_back(smalest_value[i]);\n\
    \            }\n        }\n    }\n    for (size_t i = 0; i < arr.size(); ++i)\
    \ {\n        if (even_values_indexes[i] >= even_values_indexes.size()) {\n   \
    \         break;\n        }\n        if (even_values_indexes[i] != even_values_indexes[i\
    \ + 1]) {\n            result.push_back(even_values_indexes[i]);\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp28b9wzav.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp28b9wzav.cpp:46:16: error: no match for \u2018operator==\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018std::vector<long int>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >\u2019\
    })\n   46 |         if (it == sorted_arr.end()) {\n      |             ~~ ^~ ~~~~~~~~~~~~~~~~\n\
    \      |             |                   |\n      |             long int     \
    \       std::vector<long int>::iterator {aka __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp28b9wzav.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  886 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:886:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp28b9wzav.cpp:46:34:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>\u2019 and \u2018long int\u2019\n   46 |         if (it == sort"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> index;\n  std::vector<long> even;\n  std::vector<long>\
    \ smalest_value;\n  for (long &e : arr)\n    if (e % 2 == 0)\n      even.push_back(e);\n\
    \  if (even.size() == 0)\n    return std::vector<long>();\n  else {\n    for (long\
    \ &e : even) {\n      smalest_value = std::min(smalest_value, e);\n      index.push_back(std::distance(even.begin(),\
    \ std::find(even.begin(), even.end(), e)));\n    }\n  }\n  if (smalest_value ==\
    \ arr[0])\n    return std::vector<long>();\n  else {\n    long result = smalest_value;\n\
    \    std::vector<long> ret;\n    if (index.size() > 0)\n      ret = {smalest_value,\
    \ index.back()};\n    return ret;\n  }\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkt563fe5.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkt563fe5.cpp:39:48: error: no matching function for call\
    \ to \u2018min(std::vector<long int>&, long int&)\u2019\n   39 |       smalest_value\
    \ = std::min(smalest_value, e);\n      |                                     \
    \           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpkt563fe5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpkt563fe5.cpp:39:48:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    std::vector<long int>\u2019 and \u2018long int\u2019)\n   39 |       smalest_value\
    \ = std::min(smalest_value, e);\n      |                                     \
    \           ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \ "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  // Your code here\n  int n = arr.size();\n  std::vector<long> result;\n\
    \  long smallest = INT_MIN;\n  int smallest_index = -1;\n  for (int i = 0; i <\
    \ n; i++) {\n    if (arr[i] % 2 == 0) {\n      smallest = min(smallest, arr[i]);\n\
    \      smallest_index = i;\n    }\n  }\n  result.push_back(smallest);\n  result.push_back(smallest_index);\n\
    \  return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8t57dpj0.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp8t57dpj0.cpp:36:18: error: \u2018min\u2019 was not declared\
    \ in this scope; did you mean \u2018std::min\u2019?\n   36 |       smallest =\
    \ min(smallest, arr[i]);\n      |                  ^~~\n      |              \
    \    std::min\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8t57dpj0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long result = 0, smallest = 1;\n    for (auto i : arr) {\n     \
    \   smallest = i;\n        if (i % 2 == 0) {\n            result = i;\n      \
    \      break;\n        }\n    }\n    if (result == 0 && arr.size() == 0)\n   \
    \     return {};\n    std::vector<long> results;\n    results.push_back(smallest);\n\
    \    results.push_back(arr.size());\n    return results;\n}\nint main() {\n  \
    \  auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpr3o2e16a: /tmp/tmpr3o2e16a.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> temp;\n    int largest = -1, index = 0;\n    for\
    \ (int i = 0; i < arr.size(); i++) {\n        if (arr[i] != -1) {\n          \
    \  int val = arr[i];\n            if (val > largest) {\n                largest\
    \ = val;\n                index = i;\n            } else if (arr[i] == largest)\
    \ {\n                largest = val;\n            }\n        }\n    }\n    temp.push_back(largest);\n\
    \    temp.push_back(index);\n    return temp;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmppsltgvc_: /tmp/tmppsltgvc_.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if (arr.empty())\n        return {};\n    // Write your code here.\n\
    \    auto min_index = [&](int i) -> long { return arr[i]; };\n    auto min_val\
    \ = std::min_element(arr.begin(), arr.end(), min_index);\n    auto next_val =\
    \ [&](int i) -> long { return arr[i+1]; };\n    int smalest_val = *min_val;\n\
    \    int smalest_index = *min_val;\n    for (int i = 1; i < arr.size(); i++) {\n\
    \        int next_val = next_val(i);\n        if (next_val == smalest_val) {\n\
    \            smalest_val = next_val;\n            smalest_index = i;\n       \
    \ }\n    }\n    if (smalest_val == arr[arr.size()-1])\n        return std::vector<long>{smalest_val,\
    \ smalest_index};\n    return std::vector<long>{smalest_val, smalest_index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpovi0_yin.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpovi0_yin.cpp:38:34: error: \u2018next_val\u2019 cannot\
    \ be used as a function\n   38 |         int next_val = next_val(i);\n      |\
    \                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpovi0_yin.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018constexpr bool __gnu_cxx::__ops::_Iter_comp_iter<_Compare>::operator()(_Iterator1,\
    \ _Iterator2) [with _Iterator1 = __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >; _Iterator2 = __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >; _Compare = pluck(std::vector<long int>)::<lambda(int)>]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:5589:12:\
    \   required from \u2018constexpr _ForwardIterator std::__min_element(_ForwardIterator,\
    \ _ForwardIterator, _Compare) [with _ForwardIterator = __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >; _Compare = __gnu_cxx::__ops::_Iter_comp_iter<pluck(std::vector<long\
    \ int>)::<lambda(int)> >]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:5640:43:\
    \   required from \u2018constexpr _FIter std::min_element(_FIter, _FIter, _Compare)\
    \ [with _FIter = __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >; _Com"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    if(arr.size() ==0 || arr.size()== 1){\n      \
    \  return arr;\n    }\n    long min_val = arr[0];\n    long min_idx = -1;\n  \
    \  long min_even = -1;\n    for(auto i : arr){\n        if(i%2 == 0 && i!=0){\n\
    \            if(i<min_even){\n                min_even = i;\n                min_idx\
    \ = -1;\n                min_val = i;\n            }\n        }\n        else\
    \ if(i%2!=0){\n            if(i<min_val){\n                min_val = i;\n    \
    \            min_idx = -1;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(min);\n    result.push_back(min_idx);\n    return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb1omcmu5.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpb1omcmu5.cpp:52:22: error: \u2018min\u2019 was not declared\
    \ in this scope; did you mean \u2018std::min\u2019?\n   52 |     result.push_back(min);\n\
    \      |                      ^~~\n      |                      std::min\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb1omcmu5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:3450:5:\
    \ note: \u2018std::min\u2019 declared here\n 3450 |     min(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long max_value = 0;\n    int max_index = 0;\n    for (int i = 0;\
    \ i != arr.size(); ++i) {\n        // printf(\"%ld \", arr[i]);\n        if (arr[i]\
    \ > max_value) {\n            max_value = arr[i];\n            max_index = i;\n\
    \        } else if (arr[i] == max_value) {\n            if (i != max_index) {\n\
    \                max_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ ret(2);\n    ret[0] = max_value;\n    ret[1] = max_index;\n    return ret;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpnlr2kptz: /tmp/tmpnlr2kptz.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    // return 0;\n    assert(arr.size() >= 1);\n\
    \    assert(arr.size() % 2 == 0);\n    // std::set<int> even_set;\n    std::map<long,\
    \ long> even_value;\n    for (auto &it : arr) {\n        long value = it;\n  \
    \      auto iter = even_value.find(value);\n        if (iter != even_value.end())\
    \ {\n            // find will return the existing map or a new one if the key\
    \ is not there\n            value = iter->second;\n        } else {\n        \
    \    even_value.emplace(value, it);\n        }\n    }\n    std::vector<long> result;\n\
    \    std::vector<long> new_vec;\n    for (auto &it : even_value) {\n        if\
    \ (it.second % 2 == 0) {\n            result.emplace_back(it.second);\n      \
    \  } else {\n            new_vec.emplace_back(it.second);\n        }\n    }\n\
    \    result.emplace_back(new_vec.back());\n    for (auto &it : new_vec) {\n  \
    \      result.emplace_back(it);\n    }\n    if (result.empty()) {\n        result.emplace_back();\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpyg1adca6: /tmp/tmpyg1adca6.cpp:32: std::vector<long int> pluck(std::vector<long\
    \ int>): Assertion `arr.size() % 2 == 0' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    std::vector<long> res;\n    for (auto\
    \ i : arr) {\n        auto index = res.size();\n        if (i & 1 == 0) {\n  \
    \          res.emplace_back(i, index);\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h:33,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/allocator.h:46,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb8jq33nz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ext/new_allocator.h:\
    \ In instantiation of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*,\
    \ _Args&& ...) [with _Up = long int; _Args = {long int&, long unsigned int&};\
    \ _Tp = long int]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/alloc_traits.h:482:2:\
    \   required from \u2018static void std::allocator_traits<std::allocator<_CharT>\
    \ >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&,\
    \ _Up*, _Args&& ...) [with _Up = long int; _Args = {long int&, long unsigned int&};\
    \ _Tp = long int; std::allocator_traits<std::allocator<_CharT> >::allocator_type\
    \ = std::allocator<long int>]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:115:30:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...)\
    \ [with _Args = {long int&, long unsigned int&}; _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n/tmp/tmpb8jq33nz.cpp:34:38:   required from here\n/shared/cent"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n = arr.size();\n    long smallestValue = std::numeric_limits<long>::max();\n\
    \    std::vector<long> result;\n    result.push_back(smallestValue);\n    result.push_back(-1);\n\
    \    long minIndex = -1;\n    for (auto i = 0; i < n; i++) {\n        if (arr[i]\
    \ % 2 == 0) {\n            smallestValue = std::min(smallestValue, arr[i]);\n\
    \            if (i == 0) {\n                minIndex = i;\n            }\n   \
    \     } else {\n            auto index = i;\n            while (index < n && arr[index]\
    \ % 2 == 0) {\n                index++;\n            }\n            if (index\
    \ < n) {\n                result.push_back(arr[index]);\n                minIndex\
    \ = index;\n            }\n        }\n    }\n    if (smallestValue == std::numeric_limits<long>::max())\
    \ {\n        return result;\n    }\n    if (minIndex == -1) {\n        return\
    \ result;\n    }\n    auto minIndexFound = result.begin() + minIndex;\n    result.insert(minIndexFound,\
    \ smallestValue);\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpg_5q4336: /tmp/tmpg_5q4336.cpp:64: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = INT_MIN;\n    int smalest_index = 0;\n    \n\
    \    long smalest_index1 = 0;\n    long smalest_index2 = 0;\n    \n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n            else if (arr[i] == smalest_value)\
    \ {\n                smalest_index++;\n            }\n        }\n        else\
    \ if (arr[i] == smalest_value) {\n            if (i < (arr.size()-1)) {\n    \
    \            long temp = (arr[i+1] + arr[i]);\n                if (temp % 2 ==\
    \ 0) {\n                    if (temp < smalest_value) {\n                    \
    \    smalest_value = temp;\n                        smalest_index1 = i;\n    \
    \                }\n                    else if (temp == smalest_value) {\n  \
    \                      smalest_index1++;\n                    }\n            \
    \    }\n            }\n            else if (arr.size() == 1) {\n             \
    \   smalest_index1++;\n            }\n        }\n    }\n    \n    if (smalest_index1\
    \ == arr.size()) {\n        if (smalest_index2 == arr.size()) {\n            return\
    \ std::vector<long>{smalest_value, smalest_index};\n        }\n        else {\n\
    \            return std::vector<long>{smalest_value, smalest_index};\n       \
    \ }\n    }\n    else {\n        return std::vector<long>{smalest_value, smalest_index1};\n\
    \    }\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpvnfmdhmp: /tmp/tmpvnfmdhmp.cpp:78: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long ans[2] = {0};\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        if (ans[0] == 0)\n            ans[0] = arr[i];\n        else if (arr[i]\
    \ < ans[0]) {\n            ans[0] = arr[i];\n            ans[1] = i;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n  \
    \  assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpolz2ucwl.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpolz2ucwl.cpp:38:12: error: could not convert \u2018ans\u2019\
    \ from \u2018long int [2]\u2019 to \u2018std::vector<long int>\u2019\n   38 |\
    \     return ans;\n      |            ^~~\n      |            |\n      |     \
    \       long int [2]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long smallest_value;\n  int smallest_index;\n  std::tie(smallest_value,\
    \ smallest_index) = *std::min_element(arr.begin(), arr.end());\n  std::vector<long>\
    \ result;\n  for (int i = 0; i < arr.size(); ++i) {\n    if (arr[i] % 2 == 0 &&\
    \ arr[i] != smallest_value) {\n      result.push_back(arr[i]);\n    }\n  }\n \
    \ return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpi5cd6xlr.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpi5cd6xlr.cpp:31:86: error: no match for \u2018operator=\u2019\
    \ (operand types are \u2018std::tuple<long int&, int&>\u2019 and \u2018long int\u2019\
    )\n   31 |   std::tie(smallest_value, smallest_index) = *std::min_element(arr.begin(),\
    \ arr.end());\n      |                                                       \
    \                               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:54,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:71,\n\
    \                 from /tmp/tmpi5cd6xlr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1205:7:\
    \ note: candidate: \u2018std::tuple<_T1, _T2>& std::tuple<_T1, _T2>::operator=(typename\
    \ std::conditional<__assignable<const _T1&, const _T2&>(), const std::tuple<_T1,\
    \ _T2>&, const std::__nonesuch_no_braces&>::type) [with _T1 = long int&; _T2 =\
    \ int&; typename std::conditional<__assignable<const _T1&, const _T2&>(), const\
    \ std::tuple<_T1, _T2>&, const std::__nonesuch_no_braces&>::type = const std::tuple<long\
    \ int&, int&>&]\u2019\n 1205 |       operator=(typename conditional<__assignable<const\
    \ _T1&, const _T2&>(),\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1207:45:\
    \ note:   no known conversion for argument 1 from \u2018long int\u2019 to \u2018\
    std::conditional<true, const std::tuple<long int&, int&>&, const std::__nonesuch_no_braces&>::type\u2019\
    \ {aka \u2018const std::tuple<long int&, int&>&\u2019}\n 1205 |       operator=(typename\
    \ conditional<__assignable<const _T1&, const _T2&>(),\n      |               \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n 1206 |     \
    \     const tuple&,\n      |          ~~~~~~~~~~~~~                       \n 1207\
    \ |          const __nonesuch_no_braces&>::type __in)\n      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/tuple:1215:7: note: candidate:\
    \ \u2018std::tuple<_T1, _T2>& std::tuple<_T1, _T2>::operator=(typename std::conditional"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here.\n    \n    std::set<long> vals;\n    for(auto\
    \ it=arr.begin();it!=arr.end();++it){\n        vals.insert(*it);\n    }\n    std::set<long>::iterator\
    \ it1=vals.begin();\n    std::vector<long> ans;\n    if(arr.size()==1){\n    \
    \    return arr;\n    }\n    auto it2=vals.begin();\n    long index=*it2;\n  \
    \  while(it1!=vals.end()){\n        if(index<*it1){\n            ans.push_back(index);\n\
    \            ++it2;\n        }\n        else{\n            ans.push_back(*it1);\n\
    \            ++it1;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpdwuboagr: /tmp/tmpdwuboagr.cpp:33: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value, smallest_index;\n    smallest_value = arr[arr.size()\
    \ - 1]; // Last element of the array\n    smallest_index = arr.size() - 1;\n \
    \   for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n    }\n    // std::cout << \"Smallest value: \" << smallest_value <<\
    \ \"\\n\";\n    // std::cout << \"Smallest index: \" << smallest_index << \"\\\
    n\";\n    if (smallest_value % 2 == 0) {\n        std::vector<long> returnVector\
    \ = {smallest_value, smallest_index};\n        return returnVector;\n    } else\
    \ {\n        return std::vector<long>();\n    }\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpqx4le25t: /tmp/tmpqx4le25t.cpp:50: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smallest_value = 0;\n    int index_of_smallest_value\
    \ = 0;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i] < smallest_value){\n\
    \            smallest_value = arr[i];\n            index_of_smallest_value = i;\n\
    \        }\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(index_of_smallest_value);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpbj1_n2n_: /tmp/tmpbj1_n2n_.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long max_val = INT_MIN;\n    int index = -1;\n    for (size_t i\
    \ = 0; i < arr.size(); i++)\n    {\n        if (arr[i] == 0)\n        {\n    \
    \        return {};\n        }\n        else if (arr[i] > max_val)\n        {\n\
    \            max_val = arr[i];\n            index = i;\n        }\n    }\n\n \
    \   int smalest_value = max_val;\n\n    if (smalest_value % 2 == 0)\n    {\n \
    \       std::vector<long> res;\n        std::vector<long> temp;\n        int n\
    \ = arr.size();\n        for (int i = index; i < n; ++i)\n        {\n        \
    \    if (arr[i] == 0)\n            {\n                return {};\n           \
    \ }\n            else\n            {\n                temp.push_back(arr[i]);\n\
    \            }\n        }\n\n        int index = -1;\n        int smalest_val\
    \ = INT_MIN;\n        for (int i = 1; i < n; ++i)\n        {\n            if (arr[i]\
    \ % 2 == 0)\n            {\n                if (arr[i] < smalest_val)\n      \
    \          {\n                    smalest_val = arr[i];\n                    index\
    \ = i;\n                }\n            }\n        }\n        res.push_back(smalest_val);\n\
    \        res.push_back(index);\n        return res;\n    }\n    else\n    {\n\
    \        std::vector<long> res;\n        std::vector<long> temp;\n        int\
    \ n = arr.size();\n        for (int i = index; i < n; ++i)\n        {\n      \
    \      if (arr[i] == 0)\n            {\n                return {};\n         \
    \   }\n            else\n            {\n                temp.push_back(arr[i]);\n\
    \            }\n        }\n        for (int i = index + 1; i < n; ++i)\n     \
    \   {\n            if (arr[i] % 2 == 0)\n            {\n                if (arr[i]\
    \ < smalest_val)\n                {\n                    smalest_val = arr[i];\n\
    \                    index = i;\n                }\n            }\n        }\n\
    \        res.push_back(smalest_val);\n        res.push_back(index);\n        return\
    \ res;\n    }\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzfwejt1y.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpzfwejt1y.cpp:100:30: error: \u2018smalest_val\u2019 was\
    \ not declared in this scope; did you mean \u2018smalest_value\u2019?\n  100 |\
    \                 if (arr[i] < smalest_val)\n      |                         \
    \     ^~~~~~~~~~~\n      |                              smalest_value\n/tmp/tmpzfwejt1y.cpp:107:23:\
    \ error: \u2018smalest_val\u2019 was not declared in this scope; did you mean\
    \ \u2018smalest_value\u2019?\n  107 |         res.push_back(smalest_val);\n  \
    \    |                       ^~~~~~~~~~~\n      |                       smalest_value\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = arr[0];\n    long smallest_index = 0;\n  \
    \  for (long index = 1; index < arr.size(); index++) {\n        if (arr[index]\
    \ < smallest_value) {\n            smallest_value = arr[index];\n            smallest_index\
    \ = index;\n        }\n    }\n    long counter = smallest_value;\n    while (counter\
    \ % 2 == 0) {\n        counter /= 2;\n    }\n    std::vector<long> result{counter,\
    \ smallest_index};\n    return result;\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmppcfiwf8r: /tmp/tmppcfiwf8r.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code here\n    if (arr.size() == 0){\n        return std::vector<long>();\n\
    \    }\n    long index = 0;\n    long smalest_value = 0;\n    for (auto val :\
    \ arr){\n        if (val > smalest_value) {\n            smalest_value = val;\n\
    \        }\n        if (val % 2 == 0) {\n            index = std::min(index, val);\n\
    \        }\n    }\n    std::vector<long> result;\n    for (auto val : arr){\n\
    \        if (val % 2 == 0 && val == smalest_value) {\n            result.push_back(val);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpg060kdqh: /tmp/tmpg060kdqh.cpp:53: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Your code goes here\n    std::vector<long> ans;\n    long smalest_value;\n\
    \    int index;\n    bool found = false;\n    bool found2 = false;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (found == true) {\n                if (smalest_value < arr[i]) {\n         \
    \           smalest_value = arr[i];\n                    index = i;\n        \
    \            found = true;\n                }\n            } else if (smalest_value\
    \ == arr[i]) {\n                index = i;\n                found = true;\n  \
    \          }\n        } else if (found == true) {\n            if (smalest_value\
    \ == arr[i]) {\n                found2 = true;\n                break;\n     \
    \       } else if (smalest_value < arr[i]) {\n                smalest_value =\
    \ arr[i];\n                index = i;\n                found = true;\n       \
    \     }\n        } else {\n            found = false;\n        }\n    }\n\n  \
    \  if (found2 == true) {\n        ans.push_back(smalest_value);\n        ans.push_back(index);\n\
    \    } else {\n        ans.clear();\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp9of1vjj4: /tmp/tmp9of1vjj4.cpp:71: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    if (arr.empty()) return res;\n    long\
    \ min_value = *std::min_element(arr.begin(), arr.end()) + 1;\n    auto pos = std::lower_bound(arr.begin(),\
    \ arr.end(), min_value);\n    for (long i = 0; i < arr.size(); i++) {\n      \
    \  auto val = arr[i];\n        if (val == min_value) {\n            if (i != pos)\
    \ {\n                res.push_back(val);\n            }\n            if (i ==\
    \ arr.size() - 1) {\n                res.push_back(arr[pos]);\n            }\n\
    \        } else {\n            break;\n        }\n    }\n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy7mmy46_.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpy7mmy46_.cpp:36:19: error: no match for \u2018operator!=\u2019\
    \ (operand types are \u2018long int\u2019 and \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019)\n   36 |             if (i != pos) {\n\
    \      |                 ~ ^~ ~~~\n      |                 |    |\n      |   \
    \              |    __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >\n      |                 long int\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy7mmy46_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  900 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpy7mmy46_.cpp:36:22:\
    \ note:   mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL,\
    \ _Container>\u2019 and \u2018long int\u2019\n   36 |             if (i != pos)\
    \ {\n      |                      ^~~\nIn file included from /shared/centos7/gcc/9.2.0-"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long largest = 0;\n    std::vector<long> ret;\n    for (auto i :\
    \ arr) {\n        if (i % 2 == 0 && i != 0)\n            largest = i;\n    }\n\
    \    for (auto i : arr) {\n        if (i != 0 && i != largest && i % 2 == 0) {\n\
    \            ret.push_back(i);\n        }\n    }\n    if (ret.empty())\n     \
    \   return ret;\n    else if (ret.size() == 1)\n        return ret;\n    else\
    \ {\n        long smallest = ret[0];\n        long index = 1;\n        for (auto\
    \ i : ret) {\n            if (i == smallest && i != 0)\n                index\
    \ = i;\n        }\n        std::vector<long> ret2;\n        ret2.push_back(smallest);\n\
    \        ret2.push_back(index);\n        return ret2;\n    }\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpirttcbko: /tmp/tmpirttcbko.cpp:59: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long sum = 0;\n    long sum2 = 0;\n\
    \    long index = 0;\n    int size = arr.size();\n    for (int i = 0; i < size;\
    \ i++) {\n        if (i % 2 == 0) {\n            sum += arr[i];\n            sum2\
    \ += arr[i];\n            index++;\n        }\n    }\n    int ans = sum2 % 2;\n\
    \    std::vector<long> anss;\n    anss.push_back(sum);\n    anss.push_back(index);\n\
    \    return anss;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp7g99m_g5: /tmp/tmp7g99m_g5.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value = 0;\n    long smallest_index = 0;\n    // using\
    \ std::min_element to find smallest element\n    auto minit = std::min_element(std::begin(arr),\
    \ std::end(arr));\n    // using std::distance to find index of smallest element\n\
    \    smallest_index = std::distance(std::begin(arr), minit);\n    // using std::all_of\
    \ to find if smallest even value\n    // return smallest element if smallest even\
    \ value found\n    if (std::all_of(std::begin(arr), std::end(arr), [&smallest_value,\
    \ &smallest_index](long value){\n        return smallest_value % 2 == value %\
    \ 2;\n    }))\n    {\n        smallest_value = *minit;\n    }\n    // return smallest\
    \ element with smallest index\n    return {smallest_value, smallest_index};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpl6bgepzn: /tmp/tmpl6bgepzn.cpp:48: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> result;\n  if (arr.size() == 0) return result;\n\
    \  long smalest_value = arr[0];\n  long smalest_index = 0;\n  for (long i = 1;\
    \ i < arr.size(); i++) {\n    if (arr[i] <= smalest_value) {\n      smalest_value\
    \ = arr[i];\n      smalest_index = i;\n    }\n  }\n  if (smalest_value % 2 ==\
    \ 0) {\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \  } else {\n    std::vector<long> result;\n    for (auto ele : arr) {\n     \
    \ if (ele > smalest_value) {\n        result.push_back(ele);\n      }\n    }\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp3nc92ed6: /tmp/tmp3nc92ed6.cpp:55: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::set<long> indices;\n  for (long i: arr)\n  {\n    if (indices.find(i)\
    \ == indices.end())\n    {\n      indices.insert(i);\n    }\n  }\n  std::vector<long>\
    \ result;\n  if (indices.empty())\n  {\n    result.clear();\n  }\n  else\n  {\n\
    \    result.push_back(std::min(*std::min_element(indices.begin(), indices.end()),\
    \ *std::max_element(indices.begin(), indices.end())));\n    std::for_each(indices.begin(),\
    \ indices.end(), [&](long i) { result.push_back(i); });\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpyfro7agb: /tmp/tmpyfro7agb.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long smalest_index\
    \ = 0;\n    long smalest_index2 = 0;\n    long smallest_index = 0;\n    for(long\
    \ i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 == 0) {\n            if(smalest_index\
    \ == 0){\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            }\n            else if(arr[i] < smalest_value) {\n       \
    \         smalest_value = arr[i];\n                smalest_index = i;\n      \
    \      }\n            else if(arr[i] == smalest_value){\n                if(smalest_index\
    \ != 0){\n                    if(arr[i] < smalest_value){\n                  \
    \      smalest_value = arr[i];\n                        smalest_index = i;\n \
    \                   }\n                    else {\n                        smalest_value\
    \ = arr[i];\n                        smalest_index2 = i;\n                   \
    \ }\n                }\n                else {\n                    smalest_value\
    \ = arr[i];\n                    smalest_index2 = i;\n                }\n    \
    \        }\n        }\n        else{\n            if(arr[i] < smalest_value) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n            else if(arr[i] == smalest_value){\n              \
    \  if(smalest_index != 0){\n                    if(arr[i] < smalest_value){\n\
    \                        smalest_value = arr[i];\n                        smalest_index\
    \ = i;\n                    }\n                    else {\n                  \
    \      smalest_value = arr[i];\n                        smalest_index2 = i;\n\
    \                    }\n                }\n                else {\n          \
    \          smalest_value = arr[i];\n                    smalest_index2 = i;\n\
    \                }\n            }\n        }\n    }\n    if(smalest_index2 ==\
    \ 0){\n        if(smalest_index == 0){\n            smallest_index = 0;\n    \
    \    }\n        else if(arr[0] < smalest_value) {\n            smallest_index\
    \ = 0;\n        }\n        else if(smalest_value == arr[0]){\n            smallest_index\
    \ = 0;\n        }\n        else{\n            smallest_index = 1;\n        }\n\
    \    }\n    else {\n        if(smalest_index2 == arr.size() - 1) {\n         \
    \   smallest_index = 1;\n        }\n        else if(smalest_index2 == 0) {\n \
    \           smallest_index = 0;\n        }\n        else if(arr[0] < smalest_value)\
    \ {\n            smallest_index = 0;\n        }\n        else if(smalest_value\
    \ == arr[0]){\n            smallest_index = 0;\n        }\n        else{\n   \
    \         smallest_index = 1;\n        }\n    }\n    long sum = 0;\n    long count\
    \ = 0;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] < smalest_value)\
    \ {\n\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxwl6nf28.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpxwl6nf28.cpp:121:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n  121 | int main() {\n      |     \
    \       ^\n/tmp/tmpxwl6nf28.cpp:131:1: error: expected \u2018}\u2019 at end of\
    \ input\n  131 | }\n      | ^\n/tmp/tmpxwl6nf28.cpp:117:42: note: to match this\
    \ \u2018{\u2019\n  117 |     for(long i = 0; i < arr.size(); i++) {\n      | \
    \                                         ^\n/tmp/tmpxwl6nf28.cpp:131:1: error:\
    \ expected \u2018}\u2019 at end of input\n  131 | }\n      | ^\n/tmp/tmpxwl6nf28.cpp:28:48:\
    \ note: to match this \u2018{\u2019\n   28 | std::vector<long> pluck(std::vector<long>\
    \ arr) {\n      |                                                ^\n/tmp/tmpxwl6nf28.cpp:131:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  131 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tassert(arr.size() != 0);\n\t\n\tint mid = arr.size() / 2;\n\t\n\t\
    // Sort the array\n\tstd::sort(arr.begin(), arr.end(), [&](long a, long b){\n\t\
    \treturn a > b;\n\t});\n\t\n\tint even = 0;\n\t\n\t// Search the array for even\
    \ elements\n\tfor (int i = 0; i < mid; i++){\n\t\tif (arr[i] == 0){\n\t\t\teven++;\n\
    \t\t}\n\t}\n\t\n\t// Choose the smallest even element\n\tint smallest_even = even;\n\
    \tfor (int i = mid; i < arr.size(); i++){\n\t\tif (arr[i] == 0){\n\t\t\tsmallest_even\
    \ += 2;\n\t\t}\n\t}\n\t\n\tlong index = smallest_even - (even - 1);\n\t\n\t//\
    \ Now search backwards\n\twhile (index >= 0){\n\t\tarr.push_back(arr[index]);\n\
    \t\tindex--;\n\t}\n\t\n\treturn arr;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmprgzkei00: /tmp/tmprgzkei00.cpp:67: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int size = arr.size();\n    std::map<int, int> m;\n    for (int\
    \ i = 0; i < size; ++i)\n        m[arr[i]]++;\n    std::vector<std::pair<long,\
    \ int> > v;\n    for (auto& p : m) {\n        if (p.second == 1)\n           \
    \ v.push_back(std::make_pair(p.first, p.first));\n    }\n    if (v.empty())\n\
    \        return {};\n    v.sort([](const std::pair<long, int> &x, const std::pair<long,\
    \ int> &y){\n        return x.first > y.first;\n    });\n    return std::vector<long>{v.front().first};\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppmgv2geu.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppmgv2geu.cpp:40:7: error: \u2018class std::vector<std::pair<long\
    \ int, int> >\u2019 has no member named \u2018sort\u2019\n   40 |     v.sort([](const\
    \ std::pair<long, int> &x, const std::pair<long, int> &y){\n      |       ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::sort(arr.begin(), arr.end());\n  std::reverse(arr.begin(), arr.end());\n\
    \  auto it = std::upper_bound(arr.begin(), arr.end(), 0);\n  long index = 0;\n\
    \  if (it != arr.begin()) {\n    index = std::distance(arr.begin(), it);\n  }\n\
    \  assert(it != arr.begin());\n  long smalest_value = *std::next(arr.begin(),\
    \ index);\n  std::vector<long> index;\n  while (it != arr.end()) {\n    long value\
    \ = *it;\n    if (value % 2 == 0) {\n      if (value < smalest_value) {\n    \
    \    smalest_value = value;\n      }\n      index.push_back((it - arr.begin())\
    \ % arr.size());\n    }\n    ++it;\n  }\n  if (smalest_value == 0) {\n    return\
    \ {};\n  }\n  return {smalest_value, index};\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4r0chnul.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4r0chnul.cpp:38:21: error: conflicting declaration \u2018\
    std::vector<long int> index\u2019\n   38 |   std::vector<long> index;\n      |\
    \                     ^~~~~\n/tmp/tmp4r0chnul.cpp:32:8: note: previous declaration\
    \ as \u2018long int index\u2019\n   32 |   long index = 0;\n      |        ^~~~~\n\
    /tmp/tmp4r0chnul.cpp:45:13: error: request for member \u2018push_back\u2019 in\
    \ \u2018index\u2019, which is of non-class type \u2018long int\u2019\n   45 |\
    \       index.push_back((it - arr.begin()) % arr.size());\n      |           \
    \  ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long smalest_value = *std::min_element(arr.cbegin(), arr.cend());\n\
    \  std::pair<long, int> smallest_index(smalest_value, 0); \n  std::vector<long>\
    \ ret;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i] < smalest_value\
    \ && arr[i] % 2 == 0) {\n      smalest_value = arr[i];\n      smallest_index =\
    \ std::make_pair(smalest_value, i);\n    }\n  }\n  if (smallest_index.second ==\
    \ arr.size()) {\n    return ret;\n  } else {\n    std::swap(smallest_index.second,\
    \ smallest_index.second+1);\n    ret.emplace_back(smallest_index.first);\n   \
    \ ret.emplace_back(smallest_index.second);\n    return ret;\n  }\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx2z1169k.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpx2z1169k.cpp:41:61: error: no matching function for call\
    \ to \u2018swap(int&, int)\u2019\n   41 |     std::swap(smallest_index.second,\
    \ smallest_index.second+1);\n      |                                         \
    \                    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpx2z1169k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/move.h:182:5:\
    \ note: candidate: \u2018typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp>\
    \ >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type\
    \ std::swap(_Tp&, _Tp&) [with _Tp = int; typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp>\
    \ >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type\
    \ = void]\u2019 <near match>\n  182 |     swap(_Tp& __a, _Tp& __b)\n      |  \
    \   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/move.h:182:5:\
    \ note:   conversion of argument 2 would be ill-formed:\n/tmp/tmpx2z1169k.cpp:41:59:\
    \ error: cannot bind non-const lvalue reference of type \u2018int&\u2019 to an\
    \ rvalue of type \u2018int\u2019\n   41 |     std::swap(smallest_index.second,\
    \ smallest_index.second+1);\n      |                                      ~~~~~~~~~~~~~~~~~~~~~^~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/includ"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long result = 0;\n    std::vector<long>\
    \ result;\n    for (long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2\
    \ == 0) {\n            result += arr[i];\n            result.push_back(i);\n \
    \       }\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5534o9yz.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5534o9yz.cpp:31:23: error: conflicting declaration \u2018\
    std::vector<long int> result\u2019\n   31 |     std::vector<long> result;\n  \
    \    |                       ^~~~~~\n/tmp/tmp5534o9yz.cpp:30:10: note: previous\
    \ declaration as \u2018long int result\u2019\n   30 |     long result = 0;\n \
    \     |          ^~~~~~\n/tmp/tmp5534o9yz.cpp:35:20: error: request for member\
    \ \u2018push_back\u2019 in \u2018result\u2019, which is of non-class type \u2018\
    long int\u2019\n   35 |             result.push_back(i);\n      |            \
    \        ^~~~~~~~~\n/tmp/tmp5534o9yz.cpp:38:12: error: could not convert \u2018\
    result\u2019 from \u2018long int\u2019 to \u2018std::vector<long int>\u2019\n\
    \   38 |     return result;\n      |            ^~~~~~\n      |            |\n\
    \      |            long int\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_val = *std::min_element(arr.begin(), arr.end());\n\
    \    int smallest_index = 0;\n    std::vector<long> smallest_even_val_index;\n\
    \    for (auto val : arr)\n    {\n        if (val % 2 == 0 && val < smallest_even_val)\n\
    \        {\n            smallest_even_val = val;\n            smallest_index++;\n\
    \        }\n        else if (val % 2 == 0 && val == smallest_even_val)\n     \
    \   {\n            smallest_even_val_index.push_back(val);\n        }\n    }\n\
    \n    if (smallest_even_val_index.size() <= 0)\n    {\n        return {};\n  \
    \  }\n\n    long picked_even_val = smallest_even_val;\n    long picked_index =\
    \ smallest_index;\n\n    int index_of_picked_val = picked_index;\n\n    for (auto\
    \ val : arr)\n    {\n        if (val % 2 == 0)\n        {\n            if (val\
    \ < picked_even_val)\n            {\n                picked_even_val = val;\n\
    \                picked_index = index_of_picked_val;\n                index_of_picked_val++;\n\
    \            }\n        }\n    }\n\n    return { picked_even_val, picked_index\
    \ };\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpr6a7771d: /tmp/tmpr6a7771d.cpp:72: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if (arr.empty()) return {};\n    std::unordered_map<long, long>\
    \ umap;\n    for (long i = 0; i < arr.size(); i++) {\n        umap[arr[i]] = i;\n\
    \    }\n    long smallest = 0;\n    long smalest_value = 0;\n    for (auto it\
    \ = umap.begin(); it != umap.end(); ++it) {\n        if (it->second < smallest)\
    \ {\n            smallest = it->second;\n            smalest_value = it->first;\n\
    \        }\n    }\n    std::vector<long> ret;\n    ret.push_back(smalest_value);\n\
    \    for (auto it = umap.begin(); it != umap.end(); ++it) {\n        if (it->second\
    \ == smallest) {\n            ret.push_back(it->first);\n        }\n    }\n  \
    \  return ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpgw6r_sb0: /tmp/tmpgw6r_sb0.cpp:53: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long min_even_val = *std::min_element(arr.begin(), arr.end());\n\
    \    std::vector<long> index;\n    for (auto &it : arr) {\n        if (it == min_even_val)\n\
    \            index.push_back(std::distance(arr.begin(), it));\n    }\n    return\
    \ index;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1j265qku.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp1j265qku.cpp:33:58: error: no matching function for call\
    \ to \u2018distance(std::vector<long int>::iterator, long int&)\u2019\n   33 |\
    \             index.push_back(std::distance(arr.begin(), it));\n      |      \
    \                                                    ^\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:66,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp1j265qku.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note: candidate: \u2018template<class _InputIterator> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::distance(_InputIterator, _InputIterator)\u2019\n  138 |     distance(_InputIterator\
    \ __first, _InputIterator __last)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator_base_funcs.h:138:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp1j265qku.cpp:33:58:\
    \ note:   deduced conflicting types for parameter \u2018_InputIterator\u2019 (\u2018\
    __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >\u2019 and \u2018\
    long int\u2019)\n   33 |             index.push_back(std::distance(arr.begin(),\
    \ it));\n      |                                                          ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    std::vector<long> index;\n    std::map<long,\
    \ std::vector<long>> s;\n    for(long i = 0; i < arr.size(); i++){\n        auto\
    \ it = s.find(arr[i]);\n        if(it != s.end()){\n            it->second.push_back(i);\n\
    \        }else{\n            std::vector<long> v;\n            v.push_back(i);\n\
    \            s.insert(std::pair<long, std::vector<long>>(arr[i], v));\n      \
    \  }\n    }\n    std::vector<long> smalest_value;\n    for(auto it = s.begin();\
    \ it != s.end(); it++){\n        if(smalest_value.empty() || smalest_value[0]\
    \ > it->first){\n            smalest_value = it->second;\n        }\n    }\n \
    \   if(smalest_value.empty()){\n        return index;\n    }else{\n        auto\
    \ it = smalest_value.begin();\n        index.push_back(it->first);\n        while(it\
    \ != smalest_value.end()){\n            it++;\n            index.push_back(it->first);\n\
    \        }\n        return index;\n    }\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptjt8g8s7.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmptjt8g8s7.cpp:52:29: error: request for member \u2018first\u2019\
    \ in \u2018* it.__gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >::operator->()\u2019, which is of non-class type \u2018long int\u2019\n   52\
    \ |         index.push_back(it->first);\n      |                             ^~~~~\n\
    /tmp/tmptjt8g8s7.cpp:55:33: error: request for member \u2018first\u2019 in \u2018\
    * it.__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >::operator->()\u2019\
    , which is of non-class type \u2018long int\u2019\n   55 |             index.push_back(it->first);\n\
    \      |                                 ^~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long even_values[10000];\n    // \"i\" is used to find the smallest\
    \ even value.\n    long i = 0;\n    // \"smallest_val\" is used to store the smallest\
    \ even value found.\n    long smallest_val = 0;\n    // \"j\" is used to store\
    \ the smallest index and \"k\" is used to store\n    // all the indexes of even\
    \ values.\n    long j = 0, k = 0;\n    for(long i = 0; i < arr.size(); i++) {\n\
    \        // \"i\" keeps track of all the even values stored in the array\n   \
    \     even_values[k] = arr[i];\n        k++;\n    }\n    for(k = 0; k < 10000;\
    \ k++){\n        if(even_values[k] % 2 == 0){\n            // \"k\" stores the\
    \ smallest even value.\n            smallest_val = even_values[k];\n         \
    \   // \"i\" stores the smallest index which has the smallest even value.\n  \
    \          i = k;\n        }\n    }\n    // \"i\" is used to store the smallest\
    \ even value.\n    i = smallest_val;\n    std::vector<long> ans;\n    while(i\
    \ != 0){\n        ans.push_back(i);\n        i /= 2;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp_uwetqxi: /tmp/tmp_uwetqxi.cpp:61: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::priority_queue<long, std::vector<long>, greater<>> minHeap;\n\
    \    for (long value : arr) {\n        minHeap.push(value);\n    }\n\n    if (minHeap.size()\
    \ == 0)\n        return {};\n\n    std::vector<long> ans;\n    long value = minHeap.top();\n\
    \    minHeap.pop();\n    ans.push_back(value);\n    while (!minHeap.empty()) {\n\
    \        value = minHeap.top();\n        minHeap.pop();\n        for (long i :\
    \ arr) {\n            if (i % 2 == 0) {\n                if (value < i)\n    \
    \                ans.push_back(value);\n                minHeap.push(i);\n   \
    \             break;\n            }\n        }\n    }\n\n    return ans;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq0abq_q3.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpq0abq_q3.cpp:29:50: error: \u2018greater\u2019 was not\
    \ declared in this scope; did you mean \u2018std::greater\u2019?\n   29 |    \
    \ std::priority_queue<long, std::vector<long>, greater<>> minHeap;\n      |  \
    \                                                ^~~~~~~\n      |            \
    \                                      std::greater\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:48,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpq0abq_q3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_function.h:337:12:\
    \ note: \u2018std::greater\u2019 declared here\n  337 |     struct greater;\n\
    \      |            ^~~~~~~\n/tmp/tmpq0abq_q3.cpp:29:57: error: template argument\
    \ 3 is invalid\n   29 |     std::priority_queue<long, std::vector<long>, greater<>>\
    \ minHeap;\n      |                                                         ^\n\
    /tmp/tmpq0abq_q3.cpp:29:58: error: expected unqualified-id before \u2018>\u2019\
    \ token\n   29 |     std::priority_queue<long, std::vector<long>, greater<>> minHeap;\n\
    \      |                                                          ^~\n/tmp/tmpq0abq_q3.cpp:31:9:\
    \ error: \u2018minHeap\u2019 was not declared in this scope\n   31 |         minHeap.push(value);\n\
    \      |         ^~~~~~~\n/tmp/tmpq0abq_q3.cpp:34:9: error: \u2018minHeap"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if (arr.size() == 0) {\n        return {};\n    }\n    std::vector<std::pair<long,\
    \ int>> min;\n    min.reserve(arr.size());\n    for (auto val : arr) {\n     \
    \   min.emplace_back(val, 0);\n    }\n    bool even = true;\n    for (size_t i\
    \ = 0; i < min.size() && even; ++i) {\n        auto &[val, index] = min.at(i);\n\
    \        if (val % 2 == 0 && even) {\n            min.at(i) = std::min(min.at(i),\
    \ min.at(i + 1));\n            min.at(i + 1) = std::make_pair(val, index);\n \
    \           even = !even;\n        }\n    }\n    std::vector<long> res;\n    if\
    \ (min.size() > 0) {\n        long smallest = min.at(0);\n        for (auto &[val,\
    \ index] : min) {\n            if (val == smallest && index != 0) {\n        \
    \        res.push_back(smallest);\n                res.push_back(index);\n   \
    \             break;\n            }\n            if (val < smallest) {\n     \
    \           res.push_back(smallest);\n                res.push_back(index);\n\
    \                smallest = val;\n            }\n        }\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuv80ark8.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpuv80ark8.cpp:39:15: warning: structured bindings only\
    \ available with \u2018-std=c++17\u2019 or \u2018-std=gnu++17\u2019\n   39 | \
    \        auto &[val, index] = min.at(i);\n      |               ^\n/tmp/tmpuv80ark8.cpp:48:31:\
    \ error: cannot convert \u2018__gnu_cxx::__alloc_traits<std::allocator<std::pair<long\
    \ int, int> >, std::pair<long int, int> >::value_type\u2019 {aka \u2018std::pair<long\
    \ int, int>\u2019} to \u2018long int\u2019 in initialization\n   48 |        \
    \ long smallest = min.at(0);\n      |                         ~~~~~~^~~\n    \
    \  |                               |\n      |                               __gnu_cxx::__alloc_traits<std::allocator<std::pair<long\
    \ int, int> >, std::pair<long int, int> >::value_type {aka std::pair<long int,\
    \ int>}\n/tmp/tmpuv80ark8.cpp:49:20: warning: structured bindings only available\
    \ with \u2018-std=c++17\u2019 or \u2018-std=gnu++17\u2019\n   49 |         for\
    \ (auto &[val, index] : min) {\n      |                    ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long ans;\n    long n = arr.size();\n    long max_index = 0;\n \
    \   long min_value = INT_MAX;\n\n    for (int i = 0; i < n; i++) {\n        long\
    \ val = arr[i];\n        if (val < min_value) {\n            min_value = val;\n\
    \            ans = i;\n        } else if (val == min_value) {\n            if\
    \ (i != ans) ans = i;\n        }\n        if (min_value % 2 == 0 && arr[i] % 2\
    \ == 0) {\n            max_index = i;\n        }\n    }\n    std::vector<long>\
    \ ans_list;\n    if (ans == 0) {\n        return ans_list;\n    }\n    ans_list.push_back(ans);\n\
    \    ans_list.push_back(max_index);\n\n    return ans_list;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp89aeq_qu: /tmp/tmp89aeq_qu.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::priority_queue<std::pair<long, int> > pq;\n    pq.push(std::make_pair(0,\
    \ 0));\n    for (long &i : arr) {\n        pq.push(std::make_pair(i, pq.size()));\n\
    \    }\n    pq.push(std::make_pair(arr.back(), arr.size() - 1));\n    long pick;\n\
    \    int index;\n    while (!pq.empty()) {\n        pick = pq.top().first;\n \
    \       index = pq.top().second;\n        pq.pop();\n        if (pick & 1) {\n\
    \            return { pick, index };\n        }\n    }\n    return {};\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp8alnws0u: /tmp/tmp8alnws0u.cpp:49: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    std::vector<long> indices;\n    res.push_back(arr[0]);\n\
    \    indices.push_back(0);\n    int smallest_value = 0;\n    long smallest_index\
    \ = 0;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0 && arr[i] < smallest_value) {\n            smallest_value = arr[i];\n    \
    \        smallest_index = i;\n        }\n        if (arr[i] % 2 == 0) {\n    \
    \        res.push_back(arr[i]);\n            indices.push_back(i);\n        }\n\
    \    }\n    if (res.size() == 0)\n        return res;\n    if (smallest_value\
    \ == 0)\n        return res;\n    for (int i = 0; i < res.size(); i++) {\n   \
    \     if (arr[i] - arr[smallest_index] < smallest_value)\n            indices.erase(indices.begin()\
    \ + i);\n    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpwp1oj8vg: /tmp/tmpwp1oj8vg.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto it = arr.begin();\n    long largestEven = *it;\n    long largestIndex\
    \ = 0;\n    for (long i = 1; i < arr.size(); ++i) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (arr[i] > largestEven) {\n                largestEven =\
    \ arr[i];\n                largestIndex = i;\n            }\n        }\n    }\n\
    \    std::vector<long> ans = {largestEven, largestIndex};\n    return ans;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp_6xra7tt: /tmp/tmp_6xra7tt.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    if (arr.size() == 0) return {};\n    auto it = arr.begin();\n  \
    \  auto next_it = it;\n    auto next_next_it = next_it;\n    while (next_it !=\
    \ arr.end()) {\n        next_it += 2;\n        if (*next_it % 2 == 0) {\n    \
    \        if (*next_it != *next_next_it) next_next_it = next_it;\n        }\n \
    \       next_it++;\n        if (next_it == arr.end()) break;\n    }\n    return\
    \ {*next_next_it, *next_it};\n}\nint main() {\n    auto candidate = pluck;\n \
    \   assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpxptbg_gp: /tmp/tmpxptbg_gp.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_even_value = INT_MIN, smallest_index_value = INT_MIN;\n\
    \    std::vector<long> result;\n    for(long i = 0; i < arr.size(); i++) {\n \
    \       if(smallest_even_value%2==0 && arr[i]%2==0) {\n            if(arr[i]<smallest_index_value)\
    \ {\n                smallest_even_value = arr[i];\n                smallest_index_value\
    \ = i;\n            }\n        }\n    }\n    result.push_back(smallest_even_value);\n\
    \    result.push_back(smallest_index_value);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpweq6fynd: /tmp/tmpweq6fynd.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  long result = INT_MIN;\n  std::vector<long> result_vec;\n  long index\
    \ = -1;\n  for (size_t i = 0; i < arr.size(); i++) {\n    if (arr[i] % 2 != 0)\
    \ {\n      if (result < arr[i]) {\n        result = arr[i];\n        index = i;\n\
    \      }\n    } else {\n      result_vec.push_back(arr[i]);\n    }\n  }\n  return\
    \ result_vec;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpvijelwwh: /tmp/tmpvijelwwh.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long ans=0;\n    long index = 0;\n    if(arr.size()==0){\n\
    \        return {};\n    }\n    for(auto it = arr.begin();it!=arr.end();++it){\n\
    \        if((*it)%2==0){\n            ans+=*it;\n            index=*it;\n    \
    \    }\n    }\n    auto res = {ans,index};\n    return res;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpw321my39: /tmp/tmpw321my39.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  assert(arr.size() > 0);\n  std::vector<long> result;\n  long smallestEven\
    \ = INT_MAX;\n  long smallestIndex = 0;\n  for (long idx : arr) {\n    if (idx\
    \ % 2 != 0) {\n      if (idx == smallestEven) {\n        smallestIndex = idx;\n\
    \      } else if (idx < smallestEven) {\n        smallestEven = idx;\n       \
    \ smallestIndex = idx;\n      } else {\n        smallestEven = idx;\n        smallestIndex\
    \ = idx;\n      }\n    }\n  }\n  std::cout << smallestEven << \" \" << smallestIndex\
    \ << std::endl;\n  result.emplace_back(smallestEven, smallestIndex);\n  return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h:33,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/allocator.h:46,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp446sr9go.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ext/new_allocator.h:\
    \ In instantiation of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*,\
    \ _Args&& ...) [with _Up = long int; _Args = {long int&, long int&}; _Tp = long\
    \ int]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/alloc_traits.h:482:2:\
    \   required from \u2018static void std::allocator_traits<std::allocator<_CharT>\
    \ >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&,\
    \ _Up*, _Args&& ...) [with _Up = long int; _Args = {long int&, long int&}; _Tp\
    \ = long int; std::allocator_traits<std::allocator<_CharT> >::allocator_type =\
    \ std::allocator<long int>]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:115:30:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...)\
    \ [with _Args = {long int&, long int&}; _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n/tmp/tmp446sr9go.cpp:47:50:   required from here\n/shared/centos7/gcc/9.2.0-skylake/inclu"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> ans;\n    ans.push_back(arr[0]);\n    long idx\
    \ = 0;\n    long temp = 0;\n    while (idx < arr.size() - 1) {\n        if (arr[idx]\
    \ & 1) {\n            if (arr[idx] == temp) {\n                ans.push_back({arr[idx],\
    \ idx});\n            } else if (arr[idx] < temp) {\n                temp = arr[idx];\n\
    \                ans.push_back({temp, idx});\n            }\n        } else {\n\
    \            if (arr[idx] == temp) {\n                ans.push_back({arr[idx],\
    \ idx});\n            } else {\n                temp = arr[idx];\n           \
    \     ans.push_back({temp, idx});\n            }\n        }\n        idx++;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp74liu2tz.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp74liu2tz.cpp:36:46: error: no matching function for call\
    \ to \u2018std::vector<long int>::push_back(<brace-enclosed initializer list>)\u2019\
    \n   36 |                 ans.push_back({arr[idx], idx});\n      |           \
    \                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp74liu2tz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018std::vector<long int>::value_type&&\u2019 {aka \u2018long\
    \ int&&\u2019}\n 1200 |       push_back(value_type&& __x)\n      |           \
    \      ~~~~~~~~~~~~~^~~\n/tmp/tmp74liu2tz.cpp:39:42: error: no matching function\
    \ for call to \u2018std::vector<long int>:"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n        // Your code here\n        std::set<long> s;\n        int ans=0;\n\
    \        for(std::size_t i=0 ;i < arr.size(); ++i){\n            long val= arr[i];\n\
    \            if(s.find(val)!=s.end()){\n                ans=std::min(ans,std::distance(s.begin(),s.find(val)));\n\
    \                s.erase(val);\n            }\n            else{\n           \
    \     s.insert(val);\n            }\n        }\n        std::vector<long> out;\n\
    \        while(!s.empty()){\n            out.push_back(s.begin()->second);\n \
    \           s.erase(s.begin()->first);\n        }\n        return out;\n    }\n\
    </code>\n<|/ a tags=arrays,algorithm,data-structures |>\n<| a dscore=2 |>\nIn\
    \ C++:\n<code>\n#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> arr;\n\
    int main()\n{\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++)\n    {\n      \
    \  cin>>arr[i];\n    }\n    sort(arr.begin(),arr.end());\n    for(int i=0;i<n;i++)\n\
    \    {\n        if(arr[i] % 2 == 0)\n        {\n            cout<<arr[i]<<\" \"\
    ;\n        }\n    }\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb6boczp_.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpb6boczp_.cpp:35:70: error: no matching function for call\
    \ to \u2018min(int&, std::__iterator_traits<std::_Rb_tree_const_iterator<long\
    \ int>, void>::difference_type)\u2019\n   35 |                 ans=std::min(ans,std::distance(s.begin(),s.find(val)));\n\
    \      |                                                                     \
    \ ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb6boczp_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:198:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpb6boczp_.cpp:35:70:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018std::__iterator_traits<std::_Rb_tree_const_iterator<long int>,\
    \ void>::difference_type\u2019 {aka \u2018long int\u2019})\n   35 |          \
    \       ans=std::min(ans,std::distance(s.begin(),s.find(val)));\n      |     \
    \                                                                 ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    int n1 = 0, n2 = 0;\n    int n3 = 0;\n    for (auto i = arr.begin();\
    \ i != arr.end(); i++) {\n        if (*i % 2 == 0) {\n            if (n2 != 0)\n\
    \                n3 = n2;\n            n2 = n1;\n            n1 = *i;\n      \
    \  } else {\n            if (n1 == 0) {\n                if (n2 != 0)\n      \
    \              n3 = n2;\n                else {\n                    n3 = *i;\n\
    \                    n2 = n1;\n                }\n                n1 = *i;\n \
    \           } else {\n                if (n1 != n2) {\n                    n3\
    \ = n1;\n                    n2 = n1;\n                    n1 = *i;\n        \
    \        } else {\n                    n3 = *i;\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> res;\n    if (n3 != 0)\n      \
    \  res.push_back(n3);\n    return res;\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpwfq0rano: /tmp/tmpwfq0rano.cpp:64: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value;\n    int smalest_index;\n    bool any_even_value\
    \ = false;\n    for (long i : arr) {\n        any_even_value |= (i % 2 == 0);\n\
    \        if (i == 0) {\n            continue;\n        }\n        smalest_value\
    \ = i;\n        smalest_index = arr.size() - 1;\n        while (smalest_index\
    \ >= 0 && !(smalest_index & 1)) {\n            smalest_value = (smalest_value\
    \ << 1) + (smalest_value >> 1);\n            smalest_index = smalest_index / 2;\n\
    \        }\n    }\n    if (any_even_value) {\n        std::vector<long> retval;\n\
    \        for (long i : arr) {\n            if (i == 0) {\n                continue;\n\
    \            }\n            retval.push_back(i);\n        }\n        return retval;\n\
    \    }\n    return std::vector<long>();\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpll77osl6: /tmp/tmpll77osl6.cpp:58: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value;\n    long smalest_index;\n    std::map<long,\
    \ long> map_value;\n    std::map<long, long>::iterator it;\n    for(size_t i =\
    \ 0; i < arr.size(); i++){\n        it = map_value.find(arr[i]);\n        if(it\
    \ != map_value.end()){\n            if(it->second == 0){\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n            else{\n\
    \                if(it->second < smalest_value){\n                    smalest_value\
    \ = it->second;\n                    smalest_index = it->first;\n            \
    \    }\n            }\n        }\n        else{\n            map_value.insert(std::pair<long,\
    \ long>(arr[i], 0));\n        }\n    }\n    std::vector<long> ans;\n    if(map_value.empty()){\n\
    \        ans.push_back(smalest_value);\n        ans.push_back(smalest_index);\n\
    \        return ans;\n    }\n    it = map_value.begin();\n    long last_value\
    \ = 0;\n    long last_index = 0;\n    if(smalest_value == arr[0]){\n        last_value\
    \ = arr[0];\n        last_index = 0;\n    }\n    else if(smalest_value == arr[arr.size()-1]){\n\
    \        last_value = arr[arr.size()-1];\n        last_index = arr.size()-1;\n\
    \    }\n    else{\n        it = map_value.upper_bound(smalest_value);\n      \
    \  last_value = it->first;\n        last_index = it->second;\n    }\n    while(it\
    \ != map_value.end()){\n        if((last_index == 0) && (it->second < smalest_index)){\n\
    \            ans.push_back(it->first);\n            ans.push_back(it->second);\n\
    \            return ans;\n        }\n        else if(it->second == last_index){\n\
    \            if(it->second < smalest_index){\n                ans.push_back(it->first);\n\
    \                ans.push_back(it->second);\n                return ans;\n   \
    \         }\n        }\n        else if(it->second < smalest_index){\n       \
    \     ans.push_back(it->first);\n            ans.push_back(it->second);\n    \
    \        return ans;\n        }\n        last_value = it->first;\n        last_index\
    \ = it->second;\n        ++it;\n    }\n    ans.push_back(last_value);\n    ans.push_back(last_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpqf1_b4rk: /tmp/tmpqf1_b4rk.cpp:101: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long ans = std::numeric_limits<long>::max();\n    long min_val =\
    \ std::numeric_limits<long>::max();\n    long min_val_index = -1;\n    long index\
    \ = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < arr[index])\
    \ {\n            min_val = arr[i];\n            min_val_index = i;\n        }\n\
    \    }\n    ans = min_val;\n    index = min_val_index;\n    return std::vector<long>{ans,\
    \ index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpfhlqz5yh: /tmp/tmpfhlqz5yh.cpp:45: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    auto size = arr.size();\n    long smallest_even = arr[0];\n    long\
    \ smallest_index = -1;\n    for (long i = 1; i < size; i++) {\n        if (arr[i]\
    \ < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index\
    \ = i;\n        }\n    }\n    if (smallest_even % 2 != 0) {\n        std::vector<long>\
    \ results;\n        results.push_back(smallest_even);\n        results.push_back(smallest_index);\n\
    \        return results;\n    }\n    if (size < 2) {\n        return {};\n   \
    \ }\n    std::vector<long> results;\n    if (smallest_even == arr[0]) {\n    \
    \    std::vector<long> tmp;\n        tmp.push_back(arr[0]);\n        tmp.push_back(smallest_index);\n\
    \        results.push_back(tmp);\n    }\n    else {\n        for (long i = 0;\
    \ i < size - 1; i++) {\n            if (smallest_even - arr[i] == smallest_even\
    \ - arr[i - 1]) {\n                std::vector<long> tmp;\n                tmp.push_back(arr[i]);\n\
    \                tmp.push_back(smallest_index);\n                results.push_back(tmp);\n\
    \            }\n        }\n    }\n    return results;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphefqux3u.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmphefqux3u.cpp:52:30: error: no matching function for call\
    \ to \u2018std::vector<long int>::push_back(std::vector<long int>&)\u2019\n  \
    \ 52 |         results.push_back(tmp);\n      |                              ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmphefqux3u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019}\n 1184 |\
    \       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018std::vector<long int>::value_type&&\u2019 {aka \u2018long int&&\u2019\
    }\n 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n\
    /tmp/tmphefqux3u.cpp:60:38: error: no matching function for call to \u2018std::vector<long\
    \ int>::push_back(std::vector<long int>&)\u2019\n   60 |                 results"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> res;\n    int min = *std::min_element(arr.begin(),\
    \ arr.end());\n    int idx = arr.size();\n    for (size_t i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] < min) {\n            min = arr[i];\n           \
    \ idx = i;\n        }\n    }\n    res.push_back(min);\n    res.push_back(idx);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp5rq4r956: /tmp/tmp5rq4r956.cpp:44: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::set<long> elements;\n    long smallest_value = arr[0];\n  \
    \  long smallest_index = 0;\n\n    for (long i: arr)\n        if (elements.find(i)\
    \ == elements.end())\n            elements.insert(i);\n        else {\n      \
    \      long j = i;\n            while (j < smallest_value + 1) {\n           \
    \     smallest_value = j;\n                smallest_index = elements[j];\n   \
    \             j++;\n            }\n        }\n\n    std::vector<long> result;\n\
    \    if (smallest_index == 0)\n        return result;\n    else\n        result.push_back({smallest_value,\
    \ smallest_index});\n    return result;\n}\nint main() {\n    auto candidate =\
    \ pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4wch27p1.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4wch27p1.cpp:40:42: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::set<long int>\u2019 and \u2018long int\u2019)\n\
    \   40 |                 smallest_index = elements[j];\n      |              \
    \                            ^\n/tmp/tmp4wch27p1.cpp:49:58: error: no matching\
    \ function for call to \u2018std::vector<long int>::push_back(<brace-enclosed\
    \ initializer list>)\u2019\n   49 |         result.push_back({smallest_value,\
    \ smallest_index});\n      |                                                 \
    \         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/queue:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:86,\n\
    \                 from /tmp/tmp4wch27p1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::value_type\
    \ = long int]\u2019\n 1184 |       push_back(const value_type& __x)\n      | \
    \      ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018const value_type&\u2019 {aka \u2018const long int&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::value_type = long int]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018<brace-enclosed initial"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long index = 0;\n    long minIndex = std::numeric_limits<long>::max();\n\
    \    for (auto const &i : arr) {\n        if (i % 2 == 0) {\n            index\
    \ = i;\n            minIndex = std::min(minIndex, index);\n        }\n    }\n\
    \    std::vector<long> result;\n    if (minIndex != std::numeric_limits<long>::max())\
    \ {\n        result.push_back(minIndex);\n        result.push_back(arr.size());\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2, 1})));\n\
    \    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp8w668xg1: /tmp/tmp8w668xg1.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smallest_value, smallest_index;\n    std::pair<long, long>\
    \ smallest_pair = std::min({arr.at(0), arr.at(1)});\n    if(smallest_pair.second\
    \ == arr.at(0)) {\n        smallest_value = smallest_pair.first;\n        smallest_index\
    \ = 0;\n    }\n    else {\n        smallest_value = smallest_pair.second;\n  \
    \      smallest_index = arr.at(smallest_pair.first) - 1;\n    }\n    std::vector<long>\
    \ result;\n    for(size_t i = 0; i <= arr.size(); ++i) {\n        if((i % 2 ==\
    \ 0) && (arr.at(i) == smallest_value)) {\n            result.push_back(smallest_value);\n\
    \            result.push_back(smallest_index + i + 1);\n        }\n    }\n   \
    \ return std::move(result);\n}\nint main() {\n    auto candidate = pluck;\n  \
    \  assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpui1zvucs.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpui1zvucs.cpp:30:51: error: conversion from \u2018long\
    \ int\u2019 to non-scalar type \u2018std::pair<long int, long int>\u2019 requested\n\
    \   30 |     std::pair<long, long> smallest_pair = std::min({arr.at(0), arr.at(1)});\n\
    \      |                                           ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long smalest_value = 0;\n    long index = 0;\n\
    \    long sum = 0;\n    long smalest_value;\n    for (long k : arr) {\n      \
    \  index++;\n        sum = k + index;\n        if(sum%2 == 0)\n        {\n   \
    \         smalest_value = k;\n            index = sum;\n        }\n    }\n   \
    \ std::vector<long> result;\n    if(arr.size() == 0)\n        return result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(index);\n    return\
    \ result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp23lomvdq.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp23lomvdq.cpp:33:10: error: redeclaration of \u2018long\
    \ int smalest_value\u2019\n   33 |     long smalest_value;\n      |          ^~~~~~~~~~~~~\n\
    /tmp/tmp23lomvdq.cpp:30:10: note: \u2018long int smalest_value\u2019 previously\
    \ declared here\n   30 |     long smalest_value = 0;\n      |          ^~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long minVal = 0;\n    long minIndex = -1;\n    for (long i : arr)\
    \ {\n        if (i % 2 == 0) {\n            minVal = i;\n            minIndex\
    \ = i;\n        } else if (i == minVal) {\n            minIndex = i;\n       \
    \ }\n    }\n    std::vector<long> ans;\n    ans.push_back(minVal);\n    ans.push_back(minIndex);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp0ba_8m9j: /tmp/tmp0ba_8m9j.cpp:46: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    long largestVal = 0;\n    std::vector<long> returnValue;\n\
    \    for (long &i : arr)\n    {\n        if (i & 1)\n        {\n            i\
    \ = i + 1;\n            largestVal = i;\n        }\n        else\n        {\n\
    \            if (i == largestVal)\n            {\n                returnValue.push_back(i);\n\
    \            }\n        }\n    }\n    return returnValue;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmph9otkxzh: /tmp/tmph9otkxzh.cpp:51: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    if(arr.size()==0)\n    {\n        return\
    \ {};\n    }\n    std::vector<long> a;\n    long min=*std::min_element(arr.begin(),arr.end());\n\
    \    for(long i=0;i<arr.size();i++)\n    {\n        if(arr[i]==min)\n        {\n\
    \            a.push_back(i);\n        }\n    }\n    long smalest_value=*std::min_element(a.begin(),a.end());\n\
    \    std::vector<long> output;\n    std::vector<long>::iterator iter;\n    for(iter=a.begin();iter!=a.end();iter++)\n\
    \    {\n        if(*iter==smalest_value)\n        {\n            output.push_back(*iter);\n\
    \        }\n    }\n    return output;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmp9lyr1lf2: /tmp/tmp9lyr1lf2.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    assert(arr.size() != 0);\n    // create an array to store the result\n\
    \    std::vector<long> result;\n    // sort from the smallest to the largest\n\
    \    std::sort(arr.begin(), arr.end());\n    // find even value, and save the\
    \ index\n    long min_value = arr[0];\n    long min_index = 0;\n    long idx =\
    \ 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0)\
    \ {\n            if (min_value % 2 == 0) {\n                min_value = arr[i];\n\
    \                min_index = i;\n            }\n        } else if (min_value %\
    \ 2 != 0) {\n            idx++;\n            min_value = arr[i];\n           \
    \ min_index = i;\n        }\n    }\n    if (min_value == arr[0]) {\n        //\
    \ if even value is found, no matter which one we picked, we return the smallest\
    \ one\n        result.push_back(min_index);\n    } else {\n        result.push_back(min_value);\n\
    \        result.push_back(min_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmppjp307f_: /tmp/tmppjp307f_.cpp:61: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // Write your code here\n    long min_val = *std::min_element(arr.cbegin(),\
    \ arr.cend()); \n    std::vector<long> res;\n    for (long i : arr){\n       \
    \ if (i % 2 == 0) {\n            res.push_back(i);\n        }\n        if (i !=\
    \ min_val) {\n            break;\n        }\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpxzno9ht8: /tmp/tmpxzno9ht8.cpp:44: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    int even_index[arr.size()+1];\n   \
    \ long ans[arr.size()];\n    for(int i = 0; i<arr.size();i++){\n        if(arr[i]\
    \ % 2 ==0 ){\n            even_index[i] = i;\n        }\n    }\n    for(int i=0;i<arr.size();i++){\n\
    \        int min_idx=i;\n        for(int j=0;j<arr.size();j++){\n            if(\
    \ arr[j] < arr[min_idx]){\n                min_idx = j;\n            }\n     \
    \   }\n        if(min_idx!=i ){\n            ans[i] = arr[i];\n            ans[min_idx]\
    \ = arr[i];\n            ans[even_index[min_idx]] = arr[i];\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp28k0m5vf.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp28k0m5vf.cpp:50:12: error: could not convert \u2018ans\u2019\
    \ from \u2018long int [(<anonymous> + 1)]\u2019 to \u2018std::vector<long int>\u2019\
    \n   50 |     return ans;\n      |            ^~~\n      |            |\n    \
    \  |            long int [(<anonymous> + 1)]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::vector<long> res;\n  long val = arr[0];\n  res.push_back(val);\n\
    \  // base case\n  if (arr.empty())\n    return res;\n  // pick up min/minIndex\
    \ of even\n  for (auto i : arr) {\n    // skip 0 as min\n    if (i == 0)\n   \
    \   continue;\n    // min/minIndex of even\n    if ((i % 2) == 0) {\n      if\
    \ (val > i) {\n        val = i;\n        res.push_back(val);\n      }\n    } else\
    \ {\n      if (val > i) {\n        val = i;\n        res.push_back(val);\n   \
    \   }\n    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpq_hyj02p: /tmp/tmpq_hyj02p.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value, smalest_index, smallest_value, smallest_index;\n\
    \    std::vector<long> ret_val;\n    // Your code goes here\n    std::priority_queue<long>\
    \ que;\n    std::unordered_map<long, bool> is_even;\n\n    for (long &i : arr)\n\
    \        is_even[i] = false;\n\n    que.push(arr[0]);\n\n    while (!que.empty())\
    \ {\n        smalest_value = que.top();\n        que.pop();\n        smalest_index\
    \ = smallest_value = smallest_index = 0;\n\n        for (long &i : arr)\n    \
    \        if (is_even[i] && !is_even[smalest_value]) {\n                is_even[smalest_value]\
    \ = true;\n                smallest_value = smalest_value;\n                smallest_index\
    \ = i;\n                break;\n            } else if (is_even[i]) {\n       \
    \         if (i < smalest_value) {\n                    smallest_value = i;\n\
    \                    smallest_index = i;\n                }\n            }\n \
    \       ret_val.push_back(smallest_value);\n        ret_val.push_back(smallest_index);\n\
    \    }\n\n    if (ret_val.size() == 0) return ret_val;\n\n    if (ret_val.size()\
    \ == 1) {\n        is_even[ret_val[0]] = false;\n        que.push(ret_val[0]);\n\
    \    }\n\n    while (!que.empty()) {\n        smalest_value = que.top();\n   \
    \     que.pop();\n        smalest_index = smallest_value = smallest_index = 0;\n\
    \n        for (long &i : arr)\n            if (is_even[i] && !is_even[smalest_value])\
    \ {\n                is_even[smalest_value] = true;\n                smallest_value\
    \ = smalest_value;\n                smallest_index = i;\n                break;\n\
    \            } else if (is_even[i]) {\n                if (i < smalest_value)\
    \ {\n                    smallest_value = i;\n                    smallest_index\
    \ = i;\n                }\n            }\n        ret_val.push_back(smallest_value);\n\
    \        ret_val.push_back(smallest_index);\n    }\n\n    return ret_val;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp6qh5gzyt: /tmp/tmp6qh5gzyt.cpp:93: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // code here\n    auto ret = std::min_element(arr.begin(), arr.end())\
    \ + 1;\n    std::sort(arr.begin(), arr.end(), [&arr](long a, long b)\n    {\n\
    \        if ((a % 2) != (b % 2)) {\n            return a < b;\n        }\n   \
    \     return a < arr[b];\n    });\n    return ret; \n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwxp0__tx.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpwxp0__tx.cpp:38:12: error: could not convert \u2018ret\u2019\
    \ from \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >\u2019\
    \ to \u2018std::vector<long int>\u2019\n   38 |     return ret;\n      |     \
    \       ^~~\n      |            |\n      |            __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long minValue = INT_MIN, minIndex = -1;\n    for (auto i : arr)\
    \ {\n        if (i < minValue) {\n            minValue = i;\n            minIndex\
    \ = arr.size();\n        }\n    }\n\n    if (minValue == 0) {\n        std::vector<long>\
    \ result;\n        if (arr.size() > 1) {\n            std::vector<long> index;\n\
    \            for (auto i : arr) {\n                if (i != 0) {\n           \
    \         index.push_back(i);\n                }\n            }\n            index.sort([](long\
    \ a, long b) {\n                return a < b;\n            });\n            result[0]\
    \ = index[0];\n            result.push_back(index[0]);\n            return result;\n\
    \        } else {\n            return {};\n        }\n    }\n    std::vector<long>\
    \ result;\n    std::vector<long> index;\n    for (auto i : arr) {\n        if\
    \ (i > 0) {\n            index.push_back(i);\n        }\n    }\n    index.sort([](long\
    \ a, long b) {\n        return a < b;\n    });\n    result[0] = index[0];\n  \
    \  long lastValue = index[0];\n    for (auto i : index[1:]) {\n        if (lastValue\
    \ == i) {\n            lastValue += 2;\n        } else {\n            result.push_back(lastValue);\n\
    \            lastValue = i;\n        }\n    }\n    result.push_back(lastValue);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5jlbh2c3.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5jlbh2c3.cpp:46:19: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018sort\u2019\n   46 |             index.sort([](long\
    \ a, long b) {\n      |                   ^~~~\n/tmp/tmp5jlbh2c3.cpp:63:11: error:\
    \ \u2018class std::vector<long int>\u2019 has no member named \u2018sort\u2019\
    \n   63 |     index.sort([](long a, long b) {\n      |           ^~~~\n/tmp/tmp5jlbh2c3.cpp:68:26:\
    \ error: expected \u2018]\u2019 before \u2018:\u2019 token\n   68 |     for (auto\
    \ i : index[1:]) {\n      |                          ^\n      |              \
    \            ]\n/tmp/tmp5jlbh2c3.cpp:68:26: error: \u2018begin\u2019 was not declared\
    \ in this scope; did you mean \u2018std::begin\u2019?\n   68 |     for (auto i\
    \ : index[1:]) {\n      |                          ^\n      |                \
    \          std::begin\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp5jlbh2c3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1224:5:\
    \ note: \u2018std::begin\u2019 declared here\n 1224 |     begin(const valarray<_Tp>&\
    \ __va)\n      |     ^~~~~\n/tmp/tmp5jlbh2c3.cpp:68:26: error: \u2018end\u2019\
    \ was not declared in this scope; did you mean \u2018std::end\u2019?\n   68 |\
    \     for (auto i : index[1:]) {\n      |                          ^\n      |\
    \                          std::end\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:95,\n\
    \                 from /tmp/tmp5jlbh2c3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/valarray:1244:5:\
    \ note: \u2018std::end\u2019 declared here\n 1244 |     end(const valarray<_Tp>&\
    \ __va)\n      |     ^~~\n/tmp/tmp5jlbh2c3.cpp:68:26: error: expected \u2018)\u2019\
    \ before \u2018:\u2019 token\n   68 |     for (auto i : index[1:]) {\n      |\
    \         ~                ^\n      |                          )\n/tmp/tmp5jlbh2c3.cpp:68:26:\
    \ error: expected primary-expression before \u2018:\u2019 token\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    \n    long smalest_value = 0;\n   \
    \ long smalest_index = 0;\n    long sum = 0;\n    for (int i = 0; i < arr.size();\
    \ ++i) {\n        sum += arr[i];\n        if (sum % 2 == 0) {\n            smalest_value\
    \ = sum;\n            smalest_index = i;\n        }\n    }\n    \n    std::vector<long>\
    \ res;\n    if (smalest_index != 0) {\n        std::swap(smalest_value, arr[smalest_index]);\n\
    \        res.push_back(smalest_value);\n        res.push_back(smalest_index);\n\
    \    } else {\n        res.push_back(smalest_value);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmp2trb9338: /tmp/tmp2trb9338.cpp:55: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> vec;\n    std::vector<bool> isEven(arr.size(),\
    \ true);\n    long smallestEven = arr[0];\n    int smallestIndex = -1;\n    for\
    \ (int i = 1; i < arr.size(); i++) {\n        if (isEven[i]) {\n            if\
    \ (arr[i] < smallestEven) {\n                smallestEven = arr[i];\n        \
    \        smallestIndex = i;\n            }\n        } else if (arr[i] == 0) {\n\
    \            if (smallestIndex != -1) {\n                isEven[smallestIndex]\
    \ = false;\n                vec.push_back(smallestEven);\n                smallestEven\
    \ = arr[i];\n                smallestIndex = -1;\n            }\n        }\n \
    \   }\n    return vec;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpitqfwcms: /tmp/tmpitqfwcms.cpp:52: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  \n  long smallest_value = 0, smallest_index = 0;\n  for (size_t i\
    \ = 1; i < arr.size(); i++) {\n    if (arr[i] < arr[i-1]) {\n      smallest_value\
    \ = arr[i];\n      smallest_index = i;\n    }\n  }\n  // If no even values are\
    \ present\n  if (smallest_value == 0) {\n    return std::vector<long>();\n  }\n\
    \  // If no even values are present or the array is empty\n  if (smallest_value\
    \ == 0) {\n    return std::vector<long>();\n  }\n  // If there is just one even\
    \ value\n  if (arr.size() == 1) {\n    return std::vector<long>();\n  }\n  std::vector<long>\
    \ ans;\n  std::vector<long> even_indices;\n  \n  // For each element in the array\n\
    \  for (size_t i = 0; i < arr.size(); i++) {\n    // If the current element is\
    \ smaller than the previous element\n    if (arr[i] < arr[smallest_index]) {\n\
    \      // If the current element is smaller than the previous element and is even\n\
    \      if (arr[i] % 2 == 0) {\n        even_indices.push_back(i);\n      }\n \
    \     // If the current element is smaller than the previous element is not even\n\
    \      else {\n        ans.push_back(arr[i]);\n      }\n    }\n    // If the current\
    \ element is smaller than the previous element\n    else if (arr[i] == arr[smallest_index]\
    \ && arr[i] % 2 != 0) {\n      ans.push_back(arr[i]);\n    }\n  }\n  // If there\
    \ are more than one even values\n  if (even_indices.size() > 1) {\n    for (size_t\
    \ i = 0; i < even_indices.size(); i++) {\n      // Push the even value to ans\
    \ vector\n      ans.push_back(arr[even_indices[i]]);\n    }\n  }\n  // If there\
    \ are just one even value\n  else if (even_indices.size() == 1) {\n    ans.push_back(arr[even_indices[0]]);\n\
    \  }\n  return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpa6ihxxrx: /tmp/tmpa6ihxxrx.cpp:85: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long smalest_index = 0;\n    std::vector<long>\
    \ res;\n    for(int i=0; i<arr.size(); i++)\n        if(arr[i] % 2 == 0)\n   \
    \     {\n            if(smalest_value > arr[i])\n            {\n             \
    \   smalest_value = arr[i];\n                smalest_index = i;\n            }\n\
    \        }\n    \n    for(int i=0; i<arr.size(); i++)\n        if(arr[i] % 2 ==\
    \ 0)\n        {\n            if(smalest_value == arr[i])\n            {\n    \
    \            res.push_back( smalest_value);\n                res.push_back( smalest_index);\n\
    \                break;\n            }\n        }\n    \n    return res;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpeq1n55n3: /tmp/tmpeq1n55n3.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    std::vector<long> result;\n    long evenSmallestValue = std::numeric_limits<long>::max();\n\
    \    long smallestIndex = 0;\n    // check if all nodes are even\n    for(long\
    \ i = 0; i < arr.size(); i++) {\n        // check if current index is even\n \
    \       if(arr[i] % 2 == 0) {\n            // if even, check if current value\
    \ is smaller than previously chosen smallest value\n            if(arr[i] < evenSmallestValue)\
    \ {\n                evenSmallestValue = arr[i];\n                smallestIndex\
    \ = i;\n            }\n        }\n    }\n    // if even smallest value found,\
    \ then return\n    if(evenSmallestValue == std::numeric_limits<long>::max()) return\
    \ result;\n    // if current value is smaller than smallest value found then find\
    \ smallest index\n    if(evenSmallestValue < result[smallestIndex]) smallestIndex\
    \ = evenSmallestValue;\n    // return smallest and smallest index\n    return\
    \ {evenSmallestValue, smallestIndex};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value, smalest_index, smalest_idx=0;\n    std::vector<long>\
    \ ans;\n    // sort the vector in descending order\n    std::sort(arr.rbegin(),\
    \ arr.rend(), greater<>());\n    // find smallest even value\n    for(int i=0;\
    \ i<arr.size(); i++){\n        if(arr[i]%2==0){\n            smalest_value=arr[i];\n\
    \            smalest_index=i;\n            smalest_idx=i;\n        }\n    }\n\
    \    // if array is empty, return empty vector\n    if(arr.empty()){\n       \
    \ return ans;\n    }\n    // if we haven't found any even value, return the vector\
    \ with smallest value\n    if(smalest_value==0){\n        ans.push_back(smalest_value);\n\
    \        ans.push_back(smalest_idx);\n        return ans;\n    }\n    // find\
    \ the smallest even index\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]==smalest_value){\n\
    \            smalest_idx=i;\n        }\n    }\n    // if we have found the smallest\
    \ even value, then pick up the smallest even index\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_idx);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpomg39825.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpomg39825.cpp:32:41: error: \u2018greater\u2019 was not\
    \ declared in this scope; did you mean \u2018std::greater\u2019?\n   32 |    \
    \ std::sort(arr.rbegin(), arr.rend(), greater<>());\n      |                 \
    \                        ^~~~~~~\n      |                                    \
    \     std::greater\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:48,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpomg39825.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_function.h:337:12:\
    \ note: \u2018std::greater\u2019 declared here\n  337 |     struct greater;\n\
    \      |            ^~~~~~~\n/tmp/tmpomg39825.cpp:32:49: error: expected primary-expression\
    \ before \u2018>\u2019 token\n   32 |     std::sort(arr.rbegin(), arr.rend(),\
    \ greater<>());\n      |                                                 ^\n/tmp/tmpomg39825.cpp:32:51:\
    \ error: expected primary-expression before \u2018)\u2019 token\n   32 |     std::sort(arr.rbegin(),\
    \ arr.rend(), greater<>());\n      |                                         \
    \          ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n\tstd::vector<long> ans(2);\n\tlong smallest, index;\n\tbool flag =\
    \ false;\n\tfor (int i = 0; i < arr.size(); i++) {\n\t\tif (!flag && arr[i] %\
    \ 2 == 0) {\n\t\t\tsmallest = arr[i];\n\t\t\tindex = i;\n\t\t\tflag = true;\n\t\
    \t} else if (arr[i] == smallest) {\n\t\t\tif (arr[i] % 2 == 0) {\n\t\t\t\tflag\
    \ = true;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t} else {\n\t\t\tflag = false;\n\t\t\
    }\n\t}\n\tif (flag) {\n\t\tans[0] = smallest;\n\t\tans[1] = index;\n\t} else {\n\
    \t\tans[0] = 0;\n\t\tans[1] = 0;\n\t}\n\treturn ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) ==\
    \ (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1, 2,\
    \ 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpwetktif_: /tmp/tmpwetktif_.cpp:57: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = 0;\n    long min_index = 0;\n    int max_index\
    \ = arr.size() - 1;\n    while (max_index >= 0) {\n        if (arr[max_index]\
    \ % 2 == 0) {\n            smalest_value = arr[max_index];\n            min_index\
    \ = max_index;\n        } else if (smalest_value != arr[max_index]) {\n      \
    \      smalest_value = arr[max_index];\n            min_index = max_index;\n \
    \       } else {\n            ++max_index;\n        }\n    }\n    std::vector<long>\
    \ ret;\n    for (size_t i = 0; i < arr.size(); i++) {\n        if (arr[i] == smalest_value\
    \ && i != min_index) {\n            ret.emplace_back(arr[i], i);\n        }\n\
    \    }\n    return ret;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h:33,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/allocator.h:46,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpr2nyzcqw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ext/new_allocator.h:\
    \ In instantiation of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*,\
    \ _Args&& ...) [with _Up = long int; _Args = {long int&, long unsigned int&};\
    \ _Tp = long int]\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/alloc_traits.h:482:2:\
    \   required from \u2018static void std::allocator_traits<std::allocator<_CharT>\
    \ >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&,\
    \ _Up*, _Args&& ...) [with _Up = long int; _Args = {long int&, long unsigned int&};\
    \ _Tp = long int; std::allocator_traits<std::allocator<_CharT> >::allocator_type\
    \ = std::allocator<long int>]\u2019\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/vector.tcc:115:30:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...)\
    \ [with _Args = {long int&, long unsigned int&}; _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n/tmp/tmpr2nyzcqw.cpp:46:39:   required from here\n/shared/cent"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n  std::sort(arr.begin(), arr.end());\n  std::unique(arr.begin(), arr.end());\
    \ // remove duplicate nodes\n  std::set<long> evens;\n  for (size_t i = 0; i !=\
    \ arr.size(); ++i) {\n    long curr = arr[i];\n    if (curr % 2 == 0) {\n    \
    \  evens.insert(curr);\n    }\n  }\n  std::vector<long> res;\n  if (evens.size()\
    \ == 0) return res;\n  res.push_back(*std::min_element(evens.begin(), evens.end()));\
    \ // pick the smallest even element\n  res.push_back(std::distance(arr.begin(),\
    \ std::find(arr.begin(), arr.end(), *std::min_element(evens.begin(), evens.end())))\
    \ // pick the smallest index\n  );\n  return res;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3}))) == (std::vector<long>({2,\
    \ 1})));\n    assert(candidate((std::vector<long>())) == (std::vector<long>()));\n\
    \    assert(candidate((std::vector<long>({5, 0, 3, 0, 4, 2}))) == (std::vector<long>({0,\
    \ 1})));\n    assert(candidate((std::vector<long>({1, 2, 3, 0, 5, 3}))) == (std::vector<long>({0,\
    \ 3})));\n    assert(candidate((std::vector<long>({5, 4, 8, 4, 8}))) == (std::vector<long>({4,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 6, 7, 1}))) == (std::vector<long>({6,\
    \ 1})));\n    assert(candidate((std::vector<long>({7, 9, 7, 1}))) == (std::vector<long>()));\n\
    }\n"
  stdout: ''
  stderr: "tmpj4g0r_cu: /tmp/tmpj4g0r_cu.cpp:47: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    long smalest_value = arr[0];\n    int smallest_index = 0;\n    long\
    \ max_value = arr[0];\n    for(long i : arr){\n        if(i>max_value){\n    \
    \        max_value = i;\n        }\n    }\n    for(int i : arr){\n        if(max_value%2==0\
    \ && i%2==0){\n            if(i<smalest_value){\n                smalest_value\
    \ = i;\n            }\n            if(smallest_index>max_value/2){\n         \
    \       smallest_index = max_value/2;\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    if(smallest_index>0){\n        res.push_back(smalest_value);\n   \
    \     res.push_back(smallest_index);\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4, 2, 3})))\
    \ == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpnokro1ow: /tmp/tmpnokro1ow.cpp:56: int main(): Assertion `candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n\
    // Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the\
    \ smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n\
    // Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output:\
    \ [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n\
    // so we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nstd::vector<long> pluck(std::vector<long>\
    \ arr) {\n    // write your code here\n    long smallestEvenValue, minIndex;\n\
    \    smallestEvenValue = arr[0];\n    minIndex = arr[0];\n    long minValue =\
    \ arr[0];\n\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] %\
    \ 2 == 0 && arr[i] < smallestEvenValue) {\n            smallestEvenValue = arr[i];\n\
    \            minIndex = i;\n        }\n    }\n    if (smallestEvenValue == 0)\
    \ {\n        std::vector<long> res;\n        res.push_back(arr[0]);\n        res.push_back(0);\n\
    \        return res;\n    }\n    minValue = arr[minIndex];\n    return std::vector<long>{smallestEvenValue,\
    \ minIndex};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({4,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({5, 0, 3,\
    \ 0, 4, 2}))) == (std::vector<long>({0, 1})));\n    assert(candidate((std::vector<long>({1,\
    \ 2, 3, 0, 5, 3}))) == (std::vector<long>({0, 3})));\n    assert(candidate((std::vector<long>({5,\
    \ 4, 8, 4, 8}))) == (std::vector<long>({4, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 6, 7, 1}))) == (std::vector<long>({6, 1})));\n    assert(candidate((std::vector<long>({7,\
    \ 9, 7, 1}))) == (std::vector<long>()));\n}\n"
  stdout: ''
  stderr: "tmpp6pkjg_t: /tmp/tmpp6pkjg_t.cpp:53: int main(): Assertion `candidate((std::vector<long>({1,\
    \ 2, 3}))) == (std::vector<long>({2, 1}))' failed.\n"
  exit_code: -6
  status: Exception
