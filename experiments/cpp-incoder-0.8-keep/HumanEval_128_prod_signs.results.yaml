name: HumanEval_128_prod_signs
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long res = 1;\n  for\
    \ (int i = 0; i < arr.size(); ++i) {\n    res *= arr[i];\n    long mul = 1;\n\
    \    for (int j = 0; j < i; ++j) {\n      mul *= arr[j];\n      if (mul < 0) {\n\
    \        res = -1;\n        break;\n      }\n    }\n  }\n  return res;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzbqyjzgd.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzbqyjzgd.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzbqyjzgd.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzbqyjzgd.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzbqyjzgd.cpp:2:\n/tmp/tmpzbqyjzgd.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzbqyjzgd.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzbqyjzgd.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzbqyjzgd.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzbqyjzgd.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzbqyjzgd.cpp:2:\n/tmp/tmpzbqyjzgd.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::priority_queue<int,\
    \ std::vector<long>, std::greater<int>> pq;\n    long ans = 0;\n    for (long\
    \ i : arr) {\n        int sign = i % 3;\n        pq.push(-sign * i);\n    }\n\
    \    for (long i = 0; !pq.empty(); i++) {\n        long val = pq.top();\n    \
    \    pq.pop();\n        if (val != 0) ans++;\n        ans *= val;\n    }\n   \
    \ return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4vujn5yo.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4vujn5yo.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4vujn5yo.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4vujn5yo.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4vujn5yo.cpp:2:\n/tmp/tmp4vujn5yo.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4vujn5yo.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4vujn5yo.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4vujn5yo.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4vujn5yo.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4vujn5yo.cpp:2:\n/tmp/tmp4vujn5yo.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int n = arr.size();\n    long ans = 0;\n    for (int\
    \ i = 0; i < n; i++)\n        ans += arr[i] * std::signbit(arr[i]);\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp25ohao6s.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp25ohao6s.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp25ohao6s.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp25ohao6s.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp25ohao6s.cpp:2:\n/tmp/tmp25ohao6s.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp25ohao6s.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp25ohao6s.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp25ohao6s.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp25ohao6s.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp25ohao6s.cpp:2:\n/tmp/tmp25ohao6s.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 0;\n\
    \    for(auto& elem : arr) {\n        if(elem == 0) {\n            return std::nullopt;\n\
    \        }\n        long m = 1;\n        for(int i = 1; i <= elem; i++) {\n  \
    \          m *= elem;\n        }\n        result += m * elem;\n    }\n    return\
    \ std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6ae6e71_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6ae6e71_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6ae6e71_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6ae6e71_.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6ae6e71_.cpp:2:\n/tmp/tmp6ae6e71_.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6ae6e71_.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6ae6e71_.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6ae6e71_.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6ae6e71_.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6ae6e71_.cpp:2:\n/tmp/tmp6ae6e71_.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long prod = 1;\n  for (auto& e : arr) {\n    prod *= e;\n \
    \ }\n  auto ret = std::abs(prod);\n  for (auto& e : arr) {\n    if (e < 0) {\n\
    \      ret *= -1;\n    }\n  }\n  return ret;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpjdkymdgn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjdkymdgn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjdkymdgn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjdkymdgn.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjdkymdgn.cpp:2:\n/tmp/tmpjdkymdgn.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjdkymdgn.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjdkymdgn.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjdkymdgn.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjdkymdgn.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjdkymdgn.cpp:2:\n/tmp/tmpjdkymdgn.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long sum = 0;\n    for (auto &val: arr)\n \
    \       sum += (val * std::abs(val));\n    return sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdci34dzr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdci34dzr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdci34dzr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdci34dzr.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdci34dzr.cpp:2:\n/tmp/tmpdci34dzr.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdci34dzr.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdci34dzr.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdci34dzr.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdci34dzr.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdci34dzr.cpp:2:\n/tmp/tmpdci34dzr.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    // Calculate the product of all signs of arr\
    \ and then calculate the sum of magnitudes\n    long long product = std::accumulate(arr.begin(),\
    \ arr.end(), 1, std::multiplies<long long>());\n    long long sum = 0;\n    for\
    \ (auto i : arr)\n        sum += abs(i);\n    long long result = product * sum;\n\
    \    if (result == 0)\n        result = std::numeric_limits<long long>::max();\n\
    \    return result < 0 ? std::nullopt : result;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmptsq_336h.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmptsq_336h.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmptsq_336h.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmptsq_336h.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptsq_336h.cpp:2:\n/tmp/tmptsq_336h.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmptsq_336h.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmptsq_336h.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmptsq_336h.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmptsq_336h.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmptsq_336h.cpp:2:\n/tmp/tmptsq_336h.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    int n = arr.size();\n    long prod = 0;\n \
    \   for (int i = 0; i != n; ++i) {\n        bool sign = arr[i] >= 0;\n       \
    \ if (sign)\n            prod *= -1;\n        prod *= sign;\n    }\n    return\
    \ prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqg5ggrjr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqg5ggrjr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqg5ggrjr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqg5ggrjr.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqg5ggrjr.cpp:2:\n/tmp/tmpqg5ggrjr.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqg5ggrjr.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqg5ggrjr.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqg5ggrjr.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqg5ggrjr.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqg5ggrjr.cpp:2:\n/tmp/tmpqg5ggrjr.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if(arr.empty())\n\
    \        return std::nullopt;\n    auto size = arr.size();\n    long ret = 1;\n\
    \    for(long i = 0; i < size; ++i) {\n        auto num = arr[i];\n        if(num\
    \ < 0)\n            num = -num;\n        else if(num > 0)\n            num = -num;\n\
    \        else\n            num = 1;\n        for(long j = 0; j < size; ++j)\n\
    \            ret *= num;\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpg8e0k6sj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpg8e0k6sj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpg8e0k6sj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpg8e0k6sj.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg8e0k6sj.cpp:2:\n/tmp/tmpg8e0k6sj.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpg8e0k6sj.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpg8e0k6sj.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpg8e0k6sj.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpg8e0k6sj.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg8e0k6sj.cpp:2:\n/tmp/tmpg8e0k6sj.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long ans = 1;\n  for (const auto &it : arr) {\n    ans *= it;\n\
    \    ans -= it > 0;\n    ans -= it < 0;\n  }\n  return ans;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpojs7qtr6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpojs7qtr6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpojs7qtr6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpojs7qtr6.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpojs7qtr6.cpp:2:\n/tmp/tmpojs7qtr6.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpojs7qtr6.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpojs7qtr6.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpojs7qtr6.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpojs7qtr6.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpojs7qtr6.cpp:2:\n/tmp/tmpojs7qtr6.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  // Find the max\n  long max = *std::max_element(arr.begin(),\
    \ arr.end());\n  // For each number in the arr\n  long product = 1;\n  for (long\
    \ i: arr) {\n    product *= i;\n  }\n  // For each number in the arr\n  long sum\
    \ = 0;\n  for (long i: arr) {\n    sum += i;\n  }\n  if (product * sum == max)\
    \ return max;\n  long min_magnitude = -1;\n  for (long i: arr) {\n    min_magnitude\
    \ = std::min(min_magnitude, i);\n  }\n  // Now just check the sign\n  // If max\
    \ is positive, multiply by -1\n  // If max is negative, multiply by 1\n  // If\
    \ max is 0, return None\n  long result = max;\n  if (max > 0) {\n    if (product\
    \ * -1 == max) {\n      return result;\n    }\n  }\n  if (max < 0) {\n    if (product\
    \ * 1 == max) {\n      return result;\n    }\n  }\n  return std::nullopt;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpojcmtmb2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpojcmtmb2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpojcmtmb2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpojcmtmb2.cpp:48:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   48 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpojcmtmb2.cpp:2:\n/tmp/tmpojcmtmb2.cpp:49:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   49 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpojcmtmb2.cpp:49:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpojcmtmb2.cpp:49:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   49 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpojcmtmb2.cpp:49:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpojcmtmb2.cpp:49:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   49 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpojcmtmb2.cpp:2:\n/tmp/tmpojcmtmb2.cpp:49:5: note:\
    \ to match this \u2018(\u2019\n   49 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sum = 0;\n    for (auto num : arr)\n        prod *= num;\n    for (auto\
    \ num : arr)\n        sum += std::abs(num) * std::signbit(num);\n    if (sum ==\
    \ prod)\n        return prod;\n    return std::nullopt;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqzrkyxe6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqzrkyxe6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqzrkyxe6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqzrkyxe6.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqzrkyxe6.cpp:2:\n/tmp/tmpqzrkyxe6.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqzrkyxe6.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqzrkyxe6.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqzrkyxe6.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqzrkyxe6.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqzrkyxe6.cpp:2:\n/tmp/tmpqzrkyxe6.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    // You want to find out if multiplication of\
    \ all signs is possible\n    // with your given numbers.\n    // Let's find out\
    \ if multiplication of all signs is possible.\n    // We will use the fact that\
    \ if the sum of the magnitudes is\n    // greater than 0, then multiplication\
    \ of all signs is possible.\n    auto p = std::accumulate(arr.begin(), arr.end(),\
    \ 0LL);\n    if (p > 0)\n        return std::optional<long>(arr.size());\n   \
    \ // Now we know that multiplication of all signs is not possible.\n    // Let's\
    \ see if the sign of at least one number is opposite sign of \n    // the others.\n\
    \    // If any number is negative, then multiplication of all signs is\n    //\
    \ possible.\n    auto p1 = std::accumulate(arr.begin(), arr.end(), 0LL);\n   \
    \ if (p1 > 0)\n        return std::optional<long>(arr.size());\n    // If all\
    \ numbers are positive, then multiplication of all signs is\n    // impossible.\n\
    \    return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxobhym4e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxobhym4e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxobhym4e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxobhym4e.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxobhym4e.cpp:2:\n/tmp/tmpxobhym4e.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxobhym4e.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxobhym4e.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxobhym4e.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxobhym4e.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxobhym4e.cpp:2:\n/tmp/tmpxobhym4e.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int n = 0;\n    for (long i : arr) {\n        n =\
    \ n * i;\n    }\n    auto l = std::abs(arr[0]);\n    for (auto i : arr) {\n  \
    \      l = l * i;\n    }\n    return n;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp15na70mm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp15na70mm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp15na70mm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp15na70mm.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp15na70mm.cpp:2:\n/tmp/tmp15na70mm.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp15na70mm.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp15na70mm.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp15na70mm.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp15na70mm.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp15na70mm.cpp:2:\n/tmp/tmp15na70mm.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6114m03l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6114m03l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6114m03l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6114m03l.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6114m03l.cpp:2:\n/tmp/tmp6114m03l.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6114m03l.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6114m03l.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6114m03l.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6114m03l.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6114m03l.cpp:2:\n/tmp/tmp6114m03l.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ res=std::nullopt;\n  assert(arr.size() > 0);\n  long long prod = 1;\n  for (int\
    \ i = 0; i < (int)arr.size(); ++i) {\n    long long val = arr[i];\n    if (val\
    \ < 0) val = -val;\n    prod *= val;\n    if (prod < 0) res = std::nullopt;\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq2t9sn8r.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpq2t9sn8r.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpq2t9sn8r.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpq2t9sn8r.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq2t9sn8r.cpp:2:\n/tmp/tmpq2t9sn8r.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpq2t9sn8r.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpq2t9sn8r.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpq2t9sn8r.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpq2t9sn8r.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq2t9sn8r.cpp:2:\n/tmp/tmpq2t9sn8r.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ ret{None};\n    if (arr.size() == 0)\n        return ret;\n\n    long prod =\
    \ 1;\n    int sign = 1;\n    for (int i = 0; i < arr.size(); ++i) {\n        long\
    \ temp = arr[i];\n        if (temp < 0) {\n            sign = -1;\n          \
    \  temp = -temp;\n        }\n        prod *= sign;\n        prod *= temp;\n  \
    \  }\n\n    ret = std::abs(prod);\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgcfmi67h.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgcfmi67h.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgcfmi67h.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgcfmi67h.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgcfmi67h.cpp:2:\n/tmp/tmpgcfmi67h.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgcfmi67h.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgcfmi67h.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgcfmi67h.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgcfmi67h.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgcfmi67h.cpp:2:\n/tmp/tmpgcfmi67h.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  long sum = 0;\n  for (int i = 0; i < n; ++i) {\n    sum += std::abs(arr[i]);\n\
    \  }\n\n  long prod = 1;\n  for (int i = 0; i < n; ++i) {\n    prod *= (arr[i]\
    \ > 0) ? 1 : -1;\n  }\n\n  long product = prod;\n  while (product != 0) {\n  \
    \  int flag = product % 2 == 1;\n    product /= 2;\n    if (flag != (sum % 2 ==\
    \ 1)) {\n      return std::nullopt;\n    }\n    sum += sum;\n  }\n  return sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfmomb0la.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfmomb0la.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfmomb0la.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfmomb0la.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfmomb0la.cpp:2:\n/tmp/tmpfmomb0la.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfmomb0la.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfmomb0la.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfmomb0la.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfmomb0la.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfmomb0la.cpp:2:\n/tmp/tmpfmomb0la.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long long n = std::accumulate(arr.begin(), arr.end(),\
    \ 0);\n    long long res = 0;\n    for (long long v : arr) {\n        res *= v;\n\
    \        res += v * std::signbit(v);\n    }\n    if (res != n) return std::nullopt;\n\
    \    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2jtv0tz8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2jtv0tz8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2jtv0tz8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2jtv0tz8.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2jtv0tz8.cpp:2:\n/tmp/tmp2jtv0tz8.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2jtv0tz8.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2jtv0tz8.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2jtv0tz8.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2jtv0tz8.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2jtv0tz8.cpp:2:\n/tmp/tmp2jtv0tz8.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long prod = 1;\n    for (int i :\
    \ arr) {\n        prod *= i;\n    }\n    long sum = 0;\n    for (int i : arr)\
    \ {\n        if (i == 0) {\n            continue;\n        }\n        sum += std::abs(i);\n\
    \    }\n    return std::make_pair(sum, prod);\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpt2l4ytpz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpt2l4ytpz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpt2l4ytpz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpt2l4ytpz.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2l4ytpz.cpp:2:\n/tmp/tmpt2l4ytpz.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpt2l4ytpz.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpt2l4ytpz.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpt2l4ytpz.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpt2l4ytpz.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt2l4ytpz.cpp:2:\n/tmp/tmpt2l4ytpz.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::unordered_map<long,\
    \ long> counts;\n  for (long i : arr) {\n    counts[i] = counts[i] + 1;\n  }\n\
    \  // We are doing it in a separate loop just to see how it works\n  // so as\
    \ to see what is the value that we get for empty array\n  // and also for array\
    \ having multiple equal elements\n  // Example:\n  // >>> prod_signs([1, 2, 2,\
    \ -4]) == -9\n  // >>> prod_signs([0, 1, 1]) == -1\n  // >>> prod_signs([]) ==\
    \ None\n  for (long i : arr) {\n    long count = (counts.at(i) > 0) ? counts.at(i)\
    \ : 1;\n    counts[i] = counts[i] * count;\n  }\n  long max = 0;\n  for (auto\
    \ itr = counts.begin(); itr != counts.end(); ++itr) {\n    if (itr->second > max)\
    \ {\n      max = itr->second;\n    }\n  }\n  for (auto itr = counts.begin(); itr\
    \ != counts.end(); ++itr) {\n    if (itr->second > 1) {\n      return std::optional<long>(itr->first\
    \ * itr->second * max);\n    }\n  }\n  return std::nullopt;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjinlo_hc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjinlo_hc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjinlo_hc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjinlo_hc.cpp:41:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   41 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjinlo_hc.cpp:2:\n/tmp/tmpjinlo_hc.cpp:42:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjinlo_hc.cpp:42:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjinlo_hc.cpp:42:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjinlo_hc.cpp:42:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjinlo_hc.cpp:42:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjinlo_hc.cpp:2:\n/tmp/tmpjinlo_hc.cpp:42:5: note:\
    \ to match this \u2018(\u2019\n   42 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // write your code\
    \ here\n    return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_6p25ak5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_6p25ak5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_6p25ak5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_6p25ak5.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_6p25ak5.cpp:2:\n/tmp/tmp_6p25ak5.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_6p25ak5.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_6p25ak5.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_6p25ak5.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_6p25ak5.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_6p25ak5.cpp:2:\n/tmp/tmp_6p25ak5.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.size() == 0)\
    \ {\n    return std::nullopt;\n  }\n\n  // Sum magnitude of all the elements\n\
    \  long long s = std::accumulate(arr.begin(), arr.end(), 0);\n\n  // Product of\
    \ all signs\n  long long p = 1;\n  for (long long val : arr) {\n    p = p * abs(val);\n\
    \  }\n\n  return s * p;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpa9tvus7r.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa9tvus7r.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa9tvus7r.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa9tvus7r.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa9tvus7r.cpp:2:\n/tmp/tmpa9tvus7r.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa9tvus7r.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa9tvus7r.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa9tvus7r.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa9tvus7r.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa9tvus7r.cpp:2:\n/tmp/tmpa9tvus7r.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Write your code\
    \ here\n  long sum = 0;\n  long sign = 1;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    if (arr[i] < 0) {\n      sign *= -1;\n    } else if (arr[i] == 0) {\n\
    \      return std::nullopt;\n    }\n    sum += sign * arr[i];\n  }\n  return sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9ts1fovo.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9ts1fovo.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9ts1fovo.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9ts1fovo.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ts1fovo.cpp:2:\n/tmp/tmp9ts1fovo.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9ts1fovo.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9ts1fovo.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9ts1fovo.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9ts1fovo.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ts1fovo.cpp:2:\n/tmp/tmp9ts1fovo.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() <=\
    \ 1) return {};\n    // O(mlogm) time complexity\n    auto m = arr.size();\n \
    \   auto ret = std::make_optional<long>();\n    std::sort(arr.begin(), arr.end(),\
    \ std::greater<>{});\n    for (long i = 0; i < m; i++) {\n        auto prev =\
    \ arr[i], curr = prev;\n        // O(m) time complexity\n        while (std::find(arr.begin(),\
    \ arr.end(), curr) == arr.end())\n            prev = curr;\n        if (curr ==\
    \ prev) continue;\n        // O(m) time complexity\n        for (long j = i+1;\
    \ j < m; j++) {\n            auto next = arr[j], diff = curr - next;\n       \
    \     if (diff == prev || diff == next) break;\n        }\n        // O(m) time\
    \ complexity\n        long product = std::abs(diff) * std::abs(prev) - std::abs(diff)\
    \ * std::abs(next);\n        if (product == 0) {\n            // None of the number\
    \ in the array is 0, therefore sum is positive.\n            // We just need to\
    \ add these two magnitudes to ret\n            ret.emplace(product + std::abs(prev));\n\
    \        } else {\n            ret.emplace(product);\n        }\n    }\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwig7eamy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwig7eamy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwig7eamy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwig7eamy.cpp:41:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   41 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwig7eamy.cpp:2:\n/tmp/tmpwig7eamy.cpp:42:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwig7eamy.cpp:42:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwig7eamy.cpp:42:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwig7eamy.cpp:42:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwig7eamy.cpp:42:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   42 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwig7eamy.cpp:2:\n/tmp/tmpwig7eamy.cpp:42:5: note:\
    \ to match this \u2018(\u2019\n   42 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n    long result = 1;\n    for (int i = 0;\
    \ i < arr.size(); i++)\n    {\n        long tmp = arr[i] * (arr[i] > 0 ? 1 : -1);\n\
    \        result *= tmp;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplaocmncj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplaocmncj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplaocmncj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplaocmncj.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplaocmncj.cpp:2:\n/tmp/tmplaocmncj.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplaocmncj.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplaocmncj.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplaocmncj.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplaocmncj.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplaocmncj.cpp:2:\n/tmp/tmplaocmncj.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long ans = 0;\n  std::for_each(arr.begin(),\
    \ arr.end(), [&](long &i) { ans += i * i * i / i; });\n  return std::optional<long>(ans);\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb3n3e29q.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb3n3e29q.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb3n3e29q.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb3n3e29q.cpp:17:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   17 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb3n3e29q.cpp:2:\n/tmp/tmpb3n3e29q.cpp:18:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb3n3e29q.cpp:18:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb3n3e29q.cpp:18:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb3n3e29q.cpp:18:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb3n3e29q.cpp:18:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb3n3e29q.cpp:2:\n/tmp/tmpb3n3e29q.cpp:18:5: note:\
    \ to match this \u2018(\u2019\n   18 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(arr.size()\
    \ > 0);\n    auto ans = arr[0];\n    for (int i = 1; i < arr.size(); ++i) {\n\
    \        ans *= arr[i];\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpttbmoa5z.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpttbmoa5z.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpttbmoa5z.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpttbmoa5z.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpttbmoa5z.cpp:2:\n/tmp/tmpttbmoa5z.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpttbmoa5z.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpttbmoa5z.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpttbmoa5z.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpttbmoa5z.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpttbmoa5z.cpp:2:\n/tmp/tmpttbmoa5z.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = arr[0];\n    for (int i = 1; i <\
    \ arr.size(); ++i) {\n        res *= arr[i];\n        if (arr[i] < 0)\n      \
    \      arr[i] *= -1;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp2ts0ww7u.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2ts0ww7u.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2ts0ww7u.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2ts0ww7u.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ts0ww7u.cpp:2:\n/tmp/tmp2ts0ww7u.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2ts0ww7u.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2ts0ww7u.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2ts0ww7u.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2ts0ww7u.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2ts0ww7u.cpp:2:\n/tmp/tmp2ts0ww7u.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n\n    int sign = 1;\n    long res = 0;\n    for (int\
    \ i = 0; i < arr.size(); ++i) {\n        if (arr[i] < 0) sign = -1;\n        else\
    \ if (arr[i] > 0) sign = 1;\n        res += arr[i] * sign;\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp29ocb9wm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp29ocb9wm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp29ocb9wm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp29ocb9wm.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp29ocb9wm.cpp:2:\n/tmp/tmp29ocb9wm.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp29ocb9wm.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp29ocb9wm.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp29ocb9wm.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp29ocb9wm.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp29ocb9wm.cpp:2:\n/tmp/tmp29ocb9wm.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long result = std::numeric_limits<long>::max();\n\
    \  for (auto x : arr)\n    if (x < 0)\n      result = std::min(result, x * -1);\n\
    \    else\n      result = std::min(result, x * 1);\n  return result;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7u_nl988.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7u_nl988.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7u_nl988.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7u_nl988.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7u_nl988.cpp:2:\n/tmp/tmp7u_nl988.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7u_nl988.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7u_nl988.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7u_nl988.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7u_nl988.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7u_nl988.cpp:2:\n/tmp/tmp7u_nl988.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpbu_o3f_e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbu_o3f_e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbu_o3f_e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbu_o3f_e.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbu_o3f_e.cpp:2:\n/tmp/tmpbu_o3f_e.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbu_o3f_e.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbu_o3f_e.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbu_o3f_e.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbu_o3f_e.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbu_o3f_e.cpp:2:\n/tmp/tmpbu_o3f_e.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long ans = 0, s = 0;\n    for (auto v : arr)\n\
    \        s = s * v;\n    for (auto v : arr) {\n        ans = ans + std::abs(v)\
    \ * s;\n        s *= v;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4xdswqha.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4xdswqha.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4xdswqha.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4xdswqha.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4xdswqha.cpp:2:\n/tmp/tmp4xdswqha.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4xdswqha.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4xdswqha.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4xdswqha.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4xdswqha.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4xdswqha.cpp:2:\n/tmp/tmp4xdswqha.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Your code here\n\
    \  return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpef1rkzbe.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpef1rkzbe.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpef1rkzbe.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpef1rkzbe.cpp:16:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   16 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpef1rkzbe.cpp:2:\n/tmp/tmpef1rkzbe.cpp:17:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpef1rkzbe.cpp:17:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpef1rkzbe.cpp:17:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpef1rkzbe.cpp:17:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpef1rkzbe.cpp:17:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   17 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpef1rkzbe.cpp:2:\n/tmp/tmpef1rkzbe.cpp:17:5: note:\
    \ to match this \u2018(\u2019\n   17 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int sz = arr.size();\n    // Magnitude of 0 is 0\n\
    \    // Magnitude of any other number is non-zero\n    std::vector<bool> signs(sz,\
    \ true);\n    for (int i = 0; i < sz; i++) {\n        // Multiply by 1 for all\
    \ non-zero numbers\n        if (signs[i]) arr[i] = 1L;\n    }\n    // Product\
    \ of signs is product of all numbers in the array\n    long ans = 0;\n    for\
    \ (int i = 0; i < sz; i++) {\n        if (signs[i]) {\n            ans += std::abs(arr[i]);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpti0xc6le.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpti0xc6le.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpti0xc6le.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpti0xc6le.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpti0xc6le.cpp:2:\n/tmp/tmpti0xc6le.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpti0xc6le.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpti0xc6le.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpti0xc6le.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpti0xc6le.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpti0xc6le.cpp:2:\n/tmp/tmpti0xc6le.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return None;\n    }\n    int n = arr.size();\n    int res = 0;\n\
    \    for (int i = 0; i < n; ++i) {\n        long v = arr[i];\n        if (v <\
    \ 0) {\n            v = -v;\n        }\n        res *= v;\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu9ttjqmk.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu9ttjqmk.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu9ttjqmk.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu9ttjqmk.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu9ttjqmk.cpp:2:\n/tmp/tmpu9ttjqmk.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu9ttjqmk.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu9ttjqmk.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu9ttjqmk.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu9ttjqmk.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu9ttjqmk.cpp:2:\n/tmp/tmpu9ttjqmk.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ret = 1;\n \
    \   for (auto x : arr)\n        ret *= (x < 0) ? -1 : 1;\n    return ret;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp98_d4ffe.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp98_d4ffe.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp98_d4ffe.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp98_d4ffe.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp98_d4ffe.cpp:2:\n/tmp/tmp98_d4ffe.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp98_d4ffe.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp98_d4ffe.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp98_d4ffe.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp98_d4ffe.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp98_d4ffe.cpp:2:\n/tmp/tmp98_d4ffe.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n    long ans = arr[0];\n    for (long x :\
    \ arr)\n        ans = ans * x;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpoeshu85u.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpoeshu85u.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpoeshu85u.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpoeshu85u.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoeshu85u.cpp:2:\n/tmp/tmpoeshu85u.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpoeshu85u.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpoeshu85u.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpoeshu85u.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpoeshu85u.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpoeshu85u.cpp:2:\n/tmp/tmpoeshu85u.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    \    int n = arr.size();\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        sum += arr[i] * std::signbit(arr[i]); // multiplication\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp42aaibjj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp42aaibjj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp42aaibjj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp42aaibjj.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp42aaibjj.cpp:2:\n/tmp/tmp42aaibjj.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp42aaibjj.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp42aaibjj.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp42aaibjj.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp42aaibjj.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp42aaibjj.cpp:2:\n/tmp/tmp42aaibjj.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long sum = 0;\n \
    \   for (long i : arr) sum += i * sign(i);\n    return sum;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp10byz3c4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp10byz3c4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp10byz3c4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp10byz3c4.cpp:17:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   17 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp10byz3c4.cpp:2:\n/tmp/tmp10byz3c4.cpp:18:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp10byz3c4.cpp:18:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp10byz3c4.cpp:18:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp10byz3c4.cpp:18:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp10byz3c4.cpp:18:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   18 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp10byz3c4.cpp:2:\n/tmp/tmp10byz3c4.cpp:18:5: note:\
    \ to match this \u2018(\u2019\n   18 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto begin = arr.begin();\n\
    \    auto end = arr.end();\n    auto first = begin;\n    long product = 1;\n \
    \   for (auto i = begin + 1; i < end; ++i) {\n        product *= (long long)i;\n\
    \        if (*first != 0) {\n            product *= (long long)(*first) * -1;\n\
    \        }\n        product *= *i;\n    }\n    if (product == 0)\n        return\
    \ {};\n    return product;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp2haz40fu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2haz40fu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2haz40fu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2haz40fu.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2haz40fu.cpp:2:\n/tmp/tmp2haz40fu.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2haz40fu.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2haz40fu.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2haz40fu.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2haz40fu.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2haz40fu.cpp:2:\n/tmp/tmp2haz40fu.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int N = arr.size();\n\
    \    if (N == 0)\n        return std::nullopt;\n    // sum: sum of magnitudes\
    \ of arr[i] multiplied by product of sign of arr[i]\n    long long sum = 0;\n\
    \    // product: product of sign of arr[i]\n    long long product = 1;\n    for\
    \ (int i = 0; i < N; i++) {\n        long long x = abs(arr[i]);\n        sum +=\
    \ x * product;\n        product *= (x == 0 ? -1 : 1);\n    }\n    if (sum != 0)\n\
    \        return sum;\n    return std::nullopt;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0hgruvfh.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0hgruvfh.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0hgruvfh.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0hgruvfh.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0hgruvfh.cpp:2:\n/tmp/tmp0hgruvfh.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0hgruvfh.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0hgruvfh.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0hgruvfh.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0hgruvfh.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0hgruvfh.cpp:2:\n/tmp/tmp0hgruvfh.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ retval = std::nullopt;\n  if (arr.size() > 0) {\n    long res = 0;\n    for\
    \ (long v : arr) {\n      if (v < 0) {\n        res *= -1;\n      } else if (v\
    \ > 0) {\n        res += v;\n      }\n    }\n    retval = res;\n  }\n  return\
    \ retval;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpssz4dh28.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpssz4dh28.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpssz4dh28.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpssz4dh28.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpssz4dh28.cpp:2:\n/tmp/tmpssz4dh28.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpssz4dh28.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpssz4dh28.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpssz4dh28.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpssz4dh28.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpssz4dh28.cpp:2:\n/tmp/tmpssz4dh28.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long product = 1;\n    for (long i : arr) {\n    \
    \    product *= i;\n        product *= (i < 0) ? -1 : 1;\n    }\n    return product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjw7i1ehx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjw7i1ehx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjw7i1ehx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjw7i1ehx.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjw7i1ehx.cpp:2:\n/tmp/tmpjw7i1ehx.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjw7i1ehx.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjw7i1ehx.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjw7i1ehx.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjw7i1ehx.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjw7i1ehx.cpp:2:\n/tmp/tmpjw7i1ehx.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if(arr.empty()){\n\
    \    return std::nullopt;\n  }\n  long product = 1;\n  long sum = 0;\n  for(auto\
    \ val : arr){\n    sum += abs(val);\n    product *= val;\n  }\n  return sum *\
    \ product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgk9t21we.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgk9t21we.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgk9t21we.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgk9t21we.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgk9t21we.cpp:2:\n/tmp/tmpgk9t21we.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgk9t21we.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgk9t21we.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgk9t21we.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgk9t21we.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgk9t21we.cpp:2:\n/tmp/tmpgk9t21we.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ret = 0;\n \
    \   bool flag = false;\n    for (int i = 0; i < arr.size(); i++) {\n        ret\
    \ = ret * (arr[i] < 0 ? 1 : -1) * arr[i];\n        if (arr[i] >= 0) flag = true;\n\
    \    }\n    if (flag) return ret;\n    else return std::nullopt;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpneddxmbv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpneddxmbv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpneddxmbv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpneddxmbv.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpneddxmbv.cpp:2:\n/tmp/tmpneddxmbv.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpneddxmbv.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpneddxmbv.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpneddxmbv.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpneddxmbv.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpneddxmbv.cpp:2:\n/tmp/tmpneddxmbv.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Write your code\
    \ here\n  long ans = 0;\n  long max = std::numeric_limits<long>::min();\n  for\
    \ (int i = 0; i < arr.size(); i++) {\n    if (arr[i] > max) {\n      ans = -ans;\n\
    \      max = arr[i];\n    } else {\n      ans += arr[i] * std::sign(arr[i]);\n\
    \    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_4co4u4m.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_4co4u4m.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_4co4u4m.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_4co4u4m.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_4co4u4m.cpp:2:\n/tmp/tmp_4co4u4m.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_4co4u4m.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_4co4u4m.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_4co4u4m.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_4co4u4m.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_4co4u4m.cpp:2:\n/tmp/tmp_4co4u4m.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return None;\n    std::unordered_map<long, long> mp;\n    for (long v : arr)\
    \ {\n        mp[abs(v)] += 1;\n    }\n    long prod = 1;\n    for (auto& kv :\
    \ mp) {\n        prod *= kv.second;\n    }\n    long sum = 0;\n    for (long v\
    \ : arr) {\n        sum += abs(v) * mp[abs(v)];\n    }\n    return std::max(std::min(sum,\
    \ prod), 0);\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp32_5fij2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp32_5fij2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp32_5fij2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp32_5fij2.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp32_5fij2.cpp:2:\n/tmp/tmp32_5fij2.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp32_5fij2.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp32_5fij2.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp32_5fij2.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp32_5fij2.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp32_5fij2.cpp:2:\n/tmp/tmp32_5fij2.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if(arr.empty()) return\
    \ std::nullopt;\n    int n = arr.size();\n    long prod = 0;\n    long sum = 0;\n\
    \    for(int i = 0; i < n; ++i){\n        long x = arr[i];\n        // Multiply\
    \ the magnitude of x\n        sum += x*x;\n        // Multiply the sign of x\n\
    \        prod *= x;\n    }\n    // Return product of magnitudes of numbers\n \
    \   return std::optional{sum/prod};\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpatyuvfi9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpatyuvfi9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpatyuvfi9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpatyuvfi9.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpatyuvfi9.cpp:2:\n/tmp/tmpatyuvfi9.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpatyuvfi9.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpatyuvfi9.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpatyuvfi9.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpatyuvfi9.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpatyuvfi9.cpp:2:\n/tmp/tmpatyuvfi9.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return None;\n  long product = 1;\n  for (auto i : arr) {\n    product *=\
    \ i;\n  }\n  if (product < 0)\n    return -1;\n  else if (product > 0)\n    return\
    \ 1;\n  else\n    return 0;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfcre769v.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfcre769v.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfcre769v.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfcre769v.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfcre769v.cpp:2:\n/tmp/tmpfcre769v.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfcre769v.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfcre769v.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfcre769v.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfcre769v.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfcre769v.cpp:2:\n/tmp/tmpfcre769v.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // your code goes\
    \ here\n    auto len = arr.size();\n    if (len == 0) {\n        return None;\n\
    \    }\n    long prod = 1;\n    long sign = 1;\n    long s = 0;\n    for (size_t\
    \ i = 0; i < len; i++) {\n        if (arr[i] == 0) {\n            continue;\n\
    \        }\n        s = arr[i] * sign;\n        if (arr[i] < 0) {\n          \
    \  sign = -1;\n        }\n        prod *= s;\n    }\n    return prod;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3bjzwsmq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3bjzwsmq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3bjzwsmq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3bjzwsmq.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3bjzwsmq.cpp:2:\n/tmp/tmp3bjzwsmq.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3bjzwsmq.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3bjzwsmq.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3bjzwsmq.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3bjzwsmq.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3bjzwsmq.cpp:2:\n/tmp/tmp3bjzwsmq.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if(arr.empty()) {\n\
    \    return std::nullopt;\n  }\n\n  int n = arr.size();\n\n  long res = 1;\n \
    \ for(int i = 0; i < n; i++) {\n    res = res * arr[i];\n  }\n\n  if(res > 0)\
    \ {\n    return res;\n  }\n  if(res < 0) {\n    return -res;\n  }\n\n  for(int\
    \ i = 0; i < n; i++) {\n    res = res * arr[i] % 3;\n  }\n\n  return res;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuskl32yy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpuskl32yy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpuskl32yy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpuskl32yy.cpp:37:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   37 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuskl32yy.cpp:2:\n/tmp/tmpuskl32yy.cpp:38:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpuskl32yy.cpp:38:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpuskl32yy.cpp:38:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpuskl32yy.cpp:38:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpuskl32yy.cpp:38:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuskl32yy.cpp:2:\n/tmp/tmpuskl32yy.cpp:38:5: note:\
    \ to match this \u2018(\u2019\n   38 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int N = arr.size();\n\
    \  if (N < 2) return none;\n  // For each element, calculate sum of its signs\n\
    \  long sum = 0;\n  for (int i = 0; i < (int)arr.size(); ++i)\n    sum += arr[i]\
    \ < 0 ? -1 : 1;\n  // Product of all signs\n  long product = 1;\n  for (int i\
    \ = 0; i < (int)arr.size(); ++i)\n    product *= arr[i] < 0 ? -1 : 1;\n  return\
    \ product*sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplwtse2v1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplwtse2v1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplwtse2v1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplwtse2v1.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplwtse2v1.cpp:2:\n/tmp/tmplwtse2v1.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplwtse2v1.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplwtse2v1.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplwtse2v1.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplwtse2v1.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplwtse2v1.cpp:2:\n/tmp/tmplwtse2v1.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long res = 0;\n \
    \   for (auto i: arr) {\n        res += i * sign(i);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3lfwnhj6.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3lfwnhj6.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3lfwnhj6.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3lfwnhj6.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3lfwnhj6.cpp:2:\n/tmp/tmp3lfwnhj6.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3lfwnhj6.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3lfwnhj6.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3lfwnhj6.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3lfwnhj6.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3lfwnhj6.cpp:2:\n/tmp/tmp3lfwnhj6.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return {};\n    int ret = 1;\n    for (auto i : arr) {\n        ret *= i;\n\
    \        ret *= (std::signbit(i) ? -1 : 0);\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpuzad1nou.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpuzad1nou.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpuzad1nou.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpuzad1nou.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuzad1nou.cpp:2:\n/tmp/tmpuzad1nou.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpuzad1nou.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpuzad1nou.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpuzad1nou.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpuzad1nou.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpuzad1nou.cpp:2:\n/tmp/tmpuzad1nou.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.size() == 0)\n\
    \    return std::nullopt;\n  long ans = 0, sign = 1;\n  for (auto i : arr)\n \
    \   sign *= i;\n  for (auto i : arr)\n    ans += (sign * i) * std::abs(i);\n \
    \ return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmgq8u8mb.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpmgq8u8mb.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpmgq8u8mb.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpmgq8u8mb.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmgq8u8mb.cpp:2:\n/tmp/tmpmgq8u8mb.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpmgq8u8mb.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpmgq8u8mb.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpmgq8u8mb.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpmgq8u8mb.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmgq8u8mb.cpp:2:\n/tmp/tmpmgq8u8mb.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto size = arr.size();\n\
    \    if (size == 0) {\n        return std::nullopt;\n    }\n    int sign = 1;\n\
    \    long prod = 1;\n    long sum = 0;\n    long product = 1;\n    for (auto i\
    \ = 0; i < size; i++) {\n        sum += sign * arr[i];\n        product *= sign;\n\
    \        sign *= -1;\n    }\n    return sum == 0 ? product : std::nullopt;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2yhfw8l5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2yhfw8l5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2yhfw8l5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2yhfw8l5.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2yhfw8l5.cpp:2:\n/tmp/tmp2yhfw8l5.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2yhfw8l5.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2yhfw8l5.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2yhfw8l5.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2yhfw8l5.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2yhfw8l5.cpp:2:\n/tmp/tmp2yhfw8l5.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    long ret = 0;\n    for (int i = 0; i < n; i++)\n        ret += std::abs(arr[i])\
    \ * std::signbit(arr[i]) ? 1 : 0;\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz98jthon.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpz98jthon.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpz98jthon.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpz98jthon.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz98jthon.cpp:2:\n/tmp/tmpz98jthon.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpz98jthon.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpz98jthon.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpz98jthon.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpz98jthon.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz98jthon.cpp:2:\n/tmp/tmpz98jthon.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ sum_signs;\n    if(arr.empty()) {\n        return sum_signs;\n    }\n\n    auto\
    \ first_el = arr.front();\n    for(long i: arr) {\n        sum_signs = std::max(sum_signs,\
    \ i*first_el*std::signbit(i));\n    }\n\n    return sum_signs;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq6hi89is.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpq6hi89is.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpq6hi89is.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpq6hi89is.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq6hi89is.cpp:2:\n/tmp/tmpq6hi89is.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpq6hi89is.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpq6hi89is.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpq6hi89is.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpq6hi89is.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq6hi89is.cpp:2:\n/tmp/tmpq6hi89is.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    auto it = arr.begin();\n    auto\
    \ end = arr.end();\n    while (it != end) {\n        long temp = *it * std::signbit(*it);\n\
    \        if (temp == 0) {\n            continue;\n        } else {\n         \
    \   ++it;\n        }\n    }\n    return std::make_optional(std::accumulate(arr.begin(),\
    \ arr.end(), 0));\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl67_g657.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl67_g657.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl67_g657.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl67_g657.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl67_g657.cpp:2:\n/tmp/tmpl67_g657.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl67_g657.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl67_g657.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl67_g657.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl67_g657.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl67_g657.cpp:2:\n/tmp/tmpl67_g657.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    if (arr.size() == 0) return None;\n    long s = 0;\n    for (auto\
    \ x : arr) {\n        s = s * x + (x < 0);\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpivj4kb8l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpivj4kb8l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpivj4kb8l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpivj4kb8l.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpivj4kb8l.cpp:2:\n/tmp/tmpivj4kb8l.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpivj4kb8l.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpivj4kb8l.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpivj4kb8l.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpivj4kb8l.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpivj4kb8l.cpp:2:\n/tmp/tmpivj4kb8l.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    int n = arr.size();\n    // sum = 0\n    long\
    \ sum = 0;\n    // product = 1\n    long product = 1;\n    // sign\n    long sign\
    \ = 1;\n    for (int i = 0; i < n; i++) {\n        // sum += abs(arr[i])\n   \
    \     sum += std::abs(arr[i]);\n        // product *= sign\n        product *=\
    \ sign;\n        // sign *= -1\n        sign *= -1;\n    }\n    // product *=\
    \ sum\n    product *= sum;\n    // return product if all sign magnitude positive\n\
    \    return product if sign == 1;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpier7i2uz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpier7i2uz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpier7i2uz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpier7i2uz.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpier7i2uz.cpp:2:\n/tmp/tmpier7i2uz.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpier7i2uz.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpier7i2uz.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpier7i2uz.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpier7i2uz.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpier7i2uz.cpp:2:\n/tmp/tmpier7i2uz.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    \    if(arr.size() == 0)\n        return std::nullopt;\n    long long prod = 1;\n\
    \    for(auto &x : arr)\n        prod *= x;\n    for(auto &x : arr)\n        prod\
    \ *= x;\n    return prod;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpqyswp30w.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpqyswp30w.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpqyswp30w.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpqyswp30w.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqyswp30w.cpp:2:\n/tmp/tmpqyswp30w.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpqyswp30w.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpqyswp30w.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpqyswp30w.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpqyswp30w.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpqyswp30w.cpp:2:\n/tmp/tmpqyswp30w.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  assert(arr.size() >\
    \ 0);\n  long long ans = 0;\n  for (long i = 0; i != arr.size(); ++i) {\n    long\
    \ long tmp = 0;\n    for (long j = 0; j != arr.size(); ++j) {\n      if (i !=\
    \ j) {\n        tmp *= arr[j];\n      }\n    }\n    for (long j = 0; j != arr.size();\
    \ ++j) {\n      ans += abs(tmp * arr[j]);\n    }\n  }\n  return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplm0ufpy_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplm0ufpy_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplm0ufpy_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplm0ufpy_.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplm0ufpy_.cpp:2:\n/tmp/tmplm0ufpy_.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplm0ufpy_.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplm0ufpy_.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplm0ufpy_.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplm0ufpy_.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplm0ufpy_.cpp:2:\n/tmp/tmplm0ufpy_.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ res = std::nullopt;\n  // Write your code here\n  long m = 0, n = 0;\n  for\
    \ (long i : arr) {\n    m = (arr[i] * n) + (m * (long) arr[i]);\n    n = (arr[i]\
    \ * m) + (n * arr[i]);\n  }\n  if (m < 0) {\n    m = -m * -1;\n  }\n  res = {m};\n\
    \  return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmplppw5bxe.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplppw5bxe.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplppw5bxe.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplppw5bxe.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplppw5bxe.cpp:2:\n/tmp/tmplppw5bxe.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplppw5bxe.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplppw5bxe.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplppw5bxe.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplppw5bxe.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplppw5bxe.cpp:2:\n/tmp/tmplppw5bxe.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto it = arr.begin();\n\
    \    long sum = 0;\n    while (it != arr.end()) {\n        sum += *it;\n     \
    \   ++it;\n    }\n    if (sum == 0) {\n        return none;\n    }\n    for (;\
    \ it != arr.end(); ++it) {\n        long mul = 1;\n        for (; it != arr.end();\
    \ ++it) {\n            mul *= *it;\n        }\n        if (mul < 0) {\n      \
    \      mul *= -1;\n        }\n        sum += mul;\n    }\n    return sum;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzx69a682.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpzx69a682.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpzx69a682.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpzx69a682.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzx69a682.cpp:2:\n/tmp/tmpzx69a682.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpzx69a682.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpzx69a682.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpzx69a682.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpzx69a682.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpzx69a682.cpp:2:\n/tmp/tmpzx69a682.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return None;\n  int sign = 1;\n  for (auto it : arr)\n    sign *= it * sign;\n\
    \  return sign;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpak62y2vu.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpak62y2vu.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpak62y2vu.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpak62y2vu.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpak62y2vu.cpp:2:\n/tmp/tmpak62y2vu.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpak62y2vu.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpak62y2vu.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpak62y2vu.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpak62y2vu.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpak62y2vu.cpp:2:\n/tmp/tmpak62y2vu.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long long ans = 0;\n\
    \  for (const auto& num : arr) {\n    if (num < 0) {\n      return std::nullopt;\n\
    \    }\n    ans += num;\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp4imkn0it.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4imkn0it.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4imkn0it.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4imkn0it.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4imkn0it.cpp:2:\n/tmp/tmp4imkn0it.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4imkn0it.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4imkn0it.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4imkn0it.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4imkn0it.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4imkn0it.cpp:2:\n/tmp/tmp4imkn0it.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if (n == 0) return std::nullopt;\n  long res = 0;\n  for (int i = 1; i < n;\
    \ i++) {\n    res += arr[i] * std::signbit(arr[i]);\n  }\n  return res;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf6ovhw7l.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpf6ovhw7l.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpf6ovhw7l.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpf6ovhw7l.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf6ovhw7l.cpp:2:\n/tmp/tmpf6ovhw7l.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpf6ovhw7l.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpf6ovhw7l.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpf6ovhw7l.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpf6ovhw7l.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf6ovhw7l.cpp:2:\n/tmp/tmpf6ovhw7l.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.size() < 1)\
    \ return {};\n  int s = 0;\n  for (auto& num : arr) s *= num;\n  long p = 0;\n\
    \  for (auto& num : arr) p += num;\n  if (p == 0) return {};\n  s -= p;\n  p /=\
    \ 2;\n  p += 1;\n  s *= p;\n  while (p != 0) {\n    p /= 2;\n    p += 1;\n   \
    \ s *= p;\n  }\n  return s;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxkbaj6_8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxkbaj6_8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxkbaj6_8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxkbaj6_8.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxkbaj6_8.cpp:2:\n/tmp/tmpxkbaj6_8.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxkbaj6_8.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxkbaj6_8.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxkbaj6_8.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxkbaj6_8.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxkbaj6_8.cpp:2:\n/tmp/tmpxkbaj6_8.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return None;\n    long sum = 0;\n    bool sign = true;\n    for (long &i : arr)\
    \ sum += sign * i;\n    if (sum == 0) return None;\n    long prod = 1;\n    for\
    \ (long i : arr) prod *= i;\n    long magnitude = std::abs(sum);\n    return magnitude\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp781qck40.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp781qck40.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp781qck40.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp781qck40.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp781qck40.cpp:2:\n/tmp/tmp781qck40.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp781qck40.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp781qck40.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp781qck40.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp781qck40.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp781qck40.cpp:2:\n/tmp/tmp781qck40.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long prod = 1;\n  for (auto x : arr)\n    prod *=\
    \ x;\n  long sign = 1;\n  for (auto x : arr)\n    sign = sign * x;\n  return sign\
    \ * prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnfc4p3f1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnfc4p3f1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnfc4p3f1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnfc4p3f1.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnfc4p3f1.cpp:2:\n/tmp/tmpnfc4p3f1.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnfc4p3f1.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnfc4p3f1.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnfc4p3f1.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnfc4p3f1.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnfc4p3f1.cpp:2:\n/tmp/tmpnfc4p3f1.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long product = 1;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        product = product * arr[i];\n    }\n\
    \    long product2 = 0;\n    for (long i = 0; i < arr.size(); i++) {\n       \
    \ product2 = product2 * arr[i] < 0 ? 1 : -1;\n    }\n    return product2 > 0 ?\
    \ product : std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpn9ry_fd4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpn9ry_fd4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpn9ry_fd4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpn9ry_fd4.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn9ry_fd4.cpp:2:\n/tmp/tmpn9ry_fd4.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpn9ry_fd4.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpn9ry_fd4.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpn9ry_fd4.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpn9ry_fd4.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn9ry_fd4.cpp:2:\n/tmp/tmpn9ry_fd4.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    long prod = 0;\n    for (int i = 0; i < n; i++) {\n        long sign = arr[i]\
    \ >> 63;\n        long val = arr[i] & 1LL << 63;\n        prod += sign * val *\
    \ (sign != 0);\n    }\n    return prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0z2lf9ff.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0z2lf9ff.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0z2lf9ff.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0z2lf9ff.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0z2lf9ff.cpp:2:\n/tmp/tmp0z2lf9ff.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0z2lf9ff.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0z2lf9ff.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0z2lf9ff.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0z2lf9ff.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0z2lf9ff.cpp:2:\n/tmp/tmp0z2lf9ff.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long res = 0;\n    bool bFirst = true;\n  \
    \  for (auto x : arr)\n        if (x > 0)\n            if (bFirst)\n         \
    \       res = x;\n            else {\n                long mult = 1;\n       \
    \         while (x != 0) {\n                    res = (res * mult) + ((x % 2 ==\
    \ 0) ? 1 : -1);\n                    mult = mult * 2;\n                    x /=\
    \ 2;\n                }\n                bFirst = false;\n            }\n    \
    \    else // if (x < 0)\n            if (bFirst)\n                res = x;\n \
    \           else {\n                long mult = 1;\n                while (x !=\
    \ 0) {\n                    res = (res * mult) + ((x % 2 == 0) ? -1 : 1);\n  \
    \                  mult = mult * 2;\n                    x /= 2;\n           \
    \     }\n                bFirst = false;\n            }\n    return res;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprx_kucdj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprx_kucdj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprx_kucdj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprx_kucdj.cpp:44:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   44 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx_kucdj.cpp:2:\n/tmp/tmprx_kucdj.cpp:45:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   45 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprx_kucdj.cpp:45:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprx_kucdj.cpp:45:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   45 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprx_kucdj.cpp:45:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprx_kucdj.cpp:45:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   45 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprx_kucdj.cpp:2:\n/tmp/tmprx_kucdj.cpp:45:5: note:\
    \ to match this \u2018(\u2019\n   45 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Write your code\
    \ here\n  int n = arr.size();\n  long ans = 1;\n  for (int i = 0; i < n; ++i)\
    \ {\n    ans *= arr[i];\n    ans *= sign(arr[i]);\n  }\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprdimadau.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprdimadau.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprdimadau.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprdimadau.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprdimadau.cpp:2:\n/tmp/tmprdimadau.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprdimadau.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprdimadau.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprdimadau.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprdimadau.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprdimadau.cpp:2:\n/tmp/tmprdimadau.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) return std::nullopt;\n\n    long result = 1L;\n    for (auto val : arr) {\n\
    \        long temp = val * result;\n        if (temp < 0) {\n            result\
    \ += -temp;\n        } else {\n            result += temp;\n        }\n    }\n\
    \n    return result;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpz6d96368.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpz6d96368.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpz6d96368.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpz6d96368.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz6d96368.cpp:2:\n/tmp/tmpz6d96368.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpz6d96368.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpz6d96368.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpz6d96368.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpz6d96368.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpz6d96368.cpp:2:\n/tmp/tmpz6d96368.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return None;\n  long long ans = 0;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    long long temp = arr[i] * std::signbit(arr[i]);\n    ans += temp;\n \
    \ }\n  return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj0w7tr66.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpj0w7tr66.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpj0w7tr66.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpj0w7tr66.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj0w7tr66.cpp:2:\n/tmp/tmpj0w7tr66.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpj0w7tr66.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpj0w7tr66.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpj0w7tr66.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpj0w7tr66.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj0w7tr66.cpp:2:\n/tmp/tmpj0w7tr66.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    long prod = 1;\n    long res = 0;\n    for (int i = 0; i < n; ++i) {\n  \
    \      long v = arr[i];\n        if (v < 0) {\n            prod *= -1;\n     \
    \   } else {\n            prod *= 1;\n        }\n        res += v * prod;\n  \
    \  }\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpcxljk_qn.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpcxljk_qn.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpcxljk_qn.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpcxljk_qn.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcxljk_qn.cpp:2:\n/tmp/tmpcxljk_qn.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpcxljk_qn.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpcxljk_qn.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpcxljk_qn.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpcxljk_qn.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpcxljk_qn.cpp:2:\n/tmp/tmpcxljk_qn.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy64_05qo.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpy64_05qo.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpy64_05qo.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpy64_05qo.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy64_05qo.cpp:2:\n/tmp/tmpy64_05qo.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpy64_05qo.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpy64_05qo.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpy64_05qo.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpy64_05qo.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpy64_05qo.cpp:2:\n/tmp/tmpy64_05qo.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    std::priority_queue<long, std::vector<long>, std::greater<long>>\
    \ pq(arr.begin(), arr.end());\n    long result = 0;\n    long max = 0;\n    while\
    \ (!pq.empty()) {\n        max = *pq.top();\n        pq.pop();\n        if (*pq.top()\
    \ < 0)\n            result *= -1;\n        if (*pq.top() > max)\n            result\
    \ += max;\n        else\n            result += *pq.top();\n        pq.pop();\n\
    \    }\n    return std::optional<long>(result);\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0bxrqi2e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0bxrqi2e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0bxrqi2e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0bxrqi2e.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0bxrqi2e.cpp:2:\n/tmp/tmp0bxrqi2e.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0bxrqi2e.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0bxrqi2e.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0bxrqi2e.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0bxrqi2e.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0bxrqi2e.cpp:2:\n/tmp/tmp0bxrqi2e.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::map<long, long>\
    \ result;\n  for (auto i : arr) {\n    auto sign = i % 3;\n    if (sign == 1)\
    \ result[i - 1] = 1;\n    if (sign == 2) result[i - 1] = 1;\n    if (sign == -1)\
    \ result[i - 1] = 1;\n  }\n\n  for (auto i : arr) {\n    auto sum = 0;\n    for\
    \ (auto j : result) {\n      sum *= j;\n    }\n\n    if (sum != 0) return sum;\n\
    \  }\n\n  return {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2n8wnojr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2n8wnojr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2n8wnojr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2n8wnojr.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2n8wnojr.cpp:2:\n/tmp/tmp2n8wnojr.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2n8wnojr.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2n8wnojr.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2n8wnojr.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2n8wnojr.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2n8wnojr.cpp:2:\n/tmp/tmp2n8wnojr.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 0;\n\
    \    long sign = 1;\n    for (long val : arr) {\n        result += sign * val;\n\
    \        sign *= (val > 0);\n    }\n    return result > 0 ? result : 0;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpv58km_ra.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpv58km_ra.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpv58km_ra.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpv58km_ra.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv58km_ra.cpp:2:\n/tmp/tmpv58km_ra.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpv58km_ra.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpv58km_ra.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpv58km_ra.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpv58km_ra.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpv58km_ra.cpp:2:\n/tmp/tmpv58km_ra.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long result = 1;\n\
    \    for (auto i : arr) {\n        result *= i;\n        if (result < 0)\n   \
    \         return std::nullopt;\n    }\n    return result;\n}\nint main() {\n \
    \   auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpexqkjaun.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpexqkjaun.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpexqkjaun.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpexqkjaun.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpexqkjaun.cpp:2:\n/tmp/tmpexqkjaun.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpexqkjaun.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpexqkjaun.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpexqkjaun.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpexqkjaun.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpexqkjaun.cpp:2:\n/tmp/tmpexqkjaun.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    int n = arr.size();\n    int result = 0;\n\
    \    int sign = 1;\n    // Calculate the magnitude of every number in the array\n\
    \    long long magnitude = 1;\n    for (int i = 0; i < n; ++i) {\n        magnitude\
    \ *= arr[i];\n    }\n    // Calculate the product of all signs of every number\
    \ in the array\n    for (int i = 0; i < n; ++i) {\n        result += (sign < 0)\
    \ ? arr[i] : -arr[i];\n        sign *= (sign < 0) ? 1 : -1;\n    }\n    return\
    \ result / magnitude;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpajmkd9jr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpajmkd9jr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpajmkd9jr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpajmkd9jr.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpajmkd9jr.cpp:2:\n/tmp/tmpajmkd9jr.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpajmkd9jr.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpajmkd9jr.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpajmkd9jr.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpajmkd9jr.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpajmkd9jr.cpp:2:\n/tmp/tmpajmkd9jr.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ result(std::numeric_limits<long>::min());\n    for (long n : arr) {\n      \
    \  if (n >= 0) result = std::optional<long>(result * n);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpptdt9vyy.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpptdt9vyy.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpptdt9vyy.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpptdt9vyy.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpptdt9vyy.cpp:2:\n/tmp/tmpptdt9vyy.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpptdt9vyy.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpptdt9vyy.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpptdt9vyy.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpptdt9vyy.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpptdt9vyy.cpp:2:\n/tmp/tmpptdt9vyy.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    int sign = 1;\n    long sum = 0;\n    for (auto x: arr)\n    {\n \
    \       if (x < 0) sign = -1;\n        sum += x * sign;\n    }\n    return sum\
    \ > 0;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphtdfnry8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphtdfnry8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphtdfnry8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphtdfnry8.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphtdfnry8.cpp:2:\n/tmp/tmphtdfnry8.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphtdfnry8.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphtdfnry8.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphtdfnry8.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphtdfnry8.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphtdfnry8.cpp:2:\n/tmp/tmphtdfnry8.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ret = arr[0];\n    long product = 1;\n    for\
    \ (auto i : arr) product *= i;\n    for (auto i : arr) ret += product * std::signbit(i);\n\
    \    return ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp992_rmi9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp992_rmi9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp992_rmi9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp992_rmi9.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp992_rmi9.cpp:2:\n/tmp/tmp992_rmi9.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp992_rmi9.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp992_rmi9.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp992_rmi9.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp992_rmi9.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp992_rmi9.cpp:2:\n/tmp/tmp992_rmi9.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    long sign = 1;\n    for (auto x : arr)\n        product *= x;\n        for\
    \ (auto y : arr)\n            if (y > 0)\n                product *= sign;\n \
    \               sign *= -1;\n                product *= sign;\n    return product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpa56sz67t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpa56sz67t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpa56sz67t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpa56sz67t.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa56sz67t.cpp:2:\n/tmp/tmpa56sz67t.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpa56sz67t.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpa56sz67t.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpa56sz67t.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpa56sz67t.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpa56sz67t.cpp:2:\n/tmp/tmpa56sz67t.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ret = 0;\n \
    \   for (int i = 0; i < arr.size(); i++) {\n        ret += std::abs(arr[i]);\n\
    \        ret *= std::signbit(arr[i]) ? -1 : 1;\n    }\n    return ret;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4orl4a5t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4orl4a5t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4orl4a5t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4orl4a5t.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4orl4a5t.cpp:2:\n/tmp/tmp4orl4a5t.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4orl4a5t.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4orl4a5t.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4orl4a5t.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4orl4a5t.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4orl4a5t.cpp:2:\n/tmp/tmp4orl4a5t.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  int n = arr.size();\n  long res = arr[0] * 1;\n  for (int i\
    \ = 1; i < n; ++i) {\n    res = res * arr[i];\n  }\n  return res;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpilc86apx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpilc86apx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpilc86apx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpilc86apx.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpilc86apx.cpp:2:\n/tmp/tmpilc86apx.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpilc86apx.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpilc86apx.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpilc86apx.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpilc86apx.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpilc86apx.cpp:2:\n/tmp/tmpilc86apx.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long ans = 0;\n  for (int i = 0; i < arr.size();\
    \ i++)\n    if (arr[i] > 0)\n      ans += arr[i] * std::abs(arr[i]);\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2wflt09p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2wflt09p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2wflt09p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2wflt09p.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2wflt09p.cpp:2:\n/tmp/tmp2wflt09p.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2wflt09p.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2wflt09p.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2wflt09p.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2wflt09p.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2wflt09p.cpp:2:\n/tmp/tmp2wflt09p.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto s = std::accumulate(arr.begin(),\
    \ arr.end(), 0);\n    if (arr.empty()) return std::nullopt;\n    auto prod = std::accumulate(arr.begin(),\
    \ arr.end(), 1);\n    std::optional<long> val = s;\n    for (long i : arr)\n \
    \       val = std::max(val * i, 0);\n    return val;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwcu5mck8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwcu5mck8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwcu5mck8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwcu5mck8.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwcu5mck8.cpp:2:\n/tmp/tmpwcu5mck8.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwcu5mck8.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwcu5mck8.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwcu5mck8.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwcu5mck8.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwcu5mck8.cpp:2:\n/tmp/tmpwcu5mck8.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long sum = 0;\n    for (int i = 0; i <\
    \ arr.size(); i++)\n        sum += arr[i] * ((arr[i] > 0) - (arr[i] < 0));\n \
    \   return sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk7hi6k0y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpk7hi6k0y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpk7hi6k0y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpk7hi6k0y.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk7hi6k0y.cpp:2:\n/tmp/tmpk7hi6k0y.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpk7hi6k0y.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpk7hi6k0y.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpk7hi6k0y.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpk7hi6k0y.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpk7hi6k0y.cpp:2:\n/tmp/tmpk7hi6k0y.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ans = 1;\n \
    \   for(auto i:arr) {\n        ans *= i;\n        if(i<0) ans *= -1;\n    }\n\
    \    return std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnvbmgrp0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnvbmgrp0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnvbmgrp0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnvbmgrp0.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnvbmgrp0.cpp:2:\n/tmp/tmpnvbmgrp0.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnvbmgrp0.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnvbmgrp0.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnvbmgrp0.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnvbmgrp0.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnvbmgrp0.cpp:2:\n/tmp/tmpnvbmgrp0.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  long product = 1;\n\
    \  std::optional<long> res = std::nullopt;\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    product *= arr[i];\n    auto sign = arr[i] < 0 ? -1 : 1;\n    if\
    \ (product == 0) {\n      continue;\n    }\n    res = std::min(res, sign * product);\n\
    \  }\n  return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpva4cd5ar.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpva4cd5ar.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpva4cd5ar.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpva4cd5ar.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpva4cd5ar.cpp:2:\n/tmp/tmpva4cd5ar.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpva4cd5ar.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpva4cd5ar.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpva4cd5ar.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpva4cd5ar.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpva4cd5ar.cpp:2:\n/tmp/tmpva4cd5ar.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long ans = 0, sign = 1;\n    for\
    \ (auto i : arr) {\n        ans *= sign;\n        ans *= i;\n        sign *= -1;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp02cpzdzt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp02cpzdzt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp02cpzdzt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp02cpzdzt.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp02cpzdzt.cpp:2:\n/tmp/tmp02cpzdzt.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp02cpzdzt.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp02cpzdzt.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp02cpzdzt.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp02cpzdzt.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp02cpzdzt.cpp:2:\n/tmp/tmp02cpzdzt.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.size() == 0)\n\
    \    return std::nullopt;\n  long sum = 0;\n  long product = 1;\n  for (int i\
    \ = 0; i < arr.size(); i++) {\n    if (arr[i] < 0) {\n      product = -1;\n  \
    \    sum += -arr[i];\n    } else if (arr[i] > 0) {\n      product = 1;\n     \
    \ sum += arr[i];\n    }\n  }\n  return std::nullopt if sum == 0;\n  return sum\
    \ * product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph1vfwkay.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmph1vfwkay.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmph1vfwkay.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmph1vfwkay.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph1vfwkay.cpp:2:\n/tmp/tmph1vfwkay.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmph1vfwkay.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmph1vfwkay.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmph1vfwkay.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmph1vfwkay.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmph1vfwkay.cpp:2:\n/tmp/tmph1vfwkay.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int res = 0;\n  \
    \  int prod = 1;\n    for (auto &i : arr) {\n        prod *= i;\n        if (i\
    \ == 0) {\n            continue;\n        }\n        res += std::abs(i) * prod;\n\
    \    }\n    if (res == 0) {\n        return {};\n    }\n    return res;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxl0899_d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxl0899_d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxl0899_d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxl0899_d.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxl0899_d.cpp:2:\n/tmp/tmpxl0899_d.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxl0899_d.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxl0899_d.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxl0899_d.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxl0899_d.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxl0899_d.cpp:2:\n/tmp/tmpxl0899_d.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.size() == 0)\
    \ {\n    return std::nullopt;\n  }\n  std::stack<long> stack_arr;\n  // Initialize\
    \ stack_arr\n  stack_arr.push(arr[0]);\n  for (long i = 1; i < arr.size(); i++)\
    \ {\n    long cur_val = arr[i];\n    if (cur_val < 0) {\n      cur_val = -cur_val;\n\
    \    }\n    stack_arr.push(cur_val);\n    while (stack_arr.top() > 0) {\n    \
    \  long top = stack_arr.top();\n      long cur_sign = cur_val * top;\n      stack_arr.pop();\n\
    \      if (cur_sign > 0) {\n        stack_arr.push(cur_sign);\n      }\n     \
    \ if (stack_arr.top() > 0) {\n        stack_arr.push(stack_arr.top());\n     \
    \ }\n    }\n  }\n  if (stack_arr.size() == 0) {\n    return std::nullopt;\n  }\n\
    \  return stack_arr.top();\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprf1bttui.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprf1bttui.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprf1bttui.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprf1bttui.cpp:42:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   42 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprf1bttui.cpp:2:\n/tmp/tmprf1bttui.cpp:43:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   43 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprf1bttui.cpp:43:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprf1bttui.cpp:43:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   43 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprf1bttui.cpp:43:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprf1bttui.cpp:43:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   43 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprf1bttui.cpp:2:\n/tmp/tmprf1bttui.cpp:43:5: note:\
    \ to match this \u2018(\u2019\n   43 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ res = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        res = res | arr[i]\
    \ * std::signbit(arr[i]);\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpl7o27x1p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl7o27x1p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl7o27x1p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl7o27x1p.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl7o27x1p.cpp:2:\n/tmp/tmpl7o27x1p.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl7o27x1p.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl7o27x1p.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl7o27x1p.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl7o27x1p.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl7o27x1p.cpp:2:\n/tmp/tmpl7o27x1p.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto n = arr.size();\n\
    \    if(n < 2) return std::nullopt;\n    long long ans = 0;\n    for(int i = 1;\
    \ i < n; i++) {\n        if(arr[i] == -arr[i]) ans *= -1;\n        else ans +=\
    \ arr[i] * std::sign(arr[i]);\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsdh2gpa1.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpsdh2gpa1.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpsdh2gpa1.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpsdh2gpa1.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsdh2gpa1.cpp:2:\n/tmp/tmpsdh2gpa1.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpsdh2gpa1.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpsdh2gpa1.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpsdh2gpa1.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpsdh2gpa1.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsdh2gpa1.cpp:2:\n/tmp/tmpsdh2gpa1.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) {\n\
    \    return None;\n  }\n  long product = 1;\n  for (const auto element : arr)\
    \ {\n    product *= element;\n  }\n  long sum = std::accumulate(arr.begin(), arr.end(),\
    \ product);\n  int sum2 = sum / 2;\n  for (size_t i = 0; i < arr.size(); i++)\
    \ {\n    if (arr[i] < 0) {\n      sum2 -= (long long int)(long long)(-1) * arr[i];\n\
    \    } else if (arr[i] > 0) {\n      sum2 += (long long int)(long long)(1) * arr[i];\n\
    \    }\n  }\n  return sum2;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfrdgzuge.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfrdgzuge.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfrdgzuge.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfrdgzuge.cpp:31:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   31 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfrdgzuge.cpp:2:\n/tmp/tmpfrdgzuge.cpp:32:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfrdgzuge.cpp:32:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfrdgzuge.cpp:32:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfrdgzuge.cpp:32:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfrdgzuge.cpp:32:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   32 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfrdgzuge.cpp:2:\n/tmp/tmpfrdgzuge.cpp:32:5: note:\
    \ to match this \u2018(\u2019\n   32 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if (n == 0) {\n        return 0;\n    }\n    // Calculate the product of\
    \ all signs in arr\n    // If they are all same, that product will be positive\n\
    \    long prod = 1;\n    for (int i = 0; i < n; ++i) {\n        prod *= (arr[i]\
    \ > 0) ? 1 : -1;\n    }\n    // The magnitudes of integers multiplied by product\
    \ of signs\n    std::vector<long> magnitude(n);\n    for (int i = 0; i < n; ++i)\
    \ {\n        magnitude[i] = (arr[i] > 0) ? std::abs(arr[i] - prod) : std::abs(arr[i]\
    \ - prod * -1);\n    }\n    // sum of the magnitudes of integers\n    long s =\
    \ 0, sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += magnitude[i];\n\
    \        s += magnitude[i] * magnitude[i];\n    }\n    return sum == s ? std::optional<long>(s)\
    \ : std::optional<long>();\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpxse2xfss.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxse2xfss.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxse2xfss.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxse2xfss.cpp:36:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   36 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxse2xfss.cpp:2:\n/tmp/tmpxse2xfss.cpp:37:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxse2xfss.cpp:37:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxse2xfss.cpp:37:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxse2xfss.cpp:37:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxse2xfss.cpp:37:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxse2xfss.cpp:2:\n/tmp/tmpxse2xfss.cpp:37:5: note:\
    \ to match this \u2018(\u2019\n   37 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    // int N = arr.size();\n    // long ans = 0;\n    // for(int i=0;\
    \ i<N; i++)\n    // {\n    //     ans+=arr[i];\n    // }\n    // return std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb1q9pu__.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpb1q9pu__.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpb1q9pu__.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpb1q9pu__.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb1q9pu__.cpp:2:\n/tmp/tmpb1q9pu__.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpb1q9pu__.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpb1q9pu__.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpb1q9pu__.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpb1q9pu__.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpb1q9pu__.cpp:2:\n/tmp/tmpb1q9pu__.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long long p = 1;\n    long long sum = 0;\n\
    \    for (auto i : arr)\n        if (i < 0)\n            p -= 1;\n        else\n\
    \            p += 1;\n    sum *= p;\n    for (auto i : arr)\n        sum += i\
    \ * p;\n    return sum;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkf_7wvmm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkf_7wvmm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkf_7wvmm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkf_7wvmm.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkf_7wvmm.cpp:2:\n/tmp/tmpkf_7wvmm.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkf_7wvmm.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkf_7wvmm.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkf_7wvmm.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkf_7wvmm.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkf_7wvmm.cpp:2:\n/tmp/tmpkf_7wvmm.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    assert(arr.size());\n\
    \    std::optional<long> ret(std::numeric_limits<long>::max());\n    for (auto\
    \ x: arr) {\n        ret *= x;\n        if (ret > 0) ret += x;\n        if (ret\
    \ < 0) ret -= x;\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp2naa5k1j.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2naa5k1j.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2naa5k1j.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2naa5k1j.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2naa5k1j.cpp:2:\n/tmp/tmp2naa5k1j.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2naa5k1j.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2naa5k1j.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2naa5k1j.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2naa5k1j.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2naa5k1j.cpp:2:\n/tmp/tmp2naa5k1j.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n\n  long product = arr[0];\n  for (long i : arr) {\n\
    \    product = product*i;\n  }\n  return product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_ar2x9mg.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_ar2x9mg.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_ar2x9mg.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_ar2x9mg.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_ar2x9mg.cpp:2:\n/tmp/tmp_ar2x9mg.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_ar2x9mg.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_ar2x9mg.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_ar2x9mg.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_ar2x9mg.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_ar2x9mg.cpp:2:\n/tmp/tmp_ar2x9mg.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    auto n = arr.size();\n    long product = 1;\n    std::optional<long>\
    \ ret{1};\n    for (size_t i = 0; i < n; ++i) {\n        const long v = arr[i];\n\
    \        if (v == -2)\n            product = -product;\n        else if (v ==\
    \ -1)\n            product = -product;\n        else\n            product *= v;\n\
    \        ret = ret * product;\n    }\n    return ret;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp414xt6os.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp414xt6os.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp414xt6os.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp414xt6os.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp414xt6os.cpp:2:\n/tmp/tmp414xt6os.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp414xt6os.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp414xt6os.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp414xt6os.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp414xt6os.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp414xt6os.cpp:2:\n/tmp/tmp414xt6os.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ans = 0, p =\
    \ 1;\n    for (auto e : arr) {\n        ans += e * p;\n        p = -p;\n    }\n\
    \    if (p != 0) {\n        ans *= p;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppjmj9fxq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppjmj9fxq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppjmj9fxq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppjmj9fxq.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppjmj9fxq.cpp:2:\n/tmp/tmppjmj9fxq.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppjmj9fxq.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppjmj9fxq.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppjmj9fxq.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppjmj9fxq.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppjmj9fxq.cpp:2:\n/tmp/tmppjmj9fxq.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n    int n = arr.size();\n    long sign = -1;\n\
    \    int product = 1;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] >\
    \ 0) {\n            product *= arr[i];\n        } else {\n            product\
    \ *= sign;\n        }\n        sign = -sign;\n    }\n    if (product == 0)\n \
    \       return std::nullopt;\n    return product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpkpmtx05k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkpmtx05k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkpmtx05k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkpmtx05k.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkpmtx05k.cpp:2:\n/tmp/tmpkpmtx05k.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkpmtx05k.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkpmtx05k.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkpmtx05k.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkpmtx05k.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkpmtx05k.cpp:2:\n/tmp/tmpkpmtx05k.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    auto n = arr.size();\n    std::stack<long> st;\n \
    \   std::stack<long> res;\n    long s = 0, p = 0;\n    for (int i = 0; i < n;\
    \ i++) {\n        s = 1;\n        p = 1;\n        while (p < arr[i]) {\n     \
    \       if (arr[i] >= 0) p = p * arr[i];\n            if (arr[i] < 0) s = s *\
    \ arr[i];\n            i++;\n        }\n        s.push(p);\n    }\n    while (!st.empty())\
    \ {\n        long q = st.top();\n        st.pop();\n        res.push(q * s);\n\
    \    }\n    if (res.empty()) return std::nullopt;\n    return std::make_optional(std::accumulate(res.begin(),\
    \ res.end(), 0));\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpf33jvs8k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpf33jvs8k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpf33jvs8k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpf33jvs8k.cpp:36:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   36 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf33jvs8k.cpp:2:\n/tmp/tmpf33jvs8k.cpp:37:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpf33jvs8k.cpp:37:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpf33jvs8k.cpp:37:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpf33jvs8k.cpp:37:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpf33jvs8k.cpp:37:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   37 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf33jvs8k.cpp:2:\n/tmp/tmpf33jvs8k.cpp:37:5: note:\
    \ to match this \u2018(\u2019\n   37 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    long sum = 0;\n    for (long v : arr)\n   \
    \     sum += std::abs(v) * std::signbit(v);\n    long prod = 1;\n    for (long\
    \ v : arr)\n        prod *= std::abs(v);\n    return sum * prod;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_bqgw2s8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_bqgw2s8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_bqgw2s8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_bqgw2s8.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_bqgw2s8.cpp:2:\n/tmp/tmp_bqgw2s8.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_bqgw2s8.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_bqgw2s8.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_bqgw2s8.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_bqgw2s8.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_bqgw2s8.cpp:2:\n/tmp/tmp_bqgw2s8.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Write your code\
    \ here\n  long res = 0;\n  for (long i : arr) {\n    res = i * res;\n  }\n  return\
    \ res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp15s_2afl.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp15s_2afl.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp15s_2afl.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp15s_2afl.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp15s_2afl.cpp:2:\n/tmp/tmp15s_2afl.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp15s_2afl.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp15s_2afl.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp15s_2afl.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp15s_2afl.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp15s_2afl.cpp:2:\n/tmp/tmp15s_2afl.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    long ans = 0;\n    long sign = 1;\n\
    \    for (const auto i : arr) {\n        ans += sign * i;\n        sign *= (i\
    \ < 0 ? -1 : 1);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplqv6fk5j.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplqv6fk5j.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplqv6fk5j.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplqv6fk5j.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplqv6fk5j.cpp:2:\n/tmp/tmplqv6fk5j.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplqv6fk5j.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplqv6fk5j.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplqv6fk5j.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplqv6fk5j.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplqv6fk5j.cpp:2:\n/tmp/tmplqv6fk5j.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    if (arr.empty()) return std::nullopt;\n    long long ans = 0;\n  \
    \  for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] < 0) ans *= -1;\n\
    \        else if (arr[i] > 0) ans *= 1;\n        else return std::nullopt;\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpwj0pg49n.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpwj0pg49n.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpwj0pg49n.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpwj0pg49n.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwj0pg49n.cpp:2:\n/tmp/tmpwj0pg49n.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpwj0pg49n.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpwj0pg49n.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpwj0pg49n.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpwj0pg49n.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwj0pg49n.cpp:2:\n/tmp/tmpwj0pg49n.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  long ans = 0;\n  long cur = arr[0];\n  for (int i = 1; i < n; i++) {\n    long\
    \ n = arr[i];\n    cur *= n;\n    int sign = cur >= 0 ? 1 : 0;\n    ans += sign\
    \ * std::abs(cur);\n  }\n  return std::nullopt;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpepydhrre.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpepydhrre.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpepydhrre.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpepydhrre.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpepydhrre.cpp:2:\n/tmp/tmpepydhrre.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpepydhrre.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpepydhrre.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpepydhrre.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpepydhrre.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpepydhrre.cpp:2:\n/tmp/tmpepydhrre.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() <=\
    \ 0) return std::nullopt;\n    long prod = 1;\n    for (long i : arr) {\n    \
    \    prod *= i;\n    }\n    for (long i : arr) {\n        prod *= (i * ((i < 0)\
    \ ^ (i > 0)));\n    }\n    return prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp_chmy134.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_chmy134.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_chmy134.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_chmy134.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_chmy134.cpp:2:\n/tmp/tmp_chmy134.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_chmy134.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_chmy134.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_chmy134.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_chmy134.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_chmy134.cpp:2:\n/tmp/tmp_chmy134.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto n = arr.size();\n\
    \    // check if arr has any elements\n    if (n == 0)\n        return std::nullopt;\n\
    \    // return None if arr is empty\n    if (n == 1)\n        return std::nullopt;\n\
    \    // initialize accumulator to zero\n    long acc = 0;\n    // keep iterating\
    \ while we have more than one element\n    while (n > 1) {\n        // increment\
    \ the accumulator\n        acc += arr[n-1];\n        // subtract the first element\
    \ from arr[n-1] and shift arr[n] by one\n        n -= 1;\n        long mul = 1;\n\
    \        // iterate through arr from n-1 to zero\n        for (long i = n-1; i\
    \ > 0; i--)\n            mul *= arr[i-1];\n        // add product to accumulator\n\
    \        acc += mul;\n    }\n    return acc;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpiyrs3gy8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpiyrs3gy8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpiyrs3gy8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpiyrs3gy8.cpp:37:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   37 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiyrs3gy8.cpp:2:\n/tmp/tmpiyrs3gy8.cpp:38:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpiyrs3gy8.cpp:38:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpiyrs3gy8.cpp:38:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpiyrs3gy8.cpp:38:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpiyrs3gy8.cpp:38:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   38 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiyrs3gy8.cpp:2:\n/tmp/tmpiyrs3gy8.cpp:38:5: note:\
    \ to match this \u2018(\u2019\n   38 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // O(n)\n  for (long\
    \ i : arr) {\n    if (i == 0) return std::nullopt;\n    if (i < 0) return -1;\n\
    \  }\n\n  // O(n)\n  std::set<int> signs;\n  for (long i : arr) {\n    if (i <\
    \ 0) signs.insert(-1);\n    else signs.insert(1);\n  }\n  long product = 1;\n\
    \  for (const auto s : signs) product *= s;\n\n  long ans = 0;\n  for (const auto\
    \ s : signs) {\n    ans += std::abs(i * product);\n  }\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg69m_7o7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpg69m_7o7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpg69m_7o7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpg69m_7o7.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg69m_7o7.cpp:2:\n/tmp/tmpg69m_7o7.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpg69m_7o7.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpg69m_7o7.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpg69m_7o7.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpg69m_7o7.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpg69m_7o7.cpp:2:\n/tmp/tmpg69m_7o7.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::optional<long> ret = 0;\n \
    \   for (auto elem : arr) {\n        if (elem < 0) {\n            ret = std::nullopt;\n\
    \            break;\n        }\n        long rem = 1;\n        for (long i = elem;\
    \ i >= 0; i--) {\n            rem *= i;\n        }\n        ret += rem;\n    }\n\
    \    return ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl948i43w.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl948i43w.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl948i43w.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl948i43w.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl948i43w.cpp:2:\n/tmp/tmpl948i43w.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl948i43w.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl948i43w.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl948i43w.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl948i43w.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl948i43w.cpp:2:\n/tmp/tmpl948i43w.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long long product\
    \ = 1;\n    long long sum = 0;\n    for (auto num : arr) {\n        sum += num;\n\
    \        product *= num;\n    }\n    if (sum != 0) {\n        return sum;\n  \
    \  }\n    if (product != 0) {\n        return product;\n    }\n    return std::nullopt;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpir21yvd3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpir21yvd3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpir21yvd3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpir21yvd3.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpir21yvd3.cpp:2:\n/tmp/tmpir21yvd3.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpir21yvd3.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpir21yvd3.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpir21yvd3.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpir21yvd3.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpir21yvd3.cpp:2:\n/tmp/tmpir21yvd3.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    auto n = arr.size();\n    // O(log n) solution by\
    \ sort\n    std::sort(arr.begin(), arr.end());\n    long ret = 0;\n    for (auto\
    \ i : arr) {\n        if (i == 1) ret += n;\n        else if (i == -1) ret -=\
    \ n;\n        else if (i == 0) ret *= n;\n    }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_buqkq5s.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_buqkq5s.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_buqkq5s.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_buqkq5s.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_buqkq5s.cpp:2:\n/tmp/tmp_buqkq5s.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_buqkq5s.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_buqkq5s.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_buqkq5s.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_buqkq5s.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_buqkq5s.cpp:2:\n/tmp/tmp_buqkq5s.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n\n    auto ret = 1;\n    for (auto& val : arr)\n     \
    \   ret = (val * ret);\n\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpfa42v113.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfa42v113.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfa42v113.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfa42v113.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfa42v113.cpp:2:\n/tmp/tmpfa42v113.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfa42v113.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfa42v113.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfa42v113.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfa42v113.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfa42v113.cpp:2:\n/tmp/tmpfa42v113.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n    long sign = 1;\n    for (long i : arr)\n\
    \        sign *= (i < 0 ? -1 : 1, i != 0);\n    long prod = 1;\n    for (long\
    \ i : arr)\n        prod *= (i < 0 ? -1 : 1, i != 0);\n    long res = prod * sign;\n\
    \    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgdox1uud.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgdox1uud.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgdox1uud.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgdox1uud.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgdox1uud.cpp:2:\n/tmp/tmpgdox1uud.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgdox1uud.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgdox1uud.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgdox1uud.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgdox1uud.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgdox1uud.cpp:2:\n/tmp/tmpgdox1uud.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if(arr.empty()) return\
    \ std::nullopt;\n\n    long long product = 1;\n\n    for(int i=0; i<arr.size();\
    \ i++) {\n        long long v = arr[i];\n        int sign = (v < 0) ? -1 : 1;\n\
    \n        product = product * sign;\n    }\n\n    return product;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpe0avu7uz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpe0avu7uz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpe0avu7uz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpe0avu7uz.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe0avu7uz.cpp:2:\n/tmp/tmpe0avu7uz.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpe0avu7uz.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpe0avu7uz.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpe0avu7uz.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpe0avu7uz.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpe0avu7uz.cpp:2:\n/tmp/tmpe0avu7uz.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // You have to complete\
    \ this function\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx7xcma89.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpx7xcma89.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpx7xcma89.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpx7xcma89.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx7xcma89.cpp:2:\n/tmp/tmpx7xcma89.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpx7xcma89.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpx7xcma89.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpx7xcma89.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpx7xcma89.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx7xcma89.cpp:2:\n/tmp/tmpx7xcma89.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // YOUR CODE HERE\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyfxkw12k.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpyfxkw12k.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpyfxkw12k.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpyfxkw12k.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyfxkw12k.cpp:2:\n/tmp/tmpyfxkw12k.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpyfxkw12k.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpyfxkw12k.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpyfxkw12k.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpyfxkw12k.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyfxkw12k.cpp:2:\n/tmp/tmpyfxkw12k.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if (n <= 0) {\n    return std::nullopt;\n  }\n\n  std::vector<long> mags =\
    \ std::accumulate(arr.begin(), arr.end(), std::vector<long>{-1}, [](long a, long\
    \ b) { return a + std::abs(b); }); // a is current mag, magnitude of every num\n\
    \  std::vector<long> prod = std::vector<long>{};\n  long s = 0;\n  for (int i\
    \ = 0; i < n; i++) {\n    s = s * mags[i];\n    if (arr[i] > 0) {\n      prod.push_back(1);\n\
    \    } else if (arr[i] < 0) {\n      prod.push_back(-1);\n    } else {\n     \
    \ prod.push_back(arr[i]);\n    }\n  }\n\n  return prod * std::accumulate(prod.begin(),\
    \ prod.end(), 1, std::multiplies<long>());\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpme8ek0ws.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpme8ek0ws.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpme8ek0ws.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpme8ek0ws.cpp:34:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   34 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpme8ek0ws.cpp:2:\n/tmp/tmpme8ek0ws.cpp:35:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpme8ek0ws.cpp:35:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpme8ek0ws.cpp:35:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpme8ek0ws.cpp:35:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpme8ek0ws.cpp:35:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   35 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpme8ek0ws.cpp:2:\n/tmp/tmpme8ek0ws.cpp:35:5: note:\
    \ to match this \u2018(\u2019\n   35 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n    long ans = 0;\n    for (int i = 0; i <\
    \ arr.size(); ++i) {\n        if (arr[i] == 0)\n            continue;\n      \
    \  ans += (arr[i]) * std::sign(arr[i]);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkrrehorr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkrrehorr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkrrehorr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkrrehorr.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkrrehorr.cpp:2:\n/tmp/tmpkrrehorr.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkrrehorr.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkrrehorr.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkrrehorr.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkrrehorr.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkrrehorr.cpp:2:\n/tmp/tmpkrrehorr.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return None;\n    int sign = std::count_if(arr.begin(), arr.end(), [](int x)\
    \ { return x == -1; });\n    int val = 0;\n    for (long i : arr) val += sign\
    \ * i;\n    return val;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp5kpiof73.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5kpiof73.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5kpiof73.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5kpiof73.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5kpiof73.cpp:2:\n/tmp/tmp5kpiof73.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5kpiof73.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5kpiof73.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5kpiof73.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5kpiof73.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5kpiof73.cpp:2:\n/tmp/tmp5kpiof73.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long ret = 0;\n  for (auto x : arr) {\n    ret += x * std::signbit(x);\n\
    \  }\n  return ret;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2l8vluyj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2l8vluyj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2l8vluyj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2l8vluyj.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2l8vluyj.cpp:2:\n/tmp/tmp2l8vluyj.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2l8vluyj.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2l8vluyj.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2l8vluyj.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2l8vluyj.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2l8vluyj.cpp:2:\n/tmp/tmp2l8vluyj.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ {};\n  std::optional<long> sum{};\n  long product = 1;\n  for (auto n : arr)\
    \ {\n    sum += std::abs(n) * product;\n    product *= std::sign(n);\n  }\n  return\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpets5ol6j.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpets5ol6j.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpets5ol6j.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpets5ol6j.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpets5ol6j.cpp:2:\n/tmp/tmpets5ol6j.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpets5ol6j.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpets5ol6j.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpets5ol6j.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpets5ol6j.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpets5ol6j.cpp:2:\n/tmp/tmpets5ol6j.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if(n < 2)\n        return std::nullopt;\n    long res = arr[0];\n    for(int\
    \ i = 1; i < n; i++) {\n        if(arr[i] != 0) {\n            long s = arr[i]*(arr[i]\
    \ > 0 ? 1 : -1);\n            res = res * s;\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3odajoyr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3odajoyr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3odajoyr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3odajoyr.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3odajoyr.cpp:2:\n/tmp/tmp3odajoyr.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3odajoyr.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3odajoyr.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3odajoyr.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3odajoyr.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3odajoyr.cpp:2:\n/tmp/tmp3odajoyr.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Write your code\
    \ here\n  if (arr.size() == 0) return none;\n  long product = 1, sign = 1;\n \
    \ long sum = 0;\n  for (long x : arr) \n  {\n    sum += sign * x;\n    product\
    \ *= sign;\n    sign *= (-1);\n  }\n  return sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpgf5k7dzq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgf5k7dzq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgf5k7dzq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgf5k7dzq.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgf5k7dzq.cpp:2:\n/tmp/tmpgf5k7dzq.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgf5k7dzq.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgf5k7dzq.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgf5k7dzq.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgf5k7dzq.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgf5k7dzq.cpp:2:\n/tmp/tmpgf5k7dzq.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if(arr.size() ==\
    \ 0) {\n        return {};\n    }\n\n    long sum = 0;\n    long sign = 1;\n \
    \   // Find product\n    for(long i : arr) {\n        sum = (sum * sign) * (i\
    \ & 1);\n        sign = -sign;\n    }\n    // Find sum of magnitudes\n    long\
    \ m = 0;\n    for(long i : arr) {\n        m += std::abs(i);\n    }\n    // Return\
    \ if magnitude is greater or equal than sum\n    return m >= sum ? std::make_optional(sum)\
    \ : {};\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdd2la0zb.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpdd2la0zb.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpdd2la0zb.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpdd2la0zb.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdd2la0zb.cpp:2:\n/tmp/tmpdd2la0zb.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpdd2la0zb.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpdd2la0zb.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpdd2la0zb.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpdd2la0zb.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpdd2la0zb.cpp:2:\n/tmp/tmpdd2la0zb.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    long sign = -1, prod = 1;\n    for (auto i : arr) {\n        prod\
    \ *= i;\n        if (i == 1) {\n            sign = 1;\n        } else if (i ==\
    \ -1) {\n            sign = -1;\n        } else {\n            sign = 0;\n   \
    \     }\n    }\n    return sign * prod;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpp5vnx6xz.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpp5vnx6xz.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpp5vnx6xz.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpp5vnx6xz.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5vnx6xz.cpp:2:\n/tmp/tmpp5vnx6xz.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpp5vnx6xz.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpp5vnx6xz.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpp5vnx6xz.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpp5vnx6xz.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpp5vnx6xz.cpp:2:\n/tmp/tmpp5vnx6xz.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return None;\n    long long ans = 1;\n    for (auto i : arr)\n \
    \       ans *= i;\n    for (int i = 0; i < arr.size(); i++)\n        if (arr[i]\
    \ < 0)\n            ans *= -1;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6wxei0yj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6wxei0yj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6wxei0yj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6wxei0yj.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6wxei0yj.cpp:2:\n/tmp/tmp6wxei0yj.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6wxei0yj.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6wxei0yj.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6wxei0yj.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6wxei0yj.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6wxei0yj.cpp:2:\n/tmp/tmp6wxei0yj.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // Write your code\
    \ here\n  assert(arr.size() != 0 && arr.size() % 2 == 0);\n  std::optional<long>\
    \ ans;\n  std::optional<long> p = std::optional<long>(1);\n  long sign;\n  for\
    \ (auto i : arr) {\n    p = p * sign;\n    sign = i;\n  }\n  ans = p;\n  for (auto\
    \ i : arr) {\n    sign = i;\n    p = p * sign;\n    ans = ans | p;\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpatfhge0d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpatfhge0d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpatfhge0d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpatfhge0d.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpatfhge0d.cpp:2:\n/tmp/tmpatfhge0d.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpatfhge0d.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpatfhge0d.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpatfhge0d.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpatfhge0d.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpatfhge0d.cpp:2:\n/tmp/tmpatfhge0d.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    // Sum all positive values\n    auto sum = std::accumulate(arr.begin(),\
    \ arr.end(), 0);\n    auto product = 1;\n    // Multiply all signs by the product\
    \ of signs\n    for (auto val : arr) {\n        product *= (val < 0) ? 1 : -1;\n\
    \    }\n    // Return product times sum of magnitudes\n    return product * sum;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpiqum_30_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpiqum_30_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpiqum_30_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpiqum_30_.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiqum_30_.cpp:2:\n/tmp/tmpiqum_30_.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpiqum_30_.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpiqum_30_.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpiqum_30_.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpiqum_30_.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpiqum_30_.cpp:2:\n/tmp/tmpiqum_30_.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int sum = 0;\n  int\
    \ sign = 1;\n  long product = 1;\n  assert(arr.size() >= 1);\n  for (int i = 0;\
    \ i < arr.size(); i++) {\n    if (arr[i] < 0) {\n      sign *= -1;\n      arr[i]\
    \ = -arr[i];\n    }\n    if (arr[i] > 0) {\n      sum += arr[i] * sign;\n    \
    \  product *= (sign < 0 ? -1 : 1) * sign;\n      sign *= -1;\n    }\n  }\n  return\
    \ sum == 0 ? std::nullopt : (product * sum);\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmprieph91t.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprieph91t.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprieph91t.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprieph91t.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprieph91t.cpp:2:\n/tmp/tmprieph91t.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprieph91t.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprieph91t.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprieph91t.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprieph91t.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprieph91t.cpp:2:\n/tmp/tmprieph91t.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ sum_mag;\n  for (auto i : arr) {\n    sum_mag = std::min(sum_mag, sum_mag *\
    \ i);\n  }\n  return sum_mag;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp903iw5mi.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp903iw5mi.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp903iw5mi.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp903iw5mi.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp903iw5mi.cpp:2:\n/tmp/tmp903iw5mi.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp903iw5mi.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp903iw5mi.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp903iw5mi.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp903iw5mi.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp903iw5mi.cpp:2:\n/tmp/tmp903iw5mi.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ {0};\n  std::unordered_map<long, long> mag;\n  for (auto i : arr) mag[i.second]\
    \ += 1;\n  long p = 1ll;\n  for (const auto& m : mag) {\n    p *= (m.second) ?\
    \ -1 : 1;\n  }\n  long res = 0;\n  for (const auto& m : mag) {\n    res += (m.second)\
    \ ? m.first * p : 0;\n  }\n  return {res};\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpw6_uzc6x.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpw6_uzc6x.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpw6_uzc6x.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpw6_uzc6x.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw6_uzc6x.cpp:2:\n/tmp/tmpw6_uzc6x.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpw6_uzc6x.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpw6_uzc6x.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpw6_uzc6x.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpw6_uzc6x.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpw6_uzc6x.cpp:2:\n/tmp/tmpw6_uzc6x.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    long product = 0;\n    long sign = 1;\n    for (int i = 0; i < arr.size();\
    \ i++) {\n        product = product * sign / arr[i];\n        sign = (arr[i] >\
    \ 0) ? 1 : -1;\n    }\n    return product;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplo99ypje.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplo99ypje.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplo99ypje.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplo99ypje.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplo99ypje.cpp:2:\n/tmp/tmplo99ypje.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplo99ypje.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplo99ypje.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplo99ypje.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplo99ypje.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplo99ypje.cpp:2:\n/tmp/tmplo99ypje.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Write your code\
    \ here\n    long prod = 0;\n    for (long i : arr) {\n        prod *= i;\n   \
    \ }\n    return prod;\n}\nint main() {\n    auto candidate = prod_signs;\n   \
    \ assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7z606b_u.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7z606b_u.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7z606b_u.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7z606b_u.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7z606b_u.cpp:2:\n/tmp/tmp7z606b_u.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7z606b_u.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7z606b_u.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7z606b_u.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7z606b_u.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7z606b_u.cpp:2:\n/tmp/tmp7z606b_u.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long n = arr.size();\n  long prod = 1;\n  long sign\
    \ = 1;\n  for (long i = 0; i < n; i++) {\n    long v = arr[i];\n    long m = i;\n\
    \    while (m < n && arr[m] >= 0)\n      m++;\n    if (m == n)\n      return None;\n\
    \    prod *= sign;\n    sign *= v;\n  }\n  return prod;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpnpdy3yr3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnpdy3yr3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnpdy3yr3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnpdy3yr3.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnpdy3yr3.cpp:2:\n/tmp/tmpnpdy3yr3.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnpdy3yr3.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnpdy3yr3.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnpdy3yr3.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnpdy3yr3.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnpdy3yr3.cpp:2:\n/tmp/tmpnpdy3yr3.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ result(0);\n  long res = 0;\n  for (int i = 0; i < arr.size(); i++)\n    res\
    \ += std::signbit(arr[i]) * arr[i];\n  if (res == 0)\n    return result;\n  result\
    \ = std::abs(res);\n  if (result > 0)\n    result *= -1;\n  return result;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4j4ptktb.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp4j4ptktb.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp4j4ptktb.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp4j4ptktb.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4j4ptktb.cpp:2:\n/tmp/tmp4j4ptktb.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp4j4ptktb.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp4j4ptktb.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp4j4ptktb.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp4j4ptktb.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp4j4ptktb.cpp:2:\n/tmp/tmp4j4ptktb.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    for (long x : arr) {\n        product = x * product;\n    }\n    if (product\
    \ == 0)\n        return std::nullopt;\n    if (product < 0)\n        return -product;\n\
    \    return product;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvcucmdcf.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvcucmdcf.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvcucmdcf.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvcucmdcf.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvcucmdcf.cpp:2:\n/tmp/tmpvcucmdcf.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvcucmdcf.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvcucmdcf.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvcucmdcf.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvcucmdcf.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvcucmdcf.cpp:2:\n/tmp/tmpvcucmdcf.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long sum = 0;\n    for (int i = 0; i < arr.size();\
    \ ++i) {\n        sum += std::abs(arr[i]);\n    }\n    long prod = 1;\n    for\
    \ (int i = 0; i < arr.size(); ++i) {\n        prod *= arr[i];\n    }\n    if (prod\
    \ == 0) return std::nullopt;\n    return sum * prod;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd13meklx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpd13meklx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpd13meklx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpd13meklx.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd13meklx.cpp:2:\n/tmp/tmpd13meklx.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpd13meklx.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpd13meklx.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpd13meklx.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpd13meklx.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpd13meklx.cpp:2:\n/tmp/tmpd13meklx.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::optional<long>\
    \ sum = 0;\n    for (auto i : arr) {\n        sum += std::signbit(i) ? 1 : -1;\n\
    \    }\n    return sum;\n}\nint main() {\n    auto candidate = prod_signs;\n \
    \   assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpc1drg5rm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpc1drg5rm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpc1drg5rm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpc1drg5rm.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc1drg5rm.cpp:2:\n/tmp/tmpc1drg5rm.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpc1drg5rm.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpc1drg5rm.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpc1drg5rm.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpc1drg5rm.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc1drg5rm.cpp:2:\n/tmp/tmpc1drg5rm.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    auto itr = arr.cbegin();\n\
    \    long product = 1, sign = 1;\n    for (; itr != arr.cend(); ++itr) {\n   \
    \     if (*itr < 0) {\n            sign *= -1;\n        }\n        product *=\
    \ *itr;\n    }\n    return product * sign;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp600s_s93.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp600s_s93.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp600s_s93.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp600s_s93.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp600s_s93.cpp:2:\n/tmp/tmp600s_s93.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp600s_s93.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp600s_s93.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp600s_s93.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp600s_s93.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp600s_s93.cpp:2:\n/tmp/tmp600s_s93.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    long ans = 1;\n    for (int i = 0; i < n; ++i) {\n        long prod = 1;\n\
    \        int sign = arr[i] > 0 ? 1 : -1;\n        for (int j = i + 1; j < n; ++j)\
    \ {\n            prod *= (arr[j] >= 0 ? 1 : -1);\n        }\n        ans *= sign\
    \ * prod;\n    }\n    return std::nullopt;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp6ysw2eed.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp6ysw2eed.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp6ysw2eed.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp6ysw2eed.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6ysw2eed.cpp:2:\n/tmp/tmp6ysw2eed.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp6ysw2eed.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp6ysw2eed.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp6ysw2eed.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp6ysw2eed.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp6ysw2eed.cpp:2:\n/tmp/tmp6ysw2eed.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your code here\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkowwh27_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpkowwh27_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpkowwh27_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpkowwh27_.cpp:15:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   15 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkowwh27_.cpp:2:\n/tmp/tmpkowwh27_.cpp:16:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpkowwh27_.cpp:16:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpkowwh27_.cpp:16:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpkowwh27_.cpp:16:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpkowwh27_.cpp:16:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   16 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkowwh27_.cpp:2:\n/tmp/tmpkowwh27_.cpp:16:5: note:\
    \ to match this \u2018(\u2019\n   16 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1;\n\
    \    long magnitude = 0;\n    for (auto elem : arr) {\n        product *= elem;\n\
    \        magnitude += abs(elem);\n    }\n    return magnitude * product;\n}\n\
    int main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2v6vn58f.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp2v6vn58f.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp2v6vn58f.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp2v6vn58f.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2v6vn58f.cpp:2:\n/tmp/tmp2v6vn58f.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp2v6vn58f.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp2v6vn58f.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp2v6vn58f.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp2v6vn58f.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2v6vn58f.cpp:2:\n/tmp/tmp2v6vn58f.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n\n  std::optional<long> rem = std::accumulate(arr.begin(), arr.end(),\
    \ 0);\n  for (long i : arr) rem *= i;\n  long product = rem;\n  std::optional<long>\
    \ res = std::accumulate(arr.begin(), arr.end(), product);\n  return std::min(res.value_or(0),\
    \ product);\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp34ic5dxw.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp34ic5dxw.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp34ic5dxw.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp34ic5dxw.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp34ic5dxw.cpp:2:\n/tmp/tmp34ic5dxw.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp34ic5dxw.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp34ic5dxw.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp34ic5dxw.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp34ic5dxw.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp34ic5dxw.cpp:2:\n/tmp/tmp34ic5dxw.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long ans = 0;\n  long prod = 1;\n  for (auto const\
    \ &x : arr) {\n    ans += x * prod;\n    prod *= x;\n  }\n  return ans;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl_92o7d_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl_92o7d_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl_92o7d_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl_92o7d_.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl_92o7d_.cpp:2:\n/tmp/tmpl_92o7d_.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl_92o7d_.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl_92o7d_.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl_92o7d_.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl_92o7d_.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl_92o7d_.cpp:2:\n/tmp/tmpl_92o7d_.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if (n <= 0) return {};\n    long long ans = 0;\n    std::vector<int> sign(n);\n\
    \    std::iota(sign.begin(), sign.end(), 0);\n    for (int i = 0; i != arr.size();\
    \ ++i) {\n        long v = arr[i];\n        int sig = sign[i];\n        if (sig\
    \ > 0) {\n            ans += v * std::abs(v);\n        } else if (sig < 0) {\n\
    \            ans -= v * std::abs(v);\n        } else {\n            ans += v;\n\
    \        }\n        sign[i] = 0;\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphxl6moc4.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmphxl6moc4.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmphxl6moc4.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmphxl6moc4.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphxl6moc4.cpp:2:\n/tmp/tmphxl6moc4.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmphxl6moc4.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmphxl6moc4.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmphxl6moc4.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmphxl6moc4.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphxl6moc4.cpp:2:\n/tmp/tmphxl6moc4.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long prod = 0;\n    for (long x: arr) prod *= x;\n\
    \    auto it = arr.begin();\n    auto last = arr.end();\n    while (it != last)\
    \ {\n        long sign = *it < 0 ? -1 : 1;\n        long sum = 0;\n        for\
    \ (long x: arr) {\n            if (x == *it) {\n                sum += sign;\n\
    \                break;\n            }\n        }\n        if (sum != 0) prod\
    \ *= sum;\n        ++it;\n    }\n    return prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7yxouq63.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7yxouq63.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7yxouq63.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7yxouq63.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yxouq63.cpp:2:\n/tmp/tmp7yxouq63.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7yxouq63.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7yxouq63.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7yxouq63.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7yxouq63.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7yxouq63.cpp:2:\n/tmp/tmp7yxouq63.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // arr should be sorted\
    \ in ascending order\n  if (arr.size() < 2) {\n    return {};\n  }\n  long product\
    \ = 1;\n  long last_sign = 1;\n  for (long i : arr) {\n    // sign = sign(arr[i])\n\
    \    long sign = i % 2;\n    if (sign < 0) {\n      last_sign *= -1;\n    }\n\
    \    // arr[i] = -arr[i]\n    product *= -sign;\n  }\n  // if product is zero\
    \ then all numbers have zero signs\n  // if product is greater than zero then\
    \ some numbers have zero signs\n  // and some numbers have negative signs\n  return\
    \ product > 0 ? std::make_optional(last_sign * product) : {};\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpalgh5k14.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpalgh5k14.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpalgh5k14.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpalgh5k14.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpalgh5k14.cpp:2:\n/tmp/tmpalgh5k14.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpalgh5k14.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpalgh5k14.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpalgh5k14.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpalgh5k14.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpalgh5k14.cpp:2:\n/tmp/tmpalgh5k14.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long product = 1LL;\n\
    \    for (auto i : arr) {\n        product *= i;\n    }\n    long productSign\
    \ = product >> 31; // get product sign bit \n    long sumMagnitudes = 0;\n   \
    \ for (auto i : arr) {\n        sumMagnitudes += abs(i);\n    }\n    if (sumMagnitudes\
    \ == 0) {\n        return {}; // return None \n    }\n    return { sumMagnitudes\
    \ * productSign };\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc2b_p784.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpc2b_p784.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpc2b_p784.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpc2b_p784.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc2b_p784.cpp:2:\n/tmp/tmpc2b_p784.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpc2b_p784.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpc2b_p784.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpc2b_p784.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpc2b_p784.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpc2b_p784.cpp:2:\n/tmp/tmpc2b_p784.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int i = 0;\n    int\
    \ n = 0;\n    int sum = 0;\n    int temp = 0;\n    for (auto i : arr) {\n    \
    \    sum += i;\n    }\n    for (auto i : arr) {\n        n += 1;\n    }\n    for\
    \ (auto i : arr) {\n        temp = sum % 2 == 0 ? 1 : -1;\n        if (temp ==\
    \ 1) {\n            sum += 1;\n        } else {\n            sum -= 1;\n     \
    \   }\n    }\n    return sum == 0 ? (std::optional<long>(None)) : (sum * prod_signs(arr.substr(0,\
    \ n)));\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpx08am5e9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpx08am5e9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpx08am5e9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpx08am5e9.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx08am5e9.cpp:2:\n/tmp/tmpx08am5e9.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpx08am5e9.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpx08am5e9.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpx08am5e9.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpx08am5e9.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx08am5e9.cpp:2:\n/tmp/tmpx08am5e9.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int n = arr.size();\n    long prod = 0;\n    for (int\
    \ i = 0; i < n; ++i)\n        prod = prod*arr[i] + (prod*arr[i]>0?1:-1);\n   \
    \ return prod;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjsf70a0e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjsf70a0e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjsf70a0e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjsf70a0e.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjsf70a0e.cpp:2:\n/tmp/tmpjsf70a0e.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjsf70a0e.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjsf70a0e.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjsf70a0e.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjsf70a0e.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjsf70a0e.cpp:2:\n/tmp/tmpjsf70a0e.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return None;\n    auto result = std::accumulate(arr.begin(), arr.end(), 0LL,\
    \ [](long i, long j) -> long {\n        return i + j;\n    });\n    std::vector<bool>\
    \ signs;\n    for (auto i : arr) signs.push_back(i < 0);\n    auto result = std::accumulate(arr.begin(),\
    \ arr.end(), 0LL, [&signs](long i, long j) -> long {\n        if (signs[i] ==\
    \ signs[j]) return i; // same sign\n        else return i * j; // different signs\n\
    \    });\n    return result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp3740igrj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp3740igrj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp3740igrj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp3740igrj.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3740igrj.cpp:2:\n/tmp/tmp3740igrj.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp3740igrj.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp3740igrj.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp3740igrj.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp3740igrj.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp3740igrj.cpp:2:\n/tmp/tmp3740igrj.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ans = 0;\n \
    \   for (long e : arr) {\n        long n = e * e * e;\n        ans = std::max(ans,\
    \ n);\n        ans = std::max(ans, e * e);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_9ja7mmc.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp_9ja7mmc.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp_9ja7mmc.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp_9ja7mmc.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_9ja7mmc.cpp:2:\n/tmp/tmp_9ja7mmc.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp_9ja7mmc.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp_9ja7mmc.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp_9ja7mmc.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp_9ja7mmc.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_9ja7mmc.cpp:2:\n/tmp/tmp_9ja7mmc.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return None;\n    }\n    long ans = 0, mul = 1;\n    for (int\
    \ i : arr) {\n        ans += mul * (i == 0 ? 1 : i == 1 ? -1 : 0);\n        mul\
    \ *= i;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpt_5jabmp.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpt_5jabmp.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpt_5jabmp.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpt_5jabmp.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt_5jabmp.cpp:2:\n/tmp/tmpt_5jabmp.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpt_5jabmp.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpt_5jabmp.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpt_5jabmp.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpt_5jabmp.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpt_5jabmp.cpp:2:\n/tmp/tmpt_5jabmp.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.size() == 0)\
    \ {\n    return std::nullopt;\n  }\n  int x = 0, sum = 0;\n  for (int i = 0; i\
    \ < arr.size(); i++) {\n    int sign = arr[i] >= 0 ? 1 : -1;\n    sum += sign\
    \ * x;\n    x *= arr[i];\n  }\n  return sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpts2cwic2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpts2cwic2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpts2cwic2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpts2cwic2.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpts2cwic2.cpp:2:\n/tmp/tmpts2cwic2.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpts2cwic2.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpts2cwic2.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpts2cwic2.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpts2cwic2.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpts2cwic2.cpp:2:\n/tmp/tmpts2cwic2.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long ans = 0, sign = 1;\n    for (auto val : arr)\
    \ ans *= sign;\n    for (auto val : arr) ans *= (val < 0) ? sign : (-sign);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpxrup6o3e.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpxrup6o3e.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpxrup6o3e.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpxrup6o3e.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxrup6o3e.cpp:2:\n/tmp/tmpxrup6o3e.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpxrup6o3e.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpxrup6o3e.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpxrup6o3e.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpxrup6o3e.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxrup6o3e.cpp:2:\n/tmp/tmpxrup6o3e.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    std::vector<bool>\
    \ sign(arr.size());\n    std::iota(sign.begin(), sign.end(), false);\n    long\
    \ long int sum = 0;\n    for (auto &i : arr) {\n        sum *= sign[i];\n    }\n\
    \    if (arr.empty()) {\n        return {};\n    }\n    auto min_max_index = std::min_element(sign.begin(),\
    \ sign.end());\n    long long int min = *min_max_index;\n    long long int max\
    \ = *min_max_index;\n    for (int i = sign.size() - 1; i >= 0; i--) {\n      \
    \  if (sign[i]) {\n            if (arr[i] < min) {\n                min = arr[i];\n\
    \            }\n            if (arr[i] > max) {\n                max = arr[i];\n\
    \            }\n        } else {\n            if (arr[i] < min) {\n          \
    \      min = arr[i];\n            }\n            if (arr[i] > max) {\n       \
    \         max = arr[i];\n            }\n        }\n    }\n    return sum + (max\
    \ - min) * (min > 0 ? 1 : -1);\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp9ew88jp8.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9ew88jp8.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9ew88jp8.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9ew88jp8.cpp:44:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   44 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ew88jp8.cpp:2:\n/tmp/tmp9ew88jp8.cpp:45:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   45 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9ew88jp8.cpp:45:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9ew88jp8.cpp:45:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   45 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9ew88jp8.cpp:45:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9ew88jp8.cpp:45:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   45 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9ew88jp8.cpp:2:\n/tmp/tmp9ew88jp8.cpp:45:5: note:\
    \ to match this \u2018(\u2019\n   45 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long prod = 1;\n\
    \    long sign = 1;\n    for (auto i : arr) {\n        prod *= sign;\n       \
    \ sign = std::abs(i);\n    }\n    return prod;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpf2e79y7p.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpf2e79y7p.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpf2e79y7p.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpf2e79y7p.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf2e79y7p.cpp:2:\n/tmp/tmpf2e79y7p.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpf2e79y7p.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpf2e79y7p.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpf2e79y7p.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpf2e79y7p.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpf2e79y7p.cpp:2:\n/tmp/tmpf2e79y7p.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n    std::unordered_map<long, long> map;\n\
    \    long product = 1;\n    long sum = 0;\n    for (long i : arr) {\n        map[i]\
    \ += 1;\n        product *= i;\n        sum += i * map[i];\n    }\n    return\
    \ sum == product ? std::nullopt : sum;\n}\nint main() {\n    auto candidate =\
    \ prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpby236zs_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpby236zs_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpby236zs_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpby236zs_.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpby236zs_.cpp:2:\n/tmp/tmpby236zs_.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpby236zs_.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpby236zs_.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpby236zs_.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpby236zs_.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpby236zs_.cpp:2:\n/tmp/tmpby236zs_.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if(arr.empty())\n\
    \        return std::nullopt;\n    long result = 0;\n    long long product = 1;\n\
    \    long long sign = 1;\n    for(auto val : arr) {\n        if(val < 0) {\n \
    \           sign = -1;\n            val = -val;\n        }\n        if(val > 0)\
    \ {\n            product *= val;\n        }\n        result += sign * product;\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmppu8vxihr.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmppu8vxihr.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmppu8vxihr.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmppu8vxihr.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppu8vxihr.cpp:2:\n/tmp/tmppu8vxihr.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmppu8vxihr.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmppu8vxihr.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmppu8vxihr.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmppu8vxihr.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmppu8vxihr.cpp:2:\n/tmp/tmppu8vxihr.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    auto arr_it = arr.begin();\n\
    \    auto sum_it = arr.begin();\n    long sum = 0;\n    long product = 1;\n  \
    \  while ((arr_it != arr.end()) && (*arr_it != 0)) {\n        // Consider next\
    \ element.\n        sum += *arr_it;\n        // Consider sign of the next element.\n\
    \        product *= (*arr_it < 0) ? -1 : 0;\n        ++arr_it;\n    }\n    //\
    \ Check if sum is zero.\n    if (sum == 0) {\n        return std::nullopt;\n \
    \   }\n    return product*sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp7gb0pwtt.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7gb0pwtt.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7gb0pwtt.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7gb0pwtt.cpp:33:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   33 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7gb0pwtt.cpp:2:\n/tmp/tmp7gb0pwtt.cpp:34:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7gb0pwtt.cpp:34:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7gb0pwtt.cpp:34:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7gb0pwtt.cpp:34:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7gb0pwtt.cpp:34:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   34 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7gb0pwtt.cpp:2:\n/tmp/tmp7gb0pwtt.cpp:34:5: note:\
    \ to match this \u2018(\u2019\n   34 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n\n  long product = 1;\n  for (const auto i : arr) product *=\
    \ i;\n\n  std::vector<long> mag;\n  long max_mag = arr[0];\n  for (auto i : arr)\
    \ if (i > max_mag) max_mag = i;\n  for (auto i : arr) if (i < -max_mag) max_mag\
    \ = i;\n  mag = { max_mag, product };\n  for (auto i : arr) mag += { i, -i, 0\
    \ };\n\n  std::optional<long> sum;\n  long max_mag = std::max(mag[0].first, mag[0].second);\n\
    \  long min_mag = std::min(mag[0].first, mag[0].second);\n  for (size_t i = 1;\
    \ i < mag.size(); i++) {\n    if (mag[i].first > max_mag) max_mag = mag[i].first;\n\
    \    if (mag[i].second < min_mag) min_mag = mag[i].second;\n  }\n\n  for (long\
    \ i = 1; i < arr.size(); i++) {\n    if (arr[i] > 0) {\n      long mag = max_mag;\n\
    \      mag -= min_mag;\n      sum += product;\n      product *= mag;\n    } else\
    \ {\n      long mag = -max_mag;\n      mag += min_mag;\n      product *= mag;\n\
    \    }\n  }\n  return sum;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpksoozfvs.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpksoozfvs.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpksoozfvs.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpksoozfvs.cpp:47:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   47 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksoozfvs.cpp:2:\n/tmp/tmpksoozfvs.cpp:48:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   48 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpksoozfvs.cpp:48:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpksoozfvs.cpp:48:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   48 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpksoozfvs.cpp:48:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpksoozfvs.cpp:48:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   48 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpksoozfvs.cpp:2:\n/tmp/tmpksoozfvs.cpp:48:5: note:\
    \ to match this \u2018(\u2019\n   48 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    // initialize a variable to be\
    \ the product of signs of all elements\n    long prod = 1;\n    // initialize\
    \ a variable to be sum of magnitudes of all elements\n    long sum = 0;\n    //\
    \ initialize a variable to be magnitude of each element\n    std::vector<long>\
    \ mag(arr.size(), 0);\n    for (size_t i = 0; i < arr.size(); i++) {\n       \
    \ // find the magnitude of each element\n        mag[i] = abs(arr[i]);\n     \
    \   // calculate the sign\n        prod = (arr[i] > 0) ? prod : -prod;\n     \
    \   sum += mag[i] * prod;\n    }\n    // if sum is 0, return None because 0 *\
    \ 0 is zero\n    if (sum == 0) {\n        return std::nullopt;\n    }\n    return\
    \ sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgt9nx8i0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpgt9nx8i0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpgt9nx8i0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpgt9nx8i0.cpp:35:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   35 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgt9nx8i0.cpp:2:\n/tmp/tmpgt9nx8i0.cpp:36:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpgt9nx8i0.cpp:36:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpgt9nx8i0.cpp:36:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpgt9nx8i0.cpp:36:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpgt9nx8i0.cpp:36:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   36 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgt9nx8i0.cpp:2:\n/tmp/tmpgt9nx8i0.cpp:36:5: note:\
    \ to match this \u2018(\u2019\n   36 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if (n <= 0) return std::nullopt;\n    int sign = 1;\n    for (int i = 0;\
    \ i < n; ++i) {\n        if (arr[i] < 0) sign = -sign;\n    }\n    int ans = 1;\n\
    \    for (int i = 0; i < n; ++i) {\n        if (arr[i] != 0) {\n            ans\
    \ *= sign;\n            ans -= arr[i] * std::abs(arr[i]);\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpeyf1s8um.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpeyf1s8um.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpeyf1s8um.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpeyf1s8um.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeyf1s8um.cpp:2:\n/tmp/tmpeyf1s8um.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpeyf1s8um.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpeyf1s8um.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpeyf1s8um.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpeyf1s8um.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeyf1s8um.cpp:2:\n/tmp/tmpeyf1s8um.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n    std::vector<long> prod;\n    long sum\
    \ = 0;\n    for (auto i : arr) {\n        sum += i;\n        prod.push_back(0);\n\
    \        if (i < 0)\n            prod.back() = -1;\n    }\n    while (prod.back()\
    \ > 0) {\n        sum += prod.back();\n        prod.pop_back();\n    }\n    return\
    \ sum > 0 ? sum : std::nullopt;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmplbioz2e9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmplbioz2e9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmplbioz2e9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmplbioz2e9.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplbioz2e9.cpp:2:\n/tmp/tmplbioz2e9.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmplbioz2e9.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmplbioz2e9.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmplbioz2e9.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmplbioz2e9.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmplbioz2e9.cpp:2:\n/tmp/tmplbioz2e9.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  // First make array of signs\n  long signs[10];\n  for (int\
    \ i = 0; i < 10; i++) {\n    signs[i] = 0;\n  }\n  // Set signs of each element\
    \ of arr\n  for (int i = 0; i < arr.size(); i++) {\n    signs[arr[i]] = 1;\n \
    \ }\n  // Now find the sum of magnitudes\n  long sum = 0;\n  for (int i = 0; i\
    \ < 10; i++) {\n    sum += std::abs(i * signs[i]);\n  }\n  return sum;\n}\nint\
    \ main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyo13t6ig.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpyo13t6ig.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpyo13t6ig.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpyo13t6ig.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyo13t6ig.cpp:2:\n/tmp/tmpyo13t6ig.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpyo13t6ig.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpyo13t6ig.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpyo13t6ig.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpyo13t6ig.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpyo13t6ig.cpp:2:\n/tmp/tmpyo13t6ig.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ans = 0;\n \
    \   for (int i = 0; i < arr.size(); ++i) {\n        long prod = 1;\n        for\
    \ (int j = 0; j < i; ++j) {\n            prod *= arr[j] * std::sign(arr[i]);\n\
    \        }\n        ans += prod;\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq2_3rtgb.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpq2_3rtgb.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpq2_3rtgb.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpq2_3rtgb.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq2_3rtgb.cpp:2:\n/tmp/tmpq2_3rtgb.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpq2_3rtgb.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpq2_3rtgb.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpq2_3rtgb.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpq2_3rtgb.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq2_3rtgb.cpp:2:\n/tmp/tmpq2_3rtgb.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n\n    long prod = 1;\n    for (int i = 0; i < arr.size();\
    \ ++i) {\n        int sign = (arr[i] < 0 ? 1 : -1);\n        prod *= sign;\n \
    \   }\n\n    long ans = 0;\n    for (int i = 0; i < arr.size(); ++i) {\n     \
    \   int sign = (arr[i] < 0 ? 1 : -1);\n        ans += sign * pow(10, std::log10(abs(arr[i])));\n\
    \    }\n\n    return std::optional<long>(ans * prod);\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5fd9lzax.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp5fd9lzax.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp5fd9lzax.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp5fd9lzax.cpp:29:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   29 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5fd9lzax.cpp:2:\n/tmp/tmp5fd9lzax.cpp:30:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp5fd9lzax.cpp:30:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp5fd9lzax.cpp:30:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp5fd9lzax.cpp:30:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp5fd9lzax.cpp:30:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   30 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5fd9lzax.cpp:2:\n/tmp/tmp5fd9lzax.cpp:30:5: note:\
    \ to match this \u2018(\u2019\n   30 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  long sum = 0;\n  for (int i = 0; i < n; ++i) {\n    long v = arr[i];\n    for\
    \ (int j = i; j >= 0; j--) {\n      if (arr[j] < 0) v = -v;\n    }\n    sum +=\
    \ v;\n  }\n  return sum * std::signbit(sum);\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp32ladn9w.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp32ladn9w.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp32ladn9w.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp32ladn9w.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp32ladn9w.cpp:2:\n/tmp/tmp32ladn9w.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp32ladn9w.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp32ladn9w.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp32ladn9w.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp32ladn9w.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp32ladn9w.cpp:2:\n/tmp/tmp32ladn9w.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    long p = arr[0] * 1;\n    for (long x : arr)\n   \
    \     if (x < 0) p *= -1;\n    return p;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpeid5hrz7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpeid5hrz7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpeid5hrz7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpeid5hrz7.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeid5hrz7.cpp:2:\n/tmp/tmpeid5hrz7.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpeid5hrz7.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpeid5hrz7.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpeid5hrz7.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpeid5hrz7.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpeid5hrz7.cpp:2:\n/tmp/tmpeid5hrz7.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ return std::nullopt;\n    int n = arr.size();\n    long res = 0;\n    for (int\
    \ i = 0; i < n; i++) {\n        int sign = (arr[i] > 0) - (arr[i] < 0);\n    \
    \    res += (sign * arr[i]) * arr[i];\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpu2oybmy2.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpu2oybmy2.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpu2oybmy2.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpu2oybmy2.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu2oybmy2.cpp:2:\n/tmp/tmpu2oybmy2.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpu2oybmy2.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpu2oybmy2.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpu2oybmy2.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpu2oybmy2.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpu2oybmy2.cpp:2:\n/tmp/tmpu2oybmy2.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  // your logic here\n\
    \  int sum=0;\n  for (int i=0; i<arr.size(); i++){\n      if(arr[i]<0) sum*=-1;\n\
    \      if(arr[i]>0) sum+=arr[i];\n  }\n  return sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjctbzyp9.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjctbzyp9.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjctbzyp9.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjctbzyp9.cpp:21:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   21 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjctbzyp9.cpp:2:\n/tmp/tmpjctbzyp9.cpp:22:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjctbzyp9.cpp:22:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjctbzyp9.cpp:22:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjctbzyp9.cpp:22:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjctbzyp9.cpp:22:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   22 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjctbzyp9.cpp:2:\n/tmp/tmpjctbzyp9.cpp:22:5: note:\
    \ to match this \u2018(\u2019\n   22 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  long sum = 0;\n  for (int i = 0; i < arr.size(); i++)\n   \
    \ sum += arr[i] * (arr[i] < 0 ? 1 : -1);\n  return sum;\n}\nint main() {\n   \
    \ auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2,\
    \ 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9c9j5die.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp9c9j5die.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp9c9j5die.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp9c9j5die.cpp:19:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   19 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9c9j5die.cpp:2:\n/tmp/tmp9c9j5die.cpp:20:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp9c9j5die.cpp:20:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp9c9j5die.cpp:20:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp9c9j5die.cpp:20:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp9c9j5die.cpp:20:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   20 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp9c9j5die.cpp:2:\n/tmp/tmp9c9j5die.cpp:20:5: note:\
    \ to match this \u2018(\u2019\n   20 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty()) return\
    \ std::nullopt;\n  // write your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n  // your code here\n  // your code here\n  // your\
    \ code here\n  // your code here\n  // your code here\n  // your code here\n \
    \ // your code here\n  // your code here\n  // your code here\n  // your code\
    \ here\n  // your code here\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmp0ig08wwq.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0ig08wwq.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0ig08wwq.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0ig08wwq.cpp:140:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n  140 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0ig08wwq.cpp:2:\n/tmp/tmp0ig08wwq.cpp:141:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n  141 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0ig08wwq.cpp:141:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0ig08wwq.cpp:141:76:\
    \ error: expected primary-expression before \u2018long\u2019\n  141 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0ig08wwq.cpp:141:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0ig08wwq.cpp:141:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n  141 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0ig08wwq.cpp:2:\n/tmp/tmp0ig08wwq.cpp:141:5: note:\
    \ to match this \u2018(\u2019\n  141 |     assert(candidate((std::"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  if (arr.empty())\n\
    \    return std::nullopt;\n  long n = 0;\n  for (int i = 0; i != arr.size(); i++)\n\
    \    n = n * arr[i] * (arr[i] >= 0 ? 1 : -1);\n  return n;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfkg4upkx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpfkg4upkx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpfkg4upkx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpfkg4upkx.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfkg4upkx.cpp:2:\n/tmp/tmpfkg4upkx.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpfkg4upkx.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpfkg4upkx.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpfkg4upkx.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpfkg4upkx.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpfkg4upkx.cpp:2:\n/tmp/tmpfkg4upkx.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  std::optional<long>\
    \ product = 0;\n  for (const auto &v : arr) {\n    product *= (v > 0 ? 1 : -1);\n\
    \    product *= (v >= 0 ? 1 : -1);\n  }\n  return product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjt8y3w_y.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpjt8y3w_y.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpjt8y3w_y.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpjt8y3w_y.cpp:20:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   20 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjt8y3w_y.cpp:2:\n/tmp/tmpjt8y3w_y.cpp:21:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpjt8y3w_y.cpp:21:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpjt8y3w_y.cpp:21:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpjt8y3w_y.cpp:21:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpjt8y3w_y.cpp:21:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   21 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpjt8y3w_y.cpp:2:\n/tmp/tmpjt8y3w_y.cpp:21:5: note:\
    \ to match this \u2018(\u2019\n   21 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if (n == 0)\n    return None;\n  std::map<long, long> m;\n  for (int i = 0;\
    \ i < n; ++i) {\n    m[arr[i]] += 1;\n  }\n\n  long sum = 0;\n  for (auto it =\
    \ m.begin(); it != m.end(); ++it) {\n    sum += it->first * it->second;\n  }\n\
    \  return sum;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprtpw83un.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmprtpw83un.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmprtpw83un.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmprtpw83un.cpp:27:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   27 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprtpw83un.cpp:2:\n/tmp/tmprtpw83un.cpp:28:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmprtpw83un.cpp:28:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmprtpw83un.cpp:28:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmprtpw83un.cpp:28:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmprtpw83un.cpp:28:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   28 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmprtpw83un.cpp:2:\n/tmp/tmprtpw83un.cpp:28:5: note:\
    \ to match this \u2018(\u2019\n   28 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n\tif (arr.size() == 0)\
    \ {\n\t\treturn std::nullopt;\n\t}\n\tlong result = 0;\n\tfor (long i : arr) {\n\
    \t\tlong mag = abs(i);\n\t\tif (mag < 0) {\n\t\t\tresult *= -1;\n\t\t} else if\
    \ (mag > 0) {\n\t\t\tresult *= 1;\n\t\t}\n\t\tresult += mag;\n\t}\n\treturn result;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl05xhp3d.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpl05xhp3d.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpl05xhp3d.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpl05xhp3d.cpp:28:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   28 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl05xhp3d.cpp:2:\n/tmp/tmpl05xhp3d.cpp:29:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpl05xhp3d.cpp:29:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpl05xhp3d.cpp:29:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpl05xhp3d.cpp:29:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpl05xhp3d.cpp:29:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   29 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpl05xhp3d.cpp:2:\n/tmp/tmpl05xhp3d.cpp:29:5: note:\
    \ to match this \u2018(\u2019\n   29 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long long product\
    \ = 1;\n    long long sum = 0;\n    // for each number in the array\n    for (const\
    \ auto& num : arr)\n        // check if it's positive or negative\n        if\
    \ (num > 0)\n            sum += num;\n        else if (num < 0)\n            product\
    \ *= -num;\n    else\n        return std::nullopt;\n    return sum*product;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvrxpm2nm.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpvrxpm2nm.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpvrxpm2nm.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpvrxpm2nm.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvrxpm2nm.cpp:2:\n/tmp/tmpvrxpm2nm.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpvrxpm2nm.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpvrxpm2nm.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpvrxpm2nm.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpvrxpm2nm.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvrxpm2nm.cpp:2:\n/tmp/tmpvrxpm2nm.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // arr is empty return\
    \ None as default result\n    if (arr.empty()) {\n        return std::nullopt;\n\
    \    }\n    // Calculate product of all sign for each number\n    auto prod =\
    \ arr[0] * 1;\n    for (int i = 1; i < arr.size(); i++) {\n        prod = prod\
    \ * arr[i] * -1;\n    }\n    // Calculate the magnitude of the product\n    return\
    \ std::abs(prod);\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpom9jyq8z.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpom9jyq8z.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpom9jyq8z.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpom9jyq8z.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpom9jyq8z.cpp:2:\n/tmp/tmpom9jyq8z.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpom9jyq8z.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpom9jyq8z.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpom9jyq8z.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpom9jyq8z.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpom9jyq8z.cpp:2:\n/tmp/tmpom9jyq8z.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    // Your code goes\
    \ here\n    int n = arr.size();\n    long long ans = arr[0] * 1;\n    for (long\
    \ i = 1; i < n; i++) {\n        int x = arr[i];\n        if (x >= 0) {\n     \
    \       ans *= x;\n        } else {\n            ans *= -1 * x;\n        }\n \
    \   }\n    return ans;\n}\nint main() {\n    auto candidate = prod_signs;\n  \
    \  assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmps79y8quj.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmps79y8quj.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmps79y8quj.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmps79y8quj.cpp:26:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   26 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps79y8quj.cpp:2:\n/tmp/tmps79y8quj.cpp:27:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmps79y8quj.cpp:27:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmps79y8quj.cpp:27:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmps79y8quj.cpp:27:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmps79y8quj.cpp:27:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   27 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmps79y8quj.cpp:2:\n/tmp/tmps79y8quj.cpp:27:5: note:\
    \ to match this \u2018(\u2019\n   27 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    long ans = 0;\n \
    \   for (auto val : arr)\n        ans += val * std::signbit(val);\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpexxh0tp5.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpexxh0tp5.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpexxh0tp5.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpexxh0tp5.cpp:18:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   18 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpexxh0tp5.cpp:2:\n/tmp/tmpexxh0tp5.cpp:19:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpexxh0tp5.cpp:19:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpexxh0tp5.cpp:19:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpexxh0tp5.cpp:19:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpexxh0tp5.cpp:19:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   19 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpexxh0tp5.cpp:2:\n/tmp/tmpexxh0tp5.cpp:19:5: note:\
    \ to match this \u2018(\u2019\n   19 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.size() ==\
    \ 0)\n        return std::nullopt;\n\n    long product = 1;\n    long sum = 0;\n\
    \    for (auto i : arr) {\n        product *= i;\n        sum += i;\n    }\n\n\
    \    return sum < 0 ? sum * product : sum;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpnykddnq_.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpnykddnq_.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpnykddnq_.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpnykddnq_.cpp:25:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   25 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnykddnq_.cpp:2:\n/tmp/tmpnykddnq_.cpp:26:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpnykddnq_.cpp:26:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpnykddnq_.cpp:26:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpnykddnq_.cpp:26:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpnykddnq_.cpp:26:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   26 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpnykddnq_.cpp:2:\n/tmp/tmpnykddnq_.cpp:26:5: note:\
    \ to match this \u2018(\u2019\n   26 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    int n = arr.size();\n\
    \    if(n == 0) {\n        return {};\n    }\n    long prod = 1;\n    int sig\
    \ = 0;\n    long ret = 0;\n    for(int i = 0; i < n; i++) {\n        long val\
    \ = arr[i];\n        if(val < 0) {\n            sig = -1;\n        } else {\n\
    \            sig = 1;\n        }\n        ret += std::abs(val) * prod * sig;\n\
    \        prod *= sig;\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpbhfqb2va.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpbhfqb2va.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpbhfqb2va.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpbhfqb2va.cpp:32:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   32 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbhfqb2va.cpp:2:\n/tmp/tmpbhfqb2va.cpp:33:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpbhfqb2va.cpp:33:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpbhfqb2va.cpp:33:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpbhfqb2va.cpp:33:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpbhfqb2va.cpp:33:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   33 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbhfqb2va.cpp:2:\n/tmp/tmpbhfqb2va.cpp:33:5: note:\
    \ to match this \u2018(\u2019\n   33 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n    // Sort the array\n    std::sort(arr.begin(),\
    \ arr.end());\n    // If all elements are equal, return 0\n    if (std::unique(arr.begin(),\
    \ arr.end()) == arr.end())\n        return 0;\n    // If first element is 0, return\
    \ -1\n    if (arr[0] == 0)\n        return -1;\n    // If last element is 0, return\
    \ 1\n    if (arr[arr.size() - 1] == 0)\n        return 1;\n    // Initialize sum,\
    \ keep sum for first element as sum\n    long long sum = 0;\n    // Initialize\
    \ max and min_val\n    long long max_val = std::numeric_limits<long long>::min();\n\
    \    long long min_val = std::numeric_limits<long long>::max();\n    // Fill min\
    \ and max from first and last elements\n    min_val = arr[0];\n    max_val = arr[arr.size()\
    \ - 1];\n    for (auto i : arr)\n    {\n        // If element is 0, continue to\
    \ next iteration\n        if (i == 0)\n            continue;\n        // If element\
    \ is negative, set its sign to 1 and sum up its\n        // magnitude\n      \
    \  if (i < 0)\n        {\n            i = 1;\n            sum += i;\n        }\n\
    \        else\n        {\n            // If current element is larger than current\
    \ max, set its sign to\n            // 1 and set max to current element\n    \
    \        if (i > max_val)\n            {\n                i = 1;\n           \
    \     max_val = i;\n            }\n            // Else if current element is smaller\
    \ than current min,\n            // set its sign to -1 and set min to current\
    \ element\n            else if (i < min_val)\n            {\n                i\
    \ = -1;\n                min_val = i;\n            }\n        }\n    }\n    //\
    \ If all elements of array are same sign, return its magnitude\n    // and set\
    \ its sign to 1\n    if (sum > 0)\n        return sum;\n    // Else all elements\
    \ are opposite sign, return negative sign of\n    // minimum magnitude and set\
    \ its sign to -1\n    else\n        return -min_val;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpio5ksuy0.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpio5ksuy0.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpio5ksuy0.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpio5ksuy0.cpp:73:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   73 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpio5ksuy0.cpp:2:\n/tmp/tmpio5ksuy0.cpp:74:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   74 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpio5ksuy0.cpp:74:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpio5ksuy0.cpp:74:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   74 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpio5ksuy0.cpp:74:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpio5ksuy0.cpp:74:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   74 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpio5ksuy0.cpp:2:\n/tmp/tmpio5ksuy0.cpp:74:5: note:\
    \ to match this \u2018(\u2019\n   74 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\
    \ {\n        return std::nullopt;\n    }\n\n    long long res = 0;\n    for (auto\
    \ i : arr) {\n        res = (res * i) + ((i & 1) ? 1 : -1) * (res > 0 ? res :\
    \ 0);\n    }\n\n    return res;\n}\nint main() {\n    auto candidate = prod_signs;\n\
    \    assert(candidate((std::vector<long>({1, 2, 2, -4}))) == (std::optional<long>(-9)));\n\
    \    assert(candidate((std::vector<long>({0, 1}))) == (std::optional<long>(0)));\n\
    \    assert(candidate((std::vector<long>({1, 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n\
    \    assert(candidate((std::vector<long>())) == (std::optional<long>({})));\n\
    \    assert(candidate((std::vector<long>({2, 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, -1, 1}))) == (std::optional<long>(4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 1}))) == (std::optional<long>(-4)));\n\
    \    assert(candidate((std::vector<long>({-1, 1, 1, 0}))) == (std::optional<long>(0)));\n\
    }\n"
  stdout: ''
  stderr: "/tmp/tmpey_dsio3.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpey_dsio3.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpey_dsio3.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpey_dsio3.cpp:24:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   24 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpey_dsio3.cpp:2:\n/tmp/tmpey_dsio3.cpp:25:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpey_dsio3.cpp:25:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpey_dsio3.cpp:25:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpey_dsio3.cpp:25:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpey_dsio3.cpp:25:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   25 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpey_dsio3.cpp:2:\n/tmp/tmpey_dsio3.cpp:25:5: note:\
    \ to match this \u2018(\u2019\n   25 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (!arr.size())\
    \ return std::nullopt;\n\n    long ans = 0, sign = 1;\n    for (auto x: arr)\n\
    \        if (x < 0) sign = -sign;\n        ans += sign * x;\n\n    return ans;\n\
    }\nint main() {\n    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7plq4otx.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp7plq4otx.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp7plq4otx.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp7plq4otx.cpp:22:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   22 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7plq4otx.cpp:2:\n/tmp/tmp7plq4otx.cpp:23:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp7plq4otx.cpp:23:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp7plq4otx.cpp:23:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp7plq4otx.cpp:23:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp7plq4otx.cpp:23:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   23 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp7plq4otx.cpp:2:\n/tmp/tmp7plq4otx.cpp:23:5: note:\
    \ to match this \u2018(\u2019\n   23 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n    if (arr.empty())\n\
    \        return std::nullopt;\n\n    long product = 1;\n    for (auto elem : arr)\n\
    \        product *= elem;\n\n    long sign = 1;\n    for (auto elem : arr)\n \
    \       sign *= elem;\n\n    long sum = 0;\n    for (auto elem : arr)\n      \
    \  sum += std::abs(elem) * sign;\n\n    return sum * product;\n}\nint main() {\n\
    \    auto candidate = prod_signs;\n    assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpalxtg3j7.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmpalxtg3j7.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmpalxtg3j7.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmpalxtg3j7.cpp:30:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   30 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpalxtg3j7.cpp:2:\n/tmp/tmpalxtg3j7.cpp:31:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmpalxtg3j7.cpp:31:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmpalxtg3j7.cpp:31:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmpalxtg3j7.cpp:31:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmpalxtg3j7.cpp:31:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   31 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpalxtg3j7.cpp:2:\n/tmp/tmpalxtg3j7.cpp:31:5: note:\
    \ to match this \u2018(\u2019\n   31 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given an array\
    \ arr of integers and you need to return\n// sum of magnitudes of integers multiplied\
    \ by product of all signs\n// of each number in the array, represented by 1, -1\
    \ or 0.\n// Note: return None for empty arr.\n// Example:\n// >>> prod_signs([1,\
    \ 2, 2, -4]) == -9\n// >>> prod_signs([0, 1]) == 0\n// >>> prod_signs([]) == None\n\
    std::optional<long> prod_signs(std::vector<long> arr) {\n  int n = arr.size();\n\
    \  if (n < 0)\n    return std::nullopt;\n  long sum = 0;\n  for (int i = 0; i\
    \ < n; ++i) {\n    long v = arr[i];\n    if (v > 0) sum += v * ((v >= 0) ? 1 :\
    \ -1);\n  }\n  return sum == 0 ? std::nullopt : sum;\n}\nint main() {\n    auto\
    \ candidate = prod_signs;\n    assert(candidate((std::vector<long>({1, 2, 2, -4})))\
    \ == (std::optional<long>(-9)));\n    assert(candidate((std::vector<long>({0,\
    \ 1}))) == (std::optional<long>(0)));\n    assert(candidate((std::vector<long>({1,\
    \ 1, 1, 2, 3, -1, 1}))) == (std::optional<long>(-10)));\n    assert(candidate((std::vector<long>()))\
    \ == (std::optional<long>({})));\n    assert(candidate((std::vector<long>({2,\
    \ 4, 1, 2, -1, -1, 9}))) == (std::optional<long>(20)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, -1, 1}))) == (std::optional<long>(4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 1}))) == (std::optional<long>(-4)));\n    assert(candidate((std::vector<long>({-1,\
    \ 1, 1, 0}))) == (std::optional<long>(0)));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0hw362fv.cpp:11:6: error: \u2018optional\u2019 in namespace \u2018\
    std\u2019 does not name a template type\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      |      ^~~~~~~~\n/tmp/tmp0hw362fv.cpp:11:1: note: \u2018std::optional\u2019\
    \ is only available from C++17 onwards\n   11 | std::optional<long> prod_signs(std::vector<long>\
    \ arr) {\n      | ^~~\n/tmp/tmp0hw362fv.cpp: In function \u2018int main()\u2019\
    :\n/tmp/tmp0hw362fv.cpp:23:22: error: \u2018prod_signs\u2019 was not declared\
    \ in this scope\n   23 |     auto candidate = prod_signs;\n      |           \
    \           ^~~~~~~~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0hw362fv.cpp:2:\n/tmp/tmp0hw362fv.cpp:24:67: error:\
    \ \u2018optional\u2019 is not a member of \u2018std\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                            ^~~~~~~~\n/tmp/tmp0hw362fv.cpp:24:67:\
    \ note: \u2018std::optional\u2019 is only available from C++17 onwards\n/tmp/tmp0hw362fv.cpp:24:76:\
    \ error: expected primary-expression before \u2018long\u2019\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                     ^~~~\n/tmp/tmp0hw362fv.cpp:24:76:\
    \ error: expected \u2018)\u2019 before \u2018long\u2019\n/tmp/tmp0hw362fv.cpp:24:87:\
    \ error: expected \u2018)\u2019 before \u2018;\u2019 token\n   24 |     assert(candidate((std::vector<long>({1,\
    \ 2, 2, -4}))) == (std::optional<long>(-9)));\n      |                       \
    \                                                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cassert:44,\n     \
    \            from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp0hw362fv.cpp:2:\n/tmp/tmp0hw362fv.cpp:24:5: note:\
    \ to match this \u2018(\u2019\n   24 |     assert(candidate((std::vector<"
  exit_code: 1
  status: SyntaxError
