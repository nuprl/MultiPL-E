name: HumanEval_116_sort_array
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// In this Kata, you have to\
  \ sort an array of non-negative integers according to\n// number of ones in their\
  \ binary representation in ascending order.\n// For similar number of ones, sort\
  \ based on decimal value.\n// It must be implemented like this:\n// >>> sort_array([1,\
  \ 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n// >>> sort_array([-2, -3, -4, -5, -6]) == [-6,\
  \ -5, -4, -3, -2]\n// >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\nstd::vector<long>\
  \ sort_array(std::vector<long> arr) {\n"
tests: "}\nint main() {\n    auto candidate = sort_array;\n    assert(candidate((std::vector<long>({1,\
  \ 5, 2, 3, 4}))) == (std::vector<long>({1, 2, 4, 3, 5})));\n    assert(candidate((std::vector<long>({-2,\
  \ -3, -4, -5, -6}))) == (std::vector<long>({-4, -2, -6, -5, -3})));\n    assert(candidate((std::vector<long>({1,\
  \ 0, 2, 3, 4}))) == (std::vector<long>({0, 1, 2, 4, 3})));\n    assert(candidate((std::vector<long>()))\
  \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({2, 5, 77,\
  \ 4, 5, 3, 5, 7, 2, 3, 4}))) == (std::vector<long>({2, 2, 4, 4, 3, 3, 5, 5, 5, 7,\
  \ 77})));\n    assert(candidate((std::vector<long>({3, 6, 44, 12, 32, 5}))) == (std::vector<long>({32,\
  \ 3, 5, 6, 12, 44})));\n    assert(candidate((std::vector<long>({2, 4, 8, 16, 32})))\
  \ == (std::vector<long>({2, 4, 8, 16, 32})));\n    assert(candidate((std::vector<long>({2,\
  \ 4, 8, 16, 32}))) == (std::vector<long>({2, 4, 8, 16, 32})));\n}\n"
completions: ["    // Write your code here\n    long a = 0;\n    long b = 0;\n   \
    \ long count = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    for\
    \ (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == 1) {\n           \
    \ count++;\n        } else {\n            x = count;\n            count = 1;\n\
    \            y = a;\n            a = b;\n            b = z;\n            z = arr[i];\n\
    \        }\n    }\n    std::vector<long> res(arr.size());\n    res[0] = x;\n \
    \   res[1] = y;\n    res[2] = z;\n    res[3] = a;\n    res[4] = b;\n    return\
    \ res;", "    long result = 0, sum = 0;\n    for (auto elem : arr) {\n       \
    \ sum += elem;\n    }\n    long sum_to_0 = sum - 1;\n    long count = 1;\n   \
    \ for (auto elem : arr) {\n        result += (elem + 1) * (sum_to_0 - result);\n\
    \        sum_to_0 -= count;\n        count++;\n    }\n    auto it = std::lower_bound(arr.begin(),\
    \ arr.end(), result);\n    arr.erase(it, arr.end());\n    for (auto elem : arr)\
    \ {\n        result += elem;\n    }\n    return arr;", "    // Write your code\
    \ here\n    return arr;", "    // Your code goes here\n    long long arrSize =\
    \ arr.size();\n    long long ones = 0, zeros = 0;\n    for (long long i = 0; i\
    \ != arrSize; i++) {\n        if (arr[i] == 1)\n            ones++;\n        else\n\
    \            zeros++;\n    }\n\n    long long temp = ones * 10 + zeros;\n\n  \
    \  for (long long i = 0; i < arrSize; i++) {\n        if (arr[i] == ones) {\n\
    \            arr[i] = temp;\n            temp--;\n        }\n    }\n    return\
    \ arr;", "  std::vector<long> result;\n  for (auto it1 : arr) {\n    for (auto\
    \ it2 : arr) {\n      if (it1 == it2 && it1 != it2) {\n        std::swap(it1,\
    \ it2);\n      }\n    }\n    result.push_back(it1);\n  }\n  return result;", " \
    \   assert(arr.size() != 0);\n    // create an array of zeros, sort it, and copy\
    \ it back\n    std::vector<long> result(arr.size());\n    std::iota(result.begin(),\
    \ result.end(), 0);\n    std::sort(result.begin(), result.end(), [&arr](long a,\
    \ long b) -> bool {\n        return arr[a] == arr[b];\n    });\n    arr.assign({0});\n\
    \    std::transform(arr.begin(), arr.end(), arr.begin(), [&result](long num) ->\
    \ bool {\n        return result.back() <= num;\n    });\n    result.assign({0});\n\
    \    return result;", "    if (arr.empty()) {\n        return arr;\n    }\n  \
    \  // sort based on the number of ones in the binary representation\n    std::sort(arr.begin(),\
    \ arr.end(), [](const long &a, const long &b) -> bool {\n        return count_bits(a)\
    \ < count_bits(b);\n    });\n    // sort based on the decimal representation\n\
    \    std::sort(arr.begin(), arr.end(), [](const long &a, const long &b) -> bool\
    \ {\n        return a < b;\n    });\n    return arr;", "    long result = 0;\n\
    \    for (const auto& i : arr) {\n        long count = i;\n        for (;count\
    \ != 0; count/=2) {\n            result += count;\n        }\n    }\n    std::sort(arr.begin(),\
    \ arr.end(),\n             [&](long a, long b) -> bool {return result<a-b; });\n\
    \    return arr;", "  assert(arr.size() > 0);\n  // Get number of ones in binary\
    \ representation of all the numbers in arr\n  auto ones_in_binary = [&]() {\n\
    \    long res = 0;\n    for (int i = 0; i < arr.size(); i++) {\n      auto val\
    \ = arr[i];\n      if (val != 0) res += (val == 1) ? 1 : 0;\n    }\n    return\
    \ res;\n  };\n  // If the number of ones in binary representation is same as the\
    \ number\n  // of elements in the array, the arr is already in ascending order\
    \ so we\n  // can just return that array.\n  if (ones_in_binary() == arr.size())\
    \ return arr;\n  auto compare = [&](long a, long b) -> bool {\n    auto res =\
    \ a > b ? 1 : a < b ? -1 : 0;\n    // Since we sort the array in ascending order\
    \ and we want the arr to\n    // be in descending order, we flip the comparison\
    \ here and reverse the\n    // sorted array at the end.\n    return res == 0 ?\
    \ a > b ? 1 : a < b ? -1 : 0;\n  };\n  // First sort on number of ones in binary\
    \ representation\n  std::sort(arr.begin(), arr.end(), compare);\n  // Then sort\
    \ on decimal representation of the numbers in ascending order.\n  std::stable_sort(arr.begin(),\
    \ arr.end(), compare);\n  return arr;", "    std::vector<long> result;\n    result.push_back(arr[0]);\n\
    \    for (size_t i = 1; i < arr.size(); i++) {\n        // Binary representation\
    \ of \"i\" counts how many ones are in it\n        long bin_i = arr[i];\n    \
    \    // Convert it to decimal\n        long num_ones = 1;\n        while (bin_i\
    \ > 0) {\n            bin_i /= 2;\n            num_ones++;\n        }\n      \
    \  result.push_back(arr[i] - num_ones * pow(10, arr.size() - i - 1));\n    }\n\
    \    return std::move(result);", "  std::sort(arr.begin(), arr.end(), \n     \
    \       [&arr](int i, int j) -> bool {\n              if (arr[i] + arr[j] == 0)\
    \ {\n                return i - j;\n              } else {\n                return\
    \ arr[i] + arr[j];\n              }\n            });\n  return arr;", "    long\
    \ max_digit = 0;\n    for (long n: arr) {\n        max_digit = max(max_digit,\
    \ n);\n    }\n    std::vector<long> out;\n    for (long n: arr) {\n        long\
    \ cnt = 0;\n        while (n > 0) {\n            cnt += n & 1;\n            n\
    \ >>= 1;\n        }\n        out.push_back(cnt);\n    }\n    std::sort(out.begin(),\
    \ out.end());\n    std::vector<long> ret;\n    for (long n: out) {\n        ret.push_back(n);\n\
    \    }\n    ret.push_back(max_digit);\n    return ret;", "    assert(arr.size()\
    \ >= 2);\n    // First of all, we need to find out how many ones are there in\
    \ arr[]\n    int ones = 0;\n    for (auto i : arr)\n        ones = i + ones;\n\
    \    // Now we know how many ones are there in arr[]\n    // After that, we can\
    \ start sorting the array based on the number\n    // of ones.\n    // For example\
    \ if there are three ones in arr[], we need to find out the place\n    // of first\
    \ one and store its index. Then we will start sorting from that place\n    int\
    \ place = -1;\n    int ones_place = 0;\n    while (ones_place < ones) {\n    \
    \    place = -1;\n        int ones_place = 0;\n        for (int i = 0; i < ones;\
    \ i++) {\n            int temp = arr[i];\n            // If temp is 1, we are\
    \ at the right place\n            // If temp is 0, we are at wrong place\n   \
    \         if (temp == 1) {\n                place = i;\n                break;\n\
    \            }\n        }\n        // After we found the place, we need to update\
    \ the ones_place to keep track\n        // of how many ones are left in the array.\n\
    \        // For example if there are three ones in arr[], we will update ones_place\
    \ to\n        // one and break from the loop.\n        if (place != -1) {\n  \
    \          ones_place++;\n            // Now that we found the right place, we\
    \ can begin to sort the array\n            // based on the number of ones\n  \
    \          std::vector<long> new_arr;\n            for (auto i : arr) {\n    \
    \            // If we have reached the right place, we should stop sorting\n \
    \               // the array\n                if (i == place) {\n            \
    \        break;\n                }\n                new_arr.push_back(i);\n  \
    \          }\n            // After we sort arr[], we need to append new_arr to\
    \ arr[]\n            // For example if there are three ones in arr[], we should\n\
    \            // append the new array at the end of arr[]\n            std::reverse(arr.begin(),\
    \ arr.begin() + place);\n            arr.insert(arr.end(), new_arr.begin(), new_arr.end());\n\
    \        } else {\n            break;\n        }\n    }\n    return arr;", " \
    \ std::vector<long> output;\n  assert(arr.size() != 0);\n  for (long i = 0; i\
    \ < arr.size(); i++)\n    for (long j = i + 1; j < arr.size(); j++)\n      if\
    \ (arr[j] & arr[i]) {\n        if (arr[j] & 1)\n          output.push_back(arr[j]);\n\
    \        arr[j] ^= arr[i];\n        arr[i] ^= arr[j];\n        arr[j] ^= arr[i];\n\
    \      }\n  std::sort(output.begin(), output.end(), [&arr](int x, int y) -> bool\
    \ {\n    if (x >= arr.size() || y >= arr.size() || x <= y || x <= y || x != y)\n\
    \      return false;\n    if (x == y)\n      return false;\n    return arr[x]\
    \ > arr[y];\n  });\n  return output;", "    int n = arr.size();\n    if (n < 2)\
    \ return arr;\n\n    std::vector<long> result;\n    result.reserve(n);\n    for\
    \ (long i : arr) result.push_back(i);\n\n    long prev = result[0], curr = 0;\n\
    \    for (size_t i = 1; i < result.size(); ++i) {\n        long temp = result[i];\n\
    \        long curr_two = 0;\n        while (temp) {\n            if (temp % 2)\
    \ curr_two += 2;\n            temp = temp / 2;\n        }\n        if (curr_two\
    \ < prev) std::swap(curr, prev);\n        prev = curr;\n        curr = curr_two;\n\
    \    }\n\n    return result;", "    // Write your sorting code here.\n    // Your\
    \ code should return vector<long> arr\n    assert(arr.size() > 0);\n    long n\
    \ = arr[0];\n    long m = arr.size() - 1;\n    long temp = 0;\n    long arr1 =\
    \ arr;\n    while (m != -1) {\n        while (m != n && arr[m] > n) {\n      \
    \      temp = n;\n            n = arr[m];\n            arr[m] = temp;\n      \
    \  }\n        while (m != n && arr[m] < n) {\n            temp = m-1;\n      \
    \      m = m-1;\n            arr[m] = arr[m+1];\n        }\n    }\n    std::vector<long>\
    \ ret(arr.size()/2);\n    for (int i=0;i<ret.size()-1;i++) {\n        if (arr[i]\
    \ > arr[i+1]) {\n            ret[i] = arr[i+1];\n            ret[i+1] = arr[i];\n\
    \        }\n    }\n    std::vector<long> ret2;\n    for (int i=0;i<ret.size()-1;i++)\
    \ {\n        ret2.push_back(ret[i]);\n    }\n    return ret2;", "    // Sort by\
    \ descending number\n    std::sort(arr.begin(), arr.end(), \n              [&arr](int\
    \ i, int j) -> bool {return (arr[i] < arr[j]); });\n    // Get binary representation\
    \ of number\n    std::string binary_arr;\n    for (long i = 0; i<arr.size(); i++)\
    \ {\n        binary_arr.push_back((arr[i] ^ 1) << i);\n    }\n    // Get count\
    \ of '1' in binary\n    int cnt = binary_arr.size() - 1;\n    // For every pair\
    \ of '1' in binary, sort them in ascending order based on\n    // their decimal\
    \ value\n    for (int i = 0; i < binary_arr.size(); i++) {\n        for (int j\
    \ = i + 1; j < binary_arr.size(); j++) {\n            int d1 = binary_arr[i] -\
    \ '0';\n            int d2 = binary_arr[j] - '0';\n            if (d1 < d2) {\n\
    \                std::swap(d1, d2);\n                std::swap(binary_arr[i],\
    \ binary_arr[j]);\n            }\n        }\n    }\n    // Reverse the sorted\
    \ array \n    binary_arr.resize(arr.size());\n    std::copy(binary_arr.begin(),\
    \ binary_arr.end(), arr.begin());\n    return arr;", "    std::sort(arr.begin(),\
    \ arr.end());\n    int cnt = 0;\n    for (long i : arr) {\n        if (i % 2)\
    \ {\n            cnt++;\n        }\n    }\n    std::vector<long> res;\n    for\
    \ (long i : arr) {\n        if (i % 2) {\n            res[cnt - 1 - (cnt % 2)]\
    \ = i;\n        }\n    }\n    return res;", "  int arr_size = arr.size();\n  std::vector<long>\
    \ sorted_arr(arr_size);\n  // If arr[i] == 0, then i-1 has nothing to do, so no\
    \ sorting is needed\n  for (int i = 0; i < arr_size - 1; i++) {\n    if (arr[i]\
    \ == 0) {\n      continue;\n    }\n    // If arr[i+1] == 0, then i-1 is sorted\
    \ and can be ignored\n    if (arr[i + 1] == 0) {\n      continue;\n    }\n   \
    \ // If number of ones in arr[i] and arr[i+1] are different\n    if (arr[i] &\
    \ arr[i + 1]) {\n      int temp = arr[i + 1];\n      arr[i + 1] = arr[i];\n  \
    \    arr[i] = temp;\n    }\n  }\n  // If arr[i] == 0, then i-1 has nothing to\
    \ do, so no sorting is needed\n  for (int i = 0; i < arr_size - 1; i++) {\n  \
    \  if (arr[i] == 0) {\n      continue;\n    }\n    // If arr[i+1] == 0, then i-1\
    \ is sorted and can be ignored\n    if (arr[i + 1] == 0) {\n      continue;\n\
    \    }\n    // If number of ones in arr[i] and arr[i+1] are different\n    if\
    \ (arr[i] & arr[i + 1]) {\n      // If arr[i] is greater than arr[i+1], swap the\
    \ values\n      if (arr[i] > arr[i + 1]) {\n        std::swap(arr[i + 1], arr[i]);\n\
    \      }\n      // If arr[i+1] is greater than arr[i], swap the values\n     \
    \ if (arr[i + 1] > arr[i]) {\n        std::swap(arr[i + 1], arr[i]);\n      }\n\
    \    }\n  }\n  return sorted_arr;", "    // Step 1: find number of ones in array\n\
    \    int num_ones = 0;\n    for (long &val : arr) {\n        val = val & -val;\n\
    \        num_ones += val ? 1 : 0;\n    }\n\n    // Step 2: sort the array according\
    \ to number of ones\n    std::vector<long> sorted_arr;\n    for (long &val : arr)\
    \ {\n        val = val & -val;\n        sorted_arr.push_back(val);\n    }\n\n\
    \    // Step 3: find number of ones for each value in sorted array\n    std::vector<long>\
    \ sorted_arr_big(num_ones);\n    for (long &val : sorted_arr) {\n        sorted_arr_big[val\
    \ & -val] += val;\n    }\n\n    // Step 4: sort array according to number of ones\n\
    \    long temp_val = 0;\n    for (int i = 0; i < num_ones; i++) {\n        std::vector<long>\
    \ sorted_arr_small;\n        for (long &val : sorted_arr) {\n            val =\
    \ val & -val;\n            if (val && sorted_arr_big[val & -val] <= temp_val)\
    \ {\n                sorted_arr_small.push_back(val);\n                sorted_arr_big[val\
    \ & -val] -= val;\n            }\n        }\n        sorted_arr.swap(sorted_arr_small);\n\
    \        temp_val = sorted_arr_big[i];\n    }\n\n    return sorted_arr;", "  \
    \  assert(arr.size() > 0);\n    int ones = 0;\n    int maxOnes = 0;\n    for (long\
    \ val : arr) {\n        ones += val;\n        maxOnes = std::max(maxOnes, ones);\n\
    \    }\n    std::vector<long> result; // This vector should contain the result.\n\
    \    for (long i = maxOnes; i < arr.size(); i++) {\n        long ones = 0;\n \
    \       for (long val : arr) {\n            ones += val;\n            if (ones\
    \ == i)\n                result.push_back(val);\n        }\n    }\n    return\
    \ result;", "    assert(arr.size() >= 1);\n    // Use counting sort for better\
    \ performance\n    int counter[65536]; // Initialize all elements to 0\n    for\
    \ (long i : arr) {\n        ++counter[i & 65535]; // Increment only odd element\
    \ to 1\n    }\n    for (int i = 1; i < 65536; ++i) // For every element in counter\
    \ array,\n    {\n        counter[i] += counter[i - 1]; // Increment all element\
    \ to counter\n    }\n    std::vector<long> res(arr.size()); // Res is the result\n\
    \    // Sort counter array by counter[i]\n    for (int i = 0; i < 65536; ++i)\n\
    \    {\n        std::swap(res[i], arr[counter[i]]); // Swap the ith element of\
    \ counter array\n    }\n    return res;", "  std::sort(arr.begin(), arr.end());\n\
    \  return arr;", "  std::vector<long> res;\n  res.reserve(arr.size());\n  int\
    \ size = arr.size();\n  for (int i = 0; i < size; i++) {\n    long num = arr[i];\n\
    \    long count = 0;\n    while (num > 0) {\n      int mod = num % 2;\n      num\
    \ = num / 2;\n      count++;\n    }\n    res.push_back(count);\n  }\n  std::sort(res.begin(),\
    \ res.end());\n  res.insert(res.begin(), 0);\n  for (int i = 0; i < size; i++)\
    \ {\n    long num = arr[i];\n    long count = 0;\n    while (num > 0) {\n    \
    \  int mod = num % 2;\n      num = num / 2;\n      count++;\n    }\n    int idx\
    \ = res.find(count);\n    arr[i] = idx + 1;\n  }\n  return arr;", "    // Write\
    \ your code here\n    std::vector<long> sorted_arr(arr.size());\n    std::iota(sorted_arr.begin(),\
    \ sorted_arr.end(), 0);\n    long count = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        while ((arr[i] & 1) == 1) {\n            count += 1;\n     \
    \       arr[i] >>= 1;\n        }\n        long pos = sorted_arr[arr[i] - 1] -\
    \ 1;\n        sorted_arr[arr[i] - 1] = i;\n        std::swap(sorted_arr[i], sorted_arr[pos]);\n\
    \    }\n    return sorted_arr;", '  // Solution here', "    std::sort(arr.begin(),\
    \ arr.end(), [](const long &x, const long &y) {\n        return __builtin_popcount(x)\
    \ < __builtin_popcount(y);\n    });\n    auto zeros = std::count(arr.begin(),\
    \ arr.end(), 0);\n    if (zeros > 0) {\n        for (auto i = 0u; i < zeros; i++)\
    \ std::rotate(arr.begin(), arr.begin() + i, arr.end());\n    }\n    return arr;",
  '    // Write your code here.', "    // sort the array in ascending order\n    //\
    \ If two numbers have the same number of ones,\n    // then compare them according\
    \ to their decimal value.\n    sort(arr.begin(), arr.end(), std::greater<long>());\n\
    \    return arr;", "    int size = arr.size();\n    int min_size = size;\n   \
    \ int max_size = 0;\n    int ones = 0;\n    long min = 0;\n    long max = 0;\n\
    \n    while (ones < size && ones < min_size) {\n        ones += arr[size - ones];\n\
    \        --size;\n        min_size = size;\n    }\n    max = arr[size - 1];\n\n\
    \    while (ones < size && ones < max_size) {\n        ones += arr[size - ones];\n\
    \        max_size = size;\n    }\n\n    max = arr[size - 1];\n\n    while (min_size\
    \ != max_size) {\n        while (ones < min_size) {\n            ones += arr[size\
    \ - ones];\n            ++size;\n            min_size = size;\n        }\n   \
    \     while (ones < max_size) {\n            ones += arr[size - ones];\n     \
    \       --size;\n            max_size = size;\n        }\n\n        int cmp =\
    \ max - min;\n        min = arr[size - 1];\n        max = arr[size - 1];\n\n \
    \       if (cmp == 0) return arr;\n        std::swap(min, arr[size - 1]);\n\n\
    \        ones = size - 1;\n        while (ones > 0) {\n            int cur_ones\
    \ = ones;\n            ones = ones - 1;\n            int cur_cmp = arr[size -\
    \ cur_ones];\n            int cmp = cur_cmp - min;\n            std::swap(arr[size\
    \ - cur_ones], arr[size - ones]);\n        }\n    }\n    return arr;", "  std::sort(arr.begin(),\
    \ arr.end(), [&arr](const long &a, const long &b) -> bool {\n    const long &\
    \ ones = std::count_if(arr.begin(), arr.end(), [](auto v) { return v == 1; });\n\
    \    if (ones == 0) {\n      // If the number of ones is the same in both elements,\n\
    \      // sort based on decimal value.\n      return a < b;\n    }\n    return\
    \ a > b;\n  });\n  return arr;", "    std::vector<long> ret(arr.size());\n   \
    \ int n_ones = 0;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i]\
    \ != 0) {\n            n_ones++;\n            ret[i] = n_ones;\n        } else\
    \ {\n            n_ones = 0;\n        }\n    }\n    sort(ret.begin(), ret.end());\n\
    \    return ret;", "    // assert (arr);\n    // find number of ones in arr\n\
    \    size_t count = 0;\n    for (long i : arr)\n        if (i) ++count;\n    \n\
    \    // sort arr based on number of ones in arr\n    long max_pow = 1;\n    std::vector<long>\
    \ sorted_arr(arr.size());\n    for (long i : arr) {\n        sorted_arr[i] = max_pow;\n\
    \        long temp = max_pow;\n        while(temp > i && max_pow) {\n        \
    \    max_pow = max_pow * 2;\n            temp /= 2;\n        }\n        sorted_arr[i]\
    \ = temp;\n    }\n\n    // find first index\n    size_t max_index = sorted_arr.size()\
    \ - 1;\n    long index_pow = 1;\n    long index = 0;\n    while (index_pow <=\
    \ count && index != max_index) {\n        index = index * 2;\n        index_pow\
    \ = index_pow * 2;\n        if (index_pow > count) {\n            index = -1;\n\
    \            break;\n        }\n    }\n\n    // sort the rest based on index\n\
    \    if (index == -1) {\n        for (size_t i = 0; i < arr.size(); ++i)\n   \
    \         sorted_arr[i] = arr[i];\n        return sorted_arr;\n    } else {\n\
    \        std::vector<long> remaining(arr.size() - index);\n        std::vector<long>\
    \ copy;\n        for (size_t i = 0; i < remaining.size(); ++i)\n            copy.push_back(remaining[i]);\n\
    \        std::sort(copy.begin(), copy.end(), std::greater<long>());\n        for\
    \ (size_t i = 0; i < copy.size(); ++i)\n            sorted_arr[index + i] = copy[i];\n\
    \        return sorted_arr;\n    }", "    // TODO: your code goes here\n    std::vector<long>\
    \ ans;\n    for (auto x : arr){\n        if (x==0){\n            ans.push_back(x);\n\
    \        }else{\n            long y=x;\n            long count=1;\n          \
    \  while(y!=0){\n                y=y&(y-1);\n                count++;\n      \
    \      }\n            ans.push_back(count);\n        }\n    }\n    long cnt=0;\n\
    \    for (auto x : ans){\n        cnt+=x;\n    }\n    long maxcnt=0;\n    for\
    \ (auto x : ans){\n        if (x>maxcnt){\n            maxcnt=x;\n        }\n\
    \    }\n    for (auto x : ans){\n        if (x<maxcnt){\n            ans.erase(std::find(ans.begin(),ans.end(),x-maxcnt));\n\
    \        }\n    }\n    return ans;", "    std::vector<long> result;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        bool has_zero = false;\n        int index\
    \ = 0;\n        while (arr[i] != 0) {\n            index = i * 2 + 1;\n      \
    \      arr[i] %= 10;\n            has_zero = true;\n            i++;\n       \
    \ }\n        if (!has_zero) {\n            result.push_back(arr[index]);\n   \
    \     }\n    }\n    return result;", "    long long count_of_ones = 0;\n    std::vector<long>\
    \ new_arr;\n    std::vector<long> temp;\n    std::sort(arr.begin(), arr.end(),\
    \ [&count_of_ones] (long long &a, long long &b) {\n        if (count_of_ones ==\
    \ 0) {\n            return a < b;\n        }\n        return count_of_ones > 0\
    \ ? a < b : a > b;\n    });\n    for (auto it : arr) {\n        count_of_ones++;\n\
    \    }\n    for (auto it = arr.begin(); it != arr.end(); it++) {\n        if (count_of_ones\
    \ > 0) {\n            if (*it == 0) {\n                temp.push_back(*it);\n\
    \                count_of_ones--;\n            } else {\n                new_arr.push_back(temp[0]);\n\
    \                new_arr.push_back(*it);\n                temp.erase(0);\n   \
    \         }\n        } else {\n            new_arr.push_back(*it);\n        }\n\
    \    }\n    return new_arr;", "  int n = arr.size();\n  std::vector<long> res(n);\n\
    \  for (int i = 0; i < n; i++) {\n    int count = 0;\n    for (int j = 0; j <\
    \ n; j++) {\n      if (i == j) {\n        continue;\n      }\n      if (arr[j]\
    \ & i) {\n        count++;\n      }\n    }\n    if (count == 0) {\n      res[i]\
    \ = 0;\n    } else {\n      res[i] = count;\n    }\n  }\n  std::sort(res.begin(),\
    \ res.end());\n  return res;", "    std::vector<long> new_arr(arr.size());\n \
    \   for (long i = 0; i < arr.size(); i++) {\n        int cnt = 0;\n        for\
    \ (auto x : arr)\n            if ((x & 1LLu) == 1LLu) cnt++;\n        new_arr[i]\
    \ = cnt;\n    }\n\n    int cnt = 0;\n    for (auto x : arr)\n        if ((x &\
    \ 1LLu) == 1LLu) cnt++;\n\n    int pos = 0;\n    int min = 0;\n    for (int i\
    \ = 0; i < new_arr.size(); i++)\n        if (new_arr[i] > new_arr[min])\n    \
    \        min = i;\n    if (cnt == new_arr[min]) {\n        pos = min;\n      \
    \  auto x = arr[min];\n        for (auto y : arr)\n            if ((y & 1LLu)\
    \ == x)\n                pos = 0;\n    }\n    else {\n        pos = min;\n   \
    \ }\n\n    for (int i = 1; i < arr.size(); i++) {\n        if (new_arr[pos] !=\
    \ new_arr[i]) {\n            pos = 0;\n            break;\n        }\n    }\n\
    \    std::vector<long> ans;\n    ans.push_back(arr[pos]);\n    pos = 0;\n    for\
    \ (int i = 0; i < new_arr.size(); i++) {\n        if (new_arr[pos] != new_arr[i])\
    \ {\n            ans.push_back(new_arr[i]);\n            pos = 0;\n        }\n\
    \        else\n            pos++;\n    }\n    return ans;", "    if (arr.empty())\
    \ return arr;\n    std::sort(arr.begin(), arr.end(), [](int a, int b) {\n    \
    \    int s = __builtin_popcount(a) - __builtin_popcount(b);\n        return s\
    \ > 0 ? s : -s;\n    });\n    return arr;", "    long count = 0;\n    for (long\
    \ num: arr) {\n        if (num == 1) count++;\n    }\n\n    std::vector<long>\
    \ ret;\n    ret.reserve(arr.size());\n    for (long num: arr) {\n        if (num\
    \ == 1) ret.push_back(count);\n    }\n\n    return ret;", "  std::vector<long>\
    \ ans;\n  long cnt = 0;\n  for (int i = 0; i < arr.size(); i++) {\n    if (arr[i]\
    \ == 1) {\n      cnt++;\n    } else {\n      ans.push_back(arr[i]);\n    }\n \
    \ }\n  long max_cnt = arr.size() - cnt;\n  if (max_cnt != 0) {\n    ans.push_back(max_cnt);\n\
    \  }\n  for (int i = arr.size() - 1; i >= 0; i--) {\n    if (arr[i] == 1) {\n\
    \      cnt--;\n    } else {\n      ans.push_back(arr[i]);\n    }\n  }\n  std::sort(ans.begin(),\
    \ ans.end());\n  return ans;", "  std::sort(arr.begin(), arr.end(), [](long &x,\
    \ long &y) {\n    long xl = __builtin_popcount(x);\n    long yl = __builtin_popcount(y);\n\
    \    return yl < xl;\n  });\n  std::vector<long> result = {0, };\n  for (long\
    \ &i : arr) {\n    long bits = __builtin_popcount(i);\n    result.push_back(result.size()\
    \ - result.back() + bits);\n  }\n  return result;", "    auto size = arr.size();\n\
    \    std::vector<long> ret(size);\n    auto max_ones = 0, max_ones_val = 0;\n\
    \    for (long & i : ret) {\n        i = arr[i];\n        if (i > 0) {\n     \
    \       if (max_ones < i) {\n                max_ones = i;\n                max_ones_val\
    \ = i;\n            }\n        } else {\n            if (max_ones == i) {\n  \
    \              max_ones_val = i;\n            }\n        }\n    }\n    if (max_ones\
    \ == 0) {\n        return ret;\n    }\n    auto cur_val = max_ones_val;\n    int\
    \ i = 0;\n    for (; i < size; i++) {\n        if (arr[i] != cur_val) {\n    \
    \        for (long j = i; j < size; j++) {\n                ret[j] = arr[j];\n\
    \            }\n            i = j;\n            cur_val = arr[i];\n        }\n\
    \    }\n    for (; i < size; i++) {\n        ret[i] = arr[i];\n    }\n    return\
    \ ret;", "  long num_ones = 0;\n  for (const auto i : arr) num_ones <<= 1;\n \
    \ std::vector<long> result(num_ones);\n  for (const auto i : arr) {\n    int num_bits\
    \ = 0;\n    while (i) {\n      num_bits += i & 1;\n      i >>= 1;\n    }\n   \
    \ result[num_bits] = i;\n  }\n  std::sort(result.begin(), result.end());\n  for\
    \ (auto i : result) if (i == 0) return arr;\n  throw std::runtime_error(\"This\
    \ should not happen\");", '  // Sorting logic goes here', "    assert(arr.size()\
    \ > 0);\n    std::vector<long> res(arr.begin(), arr.end());\n    std::sort(res.begin(),\
    \ res.end());\n    if (res.size() == 0)\n        return res;\n    long sum = 0;\n\
    \    for (auto i : res)\n        sum += i;\n    std::vector<long> res2(arr.begin(),\
    \ arr.end());\n    std::transform(res2.begin(), res2.end(), res2.begin(), [sum](long\
    \ i) {\n        long val = i;\n        for (auto j : res)\n            val -=\
    \ j;\n        return val + sum;\n    });\n    return res2;", "    // Your code\
    \ here\n    if(arr.size() == 0)\n        return arr;\n    auto prev = arr[0];\n\
    \    for(auto i : arr){\n        int c = 0;\n        long ans = i;\n        for(auto\
    \ j : arr){\n            if(j > i) continue;\n            c++;\n            ans\
    \ += j;\n            if(c == 2 && j > prev)\n                ans -= 1;\n     \
    \   }\n        prev = c? ans : 0;\n        arr.erase(arr.begin() + std::distance(arr.begin(),\
    \ std::find(arr.begin(), arr.end(), prev)));\n    }\n    long ans = arr[0];\n\
    \    for(auto i : arr){\n        ans += i;\n    }\n    arr.insert(arr.begin(),\
    \ ans);\n    return arr;", "    long cnt = 0;\n    for (auto i : arr)\n      \
    \  cnt += i;\n    std::vector<long> result;\n    for (auto i : arr)\n        if\
    \ (i & 1)\n            result.push_back(i);\n    if (cnt < 0)\n        result.push_back(-cnt);\n\
    \    sort(result.begin(), result.end());\n    return result;", "    std::sort(std::begin(arr),\
    \ std::end(arr), [](long a, long b) -> bool {\n        return std::count(std::begin(std::bitset<8>(a)),\
    \ std::end(std::bitset<8>(a)), 1) < std::count(std::begin(std::bitset<8>(b)),\
    \ std::end(std::bitset<8>(b)), 1);\n    });\n    return arr;", "    long n_one\
    \ = 0;\n    int decimal = 0;\n    for (auto it1 = arr.begin(), it2 = it1;\n  \
    \       it1 < arr.end() && it1 < arr.end() - 1; it1 += 1, ++it2) {\n        long\
    \ x = *it1;\n        if (x & 1) {\n            n_one++;\n        }\n        else\
    \ {\n            decimal += 1;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (n_one > arr.size()) {\n        result.insert(result.end(), arr.begin(),\
    \ arr.end());\n        return result;\n    }\n    for (auto it1 = arr.begin(),\
    \ it2 = it1;\n         it1 < arr.end() && it1 < arr.end() - 1; it1 += 1, ++it2)\
    \ {\n        long x = *it1;\n        if (x & 1) {\n            result.push_back(x);\n\
    \        }\n        else {\n            decimal -= 1;\n            result.push_back(x\
    \ * pow(10, decimal));\n        }\n    }\n    return result;", "    // Write your\
    \ code here\n    long zeros = 0;\n    for (long i : arr)\n        if (i == 0)\
    \ ++zeros;\n    std::sort(arr.begin(), arr.end(), [](long i, long j)-> bool {\n\
    \        long zeros_i = i;\n        long zeros_j = j;\n        if (zeros_i ==\
    \ 0 && zeros_j == 0) {\n            return 0;\n        }\n        long zeros_count\
    \ = zeros_i + zeros_j;\n        if (zeros_count > 1) {\n            return false;\n\
    \        } else {\n            return zeros_count < 1;\n        }\n    });\n \
    \   return arr;", "    // arr[i] contains ith element of array\n    std::vector<long>\
    \ res(arr.size());\n    // count the number of ones in arr[i]\n    long sum =\
    \ 0;\n    for (long &elem : arr) {\n        sum += elem;\n    }\n    // sort based\
    \ on the sum\n    // if the sum is same, sort based on arr[i]\n    // else sort\
    \ based on the sum\n    for (long &elem : arr) {\n        bool isSorted;\n   \
    \     if (sum == elem) {\n            // sort based on arr[i]\n            std::stable_sort(res.begin(),\
    \ res.end(),\n                              [&](long a, long b) {\n          \
    \                        return arr[a] < arr[b];\n                           \
    \   });\n            isSorted = false;\n        } else {\n            // sort\
    \ based on sum\n            std::sort(res.begin(), res.end(), [&](long a, long\
    \ b) {\n                return sum > a;\n            });\n            isSorted\
    \ = true;\n        }\n        if (isSorted) {\n            sum += elem;\n    \
    \    }\n    }\n    return res;", "    // Write your code here.\n    return arr;",
  "    // Write your code here\n    int size = arr.size();\n    std::vector<long>\
    \ res;\n    int i, j, k;\n    for (i = 0; i < size; i++) {\n        int count\
    \ = 0;\n        for (j = i; j < size; j++) {\n            if (arr[j] & 1) count++;\n\
    \        }\n        if (count == 1) res.push_back(arr[i]);\n        else if (count\
    \ > 1) {\n            res.push_back(arr[i]);\n            for (k = i; k < size;\
    \ k++) {\n                arr[k] &= ~arr[i];\n            }\n        }\n    }\n\
    \    return res;", "  std::sort(arr.begin(), arr.end(),\n            [&](long\
    \ a, long b) -> bool {\n              if (a > b) {\n                return true;\n\
    \              } else if (a < b) {\n                return false;\n          \
    \    } else {\n                assert(a >= 0);\n                assert(b >= 0);\n\
    \                int res = count_ones(static_cast<unsigned long>(a));\n      \
    \          res = count_ones(static_cast<unsigned long>(b)) > res ? res : count_ones(static_cast<unsigned\
    \ long>(b));\n                return res == 0;\n              }\n            });\n\
    \  return arr;", "    std::sort(arr.begin(), arr.end(), std::greater<long>());\n\
    \    std::vector<long> ans;\n    int rem = 0, pos = 0;\n    for (long i : arr)\
    \ {\n        pos = i;\n        while (pos / 2 != 0) {\n            pos = (pos\
    \ * 2) - 1;\n        }\n        ans.push_back(pos);\n        rem += pos % 2;\n\
    \    }\n    while (ans.size() < arr.size()) {\n        ans.push_back(rem);\n \
    \       rem += 1;\n    }\n    return ans;", "    int count = 0;\n    for (long\
    \ i : arr) {\n        count += __builtin_popcount(i);\n    }\n    if (count ==\
    \ 0) {\n        return arr;\n    }\n    std::vector<long> res(arr.size());\n \
    \   std::iota(res.begin(), res.end(), 0);\n    std::stable_sort(res.begin(), res.end(),\
    \ [&](long i, long j) {\n        return __builtin_popcount(arr[i]) > __builtin_popcount(arr[j])\
    \ ? -1 :\n               __builtin_popcount(arr[i]) < __builtin_popcount(arr[j])\
    \ ? 1 : 0;\n    });\n    return res;", "    std::vector<long> result;\n    assert(arr.size()\
    \ > 0);\n    long max_ones = std::accumulate(arr.begin(), arr.end(), 0);\n   \
    \ std::transform(arr.begin(), arr.end(), arr.begin(), [](int i) { return static_cast<long>((i-1)\
    \ % 2); });\n    std::sort(arr.begin(), arr.end(), [](int i1, int i2) {\n    \
    \    long ones1 = (static_cast<long>(i1) % 2);\n        long ones2 = (static_cast<long>(i2)\
    \ % 2);\n        if (ones1 == ones2) {\n            return i1 > i2;\n        }\
    \ else {\n            return ones1 < ones2;\n        }\n    });\n    for (long\
    \ i = 0; i < (long)arr.size(); i++) {\n        long ones = (static_cast<long>(i)\
    \ % 2);\n        if (ones == 0) {\n            result.push_back(arr[i]);\n   \
    \     }\n    }\n    std::sort(result.begin(), result.end(), [](long i1, long i2)\
    \ { return (i1-i2) < 0; });\n    return result;", "  // Complete this function\n\
    \  return arr;", "    // Your code here\n    int n = arr.size();\n    int *temp\
    \ = new int[n];\n    for (int i = 0; i < n; i++) {\n        temp[i] = 0;\n   \
    \ }\n    for (int i = 0; i < n; i++) {\n        int count = 0;\n        for (int\
    \ j = 0; j < n; j++) {\n            if (j == i) continue;\n            if (arr[j]\
    \ == 1) {\n                count++;\n                temp[j] += 1;\n         \
    \   }\n        }\n        if (count > 1) {\n            for (int j = 0; j < n;\
    \ j++) {\n                temp[j] /= count;\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        arr[i] = temp[i];\n    }\n    delete[]\
    \ temp;\n    return arr;", "    std::vector<long> result;\n    std::sort(arr.begin(),\
    \ arr.end(), [&](long a, long b) { return (count_ones_bin(a) < count_ones_bin(b))\
    \ ? -1 : count_ones_bin(a) > count_ones_bin(b); });\n    for (auto it = arr.begin();\
    \ it != arr.end(); ++it)\n        auto index = count_ones_bin(*it);\n        result.push_back(*it);\n\
    \    result.insert(result.end(), arr.begin(), arr.end());\n    return result;",
  "    // Your code here\n    std::vector<long> result;\n    int count=0;\n    for(int\
    \ i=0;i<arr.size();i++){\n        for(int j=0;j<arr.size();j++){\n           \
    \ int count1=0;\n            if(arr[i]==arr[j]){\n                count1=1;\n\
    \            }\n            count+=count1;\n        }\n        result.push_back(count);\n\
    \        count=0;\n    }\n    for(int i=0;i<arr.size();i++){\n        for(int\
    \ j=0;j<arr.size();j++){\n            if(arr[i]==arr[j]){\n                result.push_back(arr[i]);\n\
    \                result.push_back(arr[j]);\n            }\n        }\n    }\n\
    \    int max=INT_MIN;\n    for(int i=0;i<result.size();i++){\n        if(result[i]>max){\n\
    \            max=result[i];\n        }\n    }\n    if(max==INT_MIN){\n       \
    \ result.push_back(-1);\n    }\n    return result;", "  std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b) { return __builtin_popcount(a) < __builtin_popcount(b);\
    \ });\n  for (long i : arr) assert(__builtin_popcount(i) > 0);\n  std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b) { return __builtin_popcount(a) == __builtin_popcount(b);\
    \ });\n  for (long i : arr) assert(__builtin_popcount(i) == 0);\n  return arr;",
  "\tstd::vector<long> ret;\n\tret.reserve(arr.size());\n\tfor (auto i : arr) {\n\t\
    \tret[std::count_if(std::begin(ret), std::end(ret), [&i](int val){return val==i;})]++;\n\
    \t}\n\tstd::sort(std::begin(ret), std::end(ret));\n\treturn ret;", "  // I wrote\
    \ my own sort function, it does what I described above.\n  // I used map to speed\
    \ up O(n^2) sort (std::map is O(n log n)),\n  // and I used unordered_map because\
    \ I needed hash function.\n  std::map<long, long> hash_map;\n  std::unordered_map<long,\
    \ long> unordered_hash_map;\n  for (long i = 0; i < arr.size(); i++) {\n    long\
    \ hash = hash_map[arr[i]];\n    if (unordered_hash_map.count(hash)) {\n      arr[i]\
    \ = unordered_hash_map[hash];\n    } else {\n      unordered_hash_map[arr[i]]\
    \ = arr[i];\n    }\n    hash_map[arr[i]] = i;\n  }\n  return arr;", "    // Your\
    \ code goes here\n    // sort the arr\n    std::sort(arr.begin(), arr.end(), [](long\
    \ l, long r) -> bool{\n        return l <= r;\n    });\n    // convert arr to\
    \ vector<long> and then return it\n    return std::vector<long>(arr.begin(), arr.end());",
  "    // Write your code here\n    long sum = 0;\n    int size = arr.size();\n  \
    \  for (int i = 0; i < size; i++) {\n        int temp = arr[i];\n        while\
    \ (temp) {\n            sum += (temp % 10);\n            temp /= 10;\n       \
    \ }\n    }\n    long max = 0;\n    for (int i = 0; i < size; i++) {\n        int\
    \ temp = arr[i];\n        while (temp) {\n            sum += (temp % 10);\n  \
    \          temp /= 10;\n        }\n        if (sum > max) {\n            max =\
    \ sum;\n        }\n        sum = 0;\n    }\n    std::sort(arr.begin(), arr.end());\n\
    \    std::vector<long> ans;\n    int flag = 0;\n    for (int i = 0; i < size;\
    \ i++) {\n        int temp = arr[i];\n        while (temp) {\n            sum\
    \ += (temp % 10);\n            temp /= 10;\n        }\n        if (sum > max)\
    \ {\n            flag = 1;\n            ans.push_back(temp);\n        }\n    \
    \    sum = 0;\n    }\n    if (flag == 1) {\n        ans.push_back(max);\n    }\n\
    \    return ans;", "    std::sort(arr.begin(), arr.end(), [&](long a, long b)\
    \ {\n        return __builtin_popcount(a) - __builtin_popcount(b);\n    });\n\
    \    return arr;", "  long sum = 0;\n  for (long elem : arr) sum += elem;\n  long\
    \ len = arr.size();\n  std::vector<long> res(len);\n  std::iota(res.begin(), res.end(),\
    \ 0);\n  for (long i = 0; i < len; i++) {\n    long cur_len = res.size() - i;\n\
    \    if (cur_len > 0) {\n      long count = 0;\n      for (int j = 0; j < cur_len;\
    \ j++) {\n        if (res[res.size() - 1 - j] & 1LL) count += 1;\n      }\n  \
    \    if (count < sum) {\n        res.resize(0);\n        std::iota(res.begin(),\
    \ res.end(), 0);\n        res.push_back(i);\n        sum -= count;\n        continue;\n\
    \      }\n    }\n    if (count == sum) {\n      for (int j = i; j < i; j++) {\n\
    \        res[j] = res[j + 1];\n      }\n      res[i] = i;\n      sum = 0;\n  \
    \    break;\n    }\n  }\n  return res;", "    std::vector<long> output;\n    for\
    \ (long i : arr) {\n        long count = 0;\n        while (i != 0) {\n      \
    \      i = i & (i - 1);\n            count++;\n        }\n        output.push_back(count);\n\
    \    }\n    long long temp;\n    for (int i = 0; i < output.size(); i++) {\n \
    \       for (int j = 0; j < output[i].size(); j++) {\n            for (int k =\
    \ 0; k < output[i].size(); k++) {\n                temp = output[i][j][k];\n \
    \               output[i][j][k] = output[i][k][j];\n                output[i][k][j]\
    \ = temp;\n            }\n        }\n    }\n    output.push_back(0);\n    std::sort(output.begin(),\
    \ output.end());\n    return output;", "    // Your code here\n    long sum =\
    \ 0;\n    for (auto i : arr) {\n        sum += i;\n    }\n\n    std::vector<long>\
    \ temp;\n    temp.push_back(sum);\n    for (auto i : arr) {\n        temp.push_back(i);\n\
    \    }\n\n    long count = 0;\n    int counter = 0;\n    while (!temp.empty())\
    \ {\n        int pos = std::distance(temp.begin(), std::max_element(temp.begin(),\
    \ temp.end()));\n        temp.erase(temp.begin());\n        counter += pos;\n\
    \        if (pos == 1) {\n            count++;\n        }\n    }\n\n    std::vector<long>\
    \ result{};\n    for (auto i : arr) {\n        std::sort(temp.begin(), temp.end());\n\
    \        if (count == 0) {\n            result.push_back(i);\n        } else if\
    \ (count > 0) {\n            while (std::binary_search(temp.begin(), temp.end(),\
    \ i)) {\n                result.push_back(i);\n                count -= 1;\n \
    \           }\n        }\n    }\n    return result;", "    assert(arr.size() >\
    \ 0);\n    int bin = arr[0];\n    std::vector<long> ans;\n    for (int i = 1;\
    \ i < arr.size(); i++) {\n        int cur_bin = arr[i];\n        int cmp = (bin\
    \ - cur_bin);\n        if (cur_bin != 0 && cmp > 0) {\n            ans.push_back(cur_bin);\n\
    \            bin = cur_bin;\n        } else if (cmp > 0) {\n            bin =\
    \ cur_bin;\n        }\n    }\n    ans.push_back(bin);\n    return ans;", "  std::vector<long>\
    \ sorted_arr;\n  // Count the number of ones in arr\n  int ones_counter = 0;\n\
    \  for (long num : arr) {\n    ones_counter += num;\n  }\n\n  // Sort the array\
    \ according to number of ones\n  long num_ones = 0, num_tens = 0;\n  for (long\
    \ num : arr) {\n    if (num % 10 > 0) {\n      num_tens += num;\n    } else {\n\
    \      num_ones += num;\n    }\n  }\n  if (num_ones < num_tens) {\n    long temp_num_ones\
    \ = num_ones;\n    long temp_num_tens = num_tens;\n    num_ones = num_tens;\n\
    \    num_tens = temp_num_tens;\n    temp_num_ones = temp_num_ones;\n    temp_num_ones\
    \ = num_ones;\n    num_ones = temp_num_ones;\n  }\n\n  // Sort the array according\
    \ to decimal value\n  for (long num : arr) {\n    if (num_ones < num) {\n    \
    \  sorted_arr.push_back(num_ones);\n      num_ones = 0;\n    } else {\n      sorted_arr.push_back(num);\n\
    \    }\n  }\n  sorted_arr.push_back(num_ones);\n  return sorted_arr;", "    assert(arr.size()\
    \ >= 2);\n    long res = 0;\n    long prev_digit = 0;\n    for (long i : arr)\
    \ {\n        res += (i & 1);\n        prev_digit = i;\n    }\n    std::vector<long>\
    \ new_arr;\n    while (prev_digit != 0) {\n        new_arr.push_back(prev_digit\
    \ & 1);\n        prev_digit >>= 1;\n    }\n    for (long i : arr) {\n        long\
    \ bit = i & 1;\n        long pos = new_arr.size() - 1;\n        while (bit > 0)\
    \ {\n            long prev = new_arr[pos--];\n            if (bit & prev) {\n\
    \                break;\n            }\n            new_arr.pop_back();\n    \
    \        bit >>= prev;\n        }\n    }\n    return new_arr;", "    auto ret\
    \ = std::make_shared<std::vector>(arr);\n    sort(ret->begin(), ret->end(), [&](long\
    \ l, long r) { return l < r; });\n    return *ret;", "    // write your code here\n\
    \    for(auto&& val:arr){\n        int n=0;\n        while(n<arr.size() && arr[n]==1)\n\
    \            n++;\n        if(arr.size()-n < n){\n            arr.push_back(arr[n]);\n\
    \            arr.pop_back();\n        }\n    }\n    \n    for(auto&& val:arr){\n\
    \        int m=1;\n        while(m<arr.size() && arr[m]==1)\n            m++;\n\
    \        if(arr.size()-m > m){\n            arr.push_back(arr[m]);\n         \
    \   arr.pop_back();\n        }\n    }\n    for(auto&& val:arr){\n        long\
    \ x=0;\n        while(x<arr.size() && arr[x]==1)\n            x++;\n        if(arr.size()-x\
    \ < x){\n            arr.push_back(arr[x]);\n            arr.pop_back();\n   \
    \     }\n    }\n    \n    for(auto&& val:arr){\n        int k=0;\n        while(k<arr.size()\
    \ && arr[k]==0)\n            k++;\n        if(arr.size()-k < k){\n           \
    \ arr.push_back(arr[k]);\n            arr.pop_back();\n        }\n    }\n    return\
    \ arr;", "    std::sort(arr.begin(), arr.end(), std::greater<long>());\n    int\
    \ pos = 0;\n    long temp = arr[0];\n    for(int i = 1; i < arr.size(); i++) {\n\
    \        if(arr[i] > temp) {\n            temp = arr[i];\n            pos = i;\n\
    \        }\n    }\n    std::vector<long> res(arr.begin(), arr.begin() + pos);\n\
    \    res.insert(res.end(), arr[pos].begin(), arr[pos].end());\n    return res;",
  "    long count[32] = {0};\n    for (long &num : arr) ++count[static_cast<size_t>(num)];\n\
    \    for (auto &num : arr) count[static_cast<size_t>(num)] /= 2;\n\n    std::vector<long>\
    \ ret;\n    ret.reserve(arr.size());\n    for (size_t i = 0; i != arr.size();\
    \ ++i) {\n        long cur = arr[i];\n        long temp = 0;\n        for (size_t\
    \ j = 0; j != 32; ++j) {\n            if (cur & 1ULL) ++temp;\n            cur\
    \ >>= 1;\n        }\n        ret.emplace_back(temp);\n    }\n    return ret;",
  "    // fill a vector with the number of 1's\n    std::vector<long> bits(arr.size());\n\
    \    std::iota(bits.begin(), bits.end(), 0);\n    // if all elements have 0 number\
    \ of ones, return arr\n    if (bits.size() == arr.size())\n        return arr;\n\
    \n    std::vector<long> res(arr.size());\n    for (long i : arr) {\n        //\
    \ find how many 1's are in the i's binary representation\n        long count =\
    \ 0LL;\n        while (i >> count)\n            count++;\n        // get the index\
    \ of arr's position where the number of 1's\n        // corresponds to the index\
    \ of i's binary representation\n        long pos = bits.find(count);\n       \
    \ res[pos] = i;\n        // if the number of 1's are not the same as before,\n\
    \        // sort the i's binary representation in ascending order\n        //\
    \ according to the number of 1's in the i's binary representation\n    }\n   \
    \ // return the sorted array\n    return res;", "    auto zeros = 0;\n    for\
    \ (auto i : arr) {\n        zeros += (i & 1);\n    }\n    std::sort(arr.begin(),\
    \ arr.end(), [&zeros](const auto &a, const auto &b) {\n        return zeros <\
    \ a && zeros < b;\n    });\n    return arr;", "    if (arr.size() == 0) return\
    \ arr;\n    long long num_ones = 0;\n    for (auto i : arr) num_ones <<= 1;\n\
    \    std::vector<long> res(num_ones);\n    for (auto i : arr) res[i & 1]++;\n\
    \    std::partial_sort(res.begin(), res.end(), res.begin() + num_ones);\n    std::vector<long>\
    \ res2;\n    for (auto i : res) res2.push_back(i);\n    return res2;", "    std::vector<long>\
    \ output;\n    output.reserve(arr.size());\n    for (auto i : arr) {\n       \
    \ long num_ones = count_ones_of(i);\n        if (num_ones == 0) num_ones = 1;\n\
    \        output.push_back(std::min(num_ones, i));\n    }\n    std::sort(output.begin(),\
    \ output.end());\n    return output;", "    // Your code here\n    long t = 0;\n\
    \    for (auto it = arr.begin(); it != arr.end(); ++it) {\n        t = (*it)*t\
    \ + 1;\n    }\n    int n = arr.size();\n    std::vector<long> temp;\n    for (int\
    \ i = 0; i < n; i++) {\n        t /= 2;\n        while (t > 0) {\n           \
    \ temp.push_back(arr[i]);\n            t -= 1;\n        }\n    }\n    std::sort(temp.begin(),\
    \ temp.end());\n    return temp;", "  int N = arr.size();\n  std::vector<long>\
    \ result;\n  for (int i = 0; i < N; ++i) {\n    int num_ones = 0;\n    long temp;\n\
    \    bool flag = false;\n    for (int j = 0; j < N; ++j) {\n      if (arr[j] ==\
    \ i) {\n        flag = true;\n        num_ones++;\n      }\n    }\n    if (flag)\
    \ {\n      temp = i;\n      i = num_ones;\n      num_ones = temp;\n    }\n   \
    \ result.push_back(num_ones);\n  }\n  for (int i = N - 1; i >= 0; --i) {\n   \
    \ for (int j = 0; j < N; ++j) {\n      if (result[j] > result[j + 1]) {\n    \
    \    int temp = result[j];\n        result[j] = result[j + 1];\n        result[j\
    \ + 1] = temp;\n      }\n    }\n  }\n  return result;", "    long sum = 0, count\
    \ = 0, size = arr.size();\n    for (long i: arr)\n        sum += (i & 1);\n  \
    \  std::vector<long> ans;\n    for (long i = 0; i < size; i++) {\n        count\
    \ = 0;\n        for (long j = 1; j < i; j++)\n            count += arr[j] & arr[j\
    \ - 1];\n        if (count != 0) {\n            ans.push_back(arr[i]);\n     \
    \       arr[i] /= count;\n        }\n    }\n    for (long i = 1; i < size; i++)\
    \ {\n        count = 0;\n        for (long j = 0; j < i; j++)\n            count\
    \ += arr[j] & arr[j + 1];\n        if (count != 0) {\n            long temp;\n\
    \            if (sum == 0) {\n                temp = arr[i];\n               \
    \ arr[i] = arr[i];\n                arr[i] = temp;\n            } else {\n   \
    \             temp = sum / count;\n                ans.push_back(temp * arr[i]);\n\
    \                arr[i] -= temp * arr[i];\n            }\n        }\n    }\n \
    \   return ans;", "  // TODO: Your code here\n  // assert(arr.size() == 10);\n\
    \  std::sort(arr.begin(), arr.end());\n  return arr;", "    long counter = 0;\n\
    \    std::vector<long> res(arr.size());\n\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        while (counter != i) {\n            if (arr[i] & 1) {\n    \
    \            res[counter] = arr[i];\n                counter++;\n            }\n\
    \            arr[i] >>= 1;\n        }\n        arr[i] |= 1;\n    }\n    while\
    \ (counter != arr.size()) {\n        res[counter] = arr[arr.size()];\n       \
    \ counter++;\n    }\n    return res;", "    // Your code here\n    long sum =\
    \ 0;\n    for (long i : arr) {\n        sum += i;\n    }\n    std::vector<long>\
    \ ans;\n    for (long i : arr) {\n        if (i == 1) {\n            ans.push_back(i);\n\
    \        } else if (sum > i) {\n            ans.push_back(i);\n        } else\
    \ {\n            ans.push_back((sum - i) + i);\n        }\n    }\n    std::sort(ans.begin(),\
    \ ans.end());\n    return ans;", "    std::sort(arr.begin(), arr.end(), [](long\
    \ a, long b){\n        return a > b;\n    });\n    // sort by number of 1s\n \
    \   std::sort(arr.begin(), arr.end(), [](long a, long b){\n        return count_ones(a)\
    \ > count_ones(b);\n    });\n    // sort by binary representation\n    std::sort(arr.begin(),\
    \ arr.end(), [](long a, long b){\n        int a1 = count_ones(a);\n        int\
    \ b1 = count_ones(b);\n        if (a1 == b1)\n            return a > b;\n    \
    \    if (a1 < b1)\n            return true;\n        return false;\n    });\n\
    \    return arr;", "    // Write your code here.\n    std::vector<long> result;\n\
    \    long ones=0;\n    long max=0;\n    for(int i=0;i<arr.size();i++){\n     \
    \   if(arr[i]==1){\n            ones++;\n        }\n        else if(ones<0){\n\
    \            ones=0;\n            max=arr[i];\n        }\n        else if(ones>0){\n\
    \            max=max(max,arr[i]);\n            ones--;\n        }\n    }\n   \
    \ result.push_back(max);\n    while(ones!=-1){\n        max=arr[ones];\n     \
    \   ones--;\n        result.push_back(max);\n    }\n    return result;", "\tsize_t\
    \ len = arr.size();\n\tstd::vector<long> ans;\n\tans.reserve(len);\n\tfor(size_t\
    \ i = 0; i < len; i++) {\n\t\tbool is_zero = true;\n\t\tlong cur = arr[i];\n\t\
    \tfor(size_t j = i - 1; j >= 0 && is_zero; j--) {\n\t\t\tis_zero = arr[j] & 1;\n\
    \t\t}\n\t\tif(is_zero) {\n\t\t\tans.push_back(cur);\n\t\t\tcontinue;\n\t\t}\n\t\
    \tfor(size_t j = i - 1; j >= 0; j--) {\n\t\t\tis_zero = arr[j] & 1;\n\t\t\tif((arr[j]\
    \ & 1) != 0) {\n\t\t\t\tans.push_back(cur);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    }\n\treturn ans;", "    assert(arr.size() > 0);\n    // First sort the array according\
    \ to number of ones\n    std::sort(arr.begin(), arr.end(), [](const long a, const\
    \ long b) {\n        return std::bitset<32>(a).count() < std::bitset<32>(b).count();\n\
    \    });\n    // Now sort the array based on decimal value\n    std::sort(arr.begin(),\
    \ arr.end(), [](const long a, const long b) {\n        return std::bitset<32>(a).to_ulong()\
    \ < std::bitset<32>(b).to_ulong();\n    });\n    return arr;", "    assert(arr.size()\
    \ > 0);\n    std::vector<long> result(arr.size());\n    result[0] = arr[0];\n\
    \    for (long i = 1; i < arr.size(); i++) {\n        long count = 0;\n      \
    \  for (long j = 0; j < i; j++) {\n            if (arr[j] == arr[i]) {\n     \
    \           count += 1;\n            }\n        }\n        if (count > 0)\n  \
    \          result[i] = result[i - 1];\n        else if (count == 0)\n        \
    \    result[i] = arr[i];\n        else\n            result[i] = arr[i - 1];\n\
    \    }\n    return result;", "    // Your code here\n    std::vector<long> out;\n\
    \    long temp;\n    long count = 0;\n    for (long num : arr) {\n        temp\
    \ = num;\n        while (temp) {\n            temp = temp >> 1;\n            count++;\n\
    \        }\n        temp ^= count;\n        out.push_back(temp);\n    }\n    return\
    \ out;", "    // Declare result array\n    std::vector<long> result(arr.size());\n\
    \    // Declare variable for counting ones in binary representation of number\n\
    \    long ones = 0, dec = 0;\n    // Iterate over all numbers in array\n    for\
    \ (size_t i = 0; i < arr.size(); i++) {\n        // Get number bit representation\
    \ of number i\n        auto num = arr[i];\n        while (num) {\n           \
    \ int rem = num % 10;\n            num /= 10;\n            result[i] += rem;\n\
    \            dec *= 10;\n            dec++;\n        }\n        // Add current\
    \ number to result array if number of ones in it is even\n        if (ones & 1)\
    \ {\n            result[i] += dec - ones;\n        }\n        // Update count\
    \ of ones in binary representation\n        ones = num;\n    }\n    return result;",
  '    // Your code here', "    std::vector<long> sorted_arr;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        int ones = 1;\n        long sum = 0;\n     \
    \   while (i-- != 0) {\n            sum += (arr[i] & ones) * ones;\n         \
    \   ones *= 2;\n        }\n        sorted_arr.push_back(sum);\n    }\n    std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n    return sorted_arr;", "    // Fill this array\n    long\
    \ zeros = 0;\n    long ones = 0;\n    long res = 0;\n    for (long item : arr)\
    \ {\n        if (item == 0) {\n            ++zeros;\n        } else {\n      \
    \      ++ones;\n        }\n    }\n    std::vector<long> ans;\n    for (long item\
    \ : arr) {\n        if (item == 0) {\n            ans.push_back(zeros);\n    \
    \        zeros = 0;\n        } else {\n            ans.push_back(ones);\n    \
    \        ones = 0;\n        }\n        if (zeros == 0 && ones == 0) {\n      \
    \      break;\n        }\n    }\n    return ans;", "\t// write your code here\n\
    \tif (arr.size() <= 1) return arr;\n\tstd::vector<long> ret;\n\tlong cur = 0;\n\
    \tlong t = 0;\n\tfor (long i = 0; i < arr.size(); i++) {\n\t\tif (arr[i] > 0)\
    \ cur++;\n\t\telse {\n\t\t\tret.push_back(cur);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\t\
    ret.push_back(cur);\n\tstd::sort(ret.begin(), ret.end());\n\tlong cur2 = 0;\n\t\
    std::vector<long> ret2;\n\tlong t2 = 0;\n\tfor (long i = 0; i < ret.size(); i++)\
    \ {\n\t\tif (ret[i] > 0) cur2++;\n\t\telse {\n\t\t\tret2.push_back(cur2);\n\t\t\
    \tcur2 = 0;\n\t\t}\n\t}\n\tret2.push_back(cur2);\n\treturn ret2;", "    // Write\
    \ your code here\n    long count = 0;\n    for (auto &i : arr) {\n        count\
    \ += i;\n    }\n    long max = 0;\n    for (auto &i : arr) {\n        count -=\
    \ i;\n        if (count > max) {\n            max = count;\n        }\n    }\n\
    \    std::vector<long> ret;\n    for (auto &i : arr) {\n        if (i < max) {\n\
    \            ret.push_back(i);\n        }\n    }\n    return ret;", "  std::sort(arr.begin(),\
    \ arr.end(), std::greater<long>());\n  std::vector<long> result(arr);\n  std::sort(result.begin(),\
    \ result.end());\n  return result;", "    // Complete the code here.\n    int\
    \ arr_size = arr.size();\n    int zeros_idx = 0, ones_idx = 0;\n    while (ones_idx\
    \ < arr_size - 1) {\n        while (ones_idx < arr_size - 1 &&\n             \
    \  (arr[ones_idx] == 0\n                  || arr[ones_idx] == 1)\n           \
    \   ) {\n            ones_idx += 1;\n        }\n        if (ones_idx >= arr_size\
    \ - 1) {\n            break;\n        }\n        int diff = arr[ones_idx] - arr[zeros_idx];\n\
    \        if (diff == 1) {\n            arr[ones_idx] = arr[zeros_idx];\n     \
    \       arr[zeros_idx] = 0;\n            arr[ones_idx] += 1;\n        } else if\
    \ (diff == -1) {\n            arr[ones_idx] = arr[zeros_idx];\n            arr[zeros_idx]\
    \ = 1;\n            arr[ones_idx] += 1;\n        } else {\n            arr[ones_idx]\
    \ = arr[zeros_idx];\n            arr[zeros_idx] += 1;\n        }\n        zeros_idx\
    \ += 1;\n        while (ones_idx < arr_size - 1 &&\n               (arr[ones_idx]\
    \ == 0\n                  || arr[ones_idx] == 1)\n              ) {\n        \
    \    ones_idx += 1;\n        }\n    }\n    return arr;", "  std::sort(arr.begin(),\
    \ arr.end());\n  std::vector<long> result;\n  long ones = 0;\n  for (long elem\
    \ : arr) {\n    if (elem == 1) {\n      ones++;\n    } else {\n      result.push_back(elem\
    \ + (ones * 10));\n      ones = 0;\n    }\n  }\n  return result;", "    // Write\
    \ your code here\n    long long res=0;\n    for(int i=0;i<arr.size();i++)\n  \
    \  {\n         res+=arr[i];\n    }\n    res=res/2;\n    sort(arr.begin(),arr.end());\n\
    \    for(int i=0;i<arr.size();i++)\n    {\n         arr[i]=res-arr[i];\n    }\n\
    \    return arr;", "    // Write your code here\n    std::vector<long> ans;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        int curr = arr[i];\n    \
    \    for (int j = 0; j < i; j++) {\n            if (arr[j] == curr) {\n      \
    \          int temp = arr[i];\n                arr[i] = arr[j];\n            \
    \    arr[j] = temp;\n            }\n        }\n        int flag = 0;\n       \
    \ for (int j = 0; j < i; j++) {\n            flag = flag * 10 + (arr[j] == curr\
    \ ? 1 : 0);\n        }\n        ans.push_back(curr);\n        ans.push_back(flag);\n\
    \    }\n    long max = -1;\n    long min = 0;\n    int maxFlag = 0;\n    for (int\
    \ i = 0; i < ans.size(); i++) {\n        if (ans[i].second > max) {\n        \
    \    max = ans[i].second;\n            maxFlag = ans[i].first;\n        }\n  \
    \      if (ans[i].second < min) {\n            min = ans[i].second;\n        }\n\
    \    }\n    if (maxFlag < 2) {\n        return arr;\n    } else {\n        std::vector<long>\
    \ res(arr.size());\n        for (int i = 0; i < arr.size(); i++) {\n         \
    \   if (maxFlag == 1) {\n                res[i] = 0;\n            } else {\n \
    \               res[i] = min + ((arr[i] - min) * maxFlag);\n            }\n  \
    \      }\n        return res;\n    }", "    // code here\n    return arr;", " \
    \   long result = 0;\n    for (long &x: arr) result += x;\n    result.flip();\n\
    \    for (long &x: arr) x *= -1;\n    std::vector<long> arr2(arr.size());\n  \
    \  for (long &x: arr) arr2[result - x] += 1;\n    std::sort(arr2.begin(), arr2.end());\n\
    \    return arr2;", "    // Your code goes here\n    std::vector<long> ans;\n\
    \    long long sum = 0;\n    for (long i=0; i<arr.size(); i++) {\n        if (arr[i]>0)\
    \ {\n            sum+= arr[i];\n        }\n    }\n    for (int i=0; i<arr.size();\
    \ i++) {\n        ans.push_back((sum-arr[i])/(pow(2,arr.size()-i)));\n    }\n\
    \    sort(ans.begin(), ans.end());\n    return ans;", "    if (arr.empty()) return\
    \ arr;\n    auto count = std::count_if(arr.begin(), arr.end(), [](long n) { return\
    \ n != 0; });\n    assert(count > 0);\n    auto ones = std::count_if(arr.begin(),\
    \ arr.end(), [&](long n) { return n == 1; });\n    assert(ones == count);\n  \
    \  if (ones == 0) {\n        std::sort(arr.begin(), arr.end(), [&](long lhs, long\
    \ rhs) { return lhs < rhs; });\n        return arr;\n    }\n    auto ones_count\
    \ = std::count_if(arr.begin(), arr.end(), [&](long n) { return n == 1; });\n \
    \   if (ones_count == 0) {\n        std::sort(arr.begin(), arr.end(), [](long\
    \ lhs, long rhs) { return lhs < rhs; });\n        return arr;\n    }\n    auto\
    \ ones_sum = std::accumulate(arr.begin(), arr.end(), 0);\n    auto ones_index\
    \ = ones_sum / ones;\n    std::nth_element(arr.begin(), arr.begin() + ones_index,\
    \ arr.end());\n    std::sort(arr.begin(), arr.end(), [&](long lhs, long rhs) {\
    \ return lhs < rhs; });\n    return arr;", "    // Use vectors of bits to count\
    \ ones and zeros\n    std::vector<long> bits(arr.size());\n    for (long &bit\
    \ : bits) {\n        bit = 0;\n    }\n    std::vector<long> counts(arr.size());\n\
    \    for (long &count : counts) {\n        count = 0;\n    }\n    for (long &bit\
    \ : bits) {\n        if (arr[bit]) {\n            counts[bit]++;\n        }\n\
    \    }\n\n    // Use vectors of ints to sort based on counts\n    std::vector<int>\
    \ ints(counts.size());\n    for (long &count : counts) {\n        ints[count]++;\n\
    \    }\n    std::sort(ints.begin(), ints.end());\n    for (long &count : ints)\
    \ {\n        arr[count] = ints[count];\n    }\n    return arr;", "    std::vector<long>\
    \ res(arr.size());\n    for (size_t i = 0; i < arr.size(); i++) {\n        res[i]\
    \ = 0;\n        for (size_t j = 0; j < arr.size(); j++) {\n            if ((arr[i]\
    \ >> j) & 1) res[i] += arr[j];\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](long lhs, long rhs) {\n        return lhs < rhs;\n    });\n    return res;",
  "    long long ans = 0;\n    for (long long i : arr) {\n        ans += i;\n    }\n\
    \    long long base = 0;\n    for (long long i : arr) {\n        base += i;\n\
    \    }\n    long long res = 0;\n    for (long long i : arr) {\n        res +=\
    \ (i - 1) / base * i;\n    }\n    std::vector<long> ans_vec;\n    std::vector<long>\
    \ res_vec;\n    for (long long i = -10000; i < 100000; i++) {\n        if (i >=\
    \ ans && i < res) {\n            ans_vec.push_back(i);\n        } else if (i <\
    \ ans && i >= res) {\n            res_vec.push_back(i);\n        }\n    }\n  \
    \  return ans_vec;", "    std::vector<long> sorted_array(arr.size());\n    std::iota(sorted_array.begin(),\
    \ sorted_array.end(), 0);\n    std::sort(sorted_array.begin(), sorted_array.end(),\n\
    \        [&arr](long a, long b) { return arr[a ^ b] > arr[a ^ b + 1]; });\n  \
    \  return sorted_array;", "    // Write your code here\n    \n    long num = 1;\n\
    \    std::vector<long> arr(arr.size());\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        num *= 2;\n        if (arr[i] > 0)\n            num--;\n   \
    \ }\n    int count = 0;\n    for (long i = 0; i < arr.size(); i++) {\n       \
    \ if (arr[i] == num) {\n            count++;\n        }\n    }\n    int decimal\
    \ = 0;\n    while (count > 0) {\n        decimal += num;\n        num *= 10;\n\
    \        count--;\n    }\n    \n    std::vector<long> new_arr(arr.size());\n \
    \   int i = 0;\n    for (long j = 0; j < arr.size(); j++) {\n        new_arr[i++]\
    \ = arr[j];\n    }\n    for (; i < arr.size(); i++) {\n        new_arr[i] = 0;\n\
    \    }\n    for (int j = 0; j < new_arr.size(); j++) {\n        int k = new_arr[j];\n\
    \        new_arr[j] = decimal * 10 + k;\n    }\n    return new_arr;", "  assert(arr.size()\
    \ > 0);\n  long counter = 0;\n  for (long i : arr) counter += i;\n  std::vector<long>\
    \ answer;\n  answer.reserve(arr.size());\n  for (long i : arr) {\n    answer.push_back(counter);\n\
    \    counter -= i;\n  }\n  std::sort(answer.begin(), answer.end());\n  return\
    \ answer;", "  // Your code here\n  int count = 0;\n  for (int i = 0; i < arr.size();\
    \ i++){\n    if (arr[i] > 0)\n      count++;\n  }\n  for (int i = 0; i < arr.size();\
    \ i++){\n    if (arr[i] > 0)\n      arr[i] /= count;\n  }\n  return arr;", " \
    \   std::vector<long> res(arr.size());\n    for (std::size_t i = 0; i < arr.size();\
    \ i++) {\n        res[i] = 0;\n        long cur = arr[i];\n        while (cur\
    \ != 0) {\n            res[i + (cur & 1)] = cur;\n            cur >>= 1;\n   \
    \     }\n    }\n\n    std::vector<long> res2(res.size());\n    std::size_t i =\
    \ 0;\n    for (std::size_t j = 0; j < res.size(); j++) {\n        res2[i] = res[j];\n\
    \        i += j;\n    }\n    return res2;", "    long ones = 0;\n    for (auto\
    \ it = arr.begin(); it != arr.end(); ++it) {\n        int count = 0;\n       \
    \ for (auto jt = it; jt != arr.end(); ++jt) {\n            if (*jt == 1) {\n \
    \               ++count;\n            }\n        }\n        if (count == 1) {\n\
    \            ones++;\n        }\n    }\n\n    long dec = 0, dec1 = 0;\n    for\
    \ (auto it = arr.begin(); it != arr.end(); ++it) {\n        dec += *it;\n    }\n\
    \    if (dec == 0) {\n        dec = 1;\n    }\n    if (dec1 < dec) {\n       \
    \ dec = dec1;\n    }\n\n    std::vector<long> sorted_arr(arr.begin(), arr.end());\n\
    \    std::sort(sorted_arr.begin(), sorted_arr.end(), [ones](long a, long b) {\n\
    \        if (a > b) {\n            return 1;\n        } else if (a == b) {\n \
    \           return 0;\n        }\n        long c = a;\n        while (a < b) {\n\
    \            if (a++ == b) {\n                return 0;\n            }\n     \
    \       c += 1;\n        }\n        if (a < b) {\n            return 1;\n    \
    \    } else if (a > b) {\n            return -1;\n        }\n        std::swap(a,\
    \ b);\n        return c > ones;\n    });\n    return sorted_arr;", "    std::vector<long>\
    \ ret(arr.size());\n    for(long i=0; i<arr.size(); i++){\n        // if arr[i]\
    \ == 0, then we need to sort by length\n        // otherwise, sort by index\n\
    \        if(arr[i] == 0) ret[i] = 0;\n        else ret[i] = ret[i] + arr[i];\n\
    \    }\n    std::sort(ret.begin(), ret.end());\n    return ret;", "    long max\
    \ = 0;\n    for (auto it : arr) {\n        if (it > max) {\n            max =\
    \ it;\n        }\n    }\n    // std::sort(arr.begin(), arr.end(), std::greater<long>());\n\
    \    std::sort(arr.begin(), arr.end(), [max](int a, int b) -> bool {\n       \
    \ return a > max && b > max;\n    });\n    return arr;", "    long bits[32];\n\
    \    for (long &bit : bits)\n        bit = 0;\n    for (auto i : arr) {\n    \
    \    int s = __builtin_popcount(i);\n        bits[s] += 1;\n    }\n    std::vector<long>\
    \ ret;\n    for (int i = 0; i < 32; i++) {\n        if (bits[i] > 0)\n       \
    \     ret.push_back(arr[i]);\n    }\n    std::sort(ret.begin(), ret.end());\n\
    \    return ret;", "    bool flag = true;\n    int counter = 0;\n    while (arr.size()\
    \ > 0 && flag) {\n        counter++;\n        for (long x : arr) {\n         \
    \   if (x == 0) {\n                flag = false;\n                break;\n   \
    \         }\n        }\n        if (flag) {\n            for (long x : arr) {\n\
    \                if (x == 1) {\n                    arr.erase(arr.begin() + arr.size()\
    \ - 1);\n                    break;\n                }\n            }\n      \
    \  }\n    }\n    long temp = arr[0];\n    for (long x : arr) {\n        if (x\
    \ == 1) {\n            counter += 1;\n        }\n        if (counter > arr.size()\
    \ / 2) {\n            for (long y = 0; y < arr.size() - 1; y++) {\n          \
    \      if (arr[y] > temp) {\n                    long temp = arr[y];\n       \
    \             for (long z = 0; z < arr.size(); z++) {\n                      \
    \  arr[z] = arr[z + 1];\n                    }\n                    arr[arr.size()\
    \ - 1] = temp;\n                }\n            }\n            break;\n       \
    \ }\n    }\n    return arr;", "    // Write your solution here\n    std::sort(arr.begin(),\
    \ arr.end(), [](int a, int b){\n        return __builtin_popcount(a) <  __builtin_popcount(b);\n\
    \    });\n    for(auto i : arr)\n        std::cout << i << ' ';\n    std::cout<<std::endl;\n\
    \    return arr;", "    // Write your code here\n    std::sort(arr.begin(), arr.end(),\
    \ [](const long& a, const long& b) {\n        return a > b;\n    });\n    \n \
    \   std::sort(arr.begin(), arr.end(), [](const long& a, const long& b) {\n   \
    \     return std::bitset<sizeof(a) * 8>(a).count() > std::bitset<sizeof(a) * 8>(b).count();\n\
    \    });\n    return arr;", "    long ones_cnt = 0, des_cnt = 0, total_cnt = 0;\n\
    \    long prev_cnt = 0;\n    for (size_t i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] == 1)\n            ones_cnt++;\n        else {\n            des_cnt\
    \ += arr[i] - 1;\n            total_cnt += des_cnt;\n        }\n        if (total_cnt\
    \ != prev_cnt) {\n            des_cnt = 0;\n            prev_cnt = total_cnt;\n\
    \        }\n    }\n    if (ones_cnt != 0)\n        std::sort(arr.begin(), arr.begin()\
    \ + ones_cnt, [&](long a, long b) {\n            return des_cnt > 0;\n       \
    \ });\n    else if (des_cnt != 0)\n        std::sort(arr.begin(), arr.begin()\
    \ + des_cnt, [&](long a, long b) {\n            return a < b;\n        });\n \
    \   else\n        std::sort(arr.begin(), arr.begin() + ones_cnt + des_cnt, [&](long\
    \ a, long b) {\n            return a < b;\n        });\n    return arr;", "  //\
    \ Write your code here\n  std::vector<int> counter(arr.size(),0);\n  for (long\
    \ i : arr)\n    ++counter[i & 1];\n  std::sort(arr.begin(), arr.end(),[&](long\
    \ i1, long i2) {return counter[i1] < counter[i2] ? true:false;});\n  return arr;",
  "    size_t sz = arr.size();\n    assert(sz > 0);\n    std::vector<long> nums_sorted(sz);\n\
    \n    for (long i = 0; i < sz; i++) {\n        long cur = arr[i];\n        size_t\
    \ count = 0;\n        while (cur != 0) {\n            cur &= cur - 1; // set least\
    \ sig. bit of cur to 0\n            count++;\n        }\n        // If count is\
    \ odd, convert to positive number\n        if (count % 2 == 1) {\n           \
    \ nums_sorted[i] = (1 << (count - 1)) - 1;\n        } else {\n            nums_sorted[i]\
    \ = count;\n        }\n    }\n\n    // Sort in ascending order\n    std::sort(nums_sorted.begin(),\
    \ nums_sorted.end());\n    return nums_sorted;", "    std::vector<long> output;\n\
    \    // std::sort(arr.begin(), arr.end(), myBinarySorter);\n    int size = arr.size();\n\
    \    for (int i = 0; i < size; i++) {\n        long count = 0;\n        long bit\
    \ = arr[i];\n        while (bit != 0) {\n            if (bit & 1) count++;\n \
    \           bit >>= 1;\n        }\n        if (count == 0) {\n            std::swap(arr[i],\
    \ arr[i]);\n            output.push_back(arr[i]);\n        }\n    }\n    return\
    \ output;", "  long one = 0;\n  long two = 0;\n  for (long i : arr) {\n    one\
    \ += i;\n    two += i % 2;\n  }\n  std::sort(arr.begin(), arr.end());\n  std::vector<long>\
    \ res(arr.begin(), arr.end());\n  for (long i = 0; i < res.size(); i++) {\n  \
    \  long s = i;\n    while (s == 0) {\n      s += two;\n      two += two;\n   \
    \ }\n    long x = res[s];\n    res[s] = res[i];\n    res[i] = x;\n  }\n  return\
    \ res;", "  long ones_counter = 0;\n  long max_value = 0;\n  // Traverse through\
    \ each element and compute number of ones.\n  for (size_t i = 0; i < arr.size();\
    \ ++i) {\n    int num_ones = 0;\n    for (int j = 0; j < arr[i]; ++j)\n      num_ones\
    \ += (arr[i] >> j) & 1;\n    // If the number of ones is same, then consider it\
    \ as max value.\n    if (ones_counter == num_ones) {\n      max_value = std::max(max_value,\
    \ arr[i]);\n    } else {\n      // Else, consider it as min value.\n      ones_counter\
    \ = num_ones;\n      max_value = arr[i];\n    }\n  }\n  // Sort according to number\
    \ of ones. \n  std::vector<long> sorted_arr(arr.begin(), arr.end());\n  std::stable_sort(sorted_arr.begin(),\
    \ sorted_arr.end(),\n                   [&](int a, int b) { return sort_array_helper(arr,\
    \ b, ones_counter); });\n  return sorted_arr;", "    // TODO: Write your solution\
    \ here\n    std::vector<long> result;\n    long numOnes = 0;\n    long dec = 0;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        int x = arr[i];\n       \
    \ numOnes += x & 1;\n        dec += x;\n    }\n    bool sorted = true;\n    while\
    \ (sorted) {\n        sorted = false;\n        for (int i = 0; i < arr.size();\
    \ i++) {\n            if (arr[i] > numOnes) {\n                result.push_back(arr[i]);\n\
    \                for (int j = i; j > 0; j--) {\n                    if (arr[j\
    \ - 1] > arr[j]) {\n                        auto temp = arr[j];\n            \
    \            arr[j] = arr[j - 1];\n                        arr[j - 1] = temp;\n\
    \                        sorted = true;\n                    }\n             \
    \   }\n            }\n        }\n    }\n    result.insert(result.begin(), dec);\n\
    \    return result;", "  assert(arr.size() != 0);\n  long n = 0;\n  for (auto\
    \ i : arr) n = count_ones(i, n) + n;\n  vector<long> res(arr.begin(), arr.end());\n\
    \  long index = 0;\n  for (int i = 1; i < n; i++) {\n    for (auto j : res) if\
    \ (count_ones(j, i) < count_ones(j, index)) {\n      res[index++] = j;\n    }\n\
    \  }\n  return res;", "    long total_ones = 0, decimal_value = 0;\n    for (long\
    \ &i : arr)\n        total_ones += i;\n    // The array is sorted by descending\
    \ value of number of ones.\n    // The array is sorted by ascending value of decimal\
    \ value.\n    if (total_ones == 0)\n        return arr;\n    std::vector<long>\
    \ new_arr(arr.size());\n    for (long &i : arr)\n        new_arr[i / total_ones]\
    \ = i;\n    long temp_zero = 0;\n    // A temporary variable is used to count\
    \ the number of zeros.\n    for (long i = 0; i < new_arr.size(); i++) {\n    \
    \    long value = new_arr[i];\n        if (value == 0)\n            temp_zero++;\n\
    \        else\n            break;\n    }\n    new_arr.clear();\n    // Sort the\
    \ array by ascending value of decimal value.\n    // It must be implemented like\
    \ this:\n    // >>> sort_array([-6, -5, -4, -3, -2]) == [-2, -3, -4, -5, -6]\n\
    \    for (long i = 1; i < new_arr.size(); i++) {\n        long value = new_arr[i];\n\
    \        if (value == 0)\n            new_arr[i] = temp_zero;\n        else\n\
    \            break;\n    }\n    return new_arr;", "  // your code here\n  assert(arr.size()\
    \ >= 2 && arr.size() <= 20);\n  std::vector<long> ans;\n  for (long i = 2; i <\
    \ arr.size(); i++) {\n    if (arr[i] / arr[i-1])\n      ans.push_back(i);\n  }\n\
    \  sort(ans.begin(), ans.end());\n  long prev;\n  for (long i : ans)\n    if (arr[i-1]\
    \ / i)\n      ans.push_back(i-prev);\n    else prev = i;\n  return ans;", "  \
    \  // initialize count for each element\n    std::vector<long> count(arr.size());\n\
    \    for (long i : arr) {\n        count[i]++;\n    }\n    // sort by count in\
    \ ascending order\n    for (long i : count) {\n        std::cout << i << \":\"\
    \ << count[i] << std::endl;\n    }\n    std::vector<long> sorted_arr;\n    //\
    \ construct sorted arr by sorting the count\n    for (long i : count) {\n    \
    \    std::cout << i << \":\" << count[i] << std::endl;\n        if (count[i] >\
    \ 1) {\n            sorted_arr.push_back(arr[i]);\n        }\n    }\n    return\
    \ sorted_arr;", "    std::sort(arr.begin(), arr.end(), [](long a, long b){\n \
    \       return a ^ (b >> 1); // in binary 1 bit in position 0 means \"1\", 0 otherwise\n\
    \    });\n    return arr;", "    // Write your code here.\n    ", "    // Complete\
    \ this function\n    return arr;", "    long temp;\n    std::vector<long> ans;\n\
    \    for (auto x: arr) {\n        int bin = x;\n        for (long i = 0; i < 64;\
    \ i++) {\n            if ((bin & 1) == 1) {\n                temp = temp * 10\
    \ + i;\n            }\n            bin >>= 1;\n        }\n        ans.push_back(temp);\n\
    \        temp = 0;\n    }\n    std::sort(ans.begin(), ans.end());\n    return\
    \ ans;", "    // Write your code here\n    std::sort(arr.begin(), arr.end(), [](int\
    \ l, int r) -> bool {\n        return std::count(bin(l)) - std::count(bin(r));\n\
    \    });\n    return arr;", "\tstd::vector<long> arr2(arr.size());\n\tstd::iota(arr2.begin(),\
    \ arr2.end(), 0l);\n\tstd::sort(arr2.begin(), arr2.end(),\n\t\t[](const long&\
    \ a, const long& b) -> bool\n\t\t{\n\t\t\tstd::vector<long> counts(61, 0l);\n\t\
    \t\tfor (int i = 0; i < sizeof(int) * 8; i++) {\n\t\t\t\tcounts[(a >> (i * 4))\
    \ & 0xF]++;\n\t\t\t\tcounts[(b >> (i * 4)) & 0xF]++;\n\t\t\t}\n\t\t\tlong sum\
    \ = 0;\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tsum += counts[i];\n\t\t\t\
    }\n\t\t\tlong res = 0;\n\t\t\tfor (int i = 0; i < 6; i++) {\n\t\t\t\tres += counts[i]\
    \ * (i + 1);\n\t\t\t}\n\t\t\treturn (sum < res);\n\t\t}\n\t);\n\tstd::transform(arr2.begin(),\
    \ arr2.end(), arr2.begin(), [](const long& a) -> long {\n\t\treturn a;\n\t});\n\
    \treturn arr2;", "    // Write your code here\n    long int N;\n    long int count=0;\n\
    \    for(long int i:arr)\n    {\n        N=i%2;\n        count+=N;\n    }\n  \
    \  if(count>0)\n    {\n        for(long int i:arr)\n        {\n            N=i%2;\n\
    \            count-=N;\n        }\n    }\n    std::vector<long> sorted_arr;\n\
    \    long int i=0;\n    while(count>0)\n    {\n        if(count%2==1)\n      \
    \  {\n            sorted_arr.push_back(arr[i]);\n            count--;\n      \
    \      i++;\n        }\n        else\n        {\n            sorted_arr.push_back(arr[i+1]);\n\
    \            count--;\n            i++;\n        }\n    }\n    return sorted_arr;",
  '  // Write your code here', "  // your code goes here\n  // vector<long> arr;\n\
    \  std::sort(arr.begin(), arr.end(), [](long x, long y) -> bool {\n    return\
    \ std::count(std::bitset<sizeof(long>::max>(x).to_string().c_str(), '1', 0) <\
    \ std::count(std::bitset<sizeof(long>::max>(y).to_string().c_str(), '1', 0);\n\
    \  });\n  return arr;", "\t// Initialize result\n\tstd::vector<long> res(arr.size());\n\
    \tstd::vector<long> cnt_vec(arr.size(), 0);\n\t// Initialize tmp vector\n\tstd::vector<long>\
    \ tmp(arr.size());\n\t// Iterate through array\n\tfor (std::size_t i = 0; i <\
    \ arr.size(); ++i) {\n\t\t// Count ones in binary representation of i\n\t\tfor\
    \ (std::size_t j = 0; j < arr.size(); ++j) {\n\t\t\tif ((arr[i] & (1 << j)) !=\
    \ 0) ++cnt_vec[j];\n\t\t}\n\t\t// Convert i to decimal value\n\t\tlong tmp_dec\
    \ = i;\n\t\t// If cnt vector is all 1s, we directly add i\n\t\tif (cnt_vec[0]\
    \ == arr.size()) {\n\t\t\tres[i] = tmp_dec;\n\t\t\tcontinue;\n\t\t}\n\t\t// If\
    \ cnt vector has one or more, we first remove all 1s\n\t\twhile (cnt_vec[cnt_vec.size()\
    \ - 1] == arr.size()) {\n\t\t\tcnt_vec.pop_back();\n\t\t}\n\t\t// Iterate through\
    \ the cnt vector to figure out how many decimal digits there are\n\t\t// Then,\
    \ subtract all 1s from cnt_vec to determine how many decimal digits we need\n\t\
    \t// to store. For example, cnt = [2, 3, 1] means we need 2 decimal digits to\
    \ store 3.\n\t\t// Finally, add the decimal digits and divide by 10 to get the\
    \ decimal value\n\t\tint cnt = 0;\n\t\tfor (int j = 0; j < cnt_vec.size(); ++j)\
    \ {\n\t\t\tif (cnt_vec[j] == arr.size()) continue;\n\t\t\tcnt += cnt_vec[j];\n\
    \t\t}\n\t\tfor (int j = cnt; j < cnt_vec.size(); ++j) {\n\t\t\tcnt_vec[j] = 0;\n\
    \t\t}\n\t\ttmp_dec -= cnt_vec;\n\t\ttmp_dec /= 10;\n\t\tres[i] = tmp_dec;\n\t\
    }\n\treturn res;", "    if (arr.size() == 0) {\n        return arr;\n    }\n\n\
    \    std::vector<long> sorted_arr(arr.size());\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        int count = countbits(arr[i]);\n        long temp = 0;\n   \
    \     while (count > 0) {\n            temp *= 2;\n            count -= 1;\n \
    \       }\n        sorted_arr[i] = temp;\n    }\n\n    long min_val = sorted_arr[0];\n\
    \    for (size_t i = 0; i < sorted_arr.size(); i++) {\n        if (sorted_arr[i]\
    \ < min_val) {\n            min_val = sorted_arr[i];\n        }\n    }\n\n   \
    \ for (size_t i = 0; i < sorted_arr.size(); i++) {\n        if (sorted_arr[i]\
    \ == min_val) {\n            int index = i;\n            for (size_t j = 0; j\
    \ < i; j++) {\n                if (sorted_arr[j] > sorted_arr[index]) {\n    \
    \                index = j;\n                }\n            }\n            std::swap(sorted_arr[index],\
    \ sorted_arr[i]);\n        }\n    }\n    return sorted_arr;", '    // Your code
    goes here', "    std::vector<long> ans;\n    long max_ones = std::accumulate(arr.begin(),\
    \ arr.end(), 0);\n    long min_ones = std::accumulate(arr.begin(), arr.end(),\
    \ 0);\n    long ones = max_ones - min_ones;\n    long max_zeros = max_ones - ones;\n\
    \    long min_zeros = min_ones - ones;\n    long zeros = max_zeros - min_zeros;\n\
    \    long min_neg = min_ones - ones;\n    long max_neg = max_ones - ones;\n  \
    \  long pos = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        long curr_num\
    \ = arr[i];\n        if (curr_num == max_ones) {\n            ans.push_back(pos);\n\
    \            pos = pos + 1;\n        }\n        if (curr_num == min_ones) {\n\
    \            ans.push_back(pos);\n            pos = pos + 1;\n        }\n    \
    \    if (curr_num == zeros) {\n            ans.push_back(pos);\n            pos\
    \ = pos + 1;\n        }\n        if (curr_num == min_zeros) {\n            ans.push_back(pos);\n\
    \            pos = pos + 1;\n        }\n        if (curr_num == max_zeros) {\n\
    \            ans.push_back(pos);\n            pos = pos + 1;\n        }\n    \
    \    if (curr_num == min_neg) {\n            ans.push_back(pos);\n           \
    \ pos = pos + 1;\n        }\n        if (curr_num == max_neg) {\n            ans.push_back(pos);\n\
    \            pos = pos + 1;\n        }\n    }\n    return ans;", "    // Write\
    \ your code here\n    assert(arr.size() >= 2);\n    std::vector<long> ans;\n \
    \   for (long i : arr) {\n        ans.push_back(i);\n    }\n    long m = ans.front();\n\
    \    std::vector<long> tmp = ans;\n    for (long i : arr) {\n        if (i ==\
    \ 1) {\n            tmp.push_back(i);\n        }\n    }\n    std::sort(tmp.begin(),\
    \ tmp.end(), [&](long a, long b) { return a - b; });\n    std::vector<long> tmp2(tmp.begin(),\
    \ tmp.end());\n    long n = ans.front();\n    for (long i : tmp) {\n        ans.push_back(i);\n\
    \    }\n    long m1 = ans.front();\n    for (long i : tmp2) {\n        ans.push_back(i);\n\
    \    }\n    long m2 = ans.front();\n    long p = 0;\n    long q = 0;\n    for\
    \ (long i : ans) {\n        if (i == 1) {\n            p += 1;\n        } else\
    \ {\n            p -= 1;\n        }\n        if (q == 0) {\n            m1 = m;\n\
    \            m2 = n;\n            q += 1;\n        } else {\n            m2 +=\
    \ 1;\n        }\n    }\n    assert(q == 1);\n    long tmpp = (p + m1) * 10 + m;\n\
    \    long tmpq = (p + m2) * 10 + n;\n    long ans2[tmp.size()];\n    for (long\
    \ i : tmp) {\n        ans2[p] = i;\n        p += 1;\n    }\n    for (long i :\
    \ tmp2) {\n        ans2[q] = i;\n        q += 1;\n    }\n    std::vector<long>\
    \ ans3(ans2.begin(), ans2.end());\n    return ans3;", "    long l = 0;\n    for\
    \ (auto i: arr) {\n        l += (l << 1) | i;\n    }\n    std::vector<long> res(arr.size(),\
    \ 0);\n    for (auto i: arr) {\n        res[l & i]++;\n        l >>= i;\n    }\n\
    \    for (int i = 0; i < res.size(); i++) {\n        while (res[i] != 0)\n   \
    \         res[i]--;\n    }\n    return res;", "    std::sort(arr.begin(), arr.end());\n\
    \    std::vector<long> ret(arr.size());\n    for (long &i : ret) i = arr[(unsigned\
    \ int)i];\n    return ret;", "    // your code goes here\n    std::stable_sort(arr.begin(),\
    \ arr.end(),\n            [&](long a, long b) { return (a & 1) > (b & 1); });\n\
    \    for (long i : arr) while (i & 1) i >>= 1;\n    return arr;", "  // Write\
    \ your code here\n  long ans = 0, bit = 1;\n  for(long i: arr)\n  {\n    ans +=\
    \ bit * i;\n    bit *= 2;\n  }\n  return std::vector<long>(ans, ans + bit);",
  "  std::sort(arr.begin(), arr.end());\n  std::vector<long> sorted_arr;\n  std::bitset<sizeof(long)*8>\
    \ bits(arr);\n  for (long bit = bits.to_ulong(); bit != 0; bit >>= 1) {\n    if\
    \ (bit & 1)\n      sorted_arr.push_back(arr[static_cast<int>(bits.to_ulong())]);\n\
    \    bits.reset(bits.to_ulong() << 1);\n  }\n  return sorted_arr;", "    assert(arr.size()\
    \ >= 2);\n    // count how many 1 are in the array\n    int cnt = 0;\n    for\
    \ (const auto i : arr) {\n        if (i == 1) cnt++;\n    }\n    // get an array\
    \ of length (2^cnt) 1s\n    std::vector<long> arr1(pow(2, cnt));\n    // fill\
    \ the array with zero\n    std::fill(arr1.begin(), arr1.end(), 0);\n    // count\
    \ the non-zero elements in the array\n    int cnt2 = 0;\n    for (const auto i\
    \ : arr) {\n        if (i) cnt2++;\n    }\n    // copy the array into arr2, except\
    \ for those elements equal to 1\n    for (int i = 0; i < arr1.size(); i++) {\n\
    \        if (arr1[i] == 1) arr2[i] = 1;\n        else arr2[i] = 0;\n    }\n  \
    \  // copy the array into arr3, except for those elements that are in arr2\n \
    \   std::vector<long> arr3;\n    arr3.reserve(pow(2, cnt - cnt2));\n    std::vector<bool>\
    \ arr3_bool;\n    arr3_bool.reserve(pow(2, cnt - cnt2));\n    // for each 1 in\
    \ arr2, copy the corresponding element of arr2 to the arr3\n    for (auto i :\
    \ arr2) {\n        arr3.push_back(arr2[i]);\n        arr3_bool.push_back(arr2[i]);\n\
    \    }\n    // reverse arr3\n    std::reverse(arr3.begin(), arr3.end());\n   \
    \ // reverse arr3_bool\n    std::reverse(arr3_bool.begin(), arr3_bool.end());\n\
    \    // reverse arr3_bool\n    std::reverse(arr3_bool.begin(), arr3_bool.end());\n\
    \    // reverse the arr3 again\n    std::reverse(arr3.begin(), arr3.end());\n\
    \    // merge arr3 to arr\n    std::merge(arr3.begin(), arr3.end(), arr.begin(),\
    \ arr.end(), std::back_inserter(arr));\n    // reverse arr\n    std::reverse(arr.begin(),\
    \ arr.end());\n    // return the sorted array\n    return arr;", "    std::vector<long>\
    \ res;\n    int max = 0;\n    long cur;\n    for(long i : arr)\n    {\n      \
    \  max = std::max(i, max);\n    }\n    for(long i : arr)\n    {\n        cur =\
    \ (i % max);\n        if(cur != 0)\n        {\n            res.push_back(cur);\n\
    \        }\n    }\n    std::sort(res.begin(), res.end());\n    return res;", " \
    \ long max = 0L;\n  for (long i : arr) {\n    if (i > max) max = i;\n  }\n  std::vector<long>\
    \ arr2;\n  arr2.reserve(arr.size());\n  for (long i : arr) {\n    arr2.push_back((i\
    \ + max) & ~max);\n  }\n  return arr2;", "    // Your code here\n    long long\
    \ bits = 0, ones = 0;\n    for (auto i : arr) {\n        ones = 1 << (i - 1);\n\
    \        bits = bits | ones;\n    }\n    std::vector<long> res(arr.size());\n\
    \    for (auto i : arr) {\n        ones = 1 << (i - 1);\n        res[i] = (bits\
    \ & ones) - (bits & ones * ones);\n        bits = bits & ones;\n    }\n    return\
    \ res;", "  std::sort(arr.begin(), arr.end(), [&](int i, int j) {\n    int num_bits\
    \ = __builtin_popcount(i);\n    int num_bits2 = __builtin_popcount(j);\n    if\
    \ (num_bits == num_bits2)\n      return (i + j) / 2;\n    if (num_bits > num_bits2)\n\
    \      return (j - i) / 2;\n    return num_bits2 < num_bits ? -1 : 1; // reverse\
    \ order\n  });\n  return arr;", "  std::vector<long> res;\n  int cnt = 0;\n  for\
    \ (auto i : arr) {\n    while (i) {\n      cnt++;\n      i &= ~(1ULL << cnt);\n\
    \    }\n    res.push_back(cnt);\n  }\n  res.shrink_to_fit();\n  std::sort(res.begin(),\
    \ res.end());\n  return res;", "    long size = arr.size();\n    assert(size >=\
    \ 2);\n    for (long i = 1; i < size; i++) {\n        // if the count of 0s in\
    \ arr[i] is greater than 0\n        // then we need to put arr[i] on position\
    \ i\n        if (arr[i] > 0)\n            std::swap(arr[i], arr[i - 1]);\n   \
    \ }\n    // here we get the sorted array\n    std::vector<long> result;\n    for\
    \ (long i = 0; i < size; i++)\n        result.push_back(arr[i]);\n    return result;",
  "  if (arr.size() == 0) {\n    return arr;\n  }\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    if (arr[i] < 0) {\n      return arr;\n    }\n  }\n  std::vector<long>\
    \ sorted_arr(arr.size());\n  int cnt = 0;\n  for (int i = 0; i < arr.size(); i++)\
    \ {\n    if (arr[i] == 1) {\n      sorted_arr[i] = cnt++;\n    } else if (arr[i]\
    \ < 0) {\n      sorted_arr[i] = arr[arr.size() + i];\n    }\n  }\n  std::sort(sorted_arr.begin(),\
    \ sorted_arr.end());\n  return sorted_arr;", "  std::vector<long> sorted_arr(arr.size());\n\
    \  for (auto ele : arr) {\n    long bin_rep = std::to_string(ele);\n    std::string\
    \ s = bin_rep;\n    long len = s.size();\n    long pos = 0;\n    while (pos <\
    \ len) {\n      if (s[pos] == '1')\n        pos++;\n      else\n        break;\n\
    \    }\n    if (pos == len)\n      pos = 0;\n    sorted_arr[ele] = pos;\n  }\n\
    \  sort(sorted_arr.begin(), sorted_arr.end());\n  return sorted_arr;", "    std::vector<long>\
    \ rev(arr.size());\n    for (long i = 0, j = 0; i < arr.size(); i++, j++) {\n\
    \        rev[i] = arr[j];\n    }\n\n    std::sort(rev.begin(), rev.end(), [&arr](int\
    \ a, int b) {\n        long lb = 0, ub = 0;\n        do {\n            if (a &\
    \ (1 << lb)) {\n                ub = lb;\n                lb += 1;\n         \
    \   } else {\n                ub -= 1;\n            }\n        } while (ub - lb\
    \ >= 0);\n\n        if (ub - lb == 0)\n            return std::to_string(a) -\
    \ std::to_string(b);\n        if (ub - lb == 1)\n            return std::to_string(ub)\
    \ - std::to_string(b) + std::to_string(a);\n        return std::to_string(a) -\
    \ std::to_string(b);\n    });\n\n    return rev;", "    assert(arr.size() <= INT_MAX);\n\
    \    std::vector<long> ans;\n    for (int i = 0; i < arr.size(); i++) {\n    \
    \    int count = 0;\n        for (int j = 0; j < arr.size(); j++)\n          \
    \  count += arr[j] == arr[i];\n        ans.push_back(count % 10);\n    }\n   \
    \ std::sort(ans.begin(), ans.end());\n    return ans;", "    // Your code here\n\
    \    int size = arr.size();\n    int *arr = new int[size];\n    for (int i = 0;\
    \ i < size; i++) {\n        arr[i] = arr[i] + ((arr[i] >> 1) << 1);\n    }\n \
    \   sort(arr, arr + size);\n    std::reverse(arr, arr + size);\n    std::vector<long>\
    \ ret;\n    for (size_t i = 0; i < size; i++) {\n        if (arr[i] == 0) {\n\
    \            ret.push_back(-1);\n        } else {\n            ret.push_back(arr[i]);\n\
    \        }\n    }\n    return ret;", "    // Solution part 1:\n    // std::sort(arr.begin(),\
    \ arr.end());\n    // Solution part 2:\n    // std::stable_sort(arr.begin(), arr.end());\n\
    \    // Solution part 3:\n    // std::nth_element(arr.begin(), arr.end(), arr.begin());\n\
    \    // Solution part 4:\n    // std::sort(arr.begin(), arr.end());\n    // Solution\
    \ part 5:\n    // std::sort(arr.begin(), arr.end(), std::greater<long>());\n\n\
    \    // sort using std::sort\n    sort(arr.begin(), arr.end());\n    return arr;",
  "    std::vector<long> sortedArr(arr.size());\n\n    // Use a vector of counts to\
    \ count the number of 0 in each element\n    std::vector<int> counts(arr.size());\n\
    \    for (auto elem : arr) {\n        for (auto bit : dec2bin(elem)) {\n     \
    \       if (bit == '0') {\n                counts[elem - 1]--;\n            }\n\
    \        }\n    }\n\n    // Sort based on counts\n    for (auto i = 0; i < counts.size();\
    \ i++) {\n        // if the count is equal, sort based on decimal value\n    \
    \    if (counts[i] == 0)\n            std::swap(sortedArr[i], sortedArr[counts[i]]);\n\
    \        else\n            sortedArr[i] = counts[i];\n    }\n\n    // Restore\
    \ the vector order\n    for (auto i = 0; i < arr.size(); i++)\n        sortedArr[arr.size()\
    \ - 1 - i] = sortedArr[i];\n\n    return sortedArr;", "    long long ones = 0;\n\
    \    for (long long i : arr) ones |= i;\n    long long dec = 0, count = 0;\n \
    \   for (long long i : arr) count += i;\n    std::map<long long, int> count_map;\n\
    \    for (long long i : arr) {\n        count_map[i] += 1;\n        long long\
    \ bin_i = i;\n        while (bin_i > 0) {\n            int div = bin_i % 10;\n\
    \            bin_i /= 10;\n            dec += (div * pow(10, count));\n      \
    \      count -= 1;\n        }\n    }\n    std::vector<long> result;\n    for (auto\
    \ it : count_map) {\n        int num = it.second;\n        int decimal_number\
    \ = dec / num;\n        long long decimal_reminder = dec % num;\n        result.push_back(decimal_number\
    \ * num + decimal_reminder);\n        dec -= decimal_number * num;\n    }\n  \
    \  long long res = 0;\n    for (long long i : result) {\n        res += i;\n \
    \   }\n    std::sort(result.begin(), result.end());\n    return result;", "  \
    \  long temp;\n    std::sort(arr.begin(), arr.end());\n    for (long i = 0; i\
    \ <= (long)arr.size(); ++i) {\n        temp = arr[i];\n        arr[i] = arr[i]\
    \ - (((long(arr[i]) % 2 == 0) ? temp : -temp));\n    }\n    return arr;", "  \
    \  for (auto it = arr.begin(); it != arr.end(); ++it) {\n        long cnt = 0;\n\
    \        while (it != arr.begin()) {\n            cnt += *--it & 1;\n        }\n\
    \        std::swap(*it, cnt);\n    }\n\n    for (auto it = arr.begin(); it !=\
    \ arr.end(); ++it) {\n        std::sort(arr.begin(), arr.end(), [](long a, long\
    \ b) { return a > b; });\n    }\n\n    return arr;", "    assert(arr.size() >=\
    \ 2);\n    std::vector<long> res(arr.size());\n    for (size_t i = 0; i < arr.size();\
    \ i++) {\n        long tmp = 0;\n        for (size_t j = 0; j < arr.size(); j++)\
    \ {\n            if (i & 1) {\n                tmp += arr[j];\n            }\n\
    \        }\n        res[i] = tmp;\n    }\n    for (size_t i = 0; i < arr.size();\
    \ i++) {\n        long tmp = 0;\n        for (size_t j = i; j < arr.size(); j++)\
    \ {\n            if (j % 2 == 0) {\n                tmp += arr[j];\n         \
    \   }\n        }\n        res[arr.size() - i - 1] = tmp;\n    }\n    for (size_t\
    \ i = 0; i < res.size(); i++) {\n        res[i] = std::min(res[i], res[res.size()\
    \ - i - 1]);\n    }\n    return res;", "    long ones = 0;\n    long temp = 0;\n\
    \    for (int i : arr)\n        ones += i;\n    if (ones == 0)\n        return\
    \ arr;\n    std::vector<long> result{};\n    for (int i = 0; i < arr.size(); i++)\n\
    \        if (arr[i] != 0)\n            temp.push_back(arr[i]);\n    for (int i\
    \ = 0; i < arr.size(); i++)\n        if (arr[i] != 0 && ones > 0) {\n        \
    \    while (ones) {\n                result.push_back(temp[i - 1]);\n        \
    \        ones--;\n            }\n        }\n    if (ones > 0)\n        return\
    \ result;\n    std::sort(result.begin(), result.end());\n    return result;",
  "    // Sorting logic here.\n    return arr;", "    // Your code goes here\n   \
    \ sort(arr.begin(), arr.end());\n    int count=0;\n    long temp;\n    for(long\
    \ i:arr){\n        if(i==1)\n            count++;\n        else\n            if((count-arr[i-1])>0)\n\
    \                temp = arr[i-1];\n            else\n                temp = count-arr[i-1];\n\
    \            arr[i-1] = count-arr[i-1];\n            arr[count-arr[i-1]]=temp;\n\
    \            count=0;\n    }\n    return arr;", "  assert(arr.size() != 0);\n\
    \  std::vector<long> sorted_arr;\n  sorted_arr.push_back(arr[0]);\n  for (int\
    \ i = 1; i < arr.size(); i++) {\n    if (arr[i] == 0) {\n      sorted_arr.push_back(sorted_arr[0]);\n\
    \    } else if (arr[i] > 0) {\n      int j = i - 1;\n      while (j >= 0 && (arr[j]\
    \ == 0 || (arr[j] >> i) & 1)) {\n        sorted_arr.push_back(sorted_arr[j--]);\n\
    \      }\n      sorted_arr.push_back(arr[i]);\n    }\n  }\n  return sorted_arr;",
  "    assert(arr.size() > 0);\n\n    int max_bin = 0;\n    for (auto x : arr) {\n\
    \        int bin = __builtin_popcount(x);\n        if (bin > max_bin) {\n    \
    \        max_bin = bin;\n        }\n    }\n\n    std::vector<long> sorted_arr(arr.size());\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        int bin = __builtin_popcount(arr[i]);\n\
    \        sorted_arr[i] = arr[max_bin - bin];\n    }\n    return sorted_arr;",
  "    // O(1) solution for sorting array in ascending order based on count\n    for\
    \ (auto i : arr) {\n        if (i > 0) {\n            int count = 0;\n       \
    \     for (auto j : arr) {\n                if (j != i) {\n                  \
    \  if (j % 10 == 0) {\n                        count += 1;\n                 \
    \   }\n                }\n            }\n            if (count > 0) {\n      \
    \          auto index = arr.size() - 1;\n                while (index > 0 && (arr[index]\
    \ % 10 == 0)) {\n                    auto tmp = arr[index];\n                \
    \    arr[index] = arr[index - 1];\n                    arr[index - 1] = tmp;\n\
    \                    index -= 1;\n                }\n            }\n        }\n\
    \    }\n    // O(n) solution for sorting array in ascending order based on decimal\n\
    \    for (auto i : arr) {\n        std::swap(i, std::count_if(arr.begin(), arr.end(),\
    \ [&](long j) { return j % 10 == 0; }) * 10);\n    }\n    return arr;", "    std::vector<long>\
    \ ans;\n    long sum = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   sum = arr[i] + sum;\n        if (sum > 0) {\n            ans.push_back(sum);\n\
    \        }\n        sum = 0;\n    }\n    // sort the ans array in ascending order\n\
    \    for (int i = 0; i < ans.size(); i++) {\n        for (int j = i + 1; j < ans.size();\
    \ j++) {\n            if (ans[j] < ans[i]) {\n                long temp = ans[i];\n\
    \                ans[i] = ans[j];\n                ans[j] = temp;\n          \
    \  }\n        }\n    }\n    return ans;", "    sort(arr.begin(), arr.end());\n\
    \    auto it = std::unique(arr.begin(), arr.end()); // keep only unique elements\n\
    \    arr.erase(it, arr.end()); // remove unique elements\n    int cnt = 0;\n \
    \   for (long i : arr) {\n        cnt += (i & 1);\n    }\n    long min = 0;\n\
    \    for (long i : arr) {\n        if ((i & 1) == 1) {\n            min = i;\n\
    \        }\n    }\n    long ans = min;\n    long cnt2 = 0;\n    for (long i :\
    \ arr) {\n        if ((i & 1) == 1) {\n            if (min > i) {\n          \
    \      cnt2 += (i & 1);\n                min = i;\n            }\n        }\n\
    \    }\n    for (long i : arr) {\n        if ((i & 1) == 1) {\n            if\
    \ (cnt == 0) {\n                ans = i;\n            }\n            if (min >\
    \ i) {\n                cnt2 += (i & 1);\n                min = i;\n         \
    \   }\n        }\n    }\n    for (long i : arr) {\n        if ((i & 1) == 1) {\n\
    \            if (cnt == 0) {\n                ans = i;\n            }\n      \
    \      if (cnt2 > i) {\n                cnt = cnt2;\n                min = i;\n\
    \            }\n        }\n    }\n    ans += cnt;\n    ans *= cnt;\n    long cnt3\
    \ = 0;\n    for (long i : arr) {\n        if ((i & 1) == 1) {\n            if\
    \ (min > i) {\n                cnt3 += (i & 1);\n                min = i;\n  \
    \          }\n        }\n    }\n    for (long i : arr) {\n        if ((i & 1)\
    \ == 1) {\n            if (cnt == 0) {\n                ans = i;\n           \
    \ }\n            if (cnt3 > i) {\n                cnt = cnt3;\n              \
    \  min = i;\n            }\n        }\n    }\n    ans += cnt;\n    return std::vector<long>(arr);",
  "    std::sort(arr.begin(), arr.end(), [](long l, long r){\n        return count_ones(l)\
    \ > count_ones(r);\n    });\n    return arr;", "    std::vector<long> res(arr.size());\n\
    \    for(size_t i = 0; i < arr.size(); i++){\n        res[i] = 0;\n        for(int\
    \ j = 0; j < arr[i].size(); j++){\n            if (arr[i][j] == 1) res[i]++;\n\
    \        }\n    }\n    \n    for(int i = 0; i < res.size(); i++){\n        if(res[i]\
    \ > res[i+1])\n            return std::vector<long>(arr);\n    }\n    return res;",
  "    // Write your code here\n    std::sort(arr.begin(), arr.end(), [](long a, long\
    \ b) -> bool {\n        return a ^ (a >> 1) < b ^ (b >> 1);\n    });\n    if (arr.size()\
    \ == 0) return arr;\n    std::vector<long> res(arr.size());\n    for (long i :\
    \ arr) res[res.length() - 1 - i] = i;\n    return res;", "    assert(arr.size()\
    \ >= 2);\n    std::vector<long> sorted_arr;\n    long n = 0, temp;\n    sorted_arr.reserve(arr.size());\n\
    \n    for (long i = 0; i < arr.size(); i++) {\n        temp = arr[i];\n      \
    \  while (n != temp) {\n            sorted_arr.push_back(n - temp);\n        \
    \    n -= temp;\n        }\n        sorted_arr.push_back(i);\n        n += arr[i];\n\
    \    }\n    sorted_arr.resize(std::unique(sorted_arr.begin(), sorted_arr.end())\
    \ - sorted_arr.begin());\n    return sorted_arr;", "    // sort base on number\
    \ of ones in their binary representation in ascending order\n    std::sort(arr.begin(),\
    \ arr.end(), [&](long i, long j){\n        return count_one(i) < count_one(j);\n\
    \    });\n    // sort base on decimal value\n    std::sort(arr.begin(), arr.end(),\
    \ [](long i, long j){\n        return i < j;\n    });\n    return arr;", "   \
    \ assert(arr.size() > 0);\n    assert(arr.size() % 2 == 0);\n\n    std::vector<long>\
    \ res(arr.size() / 2 + 1);\n\n    for (long i = arr.size() / 2; i <= arr.size();\
    \ i++) {\n        long cnt = 0;\n\n        for (auto it = arr.cbegin() + i; it\
    \ != arr.cbegin() + i + 1; ++it)\n            cnt += *it == 1 ? 1 : 0;\n\n   \
    \     res.at(i) = cnt;\n    }\n\n    return res;", "    // Write your code here.\n\
    \    assert(arr.size() <= LONG_MAX && \"array size too big\");\n    std::sort(arr.begin(),\
    \ arr.end(), [] (long a, long b) {\n        long temp = a ^ b;\n        return\
    \ temp == 0 ? a < b : temp < 0;\n    });\n    return arr;", "  int n = arr.size();\n\
    \  if (n <= 1)\n    return arr;\n\n  int ones = 0;\n  for (int i = 0; i < n; i++)\
    \ {\n    if (arr[i] > 0)\n      ones += arr[i];\n  }\n\n  std::vector<long> new_arr(ones,\
    \ 0);\n  int max_pos = 0;\n  int max_val = 0;\n\n  for (int i = 0; i < n; i++)\
    \ {\n    if (arr[i] > 0)\n      new_arr[arr[i]] += 1;\n  }\n\n  for (int i = 0;\
    \ i < ones; i++) {\n    max_pos = i;\n    max_val = new_arr[i];\n  }\n\n  for\
    \ (int i = ones; i < n; i++) {\n    if (new_arr[i] > max_val) {\n      max_pos\
    \ = i;\n      max_val = new_arr[i];\n    }\n  }\n\n  assert(max_pos != 0);\n \
    \ assert(max_val > 0);\n\n  int pos = 0;\n  for (int i = 0; i < n; i++) {\n  \
    \  if (arr[i] > 0)\n      arr[pos++] = arr[i];\n  }\n\n  arr.erase(arr.begin()\
    \ + max_pos);\n  return sort_array(arr);", "    long n = arr.size();\n    std::sort(arr.begin(),\
    \ arr.end());\n    std::vector<long> ret;\n    int cnt = 0;\n    for (long i :\
    \ arr) {\n        if (i) {\n            ret.push_back(arr[n-(cnt++)%n]);\n   \
    \     }\n    }\n    return ret;", "  assert(arr.size() == arr.size());\n  std::sort(arr.begin(),\
    \ arr.end(), [&arr](int i, int j) {\n    return count_ones(arr[i]) < count_ones(arr[j])\
    \ ? 1 : -1;\n  });\n\n  std::vector<long> res(arr.size());\n  for (size_t i =\
    \ 0; i < arr.size(); i++)\n    res[i] = arr[i];\n  return res;", "    long long\
    \ int nOnes = 0;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        long\
    \ long int pow2 = 1;\n        for (int k = i; k < arr.size(); k++)\n        {\n\
    \            pow2 = pow2 * 2;\n        }\n        nOnes += (pow2 & arr[i]);\n\
    \    }\n    long long int nZeros = 0;\n    for (int i = 0; i < arr.size(); i++)\n\
    \    {\n        long long int pow2 = 1;\n        for (int k = i; k < arr.size();\
    \ k++)\n        {\n            pow2 = pow2 * 2;\n        }\n        nZeros +=\
    \ (pow2 & arr[i]);\n    }\n    std::vector<long> res(arr.size());\n    for (int\
    \ i = 0; i < arr.size(); i++)\n    {\n        long long int pow2 = 1;\n      \
    \  for (int k = i; k < arr.size(); k++)\n        {\n            pow2 = pow2 *\
    \ 2;\n        }\n        long long int temp = pow2 & arr[i];\n        if (temp\
    \ == 0)\n        {\n            pow2 = pow2 >> nOnes;\n            if (pow2 >\
    \ 0)\n            {\n                res[i] = pow2;\n            }\n        }\n\
    \        else\n        {\n            pow2 = pow2 >> nZeros;\n            if (pow2\
    \ > 0)\n            {\n                res[i] = pow2;\n            }\n       \
    \ }\n    }\n    return res;", "  // write your code here\n  // write your code\
    \ here\n  // write your code here\n  // write your code here\n  // write your\
    \ code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write your code here\n  // write\
    \ your code here\n  // write your code here\n  // write ", "  // Write your code\
    \ here\n  std::vector<long> num(arr.size());\n  for (int i = 0; i < arr.size();\
    \ i++) {\n    num[i] = arr[i];\n  }\n  long long n = 0, res = 0;\n  for (int i\
    \ = 0; i < arr.size(); i++) {\n    n = num[i];\n    while (n) {\n      res *=\
    \ 10;\n      res += n % 10;\n      n /= 10;\n    }\n  }\n  std::vector<long> ans;\n\
    \  ans.push_back(0);\n  while (res) {\n    int d = static_cast<int>(res);\n  \
    \  ans.push_back(res);\n    while(num[ans.size() - 1] >= d) {\n      num[ans.size()\
    \ - 1] %= 10;\n      res = res * 10 + num[ans.size() - 1];\n    }\n  }\n  return\
    \ ans;", "  std::sort(arr.begin(), arr.end(), [](const long &i, const long &j)\
    \ {\n    return count_ones(i) < count_ones(j);\n  });\n  std::vector<long> result;\n\
    \  for (long i : arr) {\n    result.push_back(i);\n  }\n  return result;", '    //
    your code goes here', "  // Write your code here.\n  std::sort(arr.begin(), arr.end());\n\
    \  std::sort(arr.begin(), arr.end(),\n            [&](const long & a, const long\
    \ & b) {\n              return (arr[a] % 2 + arr[b] % 2); });\n  return arr;",
  "  int n = arr.size();\n  std::vector<int> counts(n, 0);\n  for (long i : arr) {\n\
    \    for (int j = 0; j < i; j++) counts[j] += (i & (1 << j));\n  }\n  int result\
    \ = 0;\n  for (int i = 0; i < n; i++) {\n    while (counts[i] >= 2) {\n      result\
    \ += counts[i] + i;\n      counts[i] -= 2;\n    }\n  }\n  return std::vector<long>(arr);",
  "    long res = 0;\n    for (auto x: arr) {\n        bool flag = false;\n      \
    \  for (long i = 0; i < 32; i++) {\n            if ((1 << i) & x) {\n        \
    \        flag = true;\n            }\n        }\n        if (!flag) {\n      \
    \      res = x;\n        }\n    }\n    std::vector<long> res;\n    res.push_back(res);\n\
    \    for (auto x: arr) {\n        bool flag = false;\n        for (long i = 0;\
    \ i < 32; i++) {\n            if ((1 << i) & x) {\n                flag = true;\n\
    \            }\n        }\n        if (flag) {\n            long temp = 1;\n \
    \           for (long i = 0; i < 32; i++) {\n                if ((1 << i) & x)\
    \ {\n                    temp = (temp * 10) + (1 << i);\n                }\n \
    \           }\n            long temp = temp * 10;\n            if (temp > res)\
    \ {\n                res = temp;\n            }\n        }\n    }\n    return\
    \ res;", '  // Solution here', "    std::vector<long> temp(arr.size());\n    //\
    \ sort an array according to the number of ones in their binary representation\n\
    \    for (int i = 0; i < arr.size(); ++i) {\n        long count = 0ULL;\n    \
    \    // counts number of ones in arr[i]'s binary representation\n        while\
    \ ((arr[i] & 1ULL) != 0ULL) {\n            count += 1;\n            arr[i] >>=\
    \ 1;\n        }\n        temp[i] = count;\n    }\n    // sort an array based on\
    \ the decimal value of each number of ones in it's binary representation\n   \
    \ std::sort(temp.begin(), temp.end());\n    return temp;"]
stop_tokens:
- "\n}"
