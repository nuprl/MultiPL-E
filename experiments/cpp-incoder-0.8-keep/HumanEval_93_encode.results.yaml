name: HumanEval_93_encode
language: cpp
results:
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int len =\
    \ message.length();\n  std::string s = \"\";\n  for (int i = 0; i < len; i++)\
    \ {\n    s += message[i];\n  }\n  std::string newS = \"\";\n  for (int i = 0;\
    \ i < len; i++) {\n    switch (s[i]) {\n      case 'a':\n      case 'e':\n   \
    \   case 'i':\n      case 'o':\n      case 'u':\n        newS += 'A';\n      \
    \  break;\n      case 'e':\n      case 'i':\n      case 'o':\n      case 'u':\n\
    \        newS += 'E';\n        break;\n      case 'a':\n      case 'e':\n    \
    \  case 'i':\n      case 'o':\n      case 'u':\n        newS += 'I';\n       \
    \ break;\n      case 'e':\n      case 'i':\n      case 'o':\n      case 'u':\n\
    \        newS += 'O';\n        break;\n      case 'a':\n      case 'e':\n    \
    \  case 'i':\n      case 'o':\n      case 'u':\n        newS += 'U';\n       \
    \ break;\n      default:\n        newS += s[i];\n        break;\n    }\n  }\n\
    \  return newS;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpijzoycwi.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpijzoycwi.cpp:29:7: error: duplicate case value\n   29 |       case\
    \ 'e':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:23:7: note: previously used here\n\
    \   23 |       case 'e':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:30:7: error:\
    \ duplicate case value\n   30 |       case 'i':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:24:7:\
    \ note: previously used here\n   24 |       case 'i':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:31:7:\
    \ error: duplicate case value\n   31 |       case 'o':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:25:7:\
    \ note: previously used here\n   25 |       case 'o':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:32:7:\
    \ error: duplicate case value\n   32 |       case 'u':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:26:7:\
    \ note: previously used here\n   26 |       case 'u':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:35:7:\
    \ error: duplicate case value\n   35 |       case 'a':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:22:7:\
    \ note: previously used here\n   22 |       case 'a':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:36:7:\
    \ error: duplicate case value\n   36 |       case 'e':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:23:7:\
    \ note: previously used here\n   23 |       case 'e':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:37:7:\
    \ error: duplicate case value\n   37 |       case 'i':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:24:7:\
    \ note: previously used here\n   24 |       case 'i':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:38:7:\
    \ error: duplicate case value\n   38 |       case 'o':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:25:7:\
    \ note: previously used here\n   25 |       case 'o':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:39:7:\
    \ error: duplicate case value\n   39 |       case 'u':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:26:7:\
    \ note: previously used here\n   26 |       case 'u':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:42:7:\
    \ error: duplicate case value\n   42 |       case 'e':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:23:7:\
    \ note: previously used here\n   23 |       case 'e':\n      |       ^~~~\n/tmp/tmpijzoycwi.cpp:43:7:\
    \ er"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int vowels\
    \ = 0, consonants = 0;\n    for (int i = 0; i < message.size(); i++) {\n     \
    \   if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || message[i]\
    \ == 'o' || message[i] == 'u') {\n            vowels++;\n        } else {\n  \
    \          consonants++;\n        }\n    }\n    for (int i = 0; i < message.size();\
    \ i++) {\n        if (vowels > 2 && consonants > 2 && message[i] == 'a') {\n \
    \           message[i] = message[vowels - 1];\n            vowels--;\n       \
    \ }\n    }\n    std::string res = \"\";\n    for (int i = 0; i < message.size();\
    \ i++) {\n        if (vowels > 2 && consonants > 2 && message[i] == 'a') {\n \
    \           res.push_back(message[vowels - 1]);\n            vowels--;\n     \
    \   }\n        res.push_back(message[i]);\n    }\n    return res;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9oc_06ap: /tmp/tmp9oc_06ap.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    int vowel_count = 0;\n    for(int i = 0; i < (int)ans.size();\
    \ ++i) {\n        if(ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i]\
    \ == 'o' || ans[i] == 'u') {\n            vowel_count++;\n        }\n    }\n \
    \   for(int i = 0; i < (int)ans.size(); ++i) {\n        ans[i] = ans[i] - 'a';\n\
    \        ans[i] = ans[i] + 'A' - vowel_count + 2;\n        vowel_count = 0;\n\
    \    }\n    for(int i = 0; i < (int)ans.size(); ++i) {\n        if(ans[i] == 'a'\
    \ || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i] == 'u') {\n   \
    \         vowel_count++;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmptpsnbk55: /tmp/tmptpsnbk55.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> vmap;\n    vmap['a'] = 'A';\n    vmap['b'] = 'B';\n    vmap['c'] = 'C';\n\
    \    vmap['d'] = 'D';\n    vmap['e'] = 'E';\n    vmap['f'] = 'F';\n    vmap['g']\
    \ = 'G';\n    vmap['h'] = 'H';\n    vmap['i'] = 'I';\n    vmap['j'] = 'J';\n \
    \   vmap['k'] = 'K';\n    vmap['l'] = 'L';\n    vmap['m'] = 'M';\n    vmap['n']\
    \ = 'N';\n    vmap['o'] = 'O';\n    vmap['p'] = 'P';\n    vmap['q'] = 'Q';\n \
    \   vmap['r'] = 'R';\n    vmap['s'] = 'S';\n    vmap['t'] = 'T';\n    vmap['u']\
    \ = 'U';\n    vmap['v'] = 'V';\n    vmap['w'] = 'W';\n    vmap['x'] = 'X';\n \
    \   vmap['y'] = 'Y';\n    vmap['z'] = 'Z';\n    std::string ans = \"\";\n    for(char\
    \ &c: str_chr(message, 'A'))\n        ans += vmap[c];\n    for(char &c: str_chr(message,\
    \ 'a'))\n        ans += vmap[c];\n    for(char &c: str_chr(message, 'B'))\n  \
    \      ans += vmap[c];\n    for(char &c: str_chr(message, 'b'))\n        ans +=\
    \ vmap[c];\n    for(char &c: str_chr(message, 'C'))\n        ans += vmap[c];\n\
    \    for(char &c: str_chr(message, 'c'))\n        ans += vmap[c];\n    for(char\
    \ &c: str_chr(message, 'D'))\n        ans += vmap[c];\n    for(char &c: str_chr(message,\
    \ 'd'))\n        ans += vmap[c];\n    for(char &c: str_chr(message, 'E'))\n  \
    \      ans += vmap[c];\n    for(char &c: str_chr(message, 'e'))\n        ans +=\
    \ vmap[c];\n    for(char &c: str_chr(message, 'F'))\n        ans += vmap[c];\n\
    \    for(char &c: str_chr(message, 'f'))\n        ans += vmap[c];\n    for(char\
    \ &c: str_chr(message, 'G'))\n        ans += vmap[c];\n    for(char &c: str_chr(message,\
    \ 'g'))\n        ans += vmap[\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr15vs0yw.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpr15vs0yw.cpp:42:18: error: \u2018str_chr\u2019 was not declared in\
    \ this scope; did you mean \u2018strrchr\u2019?\n   42 |     for(char &c: str_chr(message,\
    \ 'A'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:44:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   44 |     for(char &c: str_chr(message,\
    \ 'a'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:46:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   46 |     for(char &c: str_chr(message,\
    \ 'B'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:48:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   48 |     for(char &c: str_chr(message,\
    \ 'b'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:50:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   50 |     for(char &c: str_chr(message,\
    \ 'C'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:52:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   52 |     for(char &c: str_chr(message,\
    \ 'c'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:54:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   54 |     for(char &c: str_chr(message,\
    \ 'D'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:56:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   56 |     for(char &c: str_chr(message,\
    \ 'd'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:58:18: error: \u2018str_chr\u2019 was not declared in this\
    \ scope; did you mean \u2018strrchr\u2019?\n   58 |     for(char &c: str_chr(message,\
    \ 'E'))\n      |                  ^~~~~~~\n      |                  strrchr\n\
    /tmp/tmpr15vs0yw.cpp:60:18: error: \u2018str_chr\u2019"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  std::string\
    \ encodedMessage = \"\";\n  int index = 0;\n  for (int i = 0; i < message.length();\
    \ i++) {\n    if (islower(message[i])){\n      encodedMessage += toupper(message[i]);\n\
    \      index += 2;\n    } \n    else {\n      encodedMessage += message[i];\n\
    \    }\n  }\n  return encodedMessage;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvhyw488w: /tmp/tmpvhyw488w.cpp:29: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    size_t\
    \ vowel_index = 0; \n    std::string encoded_message = \"\";\n    for (int i =\
    \ 0; i < message.length(); i++) {\n        if (message[i] == 'a' || message[i]\
    \ == 'e' || message[i] == 'i' || message[i] == 'o' || message[i] == 'u') {\n \
    \           vowel_index = i;\n        }\n    }\n    \n    for(int i=0; i < message.length();\
    \ i++) {\n        if(message[i] >= 'a' && message[i] <= 'z') {\n            encoded_message\
    \ += (message[i] + static_cast<char>(message[vowel_index + 2]));\n        } else\
    \ {\n            encoded_message += message[i];\n        }\n    }\n    return\
    \ encoded_message;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpix207dym: /tmp/tmpix207dym.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    for (auto &ch : message) {\n        if (isalpha(ch)) {\n     \
    \       std::string swapped;\n            for (int i = 0; i < 2; i++) {\n    \
    \            if (isupper(ch))\n                    swapped.push_back((tolower(ch)\
    \ - ('A' + i)));\n                else\n                    swapped.push_back((toupper(ch)\
    \ - ('a' + i)));\n            }\n            swapped.push_back(ch);\n        \
    \    encoded.append(swapped);\n        }\n        else {\n            encoded.push_back(ch);\n\
    \        }\n    }\n    return encoded;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpqgiirt_k: /tmp/tmpqgiirt_k.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ c = message[i];\n        if (c >= 'a' && c <= 'z') \n            c += ('a' -\
    \ 'a' + 1); \n        else if (c >= 'A' && c <= 'Z') \n            c += ('A' -\
    \ 'A' + 1);\n        else \n            c = c;\n        encoded += c;\n    }\n\
    \    return encoded;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpb1fa7cwd: /tmp/tmpb1fa7cwd.cpp:29: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> vowels = {{'a', 'z'}, {'e', 'i'}, {'o', 'u'}, {'A', 'Z'}, {'E', 'I'},\
    \ {'O', 'U'}};\n    for(auto c : message){\n        auto pos = vowels.find(c);\n\
    \        if(pos != vowels.end()){\n            c = vowels[pos];\n        }\n \
    \       auto vowelPos = vowels.find(c + 2);\n        if(vowelPos != vowels.end()){\n\
    \            c = vowels[vowelPos];\n        }\n        vowels.insert({c + 2, c});\n\
    \    }\n    return std::string(message.begin(), message.end());\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpw7194zkf.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpw7194zkf.cpp:18:23: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::map<char, char>\u2019 and \u2018std::_Rb_tree_iterator<std::pair<const\
    \ char, char> >\u2019)\n   18 |             c = vowels[pos];\n      |        \
    \               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/map:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpw7194zkf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:490:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::operator[](const key_type&) [with _Key = char; _Tp =\
    \ char; _Compare = std::less<char>; _Alloc = std::allocator<std::pair<const char,\
    \ char> >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = char; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = char]\u2019\n  490 |       operator[](const\
    \ key_type& __k)\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:490:34:\
    \ note:   no known conversion for argument 1 from \u2018std::_Rb_tree_iterator<std::pair<const\
    \ char, char> >\u2019 to \u2018const key_type&\u2019 {aka \u2018const char&\u2019\
    }\n  490 |       operator[](const key_type& __k)\n      |                  ~~~~~~~~~~~~~~~~^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:510:7: note:\
    \ candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::operator[](std::map<_Key, _Tp, _Compare, _Alloc>::key_type&&)\
    \ [with _Key = char; _Tp = char; _Compare = std::less<char>; _Alloc = std::allocator<std::pair<const\
    \ char, char> >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = char; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = char]\u2019\n  510 |       operator[](key_type&&\
    \ __k)\n      |       ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:510:29:\
    \ note:   no known conversion for argument 1 from \u2018std::_Rb_tree_iterator<s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n   //Complete\
    \ the code\n   return \"\";\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp6hy063sw: /tmp/tmp6hy063sw.cpp:19: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    assert(message.size()\
    \ > 0);\n    std::string ans = message;\n    for (auto i : ans) {\n        i =\
    \ toupper(i);\n    }\n    for (auto i : message) {\n        auto idx = find_char(ans,\
    \ i);\n        if (idx != std::string::npos) {\n            auto i2 = idx + 2;\n\
    \            if (i2 < ans.size()) {\n                ans[idx] = ans[i2];\n   \
    \         }\n        }\n    }\n    for (auto i : ans) {\n        i = tolower(i);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj2du9vkx.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpj2du9vkx.cpp:20:20: error: \u2018find_char\u2019 was not declared in\
    \ this scope\n   20 |         auto idx = find_char(ans, i);\n      |         \
    \           ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < message.size(); i++) {\n        if(isupper(message[i])){\n\
    \            ans += tolower(message[i]);\n        }\n        else if(islower(message[i])){\n\
    \            ans += message[i];\n        }\n        else if(isalpha(message[i])){\n\
    \            int x = findVowel(message[i]);\n            ans += message[i] + message[x\
    \ + 2];\n        }\n        else if(message[i] == ' ') {\n            ans += 'S';\n\
    \        }\n        else if(message[i] == '.') {\n            ans += 'E';\n  \
    \      }\n        else if(message[i] == '-') {\n            ans += 'E';\n    \
    \    }\n        else if(message[i] == '/') {\n            ans += 'E';\n      \
    \  }\n        else if(message[i] == '.') {\n            ans += 'E';\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_yyy2i_t.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_yyy2i_t.cpp:23:21: error: \u2018findVowel\u2019 was not declared in\
    \ this scope\n   23 |             int x = findVowel(message[i]);\n      |    \
    \                 ^~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ newMessage = message;\n    std::replace(newMessage.begin(), newMessage.end(),\
    \ \"a\", \"A\");\n    std::replace(newMessage.begin(), newMessage.end(), \"e\"\
    , \"E\");\n    std::replace(newMessage.begin(), newMessage.end(), \"i\", \"I\"\
    );\n    std::replace(newMessage.begin(), newMessage.end(), \"o\", \"O\");\n  \
    \  std::replace(newMessage.begin(), newMessage.end(), \"u\", \"U\");\n    std::replace(newMessage.begin(),\
    \ newMessage.end(), \"y\", \"Y\");\n    std::replace(newMessage.begin(), newMessage.end(),\
    \ \"b\", \"B\");\n    std::replace(newMessage.begin(), newMessage.end(), \"c\"\
    , \"C\");\n    std::replace(newMessage.begin(), newMessage.end(), \"d\", \"D\"\
    );\n    std::replace(newMessage.begin(), newMessage.end(), \"f\", \"F\");\n  \
    \  std::replace(newMessage.begin(), newMessage.end(), \"g\", \"G\");\n    std::replace(newMessage.begin(),\
    \ newMessage.end(), \"h\", \"H\");\n    std::replace(newMessage.begin(), newMessage.end(),\
    \ \"k\", \"K\");\n    std::replace(newMessage.begin(), newMessage.end(), \"l\"\
    , \"L\");\n    std::replace(newMessage.begin(), newMessage.end(), \"m\", \"M\"\
    );\n    std::replace(newMessage.begin(), newMessage.end(), \"n\", \"N\");\n  \
    \  std::replace(newMessage.begin(), newMessage.end(), \"p\", \"P\");\n    std::replace(newMessage.begin(),\
    \ newMessage.end(), \"q\", \"Q\");\n    std::replace(newMessage.begin(), newMessage.end(),\
    \ \"s\", \"S\");\n    std::replace(newMessage.begin(), newMessage.end(), \"t\"\
    , \"T\");\n    std::replace(newMessage.begin(), newMessage.end(), \"v\", \"V\"\
    );\n    std::replace(newMessage.begin(), newMessage.end(), \"w\", \"W\");\n  \
    \  std::replace(newMessage.begin(), newMessage.end(), \"x\", \"X\");\n    std::replace(newMessage.begin(),\
    \ newMessage.end(), \"z\", \"Z\");\n    return newMessage;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpirci_raq.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpirci_raq.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string newMessage\
    \ = message;\n      |     ^~~~~~\n      |     std::string\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n    \
    \             from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpirci_raq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpirci_raq.cpp:15:18:\
    \ error: \u2018newMessage\u2019 was not declared in this scope; did you mean \u2018\
    message\u2019?\n   15 |     std::replace(newMessage.begin(), newMessage.end(),\
    \ \"a\", \"A\");\n      |                  ^~~~~~~~~~\n      |               \
    \   message\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    //\
    \ We use an array to track the vowels in the message\n    bool vowels[26];\n \
    \   // We use an array to track the first letter of the message in the english\
    \ alphabet\n    bool english[26];\n    \n    // We fill the vowels array with\
    \ true and false values\n    for (int i = 0; i < 26; i++)\n        vowels[i] =\
    \ false;\n    \n    // We fill the first letter of the english array with true\
    \ and false values\n    for (int i = 0; i < 26; i++)\n        english[i] = false;\n\
    \    \n    // We use the function tolower() to make each letter lower case\n \
    \   for (int i = 0; i < message.length(); i++)\n        message[i] = tolower(message[i]);\n\
    \    \n    // We start at 0 and go through the message and if the letter is vowel\
    \ then \n    // we set the first letter of the english alphabet to true\n    //\
    \ If the letter is not a vowel then we set the first letter of the english \n\
    \    // alphabet to false\n    for (int i = 0; i < message.length(); i++)\n  \
    \      if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || message[i]\
    \ == 'o' || message[i] == 'u')\n            english[0] = true;\n        else\n\
    \            english[0] = false;\n    \n    // We go through the message and if\
    \ the letter is vowel then we set \n    // the first letter of the vowels array\
    \ to true\n    // If the letter is not a vowel then we set the first letter of\
    \ the vowels array to false\n    for (int i = 0; i < message.length(); i++)\n\
    \        if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || message[i]\
    \ == 'o' || message[i] == 'u')\n            vowels[0] = true;\n        else\n\
    \            vowels[0] = false;\n    \n    // We go through the message and if\
    \ the first letter in english is true \n    // then we set that letter to false\
    \ \n    // otherwise we set it to true \n    for (int i = 0; i < message.length();\
    \ i++)\n        if (english[i])\n            vowels[tolower(message[i]) - 'a']\
    \ = false;\n        else\n            vowels[tolower(message[i]) - 'a'] = true;\n\
    \    \n    // We use i to go through the message and if the letter at index i\
    \ of \n    // the message is a vowel then we do this\n    // If the letter is\
    \ not a vowel then we do this\n    for (int i = 0; i < message.length(); i++)\n\
    \        if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || message[i]\
    \ == 'o' || message[i] == 'u')\n            english[i] = true;\n        else\n\
    \            english[i] = false;\n    \n    // We now go through the message and\
    \ if the first letter in english is true\n    // then we set that letter to false\n\
    \    // otherwise we set it to true\n    for (int i = 0; i < message.length();\
    \ i++)\n        if (english[i])\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqyad16uv.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqyad16uv.cpp:74:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   74 | }\n      | ^\n/tmp/tmpqyad16uv.cpp:74:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ temp;\n    for(int i=0;i<message.length();i++) {\n        if(message[i]=='a')\
    \ temp+=message[i+1];\n        if(message[i]=='e') temp+=message[i+1];\n     \
    \   if(message[i]=='i') temp+=message[i+1];\n        if(message[i]=='o') temp+=message[i+1];\n\
    \        if(message[i]=='u') temp+=message[i+1];\n    }\n    for(int i=0;i<temp.length();i++)\
    \ {\n        if(temp[i]=='a') temp[i]=temp[i+1];\n        if(temp[i]=='e') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='i') temp[i]=temp[i+1];\n        if(temp[i]=='o') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='u') temp[i]=temp[i+1];\n    }\n    for(int i=0;i<temp.length();i++)\
    \ {\n        if(temp[i]=='a') temp[i]=temp[i+1];\n        if(temp[i]=='e') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='i') temp[i]=temp[i+1];\n        if(temp[i]=='o') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='u') temp[i]=temp[i+1];\n    }\n    for(int i=0;i<temp.length();i++)\
    \ {\n        if(temp[i]=='a') temp[i]=temp[i+1];\n        if(temp[i]=='e') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='i') temp[i]=temp[i+1];\n        if(temp[i]=='o') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='u') temp[i]=temp[i+1];\n    }\n    for(int i=0;i<temp.length();i++)\
    \ {\n        if(temp[i]=='a') temp[i]=temp[i+1];\n        if(temp[i]=='e') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='i') temp[i]=temp[i+1];\n        if(temp[i]=='o') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='u') temp[i]=temp[i+1];\n    }\n    for(int i=0;i<temp.length();i++)\
    \ {\n        if(temp[i]=='a') temp[i]=temp[i+1];\n        if(temp[i]=='e') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='i') temp[i]=temp[i+1];\n        if(temp[i]=='o') temp[i]=temp[i+1];\n\
    \        if(temp[i]=='u') temp[i]=temp[i+1];\n    }\n    return temp;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_ae5zbzq.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_ae5zbzq.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string temp;\n   \
    \   |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_ae5zbzq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp_ae5zbzq.cpp:16:29:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   16 |         if(message[i]=='a')\
    \ temp+=message[i+1];\n      |                             ^~~~\n/tmp/tmp_ae5zbzq.cpp:17:29:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   17 |         if(message[i]=='e')\
    \ temp+=message[i+1];\n      |                             ^~~~\n/tmp/tmp_ae5zbzq.cpp:18:29:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   18 |         if(message[i]=='i')\
    \ temp+=message[i+1];\n      |                             ^~~~\n/tmp/tmp_ae5zbzq.cpp:19:29:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   19 |         if(message[i]=='o')\
    \ temp+=message[i+1];\n      |                             ^~~~\n/tmp/tmp_ae5zbzq.cpp:20:29:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   20 |         if(message[i]=='u')\
    \ temp+=message[i+1];\n      |                             ^~~~\n/tmp/tmp_ae5zbzq.cpp:22:19:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   22 |   "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Write\
    \ your code here\n    int len = message.length();\n    for(int i = 0; i < len;\
    \ i++){\n        char c = message[i];\n        switch(c){\n            case 'a':\
    \ case 'A':\n                message.erase(i + 1, 1);\n                break;\n\
    \            case 'e': case 'E':\n                message.erase(i + 1, 1);\n \
    \               message.insert(i+1, 'a');\n                break;\n          \
    \  case 'i': case 'I':\n                message.erase(i + 1, 1);\n           \
    \     message.insert(i+1, 'e');\n                break;\n            case 'o':\
    \ case 'O':\n                message.erase(i + 1, 1);\n                message.insert(i+1,\
    \ 'i');\n                break;\n            case 'u': case 'U':\n           \
    \     message.erase(i + 1, 1);\n                message.insert(i+1, 'o');\n  \
    \              break;\n            default:\n                message.erase(i +\
    \ 1, 1);\n                message.insert(i+1, tolower(c));\n        }\n    }\n\
    \    return message;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9cewy0_u.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp9cewy0_u.cpp:24:40: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::insert(int, char)\u2019\n   24 |           \
    \      message.insert(i+1, 'a');\n      |                                    \
    \    ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9cewy0_u.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1534:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::insert(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::const_iterator, std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc>::size_type, _CharT) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::iterator\
    \ = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >; typename\
    \ __gnu_cxx::__alloc_traits<typename __gnu_cxx::__alloc_traits<_Alloc>::rebind<_CharT>::other>::pointer\
    \ = char*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_iterator\
    \ = __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >; typename __gnu_cxx::__alloc_traits<typename"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Fill this\
    \ in.\n  return \"\"; \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpfa_zib2k: /tmp/tmpfa_zib2k.cpp:19: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n\t// your code\
    \ here\n\tstd::map<char,int> vowels;\n\tstd::map<char,int> map;\n\tstd::map<char,int>::iterator\
    \ it;\n\tfor (it=vowels.begin(); it!=vowels.end(); it++) {\n\t\tmap[it->first]\
    \ = it->second;\n\t}\n\tfor (std::string::iterator it=message.begin(); it!=message.end();\
    \ it++) {\n\t\tif (map.find(*it) != map.end()) {\n\t\t\tint pos = map[*it];\n\t\
    \t\tit = message.erase(it);\n\t\t\tit = message.insert(it, it[pos]);\n\t\t}\n\t\
    }\n\tstd::stringstream ss;\n\tfor (std::string::iterator it=message.begin(); it!=message.end();\
    \ it++) {\n\t\tss << map[*it];\n\t}\n\treturn ss.str();\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp476nkpvn: /tmp/tmp476nkpvn.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> map;\n    map.put('a','t');\n    map.put('e','d');\n    map.put('i','e');\n\
    \    map.put('o','o');\n    map.put('u','h');\n    map.put('y','r');\n\n    std::string\
    \ res;\n    for (auto c : message) {\n        switch (c) {\n            case 'a'\
    \ : res += 'A'; break;\n            case 'b' : res += 'B'; break;\n          \
    \  case 'c' : res += 'C'; break;\n            case 'd' : res += 'D'; break;\n\
    \            case 'e' : res += 'E'; break;\n            case 'f' : res += 'F';\
    \ break;\n            case 'g' : res += 'G'; break;\n            case 'h' : res\
    \ += 'H'; break;\n            case 'i' : res += 'I'; break;\n            case\
    \ 'j' : res += 'J'; break;\n            case 'k' : res += 'K'; break;\n      \
    \      case 'l' : res += 'L'; break;\n            case 'm' : res += 'M'; break;\n\
    \            case 'n' : res += 'N'; break;\n            case 'o' : res += 'O';\
    \ break;\n            case 'p' : res += 'P'; break;\n            case 'q' : res\
    \ += 'Q'; break;\n            case 'r' : res += 'R'; break;\n            case\
    \ 's' : res += 'S'; break;\n            case 't' : res += 'T'; break;\n      \
    \      case 'u' : res += 'U'; break;\n            case 'v' : res += 'V'; break;\n\
    \            case 'w' : res += 'W'; break;\n            case 'x' : res += 'X';\
    \ break;\n            case 'y' : res += 'Y'; break;\n            case 'z' : res\
    \ += 'Z'; break;\n            case 'A' : res += 'A'; break;\n            case\
    \ 'B' : res += 'B'; break;\n            case 'C' : res += 'C'; break;\n      \
    \      case 'D' : res += 'D'; break;\n            case 'E' : res += 'E'; break;\n\
    \            case 'F' : res += 'F'; break;\n            case 'G' : res += 'G';\
    \ break;\n            case 'H' : res += 'H'; break;\n            case 'I' : res\
    \ += 'I'; break;\n            case 'J' : res += 'J'; break;\n            case\
    \ 'K' : res += 'K'; break;\n            case 'L' : res += 'L'; break;\n      \
    \      case 'M' : res += 'M'; break;\n            case 'N' : res += 'N'; \n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdughvzw4.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpdughvzw4.cpp:15:9: error: \u2018class std::map<char, char>\u2019 has\
    \ no member named \u2018put\u2019\n   15 |     map.put('a','t');\n      |    \
    \     ^~~\n/tmp/tmpdughvzw4.cpp:16:9: error: \u2018class std::map<char, char>\u2019\
    \ has no member named \u2018put\u2019\n   16 |     map.put('e','d');\n      |\
    \         ^~~\n/tmp/tmpdughvzw4.cpp:17:9: error: \u2018class std::map<char, char>\u2019\
    \ has no member named \u2018put\u2019\n   17 |     map.put('i','e');\n      |\
    \         ^~~\n/tmp/tmpdughvzw4.cpp:18:9: error: \u2018class std::map<char, char>\u2019\
    \ has no member named \u2018put\u2019\n   18 |     map.put('o','o');\n      |\
    \         ^~~\n/tmp/tmpdughvzw4.cpp:19:9: error: \u2018class std::map<char, char>\u2019\
    \ has no member named \u2018put\u2019\n   19 |     map.put('u','h');\n      |\
    \         ^~~\n/tmp/tmpdughvzw4.cpp:20:9: error: \u2018class std::map<char, char>\u2019\
    \ has no member named \u2018put\u2019\n   20 |     map.put('y','r');\n      |\
    \         ^~~\n/tmp/tmpdughvzw4.cpp:66:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n   66 | int main() {\n      |     \
    \       ^\n/tmp/tmpdughvzw4.cpp:73:1: error: expected \u2018}\u2019 at end of\
    \ input\n   73 | }\n      | ^\n/tmp/tmpdughvzw4.cpp:23:28: note: to match this\
    \ \u2018{\u2019\n   23 |     for (auto c : message) {\n      |               \
    \             ^\n/tmp/tmpdughvzw4.cpp:73:1: error: expected \u2018}\u2019 at end\
    \ of input\n   73 | }\n      | ^\n/tmp/tmpdughvzw4.cpp:13:41: note: to match this\
    \ \u2018{\u2019\n   13 | std::string encode(std::string message) {\n      |  \
    \                                       ^\n/tmp/tmpdughvzw4.cpp:73:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   73 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    size_t\
    \ i = 0;\n    std::string res;\n    while (i < message.size()) {\n        size_t\
    \ k = message.size() - i - 2;\n        char first = message[i];\n        if (toupper(first)\
    \ == first && !isalpha(first)) {\n            char second = message[k + 1];\n\
    \            if (toupper(second) == second && !isalpha(second)) {\n          \
    \      char third = message[k + 2];\n                if (toupper(third) == third\
    \ && !isalpha(third)) {\n                    res += tolower(first) + tolower(second)\
    \ + tolower(third);\n                    i += 3;\n                } else {\n \
    \                   res += toupper(first) + tolower(second);\n               \
    \     i += 2;\n                }\n            } else {\n                res +=\
    \ toupper(first);\n                i += 1;\n            }\n        } else {\n\
    \            res += tolower(first);\n            i += 1;\n        }\n    }\n \
    \   return res;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpswsw978k: /tmp/tmpswsw978k.cpp:43: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int size\
    \ = message.size();\n    std::string encoded_message;\n    for (int i = 0; i <\
    \ size; i++) {\n        char c = message[i];\n        if (islower(c)) {\n    \
    \        encoded_message += c;\n        } else {\n            int index = c -\
    \ 'A';\n            if (index >= 1 && index <= 2) {\n                encoded_message\
    \ += toupper(c);\n            }\n        }\n    }\n    for (int i = 0; i < size;\
    \ i++) {\n        char c = encoded_message[i];\n        if (isupper(c)) {\n  \
    \          encoded_message[i] = tolower(c) - 'A' + 1;\n        }\n    }\n    return\
    \ encoded_message;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpxzduj8i4: /tmp/tmpxzduj8i4.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ newMessage = \"\";\n    \n    for (int i = 0; i < message.length(); ++i) {\n\
    \        char currentChar = message[i];\n        int positionInAlphabet = currentChar\
    \ - 'a';\n        if (currentChar >= 'A' && currentChar <= 'Z') {\n          \
    \  currentChar = currentChar - 'A' + 'a';\n        }\n        if (positionInAlphabet\
    \ >= 2 && positionInAlphabet < message.length() - 2) {\n            newMessage\
    \ += currentChar;\n        }\n    }\n    for (int i = 0; i < newMessage.length();\
    \ ++i) {\n        newMessage[i] = (newMessage[i] + newMessage[i +1])%26;\n   \
    \ }\n    for (int i = 0; i < newMessage.length(); ++i) {\n        newMessage[i]\
    \ = newMessage[i] + 'a';\n    }\n    return newMessage;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpo1ww5iaf: /tmp/tmpo1ww5iaf.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ int> vows;\n    std::map<char, char> map;\n    map['a'] = 'A';\n    map['e']\
    \ = 'E';\n    map['i'] = 'I';\n    map['o'] = 'O';\n    map['u'] = 'U';\n    map['y']\
    \ = 'Y';\n    // Check each character of the message and update our mapping\n\
    \    for (auto& c : message) {\n        if (vows.find(c) != vows.end()) \n   \
    \         vows[c] += 2;\n        else\n            vows[c] = 1;\n    }\n    //\
    \ Iterate over vows map and make a new string with the mapping\n    std::string\
    \ encoded_message;\n    for (auto v : vows) {\n        encoded_message += map[v.first];\n\
    \        encoded_message += map[v.second];\n    }\n    return encoded_message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9vbkp_6w: /tmp/tmp9vbkp_6w.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for (std::string::iterator\
    \ it = message.begin(); it != message.end(); ++it) {\n        // if there is a\
    \ vowel in current position\n        if ((*it == 'A' || *it == 'E' || *it == 'I'\
    \ || *it == 'O' || *it == 'U') &&\n            (*(it+1) >= 'A' && *(it+1) <= 'F'))\
    \ {\n            std::swap(*it, *(it+1));\n        }\n        // if there is a\
    \ vowel 2 positions ahead of current position\n        else if (*it == 'a' &&\
    \ *(it+2) >= 'a' && *(it+2) <= 'f') {\n            std::swap(*it, *(it+2));\n\
    \        }\n        // if there is a vowel 3 positions ahead of current position\n\
    \        else if (*it == 'a' && *(it+3) >= 'a' && *(it+3) <= 'f') {\n        \
    \    std::swap(*it, *(it+3));\n        }\n        // if there is a vowel 4 positions\
    \ ahead of current position\n        else if (*it == 'a' && *(it+4) >= 'a' &&\
    \ *(it+4) <= 'f') {\n            std::swap(*it, *(it+4));\n        }\n       \
    \ // if there is a vowel 5 positions ahead of current position\n        else if\
    \ (*it == 'a' && *(it+5) >= 'a' && *(it+5) <= 'f') {\n            std::swap(*it,\
    \ *(it+5));\n        }\n        // if there is a vowel 6 positions ahead of current\
    \ position\n        else if (*it == 'a' && *(it+6) >= 'a' && *(it+6) <= 'f') {\n\
    \            std::swap(*it, *(it+6));\n        }\n    }\n    return message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp0u_q8jx9: /tmp/tmp0u_q8jx9.cpp:45: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ output = message;\n    std::transform(output.begin(), output.end(), output.begin(),\
    \ ::tolower);\n    std::transform(output.begin(), output.end(), output.begin(),\
    \ ::toupper);\n\n    std::string vowel(\"AEIOU\");\n    std::string vowel2(\"\
    AEIOU\");\n\n    std::string vowel3(\"AEIOU\");\n    std::string vowel4(\"AEIOU\"\
    );\n\n    std::string vowel5(\"AEIOU\");\n    std::string vowel6(\"AEIOU\");\n\
    \n    std::string vowel7(\"AEIOU\");\n    std::string vowel8(\"AEIOU\");\n\n \
    \   for (int i = 0; i < message.size(); i++) {\n        if (vowel.find(message[i])\
    \ != std::string::npos) {\n            std::string vowel2 = message[i];\n    \
    \        std::string vowel4 = message[i];\n            std::string vowel6 = message[i];\n\
    \            std::string vowel8 = message[i];\n            std::string vowel10\
    \ = message[i];\n            std::string vowel12 = message[i];\n            std::string\
    \ vowel14 = message[i];\n            std::string vowel16 = message[i];\n     \
    \       std::string vowel18 = message[i];\n            std::string vowel20 = message[i];\n\
    \            std::string vowel22 = message[i];\n            std::string vowel24\
    \ = message[i];\n            std::string vowel26 = message[i];\n            std::string\
    \ vowel28 = message[i];\n            std::string vowel30 = message[i];\n     \
    \       std::string vowel32 = message[i];\n            std::string vowel34 = message[i];\n\
    \            std::string vowel36 = message[i];\n            std::string vowel38\
    \ = message[i];\n            std::string vowel40 = message[i];\n            std::string\
    \ vowel42 = message[i];\n            std::string vowel44 = message[i];\n     \
    \       std::string vowel46 = message[i];\n            std::string vowel48 = message[i];\n\
    \            std::string vowel50 = message[i];\n            std::string vowel52\
    \ = message[i];\n            std::string vowel54 = message[i];\n            std::string\
    \ vowel56 = message[i];\n            std::string vowel58 = message[i];\n     \
    \       std::string vowel60 = message[i];\n            std::string vowel62 = message[i];\n\
    \            std::string vowel64 = message[i];\n            std::string vowel66\
    \ = message[i];\n            std::string vowel68 = message[i];\n            std::string\
    \ vowel70 = message[i];\n            std::string vowel72 = message[i];\n     \
    \       std::string vowel74 = message[i];\n            std::string vowel76 = message[i];\n\
    \            std::string vowel78 = message[i];\n            std::string vowel80\
    \ = message[i];\n            std::string vowel82 = message[i];\n            std::string\
    \ vowel84 = message[i];\n            std::string vowel86 = message[i];\n     \
    \       std::string vowel88 = message[i];\n            std::string vowel90 = message[i];\n\
    \            std::string vowel92 = message[i];\n            std::string vowel94\
    \ = message[i];\n            std::string vowel96 = message\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqslwyub4.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqslwyub4.cpp:32:43: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   32 |      \
    \       std::string vowel2 = message[i];\n      |                            \
    \               ^\n/tmp/tmpqslwyub4.cpp:33:43: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   33 |      \
    \       std::string vowel4 = message[i];\n      |                            \
    \               ^\n/tmp/tmpqslwyub4.cpp:34:43: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   34 |      \
    \       std::string vowel6 = message[i];\n      |                            \
    \               ^\n/tmp/tmpqslwyub4.cpp:35:43: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   35 |      \
    \       std::string vowel8 = message[i];\n      |                            \
    \               ^\n/tmp/tmpqslwyub4.cpp:36:44: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   36 |      \
    \       std::string vowel10 = message[i];\n      |                           \
    \                 ^\n/tmp/tmpqslwyub4.cpp:37:44: error: conversion from \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019 {aka \u2018\
    char\u2019} to non-scalar type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } requested\n   37 |             std::string vowel12 = message[i];\n      |  \
    \                                          ^\n/tmp/tmpqslwyub4.cpp:38:44: error:\
    \ conversion fro"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int n =\
    \ message.length();\n    std::string ans = \"\";\n    for (int i = 0; i < n; i++)\
    \ {\n        if (message[i] >= 'a' && message[i] <= 'z') {\n            char ch1\
    \ = message[i] - 'a';\n            char ch2 = message[n - i - 1] - 'a';\n    \
    \        char ch3 = ch2 - ch1;\n            ans += ch3;\n        } else {\n  \
    \          ans += message[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpz3tkn15f: /tmp/tmpz3tkn15f.cpp:30: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  char alphabet[]\
    \ = {'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};\n\
    \  std::string encoded;\n  for (int i = 0; i < message.length(); i++) {\n    std::string\
    \ ch = message[i];\n    for (int j = 0; j < 26; j++) {\n      std::swap(ch[j],\
    \ alphabet[(j + 2)%26]);\n    }\n    encoded = encoded + ch;\n  }\n  return encoded;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_fveczo8.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_fveczo8.cpp:17:31: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   17 |     std::string\
    \ ch = message[i];\n      |                               ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for(auto it = message.begin(); it < message.end(); it++)\
    \ {\n        if(isalpha(it)) {\n            char c = tolower(*it);\n         \
    \   char c2 = tolower(*(it+1));\n            ans.push_back(c ^ c2);\n        \
    \    ans.push_back(toupper(c2));\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyy2bawhz.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyy2bawhz.cpp:16:22: error: no matching function for call to \u2018\
    isalpha(__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >&)\u2019\
    \n   16 |         if(isalpha(it)) {\n      |                      ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cctype:42,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpyy2bawhz.cpp:2:\n/usr/include/ctype.h:112:1: note:\
    \ candidate: \u2018int isalpha(int)\u2019\n  112 | __exctype (isalpha);\n    \
    \  | ^~~~~~~~~\n/usr/include/ctype.h:112:1: note:   no known conversion for argument\
    \ 1 from \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018int\u2019\n  112 | __exctype (isalpha);\n      | ^~~~~~~~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_ios.h:37,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpyy2bawhz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:2599:5:\
    \ note: candidate: \u2018template<class _CharT> bool std::isalpha(_CharT, const\
    \ std::locale&)\u2019\n 2599 |     isalpha(_CharT __c, const locale& __loc)\n\
    \      |     ^~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:2599:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpyy2bawhz.cpp:16:22:\
    \ note:   candidate expects 2 arguments, 1 provided\n   16 |         if(isalpha(it))\
    \ {\n      |                      ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> map; \n    \n    // traverse the message and store all letters in map\n\
    \    for (int i = 0; i < message.length(); i++)\n    {\n        map[message[i]]\
    \ = message[i]; \n    }\n    \n    // traverse the message and replace vowels\
    \ with letters 2 places ahead \n    // in alphabet\n    for (int i = 0; i < message.length();\
    \ i++)\n    {\n        // map value will contain the current letter \n       \
    \ // if the value is 'T' then it replaces with 'H'\n        // if value is 'u'\
    \ then it replaces with 'O'\n        \n        if (map[message[i]] == 'T')\n \
    \           map[message[i]] = 'H';\n        else if (map[message[i]] == 'u')\n\
    \            map[message[i]] = 'O';\n        else\n        {\n            // get\
    \ the letter 'a' in the map and replace with \n            // 'a' 2 places ahead\
    \ of the current letter\n            \n            std::map<char, char>::iterator\
    \ it = map.find(map[message[i]]);\n            map[message[i]] = it->second +\
    \ 2; \n        }\n    }\n    \n    std::string ans = \"\";\n    \n    // traverse\
    \ the map to create ans string\n    for(std::map<char, char>::iterator it = map.begin();\
    \ it != map.end(); ++it){\n        ans += it->second;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpili7vhws: /tmp/tmpili7vhws.cpp:54: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // TODO:\
    \ Write your code here.\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpb_wil21m: /tmp/tmpb_wil21m.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // TODO:\
    \ Write your solution here\n  // Your code here\n  std::reverse(message.begin(),\
    \ message.end());\n  for (auto c : message)\n  {\n    switch(c)\n    {\n     \
    \ case 'a':\n      case 'e':\n      case 'i':\n      case 'o':\n      case 'u':\n\
    \        std::swap(c, c+2);\n        break;\n      case 'A':\n      case 'E':\n\
    \      case 'I':\n      case 'O':\n      case 'U':\n        std::swap(c, c+2);\n\
    \        break;\n    }\n  }\n  for (char &c: message)\n  {\n    switch (c)\n \
    \   {\n      case 'a':\n      case 'A':\n        std::swap(c, c+1);\n        break;\n\
    \      case 'e':\n      case 'E':\n        std::swap(c, c+2);\n        break;\n\
    \      case 'i':\n      case 'I':\n        std::swap(c, c+3);\n        break;\n\
    \      case 'o':\n      case 'O':\n        std::swap(c, c+3);\n        break;\n\
    \      case 'u':\n      case 'U':\n        std::swap(c, c+4);\n        break;\n\
    \    }\n  }\n  return message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps0xqojmg.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmps0xqojmg.cpp:26:25: error: no matching function for call to \u2018\
    swap(char&, int)\u2019\n   26 |         std::swap(c, c+2);\n      |          \
    \               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmps0xqojmg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/move.h:182:5:\
    \ note: candidate: \u2018template<class _Tp> typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp>\
    \ >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type\
    \ std::swap(_Tp&, _Tp&)\u2019\n  182 |     swap(_Tp& __a, _Tp& __b)\n      | \
    \    ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/move.h:182:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmps0xqojmg.cpp:26:25:\
    \ note:   deduced conflicting types for parameter \u2018_Tp\u2019 (\u2018char\u2019\
    \ and \u2018int\u2019)\n   26 |         std::swap(c, c+2);\n      |          \
    \               ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    std::string vowels = \"aeiouAEIOU\";\n    for (int i = 0; i < message.length();\
    \ i++) {\n        ans += message[i];\n        char ch1 = message[i];\n       \
    \ char ch2 = message[i+1];\n        if ((ch1 == 'a' || ch1 == 'e' || ch1 == 'i'\
    \ || ch1 == 'o' || ch1 == 'u') && ch2 == ch1) {\n            ans += message[i+1];\n\
    \        } else {\n            if (vowels.find(ch1) != std::string::npos) {\n\
    \                ans += message[i+1];\n            }\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpb8qc1jbm: /tmp/tmpb8qc1jbm.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n\tstd::string\
    \ encoded = message;\n\tfor (int i = 0; i < encoded.size(); i++) {\n\t\tchar c\
    \ = encoded.at(i);\n\t\tif (isupper(c)) {\n\t\t\tencoded = encoded.substr(0, i)\
    \ + tolower(encoded.at(i + 1)) + encoded.substr(i + 2);\n\t\t}\n\t\telse if (islower(c))\
    \ {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i + 1)) + encoded.substr(i\
    \ + 2);\n\t\t}\n\t\telse if (c == 'A') {\n\t\t\tencoded = encoded.substr(0, i)\
    \ + tolower(encoded.at(i + 2)) + encoded.substr(i + 3);\n\t\t}\n\t\telse if (c\
    \ == 'E') {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i + 2))\
    \ + encoded.substr(i + 3);\n\t\t}\n\t\telse if (c == 'I') {\n\t\t\tencoded = encoded.substr(0,\
    \ i) + tolower(encoded.at(i + 3)) + encoded.substr(i + 4);\n\t\t}\n\t\telse if\
    \ (c == 'O') {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i +\
    \ 3)) + encoded.substr(i + 4);\n\t\t}\n\t\telse if (c == 'U') {\n\t\t\tencoded\
    \ = encoded.substr(0, i) + tolower(encoded.at(i + 4)) + encoded.substr(i + 5);\n\
    \t\t}\n\t\telse if (c == 'E') {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i\
    \ + 4)) + encoded.substr(i + 5);\n\t\t}\n\t\telse if (c == 'A') {\n\t\t\tencoded\
    \ = encoded.substr(0, i) + tolower(encoded.at(i + 5)) + encoded.substr(i + 6);\n\
    \t\t}\n\t\telse if (c == 'I') {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i\
    \ + 5)) + encoded.substr(i + 6);\n\t\t}\n\t\telse if (c == 'O') {\n\t\t\tencoded\
    \ = encoded.substr(0, i) + tolower(encoded.at(i + 6)) + encoded.substr(i + 7);\n\
    \t\t}\n\t\telse if (c == 'U') {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i\
    \ + 6)) + encoded.substr(i + 7);\n\t\t}\n\t\telse if (c == 'A') {\n\t\t\tencoded\
    \ = encoded.substr(0, i) + tolower(encoded.at(i + 7)) + encoded.substr(i + 8);\n\
    \t\t}\n\t\telse if (c == 'I') {\n\t\t\tencoded = encoded.substr(0, i) + toupper(encoded.at(i\
    \ + 7)) + encoded.substr(i + 8);\n\t\t}\n\t\telse if (c == 'O') {\n\t\t\tencoded\
    \ = encoded.substr(0, i) + tolower(encoded.at(i + \n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp_z2ng7h2.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp_z2ng7h2.cpp:18:35: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018int\u2019)\n\
    \   18 |    encoded = encoded.substr(0, i) + tolower(encoded.at(i + 1)) + encoded.substr(i\
    \ + 2);\n      |              ~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                            |               |\n      |               \
    \             |               int\n      |                            std::__cxx11::basic_string<char>\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp_z2ng7h2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp_z2ng7h2.cpp:18:62:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   18 |    encoded = encoded.substr(0, i) + tolower(encoded.at(i\
    \ + 1)) + encoded.substr(i + 2);\n      |             "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Write\
    \ your code here\n    for(std::string::size_type i = 0; i<message.size(); i++)\n\
    \    {\n        char temp = message[i];\n        switch(temp)\n        {\n   \
    \         case 'a':\n                message[i] = 'A';\n                break;\n\
    \            case 'b':\n                message[i] = 'B';\n                break;\n\
    \            case 'c':\n                message[i] = 'C';\n                break;\n\
    \            case 'd':\n                message[i] = 'D';\n                break;\n\
    \            case 'e':\n                message[i] = 'E';\n                break;\n\
    \            case 'f':\n                message[i] = 'F';\n                break;\n\
    \            case 'g':\n                message[i] = 'G';\n                break;\n\
    \            case 'h':\n                message[i] = 'H';\n                break;\n\
    \            case 'i':\n                message[i] = 'I';\n                break;\n\
    \            case 'j':\n                message[i] = 'J';\n                break;\n\
    \            case 'k':\n                message[i] = 'K';\n                break;\n\
    \            case 'l':\n                message[i] = 'L';\n                break;\n\
    \            case 'm':\n                message[i] = 'M';\n                break;\n\
    \            case 'n':\n                message[i] = 'N';\n                break;\n\
    \            case 'o':\n                message[i] = 'O';\n                break;\n\
    \            case 'p':\n                message[i] = 'P';\n                break;\n\
    \            case 'q':\n                message[i] = 'Q';\n                break;\n\
    \            case 'r':\n                message[i] = 'R';\n                break;\n\
    \            case 's':\n                message[i] = 'S';\n                break;\n\
    \            case 't':\n                message[i] = 'T';\n                break;\n\
    \            case 'u':\n                message[i] = 'U';\n                break;\n\
    \            case 'v':\n                message[i] = 'V';\n                break;\n\
    \            case 'w':\n                message[i] = 'W';\n                break;\n\
    \            case 'x':\n                message[i] = 'X';\n                break;\n\
    \            case 'y':\n                message[i] = 'Y';\n                break;\n\
    \            case 'z':\n                message[i] = 'Z';\n                break;\n\
    \        }\n    }\n    for(std::string::size_type i = 0; i<message.size(); i++)\n\
    \    {\n        if(message[i] == 'A')\n        {\n            char temp = message[i\
    \ + 1];\n            message[i + 1] = 'a';\n            message[i] = temp;\n \
    \       }\n        if(message[i] == 'B')\n        {\n            char temp = message[i\
    \ + 1];\n            message[i + 1] = 'b';\n            message[i] = temp;\n \
    \       }\n        if(message[i] == 'C')\n        {\n            char temp = message[i\
    \ + 1];\n            message[i + 1] = 'c';\n            message[i] = temp;\n \
    \       }\n        if(message[i] == 'D')\n        {\n            char temp = message[i\
    \ + 1];\n            message[i + 1] = 'd';\n            message[i] = temp;\n \
    \       }\n        if(message[i] == 'E')\n        {\n            char temp = message[i\
    \ + 1];\n            message[i + 1] = 'e';\n            message[i] = temp;\n \
    \       }\n        if(message[i] == 'F\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl33b91na.cpp:132:26: warning: missing terminating ' character\n\
    \  132 |         if(message[i] == 'F\n      |                          ^\n/tmp/tmpl33b91na.cpp:132:26:\
    \ error: missing terminating ' character\n  132 |         if(message[i] == 'F\n\
    \      |                          ^~\n/tmp/tmpl33b91na.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmpl33b91na.cpp:133:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n  133 | }\n      | ^\n/tmp/tmpl33b91na.cpp:132:25:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n  132 |         if(message[i]\
    \ == 'F\n      |           ~             ^\n      |                         )\n\
    \  133 | }\n      | ~                        \n/tmp/tmpl33b91na.cpp:133:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n  133 | }\n      | ^\n\
    /tmp/tmpl33b91na.cpp:134:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  134 | int main() {\n      |            ^\n/tmp/tmpl33b91na.cpp:141:1:\
    \ error: expected \u2018}\u2019 at end of input\n  141 | }\n      | ^\n/tmp/tmpl33b91na.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpl33b91na.cpp:141:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  141 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> swaps;\n    char firstLetter, secondLetter;\n    \n    for (char &c: message)\n\
    \    {\n        c = tolower(c);\n        if (c.isalpha()) {\n            firstLetter\
    \ = c;\n            secondLetter = swaps.find(firstLetter)->second;\n        \
    \    swaps[firstLetter] = secondLetter;\n        } else {\n            swaps.clear();\n\
    \        }\n    }\n    \n    std::string result;\n    for (auto const &c: message)\n\
    \    {\n        result += swaps[c];\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpefqcx08q.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpefqcx08q.cpp:20:15: error: request for member \u2018isalpha\u2019 in\
    \ \u2018c\u2019, which is of non-class type \u2018char\u2019\n   20 |        \
    \ if (c.isalpha()) {\n      |               ^~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n\t// your code\
    \ goes here\n    std::string ans = \"x\";\n    for (size_t i = 0; i < message.length();\
    \ i++) {\n        char c = message[i];\n        char a = tolower(c); // a holds\
    \ index of letter in english alphabet\n        ans = ans + a;\n    }\n    std::string\
    \ res = ans;\n    std::string vowels = \"aeiou\";\n    for (size_t i = 0; i <\
    \ vowels.size(); i++) {\n        char c = vowels[i];\n        int ind = 0;\n \
    \       for (int j = 0; j < res.length(); j++) {\n            if (c == res[j])\
    \ {\n                ind = j;\n                break;\n            }\n       \
    \ }\n        char a = tolower(c); // a holds index of letter in english alphabet\n\
    \        ans = ans.substr(0, ind) + a + ans.substr(ind, ans.length());\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmps5taevdo: /tmp/tmps5taevdo.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> vowel_map = {\n        { ' ', 't' },\n        { 'a', 'a' },\n        {\
    \ 'e', 'e' },\n        { 'i', 'i' },\n        { 'o', 'o' },\n        { 'u', 'u'\
    \ },\n        { 'y', 'y' },\n        { 'A', 'a' },\n        { 'E', 'e' },\n  \
    \      { 'I', 'i' },\n        { 'O', 'o' },\n        { 'U', 'u' },\n        {\
    \ 'Y', 'y' },\n        { '0', '0' },\n        { '1', '1' },\n        { '2', '2'\
    \ },\n        { '3', '3' },\n        { '4', '4' },\n        { '5', '5' },\n  \
    \      { '6', '6' },\n        { '7', '7' },\n        { '8', '8' },\n        {\
    \ '9', '9' },\n    };\n    // Write your code here\n    std::string result=\"\"\
    ;\n    for (auto &it: message){\n        for (auto &a: vowel_map){\n         \
    \   if (it==a.first){\n                result+=a.second;\n            }\n    \
    \    }\n        result+=it;\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpf6smlt2n: /tmp/tmpf6smlt2n.cpp:53: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ encoded = \"\";\n    // Write your code here\n    for(auto &i : message) {\n\
    \        if ('a'<= i &&i <= 'z') {\n            encoded += i;\n        } else\
    \ if ( 'A'<= i &&i <= 'Z') {\n            encoded += i;\n        } else if ( '0'<=\
    \ i &&i <= '9') {\n            encoded += i;\n        } else if (i == '.') {\n\
    \            encoded += i;\n        } else if (i == '-') {\n            encoded\
    \ += i;\n        } else if (i == '_') {\n            encoded += i;\n        }\
    \ else {\n            char nextletter = 'A' + ( ( (message[i] - 'A' + 1) % 26\
    \ ) + 1);\n            encoded += nextletter;\n        }\n    }\n    return encoded;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzjd81m66.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpzjd81m66.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string encoded = \"\
    \";\n      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpzjd81m66.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpzjd81m66.cpp:18:13:\
    \ error: \u2018encoded\u2019 was not declared in this scope; did you mean \u2018\
    encode\u2019?\n   18 |             encoded += i;\n      |             ^~~~~~~\n\
    \      |             encode\n/tmp/tmpzjd81m66.cpp:20:13: error: \u2018encoded\u2019\
    \ was not declared in this scope; did you mean \u2018encode\u2019?\n   20 |  \
    \           encoded += i;\n      |             ^~~~~~~\n      |             encode\n\
    /tmp/tmpzjd81m66.cpp:22:13: error: \u2018encoded\u2019 was not declared in this\
    \ scope; did you mean \u2018encode\u2019?\n   22 |             encoded += i;\n\
    \      |             ^~~~~~~\n      |             encode\n/tmp/tmpzjd81m66.cpp:24:13:\
    \ error: \u2018encoded\u2019 was not declared in this scope; did you mean \u2018\
    encode\u2019?\n   24 |             encoded += i;\n      |             ^~~~~~~\n\
    \      |             encode\n/tmp/tmpzjd81m66.cpp:26:13: error: \u2018encoded\u2019\
    \ was not declared in this scope; did you mean \u2018encode\u2019?\n   26 |  \
    \           encoded += i;\n      |             ^~~~~~~\n      |"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ res = message;\n    for (int i = 0; i < message.length(); i++) {\n        char\
    \ letter = message[i];\n        if (letter == 'a' || letter == 'e' || letter ==\
    \ 'i' || letter == 'o' || letter == 'u') {\n            letter = letter - 'a'\
    \ + 'A';\n        }\n        res = std::string(letter, res);\n    }\n    for (int\
    \ i = 0; i < message.length(); i++) {\n        char letter = res[i];\n       \
    \ if (letter == 'A' || letter == 'E' || letter == 'I' || letter == 'O' || letter\
    \ == 'U') {\n            res = std::string(letter, res);\n        }\n    }\n \
    \   return res;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp03epj5v_.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp03epj5v_.cpp:20:38: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::basic_string(char&, std::string&)\u2019\n  \
    \ 20 |         res = std::string(letter, res);\n      |                      \
    \                ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp03epj5v_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:625:9:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)\u2019\
    \n  625 |         basic_string(_InputIterator __beg, _InputIterator __end,\n \
    \     |         ^~~~~~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:625:9:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp03epj5v_.cpp:20:38:\
    \ note:   deduced conflicting types for parameter \u2018_InputIterator\u2019 (\u2018\
    char\u2019 and \u2018std::__cxx11::basic_string<char>\u2019)\n   20 |        \
    \ res = std::string(letter, res);\n      |                                   \
    \   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for (std::string::size_type\
    \ i = 0; i < message.length(); i++) {\n        std::string vowels = \"aeiou\"\
    ;\n        int position = i;\n        if (vowels.find(message[i]) != std::string::npos)\n\
    \            position = vowels.find(message[i]);\n        int firstVowel = position;\n\
    \        if (firstVowel == 0) firstVowel = 1;\n        while (vowels.find(message[position\
    \ - 1]) != std::string::npos)\n            position--;\n        int secondVowel\
    \ = position;\n        if (secondVowel == message.length() - 1) secondVowel =\
    \ message.length() - 1;\n        std::string firstLetter = message[firstVowel\
    \ - 1];\n        std::string secondLetter = message[secondVowel + 1];\n      \
    \  std::string newLetter = message[position];\n        message = message.substr(0,\
    \ i) + newLetter + message.substr(i + 1);\n        message = message.substr(0,\
    \ firstVowel) + firstLetter + message.substr(firstVowel + 1) + secondLetter +\
    \ message.substr(secondVowel + 1);\n    }\n    return message;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm4vklxyk.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpm4vklxyk.cpp:25:57: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   25 |      \
    \   std::string firstLetter = message[firstVowel - 1];\n      |              \
    \                                           ^\n/tmp/tmpm4vklxyk.cpp:26:59: error:\
    \ conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} requested\n   26 |         std::string\
    \ secondLetter = message[secondVowel + 1];\n      |                          \
    \                                 ^\n/tmp/tmpm4vklxyk.cpp:27:49: error: conversion\
    \ from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} requested\n   27 |         std::string\
    \ newLetter = message[position];\n      |                                    \
    \             ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int len\
    \ = message.length();\n    std::string encodedMessage = \"\";\n    for (int i\
    \ = 0; i < len; i++) {\n        char c = message[i];\n        if (isalpha(c))\
    \ {\n            encodedMessage += tolower(c);\n        }\n        if (isupper(c))\
    \ {\n            encodedMessage += toupper(c);\n        }\n        if (islower(c))\
    \ {\n            encodedMessage += c;\n        }\n        if (isdigit(c)) {\n\
    \            encodedMessage += c;\n        }\n    }\n    for (int i = 0; i < message.length();\
    \ i++) {\n        int j = i + 1;\n        if (isalpha(message[i])) {\n       \
    \     while (j < message.length() && isalpha(message[j])) {\n                encodedMessage\
    \ += toupper(message[j]);\n                j++;\n            }\n        }\n  \
    \      if (isdigit(message[i])) {\n            while (j < message.length() &&\
    \ isdigit(message[j])) {\n                encodedMessage += message[j];\n    \
    \            j++;\n            }\n        }\n    }\n    for (int i = 0; i < message.length();\
    \ i++) {\n        if (isupper(message[i])) {\n            int j = i + 1;\n   \
    \         while (j < message.length() && isupper(message[j])) {\n            \
    \    encodedMessage += tolower(message[j]);\n                j++;\n          \
    \  }\n        }\n        if (islower(message[i])) {\n            int j = i + 1;\n\
    \            while (j < message.length() && islower(message[j])) {\n         \
    \       encodedMessage += toupper(message[j]);\n                j++;\n       \
    \     }\n        }\n    }\n    for (int i = 0; i < message.length(); i++) {\n\
    \        if (islower(message[i])) {\n            int j = i + 1;\n            while\
    \ (j < message.length() && islower(message[j])) {\n                encodedMessage\
    \ += toupper(message[j]);\n                j++;\n            }\n        }\n  \
    \      if (isupper(message[i])) {\n            int j = i + 1;\n            while\
    \ (j < message.length() && isupper(message[j])) {\n                encodedMessage\
    \ += tolower(message[j]);\n                j++;\n            }\n        }\n  \
    \  }\n    return encodedMessage;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp81t5jq3l: /tmp/tmp81t5jq3l.cpp:82: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n     // Step\
    \ 1: Loop through message string and replace all letters with \n     // their\
    \ counterpart in the english alphabet \n     std::string result(message.size(),\
    \ '\\0'); \n     for (int i = 0; i <message.length(); i++){\n          int index\
    \ = message[i]-'a'; \n          result[i] = 'A'+ index;\n     } \n     // Step\
    \ 2: Loop through the result string and replace vowels in the \n     // message\
    \ with the letter that appears 2 places ahead of that vowel \n     // \n     std::string\
    \ vowels = \"AEIOU\"; \n     for (int i = 0; i < result.length(); i++){\n    \
    \      if (vowels.find(result[i]) != std::string::npos){\n               result[i]\
    \ = vowels.find(result[i])-2;\n          }\n     }\n     return result; \n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpuus886co: /tmp/tmpuus886co.cpp:34: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  std::unordered_map<char,char>\
    \ map;\n  for(auto it=message.cbegin(); it!=message.cend(); ++it) {\n    map[*it]\
    \ = *it;\n  }\n  for(auto it=message.cbegin(); it!=message.cend(); ++it) {\n \
    \   if(map.count(*it) == 1) {\n      map[*it] = map[map[*it] - 'a' + 'A'];\n \
    \   }\n  }\n  std::string encoded;\n  for(auto it=message.cbegin(); it!=message.cend();\
    \ ++it) {\n    encoded.append(map[*it]);\n  }\n  return encoded;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmprti1hvl5.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmprti1hvl5.cpp:25:28: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(std::unordered_map<char, char>::mapped_type&)\u2019\
    \n   25 |     encoded.append(map[*it]);\n      |                            ^\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmprti1hvl5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmprti1hvl5.cpp:25:28:\
    \ error: invalid conversion from \u2018std::unordered_map<char, char>::mapped_type\u2019\
    \ {aka \u2018char\u2019} to \u2018const char*\u2019 [-fpermissive]\n   25 |  \
    \   encoded.append(map[*it]);\n      |                            ^\n      | \
    \                           |\n      |                            std::unordered_map<char,\
    \ char>::mapped_type {aka char}\nIn file in"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  assert(message.length()\
    \ <= 21);\n  \n  std::string encoded = message;\n  for (auto &character : message)\
    \ {\n    // Swap case\n    character.swap(tolower(character));\n  }\n  for (auto\
    \ &character : message) {\n    // Replace vowels\n    if (character == 'a' ||\
    \ character == 'e' || character == 'i' || \n        character == 'o' || character\
    \ == 'u' || character == 'A' || \n        character == 'E' || character == 'I'\
    \ || character == 'O' || \n        character == 'U') {\n      // Subtract 2 because\
    \ we want to start searching 2 places \n      // ahead of the vowel\n      character\
    \ += message.substr(2, 1);\n    }\n  }\n  \n  return encoded;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpr20xc4s5.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpr20xc4s5.cpp:19:15: error: request for member \u2018swap\u2019 in \u2018\
    character\u2019, which is of non-class type \u2018char\u2019\n   19 |     character.swap(tolower(character));\n\
    \      |               ^~~~\n/tmp/tmpr20xc4s5.cpp:29:17: error: no match for \u2018\
    operator+=\u2019 (operand types are \u2018char\u2019 and \u2018std::__cxx11::basic_string<char>\u2019\
    )\n   29 |       character += message.substr(2, 1);\n      |       ~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for(int i = 0; i < ans.size(); i++) {\n        ans[i] =\
    \ tolower(ans[i]);\n    }\n    for(int i = 0; i < ans.size(); i++) {\n       \
    \ if(ans[i] == 'a' || ans[i] == 'e' || ans[i] == 'i' || ans[i] == 'o' || ans[i]\
    \ == 'u') {\n            char temp = ans[i];\n            ans[i] = ans[++i];\n\
    \            ans[i] = temp;\n        }\n    }\n    for(int i = 0; i < ans.size();\
    \ i++) {\n        char temp = ans[i];\n        int index = find(message.begin(),\
    \ message.end(), temp);\n        ans[i] = message[index + 2];\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp58goc42p.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp58goc42p.cpp:27:25: error: cannot convert \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018int\u2019 in initialization\n\
    \   27 |         int index = find(message.begin(), message.end(), temp);\n   \
    \   |                     ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n      |\
    \                         |\n      |                         __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    int j;\n    int n = message.length();\n    for(j = 0; j < n; j++)\
    \ {\n        char c = message[j];\n        if( c >= 'A' && c <= 'Z') {\n     \
    \       char c1 = c;\n            int n = c - 'A' + 1;\n            for(int i\
    \ = 2; i <= n; i++) {\n                c1 += (char) ('A' + (i - 2));\n       \
    \     }\n            ans += c1;\n        }\n        if( c >= 'a' && c <= 'z')\
    \ {\n            char c1 = c;\n            int n = c - 'a' + 1;\n            for(int\
    \ i = 2; i <= n; i++) {\n                c1 += (char) ('a' + (i - 2));\n     \
    \       }\n            ans += c1;\n        }\n        if( c >= '0' && c <= '9')\
    \ {\n            char c1 = c;\n            int n = c - '0' + 1;\n            for(int\
    \ i = 3; i <= n; i++) {\n                c1 += (char) ('0' + (i - 3));\n     \
    \       }\n            ans += c1;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpybqe9dkb: /tmp/tmpybqe9dkb.cpp:48: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> vow;\n    vow['a'] = 'A';\n    vow['e'] = 'E';\n    vow['i'] = 'I';\n\
    \    vow['o'] = 'O';\n    vow['u'] = 'U';\n    vow['y'] = 'Y';\n    vow['A'] =\
    \ 'a';\n    vow['E'] = 'e';\n    vow['I'] = 'i';\n    vow['O'] = 'o';\n    vow['U']\
    \ = 'u';\n    vow['Y'] = 'y';\n\n    std::string res = \"\";\n    for (int i =\
    \ 0; i < message.length(); i++) {\n        char ch = message[i];\n        char\
    \ next = message[i + 1];\n        res += vow[ch];\n        if (vow.count(next))\
    \ {\n            res += vow[next];\n        } else {\n            res += next;\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpifafy1n9: /tmp/tmpifafy1n9.cpp:43: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ res(message.size(), '0');\n    for(int i = 0; i < message.size(); i++) {\n \
    \       res[i] = toupper(message[i]);\n    }\n    for(int i = 0; i < res.length();\
    \ i++) {\n        for(int j = 0; j < res.length(); j++) {\n            if(res[i]\
    \ == res[j]) {\n                res[i] = toupper(res[j]);\n                res[j]\
    \ = toupper(res[i]) + toupper(res[j+1]);\n                res[i+1] = ' ';\n  \
    \          }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpxyru19i0: /tmp/tmpxyru19i0.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ s = message;\n    for (size_t i = 0; i < s.size(); i++) {\n        char c =\
    \ s[i];\n        if (c == ' ') {\n            s[i] = 'T';\n        } else if (c\
    \ >= 'a' && c <= 'z') {\n            s[i] = c + 'a' - 'a';\n        } else if\
    \ (c >= 'A' && c <= 'Z') {\n            s[i] = c + 'A' - 'A';\n        } else\
    \ if (c >= '0' && c <= '9') {\n            s[i] = c;\n        } else {\n     \
    \       s[i] = 'T';\n        }\n    }\n    return s;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpbegn3p_1: /tmp/tmpbegn3p_1.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ str = \"\";\n    // Write your code here\n    for (int i = 0; i < message.size();\
    \ i++){\n        char a = message[i];\n        if(a == 'a'){\n            str+=message[i-1];\n\
    \        }\n        else if(a == 'e'){\n            str+=message[i-2];\n     \
    \   }\n        else if(a == 'i'){\n            str+=message[i-3];\n        }\n\
    \        else if(a == 'o'){\n            str+=message[i-4];\n        }\n     \
    \   else if(a == 'u'){\n            str+=message[i-5];\n        }\n        else\
    \ if(a == 'y'){\n            str+=message[i-6];\n        }\n        else if(a\
    \ == 'y'){\n            str+=message[i-7];\n        }\n        else if(a == 'a'){\n\
    \            str+=message[i-8];\n        }\n        else if(a == 'a'){\n     \
    \       str+=message[i-9];\n        }\n    }\n    return str;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwk97kogb: /tmp/tmpwk97kogb.cpp:50: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n\tstd::stack<char>\
    \ st;\n\tstd::string ans;\n\tint i, j, k;\n\tfor(i=0; i<message.length(); i++)\
    \ {\n\t\tif(message[i] >= 'a' && message[i] <= 'z')\n\t\t\tst.push(message[i]);\n\
    \t\telse if(message[i] >= 'A' && message[i] <= 'Z')\n\t\t\tst.push(message[i]);\n\
    \t\telse if(message[i] == 'o' || message[i] == 'O')\n\t\t\tst.push('O');\n\t\t\
    else if(message[i] == 'u' || message[i] == 'U')\n\t\t\tst.push('U');\n\t\telse\
    \ if(message[i] == 'e' || message[i] == 'E')\n\t\t\tst.push('E');\n\t\telse if(message[i]\
    \ == 'i' || message[i] == 'I')\n\t\t\tst.push('I');\n\t\telse if(message[i] ==\
    \ 'r' || message[i] == 'R')\n\t\t\tst.push('R');\n\t\telse if(message[i] == 't'\
    \ || message[i] == 'T')\n\t\t\tst.push('T');\n\t\telse if(message[i] == 'd' ||\
    \ message[i] == 'D')\n\t\t\tst.push('D');\n\t\telse if(message[i] == 'l' || message[i]\
    \ == 'L')\n\t\t\tst.push('L');\n\t\telse if(message[i] == 'r' || message[i] ==\
    \ 'R')\n\t\t\tst.push('R');\n\t\telse if(message[i] == 'p' || message[i] == 'P')\n\
    \t\t\tst.push('P');\n\t\telse if(message[i] == 'e' || message[i] == 'E')\n\t\t\
    \tst.push('E');\n\t\telse if(message[i] == 'w' || message[i] == 'W')\n\t\t\tst.push('W');\n\
    \t\telse if(message[i] == 's' || message[i] == 'S')\n\t\t\tst.push('S');\n\t\t\
    else if(message[i] == 'c' || message[i] == 'C')\n\t\t\tst.push('C');\n\t\telse\
    \ if(message[i] == 'g' || message[i] == 'G')\n\t\t\tst.push('G');\n\t\telse if(message[i]\
    \ == 'f' || message[i] == 'F')\n\t\t\tst.push('F');\n\t\telse if(message[i] ==\
    \ 'a' || message[i] == 'A')\n\t\t\tst.push('A');\n\t\telse if(message[i] == 'u'\
    \ || message[i] == 'U')\n\t\t\tst.push('U');\n\t\telse if(message[i] == 'b' ||\
    \ message[i] == 'B')\n\t\t\tst.push('B');\n\t\telse if(message[i] == 'm' || message[i]\
    \ == 'M')\n\t\t\tst.push('M');\n\t\telse if(message[i] == 'p' || message[i] ==\
    \ 'P')\n\t\t\tst.push('P');\n\t\telse if(message[i] == 'h' || message[i] == 'H')\n\
    \t\t\tst.push('H');\n\t\telse if(message[i] == 'v' || message[i] == 'V')\n\t\t\
    \tst.push('V');\n\t\telse if(message[i] == 'w' || \n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpl2xx3h8h.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpl2xx3h8h.cpp:69:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   69 | }\n      | ^\n/tmp/tmpl2xx3h8h.cpp:68:31: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   68 |   else if(message[i] == 'w'\
    \ ||\n      |          ~                    ^\n      |                       \
    \        )\n   69 | }\n      | ~                              \n/tmp/tmpl2xx3h8h.cpp:69:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   69 | }\n \
    \     | ^\n/tmp/tmpl2xx3h8h.cpp:70:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   70 | int main() {\n      |            ^\n\
    /tmp/tmpl2xx3h8h.cpp:77:1: error: expected \u2018}\u2019 at end of input\n   77\
    \ | }\n      | ^\n/tmp/tmpl2xx3h8h.cpp:13:41: note: to match this \u2018{\u2019\
    \n   13 | std::string encode(std::string message) {\n      |                 \
    \                        ^\n/tmp/tmpl2xx3h8h.cpp:77:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n   77 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,int>\
    \ vowel_map;\n    vowel_map['a'] = 1;\n    vowel_map['e'] = 1;\n    vowel_map['i']\
    \ = 1;\n    vowel_map['o'] = 1;\n    vowel_map['u'] = 1;\n    std::map<char,int>\
    \ vowel_map_rev;\n    vowel_map_rev[1] = 'a';\n    vowel_map_rev[2] = 'e';\n \
    \   vowel_map_rev[3] = 'i';\n    vowel_map_rev[4] = 'o';\n    vowel_map_rev[5]\
    \ = 'u';\n    std::map<char,int> letter_map;\n    letter_map['a'] = 0;\n    letter_map['b']\
    \ = 1;\n    letter_map['c'] = 2;\n    letter_map['d'] = 3;\n    letter_map['e']\
    \ = 4;\n    letter_map['f'] = 5;\n    letter_map['g'] = 6;\n    letter_map['h']\
    \ = 7;\n    letter_map['i'] = 8;\n    letter_map['j'] = 9;\n    letter_map['k']\
    \ = 10;\n    letter_map['l'] = 11;\n    letter_map['m'] = 12;\n    letter_map['n']\
    \ = 13;\n    letter_map['o'] = 14;\n    letter_map['p'] = 15;\n    letter_map['q']\
    \ = 16;\n    letter_map['r'] = 17;\n    letter_map['s'] = 18;\n    letter_map['t']\
    \ = 19;\n    letter_map['u'] = 20;\n    letter_map['v'] = 21;\n    letter_map['w']\
    \ = 22;\n    letter_map['x'] = 23;\n    letter_map['y'] = 24;\n    letter_map['z']\
    \ = 25;\n    for(char &x: message)\n    {\n        x = tolower(x);\n    }\n  \
    \  std::map<char,int> reverse_letter_map;\n    for(auto &x: reverse_letter_map)\n\
    \    {\n        x = letter_map.at(x);\n    }\n    std::string result = \"0\";\n\
    \    std::string temp_result;\n    bool flag = false;\n    for (auto &x: message)\
    \ {\n        int y = reverse_letter_map.at(x);\n        if (y == 0) {\n      \
    \      flag = true;\n            break;\n        } else {\n            if(flag)\n\
    \            {\n                result += y;\n                flag = false;\n\
    \            }\n            else\n            {\n                result += y;\n\
    \            }\n        }\n    }\n    std::swap(result, temp_result);\n    for(auto\
    \ &x: temp_result)\n    {\n        result += x;\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpy02ibkh_.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpy02ibkh_.cpp:60:28: error: no matching function for call to \u2018\
    std::map<char, int>::at(std::pair<const char, int>&)\u2019\n   60 |         x\
    \ = letter_map.at(x);\n      |                            ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/map:61,\n         \
    \        from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpy02ibkh_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:535:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::at(const key_type&) [with _Key = char; _Tp = int; _Compare\
    \ = std::less<char>; _Alloc = std::allocator<std::pair<const char, int> >; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key, _Tp, _Compare, _Alloc>::key_type\
    \ = char]\u2019\n  535 |       at(const key_type& __k)\n      |       ^~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:535:26:\
    \ note:   no known conversion for argument 1 from \u2018std::pair<const char,\
    \ int>\u2019 to \u2018const key_type&\u2019 {aka \u2018const char&\u2019}\n  535\
    \ |       at(const key_type& __k)\n      |          ~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:544:7:\
    \ note: candidate: \u2018const mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::at(const\
    \ key_type&) const [with _Key = char; _Tp = int; _Compare = std::less<char>; _Alloc\
    \ = std::allocator<std::pair<const char, int> >; std::map<_Key, _Tp, _Compare,\
    \ _Alloc>::mapped_type = int; std::map<_Key, _Tp, _Compare, _Alloc>::key_type\
    \ = char]\u2019\n  544 |       at(const key_type& __k) const\n      |       ^~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:544:26: note:\
    \   no known conversion for argument 1 from \u2018std::pair<const char, int>\u2019\
    \ to \u2018const key_type&\u2019 {aka \u2018const char&\u2019}\n  544 |      \
    \ at(const key_type& __k) const\n      |          ~~~~~~~~~~~~~~~~^~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result = '';\n    for(int i=0; i < message.length(); ++i) {\n        char c\
    \ = message[i];\n        result += toupper(c);\n        result += ' ';\n    }\n\
    \    int prevVowel = -1, currVowel = -1, prevLetter = -1, currLetter = -1;\n \
    \   for(int i=0; i < message.length(); ++i) {\n        char c = message[i];\n\
    \        if(c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') \n     \
    \       currLetter = i;\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') \n            currLetter = i;\n        if(c == ' ') {\n       \
    \     result += message[prevLetter] + ' ';\n            result += message[currLetter];\n\
    \            prevLetter = -1;\n            currLetter = -1;\n        } else\n\
    \            if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \                prevVowel = i - 2;\n                currVowel = i;\n        \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmppamd0965.cpp:14:26: error: empty character constant\n   14 |  \
    \   std::string result = '';\n      |                          ^~\n/tmp/tmppamd0965.cpp:\
    \ In function \u2018std::string encode(std::string)\u2019:\n/tmp/tmppamd0965.cpp:14:26:\
    \ error: conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n     \n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpy07v4vjp: /tmp/tmpy07v4vjp.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,int>\
    \ table;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['a'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['a'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['b'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['b'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['c'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['c'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['d'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['d'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['e'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['e'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['f'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['f'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['g'] = i;\n        // 'A' maps to 0, 'B' maps\
    \ to 1, ... 'Z' maps to 25. \n    for (int i=26; i<61; i++)\n        table['g'+i]\
    \ = i-1;\n    // 'a' maps to 0, 'b' maps to 1, ... 'z' maps to 25. \n    for (int\
    \ i=0; i<26; i++)\n        table['h'] = i;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpfdf21li8: /tmp/tmpfdf21li8.cpp:63: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Start\
    \ with an initialized string.\n    std::string result;\n    // Iterate through\
    \ each character.\n    for (char c: message) \n        // Append if case is different.\n\
    \        if (toupper(c) != c)\n            result.push_back(c);\n        else\
    \ \n            // Otherwise, append if letter appears 2 places ahead.\n     \
    \       result.push_back((c - 'A' + 1) % 26 + 'A');\n    return result;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp_wxb2hij: /tmp/tmp_wxb2hij.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for (std::string::size_type i = 0; i < message.length(); i++){\n \
    \       std::swap(message[i], message[i-(int)message.length()]);\n        char\
    \ firstVowel = message[i];\n        std::swap(message[i], message[i-(message.length()-2)]);\n\
    \        char secondVowel = message[i];\n        std::string currentChar = message[i];\n\
    \        char firstLetter = currentChar[0];\n        char secondLetter = currentChar[1];\n\
    \        if (firstVowel == 'a' || firstVowel == 'e' || firstVowel == 'i' || firstVowel\
    \ == 'o' || firstVowel == 'u'){\n            firstLetter = 'A';\n        }\n \
    \       if (secondVowel == 'a' || secondVowel == 'e' || secondVowel == 'i' ||\
    \ secondVowel == 'o' || secondVowel == 'u'){\n            secondLetter = 'A';\n\
    \        }\n        ans += firstLetter + secondLetter + currentChar;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2uwkkgrp.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp2uwkkgrp.cpp:20:44: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   20 |      \
    \   std::string currentChar = message[i];\n      |                           \
    \                 ^\n/tmp/tmp2uwkkgrp.cpp:29:43: error: no match for \u2018operator+\u2019\
    \ (operand types are \u2018int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   29 |         ans += firstLetter + secondLetter + currentChar;\n      |\
    \                ~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~\n      |           \
    \                 |                |\n      |                            int \
    \             std::string {aka std::__cxx11::basic_string<char>}\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp2uwkkgrp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ messageOut = message;\n    for (int i = 0; i < message.length(); i++) {\n  \
    \      if (message[i] >= 'A' && message[i] <= 'Z') {\n            int index =\
    \ message[i] - 'A';\n            if (index < 2)\n                continue;\n \
    \           else\n                index = index - 2;\n            if (index >=\
    \ 0 && index < 26)\n                messageOut[i] = 'A' + index;\n        }\n\
    \        else if (message[i] >= 'a' && message[i] <= 'z') {\n            int index\
    \ = message[i] - 'a';\n            if (index < 2)\n                continue;\n\
    \            else\n                index = index - 2;\n            if (index >=\
    \ 0 && index < 26)\n                messageOut[i] = 'a' + index;\n        }\n\
    \        else\n            messageOut[i] = message[i];\n    }\n    for (int i\
    \ = 0; i < messageOut.length(); i++) {\n        if (messageOut[i] >= 'A' && messageOut[i]\
    \ <= 'Z') {\n            int index = messageOut[i] - 'A';\n            if (index\
    \ < 2)\n                continue;\n            else\n                index = index\
    \ - 2;\n            if (index >= 0 && index < 26)\n                messageOut[i]\
    \ = 'A' + index;\n        }\n        else if (messageOut[i] >= 'a' && messageOut[i]\
    \ <= 'z') {\n            int index = messageOut[i] - 'a';\n            if (index\
    \ < 2)\n                continue;\n            else\n                index = index\
    \ - 2;\n            if (index >= 0 && index < 26)\n                messageOut[i]\
    \ = 'a' + index;\n        }\n    }\n    return messageOut;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpjmzrl1px: /tmp/tmpjmzrl1px.cpp:61: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    string\
    \ temp = \"\";\n    for (int i = 0; i < message.size(); i++){\n        if (message[i]\
    \ == message[i + 1])\n            continue;\n        temp += message[i];\n   \
    \ }\n    \n    string s = \"\";\n    int k = 0;\n    for (int i = 0; i < temp.length();\
    \ i++) {\n        s += tolower(temp[i]);\n    }\n    \n    for (int i = 0; i <\
    \ s.length(); i++) {\n        int x = toupper(s[i]);\n        \n        if (k\
    \ == 0) {\n            s += \"E\";\n            k = 1;\n        } else if (k ==\
    \ 1) {\n            s += \"A\";\n            k = 2;\n        } else if (k == 2)\
    \ {\n            s += \"O\";\n            k = 3;\n        } else if (k == 3) {\n\
    \            s += \"I\";\n            k = 4;\n        } else if (k == 4) {\n \
    \           s += \"L\";\n            k = 5;\n        } else if (k == 5) {\n  \
    \          s += \"U\";\n            k = 6;\n        } else if (k == 6) {\n   \
    \         s += \"C\";\n            k = 7;\n        } else if (k == 7) {\n    \
    \        s += \"G\";\n            k = 8;\n        } else if (k == 8) {\n     \
    \       s += \"M\";\n            k = 9;\n        } else if (k == 9) {\n      \
    \      s += \"S\";\n            k = 10;\n        } else if (k == 10) {\n     \
    \       s += \"K\";\n            k = 11;\n        } else if (k == 11) {\n    \
    \        s += \"D\";\n            k = 12;\n        } else if (k == 12) {\n   \
    \         s += \"P\";\n            k = 13;\n        } else if (k == 13) {\n  \
    \          s += \"E\";\n            k = 14;\n        } else if (k == 14) {\n \
    \           s += \"T\";\n            k = 15;\n        } else if (k == 15) {\n\
    \            s += \"H\";\n            k = 16;\n        } else if (k == 16) {\n\
    \            s += \"W\";\n            k = 17;\n        } else if (k == 17) {\n\
    \            s += \"P\";\n            k = 18;\n        } else if (k == 18) {\n\
    \            s += \"R\";\n            k = 19;\n        } else if (k == 19) {\n\
    \            s += \"F\";\n            k = 20;\n        } else if (k == 20) {\n\
    \            s += \"Y\";\n            k = 21;\n        } else if (k == 21) {\n\
    \            s += \"S\";\n            k = 22;\n        } else if (k == 22) {\n\
    \            s += \"X\";\n            k = 23;\n        } else if (k == 23) {\n\
    \            s += \"J\";\n            k = 24;\n        } else if (k == 24) {\n\
    \            s += \"W\";\n            k = 25;\n        } else if (k == 25) {\n\
    \            s += \"K\";\n            k = 26;\n        } else if (k == 26) {\n\
    \            s += \"T\";\n            k = 27;\n        } else if (k == 27) {\n\
    \            s += \"X\";\n            k = 28;\n        } else if (k == 28) {\n\
    \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp26q1wx1f.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp26q1wx1f.cpp:15:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   15 |     string temp = \"\"\
    ;\n      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp26q1wx1f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp26q1wx1f.cpp:19:9:\
    \ error: \u2018temp\u2019 was not declared in this scope\n   19 |         temp\
    \ += message[i];\n      |         ^~~~\n/tmp/tmp26q1wx1f.cpp:22:11: error: expected\
    \ \u2018;\u2019 before \u2018s\u2019\n   22 |     string s = \"\";\n      |  \
    \         ^~\n      |           ;\n/tmp/tmp26q1wx1f.cpp:24:25: error: \u2018temp\u2019\
    \ was not declared in this scope\n   24 |     for (int i = 0; i < temp.length();\
    \ i++) {\n      |                         ^~~~\n/tmp/tmp26q1wx1f.cpp:25:9: error:\
    \ \u2018s\u2019 was not declared in this scope\n   25 |         s += tolower(temp[i]);\n\
    \      |         ^\n/tmp/tmp26q1wx1f.cpp:28:25: error: \u2018s\u2019 was not declared\
    \ in this scope\n   28 |     for (int i = 0; i < s.length(); i++) {\n      | \
    \                        ^\n/tmp/tmp26q1wx1f.cpp:118:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  118 | int main() {\n     \
    \ |            ^\n/tmp/tmp26q1wx1f.cpp:125:1: error: expected \u2018}\u2019 at\
    \ end of input\n  125 | }\n      | ^\n/tmp/t"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ res;\n    int cnt = 0;\n    for(int i = 0; i < message.length(); i++) {\n  \
    \      char c = message[i];\n        if((c >= 'a' && c <= 'z') || (c >= 'A' &&\
    \ c <= 'Z')) {\n            char d = (char) tolower(c);\n            int n = (c\
    \ - 'a');\n            int k = i - 2;\n            char t1 = std::tolower(message[k-1]);\n\
    \            char t2 = std::tolower(message[k+1]);\n            for(int j = 0;\
    \ j < (int) 26; j++) {\n                if(t1 == std::tolower(j)) {\n        \
    \            n -= 1;\n                } else if(t2 == std::tolower(j)) {\n   \
    \                 n -= 2;\n                }\n            }\n            if(n\
    \ >= 1) {\n                char temp = message[i];\n                message[i]\
    \ = d;\n                res[cnt++] = temp;\n            }\n        }\n    }\n\
    \    return res;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpbspy_icq: /tmp/tmpbspy_icq.cpp:42: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Return\
    \ the string after swapping vowels in it with another letter.\n    std::string\
    \ new_message;\n    for (char letter : message) {\n        if (letter == 'a' ||\
    \ letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' || letter ==\
    \ 'A' || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U') {\n\
    \            new_message += letter;\n        } else {\n            new_message\
    \ += std::string(message.size() - std::distance(message.begin(), std::find(message.begin(),\
    \ message.end(), letter)) + 1, letter);\n        }\n    }\n    return new_message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpkpncndme: /tmp/tmpkpncndme.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n// Write your\
    \ code here\n// return message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpx7l5q2tb: /tmp/tmpx7l5q2tb.cpp:19: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ res;\n    res.reserve(message.length());\n    for (std::size_t i = 0; i < message.length();\
    \ i++) {\n        char c = message[i];\n        if (c >= 'A' && c <= 'Z') {\n\
    \            res += c;\n        } else if (c == 'a' || c == 'A') {\n         \
    \   res += 'A';\n        } else if (c == 'e' || c == 'E') {\n            res +=\
    \ 'E';\n        } else if (c == 'i' || c == 'I') {\n            res += 'I';\n\
    \        } else if (c == 'o' || c == 'O') {\n            res += 'O';\n       \
    \ } else if (c == 'u' || c == 'U') {\n            res += 'U';\n        } else\
    \ if (c == 'y' || c == 'Y') {\n            res += 'Y';\n        } else {\n   \
    \         res += 'X';\n        }\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpiy1vuxgq: /tmp/tmpiy1vuxgq.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  string result=\"\
    \";\n  for(int i=0; i<message.length(); i++)\n  {\n    char c=message[i];\n  \
    \  if(isalpha(c))\n    {\n      c=tolower(c);\n      if(tolower(c)=='a')\n   \
    \     result+=c;\n      else\n        result+=c;\n    }\n    else\n    {\n   \
    \   char t=' ';\n      for(int j=i; j<message.length(); j++)\n      {\n      \
    \  char c2=message[j];\n        if(isalpha(c2))\n        {\n          c2=tolower(c2);\n\
    \          if(tolower(c2)=='a')\n            t=c2;\n          else\n         \
    \   t=' ';\n        }\n        else\n          t=' ';\n      }\n      result+=t;\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqxs6s2qa.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqxs6s2qa.cpp:14:3: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |   string result=\"\";\n\
    \      |   ^~~~~~\n      |   std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpqxs6s2qa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpqxs6s2qa.cpp:22:9:\
    \ error: \u2018result\u2019 was not declared in this scope\n   22 |         result+=c;\n\
    \      |         ^~~~~~\n/tmp/tmpqxs6s2qa.cpp:24:9: error: \u2018result\u2019\
    \ was not declared in this scope\n   24 |         result+=c;\n      |        \
    \ ^~~~~~\n/tmp/tmpqxs6s2qa.cpp:43:7: error: \u2018result\u2019 was not declared\
    \ in this scope\n   43 |       result+=t;\n      |       ^~~~~~\n/tmp/tmpqxs6s2qa.cpp:46:10:\
    \ error: \u2018result\u2019 was not declared in this scope\n   46 |   return result;\n\
    \      |          ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result;\n    for(int i = 0; i<message.length(); i++) {\n        char c = message[i];\n\
    \        if('A' <= c && c <= 'Z') {\n            c = tolower(c);\n           \
    \ result += c;\n        }\n        else if('a' <= c && c <= 'z') {\n         \
    \   c = tolower(c);\n            result += c;\n        }\n        else if('0'\
    \ <= c && c <= '9') {\n            if(i+1 < message.length() && message[i+1] ==\
    \ '9') {\n                c = (c + message[i] + message[i+1]) % ('Z' - 'A' + 1);\n\
    \                result.append(c);\n            }\n            else {\n      \
    \          c = tolower(c);\n                result.append(c);\n            }\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp5hlv_eae.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp5hlv_eae.cpp:28:32: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(char&)\u2019\n   28 |               \
    \  result.append(c);\n      |                                ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5hlv_eae.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmp5hlv_eae.cpp:28:31:\
    \ error: invalid conversion from \u2018char\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   28 |                 result.append(c);\n      |                          \
    \     ^\n      |                               |\n      |                    \
    \           char\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int vowels[]\
    \ = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };\n    std::string alphabet[]\
    \ = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\
    \ 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };\n\n    std::string\
    \ ans = \"\";\n    int i;\n    for (i = 0; i < message.length(); i++) {\n    \
    \    char letter = message[i];\n        if (std::find(vowels, vowels + 6, letter)\
    \ != vowels + 6) {\n            ans += alphabet[std::find(vowels, vowels + 6,\
    \ letter) - vowels];\n        } else {\n            ans += letter;\n        }\n\
    \    }\n\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n   \
    \ assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpacq3a9n_.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpacq3a9n_.cpp:15:32: error: conversion from \u2018char\u2019 to non-scalar\
    \ type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } requested\n   15 |     std::string alphabet[] = { 'A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z' };\n      |                                ^~~\n/tmp/tmpacq3a9n_.cpp:15:37:\
    \ error: conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   15 |     std::string\
    \ alphabet[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };\n      |\
    \                                     ^~~\n/tmp/tmpacq3a9n_.cpp:15:42: error:\
    \ conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   15 |     std::string\
    \ alphabet[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };\n      |\
    \                                          ^~~\n/tmp/tmpacq3a9n_.cpp:15:47: error:\
    \ conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   15 |     std::string\
    \ alphabet[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };\n      |\
    \                                               ^~~\n/tmp/tmpacq3a9n_.cpp:15:52:\
    \ error: conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   15 |     std::string\
    \ alphabet[] = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };\n      |\
    \                                                    ^~~\n/tmp/tmpacq3a9n_.cpp:15:57:\
    \ error: conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   15 |"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // TODO\n\
    \    std::string encoded = message;\n    return encoded;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpnkcj9_18: /tmp/tmpnkcj9_18.cpp:20: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    for (int i=0; i<message.length(); i++) {\n        if (message[i]=='A'||message[i]=='E'||message[i]=='I'||message[i]=='O'||message[i]=='U')\n\
    \            encoded[i]=message[i]+'a';\n        else if (message[i]=='C'||message[i]=='G'||message[i]=='M'||message[i]=='S'||message[i]=='T')\n\
    \            encoded[i]=message[i]+'c';\n        else if (message[i]=='B'||message[i]=='F'||message[i]=='P'||message[i]=='V'||message[i]=='X')\n\
    \            encoded[i]=message[i]+'b';\n        else if (message[i]=='D'||message[i]=='H'||message[i]=='R'||message[i]=='W'||message[i]=='Y')\n\
    \            encoded[i]=message[i]+'d';\n        else\n            encoded[i]=message[i];\n\
    \    }\n    return encoded;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpkkaz7zc4: /tmp/tmpkkaz7zc4.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  std::stack<bool>\
    \ stack;\n  for (char &c : message) {\n    stack.push(c == ' ');\n    if (stack.top())\
    \ {\n      c = tolower(c);\n    }\n  }\n  while (!stack.empty()) {\n    char &c\
    \ = stack.top();\n    char prev = c[tolower(c) - 'a'];\n    if (c == 'a') {\n\
    \      c = 'e';\n    } else if (c == 'e') {\n      c = 'i';\n    } else if (c\
    \ == 'i') {\n      c = 'o';\n    } else if (c == 'o') {\n      c = 'u';\n    }\
    \ else if (c == 'u') {\n      c = 'a';\n    } else if (c == 'y') {\n      c =\
    \ 'o';\n    } else if (c == 'g') {\n      c = 'o';\n    } else if (c == 'f') {\n\
    \      c = 'u';\n    } else if (c == 'h') {\n      c = 'u';\n    } else if (c\
    \ == 'j') {\n      c = 'u';\n    } else if (c == 'k') {\n      c = 'u';\n    }\
    \ else if (c == 'l') {\n      c = 'u';\n    } else if (c == 's') {\n      c =\
    \ 'u';\n    } else if (c == 't') {\n      c = 'u';\n    } else if (c == 'c') {\n\
    \      c = 'u';\n    } else if (c == 'm') {\n      c = 'u';\n    }\n    stack.push(stack.top()\
    \ && c == prev);\n  }\n  return message;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7xlieuxv.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp7xlieuxv.cpp:22:24: error: cannot bind non-const lvalue reference of\
    \ type \u2018char&\u2019 to an rvalue of type \u2018char\u2019\n   22 |     char\
    \ &c = stack.top();\n      |               ~~~~~~~~~^~\n/tmp/tmp7xlieuxv.cpp:23:35:\
    \ error: invalid types \u2018char[int]\u2019 for array subscript\n   23 |    \
    \ char prev = c[tolower(c) - 'a'];\n      |                                  \
    \ ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    for(int\
    \ i = 0; i<message.size(); ++i)\n    {\n        // swap all letters \n       \
    \ if(message[i]=='a' || message[i]=='e' || message[i]=='i' || message[i]=='o'\
    \ || message[i]=='u')\n        {\n            message[i] = message[i-2];\n   \
    \     }\n\n        // replace all vowels with the letter that appears 2 places\
    \ \n        // ahead of that vowel\n        if(message[i]=='a' || message[i]=='e'\
    \ || message[i]=='i' || message[i]=='o' || message[i]=='u')\n        {\n     \
    \       std::string temp(message.begin()+i, message.end());\n            std::string\
    \ temp2(message.begin()+i+1, message.end()-1);\n            int count = 1;\n \
    \           for(int j=i+1; j<message.size(); ++j)\n            {\n           \
    \     if(message[j]=='a' || message[j]=='e' || message[j]=='i' || message[j]=='o'\
    \ || message[j]=='u')\n                {\n                    if(count==2)\n \
    \                   {\n                        temp2 += message[j];\n        \
    \                count = 1;\n                    }\n                    else\n\
    \                    {\n                        temp += message[j];\n        \
    \                count++;\n                    }\n                }\n        \
    \        else if(message[j]=='A' || message[j]=='E' || message[j]=='I' || message[j]=='O'\
    \ || message[j]=='U')\n                {\n                    if(count==2)\n \
    \                   {\n                        temp2 += message[j];\n        \
    \                count = 1;\n                    }\n                    else\n\
    \                    {\n                        temp += message[j];\n        \
    \                count++;\n                    }\n                }\n        \
    \    }\n            message = temp;\n            message = temp2;\n        }\n\
    \n    }\n    return message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp_t31k9yw: /tmp/tmp_t31k9yw.cpp:68: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ reconstructedMessage;\n    int counter = 0;\n    for (int i = 0; i < message.length();\
    \ i++) {\n        counter = 0;\n        if (message[i] == 'a') {\n           \
    \ reconstructedMessage.append(1, 'A');\n            counter = 1;\n        } else\
    \ if (message[i] == 'b') {\n            reconstructedMessage.append(1, 'B');\n\
    \            counter = 1;\n        } else if (message[i] == 'c') {\n         \
    \   reconstructedMessage.append(1, 'C');\n            counter = 1;\n        }\
    \ else if (message[i] == 'd') {\n            reconstructedMessage.append(1, 'D');\n\
    \            counter = 1;\n        } else if (message[i] == 'e') {\n         \
    \   reconstructedMessage.append(1, 'E');\n            counter = 1;\n        }\
    \ else if (message[i] == 'f') {\n            reconstructedMessage.append(1, 'F');\n\
    \            counter = 1;\n        } else if (message[i] == 'g') {\n         \
    \   reconstructedMessage.append(1, 'G');\n            counter = 1;\n        }\
    \ else if (message[i] == 'h') {\n            reconstructedMessage.append(1, 'H');\n\
    \            counter = 1;\n        } else if (message[i] == 'i') {\n         \
    \   reconstructedMessage.append(1, 'I');\n            counter = 1;\n        }\
    \ else if (message[i] == 'j') {\n            reconstructedMessage.append(1, 'J');\n\
    \            counter = 1;\n        } else if (message[i] == 'k') {\n         \
    \   reconstructedMessage.append(1, 'K');\n            counter = 1;\n        }\
    \ else if (message[i] == 'l') {\n            reconstructedMessage.append(1, 'L');\n\
    \            counter = 1;\n        } else if (message[i] == 'm') {\n         \
    \   reconstructedMessage.append(1, 'M');\n            counter = 1;\n        }\
    \ else if (message[i] == 'n') {\n            reconstructedMessage.append(1, 'N');\n\
    \            counter = 1;\n        } else if (message[i] == 'o') {\n         \
    \   reconstructedMessage.append(1, 'O');\n            counter = 1;\n        }\
    \ else if (message[i] == 'p') {\n            reconstructedMessage.append(1, 'P');\n\
    \            counter = 1;\n        } else if (message[i] == 'q') {\n         \
    \   reconstructedMessage.append(1, 'Q');\n            counter = 1;\n        }\
    \ else if (message[i] == 'r') {\n            reconstructedMessage.append(1, 'R');\n\
    \            counter = 1;\n        } else if (message[i] == 's') {\n         \
    \   reconstructedMessage.append(1, 'S');\n            counter = 1;\n        }\
    \ else if (message[i] == 't') {\n            reconstructedMessage.append(1, 'T');\n\
    \            counter = 1;\n        } else if (message[i] == 'u') {\n         \
    \   reconstructedMessage.append(1, 'U');\n            counter = 1;\n        }\
    \ else if (message[i] == 'v') {\n            reconstructedMessage.append(1, 'V');\n\
    \            counter = 1;\n        } else if (message[i] == 'w') {\n         \
    \   reconstructedMessage.append(1, 'W');\n            counter = 1;\n        }\
    \ else if (message[i] == 'x') {\n            reconstructedMessage.append(1, 'X');\n\
    \            counter = 1;\n        } else if (message[i] == 'y') {\n         \
    \   reconstru\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0j4pzr5y.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0j4pzr5y.cpp:91:13: error: \u2018reconstru\u2019 was not declared in\
    \ this scope\n   91 |             reconstru\n      |             ^~~~~~~~~\n/tmp/tmp0j4pzr5y.cpp:93:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   93 | int main() {\n      |            ^\n/tmp/tmp0j4pzr5y.cpp:100:1: error:\
    \ expected \u2018}\u2019 at end of input\n  100 | }\n      | ^\n/tmp/tmp0j4pzr5y.cpp:16:48:\
    \ note: to match this \u2018{\u2019\n   16 |     for (int i = 0; i < message.length();\
    \ i++) {\n      |                                                ^\n/tmp/tmp0j4pzr5y.cpp:100:1:\
    \ error: expected \u2018}\u2019 at end of input\n  100 | }\n      | ^\n/tmp/tmp0j4pzr5y.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp0j4pzr5y.cpp:100:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  100 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  for (int\
    \ i = 0; i <= message.length(); i++) {\n    char first = message[i];\n    char\
    \ second = message[i - 1];\n    if (first >= 'a' && first <= 'z') {\n      first\
    \ = static_cast<char>(first - 'a');\n    }\n    if (second >= 'a' && second <=\
    \ 'z') {\n      second = static_cast<char>(second - 'a');\n    }\n    if (first\
    \ >= 'A' && first <= 'Z') {\n      first = static_cast<char>(first - 'A');\n \
    \   }\n    if (second >= 'A' && second <= 'Z') {\n      second = static_cast<char>(second\
    \ - 'A');\n    }\n    message += first;\n    message += second;\n  }\n  return\
    \ message;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int n = message.length();\n\
    \  std::string new_message = message;\n  for(int i=0; i<n; i++) {\n    char c\
    \ = message[i];\n    if ( isupper(c) )\n      new_message[i] = toupper(new_message[i]);\n\
    \    if ( islower(c) )\n      new_message[i] = tolower(new_message[i]);\n  }\n\
    \  for(int i=n-1; i>0; i--) {\n    char c = new_message[i];\n    int j = 0;\n\
    \    while( (j<i) && islower(new_message[j]) ) {\n      new_message[j] = tolower(new_message[j]);\n\
    \      j++;\n    }\n    j = 0;\n    while( (j<i) && isupper(new_message[j]) )\
    \ {\n      new_message[j] = toupper(new_message[j]);\n      j++;\n    }\n  }\n\
    \  for(int i=0; i<n; i++) {\n    char c = new_message[i];\n    if ( isupper(c)\
    \ )\n      new_message[i] = toupper(new_message[i]);\n  }\n  return new_message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1o8bga1l: /tmp/tmp1o8bga1l.cpp:45: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // code here\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmphnt6k4pu: /tmp/tmphnt6k4pu.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ answer;\n    for(int i=0; i<message.length(); i++) {\n        answer += (message[i]\
    \ == 'A') ? 'T' :\n            (message[i] == 'E') ? 'G' :\n            (message[i]\
    \ == 'I') ? 'K' :\n            (message[i] == 'O') ? 'O' :\n            (message[i]\
    \ == 'U') ? 'A' :\n            (message[i] == 'Y') ? 'I' :\n            (message[i]\
    \ == 'a') ? 't' :\n            (message[i] == 'e') ? 'g' :\n            (message[i]\
    \ == 'i') ? 'k' :\n            (message[i] == 'o') ? 'o' :\n            (message[i]\
    \ == 'u') ? 'a' :\n            (message[i] == 'y') ? 'i' :\n            (message[i]\
    \ == 'A') ? 'T' :\n            (message[i] == 'E') ? 'G' :\n            (message[i]\
    \ == 'I') ? 'K' :\n            (message[i] == 'O') ? 'O' :\n            (message[i]\
    \ == 'U') ? 'A' :\n            (message[i] == 'Y') ? 'I' :\n            (message[i]\
    \ == 'a') ? 't' :\n            (message[i] == 'e') ? 'g' :\n            (message[i]\
    \ == 'i') ? 'k' :\n            (message[i] == 'o') ? 'o' :\n            (message[i]\
    \ == 'u') ? 'a' :\n            (message[i] == 'y') ? 'i' :\n            (message[i]\
    \ == 'a') ? 't' :\n            (message[i] == 'e') ? 'g' :\n            (message[i]\
    \ == 'i') ? 'k' :\n            (message[i] == 'o') ? 'o' :\n            (message[i]\
    \ == 'u') ? 'a' :\n            (message[i] == 'y') ? 'i' :\n            (message[i]\
    \ == 'A') ? 'T' :\n            (message[i] == 'E') ? 'G' :\n            (message[i]\
    \ == 'I') ? 'K' :\n            (message[i] == 'O') ? 'O' :\n            (message[i]\
    \ == 'U') ? 'A' :\n            (message[i] == 'Y') ? 'I' :\n            (message[i]\
    \ == 'a') ? 't' :\n            (message[i] == 'e') ? 'g' :\n            (message[i]\
    \ == 'i') ? 'k' :\n            (message[i] == 'o') ? 'o' :\n            (message[i]\
    \ == 'u') ? 'a' :\n            (message[i] == 'y') ? 'i' :\n            (message[i]\
    \ == 'a') ? 't' :\n            (message[i] == 'e') ? 'g' :\n            (message[i]\
    \ == 'i') ? 'k' :\n            (message[i] == 'o') ? 'o' :\n            (message[i]\
    \ == 'u') ? 'a' :\n            (message[i] == 'y') ? 'i' :\n            '?';\n\
    \    }\n    return answer;\n}\nint main() {\n    auto candidate = encode;\n  \
    \  assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpicqsw93c: /tmp/tmpicqsw93c.cpp:70: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ msg;\n    for (char &c: message) {\n        c = tolower(c);\n        switch\
    \ (c) {\n            case 'a':\n                c = 't';\n                break;\n\
    \            case 'e':\n                c = 'h';\n                break;\n   \
    \         case 'i':\n                c = 'k';\n                break;\n      \
    \      case 'o':\n                c = 'g';\n                break;\n         \
    \   case 'u':\n                c = 'u';\n                break;\n            case\
    \ 'y':\n                c = 'c';\n                break;\n            case 'b':\n\
    \                c = 'b';\n                break;\n            case 'r':\n   \
    \             c = 'r';\n                break;\n            case 'n':\n      \
    \          c = 'n';\n                break;\n            case 'w':\n         \
    \       c = 'w';\n                break;\n            case 's':\n            \
    \    c = 's';\n                break;\n            case 't':\n               \
    \ c = 't';\n                break;\n            case 'h':\n                c =\
    \ 'h';\n                break;\n            case 'k':\n                c = 'k';\n\
    \                break;\n            case 'g':\n                c = 'g';\n   \
    \             break;\n            case 'c':\n                c = 'c';\n      \
    \          break;\n            case 'm':\n                c = 'm';\n         \
    \       break;\n            case 'g':\n                c = 'g';\n            \
    \    break;\n        }\n        msg += c;\n    }\n    std::string encoded;\n \
    \   for (int i = 0; i < msg.size(); i++) {\n        if (msg[i] == 'a') {\n   \
    \         encoded.push_back('t');\n        } else if (msg[i] == 'e') {\n     \
    \       encoded.push_back('h');\n        } else if (msg[i] == 'i') {\n       \
    \     encoded.push_back('k');\n        } else if (msg[i] == 'o') {\n         \
    \   encoded.push_back('g');\n        } else if (msg[i] == 'u') {\n           \
    \ encoded.push_back('u');\n        } else if (msg[i] == 'y') {\n            encoded.push_back('c');\n\
    \        } else if (msg[i] == 'b') {\n            encoded.push_back('b');\n  \
    \      } else if (msg[i] == 'r') {\n            encoded.push_back('r');\n    \
    \    } else if (msg[i] == 'n') {\n            encoded.push_back('n');\n      \
    \  } else if (msg[i] == 'w') {\n            encoded.push_back('w');\n        }\
    \ else if (msg[i] == 's') {\n            encoded.push_back('s');\n        } else\
    \ if (msg[i] == 't') {\n            encoded.push_back('t');\n        } else if\
    \ (msg[i] == 'h') {\n            encoded.push_back('h');\n        } else if (msg[i]\
    \ == 'k') {\n            encoded.push_back('k');\n        } else if (msg[i] ==\
    \ 'g') {\n            encoded.push_back('g');\n        } else if (msg[i] == 'c')\
    \ {\n            encoded.push_back('c');\n        } else if (msg[i] == 'm') {\n\
    \            encoded.push_back('m');\n        } else if (msg[i] == 'g') {\n  \
    \          encoded.push_back('g');\n        }\n    }\n    return encoded;\n\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqfjb15n3.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqfjb15n3.cpp:69:13: error: duplicate case value\n   69 |          \
    \   case 'g':\n      |             ^~~~\n/tmp/tmpqfjb15n3.cpp:60:13: note: previously\
    \ used here\n   60 |             case 'g':\n      |             ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Write\
    \ your code here\n    int len = message.length();\n    std::string encoded;\n\
    \    for(int i = 0; i < len; i ++)\n    {\n        char letter = message[i];\n\
    \        char vowel = letter;\n        vowel = vowel == 'A' ? 'B' : \n       \
    \         vowel == 'E' ? 'F' : \n                vowel == 'I' ? 'J' : \n     \
    \           vowel == 'O' ? 'N' : \n                vowel == 'U' ? 'T' : \n   \
    \             vowel == 'Y' ? 'V' : \n                vowel == 'a' ? 'b' : \n \
    \               vowel == 'e' ? 'f' : \n                vowel == 'i' ? 'j' : \n\
    \                vowel == 'o' ? 'n' : \n                vowel == 'u' ? 't' : \n\
    \                vowel == 'y' ? 'v' : \n                vowel;\n        for(int\
    \ j = 0; j < i; j ++)\n        {\n            if(message[i] == message[j])\n \
    \           {\n                letter = letter == vowel ? letter : 'Z';\n    \
    \        }\n        }\n        encoded += letter;\n    }\n    return encoded;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1l386bgl: /tmp/tmp1l386bgl.cpp:47: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Complete\
    \ this function\n    // Use loop to find all vowels and replace them with a letter\n\
    \    // 2 places ahead of the vowel in the alphabet\n    std::string encodedMessage\
    \ = \"\";\n    return encodedMessage;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp57yf9c4k: /tmp/tmp57yf9c4k.cpp:22: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for (int i = 0; i <= message.length(); i++) {\n        char c = message[i];\n\
    \        if ('a' <= c && c <= 'z') {\n            ans += c;\n        }\n     \
    \   else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n   \
    \         char d = message[i + 1];\n            if ('A' <= d && d <= 'Z') {\n\
    \                ans += 'A' + d - 'A';\n            }\n            else {\n  \
    \              ans += c;\n            }\n        }\n        else if (c == 'o'\
    \ || c == 'u' || c == 'O' || c == 'U') {\n            char d = message[i + 1];\n\
    \            if ('o' <= d && d <= 'u') {\n                ans += 'o' + d - 'o';\n\
    \            }\n            else {\n                ans += c;\n            }\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpk_4j0j81: /tmp/tmpk_4j0j81.cpp:43: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int lenght\
    \ = message.length();\n    string s = \"\";\n    for (int i = 0; i < lenght; i++)\
    \ {\n        if ((message[i] == 'a') || (message[i] == 'e') || (message[i] ==\
    \ 'i') || (message[i] == 'o') || (message[i] == 'u') || (message[i] == 'y')) {\n\
    \            s += message[i];\n        }\n        else if ((message[i] >= 'A')\
    \ && (message[i] <= 'Z')) {\n            s += message[i] + 2;\n        }\n   \
    \     else if ((message[i] >= 'a') && (message[i] <= 'z')) {\n            s +=\
    \ message[i] - 'a' + 2;\n        }\n        else if ((message[i] == '_') || (message[i]\
    \ == '.')) {\n            s += message[i];\n        }\n        else if (message[i]\
    \ == '(') {\n            s += message[i];\n        }\n        else if (message[i]\
    \ == ')') {\n            s += message[i];\n        }\n    }\n    return s;\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpd8he5im8.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpd8he5im8.cpp:15:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   15 |     string s = \"\";\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpd8he5im8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpd8he5im8.cpp:18:13:\
    \ error: \u2018s\u2019 was not declared in this scope\n   18 |             s +=\
    \ message[i];\n      |             ^\n/tmp/tmpd8he5im8.cpp:21:13: error: \u2018\
    s\u2019 was not declared in this scope\n   21 |             s += message[i] +\
    \ 2;\n      |             ^\n/tmp/tmpd8he5im8.cpp:24:13: error: \u2018s\u2019\
    \ was not declared in this scope\n   24 |             s += message[i] - 'a' +\
    \ 2;\n      |             ^\n/tmp/tmpd8he5im8.cpp:27:13: error: \u2018s\u2019\
    \ was not declared in this scope\n   27 |             s += message[i];\n     \
    \ |             ^\n/tmp/tmpd8he5im8.cpp:30:13: error: \u2018s\u2019 was not declared\
    \ in this scope\n   30 |             s += message[i];\n      |             ^\n\
    /tmp/tmpd8he5im8.cpp:33:13: error: \u2018s\u2019 was not declared in this scope\n\
    \   33 |             s += message[i];\n      |             ^\n/tmp/tmpd8he5im8.cpp:36:12:\
    \ error: \u2018s\u2019 was not declared in this scope\n   36 |     return s;\n\
    \      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result;\n    for (char &c: message) {\n        if ('a' <= c && c <= 'z') {\n\
    \            result += std::string(tolower(c) - 'a' + 'A', 1);\n        } else\
    \ if ('A' <= c && c <= 'Z') {\n            result += std::string(tolower(c) -\
    \ 'A' + 'a', 1);\n        } else if (isupper(c)) {\n            result += std::string(toupper(c)\
    \ - 'A' + 'a', 1);\n        }\n    }\n    for (char &c: result) {\n        if\
    \ (std::count(result.begin(), result.end(), c) == 2) {\n            result +=\
    \ std::string(tolower(c) - 'A' + 'a', 1);\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpb7zc8_kk: /tmp/tmpb7zc8_kk.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ output; //to return result string \n    for(unsigned int i = 0; i < message.length();\
    \ i++){\n        char ch = message[i];\n        if(ch >= 'A' && ch <= 'Z'){\n\
    \            output+=tolower(ch);\n        }else if(ch >= 'a' && ch <= 'z'){\n\
    \            output+=toupper(ch);\n        }else if(ch == 'A' || ch == 'a'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'B' || ch == 'b'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'C' || ch == 'c'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'D' || ch == 'd'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'E' || ch == 'e'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'F' || ch == 'f'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'G' || ch == 'g'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'H' || ch == 'h'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'I' || ch == 'i'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'J' || ch == 'j'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'K' || ch == 'k'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'L' || ch == 'l'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'M' || ch == 'm'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'N' || ch == 'n'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'O' || ch == 'o'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'P' || ch == 'p'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'Q' || ch == 'q'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'R' || ch == 'r'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'S' || ch == 's'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'T' || ch == 't'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'U' || ch == 'u'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'V' || ch == 'v'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'W' || ch == 'w'){\n\
    \            output+=tolower(ch);\n        }else if(ch == 'X' || ch == 'x'){\n\
    \            output+=tolower(ch);\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyi_1efl3.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyi_1efl3.cpp:70:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   70 | int main() {\n      |            ^\n/tmp/tmpyi_1efl3.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmpyi_1efl3.cpp:15:55:\
    \ note: to match this \u2018{\u2019\n   15 |     for(unsigned int i = 0; i < message.length();\
    \ i++){\n      |                                                       ^\n/tmp/tmpyi_1efl3.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmpyi_1efl3.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpyi_1efl3.cpp:77:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   77 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int count\
    \ = 0;\n    for(char c : message) {\n        if('a' <= c && c <= 'z') {\n    \
    \        count++;\n            char tmp = c;\n            c = count - 1;\n   \
    \         message = message.substr(0, message.size() - 1) + message.substr(message.size()\
    \ - 1, 1) +\n            tmp;\n        }\n        if('a' <= c && c <= 'z') {\n\
    \            count++;\n            char tmp = c;\n            c = count - 1;\n\
    \            message = message.substr(0, message.size() - 1) + message.substr(message.size()\
    \ - 1, 1) +\n            tmp;\n        }\n    }\n    return message;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9xsu94d8: /tmp/tmp9xsu94d8.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int n =\
    \ message.length();\n    if (n==0)\n        return message;\n    string s = message;\n\
    \    for(int i=0;i<n;i++) {\n        if (s[i]=='a' || s[i]=='e' || s[i]=='i' ||\
    \ s[i]=='o' || s[i]=='u')\n            s[i] = 'A';\n        else if (s[i]=='e'\
    \ || s[i]=='i' || s[i]=='o' || s[i]=='u')\n            s[i] = 'E';\n        else\
    \ if (s[i]=='i' || s[i]=='o' || s[i]=='u')\n            s[i] = 'I';\n        else\
    \ if (s[i]=='u')\n            s[i] = 'U';\n    }\n    for (int i=0; i<n; i++)\
    \ {\n        string temp=s;\n        if (s[i]=='A' || s[i]=='E' || s[i]=='I' ||\
    \ s[i]=='O' || s[i]=='U')\n            temp = temp + s[i];\n        else if (s[i]=='a'\
    \ || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u')\n            temp = temp\
    \ + 'A';\n        else if (s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u')\n\
    \            temp = temp + 'E';\n        else if (s[i]=='i' || s[i]=='o' || s[i]=='u')\n\
    \            temp = temp + 'I';\n        else if (s[i]=='u')\n            temp\
    \ = temp + 'U';\n        s[i] = temp[0];\n    }\n    return s;\n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp6wq7g2gy.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp6wq7g2gy.cpp:17:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   17 |     string s = message;\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp6wq7g2gy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp6wq7g2gy.cpp:19:13:\
    \ error: \u2018s\u2019 was not declared in this scope\n   19 |         if (s[i]=='a'\
    \ || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u')\n      |             ^\n\
    /tmp/tmp6wq7g2gy.cpp:29:15: error: expected \u2018;\u2019 before \u2018temp\u2019\
    \n   29 |         string temp=s;\n      |               ^~~~~\n      |       \
    \        ;\n/tmp/tmp6wq7g2gy.cpp:30:13: error: \u2018s\u2019 was not declared\
    \ in this scope\n   30 |         if (s[i]=='A' || s[i]=='E' || s[i]=='I' || s[i]=='O'\
    \ || s[i]=='U')\n      |             ^\n/tmp/tmp6wq7g2gy.cpp:31:13: error: \u2018\
    temp\u2019 was not declared in this scope\n   31 |             temp = temp + s[i];\n\
    \      |             ^~~~\n/tmp/tmp6wq7g2gy.cpp:33:13: error: \u2018temp\u2019\
    \ was not declared in this scope\n   33 |             temp = temp + 'A';\n   \
    \   |             ^~~~\n/tmp/tmp6wq7g2gy.cpp:35:13: error: \u2018temp\u2019 was\
    \ not declared in this scope\n   35 |             temp = temp + 'E';\n      |\
    \             ^~~~\n/tmp/tmp6wq7g2gy.cp"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result=message;\n    std::transform(message.begin(), message.end(), message.begin(),\
    \ ::toupper);\n    std::replace( message.begin(), message.end(), 'A','B');\n \
    \   std::replace( message.begin(), message.end(), 'E','F');\n    std::replace(\
    \ message.begin(), message.end(), 'I','J');\n    std::replace( message.begin(),\
    \ message.end(), 'O','P');\n    std::replace( message.begin(), message.end(),\
    \ 'U','V');\n    std::replace( message.begin(), message.end(), 'Y','Z');\n   \
    \ for(int i=0; i<message.length(); i++)\n    {\n        for(int j=0; j<26; j++)\n\
    \        {\n            if(message[i]==(char)j)\n            {\n             \
    \   if(((i+1)%2)==0)\n                {\n                    result[i]=(char)j;\n\
    \                }\n            }\n        }\n    }\n    return result; \n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpzvpx02g3: /tmp/tmpzvpx02g3.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    for(int\
    \ i = 1; i < message.length(); i++) {\n        char c = message[i];\n        if('A'\
    \ <= c && c <= 'Z') {\n            char temp = message[i];\n            message[i]\
    \ = message[i-1];\n            message[i-1] = temp;\n        }\n    }\n    \n\
    \    for(int i = 0; i < message.length(); i++) {\n        if(message[i] == 'a'\
    \ || message[i] == 'e' || message[i] == 'i' || \n                message[i] ==\
    \ 'o' || message[i] == 'u' || message[i] == 'y') {\n            char temp = message[i];\n\
    \            message[i] = message[i+1];\n            message[i+1] = temp;\n  \
    \      }\n    }\n\n    for(int i = 0; i < message.length(); i++) {\n        if(message[i]\
    \ == 'a' || message[i] == 'e' || message[i] == 'i' || \n                message[i]\
    \ == 'o' || message[i] == 'u' || message[i] == 'y') {\n            char temp =\
    \ message[i];\n            message[i] = message[i+1];\n            message[i+1]\
    \ = temp;\n        }\n    }\n\n    for(int i = 0; i < message.length(); i++) {\n\
    \        if(message[i] == 'a' || message[i] == 'e' || message[i] == 'i' || \n\
    \                message[i] == 'o' || message[i] == 'u' || message[i] == 'y')\
    \ {\n            char temp = message[i];\n            message[i] = message[i+1];\n\
    \            message[i+1] = temp;\n        }\n    }\n\n    return message;\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1e9klldx: /tmp/tmp1e9klldx.cpp:55: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int vowels[26]\
    \ = {'a','e','i','o','u','y','A','E','I','O','U','Y'};\n    int letter_nums[26];\n\
    \    for(unsigned int i = 0; i < 26; i++)\n        letter_nums[message[i] - 'a']++;\n\
    \n    std::string encoded_message;\n    encoded_message.reserve(message.length()\
    \ * 2);\n\n    for(int i = 0; i < 26; i++) {\n        if(letter_nums[i] > 1) {\n\
    \            int letter_i = message[i] - 'a';\n            int letter_j = message[i+1\
    \ - 'a'];\n            assert(letter_i < (int)message.length() && letter_j < (int)message.length());\n\
    \n            if(letter_nums[letter_i] >= 2 && letter_nums[letter_j] >= 2)\n \
    \               encoded_message.push_back((char)(letter_i + 2));\n        }\n\
    \    }\n    return encoded_message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpchm6qhhf: /tmp/tmpchm6qhhf.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::vector<std::string>\
    \ vowels = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', \n        'H', 'I', 'J', 'K',\
    \ 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', \n        'U', 'V', 'W', 'X', 'Y',\
    \ 'Z'};\n    std::string result;\n    std::string vowel_mapping;\n    for (auto\
    \ &letter: message) {\n        if (vowels.find(letter) != vowels.end())\n    \
    \        vowel_mapping = letter;\n        else if (vowel_mapping.find(vowels[vowels.find(letter)\
    \ + 1]) != \n            vowel_mapping.end())\n            result += (vowel_mapping[vowels.find(letter)\
    \ + 1] + vowels[vowels.find(letter) + 2]);\n        else\n            result +=\
    \ letter;\n    }\n    return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfbi3woku.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpfbi3woku.cpp:16:37: error: could not convert \u2018{'A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'}\u2019 from \u2018<brace-enclosed initializer\
    \ list>\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n\
    \   16 |         'U', 'V', 'W', 'X', 'Y', 'Z'};\n      |                     \
    \                ^\n      |                                     |\n      |   \
    \                                  <brace-enclosed initializer list>\n/tmp/tmpfbi3woku.cpp:20:20:\
    \ error: \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has\
    \ no member named \u2018find\u2019\n   20 |         if (vowels.find(letter) !=\
    \ vowels.end())\n      |                    ^~~~\n/tmp/tmpfbi3woku.cpp:22:51:\
    \ error: \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has\
    \ no member named \u2018find\u2019\n   22 |         else if (vowel_mapping.find(vowels[vowels.find(letter)\
    \ + 1]) !=\n      |                                                   ^~~~\n/tmp/tmpfbi3woku.cpp:24:45:\
    \ error: \u2018class std::vector<std::__cxx11::basic_string<char> >\u2019 has\
    \ no member named \u2018find\u2019\n   24 |             result += (vowel_mapping[vowels.find(letter)\
    \ + 1] + vowels[vowels.find(letter) + 2]);\n      |                          \
    \                   ^~~~\n/tmp/tmpfbi3woku.cpp:24:79: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018find\u2019\n   24 |             result +=\
    \ (vowel_mapping[vowels.find(letter) + 1] + vowels[vowels.find(letter) + 2]);\n\
    \      |                                                                     \
    \          ^~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  std::map<char,\
    \ char> map;\n  for (char &c : message) {\n    c = toupper(c); \n    map[c] =\
    \ ' ';\n  }\n  for (char &c : message) {\n    c = tolower(c); \n    map[c] = map[tolower(c)];\
    \ \n  }\n  for (char &c : message) {\n    char pos = map[c];\n    if (pos == '\
    \ ') {\n      c = tolower(c);\n      c = ' ';\n    } else {\n      c = tolower(c);\n\
    \      pos = toupper(pos);\n      map[c] = pos;\n    }\n  }\n  return message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp3b_t025y: /tmp/tmp3b_t025y.cpp:38: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Your\
    \ code goes here!\n    \n    return message;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp268c6cwl: /tmp/tmp268c6cwl.cpp:20: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    int vowels[26];\n    for (int i=0; i<26; i++)\n        vowels[i]\
    \ = -1;\n    for (int i=0; i<message.length(); i++)\n        vowels[message[i]-'a']++;\n\
    \    for (int i=0; i<26; i++)\n        if (vowels[i] >= 2)\n            encoded\
    \ += message[i] + static_cast<char>('a'+(i+vowels[i]-2));\n    return encoded;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp5zv6fnay: /tmp/tmp5zv6fnay.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Your\
    \ code here\n    char ch;\n    int i, j, k=0;\n    int lenght=message.length();\n\
    \    for(i=0; i<lenght; i++) {\n        ch = message[i];\n        for(j=0; j<26;\
    \ j++) {\n            if(ch == static_cast<char>(j)) {\n                k++;\n\
    \            }\n        }\n        for(int j=0; j<26; j++) {\n            if(ch\
    \ == static_cast<char>(j)) {\n                ch = (ch == static_cast<char>(j))\
    \ ? static_cast<char>(j+k) : static_cast<char>(j);\n                k = k;\n \
    \           }\n        }\n    }\n    return ch;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp04w2s79j.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp04w2s79j.cpp:32:12: error: could not convert \u2018ch\u2019 from \u2018\
    char\u2019 to \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    }\n   32 |     return ch;\n      |            ^~\n      |            |\n     \
    \ |            char\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for (auto\
    \ &c: message) {\n        if (isalpha(c)) {\n            char n = toupper(c);\n\
    \            int pos = 0;\n            for (auto &p: vowels) {\n             \
    \   if (p == n) pos = vowels.find(p);\n            }\n            if (pos != 0)\
    \ {\n                c = (char) (n - pos - 1);\n            } else {\n       \
    \         c = n;\n            }\n        }\n    }\n    std::string ans = \"\"\
    ;\n    for (auto &c: message) {\n        if (isalpha(c)) {\n            ans +=\
    \ c;\n        }\n    }\n    for (auto &c: ans) {\n        if (c == 'a') {\n  \
    \          c = 'e';\n        } else if (c == 'e') {\n            c = 'i';\n  \
    \      } else if (c == 'i') {\n            c = 'o';\n        } else if (c == 'o')\
    \ {\n            c = 'u';\n        } else if (c == 'u') {\n            c = 'A';\n\
    \        } else if (c == 'A') {\n            c = 'E';\n        } else if (c ==\
    \ 'E') {\n            c = 'I';\n        } else if (c == 'I') {\n            c\
    \ = 'O';\n        } else if (c == 'O') {\n            c = 'U';\n        }\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmptykfuesk.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmptykfuesk.cpp:18:27: error: \u2018vowels\u2019 was not declared in this\
    \ scope\n   18 |             for (auto &p: vowels) {\n      |                \
    \           ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Complete\
    \ this function. \n    // Assume only letters. \n    // Write your logic here\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpr2lvhhep: /tmp/tmpr2lvhhep.cpp:20: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n   std::stack<char>\
    \ s;\n   std::stack<std::string> s1;\n   for (int i = 0; i < message.length();\
    \ i++)\n   {\n       char c = message[i];\n       if (c == 'a' || c == 'A' ||\
    \ c == 'e' || c == 'E' || c == 'i' || c == 'I' || c == 'o' || c == 'O' || c ==\
    \ 'u' || c == 'U')\n          s.push(std::to_string(c));\n       else\n      \
    \ {\n          std::string a = (i == 0) ? s.top() : s1.top();\n          s2.push(std::to_string(i));\n\
    \          s1.pop();\n          s.push(a);\n          s.push(c);\n       }\n \
    \  }\n   std::string a = s.top();\n   s2.push(std::to_string(i));\n   s1.pop();\n\
    \   s.push(a);\n   std::string b = s2.top();\n   s2.pop();\n   std::string c =\
    \ s1.top();\n   s1.pop();\n   std::string d = s2.top();\n   s2.pop();\n   std::string\
    \ final = b.empty() ? a : b.append(a).append(c);\n   std::string final1 = d.empty()\
    \ ? final : final.append(d).append(b);\n   final1.pop_back();\n   return final1;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpjedekemb.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpjedekemb.cpp:20:35: error: no matching function for call to \u2018\
    std::stack<char>::push(std::string)\u2019\n   20 |           s.push(std::to_string(c));\n\
    \      |                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/stack:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpjedekemb.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = char; _Sequence = std::deque<char, std::allocator<char> >; std::stack<_Tp,\
    \ _Sequence>::value_type = char]\u2019\n  233 |       push(const value_type& __x)\n\
    \      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:233:30:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const char&\u2019}\n  233 |       push(const value_type& __x)\n \
    \     |            ~~~~~~~~~~~~~~~~~~^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(std::stack<_Tp,\
    \ _Sequence>::value_type&&) [with _Tp = char; _Sequence = std::deque<char, std::allocator<char>\
    \ >; std::stack<_Tp, _Sequence>::value_type = char]\u2019\n  238 |       push(value_type&&\
    \ __x)\n      |       ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018std::stack<char>::value_type&&\u2019\
    \ {aka \u2018char&&\u2019}\n  238 |       push(value_type&& __x)\n      |    \
    \        ~~~~~~~~~~~~~^~~\n/tmp/tmpjedekemb.cpp:23:36: error: operands to ?: have\
    \ different types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basi"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for (int\
    \ i = 0; i < message.length(); i++) {\n        switch (message[i]) {\n       \
    \     case 'a':\n                message += 'B';\n                break;\n   \
    \         case 'b':\n                message += 'a';\n                break;\n\
    \            case 'c':\n                message += 'd';\n                break;\n\
    \            case 'd':\n                message += 'c';\n                break;\n\
    \            case 'e':\n                message += 'f';\n                break;\n\
    \            case 'f':\n                message += 'e';\n                break;\n\
    \            case 'g':\n                message += 'h';\n                break;\n\
    \            case 'h':\n                message += 'g';\n                break;\n\
    \            case 'i':\n                message += 'j';\n                break;\n\
    \            case 'j':\n                message += 'i';\n                break;\n\
    \            case 'k':\n                message += 'l';\n                break;\n\
    \            case 'l':\n                message += 'k';\n                break;\n\
    \            case 'm':\n                message += 'n';\n                break;\n\
    \            case 'n':\n                message += 'm';\n                break;\n\
    \            case 'o':\n                message += 'p';\n                break;\n\
    \            case 'p':\n                message += 'o';\n                break;\n\
    \            case 'q':\n                message += 'r';\n                break;\n\
    \            case 'r':\n                message += 'q';\n                break;\n\
    \            case 's':\n                message += 't';\n                break;\n\
    \            case 't':\n                message += 's';\n                break;\n\
    \            case 'u':\n                message += 'v';\n                break;\n\
    \            case 'v':\n                message += 'u';\n                break;\n\
    \            case 'w':\n                message += 'x';\n                break;\n\
    \            case 'x':\n                message += 'w';\n                break;\n\
    \            case 'y':\n                message += 'z';\n                break;\n\
    \            case 'z':\n                message += 'y';\n                break;\n\
    \            default:\n                break;\n        }\n    }\n    for (int\
    \ i = 0; i < message.length(); i++) {\n        switch (message[i]) {\n       \
    \     case 'a':\n                message += 'e';\n                break;\n   \
    \         case 'b':\n                message += 'f';\n                break;\n\
    \            case 'c':\n                message += 'g';\n                break;\n\
    \            case 'd':\n                message += 'h';\n                break;\n\
    \            case 'e':\n                message += 'i';\n                break;\n\
    \            case 'f':\n                message += 'j';\n                break;\n\
    \            case 'g':\n                message += 'k';\n                break;\n\
    \            case 'h':\n                message += 'l';\n                break;\n\
    \            case 'i':\n                message += 'm';\n                break;\n\
    \            case 'j':\n                message += 'n';\n                break;\n\
    \            case 'k':\n                message += 'o';\n                break;\n\
    \            case 'l':\n                message += 'p';\n                break;\n\
    \            case 'm':\n                message += 'q';\n                break;\n\
    \            case 'n':\n                message += 'r';\n                break;\n\
    \            case 'o':\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpc5dshr7z.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpc5dshr7z.cpp:143:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  143 | }\n      | ^\n/tmp/tmpc5dshr7z.cpp:144:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  144 | int main() {\n     \
    \ |            ^\n/tmp/tmpc5dshr7z.cpp:151:1: error: expected \u2018}\u2019 at\
    \ end of input\n  151 | }\n      | ^\n/tmp/tmpc5dshr7z.cpp:98:48: note: to match\
    \ this \u2018{\u2019\n   98 |     for (int i = 0; i < message.length(); i++) {\n\
    \      |                                                ^\n/tmp/tmpc5dshr7z.cpp:151:1:\
    \ error: expected \u2018}\u2019 at end of input\n  151 | }\n      | ^\n/tmp/tmpc5dshr7z.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpc5dshr7z.cpp:151:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  151 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Complete\
    \ this function\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpreqcw6xh: /tmp/tmpreqcw6xh.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Write\
    \ your code here\n    \n    for(int i=0;i<message.length();i++) {\n        if((message[i]\
    \ == 'A')&&(message[i+1] == 'E')) {\n            message[i]=message[i+1];\n  \
    \          message[i+1]='F';\n        }\n        if((message[i] == 'A')&&(message[i+1]\
    \ == 'I')) {\n            message[i]=message[i+1];\n            message[i+1]='J';\n\
    \        }\n        if((message[i] == 'A')&&(message[i+1] == 'O')) {\n       \
    \     message[i]=message[i+1];\n            message[i+1]='L';\n        }\n   \
    \     if((message[i] == 'A')&&(message[i+1] == 'U')) {\n            message[i]=message[i+1];\n\
    \            message[i+1]='N';\n        }\n        if((message[i] == 'A')&&(message[i+1]\
    \ == 'Y')) {\n            message[i]=message[i+1];\n            message[i+1]='P';\n\
    \        }\n        if((message[i] == 'B')&&(message[i+1] == 'E')) {\n       \
    \     message[i]=message[i+1];\n            message[i+1]='F';\n        }\n   \
    \     if((message[i] == 'B')&&(message[i+1] == 'I')) {\n            message[i]=message[i+1];\n\
    \            message[i+1]='J';\n        }\n        if((message[i] == 'B')&&(message[i+1]\
    \ == 'O')) {\n            message[i]=message[i+1];\n            message[i+1]='L';\n\
    \        }\n        if((message[i] == 'B')&&(message[i+1] == 'U')) {\n       \
    \     message[i]=message[i+1];\n            message[i+1]='N';\n        }\n   \
    \     if((message[i] == 'B')&&(message[i+1] == 'Y')) {\n            message[i]=message[i+1];\n\
    \            message[i+1]='P';\n        }\n        if((message[i] == 'C')&&(message[i+1]\
    \ == 'E')) {\n            message[i]=message[i+1];\n            message[i+1]='F';\n\
    \        }\n        if((message[i] == 'C')&&(message[i+1] == 'I')) {\n       \
    \     message[i]=message[i+1];\n            message[i+1]='J';\n        }\n   \
    \     if((message[i] == 'C')&&(message[i+1] == 'O')) {\n            message[i]=message[i+1];\n\
    \            message[i+1]='L';\n        }\n        if((message[i] == 'C')&&(message[i+1]\
    \ == 'U')) {\n            message[i]=message[i+1];\n            message[i+1]='N';\n\
    \        }\n        if((message[i] == 'C')&&(message[i+1] == 'Y')) {\n       \
    \     message[i]=message[i+1];\n            message[i+1]='P';\n        }\n   \
    \     if((message[i] == 'D')&&(message[i+1] == 'E')) {\n            message[i]=message[i+1];\n\
    \            message[i+1]='F';\n        }\n        if((message[i] == 'D')&&(message[i+1]\
    \ == 'I')) {\n\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmps74ub8wo.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmps74ub8wo.cpp:84:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   84 | int main() {\n      |            ^\n/tmp/tmps74ub8wo.cpp:91:1:\
    \ error: expected \u2018}\u2019 at end of input\n   91 | }\n      | ^\n/tmp/tmps74ub8wo.cpp:16:41:\
    \ note: to match this \u2018{\u2019\n   16 |     for(int i=0;i<message.length();i++)\
    \ {\n      |                                         ^\n/tmp/tmps74ub8wo.cpp:91:1:\
    \ error: expected \u2018}\u2019 at end of input\n   91 | }\n      | ^\n/tmp/tmps74ub8wo.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmps74ub8wo.cpp:91:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   91 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Your\
    \ code here\n    string ans;\n    int vowels_present[26] = {0,0,0,0,0,0,0,0,0,0,0};\n\
    \    int i;\n    for(i = 0; i<message.length(); i++)\n    {\n        if(tolower(message[i])\
    \ >= 'a' && tolower(message[i]) <= 'z')\n        {\n            ans.push_back(tolower(message[i]));\n\
    \        }\n        else\n        {\n            int j = tolower(message[i]) -\
    \ 'a';\n            ans.push_back(message[i]);\n            vowels_present[j-1]++;\n\
    \        }\n    }\n    for(i = 0; i < 26; i++)\n    {\n        if(vowels_present[i]%2\
    \ == 0)\n        {\n            ans.push_back('a'+i);\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk7a85ri0.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpk7a85ri0.cpp:15:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   15 |     string ans;\n    \
    \  |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpk7a85ri0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpk7a85ri0.cpp:22:13:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   22 |             ans.push_back(tolower(message[i]));\n      |          \
    \   ^~~\n      |             abs\n/tmp/tmpk7a85ri0.cpp:27:13: error: \u2018ans\u2019\
    \ was not declared in this scope; did you mean \u2018abs\u2019?\n   27 |     \
    \        ans.push_back(message[i]);\n      |             ^~~\n      |        \
    \     abs\n/tmp/tmpk7a85ri0.cpp:35:13: error: \u2018ans\u2019 was not declared\
    \ in this scope; did you mean \u2018abs\u2019?\n   35 |             ans.push_back('a'+i);\n\
    \      |             ^~~\n      |             abs\n/tmp/tmpk7a85ri0.cpp:38:12:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   38 |     return ans;\n      |            ^~~\n      |            abs\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Write\
    \ your code here\n    bool vowels[26];\n    vowels[a] = 'a';\n    vowels[e] =\
    \ 'e';\n    vowels[i] = 'i';\n    vowels[o] = 'o';\n    vowels[u] = 'u';\n   \
    \ for (int i = 0; i < message.length(); i++) {\n        char ch = message[i];\n\
    \        if (ch == ' ') continue;\n        char ch1 = ch;\n        char ch2 =\
    \ ch;\n        for (int j = (int)ch; j < 65; j++) {\n            if (j == ch)\
    \ ch2 = ch;\n        }\n        for (int k = (int)ch1; k < 65; k++) {\n      \
    \      if (k == ch1) ch2 = ch1;\n        }\n        message[i] = (char)ch2;\n\
    \    }\n    for (int i = 0; i < 26; i++) {\n        char ch = vowels[i];\n   \
    \     int index = message - 'a' + 1;\n        if (index >= 0 && index < 26) {\n\
    \            if (ch != message[index]) {\n                for (int j = (int)ch;\
    \ j < 65; j++) {\n                    if (j == message[index]) message[index]\
    \ = (char)j;\n                }\n            }\n        }\n    }\n    return message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpb3_ovzrh.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpb3_ovzrh.cpp:16:12: error: \u2018a\u2019 was not declared in this scope\n\
    \   16 |     vowels[a] = 'a';\n      |            ^\n/tmp/tmpb3_ovzrh.cpp:17:12:\
    \ error: \u2018e\u2019 was not declared in this scope\n   17 |     vowels[e] =\
    \ 'e';\n      |            ^\n/tmp/tmpb3_ovzrh.cpp:18:12: error: \u2018i\u2019\
    \ was not declared in this scope\n   18 |     vowels[i] = 'i';\n      |      \
    \      ^\n/tmp/tmpb3_ovzrh.cpp:19:12: error: \u2018o\u2019 was not declared in\
    \ this scope\n   19 |     vowels[o] = 'o';\n      |            ^\n/tmp/tmpb3_ovzrh.cpp:20:12:\
    \ error: \u2018u\u2019 was not declared in this scope\n   20 |     vowels[u] =\
    \ 'u';\n      |            ^\n/tmp/tmpb3_ovzrh.cpp:36:29: error: no match for\
    \ \u2018operator-\u2019 (operand types are \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} and \u2018char\u2019)\n   36 |       \
    \  int index = message - 'a' + 1;\n      |                     ~~~~~~~ ^ ~~~\n\
    \      |                     |         |\n      |                     |      \
    \   char\n      |                     std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpb3_ovzrh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> decltype\
    \ ((__y.base() - __x.base())) std::operator-(const st"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // code\
    \ here\n    return \"\";\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpm495il3j: /tmp/tmpm495il3j.cpp:19: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int length\
    \ = message.length();\n  std::string ans = \"\";\n  for (int i = 0; i < length;\
    \ ++i) {\n    if (isalpha(message[i])) {\n      char temp = message[i];\n    \
    \  int count = 0;\n      for (int j = i; j < length; ++j) {\n        if (isalpha(message[j]))\
    \ {\n          ++count;\n          char t = message[j];\n          message[j]\
    \ = temp;\n          temp = t;\n        }\n      }\n      if (count == 2) {\n\
    \        ans = ans + temp;\n      }\n    }\n  }\n  for (int i = 0; i < length;\
    \ ++i) {\n    if (isalpha(message[i])) {\n      char temp = message[i];\n    \
    \  char t = ans[i];\n      ans[i] = temp;\n      temp = t;\n    }\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpk_v3hql5: /tmp/tmpk_v3hql5.cpp:45: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int n =\
    \ message.length();\n    \n    if (n == 0) {\n        return \"\";\n    }\n  \
    \  \n    std::string encoded;\n    for (int i = 0; i < n; i++) {\n        char\
    \ c = message[i];\n        \n        if ('a' <= c && c <= 'z') {\n           \
    \ encoded += c;\n        } else if (c == 'A') {\n            encoded += 'a';\n\
    \        } else if (c == 'E') {\n            encoded += 'e';\n        } else if\
    \ (c == 'I') {\n            encoded += 'i';\n        } else if (c == 'O') {\n\
    \            encoded += 'o';\n        } else if (c == 'U') {\n            encoded\
    \ += 'u';\n        } else if (c == 'Y') {\n            encoded += 'y';\n     \
    \   } else {\n            std::string vowels = \"AEIOU\";\n            std::string\
    \ v1 = vowels.substr(0, 2);\n            std::string v2 = vowels.substr(2, 2);\n\
    \            std::string v3 = vowels.substr(4, 2);\n            std::string v4\
    \ = vowels.substr(6, 2);\n            std::string v5 = vowels.substr(8, 2);\n\
    \            std::string v6 = vowels.substr(10, 2);\n            \n          \
    \  std::string w1 = vowels.substr(0, 1);\n            std::string w2 = vowels.substr(1,\
    \ 1);\n            std::string w3 = vowels.substr(2, 1);\n            std::string\
    \ w4 = vowels.substr(3, 1);\n            std::string w5 = vowels.substr(4, 1);\n\
    \            std::string w6 = vowels.substr(5, 1);\n            std::string w7\
    \ = vowels.substr(6, 1);\n            std::string w8 = vowels.substr(7, 1);\n\
    \            std::string w9 = vowels.substr(8, 1);\n            \n           \
    \ if (c == 'a') {\n                encoded += w1;\n            }\n           \
    \ else if (c == 'e') {\n                encoded += w2;\n            }\n      \
    \      else if (c == 'i') {\n                encoded += w3;\n            }\n \
    \           else if (c == 'o') {\n                encoded += w4;\n           \
    \ }\n            else if (c == 'u') {\n                encoded += w5;\n      \
    \      }\n            else if (c == 'y') {\n                encoded += w6;\n \
    \           }\n            else if (c == 'A') {\n                encoded += w7;\n\
    \            }\n            else if (c == 'E') {\n                encoded += w8;\n\
    \            }\n            else if (c == 'I') {\n                encoded += w9;\n\
    \            }\n            else {\n                encoded += c;\n          \
    \  }\n        }\n    }\n    \n    return encoded;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 6) > this->size() (which is 5)\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int vowel_position\
    \ = 0;\n    std::string encoded_message = \"\";\n    for (auto &c: message) {\n\
    \        switch (c) {\n            case 'a': case 'e': case 'i': case 'o': case\
    \ 'u':\n                vowel_position++;\n                break;\n          \
    \  default:\n                encoded_message += c;\n                break;\n \
    \       }\n    }\n\n    int count = 1;\n    for (int i = 0; i < message.size();\
    \ i++) {\n        if (message[i] == message[i - 1])\n            count++;\n  \
    \      else\n            count = 1;\n        encoded_message += message[i];\n\
    \        for (int j = 1; j < count && i < message.size(); j++) {\n           \
    \ int index = vowel_position + j;\n            if (index > 0 && index < 26)\n\
    \                encoded_message += message[index];\n        }\n    }\n    return\
    \ encoded_message;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmptm8528ff: /tmp/tmptm8528ff.cpp:44: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  string ans\
    \ = \"\";\n  for(int i = 0; i < message.length(); ++i) {\n    char c = message[i];\n\
    \    if(c == 'a') {\n      ans += 'A';\n    } else if(c == 'e') {\n      ans +=\
    \ 'E';\n    } else if(c == 'i') {\n      ans += 'I';\n    } else if(c == 'o')\
    \ {\n      ans += 'O';\n    } else if(c == 'u') {\n      ans += 'U';\n    } else\
    \ if(c == 'A') {\n      ans += 'a';\n    } else if(c == 'E') {\n      ans += 'e';\n\
    \    } else if(c == 'I') {\n      ans += 'i';\n    } else if(c == 'O') {\n   \
    \   ans += 'o';\n    } else if(c == 'U') {\n      ans += 'u';\n    } else if(c\
    \ == 'a') {\n      ans += 'A';\n    } else if(c == 'e') {\n      ans += 'E';\n\
    \    } else if(c == 'i') {\n      ans += 'I';\n    } else if(c == 'o') {\n   \
    \   ans += 'O';\n    } else if(c == 'u') {\n      ans += 'U';\n    } else {\n\
    \      ans += c;\n    }\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpj38ep90v.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpj38ep90v.cpp:14:3: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |   string ans = \"\";\n\
    \      |   ^~~~~~\n      |   std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpj38ep90v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpj38ep90v.cpp:18:7:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   18 |       ans += 'A';\n      |       ^~~\n      |       abs\n/tmp/tmpj38ep90v.cpp:20:7:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   20 |       ans += 'E';\n      |       ^~~\n      |       abs\n/tmp/tmpj38ep90v.cpp:22:7:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   22 |       ans += 'I';\n      |       ^~~\n      |       abs\n/tmp/tmpj38ep90v.cpp:24:7:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   24 |       ans += 'O';\n      |       ^~~\n      |       abs\n/tmp/tmpj38ep90v.cpp:26:7:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   26 |       ans += 'U';\n      |       ^~~\n      |       abs\n/tmp/tmpj38ep90v.cpp:28:7:\
    \ error: \u2018ans\u2019 was not declared in this scope; did you mean \u2018abs\u2019\
    ?\n   28 |       ans += 'a';\n      |       ^~~\n      |       abs\n/tmp/tmpj38"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int m =\
    \ message.size();\n    std::string res;\n    for(int i=0;i<m;++i){\n        res.push_back((message[i]+toupper(message[i]))%26);\n\
    \        res.push_back((message[i]-toupper(message[i]))%26);\n    }\n    res.insert(res.begin(),res.begin()+res.size(),message.begin());\n\
    \    return res;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpz3u0kttx: /tmp/tmpz3u0kttx.cpp:25: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Write\
    \ your code here\n    // return your answer as a string in the format described\
    \ above\n    assert(message.size() >= 2); \n    for(int i = 0; i < message.size();\
    \ i++) {\n        char temp;\n        if(message[i] == 'a') {\n            temp\
    \ = message[i+1];\n            char temp2 = 'a';\n            std::string str\
    \ = message(0,i+1) + temp2 + message(1,i);\n            message.replace(0,i+1,str);\n\
    \            message.replace(i+1,i+2,temp);\n        }\n        if(message[i]\
    \ == 'e') {\n            temp = message[i+1];\n            char temp2 = 'e';\n\
    \            std::string str = message(0,i+1) + temp2 + message(1,i);\n      \
    \      message.replace(0,i+1,str);\n            message.replace(i+1,i+2,temp);\n\
    \        }\n        if(message[i] == 'i') {\n            temp = message[i+1];\n\
    \            char temp2 = 'i';\n            std::string str = message(0,i+1) +\
    \ temp2 + message(1,i);\n            message.replace(0,i+1,str);\n           \
    \ message.replace(i+1,i+2,temp);\n        }\n        if(message[i] == 'o') {\n\
    \            temp = message[i+1];\n            char temp2 = 'o';\n           \
    \ std::string str = message(0,i+1) + temp2 + message(1,i);\n            message.replace(0,i+1,str);\n\
    \            message.replace(i+1,i+2,temp);\n        }\n        if(message[i]\
    \ == 'u') {\n            temp = message[i+1];\n            char temp2 = 'u';\n\
    \            std::string str = message(0,i+1) + temp2 + message(1,i);\n      \
    \      message.replace(0,i+1,str);\n            message.replace(i+1,i+2,temp);\n\
    \        }\n        if(message[i] == 'e') {\n            temp = message[i+1];\n\
    \            char temp2 = 'a';\n            std::string str = message(0,i+1) +\
    \ temp2 + message(1,i);\n            message.replace(0,i+1,str);\n           \
    \ message.replace(i+1,i+2,temp);\n        }\n        if(message[i] == 'a') {\n\
    \            temp = message[i+1];\n            char temp2 = 'e';\n           \
    \ std::string str = message(0,i+1) + temp2 + message(1,i);\n            message.replace(0,i+1,str);\n\
    \            message.replace(i+1,i+2,temp);\n        }\n        if(message[i]\
    \ == 'o') {\n            temp = message[i+1];\n            char temp2 = 'i';\n\
    \            std::string str = message(0,i+1) + temp2 + message(1,i);\n      \
    \      message.replace(0,i+1,str);\n            message.replace(i+1,i+2,temp);\n\
    \        }\n        if(message[i] == 'u') {\n            temp = message[i+1];\n\
    \            char temp2 = 'o';\n            std::string str = message(0,i+1) +\
    \ temp2 + message(1,i);\n            message.replace(0,i+1,str);\n           \
    \ message.replace(i+1,i+2,temp);\n\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpdoipdgo6.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpdoipdgo6.cpp:22:44: error: no match for call to \u2018(std::string\
    \ {aka std::__cxx11::basic_string<char>}) (int, int)\u2019\n   22 |          \
    \   std::string str = message(0,i+1) + temp2 + message(1,i);\n      |        \
    \                                    ^\n/tmp/tmpdoipdgo6.cpp:22:67: error: no\
    \ match for call to \u2018(std::string {aka std::__cxx11::basic_string<char>})\
    \ (int, int&)\u2019\n   22 |             std::string str = message(0,i+1) + temp2\
    \ + message(1,i);\n      |                                                   \
    \                ^\n/tmp/tmpdoipdgo6.cpp:24:41: error: no matching function for\
    \ call to \u2018std::__cxx11::basic_string<char>::replace(int, int, char&)\u2019\
    \n   24 |             message.replace(i+1,i+2,temp);\n      |                \
    \                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpdoipdgo6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1961:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [w"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result;\n    \n    for (int i=0; i < message.size(); i++)\n    {\n        char\
    \ c = message[i];\n        \n        // Get the index of the current character.\n\
    \        int index = c - 'a';\n        \n        // If it is the first character\
    \ of the message and it is either A or E, \n        // then swap the case and\
    \ continue to the next character.\n        if (index == 0 && message[i-1] == 'a'\
    \ || message[i-1] == 'e')\n        {\n            // Store the previous character.\n\
    \            char previousChar = message[i-1];\n            \n            // Change\
    \ the previous character to the current character.\n            char currentChar\
    \ = c;\n            \n            // Change the previous character to the new\
    \ one.\n            message[i-1] = currentChar;\n            \n            //\
    \ Change the current character to the previous character.\n            c = previousChar;\n\
    \        }\n        \n        // If it is the second character of the message\
    \ and it is either A or E, \n        // then swap the case and continue to the\
    \ next character.\n        else if (index == 1 && message[i-2] == 'a' || message[i-2]\
    \ == 'e')\n        {\n            // Store the previous character.\n         \
    \   char previousChar = message[i-2];\n            \n            // Change the\
    \ previous character to the current character.\n            char currentChar =\
    \ c;\n            \n            // Change the previous character to the new one.\n\
    \            message[i-2] = currentChar;\n            \n            // Change\
    \ the current character to the previous character.\n            c = previousChar;\n\
    \        }\n        \n        // If it is the third character of the message and\
    \ it is either A or E, \n        // then swap the case and continue to the next\
    \ character.\n        else if (index == 2 && message[i-3] == 'a' || message[i-3]\
    \ == 'e')\n        {\n            // Store the previous character.\n         \
    \   char previousChar = message[i-3];\n            \n            // Change the\
    \ previous character to the current character.\n            char currentChar =\
    \ c;\n            \n            // Change the previous character to the new one.\n\
    \            message[i-3] = currentChar;\n            \n            // Change\
    \ the current character to the previous character.\n            c = previousChar;\n\
    \        }\n        \n        // If it is the fourth character of the message\
    \ and it is either A or E, \n        // then swap the case and continue to the\
    \ next character.\n        else if (index == 3 && message[i-4] == 'a' || message[i-4]\
    \ == 'e')\n        {\n            // Store the previous character.\n         \
    \   char previousChar = message[i-4];\n            \n            // Change the\
    \ previous character to the current character.\n            char currentChar =\
    \ c;\n            \n            // Change the previous character to the new one.\n\
    \            message[i-4] = currentChar;\n            \n            // Change\
    \ the current character to the previous character.\n            c = previousChar;\n\
    \        }\n        \n        // If it is the fifth character \n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpm6_is0qx.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpm6_is0qx.cpp:93:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   93 | int main() {\n      |            ^\n/tmp/tmpm6_is0qx.cpp:100:1:\
    \ error: expected \u2018}\u2019 at end of input\n  100 | }\n      | ^\n/tmp/tmpm6_is0qx.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpm6_is0qx.cpp:100:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  100 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    //\
    \ TODO: Fill in the blanks\n    \n    return \"\";\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpi05coimu: /tmp/tmpi05coimu.cpp:21: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Complete\
    \ this function\n    \n    std::string ans;\n    for (int i=0; i<message.length();\
    \ i++) {\n        \n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpvcpi1jsf: /tmp/tmpvcpi1jsf.cpp:24: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int N =\
    \ 26; // the count of letters in the english alphabet\n    int M = message.length();\
    \ // the count of vowels\n    std::string res = \"\";\n    for(int i = 0; i <\
    \ M; i++) {\n        // get letter from message in i-th position\n        char\
    \ letter = message[i];\n        // swap case for all letters except 'A'\n    \
    \    char ch = letter;\n        if(letter == 'A' || letter == 'E' || letter ==\
    \ 'I' || letter == 'O' || letter == 'U')\n            ch = letter + ((i - 1) <\
    \ M ? message[i - 1] : letter); // if the letter is vowel, get the letter that\
    \ appears 2 places ahead of it\n        for(int j = 0; j < N; j++)\n         \
    \   if(ch == tolower(letters[j]))\n                ch = letters[j + 2];\n    \
    \    res += ch;\n    }\n    return res;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyqx6y_rv.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyqx6y_rv.cpp:25:30: error: \u2018letters\u2019 was not declared in\
    \ this scope; did you mean \u2018letter\u2019?\n   25 |             if(ch == tolower(letters[j]))\n\
    \      |                              ^~~~~~~\n      |                       \
    \       letter\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans=\"\";\n    for(char &c:message) c=toupper(c);\n    for(char &c:message)\
    \ {\n        char d=c;\n        if(isupper(c)) {\n            d = tolower(c);\
    \ c = d;\n        } else if(islower(c)) {\n            d=toupper(c); c=d;\n  \
    \      }\n        if(isalpha(c))\n            ans+=tolower(c);\n        else \n\
    \            ans+=toupper(c);\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpue1x787_: /tmp/tmpue1x787_.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded_message;\n    int n = message.length();\n    std::string alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    for(int i=0;\
    \ i < n; i++) {\n        std::string letter = message.at(i);\n        // Replace\
    \ all vowels\n        letter = replace_vowels(letter);\n        // Replace 2 places\
    \ ahead vowel\n        letter = letter + alphabet.at(alphabet.find_first_of(\"\
    aeiou\") + 1);\n        encoded_message += letter;\n    }\n    return encoded_message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpk9vlb2bz.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpk9vlb2bz.cpp:18:40: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   18 |      \
    \   std::string letter = message.at(i);\n      |                             \
    \ ~~~~~~~~~~^~~\n/tmp/tmpk9vlb2bz.cpp:20:18: error: \u2018replace_vowels\u2019\
    \ was not declared in this scope\n   20 |         letter = replace_vowels(letter);\n\
    \      |                  ^~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // write\
    \ your code here\n    std::string ans = \"\";\n    std::unordered_map<char, char>\
    \ vowels;\n    for (char &i : message) {\n        if (vowels.find(i) != vowels.end())\
    \ {\n            vowels[i] = (char)(2*vowels.at(i));\n        }\n        else\
    \ {\n            vowels[i] = i;\n        }\n    }\n    for (char &i : message)\
    \ {\n        ans += vowels.find(i) != vowels.end()? vowels.find(i): i;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpqed730k7.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpqed730k7.cpp:26:46: error: operands to ?: have different types \u2018\
    std::unordered_map<char, char>::iterator\u2019 {aka \u2018std::__detail::_Node_iterator<std::pair<const\
    \ char, char>, false, false>\u2019} and \u2018char\u2019\n   26 |         ans\
    \ += vowels.find(i) != vowels.end()? vowels.find(i): i;\n      |             \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int n =\
    \ message.length();\n    std::string s;\n    for (int i = 0; i < n; i++) {\n \
    \       if (isalpha(message[i])) {\n            s += message[i] + tolower(message[i]);\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        if (isalpha(message[i]))\
    \ {\n            s += tolower(message[i]) - tolower(message[i]);\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        if (isalpha(message[i])) {\n\
    \            if (message[i] == 'a' || message[i] == 'e' || message[i] == 'i' ||\
    \ message[i] == 'o' || message[i] == 'u') {\n                s += message[i] +\
    \ tolower(message[i]);\n            }\n        }\n    }\n    return s;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp_jhpo3qn: /tmp/tmp_jhpo3qn.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // TODO\n\
    \  return message;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp3kx9g456: /tmp/tmp3kx9g456.cpp:19: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    //\
    \ Code here\n    \n    return message;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp3qi4nnma: /tmp/tmp3qi4nnma.cpp:21: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for (char &c : message) {\n        switch (c) {\n     \
    \   case 'A':\n        case 'E':\n        case 'I':\n        case 'O':\n     \
    \   case 'U':\n            c = c + 2;\n            break;\n        case 'a':\n\
    \        case 'e':\n        case 'i':\n        case 'o':\n        case 'u':\n\
    \            c = c + 2;\n            break;\n        default:\n            std::cout\
    \ << \"Error: No such letter!\" << std::endl;\n            exit(1);\n        }\n\
    \    }\n    std::string vowels(\"AEIOUaeiou\");\n    for (char &c : message) {\n\
    \        if ( vowels.find(c) != std::string::npos ) {\n            c = static_cast<char>(c\
    \ - static_cast<int>(vowels.find(c)));\n        }\n        encoded.append(1, c);\n\
    \    }\n    return encoded;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: "Error: No such letter!\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    int current = 0; \n    int index = 0; \n    while(current\
    \ <= message.size()-1) {\n        switch(message[current]) {\n            case\
    \ 'A':\n                current++;\n                index = 1;\n             \
    \   break;\n            case 'B':\n                current++;\n              \
    \  index = 2;\n                break;\n            case 'C':\n               \
    \ current++;\n                index = 3;\n                break;\n           \
    \ case 'D':\n                current++;\n                index = 4;\n        \
    \        break;\n            case 'E':\n                current++;\n         \
    \       index = 5;\n                break;\n            case 'F':\n          \
    \      current++;\n                index = 6;\n                break;\n      \
    \      case 'G':\n                current++;\n                index = 7;\n   \
    \             break;\n            case 'H':\n                current++;\n    \
    \            index = 8;\n                break;\n            case 'I':\n     \
    \           current++;\n                index = 9;\n                break;\n \
    \           case 'J':\n                current++;\n                index = 10;\n\
    \                break;\n            case 'K':\n                current++;\n \
    \               index = 11;\n                break;\n            case 'L':\n \
    \               current++;\n                index = 12;\n                break;\n\
    \            case 'M':\n                current++;\n                index = 13;\n\
    \                break;\n            case 'N':\n                current++;\n \
    \               index = 14;\n                break;\n            case 'O':\n \
    \               current++;\n                index = 15;\n                break;\n\
    \            case 'P':\n                current++;\n                index = 16;\n\
    \                break;\n            case 'Q':\n                current++;\n \
    \               index = 17;\n                break;\n            case 'R':\n \
    \               current++;\n                index = 18;\n                break;\n\
    \            case 'S':\n                current++;\n                index = 19;\n\
    \                break;\n            case 'T':\n                current++;\n \
    \               index = 20;\n                break;\n            case 'U':\n \
    \               current++;\n                index = 21;\n                break;\n\
    \            case 'V':\n                current++;\n                index = 22;\n\
    \                break;\n            case 'W':\n                current++;\n \
    \               index = 23;\n                break;\n            case 'X':\n \
    \               current++;\n                index = 24;\n                break;\n\
    \            case 'Y':\n                current++;\n                index = 25;\n\
    \                break;\n            case 'Z':\n                current++;\n \
    \               index = 26;\n                break;\n            case 'a':\n \
    \               current++;\n                index = 1;\n                break;\n\
    \            case 'b':\n                current++;\n                index = 2;\n\
    \                break;\n            case 'c':\n                current++;\n \
    \               index = 3;\n                break;\n            case 'd':\n  \
    \              current++;\n                index = 4;\n                break;\n\
    \            case 'e':\n                current++;\n                index = 5;\n\
    \                break;\n            case 'f':\n                current++;\n \
    \               index = 6;\n                break;\n            case 'g':\n  \
    \              current++;\n                index = 7;\n                break;\n\
    \            case 'h':\n                current++;\n                index = 8;\n\
    \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpfa6hjgoy.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpfa6hjgoy.cpp:156:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  156 | int main() {\n      |            ^\n/tmp/tmpfa6hjgoy.cpp:163:1:\
    \ error: expected \u2018}\u2019 at end of input\n  163 | }\n      | ^\n/tmp/tmpfa6hjgoy.cpp:17:40:\
    \ note: to match this \u2018{\u2019\n   17 |     while(current <= message.size()-1)\
    \ {\n      |                                        ^\n/tmp/tmpfa6hjgoy.cpp:163:1:\
    \ error: expected \u2018}\u2019 at end of input\n  163 | }\n      | ^\n/tmp/tmpfa6hjgoy.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpfa6hjgoy.cpp:163:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  163 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Start\
    \ by converting the message to lower case. \n  std::transform(message.begin(),\
    \ message.end(), message.begin(), ::tolower); \n  \n  // Find the vowels, and\
    \ store them in two vectors. \n  std::string vowels = \"aeiouAEIOU\"; \n  std::vector<std::string>\
    \ vowel_vector(vowels.begin(), vowels.end()); \n  std::vector<std::string> vowel_count(vowel_vector.size(),\
    \ 0);  \n  for (std::size_t i = 0; i < message.length(); i++) \n    if (vowel_vector.find(message[i])\
    \ != vowel_vector.end()) \n      vowel_count[message[i] - 'a'] ++;  \n  \n  //\
    \ Convert the letters to the english alphabet positions \n  std::vector<int> english_position(26);\
    \  \n  for (std::size_t i = 0; i < message.length(); i++) \n    english_position[message[i]\
    \ - 'a'] ++;\n  \n  // Now for the actual code. \n  std::string cipher; \n  for\
    \ (std::size_t i = 0; i < vowel_count.size(); i++) { \n    // First find the position\
    \ of the vowel in the english alphabet \n    int pos = english_position[i]; \n\
    \    if (vowel_count[i] > 0) \n      pos += vowel_count[i]; \n  \n    // Now add\
    \ that many letters in that position to the cipher. \n    for (std::size_t j =\
    \ 0; j < vowel_count[i]; j++) \n      cipher += vowel_vector[pos]; \n  \n    //\
    \ Now swap the letters around. \n    for (std::size_t j = 0; j < vowel_count[i];\
    \ j++) \n      cipher += vowel_vector[pos + j]; \n  \n    // Now reverse the order.\
    \ \n    for (std::size_t j = 0; j < vowel_count[i]; j++) \n      cipher += vowel_vector[pos\
    \ - j]; \n  \n    // Now reverse the letters. \n    for (std::size_t j = 0; j\
    \ < vowel_count[i]; j++) \n      cipher += vowel_vector[pos - j]; \n  \n    //\
    \ Reverse the letters. \n    for (std::size_t j = 0; j < vowel_count[i]; j++)\
    \ \n      cipher += vowel_vector[pos + j]; \n  } \n  \n  // Now reverse the cipher,\
    \ since we are building it from \n  // the bottom up \n  std::string rcipher;\
    \ \n  for (std::size_t i = 0; i < message.length(); i++) \n    rcipher += english_position[message[i]\
    \ - 'a']; \n  std::reverse(rcipher.begin(), rcipher.end()); \n  \n  return cipher;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp90y2oplk.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp90y2oplk.cpp:22:22: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018find\u2019\n   22 |     if (vowel_vector.find(message[i])\
    \ != vowel_vector.end())\n      |                      ^~~~\n/tmp/tmp90y2oplk.cpp:23:37:\
    \ error: no \u2018operator++(int)\u2019 declared for postfix \u2018++\u2019 [-fpermissive]\n\
    \   23 |       vowel_count[message[i] - 'a'] ++;\n/tmp/tmp90y2oplk.cpp:35:24:\
    \ error: no match for \u2018operator>\u2019 (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   35 |     if (vowel_count[i] > 0)\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp90y2oplk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:1081:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp90y2oplk.cpp:35:26:\
    \ note:   \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   35\
    \ |     if (vowel_count[i] > 0)\n      |                          ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n       \
    \          from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp90y2oplk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    //write\
    \ code here\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmplq2h7qfb: /tmp/tmplq2h7qfb.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Return\
    \ the string after performing some action\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpz87nmirp: /tmp/tmpz87nmirp.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for(int i = 0; i < ans.size(); i++) {\n        char letter\
    \ = ans[i];\n        ans[i] = tolower(letter);\n    }\n    for(int i = 0; i <\
    \ ans.size(); i++) {\n        char vowel = ans[i];\n        int j;\n        for(j\
    \ = 0; j < ans.size(); j++) {\n            if(vowel == ans[j]) {\n           \
    \     break;\n            }\n        }\n        char next = ans[j];\n        ans[j]\
    \ = tolower(next);\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpb4u7n7qj: /tmp/tmpb4u7n7qj.cpp:34: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for(int\
    \ i = 0; i < message.length(); i++) {\n        char letter = message[i];\n   \
    \     int pos = letter - 'a';\n        if(pos >=0 && pos < 26) {\n           \
    \ std::string s(1,letter);\n            std::swap(s[pos+1], s[pos]);\n       \
    \     for(int j = 2; j < s.length(); j++) {\n                std::string t(1,\
    \ s[j]);\n                std::swap(t[j-1], t[j]);\n                s += t;\n\
    \            }\n            message += s;\n        } else {\n            message\
    \ += letter;\n        }\n    }\n    return message;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (unsigned int i=0; i < message.size(); i++) {\n       \
    \ char ch = message[i];\n        bool isVowel = isVowel(ch);\n        if (isVowel)\
    \ {\n            char ch1 = message[(i + 2)];\n            char ch2 = message[(i\
    \ + 4)];\n            if (ch1 == 'a' || ch1 == 'e' || ch1 == 'i' || ch1 == 'o'\
    \ || ch1 == 'u' || ch1 == 'A' || ch1 == 'E' || ch1 == 'I' || ch1 == 'O' || ch1\
    \ == 'U' || ch1 == 'a' || ch1 == 'e' || ch1 == 'i' || ch1 == 'o' || ch1 == 'u'\
    \ || ch1 == 'A' || ch1 == 'E' || ch1 == 'I' || ch1 == 'O' || ch1 == 'U') {\n \
    \               ch = 'A';\n            } else if (ch2 == 'a' || ch2 == 'e' ||\
    \ ch2 == 'i' || ch2 == 'o' || ch2 == 'u' || ch2 == 'A' || ch2 == 'E' || ch2 ==\
    \ 'I' || ch2 == 'O' || ch2 == 'U' || ch2 == 'a' || ch2 == 'e' || ch2 == 'i' ||\
    \ ch2 == 'o' || ch2 == 'u' || ch2 == 'A' || ch2 == 'E' || ch2 == 'I' || ch2 ==\
    \ 'O' || ch2 == 'U') {\n                ch = 'A';\n            }\n        }\n\
    \        ans += ch;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp19iqm6fd.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp19iqm6fd.cpp:17:34: error: \u2018isVowel\u2019 cannot be used as a\
    \ function\n   17 |         bool isVowel = isVowel(ch);\n      |             \
    \                     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for(int\
    \ i=0; i< message.size();i++)\n    {\n        if(message[i] == 'a')\n        \
    \    message[i] = 'A';\n        else if(message[i] == 'e')\n            message[i]\
    \ = 'E';\n        else if(message[i] == 'i')\n            message[i] = 'I';\n\
    \        else if(message[i] == 'o')\n            message[i] = 'O';\n        else\
    \ if(message[i] == 'u')\n            message[i] = 'U';\n    }\n    for(int i=0;\
    \ i < message.length(); i++)\n    {\n        if(message[i] == ' ')\n        {\n\
    \            for(int j = i+1; j < message.length(); j++)\n            {\n    \
    \            char letter = message[i];\n                char vowel = message[j];\n\
    \                if(letter >= 'a' && letter <= 'z')\n                {\n     \
    \               char temp = 0;\n                    temp = letter - 'a';\n   \
    \                 message[i] = temp + 2;\n                    message[j] = temp\
    \ + 2;\n                }\n                else\n                {\n         \
    \           if(vowel >= 'a' && vowel <= 'z')\n                    {\n        \
    \                char temp = 0;\n                        temp = vowel - 'a';\n\
    \                        message[i] = temp + 2;\n                        message[j]\
    \ = temp + 2;\n                    }\n                    else if(vowel >= 'A'\
    \ && vowel <= 'Z')\n                    {\n                        char temp =\
    \ 0;\n                        temp = vowel - 'A';\n                        message[i]\
    \ = temp + 2;\n                        message[j] = temp + 2;\n              \
    \      }\n                }\n            }\n        }\n    }\n    for(int i=0;\
    \ i< message.size(); i++)\n    {\n        if(message[i] == 'A')\n            message[i]\
    \ = 'a';\n        else if(message[i] == 'E')\n            message[i] = 'e';\n\
    \        else if(message[i] == 'I')\n            message[i] = 'i';\n        else\
    \ if(message[i] == 'O')\n            message[i] = 'o';\n        else if(message[i]\
    \ == 'U')\n            message[i] = 'u';\n    }\n    for(int i=0; i < message.length();\
    \ i++)\n    {\n        if(message[i] == ' ')\n        {\n            for(int j\
    \ = i+1; j < message.length(); j++)\n            {\n                char letter\
    \ = message[i];\n                char vowel = message[j];\n                if(letter\
    \ >= 'a' && letter <= 'z')\n                {\n                    char temp =\
    \ 0;\n                    temp = letter - 'a';\n                    message[i]\
    \ = temp + 2;\n                    message[j] = temp + 2;\n                }\n\
    \                else\n                {\n                    if(vowel >= 'a'\
    \ && vowel <= 'z')\n                    {\n                        char temp =\
    \ 0;\n                        temp = vowel - 'a';\n                        message[i]\
    \ = temp + 2;\n                        message[j] = temp + 2;\n              \
    \      }\n                    else if(vowel >= 'A' && vowel <= 'Z')\n        \
    \            {\n                        char temp\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmphog8q33o.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmphog8q33o.cpp:102:1: error: expected initializer before \u2018}\u2019\
    \ token\n  102 | }\n      | ^\n/tmp/tmphog8q33o.cpp:103:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  103 | int main() {\n     \
    \ |            ^\n/tmp/tmphog8q33o.cpp:110:1: error: expected \u2018}\u2019 at\
    \ end of input\n  110 | }\n      | ^\n/tmp/tmphog8q33o.cpp:91:17: note: to match\
    \ this \u2018{\u2019\n   91 |                 {\n      |                 ^\n/tmp/tmphog8q33o.cpp:110:1:\
    \ error: expected \u2018}\u2019 at end of input\n  110 | }\n      | ^\n/tmp/tmphog8q33o.cpp:80:13:\
    \ note: to match this \u2018{\u2019\n   80 |             {\n      |          \
    \   ^\n/tmp/tmphog8q33o.cpp:110:1: error: expected \u2018}\u2019 at end of input\n\
    \  110 | }\n      | ^\n/tmp/tmphog8q33o.cpp:78:9: note: to match this \u2018{\u2019\
    \n   78 |         {\n      |         ^\n/tmp/tmphog8q33o.cpp:110:1: error: expected\
    \ \u2018}\u2019 at end of input\n  110 | }\n      | ^\n/tmp/tmphog8q33o.cpp:76:5:\
    \ note: to match this \u2018{\u2019\n   76 |     {\n      |     ^\n/tmp/tmphog8q33o.cpp:110:1:\
    \ error: expected \u2018}\u2019 at end of input\n  110 | }\n      | ^\n/tmp/tmphog8q33o.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmphog8q33o.cpp:110:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  110 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // your\
    \ code here\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp9106w_6l: /tmp/tmp9106w_6l.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Write\
    \ your code here\n  std::string newString;\n  for(std::string::iterator it = message.begin();\
    \ it != message.end(); it++){\n      if(*it >= 'a' && *it <= 'z'){\n         \
    \ *it = *it + 4;\n      }\n      if(*it >= 'A' && *it <= 'Z'){\n          *it\
    \ = *it + 6;\n      }\n      if(*it >= '0' && *it <= '9'){\n          *it = *it\
    \ + 1;\n      }\n      if(*it == ' '){\n          newString.push_back(' ');\n\
    \      }\n      else if(*it == '.'){\n          newString.push_back('.');\n  \
    \    }\n      else if(*it == '?'){\n          newString.push_back('?');\n    \
    \  }\n      else if(*it == '!'){\n          newString.push_back('!');\n      }\n\
    \      else if(*it == '-'){\n          newString.push_back('-');\n      }\n  \
    \    else if(*it == '-'){\n          newString.push_back('+');\n      }\n    \
    \  else if(*it == '_'){\n          newString.push_back('_');\n      }\n      else\
    \ if(*it == '0'){\n          newString.push_back('0');\n      }\n      else if(*it\
    \ == '1'){\n          newString.push_back('1');\n      }\n      else if(*it ==\
    \ '2'){\n          newString.push_back('2');\n      }\n      else if(*it == '3'){\n\
    \          newString.push_back('3');\n      }\n      else if(*it == '4'){\n  \
    \        newString.push_back('4');\n      }\n      else if(*it == '5'){\n    \
    \      newString.push_back('5');\n      }\n      else if(*it == '6'){\n      \
    \    newString.push_back('6');\n      }\n      else if(*it == '7'){\n        \
    \  newString.push_back('7');\n      }\n      else if(*it == '8'){\n          newString.push_back('8');\n\
    \      }\n      else if(*it == '9'){\n          newString.push_back('9');\n  \
    \    }\n      else if(*it == '-'){\n          newString.push_back('-');\n    \
    \  }\n      else if(*it == '_'){\n          newString.push_back('_');\n      }\n\
    \      else if(*it == '?'){\n          newString.push_back('?');\n      }\n  \
    \    else if(*it == '!'){\n          newString.push_back('!');\n      }\n    \
    \  else if(*it == '.'){\n          newString.push_back('.');\n      }\n      else\
    \ if(*it == '/'){\n\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp9bwjjo_w.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp9bwjjo_w.cpp:95:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   95 | int main() {\n      |            ^\n/tmp/tmp9bwjjo_w.cpp:102:1:\
    \ error: expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmp9bwjjo_w.cpp:16:77:\
    \ note: to match this \u2018{\u2019\n   16 |   for(std::string::iterator it =\
    \ message.begin(); it != message.end(); it++){\n      |                      \
    \                                                       ^\n/tmp/tmp9bwjjo_w.cpp:102:1:\
    \ error: expected \u2018}\u2019 at end of input\n  102 | }\n      | ^\n/tmp/tmp9bwjjo_w.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp9bwjjo_w.cpp:102:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  102 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ char> vowels;\n    vowels['a'] = 'A';\n    vowels['e'] = 'E';\n    vowels['i']\
    \ = 'I';\n    vowels['o'] = 'O';\n    vowels['u'] = 'U';\n    vowels['A'] = 'a';\n\
    \    vowels['E'] = 'e';\n    vowels['I'] = 'i';\n    vowels['O'] = 'o';\n    vowels['U']\
    \ = 'u';\n    for (int i = 0; i < message.length(); i++) {\n        char currChar\
    \ = message[i];\n        char newChar = vowels[currChar];\n        if (i != 0\
    \ && currChar == newChar) {\n            newChar = message[i - 1];\n        }\n\
    \        message = message.substr(0, i) + newChar + message.substr(i + 1, message.length());\n\
    \    }\n    return message;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpxtnny9b1: /tmp/tmpxtnny9b1.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::stack<char>\
    \ st;\n    std::string ans = \"\";\n    for(int i = 0; i != message.size(); i++)\
    \ {\n        if (message[i] >= 'a' && message[i] <= 'z'){\n            st.push(message[i]);\n\
    \        }\n        else if(message[i] >= 'A' && message[i] <= 'Z'){\n       \
    \     st.push(message[i]);\n        }\n        else {\n            int freq =\
    \ 1;\n            while(st.size() > 1){\n                if(st.top() == st.top())\n\
    \                    freq++;\n                st.pop();\n            }\n     \
    \       std::string vowels = \"AEIOU\";\n            std::string place = \"\"\
    ;\n            if(freq == 2){\n                int place1 = st.top() - 'a';\n\
    \                place = vowels[place1];\n                st.pop();\n        \
    \    }\n            else {\n                place = vowels[freq-1];\n        \
    \    }\n            ans += message[i] + place;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpat8fh8o4: /tmp/tmpat8fh8o4.cpp:47: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    assert(message.length()\
    \ != 0);\n    std::string result = message;\n    for (auto i : message) {\n  \
    \      auto pos = find(result, i);\n        // if character is not found in alphabet\
    \ replace with it's index\n        if (pos == std::string::npos) {\n         \
    \   pos = result.size();\n        }\n        swapCaseIn(&result[pos]);\n    }\n\
    \    for (int i = 0; i < result.size(); i++) {\n        auto j = find(result,\
    \ result[i]);\n        swapCaseIn(&result[i]);\n        if (j != std::string::npos)\
    \ {\n            swapCaseIn(&result[j]);\n        }\n    }\n    for (int i = 0;\
    \ i < result.size(); i++) {\n        auto j = find(result, result[i]);\n     \
    \   if (j != std::string::npos) {\n            swapCaseIn(&result[j]);\n     \
    \   }\n    }\n    for (int i = 0; i < result.size(); i++) {\n        auto j =\
    \ find(result, result[i]);\n        if (j != std::string::npos) {\n          \
    \  swapCaseIn(&result[j]);\n        }\n    }\n    for (int i = 0; i < result.size();\
    \ i++) {\n        auto j = find(result, result[i]);\n        if (j != std::string::npos)\
    \ {\n            swapCaseIn(&result[j]);\n        }\n    }\n    for (int i = 0;\
    \ i < result.size(); i++) {\n        auto j = find(result, result[i]);\n     \
    \   if (j != std::string::npos) {\n            swapCaseIn(&result[j]);\n     \
    \   }\n    }\n    for (int i = 0; i < result.size(); i++) {\n        auto j =\
    \ find(result, result[i]);\n        if (j != std::string::npos) {\n          \
    \  swapCaseIn(&result[j]);\n        }\n    }\n    for (int i = 0; i < result.size();\
    \ i++) {\n        auto j = find(result, result[i]);\n        if (j != std::string::npos)\
    \ {\n            swapCaseIn(&result[j]);\n        }\n    }\n    for (int i = 0;\
    \ i < result.size(); i++) {\n        auto j = find(result, result[i]);\n     \
    \   if (j != std::string::npos) {\n            swapCaseIn(&result[j]);\n     \
    \   }\n    }\n    return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq3m5w272.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpq3m5w272.cpp:17:34: error: no matching function for call to \u2018\
    find(std::string&, char&)\u2019\n   17 |         auto pos = find(result, i);\n\
    \      |                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:48,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_ios.h:37,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpq3m5w272.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/streambuf_iterator.h:373:5:\
    \ note: candidate: \u2018template<class _CharT2> typename __gnu_cxx::__enable_if<std::__is_char<_CharT2>::__value,\
    \ std::istreambuf_iterator<_CharT> >::__type std::find(std::istreambuf_iterator<_CharT>,\
    \ std::istreambuf_iterator<_CharT>, const _CharT2&)\u2019\n  373 |     find(istreambuf_iterator<_CharT>\
    \ __first,\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/streambuf_iterator.h:373:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpq3m5w272.cpp:17:34:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    std::istreambuf_iterator<_CharT>\u2019\n   17 |         auto pos = find(result,\
    \ i);\n      |                                  ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq3m5w272.cpp:2:\n/shared/centos"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // code\
    \ here\n    return \"\"; \n}\nint main() {\n    auto candidate = encode;\n   \
    \ assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpuf5yl3ol: /tmp/tmpuf5yl3ol.cpp:19: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int n = message.length();\n\
    \  std::string s = message;\n  for(int i = 0; i < n; i++) {\n    if(message[i]\
    \ == 'A') s[i] = 'a';\n    else if(message[i] == 'E') s[i] = 'e';\n    else if(message[i]\
    \ == 'I') s[i] = 'i';\n    else if(message[i] == 'O') s[i] = 'o';\n    else if(message[i]\
    \ == 'U') s[i] = 'u';\n    else if(message[i] == 'C') s[i] = 'c';\n    else if(message[i]\
    \ == 'G') s[i] = 'g';\n    else if(message[i] == 'Y') s[i] = 'y';\n    else if(message[i]\
    \ == 'S') s[i] = 's';\n  }\n  \n  int c = 0;\n  for(int i = 0; i < n; i++) {\n\
    \    if(i + 1 == n) c = 1;\n    if(message[i] >= 'a' && message[i] <= 'z') s[i]\
    \ = message[i] - 'a' + c;\n    else if(message[i] >= 'A' && message[i] <= 'Z')\
    \ s[i] = message[i] - 'A' + c;\n    else s[i] = message[i] + 'a' - 'a' + c;\n\
    \  }\n  \n  return s;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpahfhgjiz: /tmp/tmpahfhgjiz.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result;\n    for (auto c : message) {\n        int index = tolower(c) - 'a';\n\
    \        if (index < 0) index = 26 + index;\n        result[index] = toupper(c);\n\
    \    }\n    for (int i = 0; i < result.length(); i++) {\n        auto c = result[i];\n\
    \        if (c == 'A') continue;\n        int index = toupper(c) - 'A';\n    \
    \    if (index < 0) index = 26 + index;\n        result[i] = tolower(index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = encode;\n  \
    \  assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpykxv0_kn: /tmp/tmpykxv0_kn.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ answer = \"\";\n    for(int i = 0; i < message.size(); ++i) {\n        if (message[i]\
    \ == 'a') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'A') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'e') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'E') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'i') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'I') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'o') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'O') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'u') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'U') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'A') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'a') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'i') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'o') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'u') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'u') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'A') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'e') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'I') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'o') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'u') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'y') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'Y') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'Y') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'i') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'I') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'y') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'Y') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'Y') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'y') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'Y') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'O') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'o') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'O') {\n            answer += message[i+2];\n        } else if (message[i]\
    \ == 'o') {\n            answer += message[i+1];\n        } else if (message[i]\
    \ == 'I') {\n            answer \n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8jdyrxas.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp8jdyrxas.cpp:87:19: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   87 |             answer\n      |                   ^\n      |    \
    \               ;\n   88 | }\n      | ~                  \n/tmp/tmp8jdyrxas.cpp:89:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   89 | int main() {\n      |            ^\n/tmp/tmp8jdyrxas.cpp:96:1: error:\
    \ expected \u2018}\u2019 at end of input\n   96 | }\n      | ^\n/tmp/tmp8jdyrxas.cpp:15:45:\
    \ note: to match this \u2018{\u2019\n   15 |     for(int i = 0; i < message.size();\
    \ ++i) {\n      |                                             ^\n/tmp/tmp8jdyrxas.cpp:96:1:\
    \ error: expected \u2018}\u2019 at end of input\n   96 | }\n      | ^\n/tmp/tmp8jdyrxas.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp8jdyrxas.cpp:96:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   96 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Your code\
    \ goes here\n    std::string result = message;\n    for(int i = 0; i < result.size();\
    \ i++)\n    {\n        if(islower(message[i]))\n        {\n            int index\
    \ = tolower(message[i]) - 'a';\n            result[i] = result[index];\n     \
    \   }\n    }\n    for(int i = 0; i < result.size(); i++)\n    {\n        if(isupper(message[i]))\n\
    \        {\n            int index = toupper(message[i]) - 'A';\n            result[i]\
    \ = result[index];\n        }\n    }\n    for(int i = 0; i < result.size(); i++)\n\
    \    {\n        if(message[i] == 'A' || message[i] == 'a')\n        {\n      \
    \      int index = toupper(message[i]) - 'A';\n            result[index] = 'a';\n\
    \        }\n        else if(message[i] == 'B' || message[i] == 'b')\n        {\n\
    \            int index = toupper(message[i]) - 'B';\n            result[index]\
    \ = 'b';\n        }\n        else if(message[i] == 'C' || message[i] == 'c')\n\
    \        {\n            int index = toupper(message[i]) - 'C';\n            result[index]\
    \ = 'c';\n        }\n        else if(message[i] == 'D' || message[i] == 'd')\n\
    \        {\n            int index = toupper(message[i]) - 'D';\n            result[index]\
    \ = 'd';\n        }\n        else if(message[i] == 'E' || message[i] == 'e')\n\
    \        {\n            int index = toupper(message[i]) - 'E';\n            result[index]\
    \ = 'e';\n        }\n        else if(message[i] == 'F' || message[i] == 'f')\n\
    \        {\n            int index = toupper(message[i]) - 'F';\n            result[index]\
    \ = 'f';\n        }\n        else if(message[i] == 'G' || message[i] == 'g')\n\
    \        {\n            int index = toupper(message[i]) - 'G';\n            result[index]\
    \ = 'g';\n        }\n        else if(message[i] == 'H' || message[i] == 'h')\n\
    \        {\n            int index = toupper(message[i]) - 'H';\n            result[index]\
    \ = 'h';\n        }\n        else if(message[i] == 'I' || message[i] == 'i')\n\
    \        {\n            int index = toupper(message[i]) - 'I';\n            result[index]\
    \ = 'i';\n        }\n        else if(message[i] == 'J' || message[i] == 'j')\n\
    \        {\n            int index = toupper(message[i]) - 'J';\n            result[index]\
    \ = 'j';\n        }\n        else if(message[i] == 'K' || message[i] == 'k')\n\
    \        {\n            int index = toupper(message[i]) - 'K';\n            result[index]\
    \ = 'k';\n        }\n        else if(message[i] == 'L' || message[i] == 'l')\n\
    \        {\n            int index = toupper(\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp7pj3mk1e.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp7pj3mk1e.cpp:92:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   92 | }\n      | ^\n/tmp/tmp7pj3mk1e.cpp:93:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   93 | int main() {\n     \
    \ |            ^\n/tmp/tmp7pj3mk1e.cpp:100:1: error: expected \u2018}\u2019 at\
    \ end of input\n  100 | }\n      | ^\n/tmp/tmp7pj3mk1e.cpp:33:5: note: to match\
    \ this \u2018{\u2019\n   33 |     {\n      |     ^\n/tmp/tmp7pj3mk1e.cpp:100:1:\
    \ error: expected \u2018}\u2019 at end of input\n  100 | }\n      | ^\n/tmp/tmp7pj3mk1e.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp7pj3mk1e.cpp:100:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  100 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int n =\
    \ message.size();\n    // Keep track of where we are in the alphabet\n    int\
    \ alphabet[26] = {0};\n\n    for (int i = 0; i < n; i++) {\n        // Get a char\
    \ to swap case with\n        char c = message[i];\n\n        // Swap case with\
    \ that letter\n        c = tolower(c);\n\n        // Swap vowels with that letter\n\
    \        for (int j = 0; j < 26; j++) {\n            if (c >= 'a' && c <= 'z')\n\
    \                alphabet[j] += (c - 'a' + 2);\n            if (c >= 'A' && c\
    \ <= 'Z')\n                alphabet[j] += (c - 'A' + 2);\n        }\n\n      \
    \  // Move on to the next char\n        alphabet[++alphabet[0]] = alphabet[--alphabet[0]]\
    \ + 1;\n    }\n\n    // Create new string with swapped letters\n    std::string\
    \ newMessage = \"\";\n    for (int i = 0; i < n; i++) {\n        // Get a char\
    \ to swap case with\n        char c = message[i];\n\n        // Swap case with\
    \ that letter\n        c = tolower(c);\n\n        // Check if we have the right\
    \ letter in the alphabet\n        if (alphabet[c - 'a'] == 0)\n            newMessage\
    \ += c;\n        else\n            newMessage += toupper(c + alphabet[c - 'a']);\n\
    \    }\n\n    return newMessage;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpryv5ig7v: /tmp/tmpryv5ig7v.cpp:57: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ res;\n    res.reserve(message.size() + 1);\n    for (char &c: message) {\n \
    \       if (isalpha(c)) {\n            c = toupper(c);\n            if (c != 'A'\
    \ && c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n                res += c;\n\
    \            }\n        }\n    }\n    for (char &c: res) {\n        c = tolower(c);\n\
    \    }\n    for (int i = 0; i < message.size(); ++i) {\n        std::string new_word;\n\
    \        new_word.reserve(message.size() - i);\n        for (int j = 0; j < i;\
    \ ++j) {\n            new_word += tolower(message[j]);\n        }\n        for\
    \ (int j = i; j < message.size(); ++j) {\n            new_word += toupper(message[j]);\n\
    \        }\n        res += new_word;\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpjngztb_d: /tmp/tmpjngztb_d.cpp:42: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int len =\
    \ message.size();\n  std::string encodedMessage;\n  encodedMessage.reserve(len);\n\
    \  for (int i = 0; i < len; ++i) {\n    char c = message[i];\n    // If it is\
    \ not a letter, skip it\n    if (c >= 'A' && c <= 'Z')\n      continue;\n    //\
    \ If it is the first vowel before letter, skip it\n    if (i > 0 && message[i-1]\
    \ == 'A' && c != 'A')\n      continue;\n    // If it is the second vowel before\
    \ letter, skip it\n    if (i > 1 && message[i-2] == 'A' && c != 'A')\n      continue;\n\
    \    encodedMessage += c;\n  }\n  return encodedMessage;\n}\nint main() {\n  \
    \  auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpwuys7l44: /tmp/tmpwuys7l44.cpp:34: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Write\
    \ your code here\n  std::string encodedMessage;\n  for (int i = 0; i < message.size();\
    \ i++) {\n    if (message[i] >= 65 && message[i] <= 90) {\n      encodedMessage\
    \ += std::toupper(message[i]);\n      continue;\n    }\n    encodedMessage +=\
    \ message[i];\n  }\n  return encodedMessage;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpjx4vrmlc: /tmp/tmpjx4vrmlc.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans=\"\";\n    for(int i=0;i<message.length();i++)\n    {\n        if(message[i]=='A'||message[i]=='E'||message[i]=='I'||message[i]=='O'||message[i]=='U')\n\
    \        {\n            ans+=\"G\";\n        }\n        else if(message[i]=='B'||message[i]=='D'||message[i]=='F'||message[i]=='G'||message[i]=='H'||message[i]=='J'||message[i]=='K'||message[i]=='L'||message[i]=='M'||message[i]=='N'||message[i]=='P'||message[i]=='S'||message[i]=='T'||message[i]=='W'||message[i]=='Y')\n\
    \        {\n            ans+=\"F\";\n        }\n        else\n        {\n    \
    \        ans+=\"T\";\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp7bbjj0tw: /tmp/tmp7bbjj0tw.cpp:34: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ s = message;\n    for (size_t i = 0; i < s.length(); i++) {\n        if (islower(s.at(i)))\n\
    \            s = std::string(s.at(i) + 2, s.at(i)) + std::string(s.at(i), s.at(i)\
    \ + 1);\n        else if (isupper(s.at(i)))\n            s = std::string(s.at(i)\
    \ - 2, s.at(i)) + std::string(s.at(i), s.at(i) - 1);\n    }\n    std::string ans\
    \ = s;\n    for (size_t i = 0; i < s.length(); i++) {\n        if (isalpha(ans.at(i)))\n\
    \            ans = std::string(s.at(i) - 2, s.at(i)) + std::string(s.at(i), s.at(i)\
    \ - 1);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpzrc7_6g6: /tmp/tmpzrc7_6g6.cpp:30: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // your\
    \ code goes here\n    for(int i=0;i<message.length();i++)\n    {\n        if(message[i]>='a'\
    \ && message[i]<='z')\n        {\n            char c=message[i];\n           \
    \ int p=c-'a';\n            char new_c=((message[i+1]-'a')+p)%26+'a';\n      \
    \      message[i+1]=new_c;\n        }\n        else if(message[i]>='A' && message[i]<='Z')\n\
    \        {\n            char c=message[i];\n            int p=c-'A';\n       \
    \     char new_c=((message[i+1]-'A')+p)%26+'A';\n            message[i+1]=new_c;\n\
    \        }\n        else\n        {\n            message[i+1]=message[i];\n  \
    \      }\n    }\n    return message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpfcujaqfr: /tmp/tmpfcujaqfr.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    \n\
    \    for(int i = 0; i < message.length(); i++) {\n        \n        // If current\
    \ character is a vowel, \n        // swap case with the character 2 places ahead\
    \ of it\n        if(isalpha(message[i]) && message[i] == message[i-1]){\n    \
    \        // Convert all the vowels\n            char temp = message[i-1];\n  \
    \          message[i-1] = message[i];\n            message[i] = temp;\n      \
    \      // Replace vowels with vowel 2 places ahead\n            if(message[i]\
    \ == 'a'){\n                message[i] = 'e';\n            }\n            if(message[i]\
    \ == 'e'){\n                message[i] = 'i';\n            }\n            if(message[i]\
    \ == 'i'){\n                message[i] = 'o';\n            }\n            if(message[i]\
    \ == 'o'){\n                message[i] = 'u';\n            }\n            if(message[i]\
    \ == 'u'){\n                message[i] = 'A';\n            }\n        }\n    \
    \    \n        // If current character is a consonant\n        if(isalpha(message[i])){\n\
    \            // Convert all the consonants\n            char temp = message[i];\n\
    \            message[i] = message[i+1];\n            message[i+1] = temp;\n  \
    \      }\n    }\n    return message;\n    \n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpl5fk6ddy: /tmp/tmpl5fk6ddy.cpp:56: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,char>\
    \ mp;\n    for (int i=0;i<message.length();i++){\n        mp[message[i]]= message[i];\n\
    \    }\n    for (auto iter = mp.begin();iter != mp.end();iter++){\n        char\
    \ newVowel=iter->second;\n        newVowel=getVowel(iter->first,newVowel,iter->second);\n\
    \        iter->second=newVowel;\n    }\n    std::string output;\n    for (auto\
    \ iter = mp.begin();iter != mp.end();iter++){\n        char newLetter=iter->second;\n\
    \        newLetter=getLetter(iter->first,newLetter,iter->second);\n        output.push_back(newLetter);\n\
    \    }\n    return output;\n}\nint main() {\n    auto candidate = encode;\n  \
    \  assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpmlq5qw7q.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpmlq5qw7q.cpp:20:18: error: \u2018getVowel\u2019 was not declared in\
    \ this scope; did you mean \u2018newVowel\u2019?\n   20 |         newVowel=getVowel(iter->first,newVowel,iter->second);\n\
    \      |                  ^~~~~~~~\n      |                  newVowel\n/tmp/tmpmlq5qw7q.cpp:26:19:\
    \ error: \u2018getLetter\u2019 was not declared in this scope; did you mean \u2018\
    newLetter\u2019?\n   26 |         newLetter=getLetter(iter->first,newLetter,iter->second);\n\
    \      |                   ^~~~~~~~~\n      |                   newLetter\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ s;\n    // Write your code here\n    for(int i = 0; i < message.size(); i++){\n\
    \        if (message[i] >= 'a' && message[i] <= 'z'){\n            s += message[i];\n\
    \        }\n        else if (message[i] >= 'A' && message[i] <= 'Z'){\n      \
    \      s += message[i];\n        }\n    }\n    for(int i = 0; i < message.size();\
    \ i++){\n        if (message[i] == 'a' || message[i] == 'A'){\n            int\
    \ index = message.find('a',i);\n            if(index == 0){\n                i\
    \ += 1;\n            }\n            else{\n                i += 2;\n         \
    \   }\n        }\n        else if (message[i] == 'e' || message[i] == 'E'){\n\
    \            int index = message.find('e',i);\n            if(index == 0){\n \
    \               i += 1;\n            }\n            else{\n                i +=\
    \ 2;\n            }\n        }\n        else if (message[i] == 'i' || message[i]\
    \ == 'I'){\n            int index = message.find('i',i);\n            if(index\
    \ == 0){\n                i += 1;\n            }\n            else{\n        \
    \        i += 2;\n            }\n        }\n        else if (message[i] == 'o'\
    \ || message[i] == 'O'){\n            int index = message.find('o',i);\n     \
    \       if(index == 0){\n                i += 1;\n            }\n            else{\n\
    \                i += 2;\n            }\n        }\n        else if (message[i]\
    \ == 'u' || message[i] == 'U'){\n            int index = message.find('u',i);\n\
    \            if(index == 0){\n                i += 1;\n            }\n       \
    \     else{\n                i += 2;\n            }\n        }\n        else if\
    \ (message[i] == 'A' || message[i] == 'a'){\n            int index = message.find('a',i);\n\
    \            if(index == 0){\n                i += 1;\n            }\n       \
    \     else{\n                i += 2;\n            }\n        }\n        else if\
    \ (message[i] == 'E' || message[i] == 'e'){\n            int index = message.find('e',i);\n\
    \            if(index == 0){\n                i += 1;\n            }\n       \
    \     else{\n                i += 2;\n            }\n        }\n        else if\
    \ (message[i] == 'I' || message[i] == 'i'){\n            int index = message.find('i',i);\n\
    \            if(index == 0){\n                i += 1;\n            }\n       \
    \     else{\n                i += 2;\n            }\n        }\n        else if\
    \ (message[i] == 'O' || message[i] == 'o'){\n            int index = message.find('o',i);\n\
    \            if(index == 0){\n                i += 1;\n            }\n       \
    \     else{\n                i += 2;\n            }\n        }\n        else if\
    \ (message[i] == 'U' || message[i] == 'u'){\n            int index = message.find('u',i);\n\
    \            if(index == 0){\n                i += 1;\n            }\n       \
    \     else{\n                i += 2;\n            }\n\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp2o6kddjl.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp2o6kddjl.cpp:116:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  116 | int main() {\n      |            ^\n/tmp/tmp2o6kddjl.cpp:123:1:\
    \ error: expected \u2018}\u2019 at end of input\n  123 | }\n      | ^\n/tmp/tmp2o6kddjl.cpp:24:44:\
    \ note: to match this \u2018{\u2019\n   24 |     for(int i = 0; i < message.size();\
    \ i++){\n      |                                            ^\n/tmp/tmp2o6kddjl.cpp:123:1:\
    \ error: expected \u2018}\u2019 at end of input\n  123 | }\n      | ^\n/tmp/tmp2o6kddjl.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp2o6kddjl.cpp:123:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  123 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map\
    \ <char, char> alphabet {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\n\
    \    \n    // Replace all vowels with the 2nd letter ahead of it\n    for (char\
    \ &c: message) {\n        auto it = alphabet.find(c);\n        if (it != alphabet.end())\
    \ {\n            auto place2 = alphabet.find(c, it);\n            c = alphabet[place2+1];\n\
    \        }\n    }\n    return message;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpq9hizrfh.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpq9hizrfh.cpp:14:140: error: no matching function for call to \u2018\
    std::map<char, char>::map(<brace-enclosed initializer list>)\u2019\n   14 |  \
    \   std::map <char, char> alphabet {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\n\
    \      |                                                                     \
    \                                                                       ^\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/map:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpq9hizrfh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:288:2:\
    \ note: candidate: \u2018template<class _InputIterator> std::map<_Key, _Tp, _Compare,\
    \ _Alloc>::map(_InputIterator, _InputIterator, const _Compare&, const allocator_type&)\u2019\
    \n  288 |  map(_InputIterator __first, _InputIterator __last,\n      |  ^~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:288:2: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpq9hizrfh.cpp:14:140:\
    \ note:   candidate expects 4 arguments, 26 provided\n   14 |     std::map <char,\
    \ char> alphabet {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};\n\
    \      |                                                                     \
    \                                                                       ^\nIn\
    \ file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/map:61,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpq9hizrfh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_map.h:271:2:\
    \ note: candidate: \u2018template<class _InputIterator> std::map<_Key, _Tp, _Compare,\
    \ _Alloc>::map(_InputIterator, _InputIterator)\u2019\n  271 |  map(_InputIterator\
    \ __first, _InputIter"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int vowels[26]\
    \ = { 'A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u' };\n    std::string result\
    \ = \"\";\n    for (int i = 0; i < message.length(); i++) {\n        result +=\
    \ message[i];\n    }\n    for (int i = 0; i < message.length(); i++) {\n     \
    \   result += (message[i] == message[i]) \n            ? ((message[i+3] == 'a')\
    \ ? 'A' \n            : ((message[i+3] == 'e') ? 'E' \n            : ((message[i+3]\
    \ == 'i') ? 'I' \n            : ((message[i+3] == 'o') ? 'O' \n            : ((message[i+3]\
    \ == 'u') ? 'U' \n            : ((message[i+3] == 'A') ? 'a' \n            : ((message[i+3]\
    \ == 'E') ? 'e' \n            : ((message[i+3] == 'I') ? 'i' \n            : ((message[i+3]\
    \ == 'O') ? 'o' \n            : ((message[i+3] == 'U') ? 'u' \n            : ((message[i+3]\
    \ == 'a') ? 'A' \n            : ((message[i+3] == 'e') ? 'E' \n            : ((message[i+3]\
    \ == 'i') ? 'I' \n            : ((message[i+3] == 'o') ? 'O' \n            : ((message[i+3]\
    \ == 'u') ? 'U' \n            : ((message[i+3] == 'A') ? 'a' \n            : ((message[i+3]\
    \ == 'E') ? 'e' \n            : ((message[i+3] == 'I') ? 'i' \n            : ((message[i+3]\
    \ == 'O') ? 'o' \n            : ((message[i+3] == 'U') ? 'u' \n            : ((message[i+3]\
    \ == 'a') ? 'A' \n            : ((message[i+3] == 'e') ? 'E' \n            : ((message[i+3]\
    \ == 'i') ? 'I' \n            : ((message[i+3] == 'o') ? 'O' \n            : ((message[i+3]\
    \ == 'u') ? 'U' \n            : ((message[i+3] == 'A') ? 'a' \n            : ((message[i+3]\
    \ == 'E') ? 'e' \n            : ((message[i+3] == 'I') ? 'i' \n            : ((message[i+3]\
    \ == 'O') ? 'o' \n            : ((message[i+3] == 'U') ? 'u' \n            : ((message[i+3]\
    \ == 'a') ? 'A' \n            : ((message[i+3] == 'e') ? 'E' \n            : ((message[i+3]\
    \ == 'i') ? 'I' \n            : ((message[i+3] == 'o') ? 'O' \n            : ((message[i+3]\
    \ == 'u') ? 'U\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpofhegho3.cpp:55:40: warning: missing terminating ' character\n\
    \   55 |             : ((message[i+3] == 'u') ? 'U\n      |                  \
    \                      ^\n/tmp/tmpofhegho3.cpp:55:40: error: missing terminating\
    \ ' character\n   55 |             : ((message[i+3] == 'u') ? 'U\n      |    \
    \                                    ^~\n/tmp/tmpofhegho3.cpp: In function \u2018\
    std::string encode(std::string)\u2019:\n/tmp/tmpofhegho3.cpp:56:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   56 | }\n      | ^\n/tmp/tmpofhegho3.cpp:55:39:\
    \ error: expected \u2018:\u2019 before \u2018}\u2019 token\n   55 |          \
    \   : ((message[i+3] == 'u') ? 'U\n      |                                   \
    \    ^\n      |                                       :\n   56 | }\n      | ~\
    \                                      \n/tmp/tmpofhegho3.cpp:56:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   56 | }\n      | ^\n/tmp/tmpofhegho3.cpp:55:39:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   55 |          \
    \   : ((message[i+3] == 'u') ? 'U\n      |               ~                   \
    \    ^\n      |                                       )\n   56 | }\n      | ~\
    \                                      \n/tmp/tmpofhegho3.cpp:55:39: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   55 |             : ((message[i+3]\
    \ == 'u') ? 'U\n      |                                       ^\n      |     \
    \                                  )\n   56 | }\n      | ~                   \
    \                   \n/tmp/tmpofhegho3.cpp:54:15: note: to match this \u2018(\u2019\
    \n   54 |             : ((message[i+3] == 'o') ? 'O'\n      |               ^\n\
    /tmp/tmpofhegho3.cpp:55:39: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   55 |             : ((message[i+3] == 'u') ? 'U\n      |          \
    \                             ^\n      |                                     \
    \  )\n   56 | }\n      | ~                                      \n/tmp/tmpofhegho3.cpp:53:15:\
    \ note: to match this \u2018(\u2019\n   53 |             : ((message[i+3] == 'i')\
    \ ? 'I'\n      |               ^\n/tmp/tmpofhegho3.cpp:55:39: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   55 |             : ((message[i+3]\
    \ == 'u') ? 'U\n "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ int> map;\n    for (int i = 0; i < message.size(); ++i) {\n        map[message[i]]++;\n\
    \    }\n    std::string ans = \"\";\n    for (auto &it: map) {\n        int count\
    \ = it.second;\n        ans += (count > 1) ? it.first : it.first + 1;\n      \
    \  if (count > 1)\n            ans += ((count - 2) < it.second) ? \"-\" : it.first;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp1981enqz.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp1981enqz.cpp:23:46: error: operands to ?: have different types \u2018\
    const char*\u2019 and \u2018char\u2019\n   23 |             ans += ((count - 2)\
    \ < it.second) ? \"-\" : it.first;\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ s = message;\n    for (auto &c: s) {\n        c = toupper(c);\n        c = std::tolower(c);\n\
    \    }\n\n    std::string out;\n    for (auto &c: s) {\n        if (std::isalpha(c))\
    \ {\n            int count = 1;\n            for (auto &c: s) {\n            \
    \    if (c == c) {\n                    count++;\n                }\n        \
    \    }\n            if (count == 2) {\n                out += std::tolower(c);\n\
    \            }\n        }\n    }\n\n    return out;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp29pit87l: /tmp/tmp29pit87l.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Start\
    \ with empty result.\n  std::string result;\n  // Go through each character in\
    \ the message.\n  for (int i = 0; i < message.length(); i++) {\n    // Get the\
    \ next character from the message.\n    char c = message[i];\n    // If the next\
    \ character is uppercase, then it goes in the result.\n    if (c == 'A' || c ==\
    \ 'E' || c == 'I' || c == 'O' || c == 'U') {\n      // Put it on the result as\
    \ a vowel.\n      result.push_back(c);\n    }\n    // If the next character is\
    \ lowercase, then it goes in the result.\n    else if (c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u') {\n      // Put it on the result as a vowel.\n\
    \      result.push_back(c);\n    }\n    // If the next character is an uppercase\
    \ or lowercase vowel,\n    // then it goes in the result.\n    else {\n      //\
    \ Get a random number between 0 and 26 inclusive.\n      int rand = rand() % 26;\n\
    \      // Put it on the result as a vowel.\n      result.push_back('A' + rand);\n\
    \    }\n  }\n  // Return the result.\n  return result;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpkx64vr1w.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpkx64vr1w.cpp:34:23: error: \u2018rand\u2019 cannot be used as a function\n\
    \   34 |       int rand = rand() % 26;\n      |                       ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ result;\n    for (int i = 0; i < message.size(); i++) {\n        if (message[i]\
    \ == ' ') {\n            result += ' ';\n        } else {\n            result\
    \ += message[i] + toupper(message[i]);\n        }\n    }\n    for (int i = 0;\
    \ i < message.size(); i++) {\n        if (message[i] != 'A' && message[i] != 'E'\
    \ && message[i] != 'I' && message[i] != 'O' && message[i] != 'U' && message[i]\
    \ != 'Y') {\n            result += tolower(message[i] - 64);\n        }\n    }\n\
    \    for (int i = 0; i < message.size(); i++) {\n        if (message[i] == 'A'\
    \ || message[i] == 'E' || message[i] == 'I' || message[i] == 'O' || message[i]\
    \ == 'U' || message[i] == 'Y') {\n            result += message[i] + 64;\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpw5ca5int: /tmp/tmpw5ca5int.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded = \"\";\n    for(auto &i : message) {\n        auto c = i; // c stores\
    \ the current letter\n        auto l = tolower(c); // l stores the current letter\
    \ as lowercase\n        switch(c) {\n        case 'a': case 'e': case 'i': case\
    \ 'o': case 'u':\n        case 'A': case 'E': case 'I': case 'O': case 'U':\n\
    \            encoded = encoded + l;\n            break;\n        case 'b': case\
    \ 'f': case 'l': case 'n':\n        case 'B': case 'F': case 'L': case 'N':\n\
    \            encoded = encoded + l; // l is 'B' or 'F' now\n            encoded\
    \ = encoded + l; // l is 'B' or 'F' now\n            encoded = encoded + l; //\
    \ l is 'B' or 'F' now\n            break;\n        case 'c': case 'g': case 'o':\
    \ case 's':\n        case 'C': case 'G': case 'O': case 'S':\n            encoded\
    \ = encoded + l; // l is 'C' or 'G' now\n            encoded = encoded + l; //\
    \ l is 'C' or 'G' now\n            encoded = encoded + l; // l is 'C' or 'G' now\n\
    \            encoded = encoded + l; // l is 'C' or 'G' now\n            encoded\
    \ = encoded + l; // l is 'C' or 'G' now\n            encoded = encoded + l; //\
    \ l is 'C' or 'G' now\n            encoded = encoded + l; // l is 'C' or 'G' now\n\
    \            break;\n        case 'd': case 'm': case 'p':\n        case 'D':\
    \ case 'M': case 'P':\n            encoded = encoded + l; // l is 'D' or 'M' now\n\
    \            encoded = encoded + l; // l is 'D' or 'M' now\n            encoded\
    \ = encoded + l; // l is 'D' or 'M' now\n            encoded = encoded + l; //\
    \ l is 'D' or 'M' now\n            encoded = encoded + l; // l is 'D' or 'M' now\n\
    \            encoded = encoded + l; // l is 'D' or 'M' now\n            encoded\
    \ = encoded + l; // l is 'D' or 'M' now\n            break;\n        case 'e':\
    \ case 'j': case 'y':\n        case 'E': case 'J': case 'Y':\n            encoded\
    \ = encoded + l; // l is 'E' or 'J' now\n            encoded = encoded + l; //\
    \ l is 'E' or 'J' now\n            encoded = encoded + l; // l is 'E' or 'J' now\n\
    \            encoded = encoded + l; // l is 'E' or 'J' now\n            encoded\
    \ = encoded + l; // l is 'E' or 'J' now\n            encoded = encoded + l; //\
    \ l is 'E' or 'J' now\n            encoded = encoded + l; // l is 'E' or '\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpik9enlks.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpik9enlks.cpp:21:31: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   21 |             encoded = encoded + l;\n      |  \
    \                     ~~~~~~~ ^ ~\n      |                       |         |\n\
    \      |                       |         int\n      |                       std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpik9enlks.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpik9enlks.cpp:21:33:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   21 |             encoded = encoded + l;\n      |   \
    \                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \    "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans;\n    for (int i=0; i < message.length(); i++) {\n        if (message[i]\
    \ == 'a' || message[i] == 'e' || message[i] == 'i' || message[i] == 'o' || message[i]\
    \ == 'u') {\n            ans = ans + message[i];\n        } else {\n         \
    \   int val = tolower(message[i]) - 96;\n            ans = ans + toupper(message[i]\
    \ + val);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpgj1hfzqw.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpgj1hfzqw.cpp:20:23: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018int\u2019)\n   20 |             ans = ans + toupper(message[i] + val);\n\
    \      |                   ~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~\n      |          \
    \         |            |\n      |                   |            int\n      |\
    \                   std::string {aka std::__cxx11::basic_string<char>}\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpgj1hfzqw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpgj1hfzqw.cpp:20:49:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018int\u2019\n   20 |             ans = ans + toupper(message[i] + val);\n\
    \      |                                                 ^\nIn file included from\
    \ /shared/centos7/gcc/9."
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ s = message;\n    for (int i = 0; i < s.length(); i++) {\n        if (isalpha(s[i]))\
    \ {\n            string t = s;\n            for (int j = 0; j < t.length(); j++)\
    \ {\n                if (isupper(t[j])) {\n                    t[j] += 'A' - 'a';\n\
    \                }\n                else if (islower(t[j])) {\n              \
    \      t[j] += 'a' - 'A';\n                }\n                else if (t[j] ==\
    \ ' ') {\n                    t[j] = ' ';\n                }\n            }\n\
    \            s = t;\n        }\n    }\n    for (int i = 0; i < s.length(); i++)\
    \ {\n        if (isalpha(s[i])) {\n            string t = s;\n            for\
    \ (int j = 0; j < t.length(); j++) {\n                if (isupper(t[j])) {\n \
    \                   t[j] += 'a' - 'A';\n                }\n                else\
    \ if (islower(t[j])) {\n                    t[j] += 'A' - 'a';\n             \
    \   }\n                else if (t[j] == ' ') {\n                    t[j] = ' ';\n\
    \                }\n            }\n            s = t;\n        }\n    }\n    for\
    \ (int i = 0; i < s.length(); i++) {\n        if (isalpha(s[i])) {\n         \
    \   string t = s;\n            for (int j = 0; j < t.length(); j++) {\n      \
    \          if (isupper(t[j])) {\n                    t[j] -= 'A' + 'a';\n    \
    \            }\n                else if (islower(t[j])) {\n                  \
    \  t[j] -= 'a' + 'A';\n                }\n                else if (t[j] == ' ')\
    \ {\n                    t[j] = ' ';\n                }\n            }\n     \
    \       s = t;\n        }\n    }\n    return s;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0uqpe285.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0uqpe285.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string s = message;\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0uqpe285.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp0uqpe285.cpp:15:25:\
    \ error: \u2018s\u2019 was not declared in this scope\n   15 |     for (int i\
    \ = 0; i < s.length(); i++) {\n      |                         ^\n/tmp/tmp0uqpe285.cpp:17:19:\
    \ error: expected \u2018;\u2019 before \u2018t\u2019\n   17 |             string\
    \ t = s;\n      |                   ^~\n      |                   ;\n/tmp/tmp0uqpe285.cpp:18:33:\
    \ error: \u2018t\u2019 was not declared in this scope\n   18 |             for\
    \ (int j = 0; j < t.length(); j++) {\n      |                                \
    \ ^\n/tmp/tmp0uqpe285.cpp:29:17: error: \u2018t\u2019 was not declared in this\
    \ scope\n   29 |             s = t;\n      |                 ^\n/tmp/tmp0uqpe285.cpp:32:25:\
    \ error: \u2018s\u2019 was not declared in this scope\n   32 |     for (int i\
    \ = 0; i < s.length(); i++) {\n      |                         ^\n/tmp/tmp0uqpe285.cpp:34:19:\
    \ error: expected \u2018;\u2019 before \u2018t\u2019\n   34 |             string\
    \ t = s;\n      |                   ^~\n      |                   ;\n/tmp/tmp0uqpe285.cpp:3"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int size\
    \ = message.size();\n  std::string ans = \"\";\n  for (int i = 0; i < size; i++)\
    \ {\n    char c = message[i];\n    char c1 = static_cast<char>(toupper(static_cast<unsigned\
    \ char>(c)));\n    if (c1 >= 'A' && c1 <= 'Z') {\n      c1 = c1 + 2;\n    }\n\
    \    for (int j = i; j < size; j++) {\n      char d = message[j];\n      char\
    \ d1 = static_cast<char>(toupper(static_cast<unsigned char>(d)));\n      if (d\
    \ >= 'a' && d <= 'z') {\n        d = d - 2;\n      }\n      ans += c + d1;\n \
    \   }\n    ans += c1;\n  }\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpy7__oy5n: /tmp/tmpy7__oy5n.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    \n    for\
    \ (int i = 0; i < message.length(); i++) {\n        char chr = message[i];\n \
    \       if ('A' <= chr && chr <= 'Z') {\n            std::swap(chr,message[i +\
    \ 1]);\n        }\n        if ('a' <= chr && chr <= 'z') {\n            std::swap(chr,message[i\
    \ + 2]);\n        }\n        if ('0' <= chr && chr <= '9') {\n            std::swap(chr,message[i\
    \ + 3]);\n        }\n    }\n    \n    for (int i = 0; i < message.length(); i++)\
    \ {\n        char chr = message[i];\n        if ('A' <= chr && chr <= 'Z') {\n\
    \            if (i > 0) {\n                std::swap(chr,message[i - 1]);\n  \
    \          }\n        }\n        if ('a' <= chr && chr <= 'z') {\n           \
    \ if (i > 0) {\n                std::swap(chr,message[i - 1]);\n            }\n\
    \        }\n        if ('0' <= chr && chr <= '9') {\n            if (i > 0) {\n\
    \                std::swap(chr,message[i - 1]);\n            }\n        }\n  \
    \  }\n    \n    for (int i = 0; i < message.length(); i++) {\n        char chr\
    \ = message[i];\n        if ('A' <= chr && chr <= 'Z') {\n            if (i ==\
    \ 0) {\n                std::swap(chr,message[i + 1]);\n            }\n      \
    \  }\n        if ('a' <= chr && chr <= 'z') {\n            if (i == 0) {\n   \
    \             std::swap(chr,message[i + 1]);\n            }\n        }\n     \
    \   if ('0' <= chr && chr <= '9') {\n            if (i == 0) {\n             \
    \   std::swap(chr,message[i + 1]);\n            }\n        }\n    }\n    \n  \
    \  for (int i = 0; i < message.length(); i++) {\n        char chr = message[i];\n\
    \        if ('A' <= chr && chr <= 'Z') {\n            if (i == 1) {\n        \
    \        std::swap(chr,message[i + 1]);\n            }\n        }\n        if\
    \ ('a' <= chr && chr <= 'z') {\n            if (i == 1) {\n                std::swap(chr,message[i\
    \ + 1]);\n            }\n        }\n        if ('0' <= chr && chr <= '9') {\n\
    \            if (i == 1) {\n                std::swap(chr,message[i + 1]);\n \
    \           }\n        }\n    }\n    \n    for (int i = 0; i < message.length();\
    \ i++) {\n        char chr = message[i];\n        if ('A' <= chr && chr <= 'Z')\
    \ {\n            if (i == 2) {\n                std::swap(chr,message[i + 1]);\n\
    \            }\n        }\n        if ('a' <= chr && chr <= 'z') {\n         \
    \   if (i == 2) {\n                std::swap\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp3p8813zj.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp3p8813zj.cpp:94:26: error: expected \u2018;\u2019 before \u2018}\u2019\
    \ token\n   94 |                 std::swap\n      |                          ^\n\
    \      |                          ;\n   95 | }\n      | ~                    \
    \     \n/tmp/tmp3p8813zj.cpp:95:1: error: statement cannot resolve address of\
    \ overloaded function\n   95 | }\n      | ^\n/tmp/tmp3p8813zj.cpp:96:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   96\
    \ | int main() {\n      |            ^\n/tmp/tmp3p8813zj.cpp:103:1: error: expected\
    \ \u2018}\u2019 at end of input\n  103 | }\n      | ^\n/tmp/tmp3p8813zj.cpp:92:39:\
    \ note: to match this \u2018{\u2019\n   92 |         if ('a' <= chr && chr <=\
    \ 'z') {\n      |                                       ^\n/tmp/tmp3p8813zj.cpp:103:1:\
    \ error: expected \u2018}\u2019 at end of input\n  103 | }\n      | ^\n/tmp/tmp3p8813zj.cpp:85:48:\
    \ note: to match this \u2018{\u2019\n   85 |     for (int i = 0; i < message.length();\
    \ i++) {\n      |                                                ^\n/tmp/tmp3p8813zj.cpp:103:1:\
    \ error: expected \u2018}\u2019 at end of input\n  103 | }\n      | ^\n/tmp/tmp3p8813zj.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmp3p8813zj.cpp:103:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  103 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,\
    \ int> vowels;\n    for (char c : message)\n        vowels[c] = 2;\n    for (char\
    \ c : message) {\n        if (c == 'A') c = 'B';\n        else if (c == 'E') c\
    \ = 'F';\n        else if (c == 'I') c = 'J';\n        else if (c == 'O') c =\
    \ 'M';\n        else if (c == 'U') c = 'N';\n        else if (c == 'Y') c = 'R';\n\
    \        else if (c == 'a') c = 'b';\n        else if (c == 'e') c = 'f';\n  \
    \      else if (c == 'i') c = 'j';\n        else if (c == 'o') c = 'm';\n    \
    \    else if (c == 'u') c = 'n';\n        else if (c == 'y') c = 'r';\n    }\n\
    \    std::string out = message;\n    for (char c : message) {\n        int prev\
    \ = vowels[c];\n        if (prev != 0) {\n            out += (prev + 2) % 2 +\
    \ 'a';\n        } else {\n            out += c;\n        }\n        vowels[c]\
    \ %= 2;\n    }\n    return out;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpxgk4vmk_: /tmp/tmpxgk4vmk_.cpp:45: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for(size_t\
    \ i=0; i<message.length(); i++) {\n        char letter = message[i];\n       \
    \ if(letter == 'A' || letter == 'a' || letter == 'E' || letter == 'e' || letter\
    \ == 'I' || letter == 'i' || letter == 'O' || letter == 'o' || letter == 'U' ||\
    \ letter == 'u') {\n            message[i] = letter + 2;\n        }\n        if(letter\
    \ == 'B' || letter == 'b' || letter == 'C' || letter == 'c' || letter == 'G' ||\
    \ letter == 'g' || letter == 'H' || letter == 'h' || letter == 'K' || letter ==\
    \ 'k' || letter == 'M' || letter == 'm' || letter == 'S' || letter == 's' || letter\
    \ == 'T' || letter == 't' || letter == 'W' || letter == 'w' || letter == 'Y' ||\
    \ letter == 'y') {\n            message[i] = letter + 3;\n        }\n        if(letter\
    \ == 'F' || letter == 'f' || letter == 'J' || letter == 'j' || letter == 'L' ||\
    \ letter == 'l' || letter == 'N' || letter == 'n' || letter == 'P' || letter ==\
    \ 'p' || letter == 'R' || letter == 'r' || letter == 'Z' || letter == 'z' || letter\
    \ == 'a' || letter == 'c' || letter == 'g' || letter == 'h' || letter == 'j' ||\
    \ letter == 'm' || letter == 's' || letter == 't' || letter == 'w' || letter ==\
    \ 'y' || letter == 'z') {\n            message[i] = letter;\n        }\n    }\n\
    \    \n    std::string newMessage = \"\";\n    for(size_t i=0; i<message.length();\
    \ i++) {\n        newMessage += message[i];\n    }\n    return newMessage;\n}\n\
    int main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpmz_860gf: /tmp/tmpmz_860gf.cpp:35: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  // Your code\
    \ here\n  // ...\n  return answer;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpo4nkc9jj.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpo4nkc9jj.cpp:16:10: error: \u2018answer\u2019 was not declared in this\
    \ scope\n   16 |   return answer;\n      |          ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  std::map<char,\
    \ int> vowel;\n  vowel['a'] = 1;\n  vowel['b'] = 1;\n  vowel['c'] = 1;\n  vowel['d']\
    \ = 1;\n  vowel['e'] = 1;\n  vowel['f'] = 1;\n  vowel['g'] = 1;\n  vowel['h']\
    \ = 1;\n  vowel['i'] = 1;\n  vowel['j'] = 1;\n  vowel['k'] = 1;\n  vowel['l']\
    \ = 1;\n  vowel['m'] = 1;\n  vowel['n'] = 1;\n  vowel['o'] = 1;\n  vowel['p']\
    \ = 1;\n  vowel['q'] = 1;\n  vowel['r'] = 1;\n  vowel['s'] = 1;\n  vowel['t']\
    \ = 1;\n  vowel['u'] = 1;\n  vowel['v'] = 1;\n  vowel['w'] = 1;\n  vowel['x']\
    \ = 1;\n  vowel['y'] = 1;\n  vowel['z'] = 1;\n  std::string res;\n  for(int i\
    \ = 0; i < message.length(); i++) {\n    if((message[i] >= 'a') && (message[i]\
    \ <= 'z')) {\n      res += message[i];\n      res += vowel[message[i]];\n    \
    \  res += vowel[message[(i+1)]];\n      i++;\n    }\n  }\n  return res;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpq3zo55rg: /tmp/tmpq3zo55rg.cpp:54: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ s;\n    for (auto &c: message) c = tolower(c);\n    for (auto &c: message) if\
    \ (isalpha(c)) c = toupper(c);\n    for (auto &c: message) if (islower(c)) c =\
    \ toupper(c);\n    for (auto &c: message) if (isupper(c)) c = tolower(c);\n  \
    \  for (auto &c: message) {\n        if (isalpha(c)) s += c;\n        if (isupper(c))\
    \ s += toupper(c);\n        if (islower(c)) s += tolower(c);\n        if (isalpha(c)\
    \ && isupper(c) && islower(c)) s += c;\n        if (isupper(c) && islower(c))\
    \ s += toupper(c);\n        if (isupper(c) && isalpha(c) && islower(c)) s += toupper(c);\n\
    \    }\n    return s;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp60cqpxxq: /tmp/tmp60cqpxxq.cpp:31: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::map<char,int>\
    \ vowels;\n    vowels['a'] = 1;\n    vowels['e'] = 1;\n    vowels['i'] = 1;\n\
    \    vowels['o'] = 1;\n    vowels['u'] = 2;\n    std::map<char,int> newVowels;\n\
    \    newVowels['a'] = 1;\n    newVowels['e'] = 2;\n    newVowels['i'] = 2;\n \
    \   newVowels['o'] = 2;\n    newVowels['u'] = 2;\n\n    for(int i = 0; i < message.length();\
    \ i++) {\n        auto it = vowels.find(message[i]);\n        if(it != vowels.end())\
    \ {\n            auto index = vowels.find(message[i]);\n            vowels[message[i]]\
    \ = it->second;\n            vowels[message[i+index]] = it->second;\n        }\n\
    \    }\n\n    for(auto it : vowels) {\n        for(int i = 0; i < it.second; i++)\
    \ {\n            auto index = newVowels.find(it.first);\n            newVowels[it.first]\
    \ = index;\n        }\n    }\n    std::string encoded = \"\";\n    for(int i =\
    \ 0; i < message.length(); i++) {\n        encoded.push_back(newVowels[message[i]]);\n\
    \    }\n    return encoded;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzh98p4og.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpzh98p4og.cpp:32:29: error: no match for \u2018operator+\u2019 (operand\
    \ types are \u2018int\u2019 and \u2018std::_Rb_tree_iterator<std::pair<const char,\
    \ int> >\u2019)\n   32 |             vowels[message[i+index]] = it->second;\n\
    \      |                            ~^~~~~~\n      |                         \
    \   | |\n      |                            | std::_Rb_tree_iterator<std::pair<const\
    \ char, int> >\n      |                            int\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpzh98p4og.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:423:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpzh98p4og.cpp:32:30:\
    \ note:   \u2018std::_Rb_tree_iterator<std::pair<const char, int> >\u2019 is not\
    \ derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   32 |   \
    \          vowels[message[i+index]] = it->second;\n      |                   \
    \           ^~~~~\nIn file included from "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n// Code here\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp7gp08hct: /tmp/tmp7gp08hct.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = \"\";\n    for (char c : message) {\n        if ('a' <= c && c <= 'z')\
    \ {\n            ans += c; // no vowels here\n        } else if (c == 'e') {\n\
    \            ans += 'f'; ans += 'a'; ans += 'a';\n        } else if (c == 'i')\
    \ {\n            ans += 'o'; ans += 'o'; ans += 'u';\n        } else if (c ==\
    \ 'o') {\n            ans += 'o'; ans += 'u'; ans += 'u';\n        } else if (c\
    \ == 'u') {\n            ans += 'u'; ans += 'u'; ans += 'u';\n        } else if\
    \ (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ans\
    \ += c; // vowels here\n        } else {\n            ans += 'a'; ans += 'a';\
    \ ans += 'a';\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1m8d5tsj: /tmp/tmp1m8d5tsj.cpp:36: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n\tstd::map<char,\
    \ char> m;\n\tfor (int i = 0; i < message.length(); ++i) {\n\t\tchar c = tolower(message[i]);\n\
    \t\tc = (c == 'a') ? 'b' : (isalpha(c)) ? tolower(c) : c;\n\t\tm[c] = tolower(message[i]);\n\
    \t}\n\tstd::string answer;\n\tfor (int i = 0; i < message.length(); ++i) {\n\t\
    \tchar c = tolower(message[i]);\n\t\tif (isalpha(c)) {\n\t\t\tanswer.append(m[c]);\n\
    \t\t\tanswer.append(tolower(message[i]));\n\t\t}\n\t}\n\treturn answer;\n}\nint\
    \ main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) ==\
    \ (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg_3gbxax.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpg_3gbxax.cpp:24:22: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::append(std::map<char, char>::mapped_type&)\u2019\
    \n   24 |    answer.append(m[c]);\n      |                      ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n      \
    \           from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpg_3gbxax.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with\
    \ _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]\u2019\
    \ <near match>\n 1263 |       append(const _CharT* __s)\n      |       ^~~~~~\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1263:7:\
    \ note:   conversion of argument 1 would be ill-formed:\n/tmp/tmpg_3gbxax.cpp:24:22:\
    \ error: invalid conversion from \u2018std::map<char, char>::mapped_type\u2019\
    \ {aka \u2018char\u2019} to \u2018const char*\u2019 [-fpermissive]\n   24 |  \
    \  answer.append(m[c]);\n      |                      ^\n      |             \
    \         |\n      |                      std::map<char, char>::mapped_type {aka\
    \ char}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/st"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n    string vowels = \"aeiouy\";\n\
    \    string swapped = \"AEIOUY\";\n    int vowelIndex = 0;\n    int nextVowelIndex\
    \ = 0;\n    string encodedMessage = \"\";\n    for (auto &letter: message) {\n\
    \        if (alphabet.find(letter) != string::npos){\n            encodedMessage\
    \ += swapped[alphabet.find(letter)];\n        }\n        \n        if (vowels.find(letter)\
    \ != string::npos){\n            nextVowelIndex = alphabet.find(vowels[vowelIndex]);\n\
    \            encodedMessage += swapped[nextVowelIndex];\n            vowelIndex++;\n\
    \        }\n    }\n    \n    return encodedMessage;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpysmxhh7_.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpysmxhh7_.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\";\n      |     ^~~~~~\n      |     std::string\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpysmxhh7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpysmxhh7_.cpp:15:11:\
    \ error: expected \u2018;\u2019 before \u2018vowels\u2019\n   15 |     string\
    \ vowels = \"aeiouy\";\n      |           ^~~~~~~\n      |           ;\n/tmp/tmpysmxhh7_.cpp:16:11:\
    \ error: expected \u2018;\u2019 before \u2018swapped\u2019\n   16 |     string\
    \ swapped = \"AEIOUY\";\n      |           ^~~~~~~~\n      |           ;\n/tmp/tmpysmxhh7_.cpp:19:11:\
    \ error: expected \u2018;\u2019 before \u2018encodedMessage\u2019\n   19 |   \
    \  string encodedMessage = \"\";\n      |           ^~~~~~~~~~~~~~~\n      | \
    \          ;\n/tmp/tmpysmxhh7_.cpp:21:13: error: \u2018alphabet\u2019 was not\
    \ declared in this scope\n   21 |         if (alphabet.find(letter) != string::npos){\n\
    \      |             ^~~~~~~~\n/tmp/tmpysmxhh7_.cpp:21:38: error: \u2018string\u2019\
    \ is not a class, namespace, or enumeration\n   21 |         if (alphabet.find(letter)\
    \ != string::npos){\n      |                                      ^~~~~~\n/tmp/tmpysmxhh7_.cpp:22:13:\
    \ error: \u2018encodedMessage\u2019 was not declared "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // TODO:\
    \ write your implementation here\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp619ymyj2: /tmp/tmp619ymyj2.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  for(int i\
    \ = 0; i<message.length(); i++){\n    if (message[i] == ' ') \n      message.erase(message.begin()+i);\
    \ \n    else if (message[i] >= 'a' && message[i] <= 'z'){\n      int letter =\
    \ message[i] - 'a';\n      int letter_2 = letter+2;\n      std::string letters\
    \ = \"\";\n      \n      if(letter_2 < 26){\n        letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    ;\n      }\n      else {\n        letters = \"abcdefghijklmnopqrstuvwxyz\";\n\
    \      }\n      \n      message.erase(message.begin()+i, 1); \n      message.insert(message.begin()+i,\
    \ letters[letter]);\n      message.insert(message.begin()+i+1, letters[letter_2]);\n\
    \    }\n  }\n  return message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpsv26md_y.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpsv26md_y.cpp:29:41: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::erase(__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >, int)\u2019\n   29 |       message.erase(message.begin()+i, 1);\n      | \
    \                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpsv26md_y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1807:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::erase(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 1807 |       erase(size_type __pos = 0, size_type __n = npos)\n\
    \      |       ^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1807:23:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<ch"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ret; \n    for (char c : message) {\n        switch (c) {\n        case 'a':\
    \ case 'e':\n        case 'i': case 'o':\n        case 'u':\n            ret +=\
    \ std::toupper(c);\n            break;\n        case 'g':\n            ret +=\
    \ 'N';\n            break;\n        default:\n            ret += c;\n        }\n\
    \    }\n    return ret; \n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp0x4hlmjn: /tmp/tmp0x4hlmjn.cpp:33: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Your\
    \ code here\n    int len = message.length();\n    std::string out(len, 'a');\n\
    \    for(int i = 0; i < len; i++){\n        if(message[i] >= 'a' && message[i]\
    \ <= 'z'){\n            int pos1 = ((message[i] - 'a') + 2);\n            int\
    \ pos2 = ((message[i] - 'a') + 1);\n            out[i] = message[pos1];\n    \
    \        out[pos2] = message[i];\n        }\n        else if(message[i] >= 'A'\
    \ && message[i] <= 'Z'){\n            int pos1 = ((message[i] - 'A') + 2);\n \
    \           int pos2 = ((message[i] - 'A') + 1);\n            out[i] = message[pos1];\n\
    \            out[pos2] = message[i];\n        }\n        else{\n            out[i]\
    \ = message[i];\n        }\n    }\n    return out;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: -11
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::unordered_map<char,char>\
    \ vows;\n    std::string s;\n    for (int i=0; i<message.length(); i++)\n    \
    \    vows[message[i]]='A'+i;\n    for (int i=0; i<message.length(); i++) {\n \
    \       char c = message[i];\n        std::unordered_map<char,char>::iterator\
    \ it;\n        it = vows.find(c);\n        char vow = it != vows.end()? it->second:\
    \ 'A'+i;\n        s += vow;\n    }\n    std::string res = s;\n    for (int i=0;\
    \ i<message.length(); i++)\n        vows[res[i]] = message[i];\n    return s;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpi10pi0ny: /tmp/tmpi10pi0ny.cpp:32: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for (auto\
    \ &c : message) {\n        if (c == 'a') c = 'b';\n        if (c == 'e') c = 'f';\n\
    \        if (c == 'i') c = 'h';\n        if (c == 'o') c = 'r';\n        if (c\
    \ == 'u') c = 't';\n    }\n    for (auto &c : message) {\n        if (c != 'A'\
    \ && c != 'E' && c != 'I' && c != 'O' && c != 'U')\n            std::swap(message[0],\
    \ message[message.size() - 2]);\n    }\n    for (auto &c : message) {\n      \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n         \
    \   std::swap(message[0], message[message.size() - 2]);\n        }\n    }\n  \
    \  for (auto &c : message) {\n        if (c == 'a' || c == 'b' || c == 'c' ||\
    \ c == 'd' || c == 'e' || c == 'f' || c == 'g' || c == 'h' || c == 'i' || c ==\
    \ 'j' || c == 'k' || c == 'l' || c == 'm' || c == 'n' || c == 'o' || c == 'p'\
    \ || c == 'q' || c == 'r' || c == 's' || c == 't' || c == 'u' || c == 'v' || c\
    \ == 'w' || c == 'x' || c == 'y' || c == 'z')\n            std::swap(message[0],\
    \ message[message.size() - 2]);\n    }\n    for (auto &c : message) {\n      \
    \  if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n         \
    \   std::swap(message[0], message[message.size() - 2]);\n        }\n    }\n  \
    \  for (auto &c : message) {\n        if (c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n            std::swap(message[0], message[message.size()\
    \ - 2]);\n        }\n    }\n    for (auto &c : message) {\n        if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            std::swap(message[0],\
    \ message[message.size() - 2]);\n        }\n    }\n    for (auto &c : message)\
    \ {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n\
    \            std::swap(message[0], message[message.size() - 2]);\n        }\n\
    \    }\n    for (auto &c : message) {\n        if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n            std::swap(message[0], \n}\nint main()\
    \ {\n    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"\
    ));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpwfygrlx3.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpwfygrlx3.cpp:57:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   57 | }\n      | ^\n/tmp/tmpwfygrlx3.cpp:58:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   58 | int main() {\n     \
    \ |            ^\n/tmp/tmpwfygrlx3.cpp:65:1: error: expected \u2018}\u2019 at\
    \ end of input\n   65 | }\n      | ^\n/tmp/tmpwfygrlx3.cpp:54:29: note: to match\
    \ this \u2018{\u2019\n   54 |     for (auto &c : message) {\n      |         \
    \                    ^\n/tmp/tmpwfygrlx3.cpp:65:1: error: expected \u2018}\u2019\
    \ at end of input\n   65 | }\n      | ^\n/tmp/tmpwfygrlx3.cpp:13:41: note: to\
    \ match this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n\
    \      |                                         ^\n/tmp/tmpwfygrlx3.cpp:65:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   65 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::unordered_map<char,\
    \ int> u;\n    for (int i = 0; i < 26; i++) {\n        u.insert(std::pair<char,\
    \ int>(static_cast<char>(i + 'a'), i));\n    }\n\n    for (int i = 0; i < message.size();\
    \ i++) {\n        int curr = u[message[i]];\n        for (int j = i; j < message.size();\
    \ j++) {\n            if (message[j] >= 'a' && message[j] <= 'z') {\n        \
    \        if (curr != u[message[j]]) {\n                    swap(u[message[j]],\
    \ u[message[j + 2]]);\n                }\n            }\n        }\n    }\n\n\
    \    std::string ans = \"\";\n    for (int i = 0; i < message.size(); i++) {\n\
    \        ans += message[i];\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpaks8t8qn.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpaks8t8qn.cpp:24:21: error: \u2018swap\u2019 was not declared in this\
    \ scope\n   24 |                     swap(u[message[j]], u[message[j + 2]]);\n\
    \      |                     ^~~~\n/tmp/tmpaks8t8qn.cpp:24:21: note: suggested\
    \ alternatives:\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/regex:62,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpaks8t8qn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/regex.h:2029:5:\
    \ note:   \u2018std::__cxx11::swap\u2019\n 2029 |     swap(match_results<_Bi_iter,\
    \ _Alloc>& __lhs,\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:143,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpaks8t8qn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/exception_ptr.h:166:5:\
    \ note:   \u2018std::__exception_ptr::swap\u2019\n  166 |     swap(exception_ptr&\
    \ __lhs, exception_ptr& __rhs)\n      |     ^~~~\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/nested_exception.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/exception:144,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \              "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Your\
    \ code here\n    \n    // Step 1: make a vector with 26 characters \n    std::string\
    \ alphabet (\"abcdefghijklmnopqrstuvwxyz\");\n    std::vector<std::string> vowels=\
    \ {\"a\", \"e\", \"i\", \"o\", \"u\", \"y\"};\n\n    // Step 2: Iterate through\
    \ each character of the message\n    //        check if it matches any vowel,\
    \ and if it does, \n    //        subtract the index of this vowel from this character's\
    \ index\n    for (int i = 0; i < message.length(); i++) {\n        if (std::find(vowels.begin(),\
    \ vowels.end(), message[i]) != vowels.end()) {\n            int index = alphabet.find(message[i]);\n\
    \            std::string new_string = (alphabet[index] - 2) + 'a';\n         \
    \   alphabet.erase(index, 1);\n            alphabet.insert(index, new_string);\n\
    \        }\n    }\n\n    // Step 3: Iterate through each character of the message\n\
    \    //        check if it matches any letter, and if it does, \n    //      \
    \  subtract the index of this letter's index\n    for (int i = 0; i < message.length();\
    \ i++) {\n        if (std::find(alphabet.begin(), alphabet.end(), message[i])\
    \ != alphabet.end()) {\n            int index = alphabet.find(message[i]);\n \
    \           std::string new_string = (alphabet[index] - 1) + 'a';\n          \
    \  alphabet.erase(index, 1);\n            alphabet.insert(index, new_string);\n\
    \        }\n    }\n\n    // Step 4: Iterate through each character of the message\n\
    \    //        check if it matches the beginning of a letter, \n    //       \
    \ and if it does, remove it from the string\n    for (int i = 0; i < message.length();\
    \ i++) {\n        if (std::find(alphabet.begin(), alphabet.end(), message[i])\
    \ == alphabet.begin()) {\n            alphabet.erase(message[i]);\n        }\n\
    \    }\n\n    // Step 5: Iterate through each character of the message\n    //\
    \        check if it matches the end of the letter, \n    //        and if it\
    \ does, remove it from the string\n    for (int i = 0; i < message.length(); i++)\
    \ {\n        if (std::find(alphabet.end(), alphabet.begin(), message[i]) == alphabet.end())\
    \ {\n            alphabet.erase(message[i]);\n        }\n    }\n\n    // Step\
    \ 6: Iterate through the remaining letters \n    //        and add each character\
    \ to the output string\n    for (int i = 0; i < alphabet.length(); i++) {\n  \
    \      message += alphabet[i];\n    }\n    return message;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpzloo2ly6.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpzloo2ly6.cpp:26:60: error: conversion from \u2018int\u2019 to non-scalar\
    \ type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } requested\n   26 |             std::string new_string = (alphabet[index] - 2)\
    \ + 'a';\n      |                                      ~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpzloo2ly6.cpp:38:60: error: conversion from \u2018int\u2019 to non-scalar\
    \ type \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } requested\n   38 |             std::string new_string = (alphabet[index] - 1)\
    \ + 'a';\n      |                                      ~~~~~~~~~~~~~~~~~~~~~~^~~~~\n\
    In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:71,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpzloo2ly6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Value = const char]\u2019\
    :\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algo.h:120:14:\
    \   required from \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator,\
    \ _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_s"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int index\
    \ = 0;\n    for (int i = 0; i < message.length(); i++) {\n        if (message[i]\
    \ >= 65 && message[i] <= 90) {\n            index = index - 2;\n            message[i]\
    \ = message[i] + index;\n        } else if (message[i] >= 97 && message[i] <=\
    \ 122) {\n            index = index - 1;\n            message[i] = message[i]\
    \ + index;\n        }\n    }\n    return message;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpqxah65m3: /tmp/tmpqxah65m3.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ res;\n    for (int i = 0; i < message.length(); i++) {\n        int n = message[i]-'a';\n\
    \        if (n<0) n=n*-1+26;\n        else if (n>26) n=n*-2-1;\n        else n\
    \ = n;\n        res += message[i];\n        res += message[i+n];\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp8ymnj2s5: /tmp/tmp8ymnj2s5.cpp:27: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ ans = message;\n    for(auto &c:ans){\n        if(c >= 'a' && c <= 'z'){\n \
    \           c = tolower(c);\n        }\n        else if(c == 'A' || c == 'E' ||\
    \ c == 'I' || c == 'O' || c == 'U'){\n            char temp = c;\n           \
    \ c = toupper(c+1);\n            ans.push_back(temp);\n        }\n        else\
    \ if(c == 'B' || c == 'K' || c == 'M' || c == 'O' || c == 'Q' || c == 'S' || c\
    \ == 'U'){\n            char temp = c;\n            c = tolower(c+1);\n      \
    \      ans.push_back(temp);\n        }\n    }\n    for(auto &c:ans){\n       \
    \ std::cout << c << ' ';\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: 'T F t T E S '
  stderr: "tmp3b7f23ne: /tmp/tmp3b7f23ne.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n\tstd::string\
    \ encoded_message = \"\";\n\tfor (auto &i : message) {\n\t\ti = tolower(i);\n\t\
    \t\n\t\tif (isalpha(i)) {\n\t\t\tfor (auto &v : vowels) {\n\t\t\t\tif (i == v)\
    \ { \n\t\t\t\t\ti = vowels[vowels.find(i) + 2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\
    \tencoded_message += i;\n\t}\n\treturn encoded_message;\n}\nint main() {\n   \
    \ auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpyogfnrv7.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpyogfnrv7.cpp:19:19: error: \u2018vowels\u2019 was not declared in this\
    \ scope\n   19 |    for (auto &v : vowels) {\n      |                   ^~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  std::string\
    \ result;\n  int len = message.length();\n  // Case change\n  for(int i = 0; i\
    \ < len; ++i) {\n    if(message[i] == 'a') {\n      result[i] = 'b';\n    } else\
    \ if (message[i] == 'b') {\n      result[i] = 'a';\n    }\n  }\n  // Vowel to\
    \ letter change\n  for(int i = 0; i < len; ++i) {\n    if(message[i] == 'A' ||\
    \ message[i] == 'a') {\n      if(result[i - 1] == 'a') {\n        result[i-1]\
    \ = 'b';\n      }\n      result[len-i-1] = 'B';\n    }\n    if(message[i] == 'B'\
    \ || message[i] == 'b') {\n      if(result[i - 1] == 'b') {\n        result[i-1]\
    \ = 'a';\n      }\n      result[len-i-1] = 'A';\n    }\n  }\n  // All other letters\
    \ are unchanged\n  for(int i = 0; i < len; ++i) {\n    if(message[i] != 'A' &&\
    \ message[i] != 'a' && message[i] != 'B' && message[i] != 'b' && message[i] !=\
    \ 'a' && message[i] != 'B' && message[i] != 'b') {\n      result[i] = message[i];\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp30vv1dyd: /tmp/tmp30vv1dyd.cpp:49: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    // Your code goes here!\n    return encoded;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp8pqje_dk: /tmp/tmp8pqje_dk.cpp:20: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ encoded = \"\";\n    // Your code goes here\n    for(int i = 0; i < message.length();\
    \ i++)\n    {\n        if(message[i] == 'A')\n            encoded += message[i];\n\
    \        else if(message[i] == 'a' || message[i] == 'e' || message[i] == 'i' ||\
    \ message[i] == 'o' || message[i] == 'u')\n            encoded += message[i] +\
    \ message[i + 2];\n    }\n    return encoded;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpvf37ez1p.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpvf37ez1p.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string encoded = \"\
    \";\n      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvf37ez1p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmpvf37ez1p.cpp:19:13:\
    \ error: \u2018encoded\u2019 was not declared in this scope; did you mean \u2018\
    encode\u2019?\n   19 |             encoded += message[i];\n      |           \
    \  ^~~~~~~\n      |             encode\n/tmp/tmpvf37ez1p.cpp:21:13: error: \u2018\
    encoded\u2019 was not declared in this scope; did you mean \u2018encode\u2019\
    ?\n   21 |             encoded += message[i] + message[i + 2];\n      |      \
    \       ^~~~~~~\n      |             encode\n/tmp/tmpvf37ez1p.cpp:23:12: error:\
    \ \u2018encoded\u2019 was not declared in this scope; did you mean \u2018encode\u2019\
    ?\n   23 |     return encoded;\n      |            ^~~~~~~\n      |          \
    \  encode\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    assert(!message.empty());\n\
    \    std::string encodedMessage = \"\";\n    int vowels[26] = {\n        0, 1\
    \ , 2, 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18\
    \ , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27\n    };\n    for(int i = 0; i <\
    \ message.length(); i++) {\n        char currentChar = message[i];\n        if(currentChar\
    \ >= 'a' && currentChar <= 'z') {\n            char nextChar = message[i+1];\n\
    \            char prevChar = message[i-1];\n            char nextVowel = vowels[(nextChar\
    \ - 'a' + 1)];\n            char prevVowel = vowels[(prevChar - 'a' + 1)];\n \
    \           if(nextVowel == prevVowel) {\n                encodedMessage += currentChar;\n\
    \            } else {\n                encodedMessage += currentChar + prevVowel;\n\
    \            }\n        } else {\n            encodedMessage += currentChar;\n\
    \        }\n    }\n    return encodedMessage;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmph01yb0ic.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmph01yb0ic.cpp:18:5: error: too many initializers for \u2018int [26]\u2019\
    \n   18 |     };\n      |     ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    for (auto&\
    \ c : message) {\n        if (isalpha(c)) {\n            char new_c = toupper(c);\n\
    \            int next_position = find(message.begin(), message.end(), new_c);\n\
    \            if (next_position != message.end()) {\n                c = toupper(message.at(next_position\
    \ + 1));\n            }\n            else if (next_position == message.end())\
    \ {\n                c = toupper(c);\n            }\n            else {\n    \
    \            c = '0';\n            }\n        }\n    }\n    return message;\n\
    }\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"TEST\"\
    )) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n \
    \   assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"This is\
    \ a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw\
    \ WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpcirnsgya.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpcirnsgya.cpp:17:37: error: cannot convert \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018int\u2019 in initialization\n\
    \   17 |             int next_position = find(message.begin(), message.end(),\
    \ new_c);\n      |                                 ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |                                     |\n      |                      \
    \               __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\n/tmp/tmpcirnsgya.cpp:18:31: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018int\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   18 |             if (next_position != message.end()) {\n     \
    \ |                 ~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~\n      |                 |\
    \                           |\n      |                 int                   \
    \      std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/char_traits.h:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpcirnsgya.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:900:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Your\
    \ code goes here\n    std::string res = \"\";\n    for(int i = 0; i < message.length();\
    \ i++){\n        if(message[i] >= 'a' && message[i] <= 'z'){\n            int\
    \ pos = message[i] - 'a';\n            res += message[i];\n            res +=\
    \ (pos + 1) % 2 + 'a';\n        }else{\n            res += message[i];\n     \
    \   }\n    }\n    return res;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1ygy_30q: /tmp/tmp1ygy_30q.cpp:29: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    int i =\
    \ 0;\n    int vowels[26] = {0};\n    int lenght = message.length();\n    while\
    \ (i < lenght) {\n        if (message[i] >= 'a' && message[i] <= 'z') {\n    \
    \        vowels[tolower(message[i] - 'a')]++;\n        }\n        else if (message[i]\
    \ >= 'A' && message[i] <= 'Z') {\n            vowels[tolower(message[i] - 'A')]++;\n\
    \        }\n        else {\n            message[i] = message[i+1];\n        }\n\
    \        i++;\n    }\n    for (i = 0; i < 26; i++) {\n        if (vowels[i] >=\
    \ 2) {\n            std::swap(message[i], message[26 - i]);\n        }\n    }\n\
    \    std::string encoded = \"\";\n    int counter = 0;\n    while(counter < lenght\
    \ && counter < message.length()){\n        int index = find(message, message[counter],\
    \ 0);\n        if (index == message.length()-1) break;\n        if (message[counter]\
    \ >= 'a' && message[counter] <= 'z') {\n            encoded += message[counter];\n\
    \        }\n        else {\n            encoded += tolower(message[counter]);\n\
    \        }\n        counter++;\n    }\n    return encoded;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp4e5sw5qp.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp4e5sw5qp.cpp:37:54: error: no matching function for call to \u2018\
    find(std::string&, __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type&,\
    \ int)\u2019\n   37 |         int index = find(message, message[counter], 0);\n\
    \      |                                                      ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_facets.h:48,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_ios.h:37,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:44,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp4e5sw5qp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/streambuf_iterator.h:373:5:\
    \ note: candidate: \u2018template<class _CharT2> typename __gnu_cxx::__enable_if<std::__is_char<_CharT2>::__value,\
    \ std::istreambuf_iterator<_CharT> >::__type std::find(std::istreambuf_iterator<_CharT>,\
    \ std::istreambuf_iterator<_CharT>, const _CharT2&)\u2019\n  373 |     find(istreambuf_iterator<_CharT>\
    \ __first,\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/streambuf_iterator.h:373:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp4e5sw5qp.cpp:37:54:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    std::istreambuf_iterator<_CharT>\u2019\n   37 |         int index = find(message,\
    \ message[counter], 0);\n      |                                             \
    \         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:62,\n\
    \                 from /sha"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n  int len =\
    \ message.length();\n  std::string result;\n  for(int i = 0; i < len; i++) {\n\
    \    int len = message[i];\n    for(int j = 0; j < len; j++) {\n      char ch\
    \ = message[i];\n      int index = ch;\n      // Replace all vowels with 2\n \
    \     for (int k = 0; k < 26; k++) {\n        if (ch == 'A' || ch == 'e' || ch\
    \ == 'i' || ch == 'o' || ch == 'u' || ch == 'Y' || ch == 'a' || ch == 'e' || ch\
    \ == 'i' || ch == 'o' || ch == 'u' || ch == 'Y') {\n          ch = message[i+1];\n\
    \          index = ch;\n          break;\n        }\n      }\n      result.push_back(index);\n\
    \      i++;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp6vk5js7_: /tmp/tmp6vk5js7_.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ s(\"\");\n    int m = 0, n = message.length();\n    bool v[10] = { false, false,\
    \ false, false, false, false, false, false, false };\n    for (int i = 0; i <\
    \ n; i++) {\n        if (isalpha(message[i])) {\n            char c = toupper(message[i]);\n\
    \            if (isupper(c)) {\n                m++;\n            }\n        \
    \    if (v[m]) {\n                s += c;\n            } else {\n            \
    \    s += ' ';\n            }\n            v[m] = true;\n        } else {\n  \
    \          s += message[i];\n        }\n    }\n    return s;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp8n6e3g09.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp8n6e3g09.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string s(\"\");\n\
    \      |     ^~~~~~\n      |     std::string\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8n6e3g09.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp8n6e3g09.cpp:24:17:\
    \ error: \u2018s\u2019 was not declared in this scope\n   24 |               \
    \  s += c;\n      |                 ^\n/tmp/tmp8n6e3g09.cpp:26:17: error: \u2018\
    s\u2019 was not declared in this scope\n   26 |                 s += ' ';\n  \
    \    |                 ^\n/tmp/tmp8n6e3g09.cpp:30:13: error: \u2018s\u2019 was\
    \ not declared in this scope\n   30 |             s += message[i];\n      |  \
    \           ^\n/tmp/tmp8n6e3g09.cpp:33:12: error: \u2018s\u2019 was not declared\
    \ in this scope\n   33 |     return s;\n      |            ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ s = message;\n    for(int i = 0; i < s.length(); i++) {\n        if (s[i] ==\
    \ 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n       \
    \     s[i] = s[i + 1];\n        }\n    }\n    for(int i = 0; i < s.length(); i++)\
    \ {\n        if(s[i] == 'a' || s[i] == 'A') {\n            s[i] = 'A';\n     \
    \   }\n        if(s[i] == 'e' || s[i] == 'E') {\n            s[i] = 'E';\n   \
    \     }\n        if(s[i] == 'i' || s[i] == 'I') {\n            s[i] = 'I';\n \
    \       }\n        if(s[i] == 'o' || s[i] == 'O') {\n            s[i] = 'O';\n\
    \        }\n        if(s[i] == 'u' || s[i] == 'U') {\n            s[i] = 'U';\n\
    \        }\n    }\n    for(int i = 0; i < s.length(); i++) {\n        if(s[i]\
    \ == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] ==\
    \ 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n       \
    \     s[i] = tolower(s[i]);\n        }\n    }\n    for(int i = 0; i < s.length();\
    \ i++) {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o'\
    \ || s[i] == 'u') {\n            s[i] = s[i];\n        }\n    }\n    for(int i\
    \ = 0; i < s.length(); i++) {\n        if(s[i] == 'a') {\n            s[i] = 'a';\n\
    \        }\n        if(s[i] == 'e') {\n            s[i] = 'e';\n        }\n  \
    \      if(s[i] == 'i') {\n            s[i] = 'i';\n        }\n        if(s[i]\
    \ == 'o') {\n            s[i] = 'o';\n        }\n        if(s[i] == 'u') {\n \
    \           s[i] = 'u';\n        }\n    }\n    for(int i = 0; i < s.length();\
    \ i++) {\n        if(s[i] == 'a' || s[i] == 'A') {\n            s[i] = 'a';\n\
    \        }\n        if(s[i] == 'e' || s[i] == 'E') {\n            s[i] = 'e';\n\
    \        }\n        if(s[i] == 'i' || s[i] == 'I') {\n            s[i] = 'i';\n\
    \        }\n        if(s[i] == 'o' || s[i] == 'O') {\n            s[i] = 'o';\n\
    \        }\n        if(s[i] == 'u' || s[i] == 'U') {\n            s[i] = 'u';\n\
    \        }\n    }\n    for(int i = 0; i < s.length(); i++) {\n        if(s[i]\
    \ == 'a') {\n            s[i] = 'A';\n        }\n        if(s[i] == 'e') {\n \
    \           s[i] = 'E';\n        }\n        if(s[i] == 'i') {\n            s[i]\
    \ = 'I';\n        }\n        if(s[i] == 'o') {\n            s[i] = 'O';\n    \
    \    }\n        if(s[i] == 'u') {\n            s[i] = 'U';\n        }\n    }\n\
    \    for(int i = 0; i < s.length(); i++) {\n        if(s[i] == 'a' || s[i] ==\
    \ 'e\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp08nbvavf.cpp:99:35: warning: missing terminating ' character\n\
    \   99 |         if(s[i] == 'a' || s[i] == 'e\n      |                       \
    \            ^\n/tmp/tmp08nbvavf.cpp:99:35: error: missing terminating ' character\n\
    \   99 |         if(s[i] == 'a' || s[i] == 'e\n      |                       \
    \            ^~\n/tmp/tmp08nbvavf.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp08nbvavf.cpp:100:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  100 | }\n      | ^\n/tmp/tmp08nbvavf.cpp:99:34: error: expected\
    \ \u2018)\u2019 before \u2018}\u2019 token\n   99 |         if(s[i] == 'a' ||\
    \ s[i] == 'e\n      |           ~                      ^\n      |            \
    \                      )\n  100 | }\n      | ~                               \
    \  \n/tmp/tmp08nbvavf.cpp:100:1: error: expected primary-expression before \u2018\
    }\u2019 token\n  100 | }\n      | ^\n/tmp/tmp08nbvavf.cpp:101:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n  101 | int main() {\n     \
    \ |            ^\n/tmp/tmp08nbvavf.cpp:108:1: error: expected \u2018}\u2019 at\
    \ end of input\n  108 | }\n      | ^\n/tmp/tmp08nbvavf.cpp:13:41: note: to match\
    \ this \u2018{\u2019\n   13 | std::string encode(std::string message) {\n    \
    \  |                                         ^\n/tmp/tmp08nbvavf.cpp:108:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n  108 |\
    \ }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ encoded;\n    for (int i = 0; i < message.length(); i++) {\n        if (message[i]\
    \ >= 'a' && message[i] <= 'z') {\n            encoded += message[i] + 'A' - 'a';\n\
    \        } else if (message[i] >= 'A' && message[i] <= 'Z') {\n            encoded\
    \ += message[i] + 'a' - 'A';\n        } else {\n            encoded += message[i];\n\
    \        }\n    }\n    return encoded;\n}\nint main() {\n    auto candidate =\
    \ encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpf6jw9apx: /tmp/tmpf6jw9apx.cpp:28: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::vector<int>\
    \ v = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    std::string ans = message;\n    for (int\
    \ i = 0; i < message.size(); i++){\n        if (std::find(v.begin(), v.end(),\
    \ message[i]) != v.end())\n            ans.replace(i, 1, message[i]);\n      \
    \  else if(message[i] == 'A')\n            ans.replace(i, 1, \"A\");\n       \
    \ else if(message[i] == 'e')\n            ans.replace(i, 1, \"E\");\n        else\
    \ if(message[i] == 'I')\n            ans.replace(i, 1, \"i\");\n        else if(message[i]\
    \ == 'o')\n            ans.replace(i, 1, \"o\");\n        else if(message[i] ==\
    \ 'u')\n            ans.replace(i, 1, \"u\");\n        else if(message[i] == 'Y')\n\
    \            ans.replace(i, 1, \"Y\");\n        else if(message[i] == 'y')\n \
    \           ans.replace(i, 1, \"Y\");\n        else if(message[i] == 'O')\n  \
    \          ans.replace(i, 1, \"O\");\n        else if(message[i] == 'o')\n   \
    \         ans.replace(i, 1, \"O\");\n        else if(message[i] == 'u')\n    \
    \        ans.replace(i, 1, \"U\");\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpg9_g4yu0.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpg9_g4yu0.cpp:18:41: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::replace(int&, int, __gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type&)\u2019\n   18 |             ans.replace(i, 1, message[i]);\n\
    \      |                                         ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpg9_g4yu0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1961:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019 <near match>\n 1961 |       replace(size_type __pos,\
    \ size_type __n1, const _CharT* __s)\n      |       ^~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1961:7:\
    \ note:   conversion of argument 3 would be ill-formed:\n/tmp/tmpg9_g4yu0.cpp:18:41:\
    \ error: invalid conversion "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    // Initialize\
    \ a hash map (Hash table or unordered map) \n    // with 26 buckets (letters)\
    \ \n    std::map<char, int> hash; \n    char vowel = 'A'; \n    for (char ch :\
    \ message) \n        if (hash[ch] == 0) \n            hash[ch] = 26; \n    for\
    \ (char ch : message) { \n        if (hash[ch] >= 2 && hash[ch] <= 25) { \n  \
    \          hash[ch] = hash[ch] - 2; \n        }\n        else if (hash[ch] >=\
    \ 26 &&\n                 hash[ch] <= 33) { \n            hash[ch] = hash[ch]\
    \ + 2; \n        } \n        else if (hash[ch] >= 34 &&\n                 hash[ch]\
    \ <= 41) {\n            hash[ch] = hash[ch] - 1; \n        } \n        else {\
    \ \n            hash[ch] = hash[ch] + 1; \n        } \n    } \n    std::string\
    \ encodedMessage = \"\"; \n    for (char ch : message) { \n        if (hash[ch]\
    \ == 0) { \n            encodedMessage += ch; \n        } \n    } \n    return\
    \ encodedMessage;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpbbwl0opd: /tmp/tmpbbwl0opd.cpp:47: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    string\
    \ encodedMessage = \"\";\n    int vowels[26] = {0};\n    string vowels = \"AEIOUaeiou\"\
    ;\n    for (int i = 0; i < message.length(); ++i) {\n        char c = message[i];\n\
    \        c = toupper(c);\n        for (int j = 0; j < vowels.length(); ++j) {\n\
    \            if (c == vowels[j]) {\n                if (vowels[j] == vowels[j\
    \ + 1]) {\n                    c = vowels[j];\n                    vowels[j +\
    \ 1] = vowels[j - 1];\n                }\n                else {\n           \
    \         c = vowels[j + 1];\n                    vowels[j + 1] = vowels[j];\n\
    \                }\n            }\n        }\n        encodedMessage += c;\n \
    \   }\n    return encodedMessage;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp0ne5s4d4.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp0ne5s4d4.cpp:14:5: error: \u2018string\u2019 was not declared in this\
    \ scope; did you mean \u2018std::string\u2019?\n   14 |     string encodedMessage\
    \ = \"\";\n      |     ^~~~~~\n      |     std::string\nIn file included from\
    \ /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/iosfwd:39,\n           \
    \      from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:38,\n    \
    \             from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp0ne5s4d4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stringfwd.h:79:33:\
    \ note: \u2018std::string\u2019 declared here\n   79 |   typedef basic_string<char>\
    \    string;\n      |                                 ^~~~~~\n/tmp/tmp0ne5s4d4.cpp:16:11:\
    \ error: expected \u2018;\u2019 before \u2018vowels\u2019\n   16 |     string\
    \ vowels = \"AEIOUaeiou\";\n      |           ^~~~~~~\n      |           ;\n/tmp/tmp0ne5s4d4.cpp:20:36:\
    \ error: request for member \u2018length\u2019 in \u2018vowels\u2019, which is\
    \ of non-class type \u2018int [26]\u2019\n   20 |         for (int j = 0; j <\
    \ vowels.length(); ++j) {\n      |                                    ^~~~~~\n\
    /tmp/tmp0ne5s4d4.cpp:32:9: error: \u2018encodedMessage\u2019 was not declared\
    \ in this scope\n   32 |         encodedMessage += c;\n      |         ^~~~~~~~~~~~~~\n\
    /tmp/tmp0ne5s4d4.cpp:34:12: error: \u2018encodedMessage\u2019 was not declared\
    \ in this scope\n   34 |     return encodedMessage;\n      |            ^~~~~~~~~~~~~~\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n// Write your\
    \ code here\n\nreturn message;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpl_jq0qa8: /tmp/tmpl_jq0qa8.cpp:20: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ newMessage = message;\n    for (char c : newMessage) {\n        if (c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c = newMessage[(newMessage.find(c)\
    \ + 2) - 1];\n        }\n        newMessage.replace(c, 1, toupper(c));\n    }\n\
    \    for (char c : newMessage) {\n        if (c == 'A' || c == 'E' || c == 'I'\
    \ || c == 'O' || c == 'U') {\n            c = newMessage[(newMessage.find(c) +\
    \ 2) - 1];\n        }\n        newMessage.replace(c, 1, tolower(c));\n    }\n\
    \    for (int i = 0; i < newMessage.length(); i++) {\n        if (newMessage[i]\
    \ == ' ') {\n            newMessage.replace(i + 1, 1, '-');\n        }\n    }\n\
    \    return newMessage;\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmp25rfn06q.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmp25rfn06q.cpp:19:44: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::replace(char&, int, int)\u2019\n   19 |    \
    \     newMessage.replace(c, 1, toupper(c));\n      |                         \
    \                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp25rfn06q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1961:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::replace(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type,\
    \ const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019 <near match>\n 1961 |       replace(size_type __pos,\
    \ size_type __n1, const _CharT* __s)\n      |       ^~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:1961:7:\
    \ note:   conversion of argument 3 would be ill-formed:\n/tmp/tmp25rfn06q.cpp:19:41:\
    \ error: invalid conversion from \u2018int\u2019 to \u2018const char*\u2019 [-fpermissive]\n\
    \   19 |      "
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::swap(message[0],\
    \ message[1]);\n    std::map<char,char> vowels = {\n        {'A','E'},\n     \
    \   {'I','O'},\n        {'U','Y'},\n        {'a', 'e'},\n        {'i', 'o'},\n\
    \        {'u', 'y'},\n    };\n    size_t pos = 0;\n    for (char c : message)\
    \ {\n        if (vowels.find(c) != vowels.end()) {\n            pos = message.find(c,\
    \ pos) + 1;\n            continue;\n        }\n        pos = message.find(c, pos)\
    \ + 1;\n    }\n    std::string res = \"\";\n    for (int i = pos; i > 0; --i)\
    \ {\n        res += message[i-1];\n    }\n    return res;\n}\nint main() {\n \
    \   auto candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n\
    \    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"\
    YES\")) == (\"ygs\"));\n    assert(candidate((\"This is a message\")) == (\"tHKS\
    \ KS C MGSSCGG\"));\n    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) ==\
    \ (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpog1c_83s: /tmp/tmpog1c_83s.cpp:39: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::string\
    \ out=\"\";\n    for(int i=0;i<message.length();i++)\n    {\n        if(message[i]=='A'\
    \ || message[i]=='a') \n        {\n            if((i+2)<message.length() && (message[i+1]=='A'\
    \ || message[i+1]=='a'))\n            {\n                out.push_back('A');\n\
    \                out.push_back('a');\n                out.push_back('A');\n  \
    \              out.push_back('a');\n            }\n            else\n        \
    \        out.push_back('A');\n        }\n        if(message[i]=='E' || message[i]=='e')\
    \ \n        {\n            if((i+2)<message.length() && (message[i+1]=='A' ||\
    \ message[i+1]=='a') && (message[i+2]=='E' || message[i+2]=='e'))\n          \
    \  {\n                out.push_back('E');\n                out.push_back('a');\n\
    \                out.push_back('E');\n                out.push_back('e');\n  \
    \          }\n            else\n                out.push_back('E');\n        }\n\
    \        if(message[i]=='I' || message[i]=='i') \n        {\n            if((i+2)<message.length()\
    \ && (message[i+1]=='A' || message[i+1]=='a') && (message[i+2]=='I' || message[i+2]=='i'))\n\
    \            {\n                out.push_back('I');\n                out.push_back('a');\n\
    \                out.push_back('I');\n                out.push_back('i');\n  \
    \          }\n            else\n                out.push_back('I');\n        }\n\
    \        if(message[i]=='O' || message[i]=='o') \n        {\n            if((i+2)<message.length()\
    \ && (message[i+1]=='A' || message[i+1]=='a') && (message[i+2]=='O' || message[i+2]=='o'))\n\
    \            {\n                out.push_back('O');\n                out.push_back('a');\n\
    \                out.push_back('O');\n                out.push_back('o');\n  \
    \          }\n            else\n                out.push_back('O');\n        }\n\
    \        if(message[i]=='U' || message[i]=='u') \n        {\n            if((i+2)<message.length()\
    \ && (message[i+1]=='A' || message[i+1]=='a') && (message[i+2]=='U' || message[i+2]=='u'))\n\
    \            {\n                out.push_back('U');\n                out.push_back('a');\n\
    \                out.push_back('U');\n                out.push_back('u');\n  \
    \          }\n            else\n                out.push_back('U');\n        }\n\
    \        if(message[i]=='Y' || message[i]=='y') \n        {\n            if((i+2)<message.length()\
    \ && (message[i+1]=='A' || message[i+1]=='a') && (message[i+2]=='Y' || message[i+2]=='y'))\n\
    \            {\n                out.push_back('Y');\n\n}\nint main() {\n    auto\
    \ candidate = encode;\n    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"\
    Mudasir\")) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n\
    \    assert(candidate((\"This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n\
    \    assert(candidate((\"I DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT\
    \ Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "/tmp/tmpghrbjr2_.cpp: In function \u2018std::string encode(std::string)\u2019\
    :\n/tmp/tmpghrbjr2_.cpp:84:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   84 | int main() {\n      |            ^\n/tmp/tmpghrbjr2_.cpp:91:1:\
    \ error: expected \u2018}\u2019 at end of input\n   91 | }\n      | ^\n/tmp/tmpghrbjr2_.cpp:78:9:\
    \ note: to match this \u2018{\u2019\n   78 |         {\n      |         ^\n/tmp/tmpghrbjr2_.cpp:91:1:\
    \ error: expected \u2018}\u2019 at end of input\n   91 | }\n      | ^\n/tmp/tmpghrbjr2_.cpp:16:5:\
    \ note: to match this \u2018{\u2019\n   16 |     {\n      |     ^\n/tmp/tmpghrbjr2_.cpp:91:1:\
    \ error: expected \u2018}\u2019 at end of input\n   91 | }\n      | ^\n/tmp/tmpghrbjr2_.cpp:13:41:\
    \ note: to match this \u2018{\u2019\n   13 | std::string encode(std::string message)\
    \ {\n      |                                         ^\n/tmp/tmpghrbjr2_.cpp:91:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \   91 | }\n      | ^\n"
  exit_code: 1
  status: SyntaxError
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n   //write\
    \ your code here\n}\nint main() {\n    auto candidate = encode;\n    assert(candidate((\"\
    TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\")) == (\"mWDCSKR\"\
    ));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp62e207k6: /tmp/tmp62e207k6.cpp:18: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n    std::unordered_map<char,\
    \ char> vowels;\n    vowels['a'] = 'e';\n    vowels['e'] = 'a';\n    vowels['i']\
    \ = 'e';\n    vowels['o'] = 'e';\n    vowels['u'] = 'e';\n    vowels['y'] = 'o';\n\
    \n    for (int i = 0; i < message.length(); i++) {\n        if (vowels.find(message[i])\
    \ != vowels.end()) {\n            int j = i+2;\n            while(j < message.length()\
    \ && vowels.find(message[j]) != vowels.end()) {\n                ++j;\n      \
    \      }\n            char vowel1 = message[i];\n            char vowel2 = message[j];\n\
    \            message[i] = vowels[message[i]];\n            message[j] = vowels[vowel2];\n\
    \            message[i] = vowel1;\n            message[j] = vowel2;\n        }\n\
    \    }\n    return message;\n}\nint main() {\n    auto candidate = encode;\n \
    \   assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmpti_p0gai: /tmp/tmpti_p0gai.cpp:40: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
- program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ takes a message, and encodes in such a \n// way that it swaps case of all letters,\
    \ replaces all vowels in \n// the message with the letter that appears 2 places\
    \ ahead of that \n// vowel in the english alphabet. \n// Assume only letters.\
    \ \n// Examples:\n// >>> encode('test')\n// 'TGST'\n// >>> encode('This is a message')\n\
    // 'tHKS KS C MGSSCGG'\nstd::string encode(std::string message) {\n     std::string\
    \ res=\"\";\n    int i=0;\n    for(int j=message.length();j>0;j--) {\n       \
    \ char letter=message[j];\n        if(letter==' '){\n            letter='-';\n\
    \        }\n        if(isalpha(letter)){\n        res+=letter;\n        }\n  \
    \      else {\n            res+=letter;\n            letter=toupper(letter);\n\
    \        }\n        if(isalpha(letter)){\n            res+=letter;\n        }\n\
    \        i++;\n    }\n    return res;\n}\nint main() {\n    auto candidate = encode;\n\
    \    assert(candidate((\"TEST\")) == (\"tgst\"));\n    assert(candidate((\"Mudasir\"\
    )) == (\"mWDCSKR\"));\n    assert(candidate((\"YES\")) == (\"ygs\"));\n    assert(candidate((\"\
    This is a message\")) == (\"tHKS KS C MGSSCGG\"));\n    assert(candidate((\"I\
    \ DoNt KnOw WhAt tO WrItE\")) == (\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  stdout: ''
  stderr: "tmp1_bu3q9v: /tmp/tmp1_bu3q9v.cpp:37: int main(): Assertion `candidate((\"\
    TEST\")) == (\"tgst\")' failed.\n"
  exit_code: -6
  status: Exception
