name: HumanEval_136_largest_smallest_integers
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that returns\
  \ a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is\
  \ the smallest\n// of positive integers in a list.\n// If there is no negative or\
  \ positive integers, return them as None.\n// Examples:\n// largest_smallest_integers([2,\
  \ 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n\
  // largest_smallest_integers([0]) == (None, None)\nstd::tuple<std::optional<long>,\
  \ std::optional<long>> largest_smallest_integers(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = largest_smallest_integers;\n    assert(candidate((std::vector<long>({2,\
  \ 4, 1, 3, 5, 7}))) == std::make_tuple(std::optional<long>({}), std::optional<long>(1)));\n\
  \    assert(candidate((std::vector<long>({2, 4, 1, 3, 5, 7, 0}))) == std::make_tuple(std::optional<long>({}),\
  \ std::optional<long>(1)));\n    assert(candidate((std::vector<long>({1, 3, 2, 4,\
  \ 5, 6, -2}))) == std::make_tuple(-2, 1));\n    assert(candidate((std::vector<long>({4,\
  \ 5, 3, 6, 2, 7, -7}))) == std::make_tuple(-7, 2));\n    assert(candidate((std::vector<long>({7,\
  \ 3, 8, 4, 9, 2, 5, -9}))) == std::make_tuple(-9, 2));\n    assert(candidate((std::vector<long>()))\
  \ == std::make_tuple(std::optional<long>({}), std::optional<long>({})));\n    assert(candidate((std::vector<long>({0})))\
  \ == std::make_tuple(std::optional<long>({}), std::optional<long>({})));\n    assert(candidate((std::vector<long>({-1,\
  \ -3, -5, -6}))) == std::make_tuple(std::optional<long>(-1), std::optional<long>({})));\n\
  \    assert(candidate((std::vector<long>({-1, -3, -5, -6, 0}))) == std::make_tuple(std::optional<long>(-1),\
  \ std::optional<long>({})));\n    assert(candidate((std::vector<long>({-6, -4, -4,\
  \ -3, 1}))) == std::make_tuple(-3, 1));\n    assert(candidate((std::vector<long>({-6,\
  \ -4, -4, -3, -100, 1}))) == std::make_tuple(-3, 1));\n}\n"
completions: ["  // Your code here\n  if (lst.empty()) return std::make_pair(std::optional<long>(),\
    \ std::optional<long>());\n  std::pair<long, long> largest = {0, 0};\n  for (const\
    \ auto &i : lst) {\n    if (i > largest.first) largest = std::make_pair(i, i);\n\
    \    if (i < largest.second) largest = std::make_pair(i, i);\n  }\n  return std::make_pair(std::nullopt,\
    \ std::nullopt);", "    if (lst.empty()) return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    auto left = lst.begin();\n    auto right = lst.end();\n\
    \    std::optional<long> largest{*left};\n    std::optional<long> smallest{*right};\n\
    \    for (auto i = right; i != lst.end(); i++) {\n        if (*i >= 0) {\n   \
    \         if (smallest == std::nullopt) {\n                smallest = *i;\n  \
    \          } else if (*i < 0) {\n                smallest = *i;\n            }\n\
    \        } else {\n            if (largest == std::nullopt) {\n              \
    \  largest = *i;\n            } else if (*i < 0) {\n                largest =\
    \ *i;\n            }\n        }\n    }\n    return std::make_tuple(largest, smallest);",
  "    std::vector<long> reverse(lst.rbegin(), lst.rend());\n    long largest_integer\
    \ = reverse.front();\n    long smallest_integer = reverse.back();\n    bool has_smaller\
    \ = false;\n    for (auto integer : lst) {\n        bool is_larger = (integer\
    \ > largest_integer);\n        bool is_smaller = (integer < smallest_integer);\n\
    \        if (is_larger && is_smaller) {\n            has_smaller = true;\n   \
    \         smallest_integer = integer;\n            largest_integer = integer;\n\
    \        } else if (is_larger) {\n            largest_integer = integer;\n   \
    \     } else {\n            smallest_integer = integer;\n        }\n    }\n  \
    \  if (has_smaller) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    } else {\n        return std::make_tuple(std::nullopt, largest_integer);\n\
    \    }", "  std::optional<long> min;\n  std::optional<long> max;\n  for (const\
    \ auto val : lst) {\n    if (min && val < min)\n      min = val;\n    else if\
    \ (max && val > max)\n      max = val;\n    else\n      continue;\n  }\n  return\
    \ std::make_tuple(min, max);", "    long largestPositive = std::numeric_limits<long>::max();\n\
    \    long smallestNegative = std::numeric_limits<long>::min();\n    long largestPositiveInList\
    \ = 0;\n    long smallestNegativeInList = 0;\n    for (auto it : lst) {\n    \
    \    largestPositive = std::max(largestPositive, it);\n        smallestNegative\
    \ = std::min(smallestNegative, it);\n        largestPositiveInList = std::max(largestPositiveInList,\
    \ it);\n        smallestNegativeInList = std::min(smallestNegativeInList, it);\n\
    \    }\n    // return first tuple value that is not None\n    return std::make_tuple(largestPositive\
    \ >= 0 ? largestPositive : std::nullopt,\n                          smallestNegative\
    \ >= 0 ? smallestNegative : std::nullopt);", "  // Write code here\n  if (lst.empty())\n\
    \    return std::make_tuple(std::nullopt, std::nullopt);\n  std::optional<long>\
    \ min{};\n  std::optional<long> max{};\n  for (const auto& val : lst) {\n    if\
    \ (val < 0)\n      min = std::nullopt;\n    else if (val > 0)\n      max = std::nullopt;\n\
    \    else\n      max = val;\n  }\n  return std::make_tuple(min, max);", "    //\
    \ Initialize variables.\n    std::optional<long> min_val;\n    std::optional<long>\
    \ max_val;\n    if (lst.size() > 0) {\n        min_val = std::min(lst);\n    \
    \    max_val = std::max(lst);\n    }\n    // If there were no numbers in the list,\
    \ return None for each value.\n    if (min_val == max_val) return (min_val, max_val);\n\
    \    // Otherwise, return the first of the two values.\n    return (std::get<0>(min_val),\
    \ std::get<1>(min_val));", "  std::vector<long> numbers;\n  for (long n : lst)\n\
    \    numbers.push_back(n);\n  std::sort(numbers.begin(), numbers.end());\n  std::vector<long>::iterator\
    \ it = numbers.end();\n  for (long n : numbers)\n    if (n < 0) {\n      it =\
    \ std::lower_bound(numbers.begin(), numbers.end(), n);\n      if (it != numbers.end())\n\
    \        it--;\n      break;\n    } else if (n == 0)\n      it = std::lower_bound(numbers.begin(),\
    \ numbers.end(), 0);\n      break;\n  return std::make_tuple(std::make_optional(std::distance(numbers.begin(),\
    \ it)), std::make_optional(std::distance(numbers.begin(), it)));", "    if (lst.empty())\
    \ return std::tuple<std::optional<long>, std::optional<long>>{};\n    long first\
    \ = std::get<0>(std::max_element(lst.begin(), lst.end()));\n    long second =\
    \ std::get<1>(std::min_element(lst.begin(), lst.end()));\n    return std::make_tuple(first,\
    \ second);", "    // Write your code here\n    std::optional<long> largest_positive{std::numeric_limits<long>::max()};\n\
    \    std::optional<long> largest_negative{std::numeric_limits<long>::min()};\n\
    \    auto it = lst.begin();\n    for (auto i = std::min({lst.begin(), lst.end()});\
    \ i < lst.end(); ++i) {\n        if (*i > 0) {\n            largest_positive =\
    \ std::max(*i, *it);\n            largest_negative = std::min(*i, *it);\n    \
    \    }\n        ++it;\n    }\n    return std::make_pair(largest_negative, largest_positive);",
  "    // Write your code here.\n    std::vector<long> negative_ints, positive_ints;\n\
    \    for (auto val : lst) {\n        if (val < 0) {\n            negative_ints.push_back(val);\n\
    \        }\n        else if (val > 0) {\n            positive_ints.push_back(val);\n\
    \        }\n    }\n    if (negative_ints.size() == 0 && positive_ints.size() ==\
    \ 0) {\n        return std::tuple<std::optional<long>, std::optional<long>>();\n\
    \    }\n    else if (negative_ints.size() == 0 && positive_ints.size() == 0) {\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n    }\n    else if (negative_ints.size() == 0) {\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ positive_ints.front());\n    }\n    else if (positive_ints.size() == 0) {\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(negative_ints.front(),\
    \ std::optional<long>());\n    }\n    else {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(negative_ints.front(), positive_ints.front());\n    }",
  "    if(lst.size() <= 0){\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }\n    bool isNegative = false;\n    long largest = std::numeric_limits<long>::min();\n\
    \    for(long i : lst){\n        if(i < 0){\n            isNegative = true;\n\
    \            break;\n        }\n        if(isNegative == true && i > largest){\n\
    \            largest = i;\n        }\n    }\n    for(long i : lst){\n        if(isNegative\
    \ == false && i < largest){\n            largest = i;\n        }\n    }\n    return\
    \ std::tuple<std::optional<long>, std::optional<long>>(std::optional(largest),\
    \ std::nullopt);", "    std::optional<long> max_integer = std::nullopt;\n    std::optional<long>\
    \ min_integer = std::nullopt;\n    for (auto val : lst) {\n        if (max_integer.has_value())\
    \ max_integer = std::max(max_integer, val);\n        if (min_integer.has_value())\
    \ min_integer = std::min(min_integer, val);\n    }\n    return std::make_tuple(max_integer,\
    \ min_integer);", "  if (lst.size() <= 1) return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n\n  long a = std::numeric_limits<long>::min();\n  long b = std::numeric_limits<long>::max();\n\
    \  for (long i : lst) {\n    if (i < a) a = i;\n    if (i > b) b = i;\n  }\n\n\
    \  return std::make_tuple(std::make_optional(a), std::make_optional(b));", " \
    \   // Your code here\n    std::optional<long> largest = std::nullopt;\n    std::optional<long>\
    \ smallest = std::nullopt;\n    if (lst.empty()) {\n        return std::make_pair(std::nullopt,\
    \ std::nullopt);\n    }\n    for (long i : lst) {\n        if (largest == std::nullopt)\
    \ {\n            largest = i;\n        } else if (i < smallest) {\n          \
    \  smallest = i;\n        }\n    }\n    return std::make_pair(largest, smallest);",
  "    auto it = lst.end();\n    while (it != lst.begin()) {\n        it = std::max_element(it,\
    \ lst.begin());\n        auto index = std::distance(it, lst.begin());\n      \
    \  it = std::min_element(it, lst.begin());\n        auto index_b = std::distance(it,\
    \ lst.begin());\n        if (index_b > index) {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n        if (index_b == index) {\n            return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n        }\n        return std::make_tuple(std::optional<long>(*index),\
    \ std::optional<long>(*index_b));\n    }\n    return std::make_tuple(std::nullopt,\
    \ std::nullopt);", "    // Write your code here\n    std::vector<long> pos{0,\
    \ 0};\n    std::vector<long> neg{0, 0};\n    for (long &val : lst) {\n       \
    \ if (val < 0) pos.push_back(val);\n        else neg.push_back(val);\n    }\n\
    \    if (pos.size() >= neg.size()) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    } else if (neg.size() >= pos.size()) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    } else {\n        long a = neg[0];\n        long b = pos[0];\n\
    \        for (long &val : neg) {\n            if (val > b) b = val;\n        }\n\
    \        for (long &val : pos) {\n            if (val < a) a = val;\n        }\n\
    \        return std::make_tuple(std::optional<long>(a), std::optional<long>(b));\n\
    \    }", "    // Loop over the list\n    std::optional<long> max_integer;\n  \
    \  std::optional<long> min_integer;\n    for (long i : lst)\n    {\n        //\
    \ If the current number is positive\n        if (i > 0)\n        {\n         \
    \   // If this is the highest positive number\n            if (min_integer ==\
    \ std::nullopt)\n            {\n                min_integer = i;\n           \
    \ }\n            else if (min_integer > i)\n            {\n                //\
    \ Replace the lowest positive number with the current one\n                min_integer\
    \ = i;\n            }\n        }\n        // If the current number is negative\n\
    \        else if (i < 0)\n        {\n            // If this is the highest negative\
    \ number\n            if (max_integer == std::nullopt)\n            {\n      \
    \          max_integer = i;\n            }\n            else if (max_integer <\
    \ i)\n            {\n                // Replace the highest negative number with\
    \ the current one\n                max_integer = i;\n            }\n        }\n\
    \    }\n\n    // Return the highest and lowest positive or negative integers if\
    \ they are found\n    if (min_integer != std::nullopt && max_integer != std::nullopt)\n\
    \    {\n        return std::tuple<std::optional<long>, std::optional<long>>{min_integer,\
    \ max_integer};\n    }\n    else\n    {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>{std::nullopt, std::nullopt};\n    }", "    if(lst.empty())\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>({}, {});\n\
    \    }\n    std::vector<long> temp;\n    temp.emplace_back(lst.front());\n   \
    \ for(long i : lst) {\n        if(i < 0) {\n            temp.emplace_back(i);\n\
    \        }\n    }\n    std::sort(temp.begin(), temp.end());\n    for(auto i :\
    \ temp) {\n        if(i.has_value()) {\n            return {std::min(i.as_two_value_tuple().first,\
    \ i.as_two_value_tuple().second), std::max(i.as_two_value_tuple().first, i.as_two_value_tuple().second)};\n\
    \        }\n    }\n    return std::tuple<std::optional<long>, std::optional<long>>({},\
    \ {});", "  if (lst.empty()) {\n    return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n  }\n  auto max_int = std::max<long>(lst.begin(), lst.end());\n\
    \  auto min_int = std::min<long>(lst.begin(), lst.end());\n  return std::make_tuple(max_int,\
    \ min_int);", "    if (lst.empty()) return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    std::vector<long> sorted(lst.begin(), lst.end());\n    std::sort(sorted.begin(),\
    \ sorted.end());\n    if (sorted[0] == 0) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    }\n    auto beg = sorted.begin(),\
    \ end = sorted.end();\n    long left_max = -sorted[0];\n    long right_min = sorted[0];\n\
    \    for (size_t i = 1; i < sorted.size(); ++i) {\n        long cur_max = -sorted[i];\n\
    \        if (cur_max > right_min) {\n            right_min = cur_max;\n      \
    \      end = std::copy(beg, beg, std::back_inserter(sorted_right));\n        }\n\
    \        long cur_min = sorted[i];\n        if (cur_min < left_max) {\n      \
    \      left_max = cur_min;\n            beg = std::copy(beg, end, std::back_inserter(sorted_left));\n\
    \        }\n    }\n    return std::make_tuple(std::make_optional(left_max), std::make_optional(right_min));",
  "    if (lst.empty())\n        return std::tuple<std::optional<long>, std::optional<long>>({},\
    \ {});\n    long largest_val = std::numeric_limits<long>::min();\n    long smallest_val\
    \ = std::numeric_limits<long>::max();\n    for (auto val : lst) {\n        if\
    \ (val < 0)\n            largest_val = std::max(largest_val, val);\n        else\n\
    \            smallest_val = std::min(smallest_val, val);\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(\n            std::optional<long>(std::max<long>(largest_val,\
    \ 0)),\n            std::optional<long>(std::min<long>(smallest_val, 0)));", " \
    \   // Write your code here\n    if(lst.empty())\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    long large = std::max(*std::max_element(lst.begin(),\
    \ lst.end()), 0);\n    long small = std::min(*std::min_element(lst.begin(), lst.end()),\
    \ 0);\n    return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(large),\
    \ std::optional<long>(small));", "    std::optional<long> largest_val = std::nullopt;\n\
    \    std::optional<long> smallest_val = std::nullopt;\n    for (long l : lst)\
    \ {\n        if (std::abs(l) > largest_val) {\n            largest_val = std::abs(l);\n\
    \        }\n        if (std::abs(l) < smallest_val) {\n            smallest_val\
    \ = std::abs(l);\n        }\n    }\n    return std::make_tuple(largest_val, smallest_val);",
  "    int neg_index = 0;\n    int pos_index = 0;\n    bool has_neg = false;\n   \
    \ bool has_pos = false;\n    for (auto n : lst) {\n        has_neg = (!has_neg\
    \ && n < 0);\n        has_pos = (!has_pos && n > 0);\n        if (has_neg && has_pos)\
    \ {\n            return std::make_tuple(std::nullopt, std::nullopt);\n       \
    \ }\n        if (has_neg) {\n            if (neg_index < lst.size() - 1) {\n \
    \               if (n < 0) {\n                    neg_index++;\n             \
    \   }\n            }\n            else {\n                return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n            }\n        }\n        else if (has_pos) {\n    \
    \        if (pos_index < lst.size() - 1) {\n                if (n > 0) {\n   \
    \                 pos_index++;\n                }\n            }\n           \
    \ else {\n                return std::make_tuple(std::nullopt, std::nullopt);\n\
    \            }\n        }\n    }\n    if (neg_index > pos_index) {\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    }\n    else if (pos_index\
    \ > neg_index) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    }\n    else if (neg_index == lst.size()) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n    else if (pos_index == lst.size()) {\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    }\n    else {\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    }", "    if (lst.empty())\
    \ {\n        return std::make_tuple(std::nullopt, std::nullopt);\n    }\n    auto\
    \ largest = *std::max_element(std::begin(lst), std::end(lst));\n    auto smallest\
    \ = *std::min_element(std::begin(lst), std::end(lst));\n    if (smallest >= 0)\
    \ {\n        return std::make_tuple(std::nullopt, std::nullopt);\n    } else {\n\
    \        return std::make_tuple(std::optional<long>{largest}, std::optional<long>{smallest});\n\
    \    }", "    if (lst.empty()) return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    auto largest = std::max_element(lst.begin(), lst.end());\n    auto smallest\
    \ = std::min_element(lst.begin(), lst.end());\n    return std::make_tuple(std::make_optional(largest),\
    \ std::make_optional(smallest));", "  assert(lst.size() > 0);\n  std::optional<long>\
    \ min_val = std::nullopt;\n  std::optional<long> max_val = std::nullopt;\n  for\
    \ (long const val : lst) {\n    if (val < 0) {\n      if (min_val == std::nullopt)\n\
    \        min_val = val;\n      else\n        min_val = std::max(min_val, val);\n\
    \    }\n    if (val > 0) {\n      if (max_val == std::nullopt)\n        max_val\
    \ = val;\n      else\n        max_val = std::min(max_val, val);\n    }\n  }\n\
    \  return std::make_tuple(min_val, max_val);", "    long max{-1};\n    long min{1};\n\
    \    for (long num : lst) {\n        if (num < 0) min = std::min(min, num);\n\
    \        if (num > 0) max = std::max(max, num);\n    }\n    return std::make_tuple(max,\
    \ min);", "  int max_pos = std::numeric_limits<int>::min();\n  int min_neg = std::numeric_limits<int>::max();\n\
    \  for (int val : lst) {\n    if (val < 0) min_neg = val;\n    else max_pos =\
    \ val;\n  }\n  std::optional<long> res = std::make_optional(max_pos);\n  if (!res.has_value())\
    \ return res;\n  res = std::make_optional(min_neg);\n  return res;", "    long\
    \ lmax = 0, lmin = 0;\n    bool isLargerNegative;\n    std::optional<long> max;\n\
    \    std::optional<long> min;\n    for (auto i : lst) {\n        if (isLargerNegative\
    \ || (i > lmax)) {\n            lmax = i;\n            max = i;\n        }\n \
    \       if (i == lmin) {\n            min = i;\n        }\n        if (i < lmin)\
    \ {\n            isLargerNegative = true;\n            lmin = i;\n        }\n\
    \    }\n    return std::make_tuple(max, min);", "    // Write your code here\n\
    \    if(lst.size() <= 1){\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }\n    long max_pos = 0;\n    long min_pos = std::numeric_limits<long>::max();\n\
    \    for (long x: lst)\n    {\n        if(x<min_pos)\n        {\n            min_pos\
    \ = x;\n        }\n        if(x>max_pos)\n        {\n            max_pos = x;\n\
    \        }\n    }\n    return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);", "    std::optional<long> max_val, min_val;\n    for (long i\
    \ : lst) {\n        if (i < 0) {\n            max_val = i;\n        } else if\
    \ (i > 0){\n            min_val = i;\n        } else {\n            max_val =\
    \ min_val;\n            min_val = i;\n        }\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(max_val, min_val);", "    if(lst.empty()) {\n        return\
    \ std::make_pair(std::optional<long>(), std::optional<long>());\n    }\n    std::optional<long>\
    \ largest_number = std::make_optional();\n    std::optional<long> smallest_number\
    \ = std::make_optional();\n    for(long num: lst) {\n        if(num < 0) {\n \
    \           if(largest_number.has_value()) {\n                largest_number =\
    \ std::make_optional(std::max(num, *largest_number));\n            }\n       \
    \ } else {\n            if(smallest_number.has_value()) {\n                smallest_number\
    \ = std::make_optional(std::min(num, *smallest_number));\n            }\n    \
    \    }\n    }\n    if(!largest_number.has_value()) {\n        return std::make_pair(largest_number,\
    \ smallest_number);\n    } else if(!smallest_number.has_value()) {\n        return\
    \ std::make_pair(largest_number, smallest_number);\n    }\n    return std::make_pair(std::max(largest_number,\
    \ smallest_number), std::min(largest_number, smallest_number));", "    // Your\
    \ code here\n    std::optional<long> a, b;\n    for (long i : lst) {\n       \
    \ if (a && b) { break;\n        }\n        a = std::min(a, i);\n        if (b)\
    \ { b = std::max(b, i);\n        }\n    }\n    return std::make_tuple(a, b);",
  "    \n    // sort the list\n    std::sort(lst.begin(), lst.end());\n\n    // initialize\
    \ max and min to None\n    auto max = [](auto a, auto b) { return std::max(a,\
    \ b); };\n    auto min = [](auto a, auto b) { return std::min(a, b); };\n\n  \
    \  // get the biggest negative number\n    auto biggest = std::optional<long>(std::numeric_limits<long>::min());\n\
    \    auto biggestIndex = std::optional<long>(std::numeric_limits<long>::min());\n\
    \    for(std::size_t i = 0; i < lst.size(); i++) {\n        auto val = lst[i];\n\
    \        biggest = std::max(val, biggest);\n        biggestIndex = std::max(biggestIndex,\
    \ val);\n    }\n\n    // get the smallest positive number\n    auto smallest =\
    \ std::optional<long>(std::numeric_limits<long>::max());\n    auto smallestIndex\
    \ = std::optional<long>(std::numeric_limits<long>::max());\n    for(std::size_t\
    \ i = 0; i < lst.size(); i++) {\n        auto val = lst[i];\n        smallest\
    \ = std::min(val, smallest);\n        smallestIndex = std::min(smallestIndex,\
    \ val);\n    }\n\n    return std::make_tuple(biggest, smallest);", "    // write\
    \ your code here\n    int i = 0;\n    int j = lst.size();\n    while (i < j) {\n\
    \        if (lst[i] < 0 &&\n            lst[j] < 0) {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n        else if (lst[i] > 0 &&\n            lst[j]\
    \ > 0)\n        {\n            return std::make_tuple(std::nullopt, std::nullopt);\n\
    \        }\n        else if (lst[i] < 0 &&\n            lst[j] > 0)\n        {\n\
    \            return std::make_tuple(std::nullopt, std::nullopt);\n        }\n\
    \        else if (lst[i] == 0 &&\n            lst[j] > 0) {\n            return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n        }\n        else if (lst[i]\
    \ == 0 &&\n            lst[j] < 0)\n        {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n        else if (lst[i] > 0 &&\n            lst[j]\
    \ == 0) {\n            return std::make_tuple(std::nullopt, std::nullopt);\n \
    \       }\n        else if (lst[i] < 0 &&\n            lst[j] == 0) {\n      \
    \      return std::make_tuple(std::nullopt, std::nullopt);\n        }\n      \
    \  else if (lst[i] > 0 &&\n            lst[j] > 0)\n        {\n            return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n        }\n        else if (lst[i]\
    \ < 0 &&\n            lst[j] < 0)\n        {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n        else if (lst[i] > 0 &&\n            lst[j]\
    \ > 0) {\n            return std::make_tuple(std::nullopt, std::nullopt);\n  \
    \      }\n        else if (lst[i] < 0 &&\n            lst[j] > 0)\n        {\n\
    \            return std::make_tuple(std::nullopt, std::nullopt);\n        }\n\
    \        else if (lst[i] < 0 &&\n            lst[j] < 0)\n        {\n        \
    \    return std::make_tuple(std::nullopt, std::nullopt);\n        }\n        else\
    \ if (lst[i] == 0 &&\n            lst[j] == 0) {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n        else if (lst[i] == 0 &&\n            lst[j]\
    \ == 0) {\n            return std::make_tuple(std::nullopt, std::nullopt);\n \
    \       }\n        else if (lst[i] == 0 &&\n            lst[j] == 0) {\n     \
    \       return std::make_tuple(std::nullopt, std::nullopt);\n        }\n     \
    \   else if (lst[i] == 0 &&", "    if (lst.empty()) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n    auto largest = std::max_element(std::begin(lst),\
    \ std::end(lst));\n    auto smallest = std::min_element(std::begin(lst), std::end(lst));\n\
    \    return std::make_tuple(largest, *smallest < 0 ? std::nullopt : smallest);",
  "    bool flag = false; // Flag to check if any negative or positive integer is\
    \ available.\n    std::optional<long> max_num;  // Maximum value of negative integer\
    \ is found\n    std::optional<long> min_num;  // Minimum value of positive integer\
    \ is found\n    // Find if negative and positive integer is available in the list.\n\
    \    // If they are available, then set flag to true so that we know we\n    //\
    \ need to check only those two integers.\n    for (long i : lst) {\n        if\
    \ (i < 0) {\n            flag = true;\n            max_num = i;\n        } else\
    \ if (i > 0 && flag) {\n            min_num = i;\n            flag = false;\n\
    \        }\n    }\n    // Return tuple if negative and positive integer is available\n\
    \    if (flag) {\n        // If there are negative or positive integer available,\
    \ then return them.\n        return std::make_tuple(max_num, min_num);\n    }\
    \ else {\n        // If there are no negative or positive integers, then return\
    \ None tuple.\n        return std::make_tuple(std::nullopt, std::nullopt);\n \
    \   }", "  int largest = INT_MIN;\n  int smallest = INT_MAX;\n  for (const auto&\
    \ elem : lst) {\n    if (elem > largest) largest = elem;\n    if (elem < smallest)\
    \ smallest = elem;\n  }\n  return std::make_tuple(std::nullopt, std::nullopt);",
  "    long largest = std::numeric_limits<long>::min();\n    long smallest = std::numeric_limits<long>::max();\n\
    \    if (lst.size() == 0) {\n        return std::tuple<std::optional<long>, std::optional<long>>{std::nullopt,\
    \ std::nullopt};\n    }\n    for (long v : lst) {\n        if (v > largest) {\n\
    \            largest = v;\n        }\n        if (v < smallest) {\n          \
    \  smallest = v;\n        }\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>{std::nullopt, std::nullopt};", "    if (lst.empty()) {\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n    }\n    long a = 0, b = lst.front();\n    for (long\
    \ i : lst) {\n        if (a > i)\n            a = i;\n        if (b < i)\n   \
    \         b = i;\n    }\n    return std::make_tuple(std::make_optional(a), std::make_optional(b));",
  "  std::optional<long> a{};\n  std::optional<long> b{};\n  for (auto i : lst) {\n\
    \    if (a && b) break;\n    if (i < 0) {\n      a = 0;\n    } else if (i > 0)\
    \ {\n      b = 0;\n    } else {\n      a = i;\n    }\n  }\n  return std::tuple{a,\
    \ b};", "        std::optional<long> smallest, largest;\n        auto it = std::min_element(std::begin(lst),\
    \ std::end(lst));\n        smallest = *it;\n        it = std::max_element(std::begin(lst),\
    \ std::end(lst));\n        largest = *it;\n        return std::make_tuple(smallest,\
    \ largest);\n    }\n// Create a function named largest_smallest_integers that\
    \ takes\n// two integers as parameters, and returns the largest of the\n// two,\
    \ and if the first integer is less than the second,\n// the function should return\
    \ None.\n// Examples:\n// largest_smallest_integers(10, 6) == (6, 6)\n// largest_smallest_integers(10,\
    \ 10) == (None, 10)\nstd::tuple<std::optional<long>, std::optional<long>> largest_smallest_integers(int\
    \ a, int b) {\n        auto res = largest_smallest_integers(std::vector<long>{a,\
    \ b});\n        return std::make_tuple(res->first, res->second);\n    }\n// Create\
    \ a function that returns a tuple (a, b), where 'a' is\n// the smallest of negative\
    \ integers, and 'b' is the largest\n// of positive integers in a list.\n// If\
    \ there is no negative or positive integers, return them as None.\n// Examples:\n\
    // smallest_largest_integers([2, 4, 1, 3, 5, 7]) == (1, None)\n// smallest_largest_integers([])\
    \ == (None, None)\n// smallest_largest_integers([0]) == (None, None)\nstd::tuple<std::optional<long>,\
    \ std::optional<long>> smallest_largest_integers(std::vector<long> lst) {\n  \
    \      std::optional<long> smallest, largest;\n        auto it = std::max_element(std::begin(lst),\
    \ std::end(lst));\n        smallest = *it;\n        it = std::min_element(std::begin(lst),\
    \ std::end(lst));\n        largest = *it;\n        return std::make_tuple(smallest,\
    \ largest);\n    }\n// Create a function named smallest_largest_integers that\
    \ takes\n// two integers as parameters, and returns the smallest of the\n// two,\
    \ and if the first integer is greater than the second,\n// the function should\
    \ return None.\n// Examples:\n// smallest_largest_integers(10, 6) == (1, 10)\n\
    // smallest_largest_integers(10, 10) == (None, None)\nstd::tuple<std::optional<long>,\
    \ std::optional<long>> smallest_largest_integers(int a, int b) {\n        auto\
    \ res = smallest_largest_integers(std::vector<long>{a, b});\n        return std::make_tuple(res->first,\
    \ res->second);\n    }\n// Create a function named largest_largest_integer", " \
    \   // Write your code here.\n    bool flag=true;\n    long min=-1000L,max=-1000L;\n\
    \    for (long i:lst)\n    {\n        if(i<min)\n            min=i;\n        if(i>max)\n\
    \            max=i;\n    }\n    if(flag && min==max)\n    {\n        return std::make_tuple(std::nullopt,std::nullopt);\n\
    \    }\n    else if(flag)\n    {\n        return std::make_tuple(std::optional<long>(min),std::optional<long>(max));\n\
    \    }\n    else \n        return std::make_tuple(std::optional<long>(0),std::optional<long>(0));",
  "    // Write your code here\n    auto is_positive = [](auto x) {\n        return\
    \ x > 0;\n    };\n    auto is_negative = [](auto x) {\n        return x < 0;\n\
    \    };\n\n    auto neg = [](auto x) {\n        return x < 0;\n    };\n    auto\
    \ pos = [](auto x) {\n        return x > 0;\n    };\n\n    int max = std::numeric_limits<int>::max();\n\
    \    int min = std::numeric_limits<int>::min();\n\n    for (auto x : lst) {\n\
    \        if (is_positive(x)) {\n            if (x > max) {\n                max\
    \ = x;\n            }\n        } else if (is_negative(x)) {\n            if (x\
    \ < min) {\n                min = x;\n            }\n        }\n    }\n\n    return\
    \ std::make_tuple(std::optional(max), std::optional(min));", "    // Write your\
    \ code here\n    long largest = INT_MIN;\n    long smallest = LONG_MAX;\n\n  \
    \  for (auto x : lst) {\n        if (x>largest) largest = x;\n        if (x<smallest)\
    \ smallest = x;\n    }\n    return std::make_pair(std::nullopt,std::nullopt);",
  "  if (lst.empty()) {\n    return {{}, {}};\n  }\n\n  // Sort the list\n  auto lst_sorted\
    \ = std::move(lst).sort();\n\n  // Find the first and last non-zero elements.\n\
    \  auto begin = std::find_if(lst_sorted.begin(), lst_sorted.end(),\n         \
    \                  [](long x) { return !(x == 0); });\n  auto end = lst_sorted.end();\n\
    \n  // Return None if the list is not sorted.\n  if (begin != end) {\n    return\
    \ {\n        std::max({lst_sorted[begin - 1]}, std::nullopt),\n        std::min({lst_sorted[end\
    \  - 1]}, std::nullopt),\n    };\n  }\n\n  // Return None if the list is empty.\n\
    \  return {{}, {}};", "    auto cmp = [](long a, long b) { return a > b; };\n\
    \    std::optional<long> largest_val = std::nullopt;\n    std::optional<long>\
    \ smallest_val = std::nullopt;\n    for (long val : lst) {\n        if (val >\
    \ largest_val) {\n            largest_val = val;\n        } else if (val < smallest_val)\
    \ {\n            smallest_val = val;\n        }\n    }\n    if (largest_val ==\
    \ std::nullopt) {\n        return std::tuple<std::optional<long>, std::optional<long>>();\n\
    \    } else if (smallest_val == std::nullopt) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(largest_val);\n    } else {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(largest_val, smallest_val);\n    }", "    if (lst.empty())\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    auto it = std::max_element(lst.begin(), lst.end());\n  \
    \  auto it = std::min_element(lst.begin(), lst.end());\n    if (*it < *(lst.begin()))\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    if (*it > *(lst.rbegin()))\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>{std::optional<long>(*it), std::optional<long>(*(lst.rbegin()))};",
  "    long a, b;\n    if (lst.empty()) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n    a = std::max(lst.front());\n    for (long i = lst.size()\
    \ - 1; i >= 0; i--) {\n        b = std::min(lst.at(i));\n        if (a > b) {\n\
    \            a = b;\n        }\n    }\n    return std::make_tuple(std::optional<long>(a),\
    \ std::optional<long>(b));", "    \n    sort(lst.begin(), lst.end());\n    long\
    \ highest = get_max(lst.begin(), lst.end());\n    long lowest = get_min(lst.begin(),\
    \ lst.end());\n    return std::tuple<std::optional<long>, std::optional<long>>(highest,\
    \ lowest);", "    // write your code in C++17\n    std::optional<long> largest_value{};\n\
    \    std::optional<long> smallest_value{};\n    for (auto val : lst) {\n     \
    \   if (val > largest_value) {\n            largest_value = val;\n        } else\
    \ if (val < smallest_value) {\n            smallest_value = val;\n        }\n\
    \    }\n    return std::make_tuple(largest_value, smallest_value);", "    // Code\
    \ here\n    // code here\n    // code here\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional<long>(),std::optional<long>());", "  // Your\
    \ code goes here\n  if (lst.empty()) {\n    return {{}, {}};\n  }\n  std::optional<long>\
    \ max_val = *std::max_element(std::begin(lst), std::end(lst));\n  std::optional<long>\
    \ min_val = *std::min_element(std::begin(lst), std::end(lst));\n  return {max_val,\
    \ min_val};", "    auto largest = std::nullopt;\n    auto smallest = std::nullopt;\n\
    \    for(auto val : lst) {\n        if(val < 0)\n            largest = val;\n\
    \        else\n            smallest = val;\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(largest, smallest);", "  // Your code here\n  std::optional<long>\
    \ optmin;\n  std::optional<long> optmax;\n  optmin = optmax = lst[0];\n  for (int\
    \ i = 1; i < lst.size(); ++i) {\n    if (lst[i] < optmin) {\n      optmin = std::nullopt;\n\
    \    } else if (lst[i] > optmax) {\n      optmax = std::nullopt;\n    }\n  }\n\
    \  return std::make_tuple(optmin, optmax);", "    if(lst.empty()) {\n        return\
    \ std::tuple<std::optional<long>, std::optional<long>>{std::nullopt, std::nullopt};\n\
    \    }\n    std::vector<std::pair<long, bool>> temp{std::make_pair(lst.front(),\
    \ true)};\n    for(long i : lst) {\n        if(temp[i].second) {\n           \
    \ if(temp[i].first > i) {\n                temp.erase(temp.begin() + i);\n   \
    \             temp.emplace_back(i, false);\n            } else {\n           \
    \     temp.emplace_back(i, true);\n            }\n        }\n    }\n    return\
    \ std::tuple<std::optional<long>, std::optional<long>>{std::get<1>(temp.rbegin()),\
    \ std::get<0>(temp.rbegin())};", "    std::vector<std::optional<long>> result(1);\n\
    \    long largest = -INFINITY;\n    long smallest = INFINITY;\n    for (const\
    \ auto num : lst) {\n        if (num <= smallest) {\n            result[0] = {std::nullopt};\n\
    \        } else if (num <= largest) {\n            result[0] = {smallest};\n \
    \       } else {\n            result[0] = {largest};\n        }\n        if (num\
    \ >= smallest) {\n            if (num >= largest) {\n                smallest\
    \ = num;\n            } else {\n                largest = num;\n            }\n\
    \        }\n    }\n    return result[0];", "    auto largest = std::nullopt;\n\
    \    auto smallest = std::nullopt;\n    for (long i : lst) {\n        if (i <\
    \ 0) {\n            smallest = i;\n        } else if (i > largest.value()) {\n\
    \            largest = std::optional<long>(i);\n        }\n    }\n    if (smallest.has_value())\
    \ {\n        return std::make_tuple(smallest, largest);\n    }\n    return std::make_tuple(largest,\
    \ smallest);", "  std::optional<long> min{std::numeric_limits<long>::max()};\n\
    \  std::optional<long> max{std::numeric_limits<long>::min()};\n  std::optional<long>\
    \ max_elem{std::numeric_limits<long>::max()};\n  for (auto x : lst) {\n    if\
    \ (x < 0) {\n      if (std::optional<long>::has_value(min)) {\n        if (x >\
    \ max) {\n          max = x;\n        }\n      } else if (std::optional<long>::has_value(max_elem))\
    \ {\n        if (x > max_elem) {\n          max_elem = x;\n        }\n      }\
    \ else {\n        max = x;\n      }\n    } else if (x > 0) {\n      if (std::optional<long>::has_value(max))\
    \ {\n        if (x < max) {\n          max = x;\n        }\n      } else if (std::optional<long>::has_value(max_elem))\
    \ {\n        if (x < max_elem) {\n          max_elem = x;\n        }\n      }\
    \ else {\n        max = x;\n      }\n    }\n  }\n  return std::make_tuple(min,\
    \ max);", "    assert(lst.size() >= 1);\n    // sort the list from largest to\
    \ smallest\n    long largest_num = std::accumulate(lst.begin(), lst.end(), 0ll);\n\
    \    std::sort(lst.begin(), lst.end(), [](long a, long b){ return b > a; });\n\
    \    std::tuple<std::optional<long>, std::optional<long>> ret{\n        {\n  \
    \          std::optional<long> tmp{None};\n            if (largest_num < std::get<0>(tmp))\
    \ largest_num = std::get<0>(tmp);\n        },\n        {\n            std::optional<long>\
    \ tmp{None};\n            if (largest_num > std::get<1>(tmp)) largest_num = std::get<1>(tmp);\n\
    \        }\n    };\n    return ret;", "    std::vector<long> max_list(lst.size());\n\
    \    std::vector<long> min_list(lst.size());\n    // Sort the list from largest\
    \ to smallest.\n    std::stable_sort(lst.begin(), lst.end(), std::greater<>());\n\
    \    // Get the largest and smallest values in the list.\n    for (size_t i =\
    \ 0; i < lst.size(); ++i) {\n        if (lst[i] > max_list[i]) {\n           \
    \ max_list[i] = lst[i];\n        } else if (lst[i] < min_list[i]) {\n        \
    \    min_list[i] = lst[i];\n        }\n    }\n    // If there are no negative\
    \ or positive integers, return them as None.\n    if (min_list.empty()) {\n  \
    \      return std::make_tuple(std::nullopt, std::nullopt);\n    }\n    // If there\
    \ are both negative and positive integers, return them as (min(min), max(max)).\n\
    \    if (max_list.empty()) {\n        return std::make_tuple(min_list[0], std::nullopt);\n\
    \    }\n    // If there are neither negative nor positive integers, return them\
    \ as None.\n    return std::make_tuple(min_list[max_list.size() - 1], max_list[max_list.size()\
    \ - 1]);", "    long a = std::numeric_limits<long>::min();\n    long b = std::numeric_limits<long>::max();\n\
    \    for (const long &i : lst) {\n        if (i < 0) {\n            if (b > i)\
    \ {\n                b = i;\n            }\n        } else if (i > 0) {\n    \
    \        if (a < i) {\n                a = i;\n            }\n        }\n    }\n\
    \    return std::make_tuple(std::optional<long>(a), std::optional<long>(b));",
  "  std::optional<long> max = std::nullopt;\n  std::optional<long> min = std::nullopt;\n\
    \  for(auto x: lst) {\n    max = std::max(max, x);\n    min = std::min(min, x);\n\
    \  }\n  return std::make_tuple(min, max);", "    if (lst.empty())\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    long largest = lst.front();\n\
    \    long smallest = lst.back();\n    for (long i = 0; i < lst.size(); i++) {\n\
    \        std::optional<long> ls = largest_smallest_integers(lst.sublist(1, lst.size()\
    \ - 1));\n        if (ls.has_value())\n            largest = std::max(ls.value(),\
    \ largest);\n        std::optional<long> lb = largest_smallest_integers(lst.sublist(0,\
    \ i));\n        if (lb.has_value())\n            smallest = std::min(lb.value(),\
    \ smallest);\n    }\n    return std::make_tuple(largest, smallest);", "    long\
    \ max_val{0};\n    long min_val{0};\n    for (long i : lst)\n    {\n        if\
    \ (i < 0) \n        {\n            if (max_val > 0)\n            {\n         \
    \       std::optional<long> res(max_val);\n                return res;\n     \
    \       }\n        }\n        else\n        {\n            if (min_val < 0)\n\
    \            {\n                std::optional<long> res(min_val);\n          \
    \      return res;\n            }\n        }\n        max_val = i;\n        min_val\
    \ = i;\n    }\n    std::optional<long> res(max_val);\n    return res;", "  //\
    \ your code here\n  std::optional<long> largest_integer = std::nullopt;\n  std::optional<long>\
    \ smallest_integer = std::nullopt;\n  for (size_t i = 0; i < lst.size(); ++i)\
    \ {\n    if(lst[i] >= 0) {\n      if (largest_integer.has_value()) std::swap(largest_integer,\
    \ lst[i]);\n    } else if (smallest_integer.has_value()) {\n      if (lst[i] <\
    \ smallest_integer) {\n        std::swap(smallest_integer, lst[i]);\n      }\n\
    \    } else {\n      if (lst[i] < smallest_integer.value()) {\n        smallest_integer\
    \ = std::nullopt;\n        smallest_integer = lst[i];\n      } else if (lst[i]\
    \ > largest_integer.value()) {\n        largest_integer = std::nullopt;\n    \
    \    largest_integer = lst[i];\n      }\n    }\n  }\n  return std::make_tuple(largest_integer,\
    \ smallest_integer);", "    if(lst.empty()) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    }\n    if(lst.size()\
    \ <= 1) {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }\n    std::vector<std::optional<long>> res(2);\n    if(!res[0])\
    \ {\n        res[0] = std::nullopt;\n        res[1] = std::nullopt;\n    }\n \
    \   if(!res[1]) {\n        res[1] = std::nullopt;\n        res[0] = std::nullopt;\n\
    \    }\n    long a = lst[0];\n    long b = lst[1];\n    for(size_t i = 2; i <\
    \ lst.size(); ++i) {\n        bool a_lt_b = a < b;\n        bool b_lt_a = b <\
    \ a;\n        if(!res[a_lt_b]) // a was less than b\n        {\n            res[a_lt_b]\
    \ = std::nullopt;\n        }\n        res[b_lt_a] = std::nullopt;\n        a =\
    \ b;\n        b = lst[i];\n    }\n    return res;", "    auto min_value = std::numeric_limits<long>::min();\n\
    \    auto max_value = std::numeric_limits<long>::max();\n\n    // Return only\
    \ those integers in lst that were not None before\n    for (long num : lst) {\n\
    \        if (std::optional<long> opt_num = num) {\n            if (num < min_value)\
    \ {\n                min_value = num;\n            } else if (num > max_value)\
    \ {\n                max_value = num;\n            }\n        }\n    }\n\n   \
    \ return std::make_tuple(max_value, min_value);", "    bool positive_ints = false;\n\
    \    long largest_int = 0;\n    for (long x: lst) {\n        if (x > 0) {\n  \
    \          positive_ints = true;\n            largest_int = x;\n        } else\
    \ if (x < 0) {\n            largest_int = 0;\n        }\n    }\n    if (positive_ints)\
    \ {\n        return std::make_tuple(std::nullopt, largest_int);\n    } else {\n\
    \        return std::make_tuple(std::nullopt, std::nullopt);\n    }", "    long\
    \ largest = std::optional<long>{};\n    long smallest = std::optional<long>{};\n\
    \    // Loop from end to begin\n    for (long i{}; i < lst.size(); ++i) {\n  \
    \      bool is_negative = (lst[i] < 0);\n        if (is_negative && smallest)\
    \ {\n            smallest = 0;\n        }\n        else if (is_negative && !smallest)\
    \ {\n            smallest = std::optional<long>{};\n        }\n        else if\
    \ (lst[i] > largest && !smallest) {\n            largest = std::optional<long>{};\n\
    \            smallest = std::optional<long>{};\n        }\n        else if (lst[i]\
    \ > largest && smallest) {\n            largest = std::optional<long>{};\n   \
    \         smallest = std::optional<long>{};\n        }\n        else if (lst[i]\
    \ < smallest && !largest) {\n            largest = std::optional<long>{};\n  \
    \          smallest = std::optional<long>{};\n        }\n        else if (lst[i]\
    \ < smallest && largest) {\n            largest = std::optional<long>{};\n   \
    \         smallest = std::optional<long>{};\n        }\n        else if (is_negative\
    \ && !smallest) {\n            smallest = std::optional<long>{};\n        }\n\
    \        else if (lst[i] > largest && !largest) {\n            largest = std::optional<long>{};\n\
    \        }\n        else if (lst[i] > largest && largest) {\n            largest\
    \ = std::optional<long>{};\n        }\n        else if (lst[i] < smallest && smallest)\
    \ {\n            smallest = std::optional<long>{};\n        }\n        else if\
    \ (lst[i] < smallest && smallest) {\n            smallest = std::optional<long>{};\n\
    \        }\n    }\n    return std::tuple<std::optional<long>, std::optional<long>>(largest,\
    \ smallest);", "    std::vector<std::pair<long, long>> sorted_list(std::begin(lst),\
    \ std::end(lst));\n    std::sort(sorted_list.begin(), sorted_list.end(), [](const\
    \ std::pair<long, long>& p1, const std::pair<long, long>& p2) -> bool {\n    \
    \    return p1.first < p2.first;\n    });\n    long max = 0;\n    long min = 0;\n\
    \    if (sorted_list[0] < sorted_list[1]) {\n        min = sorted_list[0].first;\n\
    \        max = sorted_list[1].first;\n    } else {\n        min = sorted_list[1].first;\n\
    \        max = sorted_list[0].first;\n    }\n    std::optional<long> a{max};\n\
    \    std::optional<long> b{min};\n    return std::make_tuple(a, b);", "    int\
    \ n = lst.size();\n    auto [max_i, min_i] = std::minmax_element(lst.begin(),\
    \ lst.end());\n    if (max_i == lst.end()) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    }\n    if (min_i == lst.end())\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }\n    if (max_i == lst.begin()) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    }\n    if (min_i == lst.begin())\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }\n    std::optional<long> max_val = *max_i;\n    std::optional<long>\
    \ min_val = *min_i;\n    for (auto i = 2; i < n; ++i) {\n        if (max_val >\
    \ lst[i]) {\n            max_val = lst[i];\n        }\n        if (min_val < lst[i])\
    \ {\n            min_val = lst[i];\n        }\n    }\n    if (max_val != std::nullopt)\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>(max_val,\
    \ min_val);\n    } else {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }", "    if(lst.empty()){\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    }\n    long largest =\
    \ -INFINITY;\n    long smallest = INFINITY;\n    for(long i : lst){\n        if(i\
    \ < smallest){\n            smallest = i;\n        }\n        if(i > largest){\n\
    \            largest = i;\n        }\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::make_optional<long>(largest), std::make_optional<long>(smallest));",
  "    long smallest_val = std::numeric_limits<long>::min();\n    long largest_val\
    \ = std::numeric_limits<long>::max();\n    for (size_t i = 0; i < lst.size();\
    \ ++i) {\n        if (lst[i] < smallest_val) {\n            smallest_val = lst[i];\n\
    \        } else if (lst[i] > largest_val) {\n            largest_val = lst[i];\n\
    \        }\n    }\n    return std::make_tuple(std::nullopt,std::nullopt);", " \
    \   if (lst.size() == 0) {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n    }\n\n    // The min and max variables are initialized\
    \ to -1 so that we can\n    // check if they are less than or greater than any\
    \ positive number in\n    // the list using std::min() and std::max().\n    long\
    \ min = -1;\n    long max = -1;\n    long largest = -1;\n    long smallest = -1;\n\
    \n    for (long n : lst) {\n        // If this is the first element in the list,\
    \ the min and max\n        // will be 1 and n, respectively.\n        if (min\
    \ == -1) {\n            max = n;\n            min = n;\n            largest =\
    \ n;\n            smallest = n;\n            // If we reach the end of the list,\
    \ then these variables will\n            // be set to the first element in the\
    \ list.\n            continue;\n        }\n\n        // If this is the second\
    \ element in the list, then the max and\n        // min will be the previous max\
    \ and min and the next element,\n        // respectively, and so on.\n       \
    \ if (max < n) {\n            max = n;\n        }\n        if (min > n) {\n  \
    \          min = n;\n        }\n        largest = std::max(largest, n);\n    \
    \    smallest = std::min(smallest, n);\n    }\n\n    // If largest or smallest\
    \ are equal to -1 (no negative or positive integers),\n    // the function returns\
    \ None instead of None (no negative or positive integers).\n    if (largest ==\
    \ -1 || smallest == -1) {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n    }\n\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional<long>(largest), std::optional<long>(smallest));",
  "    for (auto i : lst) {\n        if (i < 0) {\n            return {i, None};\n\
    \        } else if (i >= 0) {\n            return {None, i};\n        }\n    }\n\
    \    return {None, None};", "    auto comp = [](const long a, const long b) {\
    \ return a > b; };\n    auto max = [&comp](long a, long b) { return std::max(a,\
    \ b); };\n    auto min = [&comp](long a, long b) { return std::min(a, b); };\n\
    \    auto max_min = [](std::vector<long> lst) {\n        long a = std::numeric_limits<long>::max();\n\
    \        long b = std::numeric_limits<long>::min();\n        for (long elem :\
    \ lst) {\n            if (elem < a) a = elem;\n            if (elem > b) b = elem;\n\
    \        }\n        return std::make_tuple(a, b);\n    };\n    if (lst.size()\
    \ == 0) return std::make_tuple(std::optional<long>(), std::optional<long>());\n\
    \    auto max_min_list = max_min(std::move(lst));\n    if (max_min_list.first\
    \ == std::optional<long>()) return std::make_tuple(std::optional<long>(), std::optional<long>());\n\
    \    if (max_min_list.second == std::optional<long>()) return std::make_tuple(std::optional<long>(),\
    \ std::optional<long>());\n    if (comp(max_min_list.first->first, max_min_list.second->first))\
    \ return std::make_tuple(std::optional<long>(), std::optional<long>());\n    if\
    \ (comp(max_min_list.first->second, max_min_list.second->second)) return std::make_tuple(std::optional<long>(),\
    \ std::optional<long>());\n    if (comp(max_min_list.first->first, max_min_list.second->first))\
    \ return std::make_tuple(std::optional<long>(), std::optional<long>());\n    return\
    \ std::make_tuple(std::optional<long>(std::max(*max_min_list.first, *max_min_list.second)),\
    \ std::optional<long>(std::min(*max_min_list.first, *max_min_list.second)));",
  "    // Your code here\n    std::optional<long> max_val{};\n    std::optional<long>\
    \ min_val{};\n    for(auto i : lst){\n        if (max_val == std::nullopt){\n\
    \            max_val = i;\n        } else if (min_val == std::nullopt){\n    \
    \        min_val = i;\n        } else if (i < 0){\n            max_val = i;\n\
    \        } else if (i > 0){\n            min_val = i;\n        }\n    }\n    if(max_val\
    \ == std::nullopt){\n        max_val = min_val;\n    }\n    return std::make_tuple(max_val,\
    \ min_val);", "    if (lst.size() < 2) return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    int largest = *std::max_element(lst.begin(), lst.end());\
    \ // Find the largest number\n    std::vector<long> pos;\n    std::vector<long>\
    \ neg;\n    for (long i : lst) {\n        if (i < 0) neg.push_back(i); // Keep\
    \ track of negative numbers\n        else pos.push_back(i);   // Keep track of\
    \ positive numbers\n    }\n    if (pos.size() > neg.size()) {\n        largest\
    \ = *std::min_element(pos.begin(), pos.end()); // Find the smallest number\n \
    \       return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(largest),\
    \ std::optional<long>(std::numeric_limits<long>::max()));\n    }\n    if (neg.size()\
    \ > pos.size()) {\n        largest = *std::max_element(neg.begin(), neg.end());\
    \ // Find the largest number\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(std::numeric_limits<long>::max()),\
    \ std::optional<long>(largest));\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional<long>(std::numeric_limits<long>::max()),\
    \ std::optional<long>(std::numeric_limits<long>::min()));", "    auto it1 = std::max_element(lst.begin(),\
    \ lst.end());\n    auto it2 = std::min_element(lst.begin(), lst.end());\n    if(it1\
    \ != lst.end()) {\n        auto a = *it1;\n        if(a < 0) return { std::optional<long>{a},\
    \ std::optional<long>{*it2} };\n    }\n    if(it2 != lst.end()) {\n        auto\
    \ b = *it2;\n        if(b > 0) return { std::optional<long>{b}, std::optional<long>{*it1}\
    \ };\n    }\n    return std::make_tuple(std::optional<long>{}, std::optional<long>{});",
  "    std::optional<long> a, b;\n    for(auto c : lst){\n        if(a != std::optional<long>{}){\n\
    \            if (c > a.value())\n            {\n                a = std::optional<long>{c};\n\
    \            }\n        }\n        else\n        {\n            a = std::optional<long>{c};\n\
    \        }\n        if(b.value() == std::optional<long>{}){\n            b = std::optional<long>{c};\n\
    \        }\n        else{\n            if (c < b.value())\n            {\n   \
    \             b = std::optional<long>{c};\n            }\n        }\n    }\n \
    \   if (b.value() == std::optional<long>{}){\n        b = std::optional<long>{};\n\
    \    }\n    return std::make_tuple(a, b);", "    if (lst.empty()) {\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    }\n    auto it = std::max_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.begin()) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n    auto it1 = std::min_element(lst.begin(), it);\n \
    \   if (it1 == lst.end()) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    }\n    // The largest and smallest values will exist in *it* and *it1*.\n\
    \    return std::make_tuple(*it, *it1);", "    if (lst.size() < 2) {\n       \
    \ return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt, std::nullopt);\n\
    \    }\n    std::optional<long> largest = std::nullopt;\n    std::optional<long>\
    \ smallest = std::nullopt;\n    for (long i : lst) {\n        if (i < 0) {\n \
    \           if (largest == std::nullopt) {\n                largest = i;\n   \
    \         } else {\n                largest = std::nullopt;\n            }\n \
    \       } else {\n            if (smallest == std::nullopt) {\n              \
    \  smallest = i;\n            } else {\n                smallest = std::nullopt;\n\
    \            }\n        }\n    }\n    if (largest != std::nullopt && smallest\
    \ != std::nullopt) {\n        return std::tuple<std::optional<long>, std::optional<long>>(largest,\
    \ smallest);\n    } else {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }", "    if (lst.empty()) return std::tuple<std::optional<long>,\
    \ std::optional<long>>{std::optional<long>{nullptr}, std::optional<long>{nullptr}};\n\
    \    if (lst.size() == 1) {\n        return std::tuple<std::optional<long>, std::optional<long>>{std::optional<long>{*lst.begin()},\
    \ std::optional<long>{nullptr}};\n    }\n    auto ls = *std::min_element(std::begin(lst),\
    \ std::end(lst));\n    auto lt = *std::max_element(std::begin(lst), std::end(lst));\n\
    \    return std::tuple<std::optional<long>, std::optional<long>>{std::optional<long>{ls},\
    \ std::optional<long>{lt}};", "    // Write your code here\n    if (lst.size()\
    \ == 0) {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>{},\
    \ std::optional<long>{});\n    }\n    long largest_value = *std::max_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find_if(lst.begin(), lst.end(), [&largest_value](long\
    \ num) {\n        return num > largest_value;\n    });\n    if (it == lst.end())\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>{},\
    \ std::optional<long>{});\n    }\n    long smallest_value = *std::min_element(lst.begin(),\
    \ it);\n    return std::make_tuple(std::optional(largest_value), std::optional(smallest_value));",
  "    std::optional<long> max;\n    std::optional<long> min;\n    if (lst.size()\
    \ == 0) return (max, min);\n    if (lst.front() >= 0) max = lst.front();\n   \
    \ else min = lst.front();\n    for (long i = 1; i < lst.size(); i++) {\n     \
    \   if (lst.front() < 0) break;\n        if (lst.front() > lst.back()) max = lst.front();\n\
    \        else min = lst.back();\n        max = std::max(max, lst.front());\n \
    \       min = std::min(min, lst.back());\n    }\n    return (max, min);", "  \
    \  auto a = std::max_element(std::begin(lst), std::end(lst));\n    auto b = std::min_element(std::begin(lst),\
    \ std::end(lst));\n    // If there are no negative or positive integers, return\
    \ them as None.\n    if (a == std::end(lst) && b == std::end(lst)) {\n       \
    \ return std::make_tuple(std::nullopt, std::nullopt);\n    }\n    // Otherwise\
    \ return the largest of the two numbers.\n    return std::make_tuple(a, b);",
  "    long max_negative = 0;\n    long min_positive = std::numeric_limits<long>::max();\n\
    \    for (auto&& num : lst) {\n        if (num <= 0) {\n            max_negative\
    \ = std::max<long>(max_negative, num);\n        }\n        if (num >= 0) {\n \
    \           min_positive = std::min<long>(min_positive, num);\n        }\n   \
    \ }\n\n    std::optional<long> max;\n    std::optional<long> min;\n    if (max_negative\
    \ == std::numeric_limits<long>::max()) {\n        max = std::nullopt;\n    } else\
    \ {\n        max = std::optional<long>(max_negative);\n    }\n    if (min_positive\
    \ == std::numeric_limits<long>::max()) {\n        min = std::nullopt;\n    } else\
    \ {\n        min = std::optional<long>(min_positive);\n    }\n    return std::make_tuple(max,\
    \ min);", "    if (lst.empty()) {\n        return {std::nullopt, std::nullopt};\n\
    \    }\n    auto largest = *std::max_element(lst.begin(), lst.end());\n    auto\
    \ smallest = *std::min_element(lst.begin(), lst.end());\n    if (largest < smallest)\
    \ {\n        return {std::nullopt, smallest};\n    } else {\n        return {largest,\
    \ std::nullopt};\n    }", "    if (lst.size() == 0) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    }\n    std::optional<long> min_int = std::nullopt;\n\
    \    for (auto x : lst) {\n        if (x < 0) {\n            min_int = x;\n  \
    \      }\n    }\n    std::optional<long> max_int = std::nullopt;\n    for (auto\
    \ x : lst) {\n        if (x >= 0) {\n            max_int = x;\n        }\n   \
    \ }\n    return std::tuple<std::optional<long>, std::optional<long>>(min_int,\
    \ max_int);", "    long max=-std::numeric_limits<long>::max();\n    long min=\
    \ std::numeric_limits<long>::max();\n    std::optional<long> max_tuple;\n    std::optional<long>\
    \ min_tuple;\n    for (long i : lst) {\n        if (i < 0) {\n            min\
    \ = i;\n        } else if (i > max) {\n            max = i;\n        }\n     \
    \   if (max_tuple) {\n            if (i > max) {\n                max = i;\n \
    \               max_tuple = std::nullopt;\n            }\n            if (i <\
    \ min) {\n                min = i;\n                min_tuple = std::nullopt;\n\
    \            }\n        } else {\n            if (i < min) {\n               \
    \ min = i;\n                min_tuple = std::nullopt;\n            }\n       \
    \     if (i > max) {\n                max = i;\n                max_tuple = std::nullopt;\n\
    \            }\n        }\n    }\n    if (min_tuple) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>{max_tuple, min_tuple};\n    } else {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>{std::nullopt, std::nullopt};\n    }", "    // Your code\
    \ here\n    std::optional<long> smallest = std::nullopt;\n    std::optional<long>\
    \ largest = std::nullopt;\n    if (lst.size() == 0)\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(smallest, largest);\n    std::vector<long> max_of_positives\
    \ = std::vector<long>(lst.begin() + 1, lst.end());\n    std::vector<long> min_of_negatives\
    \ = std::vector<long>(lst.begin(), lst.begin() + 1);\n    std::vector<long> both\
    \ = max_of_positives;\n    both.insert(max_of_positives.end(), min_of_negatives.begin(),\
    \ min_of_negatives.end());\n    for (const auto& i : both)\n        if ((i < 0)\
    \ && (smallest == std::nullopt))\n            smallest = i;\n        else if (i\
    \ > 0)\n            largest = i;\n    return std::tuple<std::optional<long>, std::optional<long>>(smallest,\
    \ largest);", "    long long largest = std::numeric_limits<long long>::min();\n\
    \    long long smallest = std::numeric_limits<long long>::max();\n\n    for (long\
    \ long i : lst) {\n        if ((i > 0 && i <= largest) || (i < 0 && i < smallest))\
    \ {\n            largest = std::max(i, largest);\n            smallest = std::min(i,\
    \ smallest);\n        } else {\n            return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n        }\n    }\n    return std::make_tuple(std::optional(largest),\
    \ std::optional(smallest));", "    if(lst.empty()) return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    long a = -std::numeric_limits<long>::min();\n    long b\
    \ = std::numeric_limits<long>::max();\n    for(long x : lst)\n    {\n        if(x\
    \ < a) a = x;\n        if(x > b) b = x;\n    }\n    return std::make_tuple(std::optional<long>(a),\
    \ std::optional<long>(b));", "    long min = -LLONG_MAX;\n    long max = LLONG_MAX;\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n        if (i > max) {\n            max = i;\n        }\n    }\n    return\
    \ std::make_tuple(std::optional<long>(min), std::optional<long>(max));", "  if\
    \ (lst.empty()) return std::make_tuple(std::nullopt, std::nullopt);\n  std::optional<long>\
    \ biggest_int = 0;\n  std::optional<long> smallest_int = 0;\n  for (auto x : lst)\
    \ {\n    if (x < 0) smallest_int = -x;\n    if (x >  0) biggest_int  = x;\n  }\n\
    \  return std::make_tuple(smallest_int, biggest_int);", "    if (lst.size() <\
    \ 2) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n    }\n \
    \   long max = lst.front();\n    for (long i : lst) {\n        if (i > max) {\n\
    \            max = i;\n        }\n    }\n    long min = lst.front();\n    for\
    \ (long i : lst) {\n        if (i < min) {\n            min = i;\n        }\n\
    \    }\n    return std::make_tuple(std::optional<long>(max), std::optional<long>(min));",
  "  // Your code here.\n  // You may use std::max_element and std::min_element to\
    \ solve this problem.\n  // You can also use std::sort or std::partial_sort to\
    \ solve this problem.\n  long max_elem = lst[0];\n  long min_elem = lst[0];\n\
    \  for (int i = 1; i < lst.size(); i++) {\n    max_elem = std::max(max_elem, lst[i]);\n\
    \    min_elem = std::min(min_elem, lst[i]);\n  }\n  if (max_elem < min_elem) return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n  else return std::make_tuple(std::optional<long>(max_elem),\
    \ std::optional<long>(min_elem));", "    std::optional<long> min{std::numeric_limits<long>::max()};\n\
    \    std::optional<long> max{std::numeric_limits<long>::min()};\n    for (const\
    \ auto i : lst) {\n        if (max < i) {\n            max = i;\n        }\n \
    \       if (min > i) {\n            min = i;\n        }\n    }\n    return std::make_tuple(min,\
    \ max);", "    long largest = std::nullopt;\n    long smallest = std::nullopt;\n\
    \n    for (long i : lst)\n        if (i < 0 && largest < i) largest = i;\n   \
    \     else if (i > 0 && smallest > i) smallest = i;\n        else return std::make_tuple(largest,\
    \ smallest);\n\n    return std::make_tuple(largest, smallest);", "    if (lst.empty())\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>{};\n\
    \    }\n    std::vector<long> negative;\n    std::vector<long> positive;\n   \
    \ for (long i : lst) {\n        if (i < 0) {\n            negative.push_back(i);\n\
    \        } else if (i > 0){\n            positive.push_back(i);\n        }\n \
    \   }\n    if (negative.size() > positive.size()) {\n        return std::make_tuple(std::optional<long>{},\
    \ std::optional<long>{});\n    }\n    return std::make_tuple(std::optional<long>(std::max(negative.begin(),\
    \ negative.end())),\n                          std::optional<long>(std::min(positive.begin(),\
    \ positive.end())));", "    // Write your code here.\n    long max_val = std::numeric_limits<long>::max();\n\
    \    long min_val = std::numeric_limits<long>::min();\n    for (auto i : lst)\
    \ {\n        max_val = std::max(max_val, i);\n        min_val = std::min(min_val,\
    \ i);\n    }\n\n    if (max_val < 0) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n\n    if (min_val < 0) {\n        return std::make_tuple(std::nullopt,\
    \ min_val);\n    }\n\n    return std::make_tuple(max_val, min_val);", '  // Code
    goes here', "    // Code here\n    if(lst.empty()) return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional<long>{}, std::optional<long>{});\n    long\
    \ max = *std::max_element(lst.begin(), lst.end());\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(max),\
    \ std::optional<long>(min));", "    // write your code in C++17\n    long largest_negative_integer\
    \ = std::numeric_limits<long>::min();\n    long largest_positive_integer = std::numeric_limits<long>::max();\n\
    \    for (long i = 0; i < lst.size(); i++)\n    {\n        if (lst[i] < 0)\n \
    \       {\n            if (largest_negative_integer < 0)\n            {\n    \
    \            largest_negative_integer = lst[i];\n            }\n        }\n  \
    \      else if (lst[i] > 0)\n        {\n            if (largest_positive_integer\
    \ > 0)\n            {\n                largest_positive_integer = lst[i];\n  \
    \          }\n        }\n    }\n    return std::make_tuple(std::optional<long>(largest_negative_integer),\
    \ std::optional<long>(largest_positive_integer));", "  // Start with the largest\
    \ and smallest numbers.\n  std::optional<long> largest = std::nullopt;\n  std::optional<long>\
    \ smallest = std::nullopt;\n  // Iterate over the list.\n  for (auto i : lst)\
    \ {\n    // If this number is less than the smallest or greater\n    // than the\
    \ largest, keep track of the largest, and\n    // the smallest.\n    if (i < smallest)\
    \ {\n      smallest = i;\n    } else if (i > largest) {\n      largest = i;\n\
    \    }\n  }\n  // If the largest and smallest numbers are the same\n  // (all\
    \ positive integers), return them as None.\n  if (largest == smallest) {\n   \
    \ return std::make_tuple(largest, smallest);\n  } else {\n    // Otherwise return\
    \ their minimum (negative) and maximum (positive)\n    // values.\n    return\
    \ std::make_tuple(std::nullopt, largest);\n  }", "  auto it = std::max_element(lst.begin(),\
    \ lst.end());\n  auto it_end = std::min_element(lst.begin(), lst.end());\n  return\
    \ std::make_pair(std::optional<long>(it != lst.end() && it == it_end), std::optional<long>(it\
    \ != lst.begin()));", "    long a = 0;\n    long b = 0;\n    for(auto x:lst){\n\
    \        if(x < 0){\n            a = x;\n        } else {\n            b = x;\n\
    \        }\n    }\n    return std::make_tuple(std::optional<long>(a), std::optional<long>(b));",
  "    long a = 0, b = 0;\n    // If lst is empty, then a and b will be None\n   \
    \ if (lst.size() == 0)\n        return std::make_tuple(std::optional<long>(),\
    \ std::optional<long>());\n    // If there is one integer in the list, then its\
    \ value is that number\n    if (lst.size() == 1)\n        return std::make_tuple(std::optional<long>(lst[0]),\
    \ std::optional<long>());\n    // Use two pointers to go through the list and\
    \ see which one is bigger\n    bool is_neg = false;\n    long min = 0;\n    long\
    \ max = 0;\n    for (long elem : lst) {\n        if (elem < 0) {\n           \
    \ max = elem;\n            is_neg = true;\n        } else if (elem > 0) {\n  \
    \          min = elem;\n        }\n    }\n    // If there is only one element\
    \ in the list, then its value is that number\n    if (min == 0)\n        return\
    \ std::make_tuple(std::optional<long>(min), std::optional<long>());\n    // If\
    \ there is a negative integer in the list, then its value is -max\n    if (is_neg)\
    \ {\n        max = -max;\n    }\n    // If there is a positive integer in the\
    \ list, then its value is max\n    if (min == max)\n        return std::make_tuple(std::optional<long>(),\
    \ std::optional<long>(max));\n    // If there are two or more elements in the\
    \ list, then its value is the minimum of all the numbers\n    if (max < min)\n\
    \        return std::make_tuple(std::optional<long>(min), std::optional<long>(max));\n\
    \    return std::make_tuple(std::optional<long>(min), std::optional<long>());",
  "    for (auto it = lst.begin(); it != lst.end(); it++) {\n        if (*it < 0)\n\
    \            return std::make_tuple(std::nullopt, std::nullopt);\n        if (*it\
    \ > 0)\n            return std::make_tuple(std::nullopt, *it);\n    }\n    return\
    \ std::make_tuple(std::nullopt, std::nullopt);", "    int max = (lst.size()==0)\
    \ ? std::optional<long>{} : std::optional<long>(std::max({lst.begin(), lst.end()}));\n\
    \    int min = (lst.size()==0) ? std::optional<long>{} : std::optional<long>(std::min({lst.begin(),\
    \ lst.end()}));\n    if (max.has_value() && min.has_value()) {\n        return\
    \ std::make_tuple(max, min);\n    }\n    return std::make_tuple(std::optional<long>{},\
    \ std::optional<long>{});", "  std::optional<long> largest{std::nullopt};\n  std::optional<long>\
    \ smallest{std::nullopt};\n\n  // Find the largest and smallest positive integer\
    \ in 'lst'.\n  for (long i : lst) {\n    if (std::abs(i) < smallest) {\n     \
    \ smallest = std::abs(i);\n    } else if (std::abs(i) > largest) {\n      largest\
    \ = std::abs(i);\n    }\n  }\n\n  return std::tuple<std::optional<long>, std::optional<long>>(largest,\
    \ smallest);", "    auto ls = lst.begin();\n    auto lx = lst.end();\n    std::optional<long>\
    \ largest = std::nullopt;\n    std::optional<long> smallest = std::nullopt;\n\
    \    while (ls != lx) {\n        if (ls < 0) {\n            if (smallest == std::nullopt)\
    \ {\n                largest = *ls; smallest = std::nullopt;\n            }\n\
    \            else if (smallest > *ls) {\n                largest = *ls; smallest\
    \ = std::nullopt;\n            }\n        }\n        else {\n            if (largest\
    \ == std::nullopt) {\n                largest = *ls; smallest = std::nullopt;\n\
    \            }\n            else if (largest < *ls) {\n                largest\
    \ = *ls; smallest = std::nullopt;\n            }\n        }\n        ++ls;\n \
    \   }\n    return std::tuple<std::optional<long>, std::optional<long>>(largest,\
    \ smallest);", "    sort(lst.begin(), lst.end());\n    auto iter = std::max_element(lst.begin(),\
    \ lst.end());\n    if (iter != lst.end() && iter > 0) {\n        if (*iter <=\
    \ 0) {\n            return std::make_tuple(std::nullopt, iter - 1);\n        }\
    \ else {\n            return std::make_tuple(iter, std::nullopt);\n        }\n\
    \    } else {\n        return std::make_tuple(std::nullopt, std::nullopt);\n \
    \   }", "  std::optional<long> max;\n  std::optional<long> min;\n  for (long i\
    \ : lst) {\n    if (i > max) {\n      max = i;\n    }\n    if (i < min) {\n  \
    \    min = i;\n    }\n  }\n  if (max == min) {\n    return {std::nullopt, std::nullopt};\n\
    \  } else {\n    return {std::max(min.as_two_times_small(), max.as_two_times_small()),\
    \ std::min(min.as_two_times_small(), max.as_two_times_small())};\n  }", "    long\
    \ max_num = std::numeric_limits<long>::max();\n    long min_num = std::numeric_limits<long>::min();\n\
    \    if (lst.size() > 0)\n    {\n        for (auto i : lst)\n        {\n     \
    \       if (i > 0)\n                max_num = std::max(max_num, i);\n        \
    \    else\n                min_num = std::min(min_num, i);\n        }\n    }\n\
    \    return std::make_tuple(std::nullopt, std::nullopt);", "    if (lst.empty())\
    \ {\n        return {std::nullopt, std::nullopt};\n    }\n    std::optional<long>\
    \ largest = std::nullopt;\n    std::optional<long> smallest = std::nullopt;\n\
    \    for (long l : lst) {\n        if (largest == std::nullopt) {\n          \
    \  smallest = std::nullopt;\n            largest = l;\n        } else if (l >\
    \ largest) {\n            smallest = std::nullopt;\n            largest = l;\n\
    \        } else if (l < smallest) {\n            smallest = l;\n        }\n  \
    \  }\n    return {largest, smallest};", "    std::optional<long> big, small;\n\
    \    if (lst.size() == 0) {\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    }\n    std::optional<long> min;\n    for (const auto &v\
    \ : lst) {\n        if (big != std::nullopt) {\n            if (v < big) {\n \
    \               min = std::nullopt;\n            }\n            else {\n     \
    \           min = v;\n            }\n        }\n        else {\n            min\
    \ = v;\n        }\n        big = v;\n    }\n    if (min != std::nullopt) {\n \
    \       if (big == std::nullopt) {\n            big = min;\n        }\n      \
    \  else {\n            if (min > big) {\n                big = min;\n        \
    \    }\n        }\n    }\n    return std::tuple<std::optional<long>, std::optional<long>>(std::move(big),\
    \ std::move(small));", "    long a, b;\n    if (lst.size() <= 1)\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    a = std::max(std::get<0>(lst.begin()),\
    \ std::get<0>(lst.end()));\n    b = std::min(std::get<1>(lst.begin()), std::get<1>(lst.end()));\n\
    \    return std::make_tuple(std::optional<long>(a), std::optional<long>(b));",
  "    // If there are no items in the list, return an empty tuple.\n    if (lst.empty())\n\
    \        return std::make_tuple(std::optional<long>(), std::optional<long>());\n\
    \    // If there's just one item, just return it.\n    if (lst.size() == 1)\n\
    \        return std::make_tuple(std::optional<long>(), std::optional<long>());\n\
    \    // Create a std::map of the positive integers in the list.\n    std::map<long,\
    \ bool> positive_integers;\n    std::map<long, bool> negative_integers;\n    //\
    \ Add all positive integers in the list.\n    for (long i = 0; i < lst.size();\
    \ ++i) {\n        if (lst[i] >= 0) {\n            positive_integers[lst[i]] =\
    \ true;\n        } else {\n            negative_integers[lst[i]] = true;\n   \
    \     }\n    }\n    // Iterate through the map, finding the largest negative integer\
    \ and\n    // smallest positive integer.\n    std::optional<long> largest_negative_integer\
    \ = std::nullopt;\n    std::optional<long> smallest_positive_integer = std::nullopt;\n\
    \    for (auto it = positive_integers.cbegin(); it != positive_integers.cend();\
    \ ++it) {\n        // If the number is negative, update largest negative integer.\n\
    \        if (negative_integers.find(it->first) == negative_integers.cend())\n\
    \            largest_negative_integer = it->first;\n        // If the number is\
    \ positive, update smallest positive integer.\n        else if (positive_integers.find(it->first)\
    \ == positive_integers.cend())\n            smallest_positive_integer = it->first;\n\
    \    }\n    // Return the largest negative number and the smallest positive number.\n\
    \    return std::make_tuple(largest_negative_integer, smallest_positive_integer);",
  "    std::optional<long> largest = std::nullopt;\n    std::optional<long> smallest\
    \ = std::nullopt;\n    for (auto x : lst) {\n        if (largest == std::nullopt)\
    \ {\n            largest = x;\n        }\n        else if (x < smallest) {\n \
    \           smallest = x;\n        }\n    }\n    if (largest != std::nullopt)\
    \ {\n        return std::make_tuple(largest, smallest);\n    }\n    return std::make_tuple(std::nullopt,\
    \ std::nullopt);", "    // Write your code here.\n    bool flag=false;\n    long\
    \ max=-LLONG_MAX;\n    long min=LLONG_MIN;\n    for(auto i:lst){\n        long\
    \ tmp=i;\n        if(tmp<0){\n            flag=true;\n            tmp=-tmp;\n\
    \        }\n        if(tmp>max){\n            max=tmp;\n        }\n        if(tmp<min){\n\
    \            min=tmp;\n        }\n    }\n    if(flag==false){\n        return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n    }\n    return std::make_tuple(max,min);",
  "    // Write your code here.\n    std::optional<long> largest;\n    std::optional<long>\
    \ smallest;\n    for (auto it = lst.begin(); it != lst.end(); it++) {\n      \
    \  if (*it < 0) {\n            largest = *it;\n        } else if (*it > 0) {\n\
    \            smallest = *it;\n        }\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(largest, smallest);", "    int min = std::numeric_limits<int>::min();\n\
    \    int max = std::numeric_limits<int>::max();\n    std::optional<int> largest;\n\
    \    std::optional<int> smallest;\n    for (auto i : lst) {\n        if (i > largest.has_value())\
    \ largest = i;\n        else if (i < smallest.has_value()) smallest = i;\n   \
    \ }\n    return std::make_tuple(largest, smallest);", "  // Write your code here\n\
    \  std::optional<long> largest{};\n  std::optional<long> smallest{};\n  largest\
    \ = std::nullopt;\n  smallest = std::nullopt;\n  for (auto element : lst) {\n\
    \    if (element < 0) {\n      if (largest == std::nullopt) {\n        largest\
    \ = element;\n      } else if (element > largest) {\n        largest = element;\n\
    \      }\n    } else {\n      if (smallest == std::nullopt) {\n        smallest\
    \ = element;\n      } else if (element < smallest) {\n        smallest = element;\n\
    \      }\n    }\n  }\n  return std::make_tuple(largest, smallest);", "  if (lst.empty())\
    \ {\n    return std::tuple<std::optional<long>, std::optional<long>>();\n  }\n\
    \  long largest_val = std::numeric_limits<long>::max();\n  long smallest_val =\
    \ std::numeric_limits<long>::min();\n  for (long val : lst) {\n    largest_val\
    \ = std::max(largest_val, val);\n    smallest_val = std::min(smallest_val, val);\n\
    \  }\n  return std::tuple<std::optional<long>, std::optional<long>>{std::optional<long>(largest_val),\
    \ std::optional<long>(smallest_val)};", "  std::vector<std::optional<long>> res;\n\
    \  // If there are no integers in the list, return as empty tuple\n  if (lst.empty())\
    \ return std::make_tuple(std::nullopt, std::nullopt);\n  // Add all negative integers\
    \ to the front of the list\n  for (long num : lst) {\n    if (num < 0) res.emplace_back(num);\n\
    \  }\n  // Add all positive integers to the back of the list\n  for (long num\
    \ : lst) {\n    if (num >= 0) res.emplace_back(num);\n  }\n  // If there were\
    \ no negative or positive numbers, return as empty tuple\n  if (res.empty()) return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n  // Find the max and min of each\
    \ list\n  long maxval = *std::max_element(std::begin(res), std::end(res));\n \
    \ long minval = *std::min_element(std::begin(res), std::end(res));\n  // Return\
    \ a tuple with the max and min of the lists\n  return std::make_tuple(std::nullopt,\
    \ std::nullopt);", "  long min = -10;\n  long max = -1;\n  for (long i : lst)\
    \ {\n    min = std::max(min, i);\n    max = std::min(max, i);\n  }\n  return std::make_tuple(std::optional{min},\
    \ std::optional{max});", "  std::optional<long> a, b;\n  if (lst.empty()) {\n\
    \    return (std::nullopt, std::nullopt);\n  }\n  long smallest = *std::min_element(std::begin(lst),\
    \ std::end(lst));\n  long largest = *std::max_element(std::begin(lst), std::end(lst));\n\
    \  if (smallest > largest) {\n    return std::nullopt;\n  }\n  else {\n    a =\
    \ smallest;\n    b = largest;\n  }\n  for (long x : lst) {\n    if (x < 0) {\n\
    \      if (a != std::nullopt) {\n        a = std::nullopt;\n      }\n      if\
    \ (b != std::nullopt) {\n        b = std::nullopt;\n      }\n    }\n    else if\
    \ (a != std::nullopt) {\n      if (x < a || (x == a && x < b)) {\n        a =\
    \ x;\n      }\n    }\n    else if (b != std::nullopt) {\n      if (x > b || (x\
    \ == b && x > a)) {\n        b = x;\n      }\n    }\n  }\n  return std::make_tuple(a,\
    \ b);", "  if (lst.empty()) return std::make_tuple(std::nullopt, std::nullopt);\n\
    \  std::optional<long> min_val(std::numeric_limits<long>::max());\n  std::optional<long>\
    \ max_val(std::numeric_limits<long>::min());\n  for (auto i : lst) \n    if (i\
    \ < min_val) \n      min_val = std::move(i);\n    else if (i > max_val)\n    \
    \  max_val = std::move(i);\n  return std::make_tuple(min_val, max_val);", "  std::optional<long>\
    \ largest = std::nullopt;\n  std::optional<long> smallest = std::nullopt;\n\n\
    \  if (lst.empty()) return std::make_tuple(std::nullopt, std::nullopt);\n\n  for\
    \ (long x : lst) {\n    if (x < 0) {\n      if (largest == std::nullopt) largest\
    \ = x;\n      else smallest = x;\n    } else {\n      if (smallest == std::nullopt)\
    \ smallest = x;\n      else largest = x;\n    }\n  }\n\n  return std::make_tuple(largest,\
    \ smallest);", "    std::optional<long> a{std::numeric_limits<long>::min()};\n\
    \    std::optional<long> b{std::numeric_limits<long>::max()};\n    for (auto element\
    \ : lst) {\n        if (element < 0) {\n            std::swap(a, b);\n       \
    \ }\n        a = std::max(a, element);\n    }\n    if (a) {\n        std::swap(a,\
    \ b);\n    }\n    return std::make_tuple(a, b);", "  if (lst.empty()) return std::make_tuple({},\
    \ {});\n  auto lst_sorted = std::is_sorted(lst.begin(), lst.end());\n  std::optional<long>\
    \ largest = lst.front();\n  std::optional<long> smallest = lst.front();\n  if\
    \ (!lst_sorted) return std::make_tuple(largest, smallest);\n  for (auto const&\
    \ i : lst) {\n    if (i > largest) {\n      largest = i;\n    } else if (i < smallest)\
    \ {\n      smallest = i;\n    }\n  }\n  return std::make_tuple(largest, smallest);",
  "    std::optional<long> biggest_int, smallest_int;\n    for (long i = 0; i < lst.size();\
    \ ++i) {\n        if (lst[i] < 0) {\n            if (biggest_int) \n         \
    \       biggest_int = std::max(biggest_int, lst[i]);\n            else\n     \
    \           biggest_int = std::max(biggest_int, std::optional<long>{});\n    \
    \    } else if (lst[i] > 0) {\n            if (smallest_int)\n               \
    \ smallest_int = std::min(smallest_int, lst[i]);\n            else\n         \
    \       smallest_int = std::min(smallest_int, std::optional<long>{});\n      \
    \  } else {\n            // Both are none. Return None.\n            return biggest_int,\
    \ smallest_int;\n        }\n    }\n    return biggest_int, smallest_int;", " \
    \   std::optional<long> min{ std::numeric_limits<long>::max() };\n    std::optional<long>\
    \ max{ std::numeric_limits<long>::min() };\n    for(auto it = lst.cbegin(); it\
    \ != lst.cend(); ++it) {\n        auto n = *it;\n        if(!n || n < min)\n \
    \           min = n;\n        else if(n > max)\n            max = n;\n    }\n\
    \    return std::tuple<std::optional<long>, std::optional<long>>{ min, max };",
  "    if (lst.empty())\n        return std::tuple<std::optional<long>, std::optional<long>>();\n\
    \    long maxValue = *std::max_element(lst.begin(), lst.end());\n    long minValue\
    \ = *std::min_element(lst.begin(), lst.end());\n    if (maxValue < 0 && minValue\
    \ > 0)\n        return std::tuple<std::optional<long>, std::optional<long>>(maxValue,\
    \ minValue);\n    else if (maxValue > 0)\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(maxValue, minValue);\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>();", "    auto smallest = std::nullopt;\n    auto largest\
    \ = std::nullopt;\n    auto it = std::max_element(lst.cbegin(), lst.cend(), [](long\
    \ a, long b){return (a < b);});\n    if (it == lst.cend()) return std::tuple<std::optional<long>,\
    \ std::optional<long>>{std::nullopt, std::nullopt};\n    largest = *it;\n    it\
    \ = std::min_element(lst.cbegin(), lst.cend(), [](long a, long b){return (a <\
    \ b);});\n    if (it == lst.cend()) return std::tuple<std::optional<long>, std::optional<long>>{std::nullopt,\
    \ std::nullopt};\n    smallest = *it;\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>{smallest, largest};", "  std::optional<long> largest;\n\
    \  std::optional<long> smallest;\n\n  for (long i : lst) {\n    if (std::abs(i)\
    \ <= largest) {\n      if (std::abs(i) < smallest) {\n        smallest = std::abs(i);\n\
    \      }\n      else if (std::abs(i) > largest) {\n        largest = std::abs(i);\n\
    \      }\n    } else if (std::abs(i) > largest) {\n      largest = std::abs(i);\n\
    \    }\n  }\n  return std::tuple<std::optional<long>, std::optional<long>>(largest,\
    \ smallest);", "  long min = std::numeric_limits<long>::min();\n  long max = std::numeric_limits<long>::max();\n\
    \  for (long i : lst) {\n    if (i < min) {\n      min = i;\n    } else if (i\
    \ > max) {\n      max = i;\n    }\n  }\n  return std::make_tuple(std::optional<long>(min),\
    \ std::optional<long>(max));", "    long smallest = std::numeric_limits<long>::min();\n\
    \    long largest = -std::numeric_limits<long>::min();\n    // Loop through the\
    \ input array\n    for (auto n: lst) {\n        if (n < smallest) {\n        \
    \    smallest = n;\n        } else if (n > largest) {\n            largest = n;\n\
    \        }\n    }\n    // If no negative and no positive, return None, None\n\
    \    if (smallest == -std::numeric_limits<long>::min() && largest == std::numeric_limits<long>::min())\
    \ {\n        return {std::nullopt, std::nullopt};\n    }\n    // Return the smallest\
    \ and largest of the numbers\n    return {std::optional{smallest}, std::optional{largest}};",
  "    if (lst.size() < 2) return std::make_tuple({}, {});\n    std::optional<long>\
    \ largest_val = std::nullopt;\n    std::optional<long> smallest_val = std::nullopt;\n\
    \    for (long num : lst) {\n        if (num < 0) smallest_val = std::nullopt;\n\
    \        else if (num > 0) largest_val = std::nullopt;\n        else if (smallest\
    \ < num) smallest_val = num;\n        else if (largest > num) largest_val = num;\n\
    \    }\n    if (smallest_val == std::nullopt) return std::make_tuple({}, {});\n\
    \    if (largest_val == std::nullopt) return std::make_tuple({}, {});\n    return\
    \ std::make_tuple(largest_val, smallest_val);", "    // Your code here.\n    \n\
    \    auto result = std::make_tuple();\n    if(lst.size() <= 0){\n        return\
    \ result;\n    }\n    \n    long small = -9223372036854775807;\n    long large\
    \ = 9223372036854775808;\n    \n    for(auto i : lst){\n        if(i < 0){\n \
    \           small = i;\n        } else if(i > 0){\n            large = i;\n  \
    \      }\n    }\n    \n    if(small > large){\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n    \n    return std::make_tuple(std::optional(large),\
    \ std::optional(small));", "    if (lst.size() == 0)\n        return std::make_pair(std::optional<long>{},\
    \ std::optional<long>{});\n    long largest_neg = *std::max_element(lst.begin(),\
    \ lst.end());\n    long largest_pos = *std::min_element(lst.begin(), lst.end());\n\
    \    return std::make_pair(std::optional<long>(largest_neg), std::optional<long>(largest_pos));",
  "    long min = -100;\n    long max = 100;\n    std::optional<long> largest_value\
    \ = std::nullopt;\n    std::optional<long> smallest_value = std::nullopt;\n  \
    \  for (auto value : lst) {\n        if (value < min) {\n            min = value;\n\
    \        } else if (value > max) {\n            max = value;\n        }\n    }\n\
    \    if (min == max) {\n        std::optional<long> result;\n        return std::make_tuple(result,\
    \ result);\n    }\n    if (min < 0 && max > 0) {\n        std::optional<long>\
    \ result = std::optional<long>{min};\n        return std::make_tuple(result, std::optional<long>{max});\n\
    \    }\n    if (min > 0 && max < 0) {\n        std::optional<long> result = std::optional<long>{max};\n\
    \        return std::make_tuple(std::optional<long>{min}, result);\n    }\n  \
    \  std::optional<long> result;\n    return std::make_tuple(std::nullopt, result);",
  "    // write your code in C\n    auto small=std::make_pair(std::optional<long>(),std::optional<long>());\n\
    \    auto large=std::make_pair(std::optional<long>(),std::optional<long>());\n\
    \    for(long i :lst){\n        if(small.first==std::optional<long>()){\n    \
    \        small.first=i;\n        }\n        else if(large.first==std::optional<long>()){\n\
    \            large.first=i;\n        }\n        else if(large.second==std::optional<long>()){\n\
    \            large.second=i;\n        }\n        else if(small.second==std::optional<long>()){\n\
    \            small.second=i;\n        }\n    }\n    return large;", "        long\
    \ largest=-1000000000LL;\n        long smallest=1000000000LL;\n        std::optional<long>\
    \ a;\n        std::optional<long> b;\n        for(long i : lst)\n        {\n \
    \           if(i>largest)\n            {\n                largest=i;\n       \
    \     }\n            if(i<smallest)\n            {\n                smallest=i;\n\
    \            }\n        }\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(largest),\
    \ std::optional<long>(smallest));", "  if (lst.size() == 0)\n    return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n  std::optional<long> greatest, least;\n  for (long i : lst)\n\
    \    if (i < 0 || i > greatest || greatest == std::nullopt)\n      greatest =\
    \ least = i;\n    else\n      least = i;\n  return std::make_tuple(greatest, least);",
  "    long a = 0, b = std::numeric_limits<long>::max();\n    for (long x : lst) {\n\
    \        if (x < 0) {\n            std::optional<long> tmp = a;\n            a\
    \ = b;\n            b = tmp;\n        } else {\n            a = std::max(a, x);\n\
    \        }\n    }\n    return std::tuple<std::optional<long>, std::optional<long>>(a,\
    \ b);", "  long largest = -99999999;\n  long smallest = 99999999;\n\n  for (int\
    \ i = 0; i < lst.size(); i++) {\n    if (lst[i] >= 0) {\n      smallest = std::min(smallest,\
    \ lst[i]);\n      largest = std::max(largest, lst[i]);\n    } else {\n      largest\
    \ = std::max(largest, std::min(lst[i], -smallest));\n    }\n  }\n  return std::make_tuple(std::optional<long>(largest),\
    \ std::optional<long>(smallest));", "    auto m = std::max_element(lst.begin(),\
    \ lst.end());\n    auto n = std::min_element(lst.begin(), lst.end());\n    //\
    \ std::max and std::min return the second argument if the first argument is less\
    \ than\n    // the second argument. For example, if std::max_element([2, 3, 5,\
    \ 1]) returns 4, then\n    // std::max(lst.begin(), lst.end()) returns 3 and std::min(lst.begin(),\
    \ lst.end()) returns\n    // 1. We need the second argument if the first argument\
    \ was less than 4, and the\n    // second if the first argument was greater than\
    \ or equal to 4.\n    if (m == lst.end()) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    } else if (n == lst.end()) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    }\n    if (*m < *n) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(*n, *m);\n    } else {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(*m, *n);\n    }", "  std::optional<long> largest;\n  std::optional<long>\
    \ smallest;\n\n  if (lst.empty())\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n\n  for (long number : lst) {\n    if (number < 0)\
    \ {\n      largest = number;\n    } else if (number > 0) {\n      smallest = number;\n\
    \    }\n  }\n\n  return std::tuple<std::optional<long>, std::optional<long>>(largest,\
    \ smallest);", "\tstd::optional<long> minVal = std::nullopt;\n\tstd::optional<long>\
    \ maxVal = std::nullopt;\n\tfor (auto i : lst) {\n\t\tif (i < 0) {\n\t\t\tif (minVal\
    \ == std::nullopt) {\n\t\t\t\tminVal = i;\n\t\t\t} else {\n\t\t\t\tmaxVal = i;\n\
    \t\t\t}\n\t\t} else if (i >= 0) {\n\t\t\tif (maxVal == std::nullopt) {\n\t\t\t\
    \tmaxVal = i;\n\t\t\t} else {\n\t\t\t\tminVal = i;\n\t\t\t}\n\t\t}\n\t}\n\tif\
    \ (minVal == std::nullopt) {\n\t\treturn std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n\t} else if (maxVal == std::nullopt) {\n\t\treturn\
    \ std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n\t}\n\treturn std::tuple<std::optional<long>, std::optional<long>>(minVal,\
    \ maxVal);", "  std::optional<long> min;\n  std::optional<long> max;\n  for (auto\
    \ val : lst) {\n    if (val < 0 || val > 0) {\n      min = std::min(val, min);\n\
    \      max = std::max(val, max);\n    } else {\n      std::optional<long> opt\
    \ = std::nullopt;\n      return std::make_tuple(min, max);\n    }\n  }\n  std::optional<long>\
    \ opt = std::nullopt;\n  return std::make_tuple(min, max);", "    assert(lst.size()\
    \ > 0);\n    // Sort using std::greater\n    std::sort(lst.begin(), lst.end(),\
    \ std::greater<>());\n    // Use std::adjacent_find to find the first\n    //\
    \ negative number or the last positive number\n    auto beg = std::adjacent_find(lst.begin(),\
    \ lst.end(), [](auto a, auto b) { return (a < 0 || b > 0); });\n    // If there\
    \ are no negative numbers, return None\n    if (beg == lst.end()) return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    // Otherwise, get the maximum and the minimum numbers\n\
    \    long max_val = *beg;\n    long min_val = *beg;\n    auto end = std::adjacent_find(beg,\
    \ lst.end(), [](auto a, auto b) { return (a < 0 || b < 0); });\n    if (end ==\
    \ lst.end()) return std::make_tuple(std::nullopt, std::nullopt);\n    // Iterate\
    \ over the list and compare each number to the maximum or minimum\n    for (auto\
    \ i = beg + 1; i != end; ++i) {\n        if (*i < 0) {\n            if (*i > max_val)\
    \ max_val = *i;\n        } else if (*i > 0) {\n            if (*i < min_val) min_val\
    \ = *i;\n        }\n    }\n    return std::make_tuple(std::optional(max_val),\
    \ std::optional(min_val));", "  long int maximum = std::numeric_limits<long>::min();\n\
    \  long int minimum = std::numeric_limits<long>::max();\n  for (auto i : lst)\
    \ {\n    if (i < 0) continue;\n    if (i > maximum) maximum = i;\n    if (i <\
    \ minimum) minimum = i;\n  }\n  return std::make_tuple(std::nullopt, std::nullopt);",
  "    if (lst.empty()) {\n        return std::make_pair(std::nullopt, std::nullopt);\n\
    \    }\n    long x = 0, y = 0, max_val = 0, min_val = std::numeric_limits<long>::min();\n\
    \    std::optional<long> max_val, min_val;\n    for (auto it = lst.begin(); it\
    \ != lst.end(); ++it) {\n        if (*it < 0) {\n            x = *it;\n      \
    \  } else if (*it > 0) {\n            y = *it;\n            if (max_val < x) max_val\
    \ = x;\n            if (min_val > y) min_val = y;\n        }\n    }\n    return\
    \ std::make_pair(max_val, min_val);", "    long max = 0;\n    long min = 1;\n\
    \    for (long i : lst) {\n        if (i < 0) {\n            if (max < 0)\n  \
    \              max = i;\n            else\n                min = i;\n        }\
    \ else {\n            if (min > 0)\n                min = i;\n            else\n\
    \                max = i;\n        }\n    }\n    if (max < min)\n        return\
    \ std::tuple<std::optional<long>, std::optional<long>>(std::nullopt, std::nullopt);\n\
    \    return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(max),\
    \ std::optional<long>(min));", "    auto max = std::optional<long>(std::numeric_limits<long>::max());\n\
    \    auto min = std::optional<long>(std::numeric_limits<long>::min());\n    std::for_each(lst.begin(),\
    \ lst.end(), [&](long v) {\n        if (v < 0)\n            max = std::max(max,\
    \ v);\n        else\n            min = std::min(min, v);\n    });\n    return\
    \ std::make_tuple(max, min);", "  if (lst.empty()) {\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>({}, {});\n  }\n  int largest_idx = -1;\n  int smallest_idx\
    \ = lst.size() - 1;\n  for (int i = 1; i < lst.size(); ++i) {\n    if (lst[smallest_idx]\
    \ <= lst[largest_idx]) {\n      smallest_idx = i;\n    } else {\n      largest_idx\
    \ = i;\n    }\n  }\n  return std::tuple<std::optional<long>, std::optional<long>>(\n\
    \      std::nullopt,\n      lst.size() > 1 ? std::optional<long>(lst[largest_idx])\
    \ : std::optional<long>(lst[smallest_idx]));", "    std::optional<long> first{};\n\
    \    std::optional<long> last{};\n    long largest_int{};\n    long smallest_int{};\n\
    \    long result{};\n    bool found = false;\n    for(long i : lst)\n    {\n \
    \       found = true;\n        if(!first && i > 0 && i < 0)\n        {\n     \
    \       first = i;\n            found = false;\n        }\n        else if(!last\
    \ && i >= 0)\n        {\n            last = i;\n            found = false;\n \
    \       }\n        if(!found)\n        {\n            if(first && last)\n    \
    \        {\n                if(first > last)\n                {\n            \
    \        std::swap(first, last);\n                }\n            }\n         \
    \   else\n            {\n                first = last = i;\n            }\n  \
    \          largest_int = std::max(largest_int, i);\n            smallest_int =\
    \ std::min(smallest_int, i);\n        }\n    }\n    if(!found)\n    {\n      \
    \  first = last = largest_int = smallest_int = None;\n    }\n    if(!first &&\
    \ !last)\n    {\n        first = None;\n        last = None;\n    }\n    if(first\
    \ && last)\n    {\n        result = std::max(first, last);\n    }\n    else\n\
    \    {\n        result = std::max(first,last);\n    }\n    return std::make_tuple(first,\
    \ last);", "    if (lst.size() == 0) {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    }\n    long largest_negative = std::numeric_limits<long>::max();\n\
    \    long smallest_positive = std::numeric_limits<long>::min();\n    // Iterate\
    \ through all the numbers in the list.\n    for (auto i : lst) {\n        // If\
    \ the number is negative return it as 'largest_negative'.\n        if (i < 0)\
    \ {\n            largest_negative = i;\n            continue;\n        }\n   \
    \     // If the number is positive return it as 'smallest_positive'.\n       \
    \ if (i > 0)\n            smallest_positive = i;\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional(largest_negative),\n                    \
    \                                                std::optional(smallest_positive));",
  "    if (lst.size() == 0) return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n    int max = lst[0];\n    int min = lst[0];\n    for\
    \ (size_t i = 1; i < lst.size(); i++) {\n        if (lst[i] > max) max = lst[i];\n\
    \        if (lst[i] < min) min = lst[i];\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(max, min);", "    // initialize first tuple element to\
    \ None\n    auto ret = std::make_tuple(std::nullopt,std::nullopt);\n    for(long\
    \ i=0;i<lst.size();++i) {\n        if(lst[i] < 0)\n            ret = std::make_tuple(std::nullopt,std::nullopt);\n\
    \        else if (lst[i] > 0)\n            ret = std::make_tuple(std::nullopt,std::nullopt);\n\
    \        else\n            ret = std::make_tuple(std::optional<long>(lst.size()-1),std::optional<long>(lst[i]-1));\n\
    \    }\n    return ret;", "    long long largest = std::numeric_limits<long long>::max();\n\
    \    long long smallest = std::numeric_limits<long long>::min();\n    for (auto\
    \ i : lst) {\n        if (i < smallest) {\n            smallest = i;\n       \
    \ } else if (i > largest) {\n            largest = i;\n        }\n    }\n    if\
    \ (largest < smallest) {\n        return (std::optional<long>{largest}, std::optional<long>{smallest});\n\
    \    } else {\n        return (std::nullopt, std::optional<long>{});\n    }",
  "    std::optional<long> largest;\n    std::optional<long> smallest;\n    for (long\
    \ number : lst) {\n        if (smallest == std::nullopt) {\n            smallest\
    \ = number;\n        }\n        if (largest == std::nullopt) {\n            largest\
    \ = number;\n        }\n        else if (number < smallest || number > largest)\
    \ {\n            largest = number;\n            smallest = number;\n        }\n\
    \        else if (number == smallest && number == largest) {\n            largest\
    \ = number;\n            smallest = number;\n        }\n        else if (number\
    \ < smallest && number > largest) {\n            largest = number;\n        }\n\
    \        else if (number > smallest && number < largest) {\n            smallest\
    \ = number;\n        }\n    }\n    return (largest == std::nullopt) ? std::nullopt\
    \ : (smallest == std::nullopt) ? std::nullopt : std::make_tuple(largest, smallest);",
  "    // Write your code here\n    long largest = 0, smallest = 0;\n    for (auto\
    \ val : lst) {\n        if (val > largest) {\n            largest = val;\n   \
    \     }\n        else if (val < smallest) {\n            smallest = val;\n   \
    \     }\n    }\n    return std::make_tuple(std::nullopt, std::nullopt);", "  \
    \  // Your code goes here\n    if(lst.empty())\n    {\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>();\n    }\n    auto min = std::numeric_limits<long>::max();\n\
    \    auto max = std::numeric_limits<long>::min();\n    for(long i = 0; i <lst.size();\
    \ i++)\n    {\n        if(lst[i] > max)\n            max = lst[i];\n        if(lst[i]\
    \ < min)\n            min = lst[i];\n    }\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional<long>(max), std::optional<long>(min));",
  "  if(lst.size() == 0) {\n    return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(),\
    \ std::optional<long>());\n  }\n\n  std::vector<long> sorted(lst.begin(), lst.end());\n\
    \  std::sort(sorted.begin(), sorted.end());\n\n  long max = -std::numeric_limits<long>::max();\n\
    \  long min = std::numeric_limits<long>::max();\n  for (int i = 0; i < sorted.size();\
    \ ++i) {\n    if (sorted[i] < 0) {\n      max = sorted[i] > max ? sorted[i] :\
    \ max;\n    } else {\n      min = sorted[i] < min ? sorted[i] : min;\n    }\n\
    \  }\n\n  std::optional<long> max_opt = max;\n  std::optional<long> min_opt =\
    \ min;\n  return std::tuple<std::optional<long>, std::optional<long>>(max_opt,\
    \ min_opt);", "    // Write your code here\n    auto min_ = std::optional<long>();\n\
    \    auto max_ = std::optional<long>();\n    for (long &i : lst) {\n        if\
    \ (i < 0)\n            i = -li;\n        if (i > 0)\n            i = li;\n   \
    \     if (i > *max_)\n            max_ = std::optional<long>(i);\n        if (i\
    \ < min_)\n            min_ = std::optional<long>(i);\n    }\n    return std::make_tuple(min_,\
    \ max_);", "    long min_val = *std::min_element(std::begin(lst), std::end(lst));\n\
    \    long max_val = *std::max_element(std::begin(lst), std::end(lst));\n    if\
    \ (min_val > max_val) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    } else {\n        return std::make_tuple(std::make_optional(min_val), std::make_optional(max_val));\n\
    \    }", "    if (lst.size() == 0) return std::make_pair(std::nullopt, std::nullopt);\n\
    \    std::optional<long> a = std::nullopt;\n    std::optional<long> b = std::nullopt;\n\
    \    for (std::size_t i = 0; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n\
    \            if (a.has_value()) return std::make_pair(a, std::nullopt);\n    \
    \        a = std::nullopt;\n        } else if (lst[i] > 0) {\n            if (b.has_value())\
    \ return std::make_pair(std::nullopt, std::nullopt);\n            b = std::nullopt;\n\
    \        } else {\n            if (a.has_value()) b = std::nullopt;\n        \
    \    else if (b.has_value()) a = std::nullopt;\n        }\n    }\n    return std::make_pair(std::move(a),\
    \ std::move(b));", "    long a = 0;\n    long b = 0;\n    for (long n : lst) {\n\
    \        if (n < 0) a = n;\n        else b = n;\n    }\n    if (a == 0) return\
    \ std::tuple<std::optional<long>, std::optional<long>>(std::nullopt, std::nullopt);\n\
    \    if (b == 0) return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(a),\
    \ std::optional<long>(b));", "  std::optional<long> result;\n  if (lst.empty())\
    \ return std::make_pair(std::nullopt, std::nullopt);\n  auto smallest = std::min_element(lst.begin(),\
    \ lst.end());\n  auto largest = std::max_element(lst.begin(), lst.end());\n  if\
    \ (*smallest > *largest) {\n    if (result) {\n      *result = *smallest;\n  \
    \  }\n  }\n  if (*smallest < *largest) {\n    if (result) {\n      *result = *largest;\n\
    \    }\n  }\n  return result;", "  std::vector<long> sorted_list = lst;\n  std::sort(sorted_list.begin(),\
    \ sorted_list.end());\n\n  if (sorted_list[0] < 0) {\n    sorted_list[0] = 0;\n\
    \  }\n\n  if (sorted_list[0] >= 0 && sorted_list[1] < 0) {\n    sorted_list[1]\
    \ = 0;\n  }\n\n  if (sorted_list[1] >= 0) {\n    return std::make_tuple(sorted_list[1],\
    \ sorted_list[0]);\n  } else {\n    return std::make_tuple();\n  }", "\tstd::optional<long>\
    \ a{};\n\tstd::optional<long> b{};\n\tfor (auto i : lst) {\n\t\tif (a != std::nullopt\
    \ && b != std::nullopt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (i > a) {\n\t\t\tb = std::optional<long>(i);\n\
    \t\t} else if (i < b) {\n\t\t\ta = std::optional<long>(i);\n\t\t}\n\t}\n\treturn\
    \ std::tie(a, b);", "    // YOUR CODE HERE\n    if (lst.empty()) {\n        return\
    \ std::tuple<std::optional<long>, std::optional<long>>();\n    }\n    std::optional<long>\
    \ min_val = *std::min_element(lst.begin(), lst.end());\n    std::optional<long>\
    \ max_val = *std::max_element(lst.begin(), lst.end());\n    if (min_val == max_val)\
    \ return {std::nullopt, std::nullopt};\n    return {min_val, max_val};", "   \
    \ // Your code here\n    if (lst.size() == 0) {\n        return std::make_tuple(std::nullopt,\
    \ std::nullopt);\n    }\n    auto result = std::make_tuple(std::nullopt, std::nullopt);\n\
    \    for (size_t i = 1; i < lst.size(); i++) {\n        if (lst[i - 1] < 0 &&\
    \ lst[i] > 0) {\n            std::swap(lst[i - 1], lst[i]);\n            result\
    \ = std::make_tuple(std::nullopt, std::nullopt);\n        }\n        else if (lst[i\
    \ - 1] > 0 && lst[i] < 0) {\n            std::swap(lst[i - 1], lst[i]);\n    \
    \        result = std::make_tuple(std::nullopt, std::nullopt);\n        }\n  \
    \  }\n    return std::get<0>(result);", "    if (lst.empty()) {\n        return\
    \ std::tuple<std::optional<long>, std::optional<long>>{std::nullopt, std::nullopt};\n\
    \    }\n    long largest = *std::max_element(std::begin(lst), std::end(lst));\n\
    \    long smallest = *std::min_element(std::begin(lst), std::end(lst));\n    return\
    \ std::make_tuple(std::optional(largest), std::optional(smallest));", "    long\
    \ largest = std::numeric_limits<long>::min();\n    long smallest = std::numeric_limits<long>::max();\n\
    \    for (auto i : lst) {\n        if (i < smallest)\n            smallest = i;\n\
    \        if (i > largest)\n            largest = i;\n    }\n    return std::make_tuple(std::optional<long>(smallest),\
    \ std::optional<long>(largest));", "    // Define our max and min variables\n\
    \    std::optional<long> max_val, min_val;\n    // Initialize our max and min\
    \ values as none\n    max_val = min_val = std::nullopt;\n    // Loop over our\
    \ list\n    for (auto val : lst) {\n        // If our value is greater than our\
    \ max value\n        if (val > max_val) {\n            // Update our max value\n\
    \            max_val = val;\n        } else if (val < min_val) {\n           \
    \ // Update our min value\n            min_val = val;\n        }\n    }\n    //\
    \ If our min and max values are still none, return None\n    if (!min_val && !max_val)\
    \ return std::make_pair(std::nullopt, std::nullopt);\n    // Else return our tuple\
    \ (max val, min val)\n    return std::make_pair(max_val, min_val);", "    // Write\
    \ your code here\n    std::optional<long> largest, smallest;\n    std::vector<long>\
    \ vec;\n    std::sort(lst.begin(), lst.end());\n    size_t size = lst.size();\n\
    \    if (size == 0) {\n        largest = std::nullopt;\n        smallest = std::nullopt;\n\
    \    }\n    else {\n        for (size_t i = 0; i < size; i++) {\n            if\
    \ (lst[i] < 0 && lst.size() > 1) {\n                largest = std::nullopt;\n\
    \                smallest = std::nullopt;\n                break;\n          \
    \  }\n            if (lst[i] > 0 && lst.size() > 1) {\n                smallest\
    \ = std::nullopt;\n                largest = std::nullopt;\n                break;\n\
    \            }\n            if (lst[i] > 0) {\n                vec.push_back(lst[i]);\n\
    \                if (lst.size() > 1) {\n                    if (smallest.has_value()\
    \ || lst[i] < smallest) {\n                        smallest = std::nullopt;\n\
    \                    }\n                    if (largest.has_value() || lst[i]\
    \ > largest) {\n                        largest = std::nullopt;\n            \
    \        }\n                }\n                else {\n                    largest\
    \ = std::nullopt;\n                    smallest = std::nullopt;\n            \
    \    }\n            }\n        }\n    }\n    return std::tuple<long, long>(smallest,\
    \ largest);", "    long a = 0, b = std::numeric_limits<long>::max();\n    for(long\
    \ num: lst) {\n        if(-num >= 0) {\n            a = std::max(a, -b);\n   \
    \         b = std::min(b, -num);\n        } else {\n            a = std::max(a,\
    \ num);\n            b = std::min(b, num);\n        }\n    }\n    return std::make_tuple(a,\
    \ b);", "  std::optional<long> a = std::nullopt;\n  std::optional<long> b = std::nullopt;\n\
    \  \n  for (auto v : lst) {\n    if (v < 0) {\n      if (a.has_value()) {\n  \
    \      b = std::optional<long>{v};\n      } else if (b.has_value()) {\n      \
    \  a = std::optional<long>{v};\n      }\n    } else if (v > 0) {\n      if (b.has_value())\
    \ {\n        b = std::optional<long>{v};\n      } else if (a.has_value()) {\n\
    \        a = std::optional<long>{v};\n      }\n    }\n  }\n  if (a.has_value())\
    \ {\n    return std::make_tuple(a, std::move(b));\n  } else {\n    return std::make_tuple(std::move(a),\
    \ std::move(b));\n  }", "    int n = lst.size();\n    int max_neg = 0;\n    int\
    \ min_pos = 0;\n    for (int i = 0; i < n; i++) {\n        if (lst[i] < 0) {\n\
    \            max_neg = std::max((int)lst[i], max_neg);\n        } else {\n   \
    \         min_pos = std::min((int)lst[i], min_pos);\n        }\n    }\n    return\
    \ std::tuple<std::optional<long>, std::optional<long>>(\n        std::optional<long>(max_neg),\n\
    \        std::optional<long>(min_pos));", "    // Your code here\n    if(lst.empty()){\n\
    \        return std::make_tuple(std::optional<long>(), std::optional<long>());\n\
    \    }\n    std::optional<long> min{*std::min_element(std::begin(lst), std::end(lst))};\n\
    \    std::optional<long> max{*std::max_element(std::begin(lst), std::end(lst))};\n\
    \    return std::make_tuple(min, max);", "    if (lst.size() <= 0) {\n       \
    \ return std::tuple<std::optional<long>, std::optional<long>>{};\n    }\n    std::pair<long,\
    \ long> largestPositive{std::numeric_limits<long>::max(), std::numeric_limits<long>::max()};\n\
    \    std::pair<long, long> largestNegative{std::numeric_limits<long>::min(), std::numeric_limits<long>::min()};\n\
    \    for (long i : lst) {\n        if (i < 0) {\n            if (largestPositive.second\
    \ > i) { largestPositive.second = i; }\n            if (largestNegative.second\
    \ < i) { largestNegative.second = i; }\n        } else {\n            if (largestPositive.first\
    \ > i) { largestPositive.first = i; }\n            if (largestNegative.first <\
    \ i) { largestNegative.first = i; }\n        }\n    }\n    if (largestPositive.second\
    \ < largestPositive.first) {\n        return std::tuple<std::optional<long>, std::optional<long>>{std::nullopt,\
    \ std::nullopt};\n    }\n    if (largestNegative.second > largestNegative.first)\
    \ {\n        return std::tuple<std::optional<long>, std::optional<long>>{std::nullopt,\
    \ std::nullopt};\n    }\n    return std::tuple<std::optional<long>, std::optional<long>>{std::nullopt,\
    \ std::nullopt};", "    long largest = std::numeric_limits<long>::max();\n   \
    \ long smallest = std::numeric_limits<long>::min();\n    for (auto num : lst)\
    \ {\n        if (num < 0) largest = std::max(largest, num);\n        else if (num\
    \ > 0) smallest = std::min(smallest, num);\n        else break;\n    }\n    return\
    \ std::make_tuple(std::make_optional(largest), std::make_optional(smallest));",
  "  if (lst.size() <= 0) {\n    return std::make_pair(std::nullopt, std::nullopt);\n\
    \  }\n  int max_negative = std::numeric_limits<long>::min(), max_positive = std::numeric_limits<long>::max();\n\
    \  for (long number : lst) {\n    if (number < 0) {\n      max_negative = std::max(max_negative,\
    \ number);\n    }\n    else {\n      max_positive = std::min(max_positive, number);\n\
    \    }\n  }\n  if (max_negative < max_positive) {\n    return std::make_pair(std::nullopt,\
    \ std::nullopt);\n  }\n  return std::make_pair(max_negative, max_positive);",
  "    if (lst.size() == 0)\n        return std::tuple<std::optional<long>, std::optional<long>>(std::nullopt,\
    \ std::nullopt);\n    auto max_value = *std::max_element(std::begin(lst), std::end(lst));\n\
    \    auto min_value = *std::min_element(std::begin(lst), std::end(lst));\n   \
    \ if (max_value == min_value)\n        return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::nullopt, std::nullopt);\n    if (max_value < 0 &&\
    \ min_value > 0)\n        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(max_value),\
    \ std::optional<long>(min_value));\n    if (max_value < 0 && min_value < 0)\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(min_value),\
    \ std::optional<long>(max_value));\n    if (max_value > 0 && min_value < 0)\n\
    \        return std::tuple<std::optional<long>, std::optional<long>>(std::optional<long>(max_value),\
    \ std::optional<long>(min_value));\n    return std::tuple<std::optional<long>,\
    \ std::optional<long>>(std::optional<long>(max_value), std::optional<long>(min_value));",
  "    auto small = [](auto a, auto b) -> bool {\n        return a < b;\n    };\n\
    \    auto big = [](auto a, auto b) -> bool {\n        return a > b;\n    };\n\
    \    auto smaller = [](auto a, auto b) -> bool {\n        return a < b;\n    };\n\
    \n    auto it = lst.begin();\n    auto last = lst.end();\n    auto small = it;\n\
    \    auto biggest = last;\n    std::optional<long> largest;\n    for (; it !=\
    \ last; ++it) {\n        if (small(*it, *small)) {\n            small = it;\n\
    \        }\n        if (big(*it, biggest)) {\n            biggest = it;\n    \
    \    }\n    }\n    if (biggest == last) return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if (small == last) return std::make_tuple(std::nullopt, std::nullopt);\n\
    \    if (*small == *biggest) {\n        largest = *small;\n        std::optional<long>\
    \ smallMax;\n        for (; small != last; ++small) {\n            if (*small\
    \ == *biggest) {\n                smallMax = *small;\n                biggest\
    \ = small;\n            }\n        }\n        if (smallMax) {\n            return\
    \ std::make_tuple(std::nullopt, smallMax);\n        } else {\n            return\
    \ std::make_tuple(std::nullopt, std::nullopt);\n        }\n    } else if (biggest)\
    \ {\n        largest = *biggest;\n    }\n    for (; biggest != last; ++biggest)\
    \ {\n        if (small(*biggest, *small)) {\n            small = biggest;\n  \
    \      }\n    }\n    if (small) {\n        largest = *small;\n    }\n    return\
    \ std::make_tuple(std::nullopt, std::nullopt);", "    int n = lst.size();\n  \
    \  int m = std::min(n, (int) std::numeric_limits<long>::max());\n    if (m ==\
    \ n) {\n        return std::make_tuple(std::nullopt, std::nullopt);\n    }\n \
    \   std::vector<long> neg_idxs(m, std::nullopt);\n    std::vector<long> pos_idxs(m,\
    \ std::nullopt);\n    for (auto i : lst) {\n        if ((i < 0) || (i >= m)) {\n\
    \            if (std::nullopt == neg_idxs[i - m]) {\n                neg_idxs[i\
    \ - m] = i;\n            } else {\n                if (std::nullopt == pos_idxs[i])\
    \ {\n                    pos_idxs[i] = i;\n                }\n            }\n\
    \        }\n    }\n    return std::make_tuple(largest_of_all_negative_or_positives(neg_idxs),\
    \ largest_of_all_negative_or_positives(pos_idxs));", "    int min_ = -std::numeric_limits<long>::max(),\
    \ max_ = std::numeric_limits<long>::max();\n    for (long i : lst) {\n       \
    \ if ((i < min_) || (i > max_)) {\n            min_ = i;\n        } else if (i\
    \ > max_) {\n            max_ = i;\n        }\n    }\n    return std::make_tuple(std::nullopt,\
    \ std::nullopt);", "    std::optional<long> max;\n    std::optional<long> min;\n\
    \    for (long n : lst) {\n        if (n.empty()) {\n            continue;\n \
    \       }\n        if (n < 0 && max && max.get() < 0) {\n            max = std::nullopt;\n\
    \        }\n        if (n >= 0 && min && min.get() >= 0) {\n            min =\
    \ std::nullopt;\n        }\n        if (max && min) {\n            if (n >= max.get())\
    \ {\n                max = std::nullopt;\n            }\n            if (n < min.get())\
    \ {\n                min = std::nullopt;\n            }\n        } else {\n  \
    \          max = std::nullopt;\n            min = std::nullopt;\n        }\n \
    \   }\n    return std::make_tuple(min, max);", "\tif (lst.empty()) {\n\t\treturn\
    \ std::make_tuple(std::nullopt, std::nullopt);\n\t}\n\t\n\tstd::optional<long>\
    \ a = std::nullopt;\n\tstd::optional<long> b = std::nullopt;\n\t// Iterate over\
    \ lst.\n\tfor (auto it = lst.begin(); it != lst.end(); ++it) {\n\t\t// If this\
    \ number is larger than a and smaller than b, set them\n\t\t// both to the current\
    \ number.\n\t\tif (*it > a) a = *it;\n\t\tif (*it < b) b = *it;\n\t}\n\treturn\
    \ std::make_tuple(a, b);", "    std::optional<long> max_negative = 0;\n    std::optional<long>\
    \ min_positive = 0;\n    for (long i : lst) {\n        if (i < 0) {\n        \
    \    max_negative = i;\n        } else if (i > 0){\n            min_positive =\
    \ i;\n        }\n    }\n    return std::make_pair(max_negative, min_positive);",
  "    int largest_negative = -2;\n    int smallest_positive = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < 0) {\n            if (largest_negative\
    \ > i) {\n                largest_negative = i;\n            }\n        }\n  \
    \      else {\n            if (smallest_positive > i) {\n                smallest_positive\
    \ = i;\n            }\n        }\n    }\n    return std::make_tuple(std::optional<long>(largest_negative),\
    \ std::optional<long>(smallest_positive));", "    // Your code here\n    long\
    \ ans = 0;\n    long negative = std::numeric_limits<long>::min();\n    long positive\
    \ = std::numeric_limits<long>::max();\n    for (long i = 0; i < lst.size(); i++)\
    \ {\n        if (lst[i] < negative) {\n            ans = negative;\n         \
    \   negative = lst[i];\n        } else if (lst[i] > positive) {\n            ans\
    \ = positive;\n            positive = lst[i];\n        } else {\n            ans\
    \ = std::max(ans, lst[i]);\n        }\n    }\n\n    return std::make_tuple(std::optional<long>(ans),\
    \ std::optional<long>(negative));", "    // initialize max and min to INT_MIN\
    \ and INT_MAX respectively.\n    std::optional<long> max = std::optional<long>(std::numeric_limits<long>::min());\n\
    \    std::optional<long> min = std::optional<long>(std::numeric_limits<long>::max());\n\
    \    // loop over the list and keep track of the largest and smallest integers\n\
    \    for (long i : lst) {\n        if (max && i > max)\n            max = std::optional<long>(std::numeric_limits<long>::max());\n\
    \        if (min && i < min)\n            min = std::optional<long>(std::numeric_limits<long>::min());\n\
    \    }\n    return std::make_tuple(max, min);"]
stop_tokens:
- "\n}"
