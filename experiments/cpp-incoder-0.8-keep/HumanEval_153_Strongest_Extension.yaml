name: HumanEval_153_Strongest_Extension
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the name\
  \ of a class (a string) and a list of extensions.\n// The extensions are to be used\
  \ to load additional classes to the class. The\n// strength of the extension is\
  \ as follows: Let CAP be the number of the uppercase\n// letters in the extension's\
  \ name, and let SM be the number of lowercase letters \n// in the extension's name,\
  \ the strength is given by the fraction CAP - SM. \n// You should find the strongest\
  \ extension and return a string in this \n// format: ClassName.StrongestExtensionName.\n\
  // If there are two or more extensions with the same strength, you should\n// choose\
  \ the one that comes first in the list.\n// For example, if you are given \"Slices\"\
  \ as the class and a list of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed']\
  \ then you should\n// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the\
  \ strongest extension \n// (its strength is -1).\n// Example:\n// for Strongest_Extension('my_class',\
  \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nstd::string Strongest_Extension(std::string\
  \ class_name, std::vector<std::string> extensions) {\n"
tests: "}\nint main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
  Watashi\"), (std::vector<std::string>({\"tEN\", \"niNE\", \"eIGHt8OKe\"}))) == (\"\
  Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({\"\
  nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
  ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({\"t\", \"\
  eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
  ));\n    assert(candidate((\"K\"), (std::vector<std::string>({\"Ta\", \"TAR\", \"\
  t234An\", \"cosSo\"}))) == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({\"\
  Tab\", \"123\", \"781345\", \"-_-\"}))) == (\"__HAHA.123\"));\n    assert(candidate((\"\
  YameRore\"), (std::vector<std::string>({\"HhAas\", \"okIWILL123\", \"WorkOut\",\
  \ \"Fails\", \"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
  finNNalLLly\"), (std::vector<std::string>({\"Die\", \"NowW\", \"Wow\", \"WoW\"})))\
  \ == (\"finNNalLLly.WoW\"));\n    assert(candidate((\"_\"), (std::vector<std::string>({\"\
  Bb\", \"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"), (std::vector<std::string>({\"\
  671235\", \"Bb\"}))) == (\"Sp.671235\"));\n}\n"
completions: ["  int n = extensions.size();\n  std::string strongest;\n  int cap =\
    \ 0;\n  int sm = 0;\n  for (int i = 0; i < n; i++) {\n    int c = 0, s = 0;\n\
    \    for (int j = 0; j <= i; j++) {\n      if (extensions[j].length() >= i) {\
    \ c++; c++; }\n      else if (extensions[j].length() < i) { s++; s++; }\n    }\n\
    \    if (c > cap) { cap = c; strongest = class_name; };\n    if (s > sm) { sm\
    \ = s; strongest = class_name; };\n  };\n  return strongest;", "    std::sort(extensions.begin(),\
    \ extensions.end()); // sort extensions according to their strength\n    std::string\
    \ result;\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        if (extensions[i][0] >= 'A' && extensions[i][0] <= 'Z') {\n\
    \            cap++;\n        } else if (extensions[i][0] >= 'a' && extensions[i][0]\
    \ <= 'z') {\n            sm++;\n        }\n    }\n    int frac = cap - sm;\n \
    \   int strength = 0;\n    for (auto& ext : extensions) {\n        int ext = cap\
    \ - sm;\n        if (ext > frac) {\n            frac = ext;\n        }\n    }\n\
    \    if (frac > 0) {\n        strength = cap - sm;\n        if (frac < strength)\
    \ {\n            frac = strength;\n        }\n    }\n    result += class_name;\n\
    \    for (int i = 0; i < extensions.size(); i++) {\n        if (extensions[i][0]\
    \ == extensions[0][0]) {\n            result += '.' + extensions[i];\n       \
    \ }\n    }\n    return result;", "    std::vector<std::tuple<int, std::string>>\
    \ exts;\n    for (auto& e : extensions) {\n        auto c = tolower(e);\n    \
    \    auto d = tolower(class_name);\n        int s = c - 'a';\n        int l =\
    \ d - 'a';\n        exts.push_back({ s, e });\n    }\n    exts.sort();\n    auto\
    \ best = exts.front();\n    for (auto& e : exts) {\n        if (std::get<0>(e)\
    \ == std::get<0>(best)) {\n            best = e;\n        }\n    }\n    return\
    \ std::get<1>(best);", "    int cap_ext, sm_ext;\n    std::string ext;\n\n   \
    \ auto extensions_copy = extensions.begin();\n    for (std::string ext : extensions)\
    \ {\n        // Get the capacity and strength of each extension\n        auto\
    \ cap = ext.find_first_of('A');\n        auto sm = ext.find_first_of('z');\n \
    \       cap_ext = cap - sm;\n        sm_ext = ext.size() - sm;\n        // Compare\
    \ and find the strongest extension with the highest strength\n        if (cap_ext\
    \ > sm_ext) {\n            cap_ext = sm_ext;\n            ext = ext;\n       \
    \ }\n    }\n\n    return class_name + ext;", "    for (auto it=extensions.begin();\
    \ it!=extensions.end(); ++it) {\n        auto s = class_name.size();\n       \
    \ auto c = *it;\n        assert(s[0]==c);\n        while (--s>=0 && isupper(s[s])\
    \ && !islower(s[s])) s--;\n        if (s>=0) {\n            auto t = c - 'A';\n\
    \            if (t > s) t = s;\n            assert(t>=0 && s<=class_name.length());\n\
    \            assert(class_name[t]==c);\n            if (t < s) return class_name\
    \ + '.' + extensions[t];\n        }\n    }\n    return class_name;", '    // Write
    your code here', "    // Solution code here\n    int max_strength = -1;\n    for(int\
    \ i = 0; i < extensions.size(); i++) {\n        if(max_strength < extensions[i].size()\
    \ - 1) {\n            max_strength = extensions[i].size() - 1;\n        }\n  \
    \  }\n\n    int total_strength = 0;\n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        total_strength += extensions[i].size() - 1;\n    }\n\n    if(total_strength\
    \ > max_strength) {\n        for(int i = 0; i < extensions.size(); i++) {\n  \
    \          if(total_strength > max_strength) {\n                max_strength =\
    \ total_strength;\n            }\n            total_strength -= extensions[i].size()\
    \ - 1;\n        }\n    }\n\n    return class_name + \".\" + extensions[max_strength].substr(0,\
    \ extensions[max_strength].size() - 1);", '  // Write your code here.', "    int\
    \ SM = extensions.size();\n    int CAP = class_name.length() - SM;\n    int strength\
    \ = -1;\n    for (auto ext : extensions) {\n        int CAP2 = CAP - ext.length();\n\
    \        if (CAP2 <= 0)\n            break;\n        int SM2 = SM - ext.length();\n\
    \        int x = CAP2 * SM2;\n        if (x == CAP * SM)\n            continue;\n\
    \        else if (x == 0)\n            strength = CAP - SM2;\n        else if\
    \ (x < 0)\n            strength = CAP - SM2;\n        else\n            strength\
    \ = CAP2 - SM2;\n    }\n    std::string s = class_name + \".\";\n    if (strength\
    \ > 0)\n        s += extensions.front();\n    return s;", "    int SM = class_name.size()\
    \ - 1;\n    int CAP = class_name.size();\n    int Strongest = -1;\n    int Strongest_Extension_Len\
    \ = extensions.size();\n    for (int i = 0; i < Strongest_Extension_Len; i++)\
    \ {\n        if (std::toupper(class_name[i]) != std::toupper(extensions[i])) {\n\
    \            SM = CAP;\n            CAP = extensions[i].size();\n        } else\
    \ {\n            SM = extensions[i].size();\n            CAP = CAP;\n        }\n\
    \        int extension_strength = (CAP - SM);\n        if (extension_strength\
    \ > Strongest) {\n            Strongest = extension_strength;\n        }\n   \
    \ }\n    return class_name + \".\" + extensions[Strongest_Extension_Len - 1];\
    \ // Strongest extension name is the last extension in the list", "    // Your\
    \ code here\n    if (extensions.size() <= 1) return class_name;\n    int cap_num\
    \ = std::count_if(extensions.begin(), extensions.end(), [] (const string& s) {\
    \ return s[0] == s[0]; });\n    int sm_num = std::count_if(extensions.begin(),\
    \ extensions.end(), [] (const string& s) { return s[1] == s[1]; });\n    int cap\
    \ = cap_num / extensions.size();\n    int sm = sm_num / extensions.size();\n \
    \   int strongest = cap - sm;\n    if (strongest == 0) return class_name;\n  \
    \  if (strongest > 0) return class_name + \".\" + extensions[0];\n    return class_name\
    \ + \".\" + extensions[strongest - 1];", "  if(extensions.size() == 0) {\n   \
    \ return class_name;\n  }\n  int cap_num = 0, smp_num = 0;\n  for (auto it = extensions.begin();\
    \ it != extensions.end(); ++it) {\n    if (std::toupper(*it) == class_name.substr(cap_num,\
    \ 1))\n      cap_num++;\n    else if (std::tolower(*it) == class_name.substr(smp_num,\
    \ 1))\n      smp_num++;\n  }\n  int smp_den = smp_num - cap_num;\n  int cap_den\
    \ = cap_num - smp_num;\n  if (cap_num >= smp_num) {\n    return class_name + '.'\
    \ + extensions[0];\n  }\n  else if (cap_num < smp_num) {\n    return class_name;\n\
    \  }\n  else {\n    // find the strongest extension\n    int strongest_num = smp_num;\n\
    \    int strongest_den = cap_num;\n    for (int i = 1; i < extensions.size();\
    \ i++) {\n      if (strongest_den > cap_den) {\n        strongest_den = cap_den;\n\
    \        strongest_num = cap_num;\n      }\n      if (strongest_den > smp_den)\
    \ {\n        strongest_den = smp_den;\n        strongest_num = smp_num;\n    \
    \  }\n      if (strongest_num >= strongest_den) {\n        break;\n      }\n \
    \   }\n    return class_name + '.' + extensions[i - 1];\n  }", "    int sm = 0;\n\
    \    int cap = 0;\n    std::string ans = class_name;\n    for (auto ext : extensions)\n\
    \    {\n        auto i = ext.find_first_of('Aa');\n        auto j = ext.find_first_of('Zz');\n\
    \        int l = 0; \n        bool flag = false;\n        if (i == 0) \n     \
    \   {\n            flag = true;\n            l = CAP - CAP - SM;\n        }\n\
    \        else \n        {\n            l = CAP - CAP - i;\n        }\n       \
    \ \n        if (l > cap && flag == true)\n        {\n            ans = class_name\
    \ + \".\" + ext;\n            cap = l;\n        }\n        else if (l > cap &&\
    \ flag == false)\n        {\n            ans = ans + \".\" + ext;\n          \
    \  cap = l;\n        }\n        else if (l <= cap)\n        {\n            ans\
    \ = class_name + \".\" + ext;\n            cap = l;\n        }\n    }\n    return\
    \ ans;", "    // Your code here\n    int count=0, max=0, cap=0, sm=0;\n    for(int\
    \ i=0;i<extensions.size();i++) {\n        if(extensions[i].at(0)==class_name[0])\
    \ {\n            count=1;\n            for(int j=1;j<extensions[i].size();j++)\
    \ {\n                if(extensions[i][j]==class_name[cap]) {\n               \
    \     count++;\n                }\n            }\n            cap++;\n       \
    \ }\n        else {\n            count=0;\n            for(int j=1;j<extensions[i].size();j++)\
    \ {\n                if(extensions[i][j]==class_name[sm]) {\n                \
    \    count++;\n                }\n            }\n            sm++;\n        }\n\
    \        if(count>max) {\n            max=count;\n        }\n    }\n    std::string\
    \ temp=class_name;\n    for(int i=0;i<temp.size();i++) {\n        if(temp[i]>='A'\
    \ && temp[i]<='Z') {\n            temp[i]=temp[i]+'A'-('A');\n        }\n    }\n\
    \    temp+=\".\";\n    for(int i=0;i<temp.size();i++) {\n        if(temp[i]>='a'\
    \ && temp[i]<='z') {\n            temp[i]=temp[i]+'a'-('a');\n        }\n    }\n\
    \    for(int i=0;i<extensions.size();i++) {\n        if(extensions[i].at(0)==class_name[0])\
    \ {\n            count=1;\n            for(int j=1;j<extensions[i].size();j++)\
    \ {\n                if(extensions[i][j]==class_name[cap]) {\n               \
    \     count++;\n                }\n            }\n            cap++;\n       \
    \ }\n        else {\n            count=0;\n            for(int j=1;j<extensions[i].size();j++)\
    \ {\n                if(extensions[i][j]==class_name[sm]) {\n                \
    \    count++;\n                }\n            }\n            sm++;\n        }\n\
    \        if(count>max) {\n            max=count;\n        }\n    }\n    return\
    \ temp+std::to_string(max);", "    // Write your code here\n    \n    // return\
    \ \"my_class.AA\";\n    // return \"my_class.Be\";\n    std::string ret = \".\"\
    \ + class_name;\n    for (auto ext : extensions) {\n        auto cap = ext.find_first_of('A');\n\
    \        auto sm = ext.find_first_of('z');\n        if (cap == ext.size() - 1\
    \ && sm == ext.size() - 1) continue;\n        int cap_stk = cap - sm;\n      \
    \  if (cap_stk == 0) continue;\n        int cap_stk_norm = cap_stk / CAP;\n  \
    \      int cap_stk_norm_last = cap_stk_norm * CAP;\n        if (cap_stk_norm ==\
    \ 0 || cap_stk_norm_last == CAP) continue;\n        int strongest_cap = cap_stk\
    \ - cap_stk_norm_last;\n        int strongest_cap_norm = strongest_cap / CAP;\n\
    \        int strongest_cap_norm_last = strongest_cap_norm * CAP;\n        if (strongest_cap_norm\
    \ == 0 || strongest_cap_norm_last == CAP) continue;\n        if (strongest_cap_norm\
    \ < strongest_cap_norm_last) {\n            ret = ret + \".\" + ext;\n       \
    \ }\n    }\n    return ret;", "    int sm = 0, cap = 0;\n    for (int i = 0; i\
    \ < extensions.size(); i++) {\n        if (class_name[cap] == extensions[i][sm])\
    \ { \n            cap++; \n            if (cap == class_name.length()) {\n   \
    \             sm++; \n                cap = 0;\n            }\n        }\n   \
    \     else { \n            cap = 0; \n            sm = 0; \n        }\n    }\n\
    \    std::string strongest_extension = class_name + extensions[cap]; \n    return\
    \ strongest_extension; ", "    // Write your code here\n    std::sort(extensions.begin(),\
    \ extensions.end());\n    int total_upper = 0;\n    int total_lower = 0;\n   \
    \ int total_len = 0;\n    for (auto itr = extensions.begin(); itr != extensions.end();\
    \ itr++) {\n        total_upper += std::count(itr->begin(), itr->end(), static_cast<unsigned\
    \ char>('A'));\n        total_lower += std::count(itr->begin(), itr->end(), static_cast<unsigned\
    \ char>('a'));\n        total_len += itr->size();\n    }\n\n    int strength =\
    \ 0;\n    if (total_upper - total_lower != 0) {\n        strength = total_upper\
    \ - total_lower;\n    }\n    else {\n        strength = total_lower;\n    }\n\n\
    \    std::string strongest_extension = class_name + '.' + extensions[0];\n\n \
    \   for (auto itr = extensions.begin() + 1; itr != extensions.end(); itr++) {\n\
    \        if (std::count(itr->begin(), itr->end(), static_cast<unsigned char>('A'))\
    \ == 0 && \n            std::count(itr->begin(), itr->end(), static_cast<unsigned\
    \ char>('a')) == 0 && \n            std::count(itr->begin(), itr->end(), static_cast<unsigned\
    \ char>('A')) == 0) {\n            strongest_extension = class_name + '.' + itr[0];\n\
    \        }\n    }\n\n    return strongest_extension;", "\t// Write your code here\n\
    \tassert(class_name != \"\");\n\tassert(extensions.size() != 0);\n\tfor (auto\
    \ &e : extensions) {\n\t\tif (std::toupper(class_name[0]) - std::toupper(e[0])\
    \ > 0) return class_name + e;\n\t\tif (std::toupper(class_name[0]) - std::toupper(e[0])\
    \ < 0) return class_name + e;\n\t\tif (std::tolower(class_name[0]) - std::tolower(e[0])\
    \ > 0) return class_name + e;\n\t\tif (std::tolower(class_name[0]) - std::tolower(e[0])\
    \ < 0) return class_name + e;\n\t}\n\treturn class_name;", "    std::vector<std::string>\
    \ sorted_extensions = extensions;\n    std::sort(sorted_extensions.begin(), sorted_extensions.end());\n\
    \    // The index of the extension with strongest strength\n    int index;\n \
    \   for (index = 0; index < sorted_extensions.size(); ++index) {\n        std::string\
    \ extension = sorted_extensions[index];\n        int count = std::count_if(extension.begin(),\
    \ extension.end(), [](char c) {return isupper(c); });\n        // Ignore all capitalized\
    \ extensions\n        if (count == 0 && islower(extension[0])) {\n           \
    \ continue;\n        }\n        // Ignore extensions with no uppercase letters.\n\
    \        if (count == 0) {\n            continue;\n        }\n        int strength\
    \ = count - 1;\n        // Strength is calculated using the fraction of the number\
    \ of uppercase\n        // letters in the extension's name.\n        int cap_strength\
    \ = std::count_if(extension.begin(), extension.end(), [](char c) {return isupper(c);\
    \ });\n        int sm_strength = std::count_if(extension.begin(), extension.end(),\
    \ [](char c) {return islower(c); });\n        int frac = cap_strength - sm_strength;\n\
    \        if (strength < frac) {\n            index = index;\n            strength\
    \ = frac;\n        }\n    }\n    return class_name + sorted_extensions[index];",
  "// Your code here\n    return 0;", "   \n    // Initialize two variables\n    int\
    \ max_extension_strength = -1;\n    std::string extension_name = \"\";\n    \n\
    \    // Loop through each extension\n    for (int i = 0; i < (int)extensions.size();\
    \ i++) {\n        \n        // Initialize a variable for each extension\n    \
    \    std::string extension = extensions[i];\n        \n        // Split the string\
    \ into first letter and rest\n        std::string first_letter = extension[0];\n\
    \        std::string extension_with_rest = extension.substr(1);\n        \n  \
    \      // Assign a variable for each letter\n        int cap_letters = 0, sml_letters\
    \ = 0;\n        \n        // Iterate through each letter in the first letter\n\
    \        for (int j = 0; j < (int)first_letter.size(); j++) {\n            //\
    \ If the first letter is a capital letter\n            if (first_letter[j] >=\
    \ 'A' && first_letter[j] <= 'Z') {\n                cap_letters++;\n         \
    \   }\n            // If the first letter is a small letter\n            else\
    \ if (first_letter[j] >= 'a' && first_letter[j] <= 'z') {\n                sml_letters++;\n\
    \            }\n        }\n        \n        // Check if the extension's strength\
    \ matches\n        if (cap_letters - sml_letters == 0) {\n            // If it\
    \ does, the strength is -1 so keep the previous extension\n            if (max_extension_strength\
    \ > -1) {\n                extension_name = extension_with_rest;\n           \
    \ }\n            // If it doesn't, the strength is 1 so keep the previous extension\n\
    \            else {\n                extension_name = extension_with_rest;\n \
    \           }\n        }\n        // If the extension's strength doesn't match\n\
    \        else if (max_extension_strength == -1) {\n            // Keep the previous\
    \ extension\n            extension_name = extension_with_rest;\n        }\n  \
    \      // If the extension's strength does match\n        else {\n           \
    \ // If it does, keep the previous extension but change the extension's name\n\
    \            if (max_extension_strength > -1) {\n                extension_name\
    \ = extension_with_rest;\n            }\n            // If it doesn't, keep the\
    \ previous extension but change the extension's name\n            else {\n   \
    \             extension_name = extension_with_rest;\n            }\n        }\n\
    \        \n        // Check if extension_name already has a value\n        if\
    \ (extension_name != \"\") {\n            // If it does, keep the previous extension\n\
    \            if (max_extension_strength > -1) {\n                max_extension_strength\
    \ = -1;\n            }\n            // If it doesn't, keep the previous extension\n\
    \            else {\n                max_extension_strength = -1;\n          \
    \  }\n        }\n    }\n    return extension_name;", "\tstd::map<int, std::string>\
    \ map;\n\tfor(auto e:extensions){\n\t\tmap[std::count_if(e.begin(), e.end(), [](char\
    \ c){ return std::toupper(c) >= 'A'; }) / std::count_if(e.begin(), e.end(), [](char\
    \ c){ return std::tolower(c) < 'a';})] = e;\n\t}\n\treturn (class_name + \".\"\
    \ + map[std::count_if(extensions.begin(), extensions.end(), [](std::string s){return\
    \ std::count_if(s.begin(), s.end(), [](char c){ return std::toupper(c) >= 'A';\
    \ }) / std::count_if(s.begin(), s.end(), [](char c){ return std::tolower(c) <\
    \ 'a';})].substr(0, extensions.size()));", "    std::string result = \"\";\n \
    \   for (auto &it : extensions) {\n        if (it == class_name) continue;\n \
    \       auto class_index = class_name.find(it);\n        if (class_index != std::string::npos)\
    \ {\n            auto it_to_start = class_name.find(it, class_index);\n      \
    \      if (it_to_start != std::string::npos) {\n                auto it_to_end\
    \ = class_name.find(it, it_to_start);\n                if (it_to_end != std::string::npos)\
    \ {\n                    int index1 = class_name.size() - it_to_end;\n       \
    \             int index2 = it_to_start;\n                    auto strength1 =\
    \ index1 - index2;\n                    auto strength2 = index1 - it_to_start;\n\
    \                    if (strength1 > strength2) {\n                        result\
    \ = class_name + \".\" + it;\n                        break;\n               \
    \     }\n                }\n            }\n        }\n    }\n    return result;",
  "    // Your code goes here\n    int cap, sm;\n    float p = (float) cap / (float)\
    \ sm;\n    std::sort(extensions.begin(), extensions.end(), \n        [](const\
    \ std::string& l, const std::string& r){return l.size() < r.size();});\n    \n\
    \    std::reverse(extensions.begin(), extensions.end());\n    std::reverse(extensions.begin(),\
    \ extensions.begin() + std::min_element(extensions.begin(), extensions.end(),\
    \ \n        [](const std::string& l, const std::string& r){return l.length() <\
    \ r.length();})->size());\n    \n    for (auto i : extensions) {\n        if (i.size()\
    \ >= cap)\n            cap -= i.size();\n        if (i.size() >= sm)\n       \
    \     sm -= i.size();\n    }\n    \n    if (cap < 1)\n        return class_name;\n\
    \    return class_name + (\"\\\\\" + std::to_string(extensions.size() - sm) +\
    \ \"\\\\\" + std::to_string(cap));", "    // Write your code here\n    int c =\
    \ 0;\n    int s = class_name.size();\n    int cap = 0;\n    for(auto i : extensions){\n\
    \        c = s + i.size();\n        cap = cap + i;\n    }\n    float f = (cap\
    \ - s)/cap;\n    float strength = -1;\n    float max = 0;\n    for(auto i : extensions){\n\
    \        if( (cap - i)/cap > f){\n            strength = i;\n            max =\
    \ cap - i;\n        }\n    }\n    return class_name + \".\" + strength;", "  //\
    \ Write your code here.\n  assert(extensions.size() > 0);\n  assert(class_name.size()\
    \ > 0);\n  assert(extensions.size() <= 50);\n  \n  int ca = 0;\n  int sm = 0;\n\
    \  int max_str = 0;\n  std::string result = \"\";\n  for (int i = 0; i < extensions.size();\
    \ i++) {\n    if (extensions[i].size() > 1) {\n      int n = 0;\n      for (int\
    \ j = 0; j < extensions[i].size(); j++) {\n        n = 2 * n + extensions[i][j]\
    \ - 'A' + 1;\n      }\n      ca = ca * n + i;\n      sm = sm * n + i;\n    }\n\
    \  }\n  max_str = ca - sm;\n  int i = 0;\n  while (ca > sm) {\n    if (max_str\
    \ > i) {\n      result += class_name[i] + \".\" + extensions[i];\n    }\n    i++;\n\
    \  }\n  return result;", '    ', "    assert(extensions.size() > 0);\n    std::map<int,\
    \ std::string> counter;\n    for (auto& extension : extensions) {\n        std::string::size_type\
    \ pos = extension.find_first_of(' ');\n        assert(pos != std::string::npos);\n\
    \        std::string s = extension.substr(pos + 1, extension.length());\n    \
    \    int c = std::count_if(s.begin(), s.end(), isupper);\n        counter[c] +=\
    \ s;\n    }\n    int max = counter.begin()->second;\n    std::map<int, std::string>::iterator\
    \ it = counter.begin();\n    for (;it != counter.end(); ++it) {\n        if (it->second\
    \ > max) {\n            max = it->second;\n        }\n    }\n    int cap = it->second.size();\n\
    \    std::string strongest = class_name + \".\" + extensions[cap];\n    return\
    \ strongest;", "    int counter = 0;\n    for (auto extension : extensions) {\n\
    \        auto pos = class_name.find(extension);\n        if (pos == std::string::npos)\
    \ {\n            counter++;\n            continue;\n        }\n        auto first_index\
    \ = pos;\n        auto last_index = pos;\n        for (auto it = first_index;\
    \ it < class_name.size(); ++it) {\n            if (class_name.at(it) >= 'A' &&\
    \ class_name.at(it) <= 'Z')\n                last_index = it;\n        }\n   \
    \     auto strength = last_index - first_index;\n        if (strength > counter)\
    \ {\n            counter = strength;\n            extension = class_name + extension;\n\
    \        }\n    }\n    return extension;", // Write your code here, "  // Complete\
    \ the implementation here.\n  assert(extensions.size() > 0);\n  for (auto e :\
    \ extensions)\n  {\n    if (e.length() < class_name.length())\n      return class_name\
    \ + e;\n    if (e.length() > class_name.length())\n    {\n      int c = 0, s =\
    \ 0;\n      for (int i = 0; i < e.length(); i++)\n      {\n        if (e[i] >=\
    \ class_name[i]) \n        {\n          c++;\n        }\n        else\n      \
    \  {\n          s++;\n        }\n      }\n      int c2 = c - s;\n      if (c2\
    \ < 0)\n      {\n        std::swap(c, c2);\n      }\n      int s1 = c - c2;\n\
    \      if (s1 < 0)\n      {\n        std::swap(s1, s2);\n      }\n      int c1\
    \ = c2 + s;\n      if (c1 < 0)\n      {\n        std::swap(c1, c2);\n      }\n\
    \      int s2 = c1 - c2;\n      if (s2 < 0)\n      {\n        std::swap(s2, s1);\n\
    \      }\n      int maxc = s1, maxs = c1;\n      if (maxc > maxs) \n      {\n\
    \        maxs = maxc;\n      }\n      std::string s = class_name + extensions[maxs];\n\
    \      return s;\n    }\n  }\n  return \"\";", "    int CAP = 0;\n    int SM =\
    \ 0;\n    for(auto it=extensions.begin(); it!=extensions.end(); ++it)\n    {\n\
    \        if(*it == class_name.at(CAP))\n        {\n            CAP++;\n      \
    \  }\n        else\n        {\n            SM++;\n        }\n    }\n    float\
    \ strength = CAP - SM;\n    return class_name + \".\" + extensions[std::distance(extensions.begin(),\
    \ std::max_element(extensions.begin(), extensions.end()))] + std::to_string(strength);",
  "   std::map<int, std::string> extension_map;\n   std::map<int, std::string>::iterator\
    \ it;\n   for(it = extension_map.begin(); it != extension_map.end(); ++it) {\n\
    \       std::cerr << \"Extension: \" << it->second << std::endl;\n   }\n   assert(extension_map.size()\
    \ > 0);\n\n   std::map<int, std::string> sorted_extensions = extension_map;\n\
    \   std::sort(sorted_extensions.begin(), sorted_extensions.end(), \n    [](const\
    \ std::pair<int, std::string> &a, const std::pair<int, std::string> &b) -> bool\
    \ {\n        return a.second < b.second;\n    });\n   std::string strongest_extension\
    \ = sorted_extensions[0].second;\n   for(auto &ext : sorted_extensions) {\n  \
    \     if((ext.second[ext.second.length() - 1] - ext.second[0]) < strongest_extension.length()\
    \ - 1) {\n           strongest_extension = ext.second;\n       }\n   }\n\n   std::cout\
    \ << \"StrangeExtension: \" << strongest_extension << std::endl;\n   return class_name\
    \ + \".\" + strongest_extension;", "    assert(extensions.size() > 0);\n    int\
    \ cap = class_name.size();\n    int sm = class_name.size();\n    for (auto ex\
    \ : extensions) {\n        cap = std::max(cap, ex.size());\n        sm = std::max(sm,\
    \ ex.size());\n    }\n    return class_name.substr(0, cap - sm) + \".\" + std::to_string(extensions.back()[0]);",
  "\t// Write your code here\n\tassert(class_name.size() > 0 && extensions.size()\
    \ > 0);\n\tint strength_sum = 0;\n\tint index = 0;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tbool flag = true;\n\t\tfor (int j = 0; j < class_name.size(); j++)\
    \ {\n\t\t\tif (class_name[j] == extensions[i][0]) {\n\t\t\t\tstrength_sum += class_name[j]\
    \ - extensions[i][0];\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t\tif (flag) {\n\t\t\tindex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint strength =\
    \ strength_sum / class_name.size();\n\tif (strength < 0) {\n\t\tstrength = -1;\n\
    \t}\n\tstd::string strongest_extension;\n\tfor (int i = 0; i < extensions.size();\
    \ i++) {\n\t\tif (extensions[i][1] == strongest_extension) {\n\t\t\tcontinue;\n\
    \t\t}\n\t\tif (strength > 0) {\n\t\t\tif (extensions[i][1] > strongest_extension)\
    \ {\n\t\t\t\tstrongest_extension = extensions[i][1];\n\t\t\t}\n\t\t} else if (extensions[i][1]\
    \ < strongest_extension) {\n\t\t\tstrongest_extension = extensions[i][1];\n\t\t\
    }\n\t}\n\treturn strongest_extension;", "\tassert(extensions.size() >= 2);\n\t\
    // Write your code here\n\n\tstd::string strongest_name = class_name + ((extensions.size()\
    \ - 2) * \".\");\n\n\tfor (int i = 1; i < extensions.size(); i++) {\n\t\tif (strongest_name[strongest_name.size()\
    \ - 1 - i] == extensions[i - 1]) {\n\t\t\tstrongest_name[strongest_name.size()\
    \ - 1 - i] = extensions[i];\n\t\t}\n\t}\n\n\treturn strongest_name;", '    //
    code here', "    std::sort(extensions.begin(), extensions.end(), [](std::string\
    \ e1, std::string e2) -> bool { return e1 == e2; });\n    auto it = std::max_element(extensions.begin(),\
    \ extensions.end()); // Find strongest extension\n    std::string strongest_extension\
    \ = class_name + std::string(it->begin(), it->end()); // Generate strongest extension\
    \ name\n    if (extensions.size() > 1) { // If more than one extensions with the\
    \ same strongest extension name we choose the first one\n        auto it = std::min_element(extensions.begin(),\
    \ extensions.end());\n        strongest_extension = class_name + std::string(it->begin(),\
    \ it->end());\n    }\n    return strongest_extension;", "    \n    int cap = class_name.length();\n\
    \    int sm = class_name.size()-1;\n    int strength = 0;\n    std::string strongest_extension\
    \ = \"\";\n    for (auto extension: extensions) {\n        auto cap_letters =\
    \ extension.size();\n        auto sm_letters = extension.size()-1;\n        auto\
    \ fraction = cap_letters-sm_letters;\n        strength += fraction;\n    }\n \
    \   if (strength == cap-sm) {\n        std::cout << \"The strongest extension\
    \ is \" << class_name <<\n            \" with the strength \" << strength << \"\
    .\" << std::endl;\n        strongest_extension = class_name;\n    }\n    else\
    \ if (strength < cap-sm) {\n        std::cout << \"There are two or more extensions\
    \ with the same strength.\" << std::endl;\n        std::cout << \"The one with\
    \ the lowest strength comes first.\" << std::endl;\n        strongest_extension\
    \ = std::to_string(strength)+\".\"+extensions[0];\n    }\n    else if (strength\
    \ == cap-sm) {\n        std::cout << \"There are two or more extensions with the\
    \ same strength.\" << std::endl;\n        std::cout << \"The one with the highest\
    \ strength comes first.\" << std::endl;\n        strongest_extension = std::to_string(strength)+\"\
    .\"+extensions[0];\n    }\n    return strongest_extension;", "    \n    struct\
    \ map\n    {\n        std::string key;\n        int val;\n    };\n\n    map m;\
    \ // A map of class names and their strength\n    // Iterate over the list and\
    \ set the key as the class name and the value as the strength\n    for(auto& e:\
    \ extensions)\n        m.insert({e, -1}); // -1 is for no extension\n    // Get\
    \ the class name \n    auto p = m.find(class_name);\n    // Get the class name's\
    \ strength\n    int s = p->val;\n    // Iterate over the list and get the value\
    \ for the given key\n    for(auto& e: extensions)\n        if(e == class_name)\n\
    \            continue;\n        p = m.find(e);\n        if(s->val > p->val)\n\
    \            s.val = p->val;\n    return class_name + '.' + std::to_string(s);",
  "    long long CAP = 0;\n    long long SM = 0;\n    for (int i = 0; i < extensions.size();\
    \ ++i) {\n        for (int j = 0; j < class_name.length(); ++j) {\n          \
    \  if (class_name[j] == extensions[i][0]) {\n                CAP++;\n        \
    \        SM++;\n            }\n        }\n    }\n    if (CAP - SM == CAP) {\n\
    \        return class_name + \".\" + extensions[0];\n    }\n    int strength =\
    \ CAP - SM;\n    for (int i = 0; i < extensions.size(); ++i) {\n        if (extensions[i].size()\
    \ == strength) {\n            return class_name + \".\" + extensions[i];\n   \
    \     }\n    }", "    int c=0;\n    for(auto e : extensions) {\n        c+=e[0]-'A';\n\
    \    }\n    int sm = c-class_name.size(); //number of letters \n    int cap =\
    \ class_name[0]-'A'; //capital letters \n    int strength = cap-sm; //strength\n\
    \    sort(extensions.begin(), extensions.end());\n    int i=0;\n    for(auto e\
    \ : extensions) {\n        if(i==0) {\n            if(c+e[0]-('A'-cap)<sm) {\n\
    \                strength = cap-(c+e[0]-('A'-cap));\n            }\n         \
    \   i=1;\n        }\n        else if(i==1) {\n            if(c+e[0]-('a'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('a'-cap));\n            }\n     \
    \       i=2;\n        }\n        else if(i==2) {\n            if(c+e[0]-('c'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('c'-cap));\n            }\n     \
    \       i=3;\n        }\n        else if(i==3) {\n            if(c+e[0]-('e'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('e'-cap));\n            }\n     \
    \       i=4;\n        }\n        else if(i==4) {\n            if(c+e[0]-('i'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('i'-cap));\n            }\n     \
    \       i=5;\n        }\n        else if(i==5) {\n            if(c+e[0]-('o'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('o'-cap));\n            }\n     \
    \       i=6;\n        }\n        else if(i==6) {\n            if(c+e[0]-('u'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('u'-cap));\n            }\n     \
    \       i=7;\n        }\n        else if(i==7) {\n            if(c+e[0]-('N'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('N'-cap));\n            }\n     \
    \       i=8;\n        }\n        else if(i==8) {\n            if(c+e[0]-('G'-cap)<sm)\
    \ {\n                strength = cap-(c+e[0]-('G'-cap));\n            }\n     \
    \       i=9;\n        }\n        else if(i==9) {", "    size_t sm = class_name.size();\n\
    \    size_t cap = class_name.find_first_of('A');\n    if (cap == std::string::npos)\
    \ {\n        cap = class_name.find_first_of('Z');\n    }\n    size_t strongest\
    \ = cap - sm;\n    size_t max_extension_count = extensions.size();\n    for (size_t\
    \ i = 0; i < max_extension_count; i++) {\n        size_t current_extension_count\
    \ \n            = extensions[i].find_first_of('a') - extensions[i].find_first_of('Z');\n\
    \        if (strongest > current_extension_count) {\n            return class_name\
    \ + '.' + extensions[i];\n        }\n        strongest = current_extension_count;\n\
    \    }\n    return class_name;", "\t// Initialize SM with number of characters\
    \ in class_name\n\tint SM = class_name.size();\n\t// Initialize CAP with number\
    \ of characters in class_name\n\tint CAP = class_name.size();\n\t\n\t// Iterate\
    \ over extensions list\n\tfor (int i = 0; i < extensions.size(); i++) {\n\t\t\
    // Extract letters from extension name\n\t\tstd::string letters = extensions[i];\n\
    \t\t\n\t\t// Iterate over class_name and find number of uppercase\n\t\tfor (int\
    \ j = 0; j < CAP; j++) {\n\t\t\tif (letters[j] == class_name[j]) CAP--;\n\t\t\
    }\n\t\t\n\t\t// Iterate over class_name and find number of lowercase\n\t\tfor\
    \ (int j = 0; j < SM; j++) {\n\t\t\tif (letters[j] == class_name[j]) SM--;\n\t\
    \t}\n\t\t\n\t\t// Calculate extension's strength\n\t\tint S = CAP - SM;\n\t\t\n\
    \t\t// If extension's strength is more than 1, set extension's name to \n\t\t\
    // the name of the class \n\t\tif (S > 1) {\n\t\t\textensions[i] = class_name;\n\
    \t\t}\n\t}\n\t\n\t// Find the strongest extension\n\tint min = 0;\n\tfor (int\
    \ i = 0; i < extensions.size(); i++) {\n\t\tif (extensions[i] < extensions[min])\
    \ { min = i; }\n\t}\n\t\n\t// Return strongest extension's name\n\treturn extensions[min];",
  "    // Your code here\n    float total_strength = 0;\n    for(int i=0;i<extensions.size();i++){\n\
    \        total_strength+=(class_name.count(extensions[i])-class_name.count(std::tolower(extensions[i])))*0.5f;\n\
    \    }\n    int max=0; //The index where we store the max string\n    for(int\
    \ i=0;i<extensions.size();i++){\n        if(total_strength>max){\n           \
    \ max=total_strength;\n        }\n        else if(total_strength==max)\n     \
    \       max=total_strength;\n        total_strength+=extensions[i].count(std::tolower(extensions[i]));\n\
    \    }\n    assert(max>0);\n    return class_name+\".\"+extensions[max];", " \
    \   // code here\n    ", "  // Your code goes here\n  \n  // Solution begins\n\
    \  int cap = 0;\n  int sm = 0;\n  for (auto e : extensions) {\n    int index =\
    \ e.find_first_of('A');\n    cap += index;\n    index = e.find_first_of('l');\n\
    \    sm += index;\n  }\n  float strength = cap - sm;\n  auto pos = extensions.find(*std::min_element(extensions.begin(),\
    \ extensions.end(), \n    [](std::string s1, std::string s2) -> bool \n    {\n\
    \       return strcmp(s1.c_str(), s2.c_str()) < 0;\n    }));\n  \n  return class_name\
    \ + \".\" + extensions[pos];", "    int sum = 0;\n    for (auto ext: extensions)\
    \ {\n        int cap = ext.size();\n        int sm = class_name.size();\n    \
    \    sum += cap - sm;\n    }\n    double strength = (double)sum / extensions.size();\n\
    \    auto it = std::min_element(extensions.begin(), extensions.end(), [strength](const\
    \ std::string &a, const std::string &b) { return strength < std::stof(a) - std::stof(b);\
    \ });\n    return class_name + \".\" + extensions[it - extensions.begin()];",
  "    std::sort(extensions.begin(), extensions.end(), [](std::string const& a, std::string\
    \ const& b){\n        return a.size() - b.size();\n    });\n    int cap = class_name.size();\n\
    \    int sm = cap;\n    for (int i = 0; i < extensions.size(); ++i) {\n      \
    \  int const slen = (extensions[i].size() - 1);\n        sm -= slen;\n       \
    \ cap -= slen;\n    }\n    int const stren = cap / sm;\n    if (stren > 0) {\n\
    \        std::string extension_class_name = class_name + extensions[stren];\n\
    \        return extension_class_name;\n    }\n    return class_name;", "    double\
    \ cap_counter = 0.0, sm_counter = 0.0, strength = -1.0;\n    std::string ext;\n\
    \    for (auto &ext : extensions) {\n        cap_counter += toupper(ext[0]) -\
    \ 'A';\n        sm_counter += tolower(ext[0]) - 'a';\n        strength = (cap_counter\
    \ - sm_counter) / (cap_counter + sm_counter);\n    }\n    if (strength == -1.0)\
    \ {\n        return \"Invalid\";\n    }\n    else {\n        return class_name\
    \ + \".\" + extensions[std::distance(extensions.begin(), std::max_element(extensions.begin(),\
    \ extensions.end()))];\n    }", "    unsigned int cap_counter = 0;\n    unsigned\
    \ int sm_counter = 0;\n    int strength;\n    for (unsigned int i = 0; i < extensions.size();\
    \ ++i) {\n        if (extensions[i][0] >= 'A' && extensions[i][0] <= 'Z') {\n\
    \            cap_counter++;\n        } else if (extensions[i][0] >= 'a' && extensions[i][0]\
    \ <= 'z') {\n            sm_counter++;\n        }\n    }\n    if (cap_counter\
    \ > sm_counter) {\n        strength = cap_counter - sm_counter;\n    } else {\n\
    \        strength = sm_counter - cap_counter;\n    }\n    unsigned int strongest_extension\
    \ = std::numeric_limits<unsigned int>::max();\n    for (unsigned int i = 0; i\
    \ < extensions.size(); ++i) {\n        if (extensions[i][0] >= 'A' && extensions[i][0]\
    \ <= 'Z') {\n            cap_counter++;\n        } else if (extensions[i][0] >=\
    \ 'a' && extensions[i][0] <= 'z') {\n            sm_counter++;\n        }\n  \
    \      if (strength >= strongest_extension) {\n            strongest_extension\
    \ = strength;\n        }\n    }\n    return class_name + extensions[strongest_extension\
    \ - 1];", "  std::stack<std::string> s;\n  int cap_counter = 0, sm_counter = 0;\n\
    \  for (auto& ext : extensions) {\n    if (ext.length() >= cap_counter) cap_counter++;\n\
    \    if (ext.length() >= sm_counter) sm_counter++;\n  }\n  return class_name +\
    \ extensions.front();", "    std::vector<int> strength;\n    strength.resize(extensions.size(),\
    \ -1);\n    for (std::size_t i = 0; i < extensions.size(); i++) {\n        int\
    \ length = extensions[i].length();\n        strength[i] = static_cast<int>(std::count_if(extensions[i].begin(),\
    \ extensions[i].end(),\n            [](char c) { return (c >= 'A' && c <= 'Z')\
    \ || (c >= 'a' && c <= 'z'); }\n        ));\n    }\n    \n    auto it = std::max_element(std::begin(strength),\
    \ std::end(strength));\n    int index = std::distance(std::begin(strength), it);\n\
    \    \n    int cap_len = class_name.size();\n    int sm_len = strength[index].size();\n\
    \    double strength = strength[index];\n    if (sm_len == 0) {\n        return\
    \ class_name;\n    }\n    int cap = std::count_if(class_name.begin(), class_name.end(),\n\
    \        [](char c) { return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\
    \ }\n    );\n    double fraction = cap / sm_len;\n    double strength_rounded\
    \ = std::round(fraction * strength);\n    return class_name + '.' + extensions[index][cap_len\
    \ - sm_len - 1];", "    int cap_ext = 0;\n    int smp_ext = 0;\n    for(auto e\
    \ : extensions){\n        if(isupper(e)){\n            cap_ext++;\n        }\n\
    \        else if(islower(e)){\n            smp_ext++;\n        }\n    }\n    int\
    \ strong_ext = cap_ext-smp_ext;\n    std::sort(extensions.begin(), extensions.end());\n\
    \    for(int i=0;i<extensions.size();i++){\n        if(isupper(extensions[i][0])){\n\
    \            cap_ext--;\n        }\n        else if(islower(extensions[i][0])){\n\
    \            smp_ext--;\n        }\n    }\n    if(cap_ext > smp_ext){\n      \
    \  std::string result = class_name + \".\";\n        int index = 0;\n        for(auto\
    \ e : extensions){\n            if(!isupper(e[0]) && index!=extensions.size()\
    \ - 1){\n                result += e;\n            }\n            else if(isupper(e[0])){\n\
    \                index++;\n            }\n        }\n        return result;\n\
    \    }\n    else{\n        return class_name;\n    }", "    int sum = 0;\n   \
    \ std::string temp = \"\";\n    for (auto& i : extensions)\n        sum += toupper(i)\
    \ - 'A';\n    if (sum == 0)\n        return \"Not Found\";\n    for (auto& i :\
    \ extensions)\n        sum += tolower(i) - 'a';\n    if (sum == 0)\n        return\
    \ \"Not Found\";\n    int cap = sum / CAP;\n    int sm = sum % CAP;\n    for (int\
    \ i = 0; i < CAP; i++) {\n        if (toupper(class_name[i]) == toupper(extensions[cap\
    \ - i]))\n            cap = i;\n    }\n    for (int i = 0; i < CAP; i++) {\n \
    \       if (tolower(class_name[i]) == tolower(extensions[sm - i]))\n         \
    \   sm = i;\n    }\n    temp = class_name + \".\" + extensions[cap - sm];\n  \
    \  return temp;", "    // Write your code here\n    // std::map<int, std::string>\
    \ extension_map;\n    \n    // your code goes here\n    \n    std::string strongest_extension\
    \ = class_name;\n    int num_uppercase_letters = 0;\n    int num_lowercase_letters\
    \ = 0;\n    for (int i = 0; i < extensions.size(); ++i) {\n        char chr =\
    \ extensions[i];\n        if (std::isupper(chr)) {\n            num_uppercase_letters++;\n\
    \        } else if (std::islower(chr)) {\n            num_lowercase_letters++;\n\
    \        }\n    }\n    int num_letters = extensions.size();\n    if (num_letters\
    \ == 0) {\n        return strongest_extension;\n    }\n    int num_strengths =\
    \ num_uppercase_letters - num_lowercase_letters;\n    if (num_strengths == 0)\
    \ {\n        return strongest_extension;\n    }\n    int uppercase_fraction =\
    \ num_uppercase_letters / num_letters;\n    int lowercase_fraction = num_lowercase_letters\
    \ / num_letters;\n    int strength = uppercase_fraction * num_strengths - lowercase_fraction\
    \ * num_strengths;\n    if (num_lowercase_letters == num_uppercase_letters) {\n\
    \        return strongest_extension;\n    }\n    if (strength > 0) {\n       \
    \ strongest_extension += \".\" + extensions[0];\n        return strongest_extension;\n\
    \    }\n    int index = extensions.rbegin()->second;\n    strongest_extension\
    \ += \".\" + extensions[index];\n    return strongest_extension;", "    int cap_num\
    \ = 0, sm_num = 0; // CAP and SM are extension's capital and small letters\n \
    \   for (auto e : extensions) {\n        if (e.size() == cap_num)\n          \
    \  cap_num += e.size();\n        else if (e.size() == sm_num)\n            sm_num\
    \ += e.size();\n        else\n            break;\n    }\n    int strength = cap_num\
    \ - sm_num;\n    if (strength > 0)\n        return class_name + extensions[std::distance(extensions.begin(),\
    \ \n                std::min_element(extensions.begin(), extensions.end(), \n\
    \                [](std::string a, std::string b) { return strlen(a.c_str()) >\
    \ strlen(b.c_str()); })) - 1] + \n        std::to_string(strength);\n    else\n\
    \        return class_name;", "    // Declare variables and set them up\n    std::string\
    \ strongest_extension;\n    int cap_num, sm_num;\n    int strength;\n\n    //\
    \ Find the cap and sm numbers for the extension\n    for (auto e : extensions)\n\
    \    {\n        cap_num = std::count(e.begin(), e.end(), 'A') - 1;\n        sm_num\
    \ = std::count(e.begin(), e.end(), 'a') - 1;\n    }\n    // Find the strength\
    \ of the extension\n    strength = cap_num - sm_num;\n\n    // If there are no\
    \ extensions return empty string\n    if (strength < 1)\n        return \"\";\n\
    \n    // If there are only two extensions with the same strength, return the second\
    \ extension\n    if (strength == 2 && cap_num > sm_num)\n        return extensions[1];\n\
    \n    // Return the strongest extension\n    strongest_extension = class_name\
    \ + \".\";\n    for (auto e : extensions)\n    {\n        // If the extension\
    \ has the same strength as the strongest extension,\n        // append the extension\
    \ name to the strongest extension, \n        // otherwise append the extension\
    \ name to the strongest extension + the extension name\n        if (strongest_extension.length()\
    \ < (class_name + \".\" + e).length())\n            strongest_extension += e;\n\
    \        else\n            strongest_extension += class_name + \".\" + e;\n  \
    \  }\n\n    return strongest_extension;", "    // Your code here\n    return 0;",
  "    float cap, sm, strength;\n    size_t pos;\n    std::string name = class_name;\n\
    \    for (pos = 0; pos < extensions.size(); ++pos) {\n        name = name + \"\
    .\" + extensions[pos];\n        cap = name.find_first_of('A');\n        sm = name.find_first_of('l');\n\
    \        strength = cap - sm;\n        if (strength > 0) {\n            strength\
    \ = -strength;\n        }\n        if (strength != 0) {\n            break;\n\
    \        }\n    }\n    if (strength == 0) {\n        return name;\n    }\n   \
    \ return name + \".\" + extensions[pos];", "    int max_extension = INT_MIN; //\
    \ Initializing max_extension \n    int strongest_extension = INT_MIN; // Initializing\
    \ strongest_extension \n    std::string temp = \"\";\n    for(int i = 0; i < extensions.size();\
    \ i++){\n        // Checking if the extension is of length more than 1 \n    \
    \    if(extensions[i].length() > 1){\n            // Checking if extension is\
    \ of length 2 \n            if(extensions[i].length() == 2){\n               \
    \ // Checking if the extension is of length 3 \n                if(extensions[i].length()\
    \ == 3){\n                    // Checking if the first letter of extension matches\
    \ the class name \n                    if(class_name.at(0) >= extensions[i].at(0)\
    \ + 3){\n                        // Checking if the extension has the second letter\
    \ of extension \n                        if(extensions[i].at(1) >= class_name.at(1)\
    \ + 2){\n                            // Checking if the extension has the third\
    \ letter of extension \n                            if(extensions[i].at(2) >=\
    \ class_name.at(2) + 1){\n                                // Checking if the extension\
    \ is equal to the class name \n                                if(extensions[i]\
    \ == class_name){\n                                    temp = class_name;\n  \
    \                              }\n                                // Checking\
    \ if the extension is greater than the class name \n                         \
    \       else if(extensions[i] > temp){\n                                    temp\
    \ = extensions[i];\n                                }\n                      \
    \      }\n                        }\n                    }\n                }\n\
    \            }\n            // Checking if extension is of length 4 \n       \
    \     if(extensions[i].length() == 4){\n                // Checking if the first\
    \ letter of extension matches the class name \n                if(class_name.at(0)\
    \ >= extensions[i].at(0) + 3){\n                    // Checking if the extension\
    \ has the second letter of extension \n                    if(extensions[i].at(1)\
    \ >= class_name.at(1) + 2){\n                        // Checking if the extension\
    \ has the third letter of extension \n                        if(extensions[i].at(2)\
    \ >= class_name.at(2) + 1){\n                            // Checking if the extension\
    \ is equal to the class name \n                            if(extensions[i] ==\
    \ class_name){\n                                temp = class_name;\n         \
    \                   }\n                            // Checking if the extension\
    \ is greater than the class name \n                            else if(extensions[i]\
    \ > temp){\n                                temp = extensions[i];\n          \
    \                  }\n                        }\n                    }\n     \
    \           }\n            }\n        }\n    }\n    if(max_extension > strongest_extension){\n\
    \        return temp;\n    }\n    return \"\";", "    int cap = 0;\n    int sm\
    \ = 0;\n    for (auto& e : extensions) \n    {\n        if (e.length() > cap)\
    \ {\n            cap = e.length();\n        }\n        if (e.length() < sm) {\n\
    \            sm = e.length();\n        }\n    }\n    int strongest_strength =\
    \ (cap - sm) / cap;\n    std::string strongest_name = \"\";\n    int len = extensions.size();\n\
    \    for (int i = 0; i < len; i++)\n    {\n        if (strongest_strength > extensions[i].size())\
    \ \n        {\n            strongest_strength = extensions[i].size();\n      \
    \      strongest_name = class_name + extensions[i];\n        }\n    }\n    return\
    \ strongest_name;", "  int cap_sum = 0;\n  int smp_sum = 0;\n  for (auto ext :\
    \ extensions) {\n    auto cap = ext.find_first_of('A');\n    auto sm = ext.find_first_of('L');\n\
    \    cap_sum += cap - sm + 1; // cap_sum is the number of uppercase letters in\
    \ class name\n    smp_sum += sm - 1; // smp_sum is the number of lowercase letters\
    \ in class name\n  }\n  int strong_ext = (cap_sum - smp_sum) / (cap_sum - 1);\n\
    \  auto it = std::min_element(extensions.begin(), extensions.end(),\n        \
    \                     [strong_ext](auto &ext1, auto &ext2) {\n               \
    \                  return std::stoi(ext1) > std::stoi(ext2);\n               \
    \              });\n  assert(it != extensions.end());\n  if (std::stoi(it->substr(0,\
    \ it->find_first_of('L')) ) == (strong_ext * (-1)) \n      || std::stoi(it->substr(0,\
    \ it->find_first_of('A')) ) == (strong_ext* (-1))) \n    return class_name + '.'\
    \ + std::to_string(strong_ext) + it->substr(it->find_first_of('L'));\n  else \n\
    \    return Strongest_Extension(class_name, extensions);", "    // Write your\
    \ code here\n    int cap = 0;\n    int sm = 0;\n    for (int i = 0; i < extensions.size();\
    \ ++i) {\n        for (int j = 0; j < extensions[i].size(); ++j) {\n         \
    \   if (extensions[i][j] == class_name[i])\n                cap++;\n         \
    \   if (extensions[i][j] == class_name[i])\n                sm++;\n        }\n\
    \    }\n    double cap_frac = cap - sm;\n    double strength = cap_frac * cap_frac;\n\
    \    if (strength > 0) {\n        for (int i = 0; i < extensions.size(); ++i)\
    \ {\n            for (int j = 0; j < extensions[i].size(); ++j) {\n          \
    \      if (extensions[i][j] == class_name[i])\n                    strength +=\
    \ cap - sm;\n            }\n        }\n    }\n    std::cout << class_name << \"\
    .\" << extensions.back() << \".\" << strength;", "    \n    for (int i = 0; i\
    \ < extensions.size(); i++) {\n        // Your code here\n    }", "  // Write\
    \ your code here\n  std::string res;\n  for (auto &ext : extensions) {\n    if\
    \ (ext.length() <= 0) {\n      continue;\n    }\n    auto cap = class_name.size();\n\
    \    auto sm = ext.size();\n    auto diff = cap - sm;\n    if (diff == 0) {\n\
    \      res = class_name + \".\" + ext;\n      continue;\n    }\n    auto f = (diff\
    \ * 2.0) / cap;\n    int c = fabs(f);\n    auto x = f / c;\n    if (fabs(x - f)\
    \ <= 0.01) {\n      continue;\n    }\n    int s = x - f * (c - 1);\n    if (s\
    \ >= 0) {\n      auto cap1 = cap - s;\n      auto sm1 = sm - s;\n      res = class_name\
    \ + \".\" + ext.substr(cap1, sm1);\n    } else {\n      auto cap2 = cap - s;\n\
    \      auto sm2 = sm + s;\n      res = class_name + \".\" + ext.substr(cap2, sm2);\n\
    \    }\n    \n  }\n  return res;", "  assert(extensions.size() != 0);\n  int num_cap_letters\
    \ = 0, num_lowercase_letters = 0;\n  for (int i = 0; i != extensions.size(); ++i)\
    \ {\n    char c = extensions[i];\n    if (c >= 'a' && c <= 'z') {\n      num_cap_letters++;\n\
    \    } else if (c >= 'A' && c <= 'Z') {\n      num_cap_letters++;\n    } else\
    \ {\n      num_lowercase_letters++;\n    }\n  }\n  int num_extensions = num_cap_letters\
    \ - num_lowercase_letters;\n  double extension_strength = (double) num_extensions\
    \ / extensions.size();\n  int max_strength_extension = -1;\n  for (int i = 0;\
    \ i != extensions.size(); ++i) {\n    char c = extensions[i];\n    if (c >= 'a'\
    \ && c <= 'z') {\n      double d = static_cast<double>(c - 'a');\n      if (d\
    \ > extension_strength) {\n        max_strength_extension = i;\n        extension_strength\
    \ = d;\n      }\n    } else if (c >= 'A' && c <= 'Z') {\n      double d = static_cast<double>(c\
    \ - 'A');\n      if (d > extension_strength) {\n        max_strength_extension\
    \ = i;\n        extension_strength = d;\n      }\n    }\n  }\n  if (max_strength_extension\
    \ != -1) {\n    std::string result = class_name + \".\" + extensions[max_strength_extension];\n\
    \    return result;\n  } else {\n    return class_name;\n  }", "    int cap_num\
    \ = 0, sm_num = 0;\n    for(int i = 0; i < extensions.size(); i++) {\n       \
    \ int s = extensions[i].size();\n        cap_num += (s - cap_num) * (s - cap_num);\n\
    \        sm_num += (s - sm_num) * (s - sm_num);\n    }\n    double cap_denom =\
    \ cap_num * cap_num;\n    double sm_denom = sm_num * sm_num;\n    double strength\
    \ = cap_num - sm_num;\n    for(int i = 0; i < extensions.size(); i++) {\n    \
    \    std::string extension = extensions[i];\n        double num_chars = (extension.size()\
    \ - cap_num) * (extension.size() - sm_num);\n        strength += num_chars * (num_chars\
    \ / cap_denom);\n    }\n    if(strength > 0) {\n        strength /= extensions.size();\n\
    \    } else {\n        strength = -1;\n    }\n    return class_name + \".\" +\
    \ extensions[0];", "    // Write your code here\n    int sm = 0, cap = 0, strength;\n\
    \    for(int i = 0; i < extensions.size(); i++) {\n        std::string ext = extensions[i];\n\
    \        cap = cap - ext.length();\n        sm = sm + ext.length();\n        strength\
    \ = cap - sm;\n    }\n    strength = cap / sm;\n    for(int i = 0; i < extensions.size();\
    \ i++) {\n        std::string ext = extensions[i];\n        cap = cap - ext.length();\n\
    \        sm = sm + ext.length();\n        strength = cap - sm;\n    }\n    strength\
    \ = cap / sm;\n    for(int i = 0; i < extensions.size(); i++) {\n        std::string\
    \ ext = extensions[i];\n        cap = cap - ext.length();\n        sm = sm + ext.length();\n\
    \        strength = cap - sm;\n    }\n    strength = cap / sm;\n    if(strength\
    \ == 0) \n        return \"Slices\";\n    else \n        return class_name + extensions[0];",
  "    // Write your code here\n    std::string strength = \"\";\n    for (std::string\
    \ ext : extensions)\n    {\n        int cap = ext.size();\n        int sm = ext.size();\n\
    \        for (char &c: ext)\n        {\n            if (isupper(c))\n        \
    \        cap--;\n            else\n                sm--;\n        }\n        std::cout\
    \ << cap << \" - \" << sm << std::endl;\n    }\n    return \"\";", "    int counter\
    \ = 0;\n    std::string best_extension;\n    for(size_t i = 0; i < extensions.size();\
    \ i++){\n        if(class_name.compare(extensions[i]) == 0){\n            counter++;\n\
    \            if(counter > best_extension.size()) best_extension = extensions[i];\n\
    \        }\n    }\n    if(counter == 0) return \"Unnamed\";\n    if(counter >\
    \ 0) return class_name + \".\" + best_extension;\n    return \"Unnamed\";", " \
    \   \n    // Write your code here\n    \n    return \"\";", "  // Write your code\
    \ here\n    int n = extensions.size();\n    int c = 0;\n    std::vector<int> h(n\
    \ + 1, 1);\n    for (auto i : extensions) {\n      if (h[i] > 1){\n        c =\
    \ 1;\n        break;\n      }\n      else {\n        c = c * (int)((int)i-'A'+1);\n\
    \      }\n    }\n    h = h - c; \n    \n    while(n > 1){\n      h[n] = h[n-1];\n\
    \      n--;\n    }\n    std::string res = class_name + extensions[h[n]];\n   \
    \ return res;", "    int CAP = 0;\n    int SM = 0;\n    for(const auto &ext :\
    \ extensions) {\n        CAP += ext.size();\n        SM = ext.size();\n    }\n\
    \    std::string ext_name = class_name + '.';\n    int strength = CAP - SM;\n\
    \    int index;\n    for(index = 0; index < extensions.size(); ++index) {\n  \
    \      std::string extn = class_name + '.' + extensions[index];\n        if(strength\
    \ == CAP - ext.size()) {\n            return ext_name + extensions[index];\n \
    \       }\n        else if(strength > CAP - ext.size()) {\n            return\
    \ ext_name + extensions[index];\n        }\n    }\n    \n    throw std::runtime_error(\"\
    No strongest extension exists with given parameters.\");", "    // initialize\
    \ a map to store all possible extensions\n    std::map<std::string, int> extensions_map;\n\
    \    for (auto &extension : extensions) {\n        extensions_map[extension] =\
    \ 1;\n    }\n    // initialize max and min extensions\n    int max_extension =\
    \ 0, min_extension = 0;\n    for (auto &extension : extensions) {\n        int\
    \ current_extension = extensions_map.at(extension);\n        if (current_extension\
    \ > max_extension) {\n            max_extension = current_extension;\n       \
    \ }\n        if (current_extension < min_extension) {\n            min_extension\
    \ = current_extension;\n        }\n    }\n    // compute Strongest extension\n\
    \    int strongest_extension = 0;\n    if (max_extension - min_extension > 0)\
    \ {\n        strongest_extension = (max_extension - min_extension) / 2;\n    }\n\
    \    // return the class\n    return class_name + \".\" + extensions[strongest_extension];",
  "    std::string result;\n    double cap_counter{0};\n    double sm_counter{0};\n\
    \    for (auto&& ext : extensions) {\n        auto cap = ext.find_first_of('A');\n\
    \        auto sm = ext.find_first_of('z');\n        if (cap == std::string::npos\
    \ || sm == std::string::npos) {\n            std::cout << \"Empty extension detected!\"\
    \ << std::endl;\n            return class_name + ext;\n        }\n        if (cap\
    \ != -1 && sm != -1) {\n            cap_counter++;\n            sm_counter++;\n\
    \        }\n    }\n    if (cap_counter == 0 || sm_counter == 0){\n        std::cout\
    \ << \"Empty extension detected!\" << std::endl;\n        return class_name;\n\
    \    }\n    double strength_counter = cap_counter - sm_counter;\n    if (strength_counter\
    \ < 0){\n        std::cout << \"Extension name not unique\" << std::endl;\n  \
    \      return class_name + extensions[0];\n    }\n    double strength = strength_counter\
    \ / cap_counter;\n    if (strength == 0){\n        std::cout << \"Extension name\
    \ not unique\" << std::endl;\n        return class_name + extensions[0];\n   \
    \ }\n    std::cout << \"Class name: \" << class_name << std::endl;\n    double\
    \ max_strength = -1;\n    for (auto&& ext : extensions) {\n        auto cap =\
    \ ext.find_first_of('A');\n        auto sm = ext.find_first_of('z');\n       \
    \ if (cap == std::string::npos || sm == std::string::npos) {\n            std::cout\
    \ << \"Empty extension detected!\" << std::endl;\n            return class_name\
    \ + ext;\n        }\n        if (cap != -1 && sm != -1) {\n            if (cap\
    \ > sm || cap < sm_counter || sm > cap_counter) {\n                std::cout <<\
    \ \"Extension name not unique\" << std::endl;\n                return class_name\
    \ + ext;\n            }\n            if (cap > max_strength){\n              \
    \  result = class_name + ext;\n                max_strength = cap;\n         \
    \   }\n        }\n    }\n    std::cout << \"Extension name: \" << result << std::endl;\n\
    \    return result;", "\t// your code goes here\n\tstd::sort(extensions.begin(),\
    \ extensions.end(), \n\t\t\t\t[](std::string a, std::string b){\n\t\t\t\t\treturn\
    \ std::stoi(a) > std::stoi(b);\n\t\t\t\t}\n\t);\n\tstd::string res = class_name;\n\
    \tint cap = 0;\n\tint sm = 0;\n\tfor (const auto &ext : extensions)\n\t{\n\t\t\
    cap = std::max(cap, std::count(ext.begin(), ext.end(), std::toupper(ext.at(0))));\n\
    \t\tsm = std::max(sm, std::count(ext.begin(), ext.end(), std::tolower(ext.at(0))));\n\
    \t}\n\tstd::string ans = res;\n\tif (cap > sm)\n\t{\n\t\tfor (const auto &ext\
    \ : extensions)\n\t\t{\n\t\t\tif (cap - sm == std::stoi(ext))\n\t\t\t{\n\t\t\t\
    \tans += \".\" + ext;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;", " \
    \   // your code goes here\n    std::string classname = class_name; //use name\
    \ to check if it is a class name\n    std::string temp;\n    int cap = 0, sm =\
    \ 0; //caps means how many uppercase letters there are\n    for(auto e : extensions)\
    \ {\n        temp = e;\n        for(int i = 0; i < temp.length(); i++) {\n   \
    \         if(std::toupper(temp.at(i)) != temp.at(i)) { //check if it is uppercase\
    \ letter\n                cap++;\n            }\n            else {\n        \
    \        sm++;\n            }\n        }\n    }\n    if(cap - sm == 0) { //check\
    \ if all letters are lowercase\n        return class_name; //return original string\n\
    \    }\n    else {\n        std::string final_name;\n        final_name = className\
    \ + \".\" + extensions[cap - sm]; //return classname with strongest extension\n\
    \        return final_name; //return final name\n    }", "    std::string strongest_ext;\n\
    \    std::sort(extensions.begin(), extensions.end());\n    for (auto it = extensions.begin();\
    \ it != extensions.end(); ++it) {\n        std::string ext_name = class_name +\
    \ '.' + std::toupper(*it) + std::tolower(*(++it));\n        std::transform(ext_name.begin(),\
    \ ext_name.end(), ext_name.begin(), ::tolower);\n        if (extensions.end()\
    \ == std::find(extensions.begin(), extensions.end(), ext_name)) {\n          \
    \  strongest_ext = ext_name;\n        }\n    }\n    return strongest_ext;", " \
    \   assert(class_name.size() > 0);\n    assert(extensions.size() > 0);\n    std::map<int,\
    \ int> ext_map;\n    for (auto &ex : extensions) {\n        std::string ext =\
    \ ex.substr(0, ex.length() - 1);\n        auto it = ext_map.find(ext.size());\n\
    \        if (it != ext_map.end()) {\n            ext_map[ext.size()] += 1;\n \
    \       } else {\n            ext_map.insert({ext.size(), 1});\n        }\n  \
    \  }\n    int max = 0;\n    for (auto &it : ext_map) {\n        if (it.second\
    \ > max) {\n            max = it.second;\n        }\n    }\n    int sum = 0;\n\
    \    for (auto &it : ext_map) {\n        sum += it.second;\n    }\n    if (sum\
    \ == 0) {\n        return class_name;\n    }\n    int cap = class_name.size();\n\
    \    int sm = class_name.size() - cap;\n    for (auto &it : ext_map) {\n     \
    \   if (it.second == max) {\n            return class_name + it.first + (cap -\
    \ sm);\n        }\n    }\n    return class_name;", "    int cap_num = 0, sm_num\
    \ = 0;\n    for (auto &ext : extensions) {\n        int cap_num = cap_num * 10\
    \ + (ext.at(0) >= 'A' ? ext.at(0) : 'A' - 10);\n        int sm_num = sm_num *\
    \ 10 + (ext.at(0) >= 'a' ? ext.at(0) : 'a' - 10);\n    }\n    return class_name.substr(0,\
    \ class_name.size() - cap_num - sm_num) + std::to_string(extensions.size() * -1)\
    \ + \".\" + extensions[extensions.size()-1];", "    \n    // Initialize a map\
    \ for extensions\n    std::map<std::string, int> extension_map;\n    \n    //\
    \ Initialize map with extension names and initial strength\n    for (auto &ext\
    \ : extensions) {\n        extension_map[ext] = 0;\n    }\n    \n    // Sort extensions\
    \ by their strength\n    std::sort(extensions.begin(), extensions.end(), [](std::string\
    \ a, std::string b) {\n        return extension_map[a] - extension_map[b];\n \
    \   });\n    \n    // Initialize a variable for holding the strongest extension\n\
    \    std::string strongest_ext;\n    \n    // If the first extension is stronger\
    \ than the second, set the strongest \n    // extension to be the first one\n\
    \    if (extension_map.at(extensions[0]) > extension_map.at(extensions[1])) {\n\
    \        strongest_ext = extensions[0];\n    }\n    \n    // Otherwise, iterate\
    \ through the sorted extensions, and for each extension \n    // that is stronger\
    \ set the strongest extension to be the first one\n    else {\n        for (auto\
    \ &ext : extensions) {\n            if (extension_map[ext] > extension_map[strongest_ext])\
    \ {\n                strongest_ext = ext;\n            }\n        }\n    }\n \
    \   return class_name + \".\" + strongest_ext;", "\tint cap = class_name.size();\n\
    \tint sm = extensions.size();\n\tdouble strongest = 0.0;\n\tstd::string extension\
    \ = extensions[0];\n\tfor (int i = 0; i < sm; i++) {\n\t\tdouble temp = (double)cap\
    \ - (double)sm;\n\t\tif (temp > strongest) {\n\t\t\tstrongest = temp;\n\t\t\t\
    extension = extensions[i];\n\t\t}\n\t}\n\treturn class_name + \".\" + extension;",
  "\tint cap = class_name.length();\n\tint sm = class_name.find_first_of(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n\tint score = cap - sm;\n\tfor (auto ext : extensions) {\n\t\tint ex = ext.length();\n\
    \t\tint sx = ext.find_first_of(\"abcdefghijklmnopqrstuvwxyz\");\n\t\tscore +=\
    \ ex - sx;\n\t}\n\tstd::sort(extensions.begin(), extensions.end(), [score](std::string\
    \ a, std::string b) { return std::streamoff(a) - std::streamoff(b) < 0; });\n\t\
    return class_name + \".\" + extensions[0];", "\tstd::string ans = class_name;\n\
    \tint cap = std::count_if(extensions.begin(), extensions.end(), [](char x){ return\
    \ std::isupper(x); }) / extensions.size();\n\tint sm = std::count_if(extensions.begin(),\
    \ extensions.end(), [](char x){ return std::islower(x); }) / extensions.size();\n\
    \tint s = cap - sm;\n\tfor (auto e : extensions) {\n\t\tif (std::isupper(e))\n\
    \t\t\tcap -= std::islower(e);\n\t\telse if (std::islower(e))\n\t\t\tsm += std::isupper(e);\n\
    \t}\n\tint s = cap - sm;\n\tif (s == 0) {\n\t\tans = ans + \"A\";\n\t} else if\
    \ (s == 1)\n\t\tans = ans + \"B\";\n\telse if (s >= 2) {\n\t\tint i = 1;\n\t\t\
    for (auto e : extensions) {\n\t\t\tif (std::isupper(e))\n\t\t\t\tcap -= std::islower(e);\n\
    \t\t\telse if (std::islower(e))\n\t\t\t\tsm += std::isupper(e);\n\t\t\tif (i ==\
    \ 2)\n\t\t\t\tans = ans + \"C\";\n\t\t\telse if (i == 1)\n\t\t\t\tans = ans +\
    \ \"D\";\n\t\t\telse if (i == 3)\n\t\t\t\tans = ans + \"E\";\n\t\t\ti++;\n\t\t\
    }\n\t}\n\treturn ans;", "    // Write your code here\n    std::vector<std::pair<int,\
    \ std::string>> sorted_vec;\n    for (auto &ext : extensions) {\n        std::transform(ext.begin(),\
    \ ext.end(), ext.begin(), ::toupper);\n        std::transform(ext.begin(), ext.end(),\
    \ ext.begin(), ::tolower);\n        std::transform(ext.begin(), ext.end(), ext.begin(),\
    \ ::tolower);\n        sorted_vec.emplace_back(ext.size(), ext);\n    }\n    \n\
    \    std::sort(sorted_vec.begin(), sorted_vec.end(), \n        [](const std::pair<int,\
    \ std::string> &a,\n           const std::pair<int, std::string> &b) {\n     \
    \       return a.first < b.first;\n        });\n    \n    int last_strongest =\
    \ -1;\n    std::string strongest;\n    for (auto &ext : sorted_vec) {\n      \
    \  if (ext.first != last_strongest) {\n            last_strongest = ext.first;\n\
    \            strongest = class_name + ext.second;\n        }\n    }\n    return\
    \ strongest;", '  // write your code here', "\tint sum = 0;\n\tint cap = 0;\n\t\
    int sm = 0;\n\tint n = 0;\n\tfor(auto it = extensions.begin(); it != extensions.end();\
    \ ++it) {\n\t\tsum += (std::toupper(*it) - std::toupper(class_name.at(n))) * 1;\n\
    \t\tcap += *it;\n\t\tsm = std::count(class_name.begin() + n, class_name.end(),\
    \ *it);\n\t\tn++;\n\t}\n\tint d = cap - sm;\n\td = std::min<int>(1, d);\n\treturn\
    \ class_name + '.' + std::to_string(sum / d);", "    // Your code here\n    int\
    \ SM;\n    for (size_t i = 0; i < extensions.size(); i++) {\n        for (size_t\
    \ j = 0; j < extensions.size(); j++) {\n            SM = std::count_if(extensions.begin(),\
    \ extensions.end(), \n            [&extensions](const std::string& e) {return\
    \ (e == extensions[i]) ? 1 : 0;});\n            assert(SM == 0);\n        }\n\
    \    }\n    int CAP = static_cast<int>(class_name.size()) - static_cast<int>(extensions[0].size());\n\
    \    return class_name + extensions[CAP];", "\tauto c = class_name.size();\n\t\
    auto s = extensions.size();\n\tassert(c > 0);\n\tassert(s > 0);\n\tint m = 1;\n\
    \tint n = 1;\n\tfor (int i = 0; i < s; ++i) {\n\t\tfor (int j = i + 1; j < s;\
    \ ++j) {\n\t\t\tint a = (class_name[i] >= class_name[j]) ? 1 : 0;\n\t\t\tint b\
    \ = (class_name[i] <= class_name[j]) ? 1 : 0;\n\t\t\tint c = (a * b);\n\t\t\t\
    if (c > m) {\n\t\t\t\tm = c;\n\t\t\t}\n\t\t\tn = max(n, m);\n\t\t}\n\t}\n\tchar\
    \ c[128];\n\tsnprintf(c, 128, \"%s.%s\", class_name.c_str(), extensions[n - 1]);\n\
    \treturn c;", "  std::vector<std::string> sorted_extensions;\n  sorted_extensions\
    \ = extensions;\n  for (int i = 0; i < extensions.size(); i++) {\n    sorted_extensions.push_back(extensions[i]);\n\
    \  }\n  sorted_extensions.sort([&](std::string a, std::string b) { return b[0]\
    \ - a[0]; });\n  std::string strongest_extension = sorted_extensions[0] + \".\"\
    \ + class_name;\n  for (int i = 1; i < sorted_extensions.size(); i++) {\n    if\
    \ (sorted_extensions[i][0] != sorted_extensions[i - 1][0])\n      break;\n   \
    \ strongest_extension += \".\" + sorted_extensions[i];\n  }\n  return strongest_extension;",
  "    std::string best_extension = \"\";\n    float best_strength = std::numeric_limits<float>::max();\n\
    \    for (auto e : extensions) {\n        float s = std::stof(e);\n        if\
    \ (s > best_strength) {\n            best_strength = s;\n            best_extension\
    \ = e;\n        }\n    }\n    return class_name + \".\" + best_extension;", " \
    \   // Your code goes here\n    float strength;\n    int cap_counter, sb_counter;\n\
    \    for (size_t i = 0; i < extensions.size(); i++) {\n        if (class_name[i]\
    \ == cap_counter) {\n            strength = cap_counter - sb_counter;\n      \
    \  } else if (class_name[i] == sb_counter) {\n            strength = sb_counter\
    \ - cap_counter;\n        } else {\n            assert(0);\n        }\n      \
    \  if ((cap_counter > sb_counter) && (cap_counter > 0)) {\n            cap_counter++;\n\
    \        } else {\n            cap_counter = 0;\n            sb_counter++;\n \
    \       }\n    }\n    return class_name + \".\" + extensions[strength];", "  \
    \  // code here\n    int cap = 0, sm = 0;\n    for(auto &ext : extensions){\n\
    \        if (ext.size()>cap){\n            cap = ext.size();\n        }\n    \
    \    for(auto &c : ext){\n            if (c>sm){\n                sm = c;\n  \
    \          }\n        }\n    }\n    std::string result = class_name;\n    for(int\
    \ i=0; i<cap; ++i){\n        result += \".\" + extensions[i];\n    }\n    for(int\
    \ i=0; i<sm; ++i){\n        result += \".\" + extensions[i];\n    }\n    return\
    \ result;", "    // Your code here\n    int C=0;\n    int S=0;\n    for (int i=0;i<extensions.size();i++)\n\
    \    {\n        int count=0;\n        for (int j=i;j<extensions.size();j++)\n\
    \        {\n            count++;\n            char x=extensions[j];\n        \
    \    if (x>='A' && x<='Z')\n            {\n                count++;\n        \
    \    }\n            else if (x>='a' && x<='z')\n            {\n              \
    \  count++;\n            }\n            else\n            {\n                count--;\n\
    \            }\n        }\n        C=C+count;\n        S+=count-i;\n    }\n  \
    \  int cap=strlen(class_name.c_str())-C;\n    int sm=strlen(class_name.c_str())-S;\n\
    \    return class_name.c_str() + \".\" +extensions[(int)(C/(cap-sm))].c_str();",
  "    assert(extensions.size() > 0);\n    // Use this variable to keep track of what\
    \ was the best extension so far\n    std::string best_extension = extensions[0];\n\
    \    int best_strength = -1;\n    for (int i = 1; i < extensions.size(); i++)\
    \ {\n        int extension_strength = std::count(class_name.begin(), class_name.end(),\
    \ \n                                           extensions[i].at(0)) - \n     \
    \                                std::count(class_name.begin(), class_name.end(),\
    \ \n                                           extensions[i].at(1) - 'A');\n \
    \       if (best_strength < 0 || best_strength > extension_strength) {\n     \
    \       best_strength = extension_strength;\n            best_extension = extensions[i];\n\
    \        }\n    }\n    return best_extension;", "    std::string class_name_with_strength\
    \ = class_name + '.';\n    std::string strongest_extension;\n    int max_strength_found\
    \ = 0, max_strength = -1;\n\n    for (int i = 0; i < extensions.size(); i++) {\n\
    \        int extension_strength = 0;\n        for (int j = i; j < extensions.size();\
    \ j++) {\n            if (class_name[j] == extensions[i][j]) {\n             \
    \   extension_strength++;\n            }\n        }\n        if (extension_strength\
    \ > max_strength) {\n            strongest_extension = class_name_with_strength\
    \ + extensions[i];\n            max_strength = extension_strength;\n        }\n\
    \        if (extension_strength == max_strength && extension_strength > max_strength_found)\
    \ {\n            max_strength_found = extension_strength;\n        }\n    }\n\
    \    if (max_strength_found > -1) {\n        for (int i = max_strength_found;\
    \ i < extensions.size(); i++) {\n            strongest_extension = class_name_with_strength\
    \ + extensions[i];\n        }\n    }\n\n    return strongest_extension;", "  std::vector<std::string>::iterator\
    \ itr = std::max_element(extensions.begin(), extensions.end(), [](const std::string&\
    \ e1, const std::string& e2) { return std::stoi(e1) - std::stoi(e2); });\n\n \
    \ if (itr == extensions.end()) {\n    throw std::invalid_argument(\"The extensions\
    \ must be numberic!\");\n  }\n\n  int cap = std::distance(extensions.begin(),\
    \ itr);\n  int sm = cap - std::count_if(extensions.begin(), extensions.end(),\
    \ [](const std::string& e) { return std::toupper(e) == e; });\n\n  return class_name\
    \ + \".\" + itr->substr(0, sm + 1); // + 1 is to remove \".\"", "    assert(extensions.size()\
    \ >= 2);\n    auto start = std::min_element(extensions.begin(), extensions.end())\
    \ - extensions.begin();\n    auto end = std::max_element(extensions.begin(), extensions.end())\
    \ - extensions.begin();\n    return class_name + \".\" + extensions[start]; ",
  "  int cap;\n  int sm;\n  int strongest_extension = 0;\n  float min_extension_strength;\n\
    \  \n  cap = std::count_if(extensions.begin(), extensions.end(), [] (char x) {\n\
    \    return (x >= 'A' && x <= 'Z');\n  });\n  sm = std::count_if(extensions.begin(),\
    \ extensions.end(), [] (char x) {\n    return (x >= 'a' && x <= 'z');\n  });\n\
    \  min_extension_strength = (float) cap / sm;\n  for (int i = 0; i < extensions.size();\
    \ i++) {\n    int len = extensions[i].length();\n    int new_strongest_extension\
    \ = std::count_if(extensions.begin() + i + 1, extensions.end(), [] (char x) {\n\
    \      return (x >= 'A' && x <= 'Z');\n    }) / len;\n    if (new_strongest_extension\
    \ > strongest_extension) {\n      strongest_extension = new_strongest_extension;\n\
    \    }\n  }\n  \n  if (strongest_extension == 0) {\n    return class_name + \"\
    .\" + extensions[0];\n  } else if (strongest_extension == 1) {\n    return class_name\
    \ + \".\" + extensions[0];\n  } else if (strongest_extension == 2) {\n    return\
    \ class_name + \".\" + extensions[0];\n  } else if (strongest_extension == 3)\
    \ {\n    return class_name + \".\" + extensions[0];\n  } else if (strongest_extension\
    \ > 3) {\n    return class_name + \".\" + extensions[0];\n  }", "    \n    //\
    \ Your code here\n    int cap = 0;\n    int sm = 0;\n    \n    for (int i = 0;\
    \ i < extensions.size(); i++)\n    {\n        if (class_name[0] == extensions[i][0])\n\
    \        {\n            cap += 1;\n        }\n        if (class_name[1] == extensions[i][0])\n\
    \        {\n            sm += 1;\n        }\n    }\n    assert(cap + sm == class_name.size());\n\
    \    \n    if (cap - sm > 0)\n    {\n        return class_name.substr(0, class_name.size()\
    \ - 1) + \"Extension\" + extensions[0];\n    }\n    else\n    {\n        return\
    \ class_name.substr(0, class_name.size() - 1) + \"Extension\" + extensions[1];\n\
    \    }", "\tint capitals, lowers, i, strength;\n\tstd::string name;\n\t\n\tname\
    \ = class_name;\n\t\n\tfor (i = 0; i < extensions.size(); i++) {\n\t\tlowers =\
    \ 0;\n\t\tcapitals = 0;\n\t\t\n\t\tstd::string temp1 = extensions[i];\n\t\t\n\t\
    \tfor (char c : temp1) {\n\t\t\tif (isupper(c)) {\n\t\t\t\tcapitals++;\n\t\t\t\
    }\n\t\t\t\n\t\t\tif (islower(c)) {\n\t\t\t\tlowers++;\n\t\t\t}\n\t\t}\n\t\t\n\t\
    \tstrength = capitals - lowers;\n\t\t\n\t\tif (strength > 0) {\n\t\t\tname +=\
    \ temp1 + \".\";\n\t\t\tname += extensions[i];\n\t\t\t\n\t\t\tif (i == extensions.size()\
    \ - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn name;", "    std::string\
    \ result = \"\";\n    size_t cap = 0;\n    size_t sm = 0;\n    for (auto e : extensions)\
    \ {\n        cap += static_cast<size_t>(e.size());\n        sm += static_cast<size_t>(e.size());\n\
    \    }\n    if (cap > sm) return class_name + extensions[0];\n    for (auto e\
    \ : extensions) {\n        cap -= static_cast<size_t>(e.size());\n        sm -=\
    \ static_cast<size_t>(e.size());\n        if (cap > sm) {\n            return\
    \ class_name + e;\n        }\n    }\n    throw std::runtime_error(\"There is not\
    \ any extension with the given strength.\");", "  std::sort(extensions.begin(),\
    \ extensions.end()); \n  int cap = class_name.size(), sm = 0;\n  for (auto& e\
    \ : extensions) {\n    if (e == std::toupper(std::tolower(e))) { cap++; sm +=\
    \ std::toupper(std::tolower(e)).size(); }\n    else { sm--; }\n  }\n  return class_name.substr(0,\
    \ cap - sm) + \".\" + extensions[0];", "    int capacity = 0;\n    int sm = 0;\n\
    \    \n    for (auto x : extensions) {\n        std::string ext = x;\n       \
    \ \n        int cap = ext.length();\n        int sm = cap - cap;\n        \n \
    \       capacity += cap;\n        sm += sm;\n    }\n    \n    std::string result\
    \ = class_name;\n    \n    if (capacity == sm) {\n        result += \"S\";\n \
    \   } else if (capacity > sm) {\n        result += \"C\";\n    } else if (capacity\
    \ == 0) {\n        result += \"F\";\n    }\n    \n    for (auto ext : extensions)\
    \ {\n        result += \".\" + ext;\n    }\n    \n    return result;", "  // Initialize\
    \ an array with the possible extensions\n  std::string ret(class_name + \".\"\
    );\n  std::vector<std::string> candidates(extensions);\n\n  // Find the extension\
    \ with the highest strongest strength\n  int max_strength = 0;\n  std::string\
    \ strongest = \"\";\n  for (int i = 0; i < candidates.size(); ++i) {\n    int\
    \ str = count(begin(candidates[i]), end(candidates[i]), toupper);\n    if (str\
    \ > max_strength) {\n      max_strength = str;\n      strongest = candidates[i];\n\
    \    }\n  }\n\n  // Append the strongest extension to the return string\n  ret.append(strongest);\n\
    \n  // Append the rest of extensions\n  for (int i = 0; i < candidates.size();\
    \ ++i) {\n    if (candidates[i] != strongest && !ret.length()) {\n      ret.append(candidates[i]);\n\
    \    }\n  }\n\n  return ret;", "    \n    std::vector<int> capitals, smalls;\n\
    \    capitals.reserve(extensions.size());\n    smalls.reserve(extensions.size());\n\
    \    std::string ans = \"\";\n    \n    for (auto & ext : extensions) {\n    \
    \    capitals.push_back(ext.find_first_of('A'));\n        smalls.push_back(ext.find_first_of('a'));\n\
    \    }\n    \n    size_t cap_pos = 0;\n    size_t sm_pos = 0;\n    size_t ext_pos\
    \ = 0;\n    \n    while (ext_pos < extensions.size()) { \n        cap_pos = capitals.at(ext_pos);\n\
    \        sm_pos = smalls.at(ext_pos);\n        \n        if (cap_pos < sm_pos)\
    \ {\n            cap_pos++;\n            ext_pos++;\n        }\n        else if\
    \ (cap_pos > sm_pos) {\n            cap_pos--;\n            ext_pos++;\n     \
    \   }\n        else if (cap_pos == sm_pos) {\n            cap_pos++;\n       \
    \     ext_pos++;\n        }\n        \n        ans += class_name + \".\" + extensions[ext_pos];\n\
    \    }\n    \n    return ans;", "    size_t SM = class_name.size();\n    size_t\
    \ CAP = class_name.size(); // Capital letter CAP\n    assert(CAP > SM);\n    //\
    \ Find Smallest extension SM\n    std::string smallest_extension = \"\";\n   \
    \ size_t smallest_extension_strength = CAP - SM;\n    for (size_t i = 0; i < extensions.size();\
    \ i++) {\n        size_t temp_class = extensions[i].size();\n        size_t temp_extension\
    \ = extensions[i].size();\n        assert(temp_extension > temp_class);\n    \
    \    temp_extension -= temp_class;\n        if (temp_extension < smallest_extension_strength)\
    \ {\n            smallest_extension = extensions[i];\n            smallest_extension_strength\
    \ = temp_extension;\n        }\n    }\n    // Find Strongest extension\n    size_t\
    \ strongest_extension_strength = smallest_extension_strength;\n    while (smallest_extension.find(smallest_extension_strength\
    \ - 1) != std::string::npos) {\n        strongest_extension_strength--;\n    }\n\
    \    std::string strongest_extension = class_name + \".\" + smallest_extension;\n\
    \    return strongest_extension;", "    \n    // Initialize max and min to -1\n\
    \    int max = 0;\n    int min = (int)extensions.size();\n    \n    // Find the\
    \ strongest extension\n    for (auto i : extensions) {\n        int count = 1;\n\
    \        for (auto j : extensions) {\n            if (i != j && i == class_name+j)\
    \ {\n                count++;\n            }\n        }\n        if (count > max)\
    \ {\n            max = count;\n        }\n    }\n    \n    // If there are two\
    \ or more extensions with the same strength return the \n    // first one which\
    \ comes first in the list\n    if (max > min) {\n        return class_name+extensions[min];\n\
    \    }\n    // If there are two or more extensions with the same strength return\
    \ the \n    // last one which comes first in the list\n    if (max == min) {\n\
    \        return class_name+extensions[max-1];\n    }\n    // If no two or more\
    \ extensions have the same strength return the \n    // one which comes last in\
    \ the list\n    return class_name+extensions[max];", "    typedef std::vector\
    \ <std::string> string_vector;\n    typedef std::vector <char> char_vector;\n\n\
    \    // Create a map that will associate letters to their number:\n    std::map\
    \ <char, int> letter_to_number; // Create a map that will store letters and their\
    \ number\n    \n    // This loop will go through the first element in the vector,\
    \ namely the\n    // class name, and insert each letter in the vector into the\
    \ map:\n    for (char letter: class_name[0]) {\n        letter_to_number.insert(std::pair<char,\
    \ int> (letter, 1));\n    }\n    \n    // This loop will go through the rest of\
    \ the vector and insert each of the\n    // letters in the vector into the map:\n\
    \    for (int i = 1; i < class_name.size(); i++) {\n        for (char letter:\
    \ class_name[i]) {\n            letter_to_number.insert(std::pair<char, int> (letter,\
    \ 1));\n        }\n    }\n    \n    // The map now contains pairs of the letter\
    \ and their number from the\n    // class name and the extensions that extend\
    \ those letters:\n    string_vector extentions_name_and_number;\n    \n    //\
    \ This loop will go through the extensions and insert each of the letters in\n\
    \    // the vector into the map: \n    for (int i = 0; i < extensions.size() -\
    \ 1; i++) {\n        for (char letter: extensions[i]) {\n            letter_to_number.insert(std::pair<char,\
    \ int> (letter, 1));\n        }\n    }\n    \n    // This loop will go through\
    \ the extensions and insert each of the letters in\n    // the vector into the\
    \ map:\n    for (int i = extensions.size() - 1; i < extensions.size(); i++) {\n\
    \        for (char letter: extensions[i]) {\n            letter_to_number.insert(std::pair<char,\
    \ int> (letter, 1));\n        }\n    }\n    \n    // This loop will go through\
    \ the extensions and insert each of the letters in\n    // the vector into the\
    \ map:\n    for (int i = 0; i < extensions.size(); i++) {\n        for (char letter:\
    \ extensions[i]) {\n            letter_to_number.insert(std::pair<char, int> (letter,\
    \ 1));\n        }\n    }\n    \n    // This loop will go through the extensions\
    \ and insert each of the letters in\n    // the vector into the map:\n    for\
    \ (int i = 0; i <= extensions.size() - 1; i++) {\n        for (char letter: extensions[i])\
    \ {\n            letter_to_number.insert(std::pair<char, int> (letter, 1));\n\
    \        }\n    }\n    \n    // This loop will go through the extensions and insert\
    \ each of the letters in\n    // the vector into the map:\n    for (int i = 0;\
    \ i < extensions.size(); i++) {\n        for (char letter: extensions[i]) {\n\
    \            letter_to_number.insert(std::pair<char, int> (letter, 1));\n    \
    \    }\n    }\n    \n    // This loop will go through the extensions and insert\
    \ each of the letters in\n    // the vector into the map:\n    for (int i = 0;\
    \ i <= ", "    assert(class_name.size() <= 5);\n    assert(extensions.size() >\
    \ 1);\n    int cap_letters = 0, sm_letters = 0;\n    for (auto & ext : extensions)\
    \ {\n        cap_letters += ext.size() / 2; // CAP = number of letters in extension\n\
    \        sm_letters += ext.size(); // SM = number of letters in extension name\n\
    \    }\n    \n    double strength = 1;\n    bool has_smaller_letters = false;\n\
    \    for (auto & ext : extensions) {\n        double ext = ext.size();\n     \
    \   double cap = ext.size() / 2; // CAP = number of letters in extension\n   \
    \     double sm = ext.size(); // SM = number of letters in extension name\n  \
    \      if (sm < sm_letters) // check if extension is in lowercase letters\n  \
    \          has_smaller_letters = true;\n        \n        double fraction = cap\
    \ - sm;\n        if (fraction < 0) // check if extension has negative strength\n\
    \            has_smaller_letters = true;\n        \n        strength *= fraction;\n\
    \    }\n    \n    if (has_smaller_letters) {\n        double fraction = cap_letters\
    \ - sm_letters;\n        if (fraction < 0) // check if there are negative letters\n\
    \            has_smaller_letters = true;\n        \n        strength *= fraction;\n\
    \    }\n    \n    double max_strength = 1;\n    for (auto & ext : extensions)\
    \ {\n        double ext = ext.size();\n        double cap = ext.size() / 2; //\
    \ CAP = number of letters in extension\n        double sm = ext.size(); // SM\
    \ = number of letters in extension name\n        double fraction = cap - sm;\n\
    \        if (fraction > max_strength)\n            max_strength = fraction;\n\
    \    }\n    \n    return class_name + std::string(class_name.size() - 5, ' ')\
    \ + std::to_string(strength) + 'A';", "    std::sort(extensions.begin(), extensions.end());\
    \ //sort extensions from small to large string\n    int cap = std::count(class_name.begin(),\
    \ class_name.end(), 'A'); //count cap\n    int sm = std::count(class_name.begin(),\
    \ class_name.end(), 'a'); //count sm\n    int frac = cap - sm;\n    int strongest\
    \ = -1;\n    std::string strongest_extension = \"\";\n    for (auto &e: extensions)\
    \ { //loop through all extension\n        if (frac > cap - std::count(e.begin(),\
    \ e.end(), 'A') - std::count(e.begin(), e.end(), 'a')) { //if frac > SM + CAP\n\
    \            strongest = frac / (cap - std::count(e.begin(), e.end(), 'A') - std::count(e.begin(),\
    \ e.end(), 'a')); //strongest extension \n            strongest_extension = class_name\
    \ + \".\" + e; //use strongest extension to create new class\n            return\
    \ strongest_extension; //return class\n        }\n    }\n    return strongest_extension;",
  "    assert(class_name != \"0\");\n    \n    std::string extension_str = \"\";\n\
    \    size_t cap = class_name.size();\n    size_t sm = extensions.size();\n   \
    \ \n    if (cap - sm > 0) {\n        int diff = cap - sm;\n        if (diff <\
    \ 0) {\n            diff = 1;\n        }\n        \n        float strength = diff/cap;\n\
    \        \n        for (int i = 0; i < diff; ++i) {\n            extension_str\
    \ += class_name[i];\n        }\n        \n        for (size_t i = 0; i < sm; ++i)\
    \ {\n            extension_str += \".\" + extensions[i];\n        }\n        \n\
    \        if (strength > 0) {\n            extension_str += \".\" + extensions[sm-1];\n\
    \        }\n        \n        extension_str = extension_str.substr(0, extension_str.size()-1);\n\
    \    }\n    \n    return class_name + extension_str;", '    // Write your code
    here', "    int cap = class_name.size();\n    int sm = extensions.size();\n  \
    \  int num;\n    int min_num;\n    int i;\n    std::string name;\n    std::string\
    \ best_name = class_name;\n    std::string str;\n    std::string best_ext = extensions[0];\n\
    \    int best_ext_length = extensions[0].size();\n    for(int i = 1; i < extensions.size();\
    \ i++) {\n        num = cap - extensions[i].size();\n        if(num == 0) {\n\
    \            name = best_name;\n            best_ext = extensions[i];\n      \
    \      best_ext_length = extensions[i].size();\n        }\n        else if(num\
    \ < min_num) {\n            best_name = name;\n            best_ext = extensions[i];\n\
    \            best_ext_length = extensions[i].size();\n        }\n        else\
    \ if(num > min_num) {\n            min_num = num;\n            name = best_name;\n\
    \            best_ext = extensions[i];\n            best_ext_length = extensions[i].size();\n\
    \        }\n    }\n    std::string result;\n    result += best_name + \".\" +\
    \ best_ext;\n    for(int i = 0; i < extensions.size(); i++) {\n        if(extensions[i].size()\
    \ < best_ext_length) {\n            result += \".\" + extensions[i];\n       \
    \ }\n        else {\n            result += \".\" + best_ext;\n        }\n    }\n\
    \    return result;", "    assert(class_name.size() > 0 && extensions.size() >\
    \ 0);\n    \n    // Your code here\n    \n    // your code\n    ", "    // Write\
    \ your code here\n    int SM = 0;\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        for (int j = i; j < extensions.size(); j++) {\n            char\
    \ temp = extensions[i].toupper();\n            char temp2 = extensions[j].toupper();\n\
    \            if (temp == temp2) {\n                SM++;\n            }\n    \
    \    }\n    }\n    int CAP = 0;\n    for (int i = 0; i < class_name.length();\
    \ i++) {\n        for (int j = 0; j < class_name.length(); j++) {\n          \
    \  char temp = class_name[i];\n            char temp2 = class_name[j];\n     \
    \       if (temp == temp2) {\n                CAP++;\n            }\n        }\n\
    \    }\n    int frac = CAP - SM;\n    if (frac <= 0) {\n        return class_name\
    \ + \".\" + extensions[0];\n    }\n    int strongest = 0;\n    for (int i = 0;\
    \ i < extensions.size(); i++) {\n        if (frac >= extensions[i].size()) break;\n\
    \        strongest = i;\n    }\n    return class_name + \".\" + extensions[strongest];",
  "    // Write your code here\n    int CAP, SM;\n    CAP = class_name.size();\n \
    \   SM = class_name.size();\n    for (int i = 0; i < extensions.size(); i++)\n\
    \    {\n        for (int j = 0; j < CAP; j++)\n        {\n            if (class_name[j]==\
    \ extensions[i][j])\n            {\n                SM = SM-2;\n            }\n\
    \        }\n    }\n    int strength = CAP-SM;\n    if (strength == 0)\n    {\n\
    \        return class_name;\n    }\n    else if  (CAP>SM)\n    {\n        return\
    \ class_name + \".\" + extensions[0];\n    }\n    else\n    {\n        return\
    \ class_name + \".\" + extensions[strength];\n    }", "  // Your code here\n \
    \ std::sort(extensions.begin(), extensions.end(), std::less<std::string>());\n\
    \  int cap = class_name.size();\n  int sm = cap;\n  for (auto& ext : extensions)\
    \ {\n    if (cap - ext.size() != sm) {\n      sm = cap - ext.size();\n    }\n\
    \  }\n  return class_name + extensions[0];", "    int CAP = (int)class_name.size();\n\
    \    int SM = (int)class_name.size();\n    for (auto &ext : extensions) {\n  \
    \      CAP -= ext.size();\n        SM -= ext.size();\n    }\n    int strength\
    \ = (CAP - SM) / CAP;\n    if (strength == 0) {\n        return class_name;\n\
    \    }\n    for (auto &ext : extensions) {\n        strength = strength * CAP\
    \ / ext.size();\n        if (strength >= 1) {\n            return class_name +\
    \ \".\" + ext;\n        }\n    }\n    return \"\";", "    int sm = 0, cap = 0;\n\
    \    for (size_t i = 0; i < extensions.size(); i++) {\n        int s = extensions[i].size();\n\
    \        if (s >= cap) cap = s;\n        sm = sm + s;\n    }\n\n    double strongest\
    \ = (cap - sm) / cap;\n    for (size_t i = 0; i < extensions.size(); i++)\n  \
    \      strongest = strongest - (extensions[i].size() - extensions[i].size() -\
    \ cap);\n\n    for (size_t i = 0; i < extensions.size(); i++)\n        if (strongest\
    \ <= extensions[i].size()) \n            return class_name + \".\" + extensions[i];\n\
    \    \n    return \"\";", "    int c = 0;\n    int sm = 0;\n    for (int i = 0;\
    \ i < extensions.size(); i++) {\n        if (class_name[i] == toupper(extensions[i][0]))\
    \ {\n            c++;\n        }\n        if (class_name[i] == tolower(extensions[i][0]))\
    \ {\n            sm++;\n        }\n    }\n    float f = 0.0;\n    if (c > sm)\n\
    \        f = ((float)c - (float)sm) / c;\n    else if ((c == sm) && (c == 0))\n\
    \        f = 0;\n    else \n        f = 1;\n    std::string answer = \"\";\n \
    \   answer += class_name;\n    for (int i = 0; i < extensions.size(); i++) {\n\
    \        answer += \".\" + extensions[i];\n    }\n    answer += \".\" + std::to_string(f);\n\
    \    return answer;", "    // Do not write main() function.\n    // Do not read\
    \ input, instead use the arguments to the function.\n    // Do not print the output,\
    \ instead return values as specified\n    // Sort extensions according to their\
    \ strength.\n    // The extensions are sorted by their strength.\n    sort(extensions.begin(),\
    \ extensions.end(), Extension::compare);\n    // Loop through extensions and find\
    \ the strongest one. \n    std::string extension_name;\n    int strength = -1;\n\
    \    for (auto ext : extensions) {\n        auto cap = ext.substr(0, 1); \n  \
    \      auto sm = ext.substr(1, 1); \n        auto n = ext.length(); \n       \
    \ if (n == 1) \n            continue;\n        auto cap_val = tolower(cap); \n\
    \        int smval = tolower(sm); \n        strength = (int)(cap_val-smval)/cap_val;\
    \ \n    }\n    // Return extension with strength less than or equal to zero.\n\
    \    return class_name+\".\"+extension_name;", "  // write your code here\n  int\
    \ numOfCaps = 0;\n  int numOfSms = 0;\n  for(auto &elem : extensions)\n  {\n \
    \   std::string extension(elem);\n    int index = class_name.find(extension);\n\
    \    int length = extension.length();\n    if(index != std::string::npos)\n  \
    \  {\n      numOfCaps += 1;\n      numOfSms += length - index;\n    }\n  }\n \
    \ int strongestStrengh = numOfCaps - numOfSms;\n  if(numOfCaps == 0 && numOfSms\
    \ == 0)\n  {\n    return class_name;\n  }\n  else\n  {\n    return class_name\
    \ + \".\" + extensions[0];\n  }", "  // Your code goes here\n  std::map<std::string,\
    \ int> ext;\n  for (std::string e : extensions) {\n    std::transform(e.begin(),\
    \ e.end(), e.begin(), ::toupper);\n    ext[e] = 0;\n  }\n  for (std::map<std::string,\
    \ int>::iterator it = ext.begin(); it != ext.end(); ++it) {\n    int s = it->second;\n\
    \    it->second = 0;\n    for (std::map<std::string, int>::iterator it2 = ext.begin();\
    \ it2 != ext.end(); ++it2) {\n      int s2 = it2->second;\n      if (s > s2) {\n\
    \        s = s2;\n      }\n    }\n    it->second = s;\n  }\n  auto it = ext.begin();\n\
    \  int s = it->second;\n  it->second = 0;\n  for (std::map<std::string, int>::iterator\
    \ it2 = ext.begin(); it2 != ext.end(); ++it2) {\n    int s2 = it2->second;\n \
    \   if (s > s2) {\n      s = s2;\n    }\n  }\n  std::string result = \"\";\n \
    \ for (std::map<std::string, int>::iterator it = ext.begin(); it != ext.end();\
    \ ++it) {\n    result += class_name + it->first + \"(\" + std::to_string(it->second)\
    \ + \")\";\n  }\n  return result;", "    double max_strength = -1;\n    std::string\
    \ strongest_extension;\n    for (auto &ext: extensions) {\n        double strength\
    \ = class_name.count(ext) / static_cast<double>(class_name.size());\n        if\
    \ (strength > max_strength) {\n            max_strength = strength;\n        \
    \    strongest_extension = ext;\n        }\n    }\n    return strongest_extension;",
  "    // your code goes here\n    return 0;", "  int num_cap_letters=0, num_lower_letters=0;\n\
    \  for(auto &e:extensions) num_cap_letters += std::count(e.begin(), e.end(), std::toupper(std::tolower(e)));\n\
    \  for(auto &e:extensions) num_lower_letters += std::count(e.begin(), e.end(),\
    \ std::tolower(std::tolower(e)));\n  int strength=num_cap_letters - num_lower_letters;\n\
    \  std::cout << strength << \" \" << num_cap_letters << \" \" << num_lower_letters\
    \ << std::endl;\n  return class_name + extensions[strength];", "    if (extensions.size()\
    \ == 0)\n        return class_name;\n    // Your code here\n    std::string res\
    \ = class_name;\n    int cap = class_name.size();\n    int sm = extensions.size();\n\
    \    if (cap - sm <= 0) return \"\";\n    double frac = (cap - sm) / cap;\n  \
    \  int n = 0;\n    for (auto i : extensions) {\n        if (i == class_name[n])\
    \ {\n            n++;\n        }\n    }\n    for (auto i : extensions) {\n   \
    \     if ((i == class_name[n]) && ((i + 1 == class_name[n]) || (cap - sm == 1)))\
    \ {\n            n++;\n        }\n    }\n    if (frac < n - 1)\n        frac =\
    \ n - 1;\n    else\n        frac = cap - sm;\n    return res + \".\" + extensions[frac];",
  "    // write your code here\n    std::unordered_map<std::string, int> m;\n    for\
    \ (const auto &extension : extensions)\n        m[extension] += 1;\n    std::vector<std::pair<int,\
    \ std::string>> v;\n    for (auto &i : m)\n        v.push_back({ i.second, i.first\
    \ });\n    std::sort(v.begin(), v.end());\n    return std::accumulate(v.begin(),\
    \ v.end(), std::string{},\n        [](const std::string &a, const std::pair<int,\
    \ std::string> &b) {\n            return a.substr(0, b.second) + b.first;\n  \
    \      });", "    // write your code here\n    int cap = 0;\n    int sm = 0;\n\
    \    std::string extension_name;\n    for (auto ext : extensions) {\n        if\
    \ (ext.size() == 0)\n            continue;\n        for (auto character : ext)\
    \ {\n            if (character == 'A' || character == 'a')\n                cap++;\n\
    \            else\n                sm++;\n        }\n    }\n    int strongest\
    \ = cap - sm;\n    if (strongest == 0)\n        return class_name;\n    for (auto\
    \ ext : extensions) {\n        if (ext.size() == 0)\n            continue;\n \
    \       for (auto character : ext) {\n            if (character == 'A' || character\
    \ == 'a')\n                cap--;\n            else\n                sm--;\n \
    \       }\n    }\n    std::string s = class_name;\n    for (int i = 0; i < cap;\
    \ i++) {\n        s = s + extension_name;\n    }\n    for (int i = 0; i < sm;\
    \ i++) {\n        s = s + extension_name;\n    }\n    return s;", "    int cap\
    \ = 0;\n    int sm = 0;\n    std::string strongest_extension;\n    for(auto e\
    \ : extensions) {\n        cap += e.size();\n        sm += std::count(e.begin(),\
    \ e.end(), 'a');\n    }\n    if (cap > sm) strongest_extension = class_name;\n\
    \    else {\n        for(auto e : extensions) {\n            if (std::count(e.begin(),\
    \ e.end(), 'A') > std::count(e.begin(), e.end(), 'a')) strongest_extension = class_name\
    \ + e;\n        }\n    }\n    return strongest_extension;", "    int cap = 0,\
    \ sm = 0, t = 0;\n    for (auto &ext : extensions) {\n        cap += ext.length();\n\
    \        sm = ext.length();\n    }\n    t = cap - sm;\n    if (t < 0) {\n    \
    \    t = 0;\n    }\n    for (auto &ext : extensions) {\n        cap -= ext.length();\n\
    \        sm -= ext.length();\n    }\n    return class_name + extensions[t + extensions.size()];",
  "    // The map of extension strengths.\n    std::map<std::string, int> strength;\n\
    \    for (auto &extension : extensions)\n        strength[extension] = -1;\n \
    \   \n    // Iterate through the list of extensions one by one.\n    for (auto\
    \ &extension : extensions) {\n        // Iterate through the list of characters\
    \ in the extension.\n        for (size_t i = 0, n = extension.length(); i < n;\
    \ ++i) {\n            // If the extension starts with an uppercase letter, then\n\
    \            // we set the strength of this extension.\n            if (isupper(extension[i]))\n\
    \                strength[extension] = i;\n            // If the extension starts\
    \ with a lowercase letter, then\n            // we set the strength of this extension.\n\
    \            else if (islower(extension[i]))\n                strength[extension]\
    \ = n - i;\n        }\n    }\n\n    // Return the name of the class and the strongest\
    \ extension\n    // with the highest strength.\n    for (auto &extension : extensions)\n\
    \        if (strength[extension] == strength[extension].max())\n            return\
    \ class_name + extension;\n\n    // If there are no extensions, then return the\
    \ given class.\n    return class_name;", '    // Your code here', "    int max_strength\
    \ = 0;\n    std::string strongest_extension = \"\";\n    for (auto x : extensions)\
    \ {\n        size_t found = class_name.find(x);\n        if (found != std::string::npos)\
    \ {\n            size_t found = class_name.find_first_of(x);\n            strongest_extension\
    \ += class_name.substr(found, x.length());\n            max_strength = std::max(max_strength,\
    \ strongest_extension.find_first_of('.'));\n        }\n    }\n    return class_name\
    \ + \".\" + std::string(strongest_extension.begin() + max_strength, '.');", " \
    \   int len = extensions.size();\n    // find out how many uppercase letters are\
    \ in each of the extensions\n    std::vector<int> upper_counts(len, 0);\n    for(auto\
    \ ext : extensions)\n        for(auto c : ext)\n            upper_counts[c - 'A']++;\n\
    \    int max_upper = 0;\n    for(auto i : upper_counts)\n        if(i > max_upper)\n\
    \            max_upper = i;\n    // find out how many lowercase letters are in\
    \ each of the extensions\n    std::vector<int> lower_counts(len, 0);\n    for(auto\
    \ ext : extensions)\n        for(auto c : ext)\n            lower_counts[c - 'a']++;\n\
    \    int max_lower = 1;\n    for(auto i : lower_counts)\n        if(i > max_lower)\n\
    \            max_lower = i;\n    // find the number of uppercase letters in the\
    \ extension\n    int num_upper = 0;\n    for(auto ext : extensions)\n        for(auto\
    \ c : ext)\n            if(c - 'A' == num_upper)\n                num_upper++;\n\
    \    // find the number of lowercase letters in the extension\n    int num_lower\
    \ = 1;\n    for(auto ext : extensions)\n        for(auto c : ext)\n          \
    \  if(c - 'a' == num_lower)\n                num_lower++;\n    // return the extension\
    \ with highest strength\n    return class_name + \".\" + extensions[max_upper\
    \ - SM - CAP + num_lower];", "\tstd::vector<std::pair<int, int> > my_extensions;\n\
    \tfor (int i = 0; i < extensions.size(); i++) {\n\t\tchar letter1 = extensions[i][0];\n\
    \t\tchar letter2 = extensions[i][1];\n\t\tint strength = std::min(std::count_if(extensions[i].begin()\
    \ + 2, extensions[i].end(),\n\t\t\t[](char letter) {return (letter == letter1);}),\
    \ std::count_if(extensions[i].begin() + 2, extensions[i].end(),\n\t\t\t[](char\
    \ letter) {return (letter == letter2);}));\n\t\tint index = std::min(std::min(std::distance(extensions[i].begin(),\
    \ extensions[i].begin() + 2), std::distance(extensions[i].begin() + 4, extensions[i].end()\
    \ - 2)),\n\t\t\tstd::distance(extensions[i].begin(), extensions[i].begin() + 4));\n\
    \t\tmy_extensions.emplace_back(std::make_pair(strength, index));\n\t}\n\tmy_extensions.sort([](std::pair<int,\
    \ int> a, std::pair<int, int> b) {return a.first > b.first;});\n\tfor (int i =\
    \ 0; i < my_extensions.size(); i++) {\n\t\tstd::cout << class_name << \".\" <<\
    \ extensions[my_extensions[i].second];\n\t\tif (i != my_extensions.size() - 1)\
    \ {\n\t\t\tstd::cout << \", \";\n\t\t}\n\t}\n\treturn class_name;", "    // Write\
    \ your code here\n    int cap = 0;\n    int sm = 0;\n    for(int i=0; i<extensions.size();i++){\n\
    \        cap += (extensions[i].size()-1);\n        sm += (extensions[i].size()-1);\n\
    \    }\n    if(cap-sm>=0) return class_name+\".\"+extensions[(cap-sm)];\n    else\
    \ return class_name+\".\"+extensions[0];", "  assert(extensions.size() != 0);\n\
    \  assert(extensions.size() <= 1);\n  std::map<int, std::string> extension_map;\n\
    \  for (std::size_t i = 0; i < extensions.size(); ++i) {\n    std::string extension\
    \ = extensions[i];\n    int count = 1;\n    for (auto c : extension) {\n     \
    \ if (std::isupper(c)) count++;\n      else break;\n    }\n    extension_map[count]\
    \ = extension;\n  }\n  auto it = extension_map.begin();\n  assert(it != extension_map.end());\n\
    \  if (std::numeric_limits<int>::max() - it->first <= 1) {\n    assert(it->second.size()\
    \ > 0);\n    return class_name + it->second;\n  }\n  std::map<int, std::string>\
    \ temp_map;\n  for (std::size_t i = 0; i < extensions.size(); ++i) {\n    int\
    \ count = 1;\n    for (auto c : extensions[i]) {\n      if (std::isupper(c)) count++;\n\
    \      else break;\n    }\n    if (count < it->first) {\n      temp_map[count]\
    \ = extensions[i];\n    }\n  }\n  std::size_t max_count = 1;\n  for (auto c :\
    \ temp_map) {\n    if (c->second != temp_map.begin()->second) max_count = c->second;\n\
    \  }\n  return class_name + it->second + temp_map.begin()->second;", "    // write\
    \ your code in C++11 (preferred)\n    //#include <bits/stdc++.h>\n    //using\
    \ namespace std;\n", "    int cap_counter = 0, sm_counter = 0;\n    std::string\
    \ result;\n    for (auto ext : extensions) {\n        for (auto c : ext) {\n \
    \           if (isupper(c)) {\n                cap_counter++;\n            } else\
    \ {\n                sm_counter++;\n            }\n        }\n    }\n    double\
    \ strength = cap_counter - sm_counter;\n    if (strength < 0)\n        return\
    \ \"Error\";\n    auto idx = std::min_element(extensions.begin(), extensions.end(),\
    \ \n            [&strength](int lhs, int rhs) { return strength - lhs < rhs -\
    \ strength; });\n    std::string class_without_ext = class_name;\n    class_without_ext.erase(0,\
    \ class_name.size() - ext[idx].size());\n    if (extensions.size() > 1) {\n  \
    \      if (strength == 0)\n            return \"Error\";\n        else\n     \
    \       result += class_name + \".\" + extensions[idx];\n    } else {\n      \
    \  result += class_name + \".\" + extensions[idx];\n    }\n    return result;",
  "    // Write your code here\n    return class_name + \".\" + extensions[0];", " \
    \ assert(extensions.size() > 0);\n  int strength = 0;\n  std::string extension;\n\
    \  for (int i = 0; i < extensions.size(); i++) {\n    std::string extension_name(extensions[i]);\n\
    \    if (extension_name.length() != 0) {\n      std::transform(extension_name.begin(),\
    \ extension_name.end(), extension_name.begin(), ::toupper);\n      std::transform(extension_name.begin(),\
    \ extension_name.end(), extension_name.begin(), ::tolower);\n      for (int j\
    \ = 0; j < extension_name.length(); j++) {\n        if (j == 0) {\n          char\
    \ c = extension_name.at(j);\n          if (std::isupper(c)) {\n            strength\
    \ += 1;\n          } else {\n            strength += 2;\n          }\n       \
    \ } else {\n          char c = extension_name.at(j);\n          if (std::isupper(c))\
    \ {\n            strength += 1;\n          } else {\n            strength += 2;\n\
    \          }\n        }\n      }\n    }\n  }\n  if (strength == 0) {\n    std::string\
    \ extension(class_name);\n    int pos = extension.rfind('.');\n    if (pos !=\
    \ std::string::npos) {\n      return extension.substr(pos + 1, extension.length()\
    \ - pos);\n    }\n    return extension;\n  }\n  if (strength < 0 && strength !=\
    \ -1) {\n    std::string extension(class_name);\n    int pos = extension.rfind('.');\n\
    \    if (pos != std::string::npos) {\n      return extension.substr(pos + 1, extension.length()\
    \ - pos);\n    }\n    return extension;\n  }\n  std::string result;\n  if (strength\
    \ == -1) {\n    result = \"Error.\";\n  } else {\n    result = class_name + \"\
    .\" + extensions[0];\n  }\n  return result;", "    float sm = class_name.length(),\
    \ cap = class_name.length()-1;\n    std::vector<std::pair<float, std::string>>\
    \ vec;\n    for(auto extension: extensions) {\n        auto cap_d = std::toupper(extension[0])-'A';\n\
    \        auto sm_d = std::tolower(extension[0])-'a';\n        float strength =\
    \ cap_d-sm_d;\n        if(strength>0) {\n            vec.emplace_back(strength,\
    \ extension);\n            cap = std::max(cap, strength);\n        }\n    }\n\
    \    float max_strength = std::accumulate(std::begin(vec), std::end(vec), 0.0f);\n\
    \    float strength = std::find(std::begin(vec), std::end(vec), max_strength)->second;\n\
    \    for(auto extension: extensions) {\n        auto cap_d = std::toupper(extension[0])-'A';\n\
    \        auto sm_d = std::tolower(extension[0])-'a';\n        float strength_extension\
    \ = cap_d-sm_d;\n        if((strength_extension>0) && (strength_extension>strength))\
    \ {\n            strength = strength_extension;\n        }\n    }\n    return\
    \ class_name + extensions[std::distance(std::begin(extensions), std::find(std::begin(extensions),\
    \ std::end(extensions), strength))];", "    // Write your code here\n    int strongest_extension_strength\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        int extension_strength\
    \ = 0;\n        for (int j = 0; j < class_name.length(); j++) {\n            extension_strength\
    \ += (class_name[j]-extensions[i][j])*(class_name[j]-extensions[i][j]);\n    \
    \    }\n        if (extension_strength > strongest_extension_strength)\n     \
    \       strongest_extension_strength = extension_strength;\n    }\n    int cap\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        int extension_strength\
    \ = 0;\n        for (int j = 0; j < class_name.length(); j++) {\n            extension_strength\
    \ += (class_name[j]-extensions[i][j])*(class_name[j]-extensions[i][j]);\n    \
    \    }\n        if (extension_strength > strongest_extension_strength)\n     \
    \       strongest_extension_strength = extension_strength;\n        if (class_name[i]\
    \ == 'S')\n            cap++;\n    }\n    if (cap == 0)\n        cap = 1;\n  \
    \  double strongest_extension_strength_percentage = strongest_extension_strength\
    \ / cap;\n    int index = static_cast<int>(strongest_extension_strength_percentage);\n\
    \    if (index > 0 && index < extensions.size())\n        index = static_cast<int>(strongest_extension_strength_percentage);\n\
    \    return class_name + \".\" + extensions[index];", "    int cap_num = 0, sm_num\
    \ = 0;\n    std::string strongest_extension = class_name;\n    for (size_t i =\
    \ 0; i < extensions.size(); ++i) {\n        std::string extension = extensions[i];\n\
    \        size_t pos = extension.find_first_of(' ');\n        if (pos == std::string::npos)\
    \ pos = extension.size();\n        std::string name = extension.substr(0, pos);\n\
    \        int cap_pos = name.find_first_of('A');\n        if (cap_pos == std::string::npos)\
    \ cap_pos = name.size();\n        cap_num += (name.size() - cap_pos) * pow(26,\
    \ static_cast<int>(name.size()) - cap_pos);\n        int sm_pos = name.find_first_of('z');\n\
    \        if (sm_pos == std::string::npos) sm_pos = name.size();\n        sm_num\
    \ += (name.size() - sm_pos) * pow(26, static_cast<int>(name.size()) - sm_pos);\n\
    \    }\n    strongest_extension += \".\";\n    strongest_extension += extensions[0];\n\
    \    for (int i = 1; i < extensions.size(); ++i) {\n        std::string extension\
    \ = extensions[i];\n        size_t pos = extension.find_first_of(' ');\n     \
    \   if (pos == std::string::npos) pos = extension.size();\n        std::string\
    \ name = extension.substr(0, pos);\n        int cap_pos = name.find_first_of('A');\n\
    \        if (cap_pos == std::string::npos) cap_pos = name.size();\n        cap_num\
    \ += (name.size() - cap_pos) * pow(26, static_cast<int>(name.size()) - cap_pos);\n\
    \        int sm_pos = name.find_first_of('z');\n        if (sm_pos == std::string::npos)\
    \ sm_pos = name.size();\n        sm_num += (name.size() - sm_pos) * pow(26, static_cast<int>(name.size())\
    \ - sm_pos);\n        strongest_extension += \".\" + extensions[i];\n    }\n \
    \   double strength = static_cast<double>(cap_num - sm_num) / cap_num;\n    if\
    \ (strength > 0) strongest_extension += \".\" + extensions[0];\n    return strongest_extension;",
  "  int cap_sum = 0, sm_sum = 0;\n  for (const auto &ext : extensions)\n  {\n   \
    \ cap_sum += ext.size();\n    sm_sum += ext.size();\n  }\n  int cap = cap_sum\
    \ / extensions.size();\n  int sm = sm_sum / extensions.size();\n  if (cap < sm)\n\
    \  {\n    std::string ext = class_name;\n    for (int i = 0; cap > cap_sum - cap\
    \ + sm_sum; i++) {\n      cap -= cap_sum - cap + sm_sum;\n      sm -= sm_sum;\n\
    \      ext + \".\" + extensions[i];\n    }\n    return ext;\n  }\n  else return\
    \ class_name;", "\tassert(extensions.size() >= 2);\n\tstd::map<int, std::string>\
    \ counters;\n\tfor (const auto& ext : extensions) {\n\t\tint count = 0;\n\t\t\
    for (int i = 0; i < ext.size(); i++) {\n\t\t\tif (ext.at(i) >= 'A' && ext.at(i)\
    \ <= 'Z') count++;\n\t\t\telse if (ext.at(i) >= 'a' && ext.at(i) <= 'z') count++;\n\
    \t\t}\n\t\tcounters[count] += ext;\n\t}\n\tstd::string strongest = class_name;\n\
    \tfor (auto it = counters.begin(); it != counters.end(); ++it) {\n\t\tconst auto&\
    \ count = it->first;\n\t\tif (count == 0) continue;\n\t\tconst auto& ext = it->second;\n\
    \t\tassert(ext.size() == 1);\n\t\tif (strongest.size() > ext.size() + 1) {\n\t\
    \t\tstrongest.erase(0, strongest.size() - ext.size());\n\t\t}\n\t\tstrongest +=\
    \ ext;\n\t}\n\treturn strongest;", "    // Your code here\n    std::string result;\n\
    \    for(auto& ext : extensions) {\n        std::string ext_name = ext + class_name;\n\
    \        int stren = ext_name.length();\n        stren = stren - (stren - class_name.length());\n\
    \        stren = stren / 2;\n        if(ext_name[stren - class_name.length()]\
    \ != class_name.at(0)) {\n            if(stren > result) {\n                result\
    \ = ext_name;\n            }\n        }\n    }\n    return result;", "   //your\
    \ code goes here\n   assert(extensions.size() > 0);\n   int strongest_extension\
    \ = -1;\n   std::sort(extensions.begin(), extensions.end());\n   if(extensions.front()\
    \ != class_name.substr(0,1)) {\n       return class_name;\n   }\n   for(size_t\
    \ i = 0; i < extensions.size(); ++i) {\n       if(extensions[i] == class_name.substr(0,\
    \ 1)) {\n          strongest_extension = i;\n          break; \n       }\n   }\n\
    \   if(strongest_extension >= 0) {\n      return class_name + \".\" + extensions[strongest_extension];\n\
    \   }\n   else return class_name;", "  int cap = class_name.length();\n  int sm\
    \ = class_name.size();\n  int strength = 0;\n  int pos = 0;\n\n  for (size_t i\
    \ = 0; i < extensions.size(); i++) {\n    char c = extensions[i];\n    int c_cap\
    \ = c.size();\n    int c_sm = c.size();\n    strength = (c_cap - c_sm);\n    if\
    \ (strength > cap) {\n      cap = strength;\n      pos = i;\n    }\n  }\n\n  return\
    \ class_name + \".\" + extensions[pos];", "    int cap = class_name.size();\n\
    \    int sm = cap;\n    for(auto extension : extensions) {\n        auto cap_str\
    \ = extension.substr(0, cap);\n        auto sm_str = extension.substr(cap, sm);\n\
    \        if (cap_str.length() == cap && sm_str.length() == sm) {\n           \
    \ sm = cap_str.length();\n            cap = sm_str.length();\n        }\n    }\n\
    \    std::string result;\n    result += class_name + '.';\n    if (cap != sm)\n\
    \        result += extensions[cap];\n    else\n        result += extensions[0];\n\
    \    return result;", "    // Your code here\n    std::map<int, std::string> mymap;\n\
    \    int cnt = 0;\n    for (auto e : extensions)\n        mymap[cnt] = e;\n  \
    \      cnt++;\n    int cap = 0;\n    for (auto mymap_it : mymap)\n    {\n    \
    \    cap += mymap_it.second;\n    }\n    float sm = 0;\n    for (auto e : extensions)\n\
    \        sm += std::toupper(std::tolower(e));\n    float score = cap - sm;\n \
    \   std::string str;\n    for (int i = 0; i < extensions.size();i++)\n    {\n\
    \        if (str != \"\")\n            str += \".\";\n        str += class_name\
    \ + \".\" + extensions[i] + \"_\" + std::to_string(score);\n    }\n    std::string\
    \ result = str.substr(0, str.size() - 4);\n    return result;", "    // Write\
    \ your code here\n    std::string res = class_name;\n    int sum = 0;\n    for\
    \ (int i = 0; i < extensions.size(); i++) {\n        sum += (tolower(extensions[i][0])\
    \ - 'a');\n    }\n    if (sum > 0) {\n        sum -= extensions.size();\n    \
    \    for (int i = 0; i < extensions.size(); i++) {\n            char c = extensions[i][0];\n\
    \            char d = tolower(c);\n            char e = toupper(c);\n        \
    \    int k = c - d;\n            int l = sum + d - e;\n            if (k >= l)\
    \ {\n                res = class_name + extensions[i];\n            }\n      \
    \  }\n    }\n    return res;", "    // Initialize a max_extension_strength variable.\
    \ \n    int max_extension_strength = 0;\n    for (auto e : extensions) {\n   \
    \     auto cap = std::count_if(e.begin(), e.end(), [](char x) { return (x >= 'A')\
    \ && (x <= 'Z'); });\n        auto sm = std::count_if(e.begin(), e.end(), [](char\
    \ x) { return (x >= 'a') && (x <= 'z'); });\n        max_extension_strength +=\
    \ cap - sm;\n    }\n    // The max extension strength is the sum of the strengths\
    \ of the extension names.\n    return class_name + std::to_string(max_extension_strength);",
  "    std::sort(extensions.begin(), extensions.end(), Extension::cmp);\n    std::string\
    \ result;\n    std::string last_name = class_name;\n    int last_strength = 1;\n\
    \    for (int i = 0; i < extensions.size(); i++) {\n        char ch = extensions[i];\n\
    \        auto pos = class_name.find(ch);\n        if (pos == std::string::npos)\
    \ {\n            if (last_strength != 1) {\n                result += last_name;\n\
    \                last_strength = 1;\n            }\n            last_name = ch;\n\
    \        } else {\n            assert(last_strength > 0);\n            last_strength--;\n\
    \            last_name = class_name.substr(pos + 1, std::string::npos);\n    \
    \    }\n    }\n    if (last_strength != 1) {\n        result += last_name;\n \
    \   }\n    return result;", "  // Your code here\n  assert(extensions.size() >\
    \ 0);\n  int c = 0;\n  for (size_t i = 0; i < extensions.size(); ++i) {\n    if\
    \ (extensions[i].at(0) == class_name[0]) {\n      c = i;\n    }\n  }\n  assert(c\
    \ > 0);\n  int cap = 0;\n  int sm = 0;\n  for (size_t i = 0; i < extensions.size();\
    \ ++i) {\n    if (extensions[i].at(0) == class_name[0]) {\n      cap = i;\n  \
    \  }\n    if (extensions[i].at(1) == class_name[1]) {\n      sm = i;\n    }\n\
    \  }\n  assert(cap >= 0 && sm >= 0);\n  return class_name + \".\" + extensions[cap].substr(0,\
    \ cap - sm) + \".\" + extensions[sm].substr(0, sm - cap);", "    assert(extensions.size()\
    \ > 0);\n    auto it = extensions.begin();\n    \n    std::string strongest_ext\
    \ = *it;\n    int strength = 0;\n    \n    for (++it; it != extensions.end();\
    \ ++it) {\n        int cap = std::count(it.begin(), it.end(), 'A');\n        int\
    \ sm = std::count(it.begin(), it.end(), 'a');\n        strength += cap - sm;\n\
    \    }\n    \n    if (strength == 0) return class_name;\n    else return class_name\
    \ + '.' + strongest_ext;", "  // your code goes here\n  assert(class_name != \"\
    Slices\" && class_name != \"Chickens\" && class_name != \"Fish\");\n  for (int\
    \ i = 0; i < extensions.size(); i++) {\n    std::string extension_name = class_name\
    \ + extensions[i];\n    std::map<int, int> letter_count;\n    for (int j=0; j\
    \ < extensions[i].size(); j++) {\n      letter_count[static_cast<int>(extensions[i][j])]++;\n\
    \    }\n    int min_count = INT_MAX;\n    for (int j=0; j < extensions[i].size();\
    \ j++) {\n      if (letter_count[static_cast<int>(extensions[i][j])] == min_count)\
    \ {\n        min_count = letter_count[static_cast<int>(extensions[i][j])];\n \
    \     }\n    }\n    for (int j = 0; j < extensions[i].size(); j++) {\n      if\
    \ (letter_count[static_cast<int>(extensions[i][j])] == min_count) {\n        return\
    \ extension_name + extensions[i][j];\n      }\n    }\n  }", "    // Your code\
    \ goes here\n    // Write your code here", "    int num_uppers = 0;\n    int num_lowers\
    \ = 0;\n    std::string strongest_extension_name;\n    for(int i = 0; i < extensions.size();i++)\
    \ {\n        int length = extensions[i].size();\n        if(length > 0) {\n  \
    \          if(class_name == extensions[i].substr(0, length)) {\n             \
    \   if(strongest_extension_name == \"\" || strongest_extension_name == extensions[i].substr(0,\
    \ length)) {\n                    strongest_extension_name = class_name + extensions[i];\n\
    \                }\n            }\n            else if(class_name.size() > strongest_extension_name.size())\
    \ {\n                strongest_extension_name = class_name + extensions[i];\n\
    \            }\n            if(class_name == extensions[i].substr(length)) {\n\
    \                if(strongest_extension_name == \"\" || strongest_extension_name\
    \ == extensions[i].substr(length)) {\n                    strongest_extension_name\
    \ = class_name + extensions[i];\n                }\n            }\n          \
    \  if(class_name == extensions[i].substr(0, length)) {\n                if(strongest_extension_name\
    \ == \"\" || strongest_extension_name == extensions[i].substr(0, length)) {\n\
    \                    strongest_extension_name = class_name + extensions[i];\n\
    \                }\n            }\n            else if(class_name.size() > strongest_extension_name.size())\
    \ {\n                strongest_extension_name = class_name + extensions[i];\n\
    \            }\n        }\n    }\n    int cap_diff = strongest_extension_name.size()\
    \ - class_name.size();\n    int sml_diff = class_name.size() - strongest_extension_name.size();\n\
    \    \n    if(cap_diff == 0 || sml_diff == 0)\n        return strongest_extension_name;\n\
    \    \n    \n    if(num_uppers < cap_diff)\n        num_uppers = cap_diff;\n \
    \   \n    if(num_lowers < sml_diff)\n        num_lowers = sml_diff;\n    \n  \
    \  \n    if(num_uppers == 0) {\n        if(num_lowers > 0) {\n            return\
    \ strongest_extension_name;\n        }\n        else if(num_lowers == 0) {\n \
    \           return class_name;\n        }\n    }\n    else if(num_lowers == 0)\
    \ {\n        if(num_uppers > 0) {\n            return strongest_extension_name;\n\
    \        }\n        else if(num_uppers == 0) {\n            return class_name;\n\
    \        }\n    }\n    \n    if(strongest_extension_name.size() > class_name.size())\
    \ {\n        return strongest_extension_name;\n    }\n    else if(strongest_extension_name.size()\
    \ < class_name.size()) {\n        return class_name;\n    }\n    else if(strongest_extension_name.size()\
    \ == class_name.size()) {\n        return strongest_extension_name + \".\" + class_name.substr(strongest_extension_name.size());\n\
    \    }\n    else if(strongest_extension_name.size() > class_name.size() && strongest_extension_name.size()\
    \ < class_name.size", "    std::string res;\n    std::map<int, std::string> res;\n\
    \    for (auto &ele : extensions) {\n        auto i = std::string::npos;\n   \
    \     i = class_name.find(ele);\n        if (i != std::string::npos) {\n     \
    \       std::string tmp = class_name;\n            tmp.replace(i, ele.length(),\
    \ \"\");\n            std::string str = tmp + ele;\n            res[i] = str;\n\
    \        }\n    }\n    if (res.size() > 0) {\n        auto max_strength = std::max_element(std::begin(res),\
    \ std::end(res));\n        res = res[max_strength];\n    }\n    return res;",
  "    // Complete the code here\n    \n    std::string result = \"\";\n    \n   \
    \ // use unordered_map for faster access of extensions \n    std::unordered_map<char,\
    \ int> counter;\n    for(const auto& e : extensions) {\n        counter[e]++;\n\
    \    }\n    int biggest = -1;\n    char biggest_extension;\n    for (const auto&\
    \ e : extensions) {\n        int current_value = counter[e];\n        \n     \
    \   if(current_value > biggest) {\n            biggest = current_value;\n    \
    \        biggest_extension = e;\n        }\n    }\n    \n    result += class_name;\n\
    \    result += biggest_extension;\n    \n    return result;", "\tstd::sort(extensions.begin(),\
    \ extensions.end()); \n\tint n = extensions.size();\n\tdouble strongest_strength\
    \ = -1;\n\tfor (auto i = 0 ; i != n ; i++) {\n\t\tstd::string s = class_name +\
    \ \".\" + extensions[i];\n\t\tint sc = 0;\n\t\tfor (auto j = 0 ; j != n ; j++)\
    \ {\n\t\t\tif (j != i) {\n\t\t\t\tdouble scc = std::count_if(s.begin(), s.end(),\
    \ [&](char &c) {return c >= 'A' && c <= 'Z'});\n\t\t\t\tsc += scc;\n\t\t\t}\n\t\
    \t}\n\t\tstrongest_strength = (sc > strongest_strength) ? sc : strongest_strength;\n\
    \t}\n\treturn class_name + \".\" + extensions[strongest_strength];", "  int cap\
    \ = class_name.length();\n  int sm = 0;\n  for (int i = 0; i < extensions.size();\
    \ i++) {\n    int ext_len = extensions[i].length();\n    char c = extensions[i].at(0)\
    \ - 'a';\n    if (c >= cap) continue;\n    cap = c;\n    sm = ext_len;\n  }\n\
    \  int strength = cap - sm;\n  std::sort(extensions.begin(), extensions.end(),\
    \ [strength](std::string a, std::string b) {\n    return a.length() < b.length()\
    \ || (a.length() == b.length() && a[0] > b[0]);\n  });\n  return class_name +\
    \ \".\" + extensions.front();", "    \n    std::string strongest_extension = \"\
    \";\n    int cap = 0;\n    int sm = 0;\n    \n    for(auto i : extensions) {\n\
    \        if(std::toupper(i) == class_name.at(cap)) {\n            cap++;\n   \
    \     }\n        if(std::tolower(i) == class_name.at(sm)) {\n            sm++;\n\
    \        }\n    }\n    \n    if(cap - sm > 0) {\n        \n        auto diff =\
    \ cap - sm;\n        std::swap(cap, sm);\n        \n        if(diff == 0)\n  \
    \          strongest_extension = class_name + extensions[0];\n        else\n \
    \           strongest_extension = class_name + extensions[diff];\n    }\n    \n\
    \    return strongest_extension;", "    // Write your code here\n    std::string\
    \ strongest_extension = \"\";\n    for (auto e : extensions) {\n        // write\
    \ your code here\n        std::pair<int, std::string> ext_pair = std::make_pair(std::toupper(std::distance(cbegin(extensions),\
    \ e)), e);\n        std::sort(extensions.begin(), extensions.end());\n       \
    \ for (auto e2 : extensions) {\n            ext_pair.second = std::tolower(std::distance(cbegin(extensions),\
    \ e2));\n            if (ext_pair.first == ext_pair.second) {\n              \
    \  break;\n            }\n        }\n        if (strongest_extension.size() ==\
    \ 0) {\n            strongest_extension = class_name + ext_pair.second;\n    \
    \    } else {\n            if (ext_pair.first > strongest_extension.size()) strongest_extension\
    \ = class_name + ext_pair.second;\n        }\n    }\n    return strongest_extension;",
  "    // Write your code here\n    int cap = class_name.size();\n    int sm = extensions.size();\n\
    \    int result = 0;\n    int count = 0;\n    for (const auto &e : extensions)\
    \ {\n        std::string temp = class_name + e;\n        for (int i = 0; i < cap\
    \ - sm; i++) {\n            result += (temp[i]) - 'A';\n        }\n        if\
    \ (result >= 0) count++;\n    }\n    \n    if (count == 0) {\n        for (const\
    \ auto &e : extensions) {\n            result += e - 'A';\n        }\n    }\n\
    \    \n    return class_name + extensions[result >= 0 ? result : 0];", "// Write\
    \ your code here\nint cap_min = 0, cap_max = 0, sm_min = 0, sm_max = 0;\nfor(std::string\
    \ extension : extensions)\n{\n    char c = extension[0];\n    cap_min = std::min(std::min(cap_min,\
    \ std::toupper(c)), cap_max);\n    cap_max = std::max(std::max(cap_min, std::toupper(c)),\
    \ cap_max);\n    sm_min = std::min(std::min(sm_min, std::tolower(c)), sm_max);\n\
    \    sm_max = std::max(std::max(sm_min, std::tolower(c)), sm_max);", "    std::sort(extensions.begin(),\
    \ extensions.end(), [](std::string &x, std::string &y) { return x.size() - y.size();\
    \ });\n    std::string strongest_extension = \"\";\n    auto it = extensions.begin();\n\
    \    for (size_t i = 0; i < extensions.size(); ++i) {\n        bool flag = false;\n\
    \        auto it_tmp = it;\n        ++it_tmp;\n        while (flag) {\n      \
    \      if (it_tmp == extensions.end()) {\n                flag = true;\n     \
    \       } else {\n                flag = class_name.at(i) == it_tmp->at(0);\n\
    \            }\n            ++it_tmp;\n        }\n        if (i == 0 && it->size()\
    \ == 0) {\n            strongest_extension += class_name + \".\" + extensions[0];\n\
    \        } else {\n            strongest_extension += class_name + \".\" + extensions[i];\n\
    \        }\n    }\n    return strongest_extension;", "  int total_len = 0;\n \
    \ for (auto &ext : extensions) {\n    total_len += ext.length();\n  }\n  int strongest_ext\
    \ = -1;\n  int sm = 0;\n  for (auto &ext : extensions) {\n    int cur_len = ext.length();\n\
    \    if (cur_len == 0) continue; // skip empty extensions\n    if (strongest_ext\
    \ > 0 && cur_len >= strongest_ext) {\n      continue;\n    }\n    if (ext.compare(0,\
    \ CAP - sm, CAP - sm) == 0) {\n      strongest_ext = CAP - sm;\n    }\n    sm\
    \ += CAP - cur_len;\n  }\n  if (strongest_ext == -1) {\n    return class_name;\
    \ // no extensions match the criteria\n  }\n  return class_name + \".\" + extensions[strongest_ext];",
  "    int CAP = class_name.size();\n    int SM = extensions.size();\n    int strength\
    \ = 0;\n    for (auto ext : extensions) {\n        auto cap = ext.size();\n  \
    \      auto sm = cap;\n        auto frac = cap - sm;\n        if (cap.size() !=\
    \ CAP) {\n            frac /= CAP - 1;\n        }\n        if (cap != CAP) {\n\
    \            frac /= CAP;\n        }\n        auto i = frac;\n        while (i--)\
    \ {\n            if (ext != ext.substr(0, CAP - sm)) {\n                sm--;\n\
    \            }\n        }\n        strength += sm;\n    }\n    strength /= SM;\n\
    \    std::string extension;\n    if (strength < 0) {\n        extension = \".\"\
    \ + extensions[abs(strength) - 1];\n    }\n    else {\n        extension = class_name\
    \ + \".\" + extensions[abs(strength) - 1];\n    }\n    return extension;", "\t\
    assert(extensions.size() > 0);\n\tdouble max_strength = 0.0;\n\tdouble max_index\
    \ = -1;\n\tfor (size_t i = 0; i < extensions.size(); ++i) {\n\t\tdouble strength\
    \ = std::stoi(extensions[i]);\n\t\tassert(strength >= 0);\n\t\tif (strength >\
    \ max_strength) {\n\t\t\tmax_index = i;\n\t\t\tmax_strength = strength;\n\t\t\
    }\n\t}\n\treturn class_name + \".\" + extensions[max_index];", "    // Your code\
    \ goes here\n    std::string result=class_name;\n    int cap_sum=0,sm_sum=0;\n\
    \    for(unsigned int i=0;i<extensions.size();i++)\n    {\n        cap_sum+=std::tolower(extensions[i].at(0)-'A');\n\
    \        sm_sum+=std::toupper(extensions[i].at(0)-'A');\n    }\n    int sc=cap_sum-sm_sum;\n\
    \    for(int i=0;i<extensions.size();i++)\n    {\n        int x=std::tolower(extensions[i].at(0)-'A');\n\
    \        int y=std::toupper(extensions[i].at(0)-'A');\n        sc+=(x-y)*(x-y);\n\
    \    }\n    if(sc==0)\n    {\n        return result;\n    }\n    int d=(int)(sc/(cap_sum-sm_sum));\n\
    \    for(int i=0;i<extensions.size();i++)\n    {\n        if(d==(cap_sum-sm_sum))\n\
    \        {\n            result=class_name+\".\"+extensions[i];\n            return\
    \ result;\n        }\n        d--;\n    }\n    return \"\";", "    // code here\n\
    \    ", "  // Write your code here\n  int cap = 0;\n  int sm = 0;\n  std::string\
    \ ext;\n  for (int i = 0; i < extensions.size(); i++) {\n    cap = cap + std::toupper(extensions[i][0])\
    \ - std::toupper(extensions[i][0]);\n    sm = sm + std::tolower(extensions[i][0])\
    \ - std::tolower(extensions[i][0]);\n  }\n  if (cap >= sm) {\n    ext = class_name\
    \ + extensions[0];\n  } else {\n    for (int i = 1; i < extensions.size(); i++)\
    \ {\n      cap = cap - std::tolower(extensions[i][0]);\n      sm = sm - std::toupper(extensions[i][0]);\n\
    \    }\n    if (cap >= sm) {\n      ext = class_name + extensions[i];\n    }\n\
    \  }\n  return ext;", "\tassert(extensions.size() > 1);\n\tconst auto extensions_count\
    \ = extensions.size();\n\tconst auto classes_count = class_name.size();\n\t\n\t\
    assert(extensions_count > classes_count);\n\t\n\tstd::map<int, int> extension_to_class;\n\
    \tstd::vector<int> strongest_extensions;\n\t\n\tfor (int i = 0; i < extensions_count;\
    \ i++) {\n\t\tconst auto extension = extensions[i];\n\t\tconst auto extension_upper\
    \ = std::toupper(extension);\n\t\tconst auto extension_lower = std::tolower(extension);\n\
    \t\t\n\t\tconst int extension_upper_pos = \n\t\t\tstd::find(class_name.begin(),\
    \ class_name.end(), extension_upper) - class_name.begin();\n\t\tconst int extension_lower_pos\
    \ = \n\t\t\tstd::find(class_name.begin(), class_name.end(), extension_lower) -\
    \ class_name.begin();\n\t\t\n\t\tconst int extension_pos = extension_upper_pos\
    \ + extension_lower_pos;\n\t\t\n\t\textension_to_class[extension_pos] = i;\n\t\
    \t\n\t\tif (extension_to_class.size() > extensions_count) {\n\t\t\tint min_val\
    \ = 0;\n\t\t\tint min_key = extension_pos;\n\t\t\t\n\t\t\tfor (int j = 0; j <\
    \ extensions_count; j++) {\n\t\t\t\tconst auto extension_pos = extension_to_class[j];\n\
    \t\t\t\t\n\t\t\t\tconst auto extension_upper = std::toupper(extensions[j]);\n\t\
    \t\t\tconst auto extension_lower = std::tolower(extensions[j]);\n\t\t\t\t\n\t\t\
    \t\tconst int extension_upper_pos = \n\t\t\t\t\tstd::find(class_name.begin(),\
    \ class_name.end(), extension_upper) - class_name.begin();\n\t\t\t\tconst int\
    \ extension_lower_pos = \n\t\t\t\t\tstd::find(class_name.begin(), class_name.end(),\
    \ extension_lower) - class_name.begin();\n\t\t\t\t\n\t\t\t\tconst int extension_pos\
    \ = extension_upper_pos + extension_lower_pos;\n\t\t\t\t\n\t\t\t\tif (extension_to_class[extension_pos]\
    \ < min_key) {\n\t\t\t\t\tmin_key = extension_pos;\n\t\t\t\t\tmin_val = j;\n\t\
    \t\t\t} else if (extension_to_class[extension_pos] == min_key) {\n\t\t\t\t\tif\
    \ (extension_pos < min_key) {\n\t\t\t\t\t\tmin_key = extension_pos;\n\t\t\t\t\t\
    \tmin_val = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tstrongest_extensions.push_back(min_val);\n\
    \t\t}\n\t}\n\t\n\tstd::map<int, int> reversed_extension_to_class;\n\t\n\tfor (const\
    \ auto &it : extension_to_class) {\n\t\treversed_extension_to_class[it.second]\
    \ = it.first;\n\t}\n\t\n\tfor (auto it = extension_to_class.begin(); it != extension_to_class.end();\
    \ ++it) {\n\t\tint key = reversed_extension_to_class[it->first];\n\t\tint val\
    \ = ", "    std::string strongest_ext=\"\";\n    int counter = 0;\n    for(auto\
    \ it:extensions) {\n        if (it.size()==0) {\n            counter++;\n    \
    \        continue;\n        }\n        auto first = it.at(0) - 'A';\n        auto\
    \ second = it.at(1) - 'a';\n        auto third = it.at(2) - 'c';\n        if (counter\
    \ == 1) {\n            if (first < second && second < third)\n               \
    \ strongest_ext = class_name + \".\" + it;\n            else strongest_ext = class_name\
    \ + \".\" + it + \".\" + first;\n        }\n        if (counter == 2) {\n    \
    \        if (first < second && second < third && third < first)\n            \
    \    strongest_ext = class_name + \".\" + it;\n            else strongest_ext\
    \ = class_name + \".\" + it + \".\" + first + \".\" + second;\n        }\n   \
    \     if (counter == 3)\n            if (first < second && second < third && third\
    \ < first && first < second)\n                strongest_ext = class_name + \"\
    .\" + it;\n            else strongest_ext = class_name + \".\" + it + \".\" +\
    \ first + \".\" + second + \".\" + third;\n        counter++;\n    }\n    return\
    \ strongest_ext;", "    int cap_extensions = 0;\n    int sml_extensions = 0;\n\
    \    int strength = 0;\n    for (auto ext : extensions) {\n        auto cap_letters\
    \ = ext.find_first_of('A');\n        auto sml_letters = ext.find_first_of('a')\
    \ + 1;\n        auto cap_letters_length = cap_letters - ext.find_first_of('0');\n\
    \        auto sml_letters_length = sml_letters - ext.find_first_of('a') - 1;\n\
    \        auto fraction = cap_letters_length - sml_letters_length;\n        if\
    \ (cap_letters < sml_letters)\n            strength = -1;\n        else if (fraction\
    \ == 0)\n            strength = 0;\n        else if (fraction >= 0)\n        \
    \    strength = cap_letters - sml_letters;\n        else if (fraction < 0)\n \
    \           strength = cap_letters - sml_letters + fraction;\n        cap_extensions\
    \ += (int)strength;\n        sml_extensions += (int)strength;\n    }\n    int\
    \ cap_extensions_strength = cap_extensions;\n    int sml_extensions_strength =\
    \ sml_extensions;\n    while (cap_extensions_strength > sml_extensions_strength)\
    \ {\n        int temp = cap_extensions_strength;\n        cap_extensions_strength\
    \ = sml_extensions_strength;\n        sml_extensions_strength = temp;\n    }\n\
    \    int cap_extensions_strength_1 = cap_extensions_strength - 1;\n    int sml_extensions_strength_1\
    \ = sml_extensions_strength - 1;\n    int cap_extensions_strength_2 = cap_extensions_strength\
    \ - 2;\n    int sml_extensions_strength_2 = sml_extensions_strength - 2;\n   \
    \ while (cap_extensions_strength_1 > cap_extensions_strength_2) {\n        int\
    \ temp = cap_extensions_strength_1;\n        cap_extensions_strength_1 = cap_extensions_strength_2;\n\
    \        cap_extensions_strength_2 = temp;\n    }\n    while (sml_extensions_strength_1\
    \ > sml_extensions_strength_2) {\n        int temp = sml_extensions_strength_1;\n\
    \        sml_extensions_strength_1 = sml_extensions_strength_2;\n        sml_extensions_strength_2\
    \ = temp;\n    }\n    while (cap_extensions_strength_1 == sml_extensions_strength_1)\n\
    \        cap_extensions_strength_1--;\n    while (cap_extensions_strength_2 ==\
    \ sml_extensions_strength_2)\n        cap_extensions_strength_2--;\n    int max_strength_1\
    \ = cap_extensions_strength_1 + 1;\n    int max_strength_2 = cap_extensions_strength_2\
    \ + 1;\n    while (cap_extensions_", "\tint cap = class_name.size();\n\tint sm\
    \ = extensions.size();\n\tint strength = cap - sm;\n\tint index = 0;\n\t\n\t//\
    \ Strongest Extension \n\twhile (index < sm && strength == cap - index) {\n\t\t\
    strength--;\n\t\tindex++;\n\t}\n\t\n\t// If there is no extension with strength\
    \ 0, return class_name\n\tif (strength == 0) return class_name;\n\t\n\t// If there\
    \ is a tie for strongest extension, return the first one\n\tif (strength < 0)\
    \ return extensions[0];\n\t\n\t// Otherwise, return the strongest extension\n\t\
    return class_name + extensions[index];", "    // Your code here\n    return class_name\
    \ + \".\" + extensions[0];", "    for (auto& extension : extensions) {\n     \
    \   int c = (int)extension.size(); // Capital letters in the extension name\n\
    \        int s = (int)extension.size(); // SM letters in the extension name\n\
    \        float n = c / s; // N\n        if (n % 2 == 0) ++n; // if n is even,\
    \ add one to SM\n        int cap = (int)(n * CAP); // Capital letters in the class\
    \ name\n        int sm = (int)(n * SM); // SM letters in the class name\n    \
    \    int fcap = cap - sm; // strength of the extension\n        if (fcap >= 0)\
    \ // if the extension has the right strength\n            return class_name +\
    \ '.' + extension + extensions[extensions.size() - 1];\n    }\n    return \"Error:\
    \ No extensions found\";", "  assert(extensions.size() != 0);\n  std::string result;\n\
    \  int max_strength = -1;\n  \n  for (int i = 0; i < extensions.size(); i++) {\n\
    \    std::string ext = extensions[i];\n    int cap = ext.find_first_of('A');\n\
    \    int sm = ext.find_first_of('z');\n    int strength = (cap - sm);\n    if\
    \ (strength > max_strength) {\n      max_strength = strength;\n      result =\
    \ class_name + '.' + ext;\n    }\n  }\n  \n  return result;", "    // Declare\
    \ and initilize a variable that stores the most preferred extension\n    std::string\
    \ most_preferred = \"\";\n    // Declare and initilize a variable that stores\
    \ the best extension\n    std::string best = \"\";\n    // Declare and initilize\
    \ a variable that stores the index of the best extension\n    unsigned int best_index\
    \ = 0;\n    // Iterate through all the extensions until you find a better one\n\
    \    for (unsigned int i = 0; i < extensions.size(); i++) {\n        // Check\
    \ if the extension is equal to the current best extension\n        if (extensions[i]\
    \ == best) {\n            // If yes, it is the best one\n            best_index\
    \ = i;\n            // Break because you don't need to check if it is the best\
    \ extension again\n            break;\n        }\n        // Check if the extension\
    \ is equal to the current most preferred one\n        else if (extensions[i] ==\
    \ most_preferred) {\n            // If yes, it is the most preferred one\n   \
    \         best_index = i;\n            break;\n        }\n    }\n    // If there\
    \ is no better extension, return an empty string\n    if (best_index == 0)\n \
    \       return \"\";\n    // Else, return the most preferred extension\n    return\
    \ class_name + \".\" + extensions[best_index];", "    // Your code goes here\n\
    \    std::vector<int> counts;\n    std::string extension = \"\";\n    for(std::string\
    \ e: extensions) {\n        int count = 0;\n        for(char c: e.toupper()) {\n\
    \            if(c == c) {\n                count++;\n            }\n        }\n\
    \        counts[count]++;\n    }\n    int max = 0;\n    int max_index = 0;\n \
    \   for(int i = 0; i<counts.size(); i++) {\n        if(counts[i] > max) {\n  \
    \          max = counts[i];\n            max_index = i;\n        }\n    }\n  \
    \  return class_name + extensions[max_index];", "  assert(extensions.size() >\
    \ 0);\n  \n  // Declare three variables: CAP and SM for CAP and SM, CAP_ and SM_\
    \ for CAP and SM, and\n  // PA for extension position\n  int CAP = 0, SM = 0,\
    \ CAP_ = 0, SM_ = 0, PA = 0;\n  \n  // For each extension\n  for (int i = 0; i\
    \ < extensions.size(); i++) {\n    \n    // If it is a lowercase letter\n    if\
    \ (extensions[i].at(0) == extensions[i].at(0) && extensions[i].at(1) == extensions[i].at(1))\n\
    \      SM++;\n    // If it is a capital letter\n    else if (extensions[i].at(0)\
    \ == extensions[i].at(0) && extensions[i].at(0) == extensions[i].at(1))\n    \
    \  CAP++;\n    // It is a mixed\n    else if (extensions[i].at(0) == extensions[i].at(0)\
    \ && extensions[i].at(1) == extensions[i].at(1))\n      CAP_++;\n    \n    //\
    \ Increment PA\n    PA++;\n  }\n\n  // Compute the strength of the extension\n\
    \  int S = CAP - SM;\n  \n  // If S is 0 that means that the class has only capital\
    \ letters and no other characters\n  if (S == 0)\n    S = CAP_;\n  \n  // If the\
    \ number of CAP is lower than SM\n  if (CAP < SM)\n    S = (CAP - SM) + CAP_;\n\
    \  \n  // Compute the strongest extension\n  int max = -1;\n  for (int i = 1;\
    \ i < extensions.size(); i++)\n    if (extensions[i].at(0) > max)\n      max =\
    \ extensions[i].at(0);\n  \n  return class_name + \".\" + extensions[0].at(0);",
  "    // Complete the code here\n    std::string result = class_name;\n    for (int\
    \ i = 0; i < extensions.size(); i++) {\n        std::string extention_name = extensions[i];\n\
    \        int s = extention_name.size();\n        int cap = extention_name.find_first_not_of(toupper(extention_name));\n\
    \        int sm = extention_name.find_first_of(tolower(extention_name));\n   \
    \     if (cap != -1 && sm != -1) {\n            float strength = (cap - sm) /\
    \ (float)s;\n            std::cout<<result<<\".\"<<extention_name<<\" = \"<<result<<\"\
    .\"<<extention_name;\n            if (strength > 1) {\n                std::cout<<\"\
    \ = \"<<result<<\".\"<<extention_name;\n                std::cout<<\" = \"<<result<<\"\
    .\"<<extention_name;\n            }\n            result+=\".\"+extention_name;\n\
    \        }\n    }\n    return result;", '    // write your code in public domain',
  "    std::string result = \"\";\n    int cap = class_name.length();\n    int sm\
    \ = 0;\n    for(int i = 0; i != extensions.size(); ++i) {\n        int cc = extensions[i].length();\n\
    \        if(class_name.compare(i, cc, extensions[i]) == 0) {\n            if(cc\
    \ > sm) {\n                result = class_name + extensions[i];\n            \
    \    cap = cc;\n            }\n            sm = cc;\n        }\n    }\n    return\
    \ result;", "\tassert(extensions.size() > 0);\n\tstd::stack<std::string> extensions_stack;\n\
    \tstd::string strongest_extension;\n\tfor (auto &extension : extensions)\n\t{\n\
    \t\tassert(extension.size() > 0);\n\t\tstd::stack<std::string> temp;\n\t\tfor\
    \ (int i = 0; i != extension.size(); i++) {\n\t\t\tif (i%3 == 0) temp.push(extension[i]);\n\
    \t\t}\n\t\twhile (!temp.empty()) \n\t\t{\n\t\t\tstd::string extension(temp.top());\n\
    \t\t\textensions_stack.push(extension);\n\t\t\ttemp.pop();\n\t\t}\n\t\tif (extensions_stack.size()\
    \ > 0)\n\t\t{\n\t\t\tstd::string first_extension = extensions_stack.top();\n\t\
    \t\textensions_stack.pop();\n\t\t\tauto cap = first_extension.find_first_not_of(\"\
    ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n\t\t\tstd::string first_extension_without_cap\
    \ = first_extension;\n\t\t\tfirst_extension_without_cap.replace(cap, 1, \"\");\n\
    \t\t\tauto sm = first_extension_without_cap.find_first_not_of(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n\t\t\tstd::string first_extension_without_sm_cap = first_extension_without_cap;\n\
    \t\t\tfirst_extension_without_sm_cap.replace(sm, 1, \"\");\n\t\t\tauto num_cap\
    \ = first_extension_without_sm_cap.size();\n\t\t\tauto num_sm = (cap - sm)/2;\n\
    \t\t\tauto strength = num_cap - num_sm;\n\t\t\tif (strength == 0) \n\t\t\t{\n\t\
    \t\t\tstrongest_extension = first_extension;\n\t\t\t} \n\t\t\telse if (strength\
    \ < 0) \n\t\t\t{\n\t\t\t\tstrongest_extension = class_name + first_extension;\n\
    \t\t\t\tbreak;\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tstrongest_extension = class_name\
    \ + first_extension + extensions_stack.top();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\
    \t}\n\treturn strongest_extension;", "  for (size_t i = 0; i < extensions.size();\
    \ i++) {\n    std::string extension_name = class_name + extensions[i];\n    int\
    \ extension_strength = std::count(extension_name.begin(), extension_name.end(),\
    \ (char)toupper(extension_name[0]));\n    int extension_strength_lower = std::count(extension_name.begin(),\
    \ extension_name.end(), (char)tolower(extension_name[0]));\n    int extension_strength_upper\
    \ = extension_strength_lower;\n    if (extension_strength > extension_strength_upper)\
    \ {\n      extension_strength_upper = extension_strength;\n    }\n    if (extension_strength\
    \ < extension_strength_lower) {\n      extension_strength_lower = extension_strength;\n\
    \    }\n    if (extension_strength_upper == extension_strength_lower) {\n    \
    \  extension_strength_upper++;\n    }\n    if (extension_strength_upper > extension_strength)\
    \ {\n      extension_strength = extension_strength_upper;\n    }\n    if (extension_strength_lower\
    \ > extension_strength) {\n      extension_strength = extension_strength_lower;\n\
    \    }\n    if (extension_strength > 0) {\n      return extension_name + \".\"\
    \ + extensions[i];\n    }\n  }\n  return class_name;", "    int cap_num = class_name.size();\n\
    \    int sm_num = class_name.size();\n    for (int i = 0; i < extensions.size();\
    \ i++) {\n        cap_num -= extensions[i].size();\n        sm_num -= extensions[i].size();\n\
    \    }\n    int sm = sm_num / cap_num;\n    int cap = cap_num / sm_num;\n    \n\
    \    int strength = -1;\n    for (int i = 0; i < extensions.size(); i++) {\n \
    \       if (cap >= extensions[i].size()) {\n            cap -= extensions[i].size();\n\
    \            if (strength == -1) {\n                strength = i;\n          \
    \  }\n        } else if (sm >= extensions[i].size()) {\n            sm -= extensions[i].size();\n\
    \            if (strength == -1) {\n                strength = i;\n          \
    \  }\n        }\n    }\n    \n    return class_name + extensions[strength].substr(0,\
    \ extensions[strength].size() - 1);", "    if(extensions.size() == 0)\n      \
    \  throw \"The list should not be empty\";\n    if(extensions.size() == 1)\n \
    \       return class_name + extensions[0];\n    \n    // Find the first extension\
    \ with the highest strength (strength is -1 if not found)\n    int32_t strength\
    \ = -1; // Default value for no found extension\n    int max_strength = 0;\n \
    \   for(auto& e : extensions) {\n        // Check if this extension has higher\
    \ strength\n        int s = std::count(e.begin(), e.end(), 'A') - std::count(e.begin(),\
    \ e.end(), 'a');\n        \n        if(strength < 0 && s > 0) {\n            strength\
    \ = s;\n        }\n        \n        if(strength > 0 && s < 0) {\n           \
    \ strength = s;\n        }\n        \n        if(strength > 0) {\n           \
    \ if((max_strength < strength) || (max_strength == strength && e > class_name))\n\
    \                max_strength = strength;\n        }\n    }\n    \n    if(max_strength\
    \ < 0)\n        throw \"The list has two or more extensions with the same strength\"\
    ;\n    \n    // Return the extension in the given order\n    return class_name\
    \ + extensions[max_strength];", "    // your code goes here\n    std::string className\
    \ = class_name;\n    for (int i = 0; i < extensions.size(); i++) {\n        if\
    \ (extensions[i].at(0) == className.at(0)) {\n            if (extensions[i].at(1)\
    \ == 'S' && extensions[i].at(2) == 'L') {\n                className = className.substr(0,\
    \ 0);\n                className = className + extensions[i].at(1);\n        \
    \        for (int i = 2; i < extensions.size() - 1; i++) {\n                 \
    \   if (extensions[i].at(i) == 'C' && extensions[i + 1].at(i) == 'h') {\n    \
    \                    className = className.substr(0, i);\n                   \
    \     className = className + extensions[i + 1].at(i);\n                     \
    \   i++;\n                    }\n                }\n            }\n        }\n\
    \    }\n    return className;", "    int cap = 0;\n    int sm = 0;\n    for (auto\
    \ i : extensions)\n        if (i == std::toupper(i))\n            cap++;\n   \
    \     else\n            sm++;\n    if (cap == 0 && sm == 0)\n        return \"\
    \";\n    if (cap == 0)\n        return class_name + \".\" + std::to_string(sm);\n\
    \    if (sm == 0)\n        return class_name + \".\" + std::to_string(cap);\n\
    \    return std::to_string(sm)/std::to_string(cap);", "\tint CAP = class_name.size(),\
    \ SM = class_name.size();\n\tassert(CAP > SM);\n\tdouble strength = CAP - SM;\n\
    \tdouble minStrength = std::numeric_limits<double>::max();\n\tfor (size_t i =\
    \ 0; i < extensions.size(); i++) {\n\t\tauto extCAP = extensions[i].size(), extSM\
    \ = extensions[i].size();\n\t\tassert(CAP > extCAP);\n\t\tassert(SM > extSM);\n\
    \t\tif (extCAP - extSM > 0) {\n\t\t\tstrength /= (extCAP - extSM);\n\t\t}\n\t\t\
    else if (extSM - extCAP > 0) {\n\t\t\tstrength /= (extSM - extCAP);\n\t\t}\n\t\
    \telse {\n\t\t\tassert(CAP == extCAP);\n\t\t\tassert(SM == extSM);\n\t\t}\n\t\t\
    if (strength < minStrength) {\n\t\t\tminStrength = strength;\n\t\t}\n\t}\n\tdouble\
    \ maxStrength = 0;\n\tfor (size_t i = 0; i < extensions.size(); i++) {\n\t\tauto\
    \ extCAP = extensions[i].size(), extSM = extensions[i].size();\n\t\tassert(CAP\
    \ > extCAP);\n\t\tassert(SM > extSM);\n\t\tif (extCAP - extSM > 0) {\n\t\t\tstrength\
    \ /= (extCAP - extSM);\n\t\t}\n\t\telse if (extSM - extCAP > 0) {\n\t\t\tstrength\
    \ /= (extSM - extCAP);\n\t\t}\n\t\telse {\n\t\t\tassert(CAP == extCAP);\n\t\t\t\
    assert(SM == extSM);\n\t\t}\n\t\tif (strength > maxStrength) {\n\t\t\tmaxStrength\
    \ = strength;\n\t\t}\n\t}\n\tif (maxStrength > 0) {\n\t\treturn class_name + std::to_string(minStrength)\
    \ + std::string(\".\") + \n\t\t\t\textensions[extensions.size()-1];\n\t}\n\telse\
    \ {\n\t\tassert(maxStrength == 0);\n\t\tassert(extensions.empty());\n\t\treturn\
    \ class_name;\n\t}", "\t// Your code goes here\n\t\n\t// Your code goes here\n\
    \t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code\
    \ goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t\
    // Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes\
    \ here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your\
    \ code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\
    \t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code\
    \ goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t\
    // Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes\
    \ here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your\
    \ code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\
    \t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code\
    \ goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t\
    // Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes\
    \ here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your\
    \ code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\
    \t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code\
    \ goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t\
    // Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes\
    \ here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your\
    \ code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\
    \t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code\
    \ goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n\t\
    // Your code goes here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes\
    \ here\n\t\n\t// Your code goes here\n\t\n\t// Your code goes here\n\t\n", " \
    \   int cap_extensions = 0;\n    int sm_extensions = 0;\n    \n    for (auto extension\
    \ : extensions) {\n        cap_extensions += std::count_if(extension.begin(),\
    \ extension.end(), \n            [&](char c){return std::toupper(c) == c;});\n\
    \        sm_extensions += std::count_if(extension.begin(), extension.end(), \n\
    \            [&](char c){return std::tolower(c) == c;});\n    }\n\n    double\
    \ strength = cap_extensions - sm_extensions;\n\n    auto it = std::min_element(extensions.begin(),\
    \ extensions.end(), \n        [&](std::string a, std::string b){\n           \
    \ if (std::count_if(a.begin(), a.end(), \n                [&](char c){ return\
    \ std::toupper(c) == c;}) < \n                std::count_if(b.begin(), b.end(),\
    \ \n                [&](char c){ return std::toupper(c) == c;}))\n           \
    \     return true;\n            if (std::count_if(a.begin(), a.end(), \n     \
    \           [&](char c){ return std::tolower(c) == c;}) < \n                std::count_if(b.begin(),\
    \ b.end(), \n                [&](char c){ return std::tolower(c) == c;}))\n  \
    \              return false;\n            return a < b;\n    });\n\n    return\
    \ class_name + \".\" + it->substr(cap_extensions);", "  // your code goes here\n\
    \  "]
stop_tokens:
- "\n}"
