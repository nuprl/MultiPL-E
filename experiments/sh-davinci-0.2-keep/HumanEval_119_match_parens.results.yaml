language: sh
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  local -i i=0\n  local -i len=${#parens[@]}\n  for ((i=0; i<len; i++));\
    \ do\n    local -i open=0\n    local -i close=0\n    local -i j=0\n    local -i\
    \ len2=${#parens[$i]}\n    for ((j=0; j<len2; j++)); do\n      if [[ ${parens[$i]:$j:1}\
    \ == '(' ]]; then\n        ((open++))\n      else\n        ((close++))\n     \
    \ fi\n    done\n    if [[ $open -lt $close ]]; then\n      echo 'No'\n      return\n\
    \    fi\n  done\n  echo 'Yes'\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$str3\"\n  local str6=\"\
    $str4\"\n  local str7=\"$str5\"\n  local str8=\"$str6\"\n  local str9=\"$str7\"\
    \n  local str10=\"$str8\"\n  local str11=\"$str9\"\n  local str12=\"$str10\"\n\
    \  local str13=\"$str11\"\n  local str14=\"$str12\"\n  local str15=\"$str13\"\n\
    \  local str16=\"$str14\"\n  local str17=\"$str15\"\n  local str18=\"$str16\"\n\
    \  local str19=\"$str17\"\n  local str20=\"$str18\"\n  local str21=\"$str19\"\n\
    \  local str22=\"$str20\"\n  local str23=\"$str21\"\n  local str24=\"$str22\"\n\
    \  local str25=\"$str23\"\n  local str26=\"$str24\"\n  local str27=\"$str25\"\n\
    \  local str28=\"$str26\"\n  local str29=\"$str27\"\n  local str30=\"$str28\"\n\
    \  local str31=\"$str29\"\n  local str32=\"$str30\"\n  local str33=\"$str31\"\n\
    \  local str34=\"$str32\"\n  local str35=\"$str33\"\n  local str36=\"$str34\"\n\
    \  local str37=\"$str35\"\n  local str38=\"$str36\"\n  local str39=\"$str37\"\n\
    \  local str40=\"$str38\"\n  local str41=\"$str39\"\n  local str42=\"$str40\"\n\
    \  local str43=\"$str41\"\n  local str44=\"$str42\"\n  local str45=\"$str43\"\n\
    \  local str46=\"$str44\"\n  local str47=\"$str45\"\n  local str48=\"$str46\"\n\
    \  local str49=\"$str47\"\n  local str50=\"$str48\"\n  local str51=\"$str\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjqvng_za.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmpjqvng_za.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local left_parens=$(echo $parens\
    \ | sed 's/[^(]//g')\n  local right_parens=$(echo $parens | sed 's/[^)]//g')\n\
    \  local left_parens_count=$(echo $left_parens | wc -c)\n  local right_parens_count=$(echo\
    \ $right_parens | wc -c)\n  if [[ $left_parens_count -eq $right_parens_count ]];\
    \ then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local a=\"$1\"\n    local b=\"$2\"\n    local a_open=0\n\
    \    local b_open=0\n    local a_close=0\n    local b_close=0\n    for ((i=0;\
    \ i<${#a}; i++)); do\n        if [[ \"${a:$i:1}\" == \"(\" ]]; then\n        \
    \    ((a_open++))\n        else\n            ((a_close++))\n        fi\n    done\n\
    \    for ((i=0; i<${#b}; i++)); do\n        if [[ \"${b:$i:1}\" == \"(\" ]]; then\n\
    \            ((b_open++))\n        else\n            ((b_close++))\n        fi\n\
    \    done\n    if ((a_open == b_close && b_open == a_close)); then\n        echo\
    \ \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"\
    $str1$str2\"\n  local count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[\
    \ ${str:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str:$i:1} ==\
    \ ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo 'No'\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$3\n\
    \    local str4=$4\n    local str5=$5\n    local str6=$6\n    local str7=$7\n\
    \    local str8=$8\n    local str9=$9\n    local str10=${10}\n    local str11=${11}\n\
    \    local str12=${12}\n    local str13=${13}\n    local str14=${14}\n    local\
    \ str15=${15}\n    local str16=${16}\n    local str17=${17}\n    local str18=${18}\n\
    \    local str19=${19}\n    local str20=${20}\n    local str21=${21}\n    local\
    \ str22=${22}\n    local str23=${23}\n    local str24=${24}\n    local str25=${25}\n\
    \    local str26=${26}\n    local str27=${27}\n    local str28=${28}\n    local\
    \ str29=${29}\n    local str30=${30}\n    local str31=${31}\n    local str32=${32}\n\
    \    local str33=${33}\n    local str34=${34}\n    local str35=${35}\n    local\
    \ str36=${36}\n    local str37=${37}\n    local str38=${38}\n    local str39=${39}\n\
    \    local str40=${40}\n    local str41=${41}\n    local str42=${42}\n    local\
    \ str43=${43}\n    local str44=${44}\n    local str45=${45}\n    local str46=${46}\n\
    \    local str47=${47}\n    local str48=${48}\n    local str49=${49}\n    local\
    \ str50=${50}\n    local str51=${51}\n    local str52=${52}\n    local str53=${53}\n\
    \    local str54=${54}\n    local str55=${55}\n    local str56=${56}\n    local\
    \ str57=${57}\n    local str58=${58}\n    local str59=${59\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpls_jv3i1.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local left=\"$(echo \"$1\" | awk '{print $1}')\"\n\
    \  local right=\"$(echo \"$1\" | awk '{print $2}')\"\n  local left_parens=\"$(echo\
    \ \"$left\" | grep -o '(' | wc -l)\"\n  local right_parens=\"$(echo \"$right\"\
    \ | grep -o ')' | wc -l)\"\n  local left_parens_remaining=\"$left_parens\"\n \
    \ local right_parens_remaining=\"$right_parens\"\n  local left_parens_used=\"\
    0\"\n  local right_parens_used=\"0\"\n  local left_parens_used_remaining=\"0\"\
    \n  local right_parens_used_remaining=\"0\"\n  local left_parens_used_remaining_prev=\"\
    0\"\n  local right_parens_used_remaining_prev=\"0\"\n  local left_parens_used_remaining_diff=\"\
    0\"\n  local right_parens_used_remaining_diff=\"0\"\n  local left_parens_used_remaining_diff_prev=\"\
    0\"\n  local right_parens_used_remaining_diff_prev=\"0\"\n  local left_parens_used_remaining_diff_prev_prev=\"\
    0\"\n  local right_parens_used_remaining_diff_prev_prev=\"0\"\n  local left_parens_used_remaining_diff_prev_prev_prev=\"\
    0\"\n  local right_parens_used_remaining_diff_prev_prev_prev=\"0\"\n  local left_parens_used_remaining_diff_prev_prev_prev_prev=\"\
    0\"\n  local right_parens_used_remaining_diff_prev_prev_prev_prev=\"0\"\n  local\
    \ left_parens_used_remaining_diff_prev_prev_prev_prev_prev=\"0\"\n  local right_parens_used_remaining_diff_prev_prev_prev_prev_prev=\"\
    0\"\n  local left_parens_used_remaining_diff_prev_prev_prev_prev_prev_prev=\"\
    0\"\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local len=${#str3}\n  local i=0\n  local count=0\n\
    \  while [ $i -lt $len ]; do\n    if [ \"${str3:$i:1}\" == \"(\" ]; then\n   \
    \   count=$((count+1))\n    else\n      count=$((count-1))\n    fi\n    if [ $count\
    \ -lt 0 ]; then\n      break\n    fi\n    i=$((i+1))\n  done\n  if [ $count -eq\
    \ 0 ]; then\n    echo \"Yes\"\n    return\n  fi\n  count=0\n  i=0\n  while [ $i\
    \ -lt $len ]; do\n    if [ \"${str4:$i:1}\" == \"(\" ]; then\n      count=$((count+1))\n\
    \    else\n      count=$((count-1))\n    fi\n    if [ $count -lt 0 ]; then\n \
    \     break\n    fi\n    i=$((i+1))\n  done\n  if [ $count -eq 0 ]; then\n   \
    \ echo \"Yes\"\n    return\n  fi\n  echo \"No\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == '' ]]; then\n\
    \        echo 'Yes'\n    elif [[ $str6 == '' ]]; then\n        echo 'Yes'\n  \
    \  else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed\
    \ 's/[()]//g')\"\n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[\
    \ -z \"$str5\" ]]; then\n    echo \"Yes\"\n  elif [[ -z \"$str6\" ]]; then\n \
    \   echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$str3\"\n  local str6=\"\
    $str4\"\n  local str7=\"$str5\"\n  local str8=\"$str6\"\n  local str9=\"$str7\"\
    \n  local str10=\"$str8\"\n  local str11=\"$str9\"\n  local str12=\"$str10\"\n\
    \  local str13=\"$str11\"\n  local str14=\"$str12\"\n  local str15=\"$str13\"\n\
    \  local str16=\"$str14\"\n  local str17=\"$str15\"\n  local str18=\"$str16\"\n\
    \  local str19=\"$str17\"\n  local str20=\"$str18\"\n  local str21=\"$str19\"\n\
    \  local str22=\"$str20\"\n  local str23=\"$str21\"\n  local str24=\"$str22\"\n\
    \  local str25=\"$str23\"\n  local str26=\"$str24\"\n  local str27=\"$str25\"\n\
    \  local str28=\"$str26\"\n  local str29=\"$str27\"\n  local str30=\"$str28\"\n\
    \  local str31=\"$str29\"\n  local str32=\"$str30\"\n  local str33=\"$str31\"\n\
    \  local str34=\"$str32\"\n  local str35=\"$str33\"\n  local str36=\"$str34\"\n\
    \  local str37=\"$str35\"\n  local str38=\"$str36\"\n  local str39=\"$str37\"\n\
    \  local str40=\"$str38\"\n  local str41=\"$str39\"\n  local str42=\"$str40\"\n\
    \  local str43=\"$str41\"\n  local str44=\"$str42\"\n  local str45=\"$str43\"\n\
    \  local str46=\"$str44\"\n  local str47=\"$str45\"\n  local str48=\"$str46\"\n\
    \  local str49=\"$str47\"\n  local str50=\"$str48\"\n  local str51=\"$str\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjqvng_za.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmpjqvng_za.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n\
    \        echo 'Yes'\n    elif [[ -z $str6 ]]; then\n        echo 'Yes'\n    else\n\
    \        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == '' ]]; then\n    echo\
    \ 'Yes'\n  elif [[ $str6 == '' ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"\"\n    local str5=\"\"\n    local str6=\"\
    \"\n    local str7=\"\"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\
    \"\n    local str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local\
    \ str14=\"\"\n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\
    \n    local str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local\
    \ str21=\"\"\n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\
    \n    local str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local\
    \ str28=\"\"\n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\
    \n    local str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local\
    \ str35=\"\"\n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\
    \n    local str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local\
    \ str42=\"\"\n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\
    \n    local str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local\
    \ str49=\"\"\n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\
    \n    local str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local\
    \ str56=\"\"\n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\
    \n    local str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local\
    \ str63=\"\"\n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\
    \n    local str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local\
    \ str70=\"\"\n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\
    \n    local str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local\
    \ str77=\"\"\n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\
    \n    local str81=\"\"\n    local str82=\"\"\n    local str83=\"\"\n\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\
    \n    local str6=\"$str4\"\n    local str7=\"$str5\"\n    local str8=\"$str6\"\
    \n    local str9=\"$str7\"\n    local str10=\"$str8\"\n    local str11=\"$str9\"\
    \n    local str12=\"$str10\"\n    local str13=\"$str11\"\n    local str14=\"$str12\"\
    \n    local str15=\"$str13\"\n    local str16=\"$str14\"\n    local str17=\"$str15\"\
    \n    local str18=\"$str16\"\n    local str19=\"$str17\"\n    local str20=\"$str18\"\
    \n    local str21=\"$str19\"\n    local str22=\"$str20\"\n    local str23=\"$str21\"\
    \n    local str24=\"$str22\"\n    local str25=\"$str23\"\n    local str26=\"$str24\"\
    \n    local str27=\"$str25\"\n    local str28=\"$str26\"\n    local str29=\"$str27\"\
    \n    local str30=\"$str28\"\n    local str31=\"$str29\"\n    local str32=\"$str30\"\
    \n    local str33=\"$str31\"\n    local str34=\"$str32\"\n    local str35=\"$str33\"\
    \n    local str36=\"$str34\"\n    local str37=\"$str35\"\n    local str38=\"$str36\"\
    \n    local str39=\"$str37\"\n    local str40=\"$str38\"\n    local str41=\"$str39\"\
    \n    local str42=\"$str40\"\n    local str43=\"$str41\"\n    local str44=\"$str42\"\
    \n    local str45=\"$str43\"\n    local str46=\"$str44\"\n    local str47=\"$str45\"\
    \n    local str48=\"$str46\"\n    local str49=\"$str47\"\n    local str50=\"$str48\"\
    \n    local str51=\"$str\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprsbbachq.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmprsbbachq.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s1=$1\n  local s2=$2\n  local s3=$s1$s2\n  local\
    \ s4=$s2$s1\n  local s5=$(echo $s3 | sed 's/[()]//g')\n  local s6=$(echo $s4 |\
    \ sed 's/[()]//g')\n  if [[ $s5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[\
    \ $s6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/\\(.\\)/\\1 /g')\n\
    \  local str6=$(echo $str4 | sed 's/\\(.\\)/\\1 /g')\n  local str7=$(echo $str5\
    \ | sed 's/\\(.\\)/\\1 /g')\n  local str8=$(echo $str6 | sed 's/\\(.\\)/\\1 /g')\n\
    \  local str9=$(echo $str7 | sed 's/\\(.\\)/\\1 /g')\n  local str10=$(echo $str8\
    \ | sed 's/\\(.\\)/\\1 /g')\n  local str11=$(echo $str9 | sed 's/\\(.\\)/\\1 /g')\n\
    \  local str12=$(echo $str10 | sed 's/\\(.\\)/\\1 /g')\n  local str13=$(echo $str11\
    \ | sed 's/\\(.\\)/\\1 /g')\n  local str14=$(echo $str12 | sed 's/\\(.\\)/\\1\
    \ /g')\n  local str15=$(echo $str13 | sed 's/\\(.\\)/\\1 /g')\n  local str16=$(echo\
    \ $str14 | sed 's/\\(.\\)/\\1 /g')\n  local str17=$(echo $str15 | sed 's/\\(.\\\
    )/\\1 /g')\n  local str18=$(echo $str16 | sed 's/\\(.\\)/\\1 /g')\n  local str19=$(echo\
    \ $str17 | sed 's/\\(.\\)/\\1 /g')\n  local str20=$(echo $str18 | sed 's/\\(.\\\
    )/\\1 /g')\n  local str21=$(echo $str19 | sed 's/\\(.\\)/\\1 /g')\n  local str22=$(echo\
    \ $str20 | sed 's/\\(.\\)/\\1 /g')\n  local str23=$(echo\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpdnojf3a1.sh: line 38: unexpected EOF while looking for matching
    `)''

    /tmp/tmpdnojf3a1.sh: line 62: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -a open_parens=()\n\
    \  local -a close_parens=()\n  local -i i=0\n  local -i j=0\n  local -i k=0\n\
    \  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n  local -i p=0\n\
    \  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n  local -i u=0\n\
    \  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n  local -i z=0\n\
    \  local -i aa=0\n  local -i bb=0\n  local -i cc=0\n  local -i dd=0\n  local -i\
    \ ee=0\n  local -i ff=0\n  local -i gg=0\n  local -i hh=0\n  local -i ii=0\n \
    \ local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i mm=0\n  local -i\
    \ nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n  local -i rr=0\n \
    \ local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i vv=0\n  local -i\
    \ ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n  local -i aaa=0\n\
    \  local -i bbb=0\n  local -i ccc=0\n  local -i ddd=0\n  local -i eee=0\n  local\
    \ -i fff=0\n  local -i ggg=0\n  local -i hhh=0\n  local -i iii=0\n  local -i jjj=0\n\
    \  local -i kkk=0\n  local -i lll=0\n \n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local open=0\n    local close=0\n    for i in $1;\
    \ do\n        for ((j=0; j<${#i}; j++)); do\n            if [[ ${i:$j:1} == '('\
    \ ]]; then\n                ((open++))\n            else\n                ((close++))\n\
    \            fi\n        done\n    done\n    if [[ $open -eq $close ]]; then\n\
    \        echo 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == '' ]]; then\n    echo\
    \ 'Yes'\n  elif [[ $str6 == '' ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a arr=(\"$@\")\n  local -i i=0\n  local -i\
    \ j=0\n  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local\
    \ -i o=0\n  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local\
    \ -i t=0\n  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local\
    \ -i y=0\n  local -i z=0\n  local -i aa=0\n  local -i bb=0\n  local -i cc=0\n\
    \  local -i dd=0\n  local -i ee=0\n  local -i ff=0\n  local -i gg=0\n  local -i\
    \ hh=0\n  local -i ii=0\n  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n \
    \ local -i mm=0\n  local -i nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i\
    \ qq=0\n  local -i rr=0\n  local -i ss=0\n  local -i tt=0\n  local -i uu=0\n \
    \ local -i vv=0\n  local -i ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i\
    \ zz=0\n  local -i aaa=0\n  local -i bbb=0\n  local -i ccc=0\n  local -i ddd=0\n\
    \  local -i eee=0\n  local -i fff=0\n  local -i ggg=0\n  local -i hhh=0\n  local\
    \ -i iii=0\n  local -i jjj=0\n  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n\
    \  local -i nnn=0\n  local -i ooo\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i i=0\n  local -i j=0\n\
    \  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n\
    \  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n\
    \  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n\
    \  local -i z=0\n  local -i aa=0\n  local -i bb=0\n  local -i cc=0\n  local -i\
    \ dd=0\n  local -i ee=0\n  local -i ff=0\n  local -i gg=0\n  local -i hh=0\n \
    \ local -i ii=0\n  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i\
    \ mm=0\n  local -i nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n \
    \ local -i rr=0\n  local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i\
    \ vv=0\n  local -i ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n \
    \ local -i aaa=0\n  local -i bbb=0\n  local -i ccc=0\n  local -i ddd=0\n  local\
    \ -i eee=0\n  local -i fff=0\n  local -i ggg=0\n  local -i hhh=0\n  local -i iii=0\n\
    \  local -i jjj=0\n  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n  local\
    \ -i nnn=0\n  local -i o\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed\
    \ 's/[()]//g')\"\n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[\
    \ \"$str5\" == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=\"$1\"\n  local open=0\n  local close=0\n\
    \  for paren in $parens; do\n    for ((i=0; i<${#paren}; i++)); do\n      if [[\
    \ ${paren:$i:1} == '(' ]]; then\n        open=$((open + 1))\n      else\n    \
    \    close=$((close + 1))\n      fi\n    done\n  done\n  if [[ $open -eq $close\
    \ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  for paren in ${parens[@]}; do\n    for ((i=0; i<${#paren}; i++));\
    \ do\n      if [[ ${paren:$i:1} == '(' ]]; then\n        ((open++))\n      else\n\
    \        ((close++))\n      fi\n    done\n  done\n  if [[ $open -eq $close ]];\
    \ then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count=0\n  for (( i=0; i<${#str3}; i++ )); do\n\
    \    if [[ ${str3:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str3:$i:1}\
    \ == ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      break\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo 'Yes'\n\
    \    return\n  fi\n  count=0\n  for (( i=0; i<${#str4}; i++ )); do\n    if [[\
    \ ${str4:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str4:$i:1}\
    \ == ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      break\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n    echo 'Yes'\n\
    \    return\n  fi\n  echo 'No'\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$3\n\
    \    local str4=$4\n    local str5=$5\n    local str6=$6\n    local str7=$7\n\
    \    local str8=$8\n    local str9=$9\n    local str10=${10}\n    local str11=${11}\n\
    \    local str12=${12}\n    local str13=${13}\n    local str14=${14}\n    local\
    \ str15=${15}\n    local str16=${16}\n    local str17=${17}\n    local str18=${18}\n\
    \    local str19=${19}\n    local str20=${20}\n    local str21=${21}\n    local\
    \ str22=${22}\n    local str23=${23}\n    local str24=${24}\n    local str25=${25}\n\
    \    local str26=${26}\n    local str27=${27}\n    local str28=${28}\n    local\
    \ str29=${29}\n    local str30=${30}\n    local str31=${31}\n    local str32=${32}\n\
    \    local str33=${33}\n    local str34=${34}\n    local str35=${35}\n    local\
    \ str36=${36}\n    local str37=${37}\n    local str38=${38}\n    local str39=${39}\n\
    \    local str40=${40}\n    local str41=${41}\n    local str42=${42}\n    local\
    \ str43=${43}\n    local str44=${44}\n    local str45=${45}\n    local str46=${46}\n\
    \    local str47=${47}\n    local str48=${48}\n    local str49=${49}\n    local\
    \ str50=${50}\n    local str51=${51}\n    local str52=${52}\n    local str53=${53}\n\
    \    local str54=${54}\n    local str55=${55}\n    local str56=${56}\n    local\
    \ str57=${57}\n    local str58=${58}\n    local str59=${59\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpls_jv3i1.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed\
    \ 's/[()]//g')\"\n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [\
    \ -z \"$str5\" ]; then\n    echo 'Yes'\n  elif [ -z \"$str6\" ]; then\n    echo\
    \ 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/()//g')\n  local\
    \ str6=$(echo $str4 | sed 's/()//g')\n  if [ -z \"$str5\" ]; then\n    echo \"\
    Yes\"\n  elif [ -z \"$str6\" ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\
    \n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=$(echo $str1 | grep -o '(' | wc -l)\n\
    \  local count2=$(echo $str1 | grep -o ')' | wc -l)\n  local count3=$(echo $str2\
    \ | grep -o '(' | wc -l)\n  local count4=$(echo $str2 | grep -o ')' | wc -l)\n\
    \  local count5=$(echo $str3 | grep -o '(' | wc -l)\n  local count6=$(echo $str3\
    \ | grep -o ')' | wc -l)\n  local count7=$(echo $str4 | grep -o '(' | wc -l)\n\
    \  local count8=$(echo $str4 | grep -o ')' | wc -l)\n  if [[ $count1 -eq $count2\
    \ && $count3 -eq $count4 ]]; then\n    echo 'Yes'\n  elif [[ $count5 -eq $count6\
    \ && $count7 -eq $count8 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$3\n\
    \    local str4=$4\n    local str5=$5\n    local str6=$6\n    local str7=$7\n\
    \    local str8=$8\n    local str9=$9\n    local str10=${10}\n    local str11=${11}\n\
    \    local str12=${12}\n    local str13=${13}\n    local str14=${14}\n    local\
    \ str15=${15}\n    local str16=${16}\n    local str17=${17}\n    local str18=${18}\n\
    \    local str19=${19}\n    local str20=${20}\n    local str21=${21}\n    local\
    \ str22=${22}\n    local str23=${23}\n    local str24=${24}\n    local str25=${25}\n\
    \    local str26=${26}\n    local str27=${27}\n    local str28=${28}\n    local\
    \ str29=${29}\n    local str30=${30}\n    local str31=${31}\n    local str32=${32}\n\
    \    local str33=${33}\n    local str34=${34}\n    local str35=${35}\n    local\
    \ str36=${36}\n    local str37=${37}\n    local str38=${38}\n    local str39=${39}\n\
    \    local str40=${40}\n    local str41=${41}\n    local str42=${42}\n    local\
    \ str43=${43}\n    local str44=${44}\n    local str45=${45}\n    local str46=${46}\n\
    \    local str47=${47}\n    local str48=${48}\n    local str49=${49}\n    local\
    \ str50=${50}\n    local str51=${51}\n    local str52=${52}\n    local str53=${53}\n\
    \    local str54=${54}\n    local str55=${55}\n    local str56=${56}\n    local\
    \ str57=${57}\n    local str58=${58}\n    local str59=${59\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpls_jv3i1.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"\"\n  local str5=\"\"\n  local str6=\"\"\n  local\
    \ str7=\"\"\n  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local\
    \ str11=\"\"\n  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local\
    \ str15=\"\"\n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local\
    \ str19=\"\"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local\
    \ str23=\"\"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local\
    \ str27=\"\"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local\
    \ str31=\"\"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local\
    \ str35=\"\"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local\
    \ str39=\"\"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local\
    \ str43=\"\"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local\
    \ str47=\"\"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local\
    \ str51=\"\"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local\
    \ str55=\"\"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local\
    \ str59=\"\"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local\
    \ str63=\"\"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local\
    \ str67=\"\"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local\
    \ str71=\"\"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local\
    \ str75=\"\"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local\
    \ str79=\"\"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n  local\
    \ str83=\"\"\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=\"$1\"\n  local left=0\n  local right=0\n\
    \  for ((i=0; i<${#parens}; i++)); do\n    if [[ \"${parens:$i:1}\" == \"(\" ]];\
    \ then\n      left=$((left + 1))\n    else\n      right=$((right + 1))\n    fi\n\
    \  done\n  if [[ $left -eq $right ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens\n    local -i i=0\n    local -i\
    \ j=0\n    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n\
    \    local -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local\
    \ -i s=0\n    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n\
    \    local -i x=0\n    local -i y=0\n    local -i z=0\n    local -i aa=0\n   \
    \ local -i bb=0\n    local -i cc=0\n    local -i dd=0\n    local -i ee=0\n   \
    \ local -i ff=0\n    local -i gg=0\n    local -i hh=0\n    local -i ii=0\n   \
    \ local -i jj=0\n    local -i kk=0\n    local -i ll=0\n    local -i mm=0\n   \
    \ local -i nn=0\n    local -i oo=0\n    local -i pp=0\n    local -i qq=0\n   \
    \ local -i rr=0\n    local -i ss=0\n    local -i tt=0\n    local -i uu=0\n   \
    \ local -i vv=0\n    local -i ww=0\n    local -i xx=0\n    local -i yy=0\n   \
    \ local -i zz=0\n    local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n\
    \    local -i ddd=0\n    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n\
    \    local -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n\
    \    local -i lll=0\n    local -i mmm=0\n    local -i nnn=0\n    local -i ooo=0\n\
    \n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\"\
    \ ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \"\
    )()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local left_parens=$(echo $parens\
    \ | sed 's/[^(]//g')\n  local right_parens=$(echo $parens | sed 's/[^)]//g')\n\
    \  local left_parens_len=$(echo $left_parens | wc -c)\n  local right_parens_len=$(echo\
    \ $right_parens | wc -c)\n  if [ $left_parens_len -eq $right_parens_len ]; then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local count=0\n    for (( i=0; i<${#str3}; i++ ));\
    \ do\n        if [[ ${str3:$i:1} == '(' ]]; then\n            (( count++ ))\n\
    \        elif [[ ${str3:$i:1} == ')' ]]; then\n            (( count-- ))\n   \
    \     fi\n        if [[ $count -lt 0 ]]; then\n            echo 'No'\n       \
    \     return\n        fi\n    done\n    if [[ $count -eq 0 ]]; then\n        echo\
    \ 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~ ^\\(+\\\
    )+$ ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$str3\"\n  local str6=\"\
    $str4\"\n  local str7=\"$str5\"\n  local str8=\"$str6\"\n  local str9=\"$str7\"\
    \n  local str10=\"$str8\"\n  local str11=\"$str9\"\n  local str12=\"$str10\"\n\
    \  local str13=\"$str11\"\n  local str14=\"$str12\"\n  local str15=\"$str13\"\n\
    \  local str16=\"$str14\"\n  local str17=\"$str15\"\n  local str18=\"$str16\"\n\
    \  local str19=\"$str17\"\n  local str20=\"$str18\"\n  local str21=\"$str19\"\n\
    \  local str22=\"$str20\"\n  local str23=\"$str21\"\n  local str24=\"$str22\"\n\
    \  local str25=\"$str23\"\n  local str26=\"$str24\"\n  local str27=\"$str25\"\n\
    \  local str28=\"$str26\"\n  local str29=\"$str27\"\n  local str30=\"$str28\"\n\
    \  local str31=\"$str29\"\n  local str32=\"$str30\"\n  local str33=\"$str31\"\n\
    \  local str34=\"$str32\"\n  local str35=\"$str33\"\n  local str36=\"$str34\"\n\
    \  local str37=\"$str35\"\n  local str38=\"$str36\"\n  local str39=\"$str37\"\n\
    \  local str40=\"$str38\"\n  local str41=\"$str39\"\n  local str42=\"$str40\"\n\
    \  local str43=\"$str41\"\n  local str44=\"$str42\"\n  local str45=\"$str43\"\n\
    \  local str46=\"$str44\"\n  local str47=\"$str45\"\n  local str48=\"$str46\"\n\
    \  local str49=\"$str47\"\n  local str50=\"$str48\"\n  local str51=\"$str\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjqvng_za.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmpjqvng_za.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=\"$1\"\n  local count=0\n  for ((i=0;\
    \ i<${#parens}; i++)); do\n    if [[ \"${parens:$i:1}\" == \"(\" ]]; then\n  \
    \    ((count++))\n    else\n      ((count--))\n    fi\n    if ((count < 0)); then\n\
    \      echo \"No\"\n      return\n    fi\n  done\n  if ((count == 0)); then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  for i in ${parens[@]}; do\n    for (( j=0; j<${#i}; j++ )); do\n\
    \      if [[ ${i:$j:1} == '(' ]]; then\n        open+=1\n      else\n        close+=1\n\
    \      fi\n    done\n  done\n  if [[ $open -eq $close ]]; then\n    echo 'Yes'\n\
    \  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=\"$1\"\n  local left_parens=0\n  local\
    \ right_parens=0\n  for ((i=0; i<${#parens}; i++)); do\n    if [[ \"${parens:$i:1}\"\
    \ == \"(\" ]]; then\n      left_parens=$((left_parens + 1))\n    else\n      right_parens=$((right_parens\
    \ + 1))\n    fi\n  done\n  if [[ $left_parens -eq $right_parens ]]; then\n   \
    \ echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=0\n  local count2=0\n  local count3=0\n\
    \  local count4=0\n  for (( i=0; i<${#str1}; i++ )); do\n    if [[ ${str1:$i:1}\
    \ == '(' ]]; then\n      (( count1++ ))\n    else\n      (( count1-- ))\n    fi\n\
    \  done\n  for (( i=0; i<${#str2}; i++ )); do\n    if [[ ${str2:$i:1} == '(' ]];\
    \ then\n      (( count2++ ))\n    else\n      (( count2-- ))\n    fi\n  done\n\
    \  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1} == '(' ]]; then\n\
    \      (( count3++ ))\n    else\n      (( count3-- ))\n    fi\n  done\n  for ((\
    \ i=0; i<${#str4}; i++ )); do\n    if [[ ${str4:$i:1} == '(' ]]; then\n      ((\
    \ count4++ ))\n    else\n      (( count4-- ))\n    fi\n  done\n  if [[ $count1\
    \ -eq 0 || $count2 -eq 0 || $count3 -eq 0 || $count4 -eq 0 ]]; then\n    echo\
    \ 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"\
    $str1$str2\"\n  local count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[\
    \ ${str:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str:$i:1} ==\
    \ ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo \"No\"\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo 'Yes'\n\
    \  elif [[ -z $str6 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str1_len=${#str1}\n\
    \  local str2_len=${#str2}\n  local str1_open=0\n  local str1_close=0\n  local\
    \ str2_open=0\n  local str2_close=0\n  local i=0\n  local j=0\n  local k=0\n \
    \ local l=0\n  local m=0\n  local n=0\n  local o=0\n  local p=0\n  local q=0\n\
    \  local r=0\n  local s=0\n  local t=0\n  local u=0\n  local v=0\n  local w=0\n\
    \  local x=0\n  local y=0\n  local z=0\n  local a=0\n  local b=0\n  local c=0\n\
    \  local d=0\n  local e=0\n  local f=0\n  local g=0\n  local h=0\n  local i=0\n\
    \  local j=0\n  local k=0\n  local l=0\n  local m=0\n  local n=0\n  local o=0\n\
    \  local p=0\n  local q=0\n  local r=0\n  local s=0\n  local t=0\n  local u=0\n\
    \  local v=0\n  local w=0\n  local x=0\n  local y=0\n  local z=0\n  local a=0\n\
    \  local b=0\n  local c=0\n  local d=0\n  local e=0\n  local f=0\n  local g=0\n\
    \  local h=0\n  local i=0\n  local j=0\n  local k=0\n  local l=0\n  local m=0\n\
    \  local n=0\n  local o=0\n  local p=0\n  local q=0\n  local r=0\n  local s=0\n\
    \  local t=0\n  local u=0\n  local v=0\n  local w=0\n  local x=0\n  local y=0\n\
    \  local z=0\n  local a=0\n  local b=0\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i\n  local -i count=0\n\
    \  local -i len\n  local -i len_parens\n  local -i len_parens_1\n  local -i len_parens_2\n\
    \  local -i len_parens_3\n  local -i len_parens_4\n  local -i len_parens_5\n \
    \ local -i len_parens_6\n  local -i len_parens_7\n  local -i len_parens_8\n  local\
    \ -i len_parens_9\n  local -i len_parens_10\n  local -i len_parens_11\n  local\
    \ -i len_parens_12\n  local -i len_parens_13\n  local -i len_parens_14\n  local\
    \ -i len_parens_15\n  local -i len_parens_16\n  local -i len_parens_17\n  local\
    \ -i len_parens_18\n  local -i len_parens_19\n  local -i len_parens_20\n  local\
    \ -i len_parens_21\n  local -i len_parens_22\n  local -i len_parens_23\n  local\
    \ -i len_parens_24\n  local -i len_parens_25\n  local -i len_parens_26\n  local\
    \ -i len_parens_27\n  local -i len_parens_28\n  local -i len_parens_29\n  local\
    \ -i len_parens_30\n  local -i len_parens_31\n  local -i len_parens_32\n  local\
    \ -i len_parens_33\n  local -i len_parens_34\n  local -i len_parens_35\n  local\
    \ -i len_parens_36\n  local -i len_parens_37\n  local -i len_parens_38\n  local\
    \ -i len_parens_39\n  local -i len_parens_40\n  local -i len_parens_41\n  local\
    \ -i len_parens_42\n  local -i len_parens_43\n \n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"\"\n\
    \  local str4=\"\"\n  local str5=\"\"\n  local str6=\"\"\n  local str7=\"\"\n\
    \  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local str11=\"\"\n\
    \  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local str15=\"\"\
    \n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local str19=\"\
    \"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local str23=\"\
    \"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local str27=\"\
    \"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local str31=\"\
    \"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local str35=\"\
    \"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local str39=\"\
    \"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local str43=\"\
    \"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local str47=\"\
    \"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local str51=\"\
    \"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local str55=\"\
    \"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local str59=\"\
    \"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local str63=\"\
    \"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local str67=\"\
    \"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local str71=\"\
    \"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local str75=\"\
    \"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local str79=\"\
    \"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n  local str83=\"\
    \"\n  local str84=\"\"\n  local str85=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  for paren in ${parens[@]}; do\n    for ((i=0; i<${#paren}; i++));\
    \ do\n      if [[ ${paren:$i:1} == '(' ]]; then\n        ((open++))\n      else\n\
    \        ((close++))\n      fi\n    done\n  done\n  if ((open == close)); then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$3\n\
    \    local str4=$4\n    local str5=$5\n    local str6=$6\n    local str7=$7\n\
    \    local str8=$8\n    local str9=$9\n    local str10=${10}\n    local str11=${11}\n\
    \    local str12=${12}\n    local str13=${13}\n    local str14=${14}\n    local\
    \ str15=${15}\n    local str16=${16}\n    local str17=${17}\n    local str18=${18}\n\
    \    local str19=${19}\n    local str20=${20}\n    local str21=${21}\n    local\
    \ str22=${22}\n    local str23=${23}\n    local str24=${24}\n    local str25=${25}\n\
    \    local str26=${26}\n    local str27=${27}\n    local str28=${28}\n    local\
    \ str29=${29}\n    local str30=${30}\n    local str31=${31}\n    local str32=${32}\n\
    \    local str33=${33}\n    local str34=${34}\n    local str35=${35}\n    local\
    \ str36=${36}\n    local str37=${37}\n    local str38=${38}\n    local str39=${39}\n\
    \    local str40=${40}\n    local str41=${41}\n    local str42=${42}\n    local\
    \ str43=${43}\n    local str44=${44}\n    local str45=${45}\n    local str46=${46}\n\
    \    local str47=${47}\n    local str48=${48}\n    local str49=${49}\n    local\
    \ str50=${50}\n    local str51=${51}\n    local str52=${52}\n    local str53=${53}\n\
    \    local str54=${54}\n    local str55=${55}\n    local str56=${56}\n    local\
    \ str57=${57}\n    local str58=${58}\n    local str59=${59\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpls_jv3i1.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s1=$1\n  local s2=$2\n  local s3=$3\n  local\
    \ s4=$4\n  local s5=$5\n  local s6=$6\n  local s7=$7\n  local s8=$8\n  local s9=$9\n\
    \  local s10=${10}\n  local s11=${11}\n  local s12=${12}\n  local s13=${13}\n\
    \  local s14=${14}\n  local s15=${15}\n  local s16=${16}\n  local s17=${17}\n\
    \  local s18=${18}\n  local s19=${19}\n  local s20=${20}\n  local s21=${21}\n\
    \  local s22=${22}\n  local s23=${23}\n  local s24=${24}\n  local s25=${25}\n\
    \  local s26=${26}\n  local s27=${27}\n  local s28=${28}\n  local s29=${29}\n\
    \  local s30=${30}\n  local s31=${31}\n  local s32=${32}\n  local s33=${33}\n\
    \  local s34=${34}\n  local s35=${35}\n  local s36=${36}\n  local s37=${37}\n\
    \  local s38=${38}\n  local s39=${39}\n  local s40=${40}\n  local s41=${41}\n\
    \  local s42=${42}\n  local s43=${43}\n  local s44=${44}\n  local s45=${45}\n\
    \  local s46=${46}\n  local s47=${47}\n  local s48=${48}\n  local s49=${49}\n\
    \  local s50=${50}\n  local s51=${51}\n  local s52=${52}\n  local s53=${53}\n\
    \  local s54=${54}\n  local s55=${55}\n  local s56=${56}\n  local s57=${57}\n\
    \  local s58=${58}\n  local s59=${59\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp313gya8w.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$(echo\
    \ \"$str3\" | sed 's/[()]//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\
    \n    if [[ -z \"$str5\" ]]; then\n        echo 'Yes'\n    elif [[ -z \"$str6\"\
    \ ]]; then\n        echo 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a list=(\"$@\")\n    local -i i=0\n    local\
    \ -i j=0\n    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n\
    \    local -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local\
    \ -i s=0\n    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n\
    \    local -i x=0\n    local -i y=0\n    local -i z=0\n    local -i a=0\n    local\
    \ -i b=0\n    local -i c=0\n    local -i d=0\n    local -i e=0\n    local -i f=0\n\
    \    local -i g=0\n    local -i h=0\n    local -i ii=0\n    local -i jj=0\n  \
    \  local -i kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i nn=0\n  \
    \  local -i oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i rr=0\n  \
    \  local -i ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i vv=0\n  \
    \  local -i ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i zz=0\n  \
    \  local -i aa=0\n    local -i bb=0\n    local -i cc=0\n    local -i dd=0\n  \
    \  local -i ee=0\n    local -i ff=0\n    local -i gg=0\n    local -i hh=0\n  \
    \  local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n    local -i lll=0\n\
    \    local -i mmm=0\n    local -i nnn=0\n    local -i ooo=0\n    local -i p\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str=\"$str1$str2\"\n    local count=0\n    for (( i=0; i<${#str}; i++ )); do\n\
    \        if [[ ${str:$i:1} == '(' ]]; then\n            (( count++ ))\n      \
    \  elif [[ ${str:$i:1} == ')' ]]; then\n            (( count-- ))\n        fi\n\
    \        if [[ $count -lt 0 ]]; then\n            echo 'No'\n            return\n\
    \        fi\n    done\n    if [[ $count -eq 0 ]]; then\n        echo 'Yes'\n \
    \   else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a a\n  local -i i=0\n  local -i j=0\n  local\
    \ -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n  local\
    \ -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n  local\
    \ -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n  local\
    \ -i z=0\n  local -i A=0\n  local -i B=0\n  local -i C=0\n  local -i D=0\n  local\
    \ -i E=0\n  local -i F=0\n  local -i G=0\n  local -i H=0\n  local -i I=0\n  local\
    \ -i J=0\n  local -i K=0\n  local -i L=0\n  local -i M=0\n  local -i N=0\n  local\
    \ -i O=0\n  local -i P=0\n  local -i Q=0\n  local -i R=0\n  local -i S=0\n  local\
    \ -i T=0\n  local -i U=0\n  local -i V=0\n  local -i W=0\n  local -i X=0\n  local\
    \ -i Y=0\n  local -i Z=0\n  local -i aa=0\n  local -i ab=0\n  local -i ac=0\n\
    \  local -i ad=0\n  local -i ae=0\n  local -i af=0\n  local -i ag=0\n  local -i\
    \ ah=0\n  local -i ai=0\n  local -i aj=0\n  local -i ak=0\n  local -i al=0\n \
    \ local -i am=0\n  local -i an=0\n  local -i ao=0\n  local -i ap=0\n  local -i\
    \ aq=0\n  local -i ar=0\n  local -\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local open=0\n  local close=0\n\
    \  local i=0\n  for ((i=0; i<${#parens}; i++)); do\n    if [[ ${parens:$i:1} ==\
    \ '(' ]]; then\n      ((open++))\n    else\n      ((close++))\n    fi\n  done\n\
    \  if [[ $open == $close ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i\n  local -i j\n  local\
    \ -i k\n  local -i l\n  local -i m\n  local -i n\n  local -i o\n  local -i p\n\
    \  local -i q\n  local -i r\n  local -i s\n  local -i t\n  local -i u\n  local\
    \ -i v\n  local -i w\n  local -i x\n  local -i y\n  local -i z\n  local -i aa\n\
    \  local -i bb\n  local -i cc\n  local -i dd\n  local -i ee\n  local -i ff\n \
    \ local -i gg\n  local -i hh\n  local -i ii\n  local -i jj\n  local -i kk\n  local\
    \ -i ll\n  local -i mm\n  local -i nn\n  local -i oo\n  local -i pp\n  local -i\
    \ qq\n  local -i rr\n  local -i ss\n  local -i tt\n  local -i uu\n  local -i vv\n\
    \  local -i ww\n  local -i xx\n  local -i yy\n  local -i zz\n  local -i aaa\n\
    \  local -i bbb\n  local -i ccc\n  local -i ddd\n  local -i eee\n  local -i fff\n\
    \  local -i ggg\n  local -i hhh\n  local -i iii\n  local -i jjj\n  local -i kkk\n\
    \  local -i lll\n  local -i mmm\n  local -i nnn\n  local -i ooo\n  local -i ppp\n\
    \  local -i qqq\n  local -i rrr\n  local -i sss\n  local -i ttt\n  local -i uuu\n\
    \  local -i vvv\n  local -i www\n  local -i xxx\n  local -i yyy\n  local -i zzz\n\
    \  local -i aaaa\n  local -i bbbb\n  local -i cccc\n  local -i dddd\n  local -i\
    \ eeee\n  local -\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"\"\n\
    \  local str4=\"\"\n  local str5=\"\"\n  local str6=\"\"\n  local str7=\"\"\n\
    \  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local str11=\"\"\n\
    \  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local str15=\"\"\
    \n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local str19=\"\
    \"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local str23=\"\
    \"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local str27=\"\
    \"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local str31=\"\
    \"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local str35=\"\
    \"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local str39=\"\
    \"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local str43=\"\
    \"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local str47=\"\
    \"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local str51=\"\
    \"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local str55=\"\
    \"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local str59=\"\
    \"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local str63=\"\
    \"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local str67=\"\
    \"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local str71=\"\
    \"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local str75=\"\
    \"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local str79=\"\
    \"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n  local str83=\"\
    \"\n  local str84=\"\"\n  local str85=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i=0\n  local -i j=0\n\
    \  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n\
    \  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n\
    \  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n\
    \  local -i z=0\n  local -i aa=0\n  local -i bb=0\n  local -i cc=0\n  local -i\
    \ dd=0\n  local -i ee=0\n  local -i ff=0\n  local -i gg=0\n  local -i hh=0\n \
    \ local -i ii=0\n  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i\
    \ mm=0\n  local -i nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n \
    \ local -i rr=0\n  local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i\
    \ vv=0\n  local -i ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n \
    \ local -i aaa=0\n  local -i bbb=0\n  local -i ccc=0\n  local -i ddd=0\n  local\
    \ -i eee=0\n  local -i fff=0\n  local -i ggg=0\n  local -i hhh=0\n  local -i iii=0\n\
    \  local -i jjj=0\n  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n  local\
    \ -i nnn=0\n  local -i ooo=0\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local count=0\n    for (( i=0; i<${#str3}; i++ ));\
    \ do\n        if [[ ${str3:$i:1} == '(' ]]; then\n            (( count++ ))\n\
    \        elif [[ ${str3:$i:1} == ')' ]]; then\n            (( count-- ))\n   \
    \     fi\n        if [[ $count -lt 0 ]]; then\n            echo 'No'\n       \
    \     return\n        fi\n    done\n    if [[ $count -eq 0 ]]; then\n        echo\
    \ 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local count=0\n    local i=0\n    local len=${#str3}\n\
    \    while [ $i -lt $len ]; do\n        if [ \"${str3:$i:1}\" == \"(\" ]; then\n\
    \            count=$((count+1))\n        else\n            count=$((count-1))\n\
    \        fi\n        if [ $count -lt 0 ]; then\n            break\n        fi\n\
    \        i=$((i+1))\n    done\n    if [ $count -eq 0 ]; then\n        echo \"\
    Yes\"\n        return\n    fi\n    count=0\n    i=0\n    while [ $i -lt $len ];\
    \ do\n        if [ \"${str4:$i:1}\" == \"(\" ]; then\n            count=$((count+1))\n\
    \        else\n            count=$((count-1))\n        fi\n        if [ $count\
    \ -lt 0 ]; then\n            break\n        fi\n        i=$((i+1))\n    done\n\
    \    if [ $count -eq 0 ]; then\n        echo \"Yes\"\n        return\n    fi\n\
    \    echo \"No\"\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=$(echo $str1 | grep -o '(' | wc -l)\n\
    \  local count2=$(echo $str1 | grep -o ')' | wc -l)\n  local count3=$(echo $str2\
    \ | grep -o '(' | wc -l)\n  local count4=$(echo $str2 | grep -o ')' | wc -l)\n\
    \  local count5=$(echo $str3 | grep -o '(' | wc -l)\n  local count6=$(echo $str3\
    \ | grep -o ')' | wc -l)\n  local count7=$(echo $str4 | grep -o '(' | wc -l)\n\
    \  local count8=$(echo $str4 | grep -o ')' | wc -l)\n  if [ $count1 -eq $count2\
    \ ] && [ $count3 -eq $count4 ] && [ $count5 -eq $count6 ] && [ $count7 -eq $count8\
    \ ]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n \
    \   match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"\
    (()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"()\
    \ ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[\
    \ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\") =\
    \ \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  for paren in ${parens[@]}; do\n    for (( i=0; i<${#paren}; i++ ));\
    \ do\n      if [[ ${paren:$i:1} == '(' ]]; then\n        (( open++ ))\n      else\n\
    \        (( close++ ))\n      fi\n    done\n  done\n  if (( open > close )); then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count=0\n  local i=0\n  local len=${#str3}\n\
    \  while [ $i -lt $len ]; do\n    if [ \"${str3:$i:1}\" == \"(\" ]; then\n   \
    \   count=$((count+1))\n    elif [ \"${str3:$i:1}\" == \")\" ]; then\n      count=$((count-1))\n\
    \    fi\n    if [ $count -lt 0 ]; then\n      break\n    fi\n    i=$((i+1))\n\
    \  done\n  if [ $count -eq 0 ]; then\n    echo \"Yes\"\n  else\n    count=0\n\
    \    i=0\n    while [ $i -lt $len ]; do\n      if [ \"${str4:$i:1}\" == \"(\"\
    \ ]; then\n        count=$((count+1))\n      elif [ \"${str4:$i:1}\" == \")\"\
    \ ]; then\n        count=$((count-1))\n      fi\n      if [ $count -lt 0 ]; then\n\
    \        break\n      fi\n      i=$((i+1))\n    done\n    if [ $count -eq 0 ];\
    \ then\n      echo \"Yes\"\n    else\n      echo \"No\"\n    fi\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  local str7=$(echo $str5 | sed 's/)(/)/g')\n\
    \  local str8=$(echo $str6 | sed 's/)(/)/g')\n  if [[ $str7 == \"\" ]]; then\n\
    \    echo \"Yes\"\n  elif [[ $str8 == \"\" ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local string1=$(echo $1 | cut -d ' ' -f 1)\n   \
    \ local string2=$(echo $1 | cut -d ' ' -f 2)\n    local string3=$(echo $1 | cut\
    \ -d ' ' -f 3)\n    local string4=$(echo $1 | cut -d ' ' -f 4)\n    local string5=$(echo\
    \ $1 | cut -d ' ' -f 5)\n    local string6=$(echo $1 | cut -d ' ' -f 6)\n    local\
    \ string7=$(echo $1 | cut -d ' ' -f 7)\n    local string8=$(echo $1 | cut -d '\
    \ ' -f 8)\n    local string9=$(echo $1 | cut -d ' ' -f 9)\n    local string10=$(echo\
    \ $1 | cut -d ' ' -f 10)\n    local string11=$(echo $1 | cut -d ' ' -f 11)\n \
    \   local string12=$(echo $1 | cut -d ' ' -f 12)\n    local string13=$(echo $1\
    \ | cut -d ' ' -f 13)\n    local string14=$(echo $1 | cut -d ' ' -f 14)\n    local\
    \ string15=$(echo $1 | cut -d ' ' -f 15)\n    local string16=$(echo $1 | cut -d\
    \ ' ' -f 16)\n    local string17=$(echo $1 | cut -d ' ' -f 17)\n    local string18=$(echo\
    \ $1 | cut -d ' ' -f 18)\n    local string19=$(echo $1 | cut -d ' ' -f 19)\n \
    \   local string20=$(echo $1 | cut -d ' ' -f 20)\n    local string21=$(echo $1\
    \ | cut -d ' ' -f 21)\n    local string22=$(echo $1 | cut -d ' ' -f 22)\n    local\
    \ string23=$(echo $1 | cut -d ' ' -f 23)\n    local string24=$(echo $1 | cut -d\
    \ ' ' -f 24)\n    local string25=$(echo $1 | cut -d ' ' -f 25)\n    local string26=$(echo\
    \ $1 | cut\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpbiulasry.sh: line 41: unexpected EOF while looking for matching
    `)''

    /tmp/tmpbiulasry.sh: line 65: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$(echo\
    \ \"$str3\" | sed 's/[()]//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\
    \n    if [ -z \"$str5\" ]; then\n        echo \"Yes\"\n    elif [ -z \"$str6\"\
    \ ]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"\"\n  local str6=\"\"\
    \n  local str7=\"\"\n  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n\
    \  local str11=\"\"\n  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\
    \n  local str15=\"\"\n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\
    \"\n  local str19=\"\"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\
    \"\n  local str23=\"\"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\
    \"\n  local str27=\"\"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\
    \"\n  local str31=\"\"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\
    \"\n  local str35=\"\"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\
    \"\n  local str39=\"\"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\
    \"\n  local str43=\"\"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\
    \"\n  local str47=\"\"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\
    \"\n  local str51=\"\"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\
    \"\n  local str55=\"\"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\
    \"\n  local str59=\"\"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\
    \"\n  local str63=\"\"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\
    \"\n  local str67=\"\"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\
    \"\n  local str71=\"\"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\
    \"\n  local str75=\"\"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\
    \"\n  local str79=\"\"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\
    \"\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n \
    \   [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\"\
    \ ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \"\
    )()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | tr -d '()')\n    local\
    \ str6=$(echo $str4 | tr -d '()')\n    if [[ $str5 == \"\" ]]; then\n        echo\
    \ \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\n    else\n\
    \        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$(echo\
    \ \"$str3\" | sed 's/[()]//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\
    \n    if [[ \"$str5\" == \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\"\
    \ == \"\" ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\
    \n    local str6=\"$str4\"\n    local str7=\"$str5\"\n    local str8=\"$str6\"\
    \n    local str9=\"$str7\"\n    local str10=\"$str8\"\n    local str11=\"$str9\"\
    \n    local str12=\"$str10\"\n    local str13=\"$str11\"\n    local str14=\"$str12\"\
    \n    local str15=\"$str13\"\n    local str16=\"$str14\"\n    local str17=\"$str15\"\
    \n    local str18=\"$str16\"\n    local str19=\"$str17\"\n    local str20=\"$str18\"\
    \n    local str21=\"$str19\"\n    local str22=\"$str20\"\n    local str23=\"$str21\"\
    \n    local str24=\"$str22\"\n    local str25=\"$str23\"\n    local str26=\"$str24\"\
    \n    local str27=\"$str25\"\n    local str28=\"$str26\"\n    local str29=\"$str27\"\
    \n    local str30=\"$str28\"\n    local str31=\"$str29\"\n    local str32=\"$str30\"\
    \n    local str33=\"$str31\"\n    local str34=\"$str32\"\n    local str35=\"$str33\"\
    \n    local str36=\"$str34\"\n    local str37=\"$str35\"\n    local str38=\"$str36\"\
    \n    local str39=\"$str37\"\n    local str40=\"$str38\"\n    local str41=\"$str39\"\
    \n    local str42=\"$str40\"\n    local str43=\"$str41\"\n    local str44=\"$str42\"\
    \n    local str45=\"$str43\"\n    local str46=\"$str44\"\n    local str47=\"$str45\"\
    \n    local str48=\"$str46\"\n    local str49=\"$str47\"\n    local str50=\"$str48\"\
    \n    local str51=\"$str\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprsbbachq.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmprsbbachq.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local left=\"$(echo \"$1\" | cut -d' ' -f1)\"\n\
    \    local right=\"$(echo \"$1\" | cut -d' ' -f2)\"\n    local left_count=\"$(echo\
    \ \"$left\" | grep -o '(' | wc -l)\"\n    local right_count=\"$(echo \"$right\"\
    \ | grep -o ')' | wc -l)\"\n    local left_parens=\"$(echo \"$left\" | sed 's/[^(]//g')\"\
    \n    local right_parens=\"$(echo \"$right\" | sed 's/[^)]//g')\"\n    local left_parens_count=\"\
    $(echo \"$left_parens\" | wc -c)\"\n    local right_parens_count=\"$(echo \"$right_parens\"\
    \ | wc -c)\"\n    local left_parens_count_minus_right_parens_count=$((left_parens_count\
    \ - right_parens_count))\n    local right_parens_count_minus_left_parens_count=$((right_parens_count\
    \ - left_parens_count))\n    if [[ \"$left_count\" -eq \"$right_count\" ]]; then\n\
    \        if [[ \"$left_parens_count_minus_right_parens_count\" -eq 0 ]]; then\n\
    \            echo 'Yes'\n        else\n            echo 'No'\n        fi\n   \
    \ elif [[ \"$left_count\" -gt \"$right_count\" ]]; then\n        if [[ \"$left_parens_count_minus_right_parens_count\"\
    \ -eq 1 ]]; then\n            echo 'Yes'\n        else\n            echo 'No'\n\
    \        fi\n    elif [[ \"$left_count\" -lt \"$right_count\" ]]; then\n     \
    \   if [[ \"$right_parens_count_minus_left_parens_count\" -eq 1 ]]; then\n   \
    \         echo 'Yes'\n        else\n            echo 'No'\n        fi\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local open=0\n  local close=0\n\
    \  for (( i=0; i<${#parens}; i++ )); do\n    if [[ ${parens:$i:1} == '(' ]]; then\n\
    \      (( open++ ))\n    else\n      (( close++ ))\n    fi\n  done\n  if [[ $open\
    \ -eq $close ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a strs=($1)\n  local -a stack\n  local -i i=0\n\
    \  local -i j=0\n  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n\
    \  local -i o=0\n  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n\
    \  local -i t=0\n  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n\
    \  local -i y=0\n  local -i z=0\n  local -i aa=0\n  local -i bb=0\n  local -i\
    \ cc=0\n  local -i dd=0\n  local -i ee=0\n  local -i ff=0\n  local -i gg=0\n \
    \ local -i hh=0\n  local -i ii=0\n  local -i jj=0\n  local -i kk=0\n  local -i\
    \ ll=0\n  local -i mm=0\n  local -i nn=0\n  local -i oo=0\n  local -i pp=0\n \
    \ local -i qq=0\n  local -i rr=0\n  local -i ss=0\n  local -i tt=0\n  local -i\
    \ uu=0\n  local -i vv=0\n  local -i ww=0\n  local -i xx=0\n  local -i yy=0\n \
    \ local -i zz=0\n  local -i aaa=0\n  local -i bbb=0\n  local -i ccc=0\n  local\
    \ -i ddd=0\n  local -i eee=0\n  local -i fff=0\n  local -i ggg=0\n  local -i hhh=0\n\
    \  local -i iii=0\n  local -i jjj=0\n  local -i kkk=0\n  local -i lll=0\n  local\
    \ -i mmm=0\n  local -i nnn=0\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=${str1}${str2}\n\
    \    local str4=${str2}${str1}\n    local str5=${str1}${str1}\n    local str6=${str2}${str2}\n\
    \    local str7=${str1}${str2}${str1}\n    local str8=${str2}${str1}${str2}\n\
    \    local str9=${str1}${str2}${str2}\n    local str10=${str2}${str1}${str1}\n\
    \    local str11=${str1}${str1}${str2}\n    local str12=${str2}${str2}${str1}\n\
    \    local str13=${str1}${str2}${str1}${str2}\n    local str14=${str2}${str1}${str2}${str1}\n\
    \    local str15=${str1}${str2}${str2}${str1}\n    local str16=${str2}${str1}${str1}${str2}\n\
    \    local str17=${str1}${str1}${str2}${str2}\n    local str18=${str2}${str2}${str1}${str1}\n\
    \    local str19=${str1}${str2}${str1}${str2}${str1}\n    local str20=${str2}${str1}${str2}${str1}${str2}\n\
    \    local str21=${str1}${str2}${str2}${str1}${str2}\n    local str22=${str2}${str1}${str1}${str2}${str1}\n\
    \    local str23=${str1}${str1}${str2}${str2}${str1}\n    local str24=${str2}${str2}${str1}${str1}${str2}\n\
    \    local str25=${str1}${str2}${str1}${str2}${str1}${str2}\n    local str26=${str2}${str1}${str\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjndjzriu.sh: line 65: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s=\"$1\"\n  local count=0\n  for ((i=0; i<${#s};\
    \ i++)); do\n    if [[ \"${s:$i:1}\" == \"(\" ]]; then\n      ((count++))\n  \
    \  else\n      ((count--))\n    fi\n    if ((count < 0)); then\n      echo \"\
    No\"\n      return\n    fi\n  done\n  if ((count == 0)); then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed\
    \ 's/[()]//g')\"\n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[\
    \ -z \"$str5\" ]]; then\n    echo 'Yes'\n  elif [[ -z \"$str6\" ]]; then\n   \
    \ echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local len=${#str3}\n  local i=0\n  local count=0\n  while [ $i\
    \ -lt $len ]; do\n    if [ \"${str3:$i:1}\" == \"(\" ]; then\n      count=$((count\
    \ + 1))\n    else\n      count=$((count - 1))\n    fi\n    if [ $count -lt 0 ];\
    \ then\n      echo \"No\"\n      return\n    fi\n    i=$((i + 1))\n  done\n  if\
    \ [ $count -eq 0 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens=($1)\n    local -i open=0\n    local\
    \ -i close=0\n    local -i i=0\n    local -i len=${#parens[@]}\n    local -i j=0\n\
    \    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n    local\
    \ -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local -i s=0\n\
    \    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n    local\
    \ -i x=0\n    local -i y=0\n    local -i z=0\n    local -i aa=0\n    local -i\
    \ bb=0\n    local -i cc=0\n    local -i dd=0\n    local -i ee=0\n    local -i\
    \ ff=0\n    local -i gg=0\n    local -i hh=0\n    local -i ii=0\n    local -i\
    \ jj=0\n    local -i kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i\
    \ nn=0\n    local -i oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i\
    \ rr=0\n    local -i ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i\
    \ vv=0\n    local -i ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i\
    \ zz=0\n    local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n    local\
    \ -i ddd=0\n    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n    local\
    \ -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n    local\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i=0\n  local -i j=0\n\
    \  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n\
    \  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n\
    \  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n\
    \  local -i z=0\n  local -i aa=0\n  local -i bb=0\n  local -i cc=0\n  local -i\
    \ dd=0\n  local -i ee=0\n  local -i ff=0\n  local -i gg=0\n  local -i hh=0\n \
    \ local -i ii=0\n  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i\
    \ mm=0\n  local -i nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n \
    \ local -i rr=0\n  local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i\
    \ vv=0\n  local -i ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n \
    \ local -i aaa=0\n  local -i bbb=0\n  local -i ccc=0\n  local -i ddd=0\n  local\
    \ -i eee=0\n  local -i fff=0\n  local -i ggg=0\n  local -i hhh=0\n  local -i iii=0\n\
    \  local -i jjj=0\n  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n  local\
    \ -i nnn=0\n  local -i ooo=0\n\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"\
    $str1$str2\"\n  local count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[\
    \ ${str:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str:$i:1} ==\
    \ ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo 'No'\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"\"\n\
    \  local str4=\"\"\n  local str5=\"\"\n  local str6=\"\"\n  local str7=\"\"\n\
    \  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local str11=\"\"\n\
    \  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local str15=\"\"\
    \n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local str19=\"\
    \"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local str23=\"\
    \"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local str27=\"\
    \"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local str31=\"\
    \"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local str35=\"\
    \"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local str39=\"\
    \"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local str43=\"\
    \"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local str47=\"\
    \"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local str51=\"\
    \"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local str55=\"\
    \"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local str59=\"\
    \"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local str63=\"\
    \"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local str67=\"\
    \"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local str71=\"\
    \"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local str75=\"\
    \"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local str79=\"\
    \"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n  local str83=\"\
    \"\n  local str84=\"\"\n  local str85=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens\n    local -i i=0\n    local -i\
    \ j=0\n    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n\
    \    local -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local\
    \ -i s=0\n    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n\
    \    local -i x=0\n    local -i y=0\n    local -i z=0\n    local -i a=0\n    local\
    \ -i b=0\n    local -i c=0\n    local -i d=0\n    local -i e=0\n    local -i f=0\n\
    \    local -i g=0\n    local -i h=0\n    local -i ii=0\n    local -i jj=0\n  \
    \  local -i kk=0\n    local -i ll=0\n    local -i mm=0\n    local -i nn=0\n  \
    \  local -i oo=0\n    local -i pp=0\n    local -i qq=0\n    local -i rr=0\n  \
    \  local -i ss=0\n    local -i tt=0\n    local -i uu=0\n    local -i vv=0\n  \
    \  local -i ww=0\n    local -i xx=0\n    local -i yy=0\n    local -i zz=0\n  \
    \  local -i aa=0\n    local -i bb=0\n    local -i cc=0\n    local -i dd=0\n  \
    \  local -i ee=0\n    local -i ff=0\n    local -i gg=0\n    local -i hh=0\n  \
    \  local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n    local -i lll=0\n\
    \    local -i mmm=0\n    local -i nnn=0\n    local -i ooo=0\n    local -i ppp=0\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\
    \n    local str6=\"$str4\"\n    local str7=\"$str5\"\n    local str8=\"$str6\"\
    \n    local str9=\"$str7\"\n    local str10=\"$str8\"\n    local str11=\"$str9\"\
    \n    local str12=\"$str10\"\n    local str13=\"$str11\"\n    local str14=\"$str12\"\
    \n    local str15=\"$str13\"\n    local str16=\"$str14\"\n    local str17=\"$str15\"\
    \n    local str18=\"$str16\"\n    local str19=\"$str17\"\n    local str20=\"$str18\"\
    \n    local str21=\"$str19\"\n    local str22=\"$str20\"\n    local str23=\"$str21\"\
    \n    local str24=\"$str22\"\n    local str25=\"$str23\"\n    local str26=\"$str24\"\
    \n    local str27=\"$str25\"\n    local str28=\"$str26\"\n    local str29=\"$str27\"\
    \n    local str30=\"$str28\"\n    local str31=\"$str29\"\n    local str32=\"$str30\"\
    \n    local str33=\"$str31\"\n    local str34=\"$str32\"\n    local str35=\"$str33\"\
    \n    local str36=\"$str34\"\n    local str37=\"$str35\"\n    local str38=\"$str36\"\
    \n    local str39=\"$str37\"\n    local str40=\"$str38\"\n    local str41=\"$str39\"\
    \n    local str42=\"$str40\"\n    local str43=\"$str41\"\n    local str44=\"$str42\"\
    \n    local str45=\"$str43\"\n    local str46=\"$str44\"\n    local str47=\"$str45\"\
    \n    local str48=\"$str46\"\n    local str49=\"$str47\"\n    local str50=\"$str48\"\
    \n    local str51=\"$str\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprsbbachq.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmprsbbachq.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$str1$str1\n  local str6=$str2$str2\n \
    \ local str7=$str1$str2$str1\n  local str8=$str2$str1$str2\n  local str9=$str1$str2$str2\n\
    \  local str10=$str2$str1$str1\n  if [[ $str3 =~ ^\\(+\\)+$ ]] || [[ $str4 =~\
    \ ^\\(+\\)+$ ]] || [[ $str5 =~ ^\\(+\\)+$ ]] || [[ $str6 =~ ^\\(+\\)+$ ]] || [[\
    \ $str7 =~ ^\\(+\\)+$ ]] || [[ $str8 =~ ^\\(+\\)+$ ]] || [[ $str9 =~ ^\\(+\\)+$\
    \ ]] || [[ $str10 =~ ^\\(+\\)+$ ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i\n  local -i count=0\n\
    \  local -i len\n  local -i len1\n  local -i len2\n  local -i len3\n  local -i\
    \ len4\n  local -i len5\n  local -i len6\n  local -i len7\n  local -i len8\n \
    \ local -i len9\n  local -i len10\n  local -i len11\n  local -i len12\n  local\
    \ -i len13\n  local -i len14\n  local -i len15\n  local -i len16\n  local -i len17\n\
    \  local -i len18\n  local -i len19\n  local -i len20\n  local -i len21\n  local\
    \ -i len22\n  local -i len23\n  local -i len24\n  local -i len25\n  local -i len26\n\
    \  local -i len27\n  local -i len28\n  local -i len29\n  local -i len30\n  local\
    \ -i len31\n  local -i len32\n  local -i len33\n  local -i len34\n  local -i len35\n\
    \  local -i len36\n  local -i len37\n  local -i len38\n  local -i len39\n  local\
    \ -i len40\n  local -i len41\n  local -i len42\n  local -i len43\n  local -i len44\n\
    \  local -i len45\n  local -i len46\n  local -i len47\n  local -i len48\n  local\
    \ -i len49\n  local -i len50\n  local -i len51\n  local -i len52\n  local -i len53\n\
    \  local -i len54\n  local -i len55\n  local -i len56\n  local -i len57\n  local\
    \ -i len58\n  local -i len59\n  local -i len60\n  local -i len61\n  local -i len62\n\
    \  local -i len63\n  local -i len64\n  local -i len65\n  local -i len66\n  local\
    \ -i len67\n  local -i len68\n  local -i len69\n\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local parens_list=($parens)\n \
    \ local parens_1=${parens_list[0]}\n  local parens_2=${parens_list[1]}\n  local\
    \ parens_1_count=0\n  local parens_2_count=0\n  for (( i=0; i<${#parens_1}; i++\
    \ )); do\n    if [[ ${parens_1:$i:1} == '(' ]]; then\n      (( parens_1_count++\
    \ ))\n    else\n      (( parens_1_count-- ))\n    fi\n  done\n  for (( i=0; i<${#parens_2};\
    \ i++ )); do\n    if [[ ${parens_2:$i:1} == '(' ]]; then\n      (( parens_2_count++\
    \ ))\n    else\n      (( parens_2_count-- ))\n    fi\n  done\n  if [[ $parens_1_count\
    \ -eq 0 && $parens_2_count -eq 0 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local count=0\n  for (( i=0; i<${#str3}; i++ )); do\n    if [[\
    \ ${str3:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str3:$i:1}\
    \ == ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo 'No'\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local parens=\"$1\"\n    local left_parens=0\n \
    \   local right_parens=0\n    for paren in $parens; do\n        for ((i=0; i<${#paren};\
    \ i++)); do\n            if [[ ${paren:$i:1} == '(' ]]; then\n               \
    \ left_parens=$((left_parens + 1))\n            else\n                right_parens=$((right_parens\
    \ + 1))\n            fi\n        done\n    done\n    if [[ $left_parens -eq $right_parens\
    \ ]]; then\n        echo 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s=$1\n  local c=0\n  for ((i=0; i<${#s}; i++));\
    \ do\n    if [[ ${s:i:1} == '(' ]]; then\n      ((c++))\n    else\n      ((c--))\n\
    \    fi\n    if ((c < 0)); then\n      echo 'No'\n      return\n    fi\n  done\n\
    \  if ((c == 0)); then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local stack=()\n    local str\n    for str in $1;\
    \ do\n        for ((i=0; i<${#str}; i++)); do\n            case ${str:$i:1} in\n\
    \                '(')\n                    stack+=('(')\n                    ;;\n\
    \                ')')\n                    if [[ ${#stack[@]} -eq 0 ]]; then\n\
    \                        echo 'No'\n                        return\n         \
    \           fi\n                    stack=(\"${stack[@]:0:${#stack[@]}-1}\")\n\
    \                    ;;\n            esac\n        done\n    done\n    if [[ ${#stack[@]}\
    \ -eq 0 ]]; then\n        echo 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -i open=0\n  local -i close=0\n  for ((i=0;\
    \ i<${#1}; i++)); do\n    if [[ ${1:i:1} == '(' ]]; then\n      ((open++))\n \
    \   else\n      ((close++))\n    fi\n  done\n  if ((open == close)); then\n  \
    \  echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a list=($1)\n  local -a stack\n  local -i i=0\n\
    \  local -i len=${#list[@]}\n  local -i top=0\n  local -i balance=0\n  local -i\
    \ open=0\n  local -i close=0\n  local -i flag=0\n  local -i flag2=0\n  local -i\
    \ flag3=0\n  local -i flag4=0\n  local -i flag5=0\n  local -i flag6=0\n  local\
    \ -i flag7=0\n  local -i flag8=0\n  local -i flag9=0\n  local -i flag10=0\n  local\
    \ -i flag11=0\n  local -i flag12=0\n  local -i flag13=0\n  local -i flag14=0\n\
    \  local -i flag15=0\n  local -i flag16=0\n  local -i flag17=0\n  local -i flag18=0\n\
    \  local -i flag19=0\n  local -i flag20=0\n  local -i flag21=0\n  local -i flag22=0\n\
    \  local -i flag23=0\n  local -i flag24=0\n  local -i flag25=0\n  local -i flag26=0\n\
    \  local -i flag27=0\n  local -i flag28=0\n  local -i flag29=0\n  local -i flag30=0\n\
    \  local -i flag31=0\n  local -i flag32=0\n  local -i flag33=0\n  local -i flag34=0\n\
    \  local -i flag35=0\n  local -i flag36=0\n  local -i flag37=0\n  local -i flag38=0\n\
    \  local -i flag39=0\n  local -i flag40=0\n  local -i flag41=0\n  local -i flag42=0\n\
    \  local -i flag43=0\n  local -i flag44=0\n  local -i flag45=0\n  local -i flag46=0\n\
    \  local -i flag47=0\n  local -i flag48=0\n  local -i flag49=0\n  local\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $str6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s=$1\n  local i=0\n  local l=0\n  local r=0\n\
    \  local c\n  for ((i=0; i<${#s}; i++)); do\n    c=${s:$i:1}\n    if [[ $c ==\
    \ '(' ]]; then\n      ((l++))\n    elif [[ $c == ')' ]]; then\n      ((r++))\n\
    \    fi\n    if ((r > l)); then\n      echo 'No'\n      return\n    fi\n  done\n\
    \  if ((l == r)); then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=$(echo $str3 | grep -o \"(\" | wc -l)\n\
    \  local count2=$(echo $str3 | grep -o \")\" | wc -l)\n  local count3=$(echo $str4\
    \ | grep -o \"(\" | wc -l)\n  local count4=$(echo $str4 | grep -o \")\" | wc -l)\n\
    \  if [ $count1 -eq $count2 ] && [ $count3 -eq $count4 ]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  parens=($1)\n  local -i open=0\n\
    \  local -i close=0\n  for ((i=0; i<${#parens[@]}; i++)); do\n    for ((j=0; j<${#parens[$i]};\
    \ j++)); do\n      if [[ ${parens[$i]:$j:1} == '(' ]]; then\n        ((open++))\n\
    \      else\n        ((close++))\n      fi\n    done\n  done\n  if [[ $open -eq\
    \ $close ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i=0\n  local -i j=0\n\
    \  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n\
    \  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n\
    \  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n\
    \  local -i z=0\n  local -i a=0\n  local -i b=0\n  local -i c=0\n  local -i d=0\n\
    \  local -i e=0\n  local -i f=0\n  local -i g=0\n  local -i h=0\n  local -i ii=0\n\
    \  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i mm=0\n  local -i\
    \ nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n  local -i rr=0\n \
    \ local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i vv=0\n  local -i\
    \ ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n  local -i aa=0\n \
    \ local -i bb=0\n  local -i cc=0\n  local -i dd=0\n  local -i ee=0\n  local -i\
    \ ff=0\n  local -i gg=0\n  local -i hh=0\n  local -i iii=0\n  local -i jjj=0\n\
    \  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n  local -i nnn=0\n  local\
    \ -i ooo=0\n  local -i ppp=0\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local a=\"$1\"\n    local b=\"$2\"\n    local c\n\
    \    local d\n    local e\n    local f\n    local g\n    local h\n    local i\n\
    \    local j\n    local k\n    local l\n    local m\n    local n\n    local o\n\
    \    local p\n    local q\n    local r\n    local s\n    local t\n    local u\n\
    \    local v\n    local w\n    local x\n    local y\n    local z\n    local A\n\
    \    local B\n    local C\n    local D\n    local E\n    local F\n    local G\n\
    \    local H\n    local I\n    local J\n    local K\n    local L\n    local M\n\
    \    local N\n    local O\n    local P\n    local Q\n    local R\n    local S\n\
    \    local T\n    local U\n    local V\n    local W\n    local X\n    local Y\n\
    \    local Z\n    local aa\n    local ab\n    local ac\n    local ad\n    local\
    \ ae\n    local af\n    local ag\n    local ah\n    local ai\n    local aj\n \
    \   local ak\n    local al\n    local am\n    local an\n    local ao\n    local\
    \ ap\n    local aq\n    local ar\n    local as\n    local at\n    local au\n \
    \   local av\n    local aw\n    local ax\n    local ay\n    local az\n    local\
    \ ba\n    local bb\n    local bc\n    local bd\n    local be\n    local bf\n \
    \   local bg\n    local bh\n    local bi\n    local bj\n    local bk\n    local\
    \ bl\n    local bm\n    local bn\n    local bo\n    local bp\n    local bq\n \
    \   local br\n    local bs\n    local bt\n    local bu\n    local bv\n    local\
    \ bw\n    local bx\n    local by\n    local bz\n    local ca\n    local cb\n \
    \   local cc\n    local cd\n    local ce\n    local cf\n    local cg\n    local\
    \ ch\n    local ci\n    local cj\n    local ck\n    local cl\n    local cm\n \
    \   local cn\n    local\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $str6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"\
    $str1$str2\"\n  local count=0\n  for (( i=0; i<${#str}; i++ )); do\n    if [[\
    \ ${str:$i:1} == '(' ]]; then\n      (( count++ ))\n    elif [[ ${str:$i:1} ==\
    \ ')' ]]; then\n      (( count-- ))\n    fi\n    if [[ $count -lt 0 ]]; then\n\
    \      echo 'No'\n      return\n    fi\n  done\n  if [[ $count -eq 0 ]]; then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local left=0\n  local right=0\n\
    \  for (( i=0; i<${#parens}; i++ )); do\n    if [[ ${parens:$i:1} == '(' ]]; then\n\
    \      (( left++ ))\n    else\n      (( right++ ))\n    fi\n  done\n  if [[ $left\
    \ == $right ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens\n    local -i i=0\n    local -i\
    \ j=0\n    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n\
    \    local -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local\
    \ -i s=0\n    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n\
    \    local -i x=0\n    local -i y=0\n    local -i z=0\n    local -i A=0\n    local\
    \ -i B=0\n    local -i C=0\n    local -i D=0\n    local -i E=0\n    local -i F=0\n\
    \    local -i G=0\n    local -i H=0\n    local -i I=0\n    local -i J=0\n    local\
    \ -i K=0\n    local -i L=0\n    local -i M=0\n    local -i N=0\n    local -i O=0\n\
    \    local -i P=0\n    local -i Q=0\n    local -i R=0\n    local -i S=0\n    local\
    \ -i T=0\n    local -i U=0\n    local -i V=0\n    local -i W=0\n    local -i X=0\n\
    \    local -i Y=0\n    local -i Z=0\n    local -i a=0\n    local -i b=0\n    local\
    \ -i c=0\n    local -i d=0\n    local -i e=0\n    local -i f=0\n    local -i g=0\n\
    \    local -i h=0\n    local -i ii=0\n    local -i jj=0\n    local -i kk=0\n \
    \   local -i ll=0\n    local -i mm=0\n    local -i nn=0\n    local -i oo=0\n \
    \   local -i pp=0\n    local -i qq=0\n    local -i rr=0\n   \n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=\"$1\"\n  local left=0\n  local right=0\n\
    \  for (( i=0; i<${#parens}; i++ )); do\n    if [[ \"${parens:$i:1}\" == \"(\"\
    \ ]]; then\n      left=$(( left + 1 ))\n    else\n      right=$(( right + 1 ))\n\
    \    fi\n  done\n  if [[ $left -eq $right ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=$1\n  local parens_arr=($parens)\n  local\
    \ parens_1=${parens_arr[0]}\n  local parens_2=${parens_arr[1]}\n  local parens_1_len=${#parens_1}\n\
    \  local parens_2_len=${#parens_2}\n  local parens_1_open_count=0\n  local parens_1_close_count=0\n\
    \  local parens_2_open_count=0\n  local parens_2_close_count=0\n  local i=0\n\
    \  local parens_1_char=''\n  local parens_2_char=''\n  local parens_1_open_count_after_parens_2=0\n\
    \  local parens_1_close_count_after_parens_2=0\n  local parens_2_open_count_after_parens_1=0\n\
    \  local parens_2_close_count_after_parens_1=0\n\n  for ((i=0; i<parens_1_len;\
    \ i++)); do\n    parens_1_char=${parens_1:$i:1}\n    if [[ $parens_1_char == '('\
    \ ]]; then\n      parens_1_open_count=$((parens_1_open_count + 1))\n    else\n\
    \      parens_1_close_count=$((parens_1_close_count + 1))\n    fi\n  done\n\n\
    \  for ((i=0; i<parens_2_len; i++)); do\n    parens_2_char=${parens_2:$i:1}\n\
    \    if [[ $parens_2_char == '(' ]]; then\n      parens_2_open_count=$((parens_2_open_count\
    \ + 1))\n    else\n      parens_2_close_count=$((parens_2_close_count + 1))\n\
    \    fi\n  done\n\n  if [[ $parens_1_open_count -eq $parens_\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp3czfw_we.sh: line 52: syntax error in conditional expression

    /tmp/tmp3czfw_we.sh: line 53: syntax error near `}''

    /tmp/tmp3czfw_we.sh: line 53: `}''

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | tr -d '()')\n    local\
    \ str6=$(echo $str4 | tr -d '()')\n    if [[ $str5 == '' && $str6 == '' ]]; then\n\
    \        echo 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str1_open=0\n    local str2_open=0\n    local str1_close=0\n    local str2_close=0\n\
    \    for ((i=0; i<${#str1}; i++)); do\n        if [[ \"${str1:$i:1}\" == \"(\"\
    \ ]]; then\n            ((str1_open++))\n        else\n            ((str1_close++))\n\
    \        fi\n    done\n    for ((i=0; i<${#str2}; i++)); do\n        if [[ \"\
    ${str2:$i:1}\" == \"(\" ]]; then\n            ((str2_open++))\n        else\n\
    \            ((str2_close++))\n        fi\n    done\n    if [[ \"$str1_open\"\
    \ -gt \"$str2_close\" ]]; then\n        echo \"No\"\n    elif [[ \"$str2_open\"\
    \ -gt \"$str1_close\" ]]; then\n        echo \"No\"\n    else\n        echo \"\
    Yes\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -r str1=\"$1\"\n  local -r str2=\"$2\"\n  local\
    \ -r str3=\"$str1$str2\"\n  local -r str4=\"$str2$str1\"\n  local -r str5=\"$(echo\
    \ \"$str3\" | sed 's/[()]//g')\"\n  local -r str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\
    \n  if [[ -z \"$str5\" ]]; then\n    echo 'Yes'\n  elif [[ -z \"$str6\" ]]; then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"\
    $str1$str2\"\n  local len=${#str}\n  local i=0\n  local count=0\n  while [ $i\
    \ -lt $len ]; do\n    if [ \"${str:$i:1}\" == \"(\" ]; then\n      count=$((count\
    \ + 1))\n    else\n      count=$((count - 1))\n    fi\n    if [ $count -lt 0 ];\
    \ then\n      echo \"No\"\n      return\n    fi\n    i=$((i + 1))\n  done\n  if\
    \ [ $count -eq 0 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local parens=\"$1\"\n  local left_parens=0\n  local\
    \ right_parens=0\n  for ((i=0; i<${#parens}; i++)); do\n    if [[ \"${parens:$i:1}\"\
    \ == \"(\" ]]; then\n      left_parens=$((left_parens + 1))\n    else\n      right_parens=$((right_parens\
    \ + 1))\n    fi\n  done\n  if [[ $left_parens -eq $right_parens ]]; then\n   \
    \ echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=0\n  local count2=0\n  local count3=0\n\
    \  local count4=0\n  for ((i=0; i<${#str1}; i++)); do\n    if [[ ${str1:$i:1}\
    \ == '(' ]]; then\n      ((count1++))\n    else\n      ((count1--))\n    fi\n\
    \  done\n  for ((i=0; i<${#str2}; i++)); do\n    if [[ ${str2:$i:1} == '(' ]];\
    \ then\n      ((count2++))\n    else\n      ((count2--))\n    fi\n  done\n  for\
    \ ((i=0; i<${#str3}; i++)); do\n    if [[ ${str3:$i:1} == '(' ]]; then\n     \
    \ ((count3++))\n    else\n      ((count3--))\n    fi\n  done\n  for ((i=0; i<${#str4};\
    \ i++)); do\n    if [[ ${str4:$i:1} == '(' ]]; then\n      ((count4++))\n    else\n\
    \      ((count4--))\n    fi\n  done\n  if [[ $count1 -eq 0 || $count2 -eq 0 ||\
    \ $count3 -eq 0 || $count4 -eq 0 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == '' ]]; then\n    echo\
    \ 'Yes'\n  elif [[ $str6 == '' ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n\
    \  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n\
    \    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"\
    No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$(echo\
    \ \"$str3\" | sed 's/[()]//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\
    \n    if [[ \"$str5\" == \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\"\
    \ == \"\" ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  for paren in ${parens[@]}; do\n    for ((i=0; i<${#paren}; i++));\
    \ do\n      if [[ ${paren:$i:1} == '(' ]]; then\n        ((open++))\n      else\n\
    \        ((close++))\n      fi\n    done\n  done\n  if ((open == close)); then\n\
    \    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens\n    local -i i=0\n    local -i\
    \ len=0\n    local -i open=0\n    local -i close=0\n    local -i balance=0\n \
    \   local -i total=0\n    local -i total_open=0\n    local -i total_close=0\n\
    \    local -i total_balance=0\n    local -i total_total=0\n    local -i total_total_open=0\n\
    \    local -i total_total_close=0\n    local -i total_total_balance=0\n    local\
    \ -i total_total_total=0\n    local -i total_total_total_open=0\n    local -i\
    \ total_total_total_close=0\n    local -i total_total_total_balance=0\n    local\
    \ -i total_total_total_total=0\n    local -i total_total_total_total_open=0\n\
    \    local -i total_total_total_total_close=0\n    local -i total_total_total_total_balance=0\n\
    \    local -i total_total_total_total_total=0\n    local -i total_total_total_total_total_open=0\n\
    \    local -i total_total_total_total_total_close=0\n    local -i total_total_total_total_total_balance=0\n\
    \    local -i total_total_total_total_total_total=0\n    local -i total_total_total_total_total_total_open=0\n\
    \    local -i total_total_total_total_total_total_close=0\n    local -i total_total_total_total_total_total_balance=0\n\
    \    local -i total_total_total_total_total_total_total=0\n    local -i total_total_total_total_total_total_total_open=0\n\
    \    local -i total_total_total_total_total_total_total_close=0\n    local -i\
    \ total_total_total_total_total_total_total_balance=0\n    local -i total_total_total_total_total_total_total_total=0\n\
    \    local -i total_total\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=0\n  local count2=0\n  local count3=0\n\
    \  local count4=0\n  for ((i=0; i<${#str1}; i++)); do\n    if [[ ${str1:$i:1}\
    \ == '(' ]]; then\n      count1=$((count1+1))\n    else\n      count1=$((count1-1))\n\
    \    fi\n  done\n  for ((i=0; i<${#str2}; i++)); do\n    if [[ ${str2:$i:1} ==\
    \ '(' ]]; then\n      count2=$((count2+1))\n    else\n      count2=$((count2-1))\n\
    \    fi\n  done\n  for ((i=0; i<${#str3}; i++)); do\n    if [[ ${str3:$i:1} ==\
    \ '(' ]]; then\n      count3=$((count3+1))\n    else\n      count3=$((count3-1))\n\
    \    fi\n  done\n  for ((i=0; i<${#str4}; i++)); do\n    if [[ ${str4:$i:1} ==\
    \ '(' ]]; then\n      count4=$((count4+1))\n    else\n      count4=$((count4-1))\n\
    \    fi\n  done\n  if [[ $count1 -eq 0 || $count2 -eq 0 || $count3 -eq 0 || $count4\
    \ -eq 0 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  # TODO: implement this function\n  # return 'Yes'\
    \ or 'No'\n  #\n  # Hint:\n  #   - You can use the following bash commands:\n\
    \  #     - `expr`\n  #     - `grep`\n  #     - `sed`\n  #     - `tr`\n  #    \
    \ - `sort`\n  #     - `uniq`\n  #     - `wc`\n  #     - `xargs`\n  #     - `cut`\n\
    \  #     - `paste`\n  #     - `bc`\n  #   - You can use the following bash operators:\n\
    \  #     - `=`\n  #     - `!=`\n  #     - `-eq`\n  #     - `-ne`\n  #     - `-lt`\n\
    \  #     - `-le`\n  #     - `-gt`\n  #     - `-ge`\n  #     - `-z`\n  #     -\
    \ `-n`\n  #     - `-a`\n  #     - `-o`\n  #     - `&&`\n  #     - `||`\n  #  \
    \   - `!`\n  #     - `{}`\n  #     - `()`\n  #     - `[]`\n  #     - `[[]]`\n\
    \  #     - `=`\n  #     - `+`\n  #     - `-`\n  #     - `*`\n  #     - `/`\n \
    \ #     - `%`\n  #     - `**`\n  #     - `<<`\n  #     - `>>`\n  #     - `&`\n\
    \  #     - `|`\n  #     - `^`\n  #     - `~`\n  #     - `<`\n  #     - `>`\n \
    \ #     - `<=`\n  #     - `>=`\n  #     - `==`\n  #     - `!=`\n  #     - `<>`\n\
    \  #     - `<<=`\n  #     - `>>=`\n  #     - `&&=`\n  #     - `||=`\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpqglns92s.sh: line 76: syntax error near unexpected token `}''

    /tmp/tmpqglns92s.sh: line 76: `}''

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$3\n\
    \    local str4=$4\n    local str5=$5\n    local str6=$6\n    local str7=$7\n\
    \    local str8=$8\n    local str9=$9\n    local str10=${10}\n    local str11=${11}\n\
    \    local str12=${12}\n    local str13=${13}\n    local str14=${14}\n    local\
    \ str15=${15}\n    local str16=${16}\n    local str17=${17}\n    local str18=${18}\n\
    \    local str19=${19}\n    local str20=${20}\n    local str21=${21}\n    local\
    \ str22=${22}\n    local str23=${23}\n    local str24=${24}\n    local str25=${25}\n\
    \    local str26=${26}\n    local str27=${27}\n    local str28=${28}\n    local\
    \ str29=${29}\n    local str30=${30}\n    local str31=${31}\n    local str32=${32}\n\
    \    local str33=${33}\n    local str34=${34}\n    local str35=${35}\n    local\
    \ str36=${36}\n    local str37=${37}\n    local str38=${38}\n    local str39=${39}\n\
    \    local str40=${40}\n    local str41=${41}\n    local str42=${42}\n    local\
    \ str43=${43}\n    local str44=${44}\n    local str45=${45}\n    local str46=${46}\n\
    \    local str47=${47}\n    local str48=${48}\n    local str49=${49}\n    local\
    \ str50=${50}\n    local str51=${51}\n    local str52=${52}\n    local str53=${53}\n\
    \    local str54=${54}\n    local str55=${55}\n    local str56=${56}\n    local\
    \ str57=${57}\n    local str58=${58}\n    local str59=${59\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpls_jv3i1.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local parens=\"$1\"\n    local left_parens=$(echo\
    \ \"$parens\" | tr -d ')' | wc -c)\n    local right_parens=$(echo \"$parens\"\
    \ | tr -d '(' | wc -c)\n    if [[ $left_parens -eq $right_parens ]]; then\n  \
    \      echo 'Yes'\n    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n \
    \   match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"\
    (()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"()\
    \ ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[\
    \ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\") =\
    \ \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$3\n\
    \    local str4=$4\n    local str5=$5\n    local str6=$6\n    local str7=$7\n\
    \    local str8=$8\n    local str9=$9\n    local str10=${10}\n    local str11=${11}\n\
    \    local str12=${12}\n    local str13=${13}\n    local str14=${14}\n    local\
    \ str15=${15}\n    local str16=${16}\n    local str17=${17}\n    local str18=${18}\n\
    \    local str19=${19}\n    local str20=${20}\n    local str21=${21}\n    local\
    \ str22=${22}\n    local str23=${23}\n    local str24=${24}\n    local str25=${25}\n\
    \    local str26=${26}\n    local str27=${27}\n    local str28=${28}\n    local\
    \ str29=${29}\n    local str30=${30}\n    local str31=${31}\n    local str32=${32}\n\
    \    local str33=${33}\n    local str34=${34}\n    local str35=${35}\n    local\
    \ str36=${36}\n    local str37=${37}\n    local str38=${38}\n    local str39=${39}\n\
    \    local str40=${40}\n    local str41=${41}\n    local str42=${42}\n    local\
    \ str43=${43}\n    local str44=${44}\n    local str45=${45}\n    local str46=${46}\n\
    \    local str47=${47}\n    local str48=${48}\n    local str49=${49}\n    local\
    \ str50=${50}\n    local str51=${51}\n    local str52=${52}\n    local str53=${53}\n\
    \    local str54=${54}\n    local str55=${55}\n    local str56=${56}\n    local\
    \ str57=${57}\n    local str58=${58}\n    local str59=${59\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpls_jv3i1.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local count=0\n    for (( i=0; i<${#str3}; i++\
    \ )); do\n        if [[ ${str3:$i:1} == '(' ]]; then\n            (( count++ ))\n\
    \        elif [[ ${str3:$i:1} == ')' ]]; then\n            (( count-- ))\n   \
    \     fi\n        if [[ $count -lt 0 ]]; then\n            break\n        fi\n\
    \    done\n    if [[ $count -eq 0 ]]; then\n        echo 'Yes'\n        return\n\
    \    fi\n    count=0\n    for (( i=0; i<${#str4}; i++ )); do\n        if [[ ${str4:$i:1}\
    \ == '(' ]]; then\n            (( count++ ))\n        elif [[ ${str4:$i:1} ==\
    \ ')' ]]; then\n            (( count-- ))\n        fi\n        if [[ $count -lt\
    \ 0 ]]; then\n            break\n        fi\n    done\n    if [[ $count -eq 0\
    \ ]]; then\n        echo 'Yes'\n        return\n    fi\n    echo 'No'\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i=0\n  local -i len=0\n\
    \  local -i count=0\n  local -i open=0\n  local -i close=0\n  local -i total=0\n\
    \  local -i diff=0\n  local -i index=0\n  local -i len_parens=0\n  local -i len_parens_minus_1=0\n\
    \  local -i len_parens_minus_2=0\n  local -i len_parens_minus_3=0\n  local -i\
    \ len_parens_minus_4=0\n  local -i len_parens_minus_5=0\n  local -i len_parens_minus_6=0\n\
    \  local -i len_parens_minus_7=0\n  local -i len_parens_minus_8=0\n  local -i\
    \ len_parens_minus_9=0\n  local -i len_parens_minus_10=0\n  local -i len_parens_minus_11=0\n\
    \  local -i len_parens_minus_12=0\n  local -i len_parens_minus_13=0\n  local -i\
    \ len_parens_minus_14=0\n  local -i len_parens_minus_15=0\n  local -i len_parens_minus_16=0\n\
    \  local -i len_parens_minus_17=0\n  local -i len_parens_minus_18=0\n  local -i\
    \ len_parens_minus_19=0\n  local -i len_parens_minus_20=0\n  local -i len_parens_minus_21=0\n\
    \  local -i len_parens_minus_22=0\n  local -i len_parens_minus_23=0\n  local -i\
    \ len_parens_minus_24=0\n  local -i len_parens_minus_25=0\n  local -i len_parens_minus_26=0\n\
    \  local -i len_parens_minus_27=0\n  local -i len_parens_minus_28=0\n  local -i\
    \ len_parens\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\
    \n    local str6=\"$str4\"\n    local str7=\"$str5\"\n    local str8=\"$str6\"\
    \n    local str9=\"$str7\"\n    local str10=\"$str8\"\n    local str11=\"$str9\"\
    \n    local str12=\"$str10\"\n    local str13=\"$str11\"\n    local str14=\"$str12\"\
    \n    local str15=\"$str13\"\n    local str16=\"$str14\"\n    local str17=\"$str15\"\
    \n    local str18=\"$str16\"\n    local str19=\"$str17\"\n    local str20=\"$str18\"\
    \n    local str21=\"$str19\"\n    local str22=\"$str20\"\n    local str23=\"$str21\"\
    \n    local str24=\"$str22\"\n    local str25=\"$str23\"\n    local str26=\"$str24\"\
    \n    local str27=\"$str25\"\n    local str28=\"$str26\"\n    local str29=\"$str27\"\
    \n    local str30=\"$str28\"\n    local str31=\"$str29\"\n    local str32=\"$str30\"\
    \n    local str33=\"$str31\"\n    local str34=\"$str32\"\n    local str35=\"$str33\"\
    \n    local str36=\"$str34\"\n    local str37=\"$str35\"\n    local str38=\"$str36\"\
    \n    local str39=\"$str37\"\n    local str40=\"$str38\"\n    local str41=\"$str39\"\
    \n    local str42=\"$str40\"\n    local str43=\"$str41\"\n    local str44=\"$str42\"\
    \n    local str45=\"$str43\"\n    local str46=\"$str44\"\n    local str47=\"$str45\"\
    \n    local str48=\"$str46\"\n    local str49=\"$str47\"\n    local str50=\"$str48\"\
    \n    local str51=\"$str\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprsbbachq.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmprsbbachq.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed\
    \ 's/[()]//g')\"\n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [\
    \ \"$str5\" == \"\" ] || [ \"$str6\" == \"\" ]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=\"\
    \"\n    local str4=\"\"\n    local str5=\"\"\n    local str6=\"\"\n    local str7=\"\
    \"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\"\n    local\
    \ str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local str14=\"\"\
    \n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\n    local\
    \ str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local str21=\"\"\
    \n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\n    local\
    \ str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local str28=\"\"\
    \n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\n    local\
    \ str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local str35=\"\"\
    \n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\n    local\
    \ str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local str42=\"\"\
    \n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\n    local\
    \ str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local str49=\"\"\
    \n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\n    local\
    \ str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local str56=\"\"\
    \n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\n    local\
    \ str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local str63=\"\"\
    \n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\n    local\
    \ str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local str70=\"\"\
    \n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\n    local\
    \ str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local str77=\"\"\
    \n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\n    local\
    \ str81=\"\"\n    local str82=\"\"\n    local str83=\"\"\n    local str84=\"\"\
    \n    local str85=\"\"\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local parens=$1\n    local left=0\n    local right=0\n\
    \    for ((i=0; i<${#parens}; i++)); do\n        if [[ ${parens:$i:1} == '(' ]];\
    \ then\n            left=$((left+1))\n        else\n            right=$((right+1))\n\
    \        fi\n    done\n    if [[ $left -eq $right ]]; then\n        echo 'Yes'\n\
    \    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens=($1)\n    local -i open=0\n    local\
    \ -i close=0\n    for paren in ${parens[@]}; do\n        for ((i=0; i<${#paren};\
    \ i++)); do\n            if [[ ${paren:$i:1} == '(' ]]; then\n               \
    \ ((open++))\n            else\n                ((close++))\n            fi\n\
    \        done\n    done\n    if ((open == close)); then\n        echo 'Yes'\n\
    \    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens\n    local -i i=0\n    local -i\
    \ open=0\n    local -i close=0\n    local -i total=0\n    local -i len=0\n   \
    \ local -i diff=0\n    local -i paren_count=0\n    local -i paren_count_2=0\n\
    \    local -i paren_count_3=0\n    local -i paren_count_4=0\n    local -i paren_count_5=0\n\
    \    local -i paren_count_6=0\n    local -i paren_count_7=0\n    local -i paren_count_8=0\n\
    \    local -i paren_count_9=0\n    local -i paren_count_10=0\n    local -i paren_count_11=0\n\
    \    local -i paren_count_12=0\n    local -i paren_count_13=0\n    local -i paren_count_14=0\n\
    \    local -i paren_count_15=0\n    local -i paren_count_16=0\n    local -i paren_count_17=0\n\
    \    local -i paren_count_18=0\n    local -i paren_count_19=0\n    local -i paren_count_20=0\n\
    \    local -i paren_count_21=0\n    local -i paren_count_22=0\n    local -i paren_count_23=0\n\
    \    local -i paren_count_24=0\n    local -i paren_count_25=0\n    local -i paren_count_26=0\n\
    \    local -i paren_count_27=0\n    local -i paren_count_28=0\n    local -i paren_count_29=0\n\
    \    local -i paren_count_30=0\n    local -i paren_count_31=0\n    local -i paren_count_32=0\n\
    \    local -i paren_count_33=0\n    local -i paren_count_34=0\n    local -i paren_count_35=0\n\
    \    local\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local open=0\n  local close=0\n  for ((i=0; i<${#str3}; i++));\
    \ do\n    if [[ ${str3:$i:1} == '(' ]]; then\n      open=$((open+1))\n    elif\
    \ [[ ${str3:$i:1} == ')' ]]; then\n      close=$((close+1))\n    fi\n    if [[\
    \ $close -gt $open ]]; then\n      echo 'No'\n      return\n    fi\n  done\n \
    \ if [[ $open -eq $close ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\
    \n  local str4=\"$str2$str1\"\n  local str5=\"$str1$str1\"\n  local str6=\"$str2$str2\"\
    \n  local str7=\"$str1$str2$str1\"\n  local str8=\"$str2$str1$str2\"\n  local\
    \ str9=\"$str1$str2$str2\"\n  local str10=\"$str2$str1$str1\"\n  local str11=\"\
    $str1$str1$str2\"\n  local str12=\"$str2$str2$str1\"\n  local str13=\"$str1$str2$str1$str2\"\
    \n  local str14=\"$str2$str1$str2$str1\"\n  local str15=\"$str1$str2$str2$str1\"\
    \n  local str16=\"$str2$str1$str1$str2\"\n  local str17=\"$str1$str1$str2$str2\"\
    \n  local str18=\"$str2$str2$str1$str1\"\n  local str19=\"$str1$str1$str1$str2\"\
    \n  local str20=\"$str2$str2$str2$str1\"\n  local str21=\"$str1$str2$str1$str2$str1\"\
    \n  local str22=\"$str2$str1$str2$str1$str2\"\n  local str23=\"$str1$str2$str2$str1$str2\"\
    \n  local str24=\"$str2$str1$str1$str2$str1\"\n  local str25=\"$str1$str1$str2$str2$str1\"\
    \n  local str26=\"$str2$str2$str1$str1$str2\"\n  local str27=\"$str1$str2$str1$str2$str2\"\
    \n  local str28=\"$str2$str1$str2$str1$str1\"\n  local str29=\"$str1$str1$str1$str2$str2\"\
    \n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\"\
    \ ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \"\
    )()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed -e 's/[()]//g')\n\
    \    local str6=$(echo $str4 | sed -e 's/[()]//g')\n    if [[ -z $str5 ]]; then\n\
    \        echo 'Yes'\n    elif [[ -z $str6 ]]; then\n        echo 'Yes'\n    else\n\
    \        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\
    \n  local str4=\"$str2$str1\"\n  if [[ $(echo \"$str3\" | sed 's/[()]//g') ==\
    \ \"\" ]]; then\n    echo \"Yes\"\n  elif [[ $(echo \"$str4\" | sed 's/[()]//g')\
    \ == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i\n  local -i l\n  local\
    \ -i r\n  local -i n\n  local -i m\n  local -i s\n  local -i t\n  local -i u\n\
    \  local -i v\n  local -i w\n  local -i x\n  local -i y\n  local -i z\n  local\
    \ -i a\n  local -i b\n  local -i c\n  local -i d\n  local -i e\n  local -i f\n\
    \  local -i g\n  local -i h\n  local -i j\n  local -i k\n  local -i o\n  local\
    \ -i p\n  local -i q\n  local -i r\n  local -i s\n  local -i t\n  local -i u\n\
    \  local -i v\n  local -i w\n  local -i x\n  local -i y\n  local -i z\n  local\
    \ -i a\n  local -i b\n  local -i c\n  local -i d\n  local -i e\n  local -i f\n\
    \  local -i g\n  local -i h\n  local -i j\n  local -i k\n  local -i o\n  local\
    \ -i p\n  local -i q\n  local -i r\n  local -i s\n  local -i t\n  local -i u\n\
    \  local -i v\n  local -i w\n  local -i x\n  local -i y\n  local -i z\n  local\
    \ -i a\n  local -i b\n  local -i c\n  local -i d\n  local -i e\n  local -i f\n\
    \  local -i g\n  local -i h\n  local -i j\n  local -i k\n  local -i o\n  local\
    \ -i p\n  local -i q\n  local -i r\n  local -i s\n  local -i t\n  local -i u\n\
    \  local -i v\n  local -i w\n  local -i x\n  local -i y\n  local -i z\n  local\
    \ -i a\n  local -i b\n  local -i c\n  local -i d\n  local -i e\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local open=0\n    local close=0\n    for ((i=0;\
    \ i<${#1}; i++)); do\n        if [[ ${1:$i:1} == '(' ]]; then\n            ((open++))\n\
    \        else\n            ((close++))\n        fi\n    done\n    if [[ $open\
    \ -eq $close ]]; then\n        echo 'Yes'\n    else\n        echo 'No'\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=($1)\n  local -i open=0\n  local -i\
    \ close=0\n  local -i i=0\n  local -i j=0\n  local -i k=0\n  local -i l=0\n  local\
    \ -i m=0\n  local -i n=0\n  local -i o=0\n  local -i p=0\n  local -i q=0\n  local\
    \ -i r=0\n  local -i s=0\n  local -i t=0\n  local -i u=0\n  local -i v=0\n  local\
    \ -i w=0\n  local -i x=0\n  local -i y=0\n  local -i z=0\n  local -i a=0\n  local\
    \ -i b=0\n  local -i c=0\n  local -i d=0\n  local -i e=0\n  local -i f=0\n  local\
    \ -i g=0\n  local -i h=0\n  local -i ii=0\n  local -i jj=0\n  local -i kk=0\n\
    \  local -i ll=0\n  local -i mm=0\n  local -i nn=0\n  local -i oo=0\n  local -i\
    \ pp=0\n  local -i qq=0\n  local -i rr=0\n  local -i ss=0\n  local -i tt=0\n \
    \ local -i uu=0\n  local -i vv=0\n  local -i ww=0\n  local -i xx=0\n  local -i\
    \ yy=0\n  local -i zz=0\n  local -i aa=0\n  local -i bb=0\n  local -i cc=0\n \
    \ local -i dd=0\n  local -i ee=0\n  local -i ff=0\n  local -i gg=0\n  local -i\
    \ hh=0\n  local -i iii=0\n  local -i jjj=0\n  local -i kkk=0\n  local -i lll=0\n\
    \  local -i mmm=0\n  local -i nnn\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local left=\"$(echo \"$1\" | cut -d' ' -f1)\"\n  local\
    \ right=\"$(echo \"$1\" | cut -d' ' -f2)\"\n  local left_count=\"$(echo \"$left\"\
    \ | grep -o '(' | wc -l)\"\n  local right_count=\"$(echo \"$right\" | grep -o\
    \ ')' | wc -l)\"\n  if [[ \"$left_count\" -gt \"$right_count\" ]]; then\n    echo\
    \ 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo 'Yes'\n\
    \  elif [[ -z $str6 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | tr -d '()')\n  local str6=$(echo\
    \ $str4 | tr -d '()')\n  if [[ $str5 == '' ]]; then\n    echo 'Yes'\n  elif [[\
    \ $str6 == '' ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"\"\n    local str4=\"\"\n    local str5=\"\"\n    local str6=\"\"\n \
    \   local str7=\"\"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\
    \"\n    local str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local\
    \ str14=\"\"\n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\
    \n    local str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local\
    \ str21=\"\"\n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\
    \n    local str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local\
    \ str28=\"\"\n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\
    \n    local str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local\
    \ str35=\"\"\n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\
    \n    local str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local\
    \ str42=\"\"\n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\
    \n    local str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local\
    \ str49=\"\"\n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\
    \n    local str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local\
    \ str56=\"\"\n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\
    \n    local str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local\
    \ str63=\"\"\n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\
    \n    local str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local\
    \ str70=\"\"\n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\
    \n    local str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local\
    \ str77=\"\"\n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\
    \n    local str81=\"\"\n    local str82=\"\"\n    local str83=\"\"\n    local\
    \ str84=\"\"\n   \n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == '' ]]; then\n\
    \        echo 'Yes'\n    elif [[ $str6 == '' ]]; then\n        echo 'Yes'\n  \
    \  else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\
    \n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i=0\n  local -i j=0\n\
    \  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n\
    \  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n\
    \  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n\
    \  local -i z=0\n  local -i a=0\n  local -i b=0\n  local -i c=0\n  local -i d=0\n\
    \  local -i e=0\n  local -i f=0\n  local -i g=0\n  local -i h=0\n  local -i ii=0\n\
    \  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i mm=0\n  local -i\
    \ nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n  local -i rr=0\n \
    \ local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i vv=0\n  local -i\
    \ ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n  local -i aa=0\n \
    \ local -i bb=0\n  local -i cc=0\n  local -i dd=0\n  local -i ee=0\n  local -i\
    \ ff=0\n  local -i gg=0\n  local -i hh=0\n  local -i iii=0\n  local -i jjj=0\n\
    \  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n  local -i nnn=0\n  local\
    \ -i ooo=0\n  local -i ppp=0\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i\n  local -i len\n  local\
    \ -i open\n  local -i close\n  local -i balance\n  local -i good\n  local -i bad\n\
    \  local -i total\n  local -i sum\n  local -i left\n  local -i right\n  local\
    \ -i left_balance\n  local -i right_balance\n  local -i left_open\n  local -i\
    \ left_close\n  local -i right_open\n  local -i right_close\n  local -i left_good\n\
    \  local -i left_bad\n  local -i right_good\n  local -i right_bad\n  local -i\
    \ left_total\n  local -i right_total\n  local -i left_sum\n  local -i right_sum\n\
    \  local -i left_len\n  local -i right_len\n  local -i left_i\n  local -i right_i\n\
    \  local -i left_j\n  local -i right_j\n  local -i left_k\n  local -i right_k\n\
    \  local -i left_l\n  local -i right_l\n  local -i left_m\n  local -i right_m\n\
    \  local -i left_n\n  local -i right_n\n  local -i left_o\n  local -i right_o\n\
    \  local -i left_p\n  local -i right_p\n  local -i left_q\n  local -i right_q\n\
    \  local -i left_r\n  local -i right_r\n  local -i left_s\n  local -i right_s\n\
    \  local -i left_t\n  local -i right_t\n  local -i left_u\n  local -i right_u\n\
    \  local -i left_v\n  local -i right_v\n  local -i left_w\n  local -i right_w\n\
    \  local -i left_x\n  local -i right_x\n  local -i left_y\n  local -i right_y\n\
    \  local -i left_z\n  local -i right_z\n  local -i left_aa\n  local -i right_aa\n\
    \  local -i left\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | tr -d '()')\n  local str6=$(echo\
    \ $str4 | tr -d '()')\n  if [[ $str5 == '' ]]; then\n    echo 'Yes'\n  elif [[\
    \ $str6 == '' ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local s1=$1\n    local s2=$2\n    local s3=\"\"\n\
    \    local s4=\"\"\n    local s5=\"\"\n    local s6=\"\"\n    local s7=\"\"\n\
    \    local s8=\"\"\n    local s9=\"\"\n    local s10=\"\"\n    local s11=\"\"\n\
    \    local s12=\"\"\n    local s13=\"\"\n    local s14=\"\"\n    local s15=\"\"\
    \n    local s16=\"\"\n    local s17=\"\"\n    local s18=\"\"\n    local s19=\"\
    \"\n    local s20=\"\"\n    local s21=\"\"\n    local s22=\"\"\n    local s23=\"\
    \"\n    local s24=\"\"\n    local s25=\"\"\n    local s26=\"\"\n    local s27=\"\
    \"\n    local s28=\"\"\n    local s29=\"\"\n    local s30=\"\"\n    local s31=\"\
    \"\n    local s32=\"\"\n    local s33=\"\"\n    local s34=\"\"\n    local s35=\"\
    \"\n    local s36=\"\"\n    local s37=\"\"\n    local s38=\"\"\n    local s39=\"\
    \"\n    local s40=\"\"\n    local s41=\"\"\n    local s42=\"\"\n    local s43=\"\
    \"\n    local s44=\"\"\n    local s45=\"\"\n    local s46=\"\"\n    local s47=\"\
    \"\n    local s48=\"\"\n    local s49=\"\"\n    local s50=\"\"\n    local s51=\"\
    \"\n    local s52=\"\"\n    local s53=\"\"\n    local s54=\"\"\n    local s55=\"\
    \"\n    local s56=\"\"\n    local s57=\"\"\n    local s58=\"\"\n    local s59=\"\
    \"\n    local s60=\"\"\n    local s61=\"\"\n    local s62=\"\"\n    local s63=\"\
    \"\n    local s64=\"\"\n    local s65=\"\"\n    local s66=\"\"\n    local s67=\"\
    \"\n    local s68=\"\"\n    local s69=\"\"\n    local s70=\"\"\n    local s71=\"\
    \"\n    local s72=\"\"\n    local s73=\"\"\n    local s74=\"\"\n    local s75=\"\
    \"\n    local s76=\"\"\n    local s77=\"\"\n    local s78=\"\"\n    local s79=\"\
    \"\n    local s80=\"\"\n    local s81=\"\"\n    local s82=\"\"\n    local s83=\"\
    \"\n    local s84=\"\"\n    local s85=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s=$1\n  local count=0\n  for ((i=0; i<${#s};\
    \ i++)); do\n    if [[ ${s:$i:1} == '(' ]]; then\n      ((count++))\n    else\n\
    \      ((count--))\n    fi\n    if ((count < 0)); then\n      echo 'No'\n    \
    \  return\n    fi\n  done\n  if ((count == 0)); then\n    echo 'Yes'\n  else\n\
    \    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$3\n\
    \  local str4=$4\n  local str5=$5\n  local str6=$6\n  local str7=$7\n  local str8=$8\n\
    \  local str9=$9\n  local str10=${10}\n  local str11=${11}\n  local str12=${12}\n\
    \  local str13=${13}\n  local str14=${14}\n  local str15=${15}\n  local str16=${16}\n\
    \  local str17=${17}\n  local str18=${18}\n  local str19=${19}\n  local str20=${20}\n\
    \  local str21=${21}\n  local str22=${22}\n  local str23=${23}\n  local str24=${24}\n\
    \  local str25=${25}\n  local str26=${26}\n  local str27=${27}\n  local str28=${28}\n\
    \  local str29=${29}\n  local str30=${30}\n  local str31=${31}\n  local str32=${32}\n\
    \  local str33=${33}\n  local str34=${34}\n  local str35=${35}\n  local str36=${36}\n\
    \  local str37=${37}\n  local str38=${38}\n  local str39=${39}\n  local str40=${40}\n\
    \  local str41=${41}\n  local str42=${42}\n  local str43=${43}\n  local str44=${44}\n\
    \  local str45=${45}\n  local str46=${46}\n  local str47=${47}\n  local str48=${48}\n\
    \  local str49=${49}\n  local str50=${50}\n  local str51=${51}\n  local str52=${52}\n\
    \  local str53=${53}\n  local str54=${54}\n  local str55=${55}\n  local str56=${56}\n\
    \  local str57=${57}\n  local str58=${58}\n  local str59=${59\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmp5wsfvvjj.sh: line 98: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed -e 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed -e 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n  \
    \  echo \"Yes\"\n  elif [[ $str6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n\
    \    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"$str1$str2\"\
    \n  local str4=\"$str2$str1\"\n  local str5=\"$str1$str1\"\n  local str6=\"$str2$str2\"\
    \n  local str7=\"$str1$str2$str1\"\n  local str8=\"$str2$str1$str2\"\n  local\
    \ str9=\"$str1$str2$str2\"\n  local str10=\"$str2$str1$str1\"\n  local str11=\"\
    $str1$str1$str2\"\n  local str12=\"$str2$str2$str1\"\n  local str13=\"$str1$str2$str1$str2\"\
    \n  local str14=\"$str2$str1$str2$str1\"\n  local str15=\"$str1$str2$str2$str1\"\
    \n  local str16=\"$str2$str1$str1$str2\"\n  local str17=\"$str1$str1$str2$str2\"\
    \n  local str18=\"$str2$str2$str1$str1\"\n  local str19=\"$str1$str1$str1$str2\"\
    \n  local str20=\"$str2$str2$str2$str1\"\n  local str21=\"$str1$str2$str1$str2$str1\"\
    \n  local str22=\"$str2$str1$str2$str1$str2\"\n  local str23=\"$str1$str2$str2$str1$str2\"\
    \n  local str24=\"$str2$str1$str1$str2$str1\"\n  local str25=\"$str1$str1$str2$str2$str1\"\
    \n  local str26=\"$str2$str2$str1$str1$str2\"\n  local str27=\"$str1$str2$str1$str2$str2\"\
    \n  local str28=\"$str2$str1$str2$str1$str1\"\n  local str29=\"$str1$str1$str1$str2$str2\"\
    \n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n   \
    \ [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\"\
    \ ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \"\
    )()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo 'Yes'\n\
    \  elif [[ -z $str6 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i=0\n  local -i len=0\n\
    \  local -i open=0\n  local -i close=0\n  local -i total=0\n  local -i balance=0\n\
    \  local -i parens_len=0\n  local -i parens_open=0\n  local -i parens_close=0\n\
    \  local -i parens_balance=0\n  local -i parens_total=0\n  local -i parens_balance_diff=0\n\
    \  local -i parens_total_diff=0\n  local -i parens_balance_diff_abs=0\n  local\
    \ -i parens_total_diff_abs=0\n  local -i parens_balance_diff_abs_min=0\n  local\
    \ -i parens_total_diff_abs_min=0\n  local -i parens_balance_diff_abs_min_idx=0\n\
    \  local -i parens_total_diff_abs_min_idx=0\n  local -i parens_balance_diff_abs_min_idx_final=0\n\
    \  local -i parens_total_diff_abs_min_idx_final=0\n  local -i parens_balance_diff_abs_min_idx_final_final=0\n\
    \  local -i parens_total_diff_abs_min_idx_final_final=0\n  local -i parens_balance_diff_abs_min_idx_final_final_final=0\n\
    \  local -i parens_total_diff_abs_min_idx_final_final_final=0\n  local -i parens_balance_diff_abs_min_idx_final_final_final_final=0\n\
    \  local -i parens_total_diff_abs_min_idx_final_final_final_final=0\n  local -i\
    \ parens_balance_diff_abs_min_idx_final_final_final_final_final=0\n  local -i\
    \ parens_total_diff_abs_min_idx\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  parens=($1)\n  local -i open=0\n\
    \  local -i close=0\n  for paren in \"${parens[@]}\"; do\n    for ((i=0; i<${#paren};\
    \ i++)); do\n      if [[ ${paren:$i:1} == '(' ]]; then\n        ((open++))\n \
    \     else\n        ((close++))\n      fi\n    done\n  done\n  if ((open == close));\
    \ then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/()//g')\n   \
    \ local str6=$(echo $str4 | sed 's/()//g')\n    if [[ $str5 == \"\" ]]; then\n\
    \        echo \"Yes\"\n    elif [[ $str6 == \"\" ]]; then\n        echo \"Yes\"\
    \n    else\n        echo \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$str3\"\
    \n    local str6=\"$str4\"\n    local str7=\"$str5\"\n    local str8=\"$str6\"\
    \n    local str9=\"$str7\"\n    local str10=\"$str8\"\n    local str11=\"$str9\"\
    \n    local str12=\"$str10\"\n    local str13=\"$str11\"\n    local str14=\"$str12\"\
    \n    local str15=\"$str13\"\n    local str16=\"$str14\"\n    local str17=\"$str15\"\
    \n    local str18=\"$str16\"\n    local str19=\"$str17\"\n    local str20=\"$str18\"\
    \n    local str21=\"$str19\"\n    local str22=\"$str20\"\n    local str23=\"$str21\"\
    \n    local str24=\"$str22\"\n    local str25=\"$str23\"\n    local str26=\"$str24\"\
    \n    local str27=\"$str25\"\n    local str28=\"$str26\"\n    local str29=\"$str27\"\
    \n    local str30=\"$str28\"\n    local str31=\"$str29\"\n    local str32=\"$str30\"\
    \n    local str33=\"$str31\"\n    local str34=\"$str32\"\n    local str35=\"$str33\"\
    \n    local str36=\"$str34\"\n    local str37=\"$str35\"\n    local str38=\"$str36\"\
    \n    local str39=\"$str37\"\n    local str40=\"$str38\"\n    local str41=\"$str39\"\
    \n    local str42=\"$str40\"\n    local str43=\"$str41\"\n    local str44=\"$str42\"\
    \n    local str45=\"$str43\"\n    local str46=\"$str44\"\n    local str47=\"$str45\"\
    \n    local str48=\"$str46\"\n    local str49=\"$str47\"\n    local str50=\"$str48\"\
    \n    local str51=\"$str\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset\
    \ -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmprsbbachq.sh: line 86: unexpected EOF while looking for matching
    `"''

    /tmp/tmprsbbachq.sh: line 90: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=$str1$str2\n\
    \    local str4=$str2$str1\n    local str5=$(echo $str3 | sed 's/[()]//g')\n \
    \   local str6=$(echo $str4 | sed 's/[()]//g')\n    if [[ -z $str5 ]]; then\n\
    \        echo 'Yes'\n    elif [[ -z $str6 ]]; then\n        echo 'Yes'\n    else\n\
    \        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\n\
    set -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=''\n\
    \  local str4=''\n  local str5=''\n  local str6=''\n  local str7=''\n  local str8=''\n\
    \  local str9=''\n  local str10=''\n  local str11=''\n  local str12=''\n  local\
    \ str13=''\n  local str14=''\n  local str15=''\n  local str16=''\n  local str17=''\n\
    \  local str18=''\n  local str19=''\n  local str20=''\n  local str21=''\n  local\
    \ str22=''\n  local str23=''\n  local str24=''\n  local str25=''\n  local str26=''\n\
    \  local str27=''\n  local str28=''\n  local str29=''\n  local str30=''\n  local\
    \ str31=''\n  local str32=''\n  local str33=''\n  local str34=''\n  local str35=''\n\
    \  local str36=''\n  local str37=''\n  local str38=''\n  local str39=''\n  local\
    \ str40=''\n  local str41=''\n  local str42=''\n  local str43=''\n  local str44=''\n\
    \  local str45=''\n  local str46=''\n  local str47=''\n  local str48=''\n  local\
    \ str49=''\n  local str50=''\n  local str51=''\n  local str52=''\n  local str53=''\n\
    \  local str54=''\n  local str55=''\n  local str56=''\n  local str57=''\n  local\
    \ str58=''\n  local str59=''\n  local str60=''\n  local str61=''\n  local str62=''\n\
    \  local str63=''\n  local str64=''\n  local str65=''\n  local str66=''\n  local\
    \ str67=''\n  local str68=''\n  local str69=''\n  local str70=''\n  local str71=''\n\
    \  local str72=''\n  local str73=''\n\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local s1=$1\n  local s2=$2\n  local s3=$s1$s2\n  local\
    \ s4=$s2$s1\n  local s5=$(echo $s3 | sed 's/[()]//g')\n  local s6=$(echo $s4 |\
    \ sed 's/[()]//g')\n  if [[ $s5 == \"\" ]]; then\n    echo \"Yes\"\n  elif [[\
    \ $s6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\n\
    candidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens=(\"$@\")\n  local -i i=0\n  local\
    \ -i j=0\n  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local\
    \ -i o=0\n  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local\
    \ -i t=0\n  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local\
    \ -i y=0\n  local -i z=0\n  local -i a=0\n  local -i b=0\n  local -i c=0\n  local\
    \ -i d=0\n  local -i e=0\n  local -i f=0\n  local -i g=0\n  local -i h=0\n  local\
    \ -i ii=0\n  local -i jj=0\n  local -i kk=0\n  local -i ll=0\n  local -i mm=0\n\
    \  local -i nn=0\n  local -i oo=0\n  local -i pp=0\n  local -i qq=0\n  local -i\
    \ rr=0\n  local -i ss=0\n  local -i tt=0\n  local -i uu=0\n  local -i vv=0\n \
    \ local -i ww=0\n  local -i xx=0\n  local -i yy=0\n  local -i zz=0\n  local -i\
    \ aa=0\n  local -i bb=0\n  local -i cc=0\n  local -i dd=0\n  local -i ee=0\n \
    \ local -i ff=0\n  local -i gg=0\n  local -i hh=0\n  local -i iii=0\n  local -i\
    \ jjj=0\n  local -i kkk=0\n  local -i lll=0\n  local -i mmm=0\n  local -i nnn=0\n\
    \  local -i ooo=0\n  local -\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str=\"\
    $str1$str2\"\n  local len=${#str}\n  local i=0\n  local count=0\n  while [ $i\
    \ -lt $len ]; do\n    if [ \"${str:$i:1}\" == \"(\" ]; then\n      count=$((count\
    \ + 1))\n    else\n      count=$((count - 1))\n    fi\n    if [ $count -lt 0 ];\
    \ then\n      echo \"No\"\n      return\n    fi\n    i=$((i + 1))\n  done\n  if\
    \ [ $count -eq 0 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local left=$(echo \"$1\" | cut -d' ' -f1)\n    local\
    \ right=$(echo \"$1\" | cut -d' ' -f2)\n    local left_count=$(echo \"$left\"\
    \ | grep -o '(' | wc -l)\n    local right_count=$(echo \"$right\" | grep -o ')'\
    \ | wc -l)\n    if [[ $left_count -eq $right_count ]]; then\n        echo 'Yes'\n\
    \    else\n        echo 'No'\n    fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a a=($1)\n  local -i i=0\n  local -i j=0\n\
    \  local -i k=0\n  local -i l=0\n  local -i m=0\n  local -i n=0\n  local -i o=0\n\
    \  local -i p=0\n  local -i q=0\n  local -i r=0\n  local -i s=0\n  local -i t=0\n\
    \  local -i u=0\n  local -i v=0\n  local -i w=0\n  local -i x=0\n  local -i y=0\n\
    \  local -i z=0\n  local -i A=0\n  local -i B=0\n  local -i C=0\n  local -i D=0\n\
    \  local -i E=0\n  local -i F=0\n  local -i G=0\n  local -i H=0\n  local -i I=0\n\
    \  local -i J=0\n  local -i K=0\n  local -i L=0\n  local -i M=0\n  local -i N=0\n\
    \  local -i O=0\n  local -i P=0\n  local -i Q=0\n  local -i R=0\n  local -i S=0\n\
    \  local -i T=0\n  local -i U=0\n  local -i V=0\n  local -i W=0\n  local -i X=0\n\
    \  local -i Y=0\n  local -i Z=0\n  local -i aa=0\n  local -i ab=0\n  local -i\
    \ ac=0\n  local -i ad=0\n  local -i ae=0\n  local -i af=0\n  local -i ag=0\n \
    \ local -i ah=0\n  local -i ai=0\n  local -i aj=0\n  local -i ak=0\n  local -i\
    \ al=0\n  local -i am=0\n  local -i an=0\n  local -i ao=0\n  local -i ap=0\n \
    \ local -i aq=0\n  local -i ar=0\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=0\n  local count2=0\n  local count3=0\n\
    \  local count4=0\n  for (( i=0; i<${#str1}; i++ )); do\n    if [[ ${str1:$i:1}\
    \ == '(' ]]; then\n      count1=$((count1+1))\n    else\n      count1=$((count1-1))\n\
    \    fi\n  done\n  for (( i=0; i<${#str2}; i++ )); do\n    if [[ ${str2:$i:1}\
    \ == '(' ]]; then\n      count2=$((count2+1))\n    else\n      count2=$((count2-1))\n\
    \    fi\n  done\n  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1}\
    \ == '(' ]]; then\n      count3=$((count3+1))\n    else\n      count3=$((count3-1))\n\
    \    fi\n  done\n  for (( i=0; i<${#str4}; i++ )); do\n    if [[ ${str4:$i:1}\
    \ == '(' ]]; then\n      count4=$((count4+1))\n    else\n      count4=$((count4-1))\n\
    \    fi\n  done\n  if [[ $count1 -eq 0 || $count2 -eq 0 || $count3 -eq 0 || $count4\
    \ -eq 0 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a stack\n    local -i i=0\n    local -i len=${#1}\n\
    \    local -i open=0\n    local -i close=0\n    local -i top=0\n    local -i balance=0\n\
    \    local -i total=0\n    local -i index=0\n    local -i count=0\n    local -i\
    \ flag=0\n    local -i flag2=0\n    local -i flag3=0\n    local -i flag4=0\n \
    \   local -i flag5=0\n    local -i flag6=0\n    local -i flag7=0\n    local -i\
    \ flag8=0\n    local -i flag9=0\n    local -i flag10=0\n    local -i flag11=0\n\
    \    local -i flag12=0\n    local -i flag13=0\n    local -i flag14=0\n    local\
    \ -i flag15=0\n    local -i flag16=0\n    local -i flag17=0\n    local -i flag18=0\n\
    \    local -i flag19=0\n    local -i flag20=0\n    local -i flag21=0\n    local\
    \ -i flag22=0\n    local -i flag23=0\n    local -i flag24=0\n    local -i flag25=0\n\
    \    local -i flag26=0\n    local -i flag27=0\n    local -i flag28=0\n    local\
    \ -i flag29=0\n    local -i flag30=0\n    local -i flag31=0\n    local -i flag32=0\n\
    \    local -i flag33=0\n    local -i flag34=0\n    local -i flag35=0\n    local\
    \ -i flag36=0\n    local -i flag37=0\n    local -i flag38=0\n    local -i flag39=0\n\
    \    local -i flag40=0\n    local -i flag41=0\n    local -i flag42=0\n    local\
    \ -i flag43=0\n    local -i flag44=0\n    local -i flag45=0\n    local -i flag46=0\n\
    \    local -i flag47=0\n    local -i flag48=0\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local len1=${#str1}\n  local len2=${#str2}\n\
    \  local len3=${#str3}\n  local len4=${#str4}\n  local i=0\n  local j=0\n  local\
    \ k=0\n  local l=0\n  local m=0\n  local n=0\n  local o=0\n  local p=0\n  local\
    \ q=0\n  local r=0\n  local s=0\n  local t=0\n  local u=0\n  local v=0\n  local\
    \ w=0\n  local x=0\n  local y=0\n  local z=0\n  local aa=0\n  local bb=0\n  local\
    \ cc=0\n  local dd=0\n  local ee=0\n  local ff=0\n  local gg=0\n  local hh=0\n\
    \  local ii=0\n  local jj=0\n  local kk=0\n  local ll=0\n  local mm=0\n  local\
    \ nn=0\n  local oo=0\n  local pp=0\n  local qq=0\n  local rr=0\n  local ss=0\n\
    \  local tt=0\n  local uu=0\n  local vv=0\n  local ww=0\n  local xx=0\n  local\
    \ yy=0\n  local zz=0\n  local aaa=0\n  local bbb=0\n  local ccc=0\n  local ddd=0\n\
    \  local eee=0\n  local fff=0\n  local ggg=0\n  local hhh=0\n  local iii=0\n \
    \ local jjj=0\n  local kkk=0\n  local lll=0\n  local mmm=0\n  local nnn=0\n  local\
    \ ooo=0\n  local ppp=0\n  local qqq=0\n  local rrr=0\n  local sss=0\n  local ttt=0\n\
    \  local u\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $str6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ -z $str5 ]]; then\n    echo 'Yes'\n\
    \  elif [[ -z $str6 ]]; then\n    echo 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\
    \ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate\
    \ \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a list=($1)\n    local -i i=0\n    local\
    \ -i j=0\n    local -i k=0\n    local -i l=0\n    local -i m=0\n    local -i n=0\n\
    \    local -i o=0\n    local -i p=0\n    local -i q=0\n    local -i r=0\n    local\
    \ -i s=0\n    local -i t=0\n    local -i u=0\n    local -i v=0\n    local -i w=0\n\
    \    local -i x=0\n    local -i y=0\n    local -i z=0\n    local -i aa=0\n   \
    \ local -i bb=0\n    local -i cc=0\n    local -i dd=0\n    local -i ee=0\n   \
    \ local -i ff=0\n    local -i gg=0\n    local -i hh=0\n    local -i ii=0\n   \
    \ local -i jj=0\n    local -i kk=0\n    local -i ll=0\n    local -i mm=0\n   \
    \ local -i nn=0\n    local -i oo=0\n    local -i pp=0\n    local -i qq=0\n   \
    \ local -i rr=0\n    local -i ss=0\n    local -i tt=0\n    local -i uu=0\n   \
    \ local -i vv=0\n    local -i ww=0\n    local -i xx=0\n    local -i yy=0\n   \
    \ local -i zz=0\n    local -i aaa=0\n    local -i bbb=0\n    local -i ccc=0\n\
    \    local -i ddd=0\n    local -i eee=0\n    local -i fff=0\n    local -i ggg=0\n\
    \    local -i hhh=0\n    local -i iii=0\n    local -i jjj=0\n    local -i kkk=0\n\
    \    local -i lll=0\n    local -i mmm=0\n    local -i nnn=0\n    local -i ooo=\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a arr=(\"$@\")\n  local str1=\"${arr[0]}\"\n\
    \  local str2=\"${arr[1]}\"\n  local str3=\"${str1}${str2}\"\n  local str4=\"\
    ${str2}${str1}\"\n  local str5=\"${str3//(/}\"\n  local str6=\"${str3//)/}\"\n\
    \  local str7=\"${str4//(/}\"\n  local str8=\"${str4//)/}\"\n  if [[ \"${str5}\"\
    \ == \"${str6}\" ]] && [[ \"${str7}\" == \"${str8}\" ]]; then\n    echo \"Yes\"\
    \n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n\
    }\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[\
    \ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"\
    No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 2
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=${str1}${str2}\n\
    \    local str4=${str2}${str1}\n    local str5=${str1}${str1}\n    local str6=${str2}${str2}\n\
    \    local str7=${str1}${str2}${str1}\n    local str8=${str2}${str1}${str2}\n\
    \    local str9=${str1}${str2}${str2}\n    local str10=${str2}${str1}${str1}\n\
    \    local str11=${str1}${str1}${str2}\n    local str12=${str2}${str2}${str1}\n\
    \    local str13=${str1}${str2}${str1}${str2}\n    local str14=${str2}${str1}${str2}${str1}\n\
    \    local str15=${str1}${str2}${str2}${str1}\n    local str16=${str2}${str1}${str1}${str2}\n\
    \    local str17=${str1}${str1}${str2}${str2}\n    local str18=${str2}${str2}${str1}${str1}\n\
    \    local str19=${str1}${str2}${str1}${str2}${str1}\n    local str20=${str2}${str1}${str2}${str1}${str2}\n\
    \    local str21=${str1}${str2}${str2}${str1}${str2}\n    local str22=${str2}${str1}${str1}${str2}${str1}\n\
    \    local str23=${str1}${str1}${str2}${str2}${str1}\n    local str24=${str2}${str2}${str1}${str1}${str2}\n\
    \    local str25=${str1}${str2}${str1}${str2}${str1}${str2}\n    local str26=${str2}${str1}${str\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: SyntaxError
  stderr: '/tmp/tmpjndjzriu.sh: line 65: syntax error: unexpected end of file

    '
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local count1=0\n  local count2=0\n  local count3=0\n\
    \  local count4=0\n  for (( i=0; i<${#str1}; i++ )); do\n    if [[ ${str1:$i:1}\
    \ == '(' ]]; then\n      (( count1++ ))\n    else\n      (( count1-- ))\n    fi\n\
    \  done\n  for (( i=0; i<${#str2}; i++ )); do\n    if [[ ${str2:$i:1} == '(' ]];\
    \ then\n      (( count2++ ))\n    else\n      (( count2-- ))\n    fi\n  done\n\
    \  for (( i=0; i<${#str3}; i++ )); do\n    if [[ ${str3:$i:1} == '(' ]]; then\n\
    \      (( count3++ ))\n    else\n      (( count3-- ))\n    fi\n  done\n  for ((\
    \ i=0; i<${#str4}; i++ )); do\n    if [[ ${str4:$i:1} == '(' ]]; then\n      ((\
    \ count4++ ))\n    else\n      (( count4-- ))\n    fi\n  done\n  if [[ $count1\
    \ -eq 0 || $count2 -eq 0 || $count3 -eq 0 || $count4 -eq 0 ]]; then\n    echo\
    \ 'Yes'\n  else\n    echo 'No'\n  fi\n}\n\ncandidate() {\n    match_parens \"\
    $@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1 str2\n    str1=\"$1\"\n    str2=\"$2\"\
    \n    local str1_len str2_len\n    str1_len=\"${#str1}\"\n    str2_len=\"${#str2}\"\
    \n    local str1_open str1_close\n    str1_open=\"$(echo \"$str1\" | grep -o '('\
    \ | wc -l)\"\n    str1_close=\"$(echo \"$str1\" | grep -o ')' | wc -l)\"\n   \
    \ local str2_open str2_close\n    str2_open=\"$(echo \"$str2\" | grep -o '(' |\
    \ wc -l)\"\n    str2_close=\"$(echo \"$str2\" | grep -o ')' | wc -l)\"\n    local\
    \ str1_diff str2_diff\n    str1_diff=$((str1_open - str1_close))\n    str2_diff=$((str2_open\
    \ - str2_close))\n    local str1_diff_abs str2_diff_abs\n    str1_diff_abs=$((str1_diff\
    \ < 0 ? -str1_diff : str1_diff))\n    str2_diff_abs=$((str2_diff < 0 ? -str2_diff\
    \ : str2_diff))\n    local str_diff\n    str_diff=$((str1_diff_abs + str2_diff_abs))\n\
    \    if [[ $str_diff -eq 0 ]]; then\n        echo \"Yes\"\n    else\n        echo\
    \ \"No\"\n    fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995715
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local -a parens\n    local -i open=0\n    local\
    \ -i close=0\n    local -i i\n    local -i j\n    local -i k\n    local -i l\n\
    \    local -i m\n    local -i n\n    local -i o\n    local -i p\n    local -i\
    \ q\n    local -i r\n    local -i s\n    local -i t\n    local -i u\n    local\
    \ -i v\n    local -i w\n    local -i x\n    local -i y\n    local -i z\n    local\
    \ -i aa\n    local -i bb\n    local -i cc\n    local -i dd\n    local -i ee\n\
    \    local -i ff\n    local -i gg\n    local -i hh\n    local -i ii\n    local\
    \ -i jj\n    local -i kk\n    local -i ll\n    local -i mm\n    local -i nn\n\
    \    local -i oo\n    local -i pp\n    local -i qq\n    local -i rr\n    local\
    \ -i ss\n    local -i tt\n    local -i uu\n    local -i vv\n    local -i ww\n\
    \    local -i xx\n    local -i yy\n    local -i zz\n    local -i aaa\n    local\
    \ -i bbb\n    local -i ccc\n    local -i ddd\n    local -i eee\n    local -i fff\n\
    \    local -i ggg\n    local -i hhh\n    local -i iii\n    local -i jjj\n    local\
    \ -i kkk\n    local -i lll\n    local -i mmm\n    local -i nnn\n    local -i ooo\n\
    \    local -i ppp\n    local -i qqq\n    local -i rrr\n    local -i sss\n    local\
    \ -i ttt\n    local -i uuu\n    local -i vvv\n    local -i www\n    local -i xxx\n\
    \    local -i yyy\n    local -i zzz\n    local -i aaaa\n    local -i bbbb\n  \
    \  local -i cccc\n    local -\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\
    \nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n \
    \   [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(())))\
    \ (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[\
    \ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=\"\"\n\
    \  local str4=\"\"\n  local str5=\"\"\n  local str6=\"\"\n  local str7=\"\"\n\
    \  local str8=\"\"\n  local str9=\"\"\n  local str10=\"\"\n  local str11=\"\"\n\
    \  local str12=\"\"\n  local str13=\"\"\n  local str14=\"\"\n  local str15=\"\"\
    \n  local str16=\"\"\n  local str17=\"\"\n  local str18=\"\"\n  local str19=\"\
    \"\n  local str20=\"\"\n  local str21=\"\"\n  local str22=\"\"\n  local str23=\"\
    \"\n  local str24=\"\"\n  local str25=\"\"\n  local str26=\"\"\n  local str27=\"\
    \"\n  local str28=\"\"\n  local str29=\"\"\n  local str30=\"\"\n  local str31=\"\
    \"\n  local str32=\"\"\n  local str33=\"\"\n  local str34=\"\"\n  local str35=\"\
    \"\n  local str36=\"\"\n  local str37=\"\"\n  local str38=\"\"\n  local str39=\"\
    \"\n  local str40=\"\"\n  local str41=\"\"\n  local str42=\"\"\n  local str43=\"\
    \"\n  local str44=\"\"\n  local str45=\"\"\n  local str46=\"\"\n  local str47=\"\
    \"\n  local str48=\"\"\n  local str49=\"\"\n  local str50=\"\"\n  local str51=\"\
    \"\n  local str52=\"\"\n  local str53=\"\"\n  local str54=\"\"\n  local str55=\"\
    \"\n  local str56=\"\"\n  local str57=\"\"\n  local str58=\"\"\n  local str59=\"\
    \"\n  local str60=\"\"\n  local str61=\"\"\n  local str62=\"\"\n  local str63=\"\
    \"\n  local str64=\"\"\n  local str65=\"\"\n  local str66=\"\"\n  local str67=\"\
    \"\n  local str68=\"\"\n  local str69=\"\"\n  local str70=\"\"\n  local str71=\"\
    \"\n  local str72=\"\"\n  local str73=\"\"\n  local str74=\"\"\n  local str75=\"\
    \"\n  local str76=\"\"\n  local str77=\"\"\n  local str78=\"\"\n  local str79=\"\
    \"\n  local str80=\"\"\n  local str81=\"\"\n  local str82=\"\"\n  local str83=\"\
    \"\n  local str84=\"\"\n  local str85=\"\"\n}\n\ncandidate() {\n    match_parens\
    \ \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n\
    \    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\"\
    ) = \"No\" ]]\n    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate\
    \ \")( )(\") = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local str4=\"$str2$str1\"\n  local str5=\"$(echo \"$str3\" | sed\
    \ 's/[()]//g')\"\n  local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\n  if [[\
    \ \"$str5\" == \"\" ]]; then\n    echo \"Yes\"\n  elif [[ \"$str6\" == \"\" ]];\
    \ then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate() {\n\
    \    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"()(\
    \ )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"$str2$str1\"\n    local str5=\"$(echo\
    \ \"$str3\" | sed 's/[()]//g')\"\n    local str6=\"$(echo \"$str4\" | sed 's/[()]//g')\"\
    \n    if [[ \"$str5\" == \"\" ]]; then\n        echo \"Yes\"\n    elif [[ \"$str6\"\
    \ == \"\" ]]; then\n        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n\
    }\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[\
    \ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n\
    \    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")())\
    \ (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[\
    \ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n\
    }\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=\"$1\"\n    local str2=\"$2\"\n    local\
    \ str3=\"$str1$str2\"\n    local str4=\"\"\n    local str5=\"\"\n    local str6=\"\
    \"\n    local str7=\"\"\n    local str8=\"\"\n    local str9=\"\"\n    local str10=\"\
    \"\n    local str11=\"\"\n    local str12=\"\"\n    local str13=\"\"\n    local\
    \ str14=\"\"\n    local str15=\"\"\n    local str16=\"\"\n    local str17=\"\"\
    \n    local str18=\"\"\n    local str19=\"\"\n    local str20=\"\"\n    local\
    \ str21=\"\"\n    local str22=\"\"\n    local str23=\"\"\n    local str24=\"\"\
    \n    local str25=\"\"\n    local str26=\"\"\n    local str27=\"\"\n    local\
    \ str28=\"\"\n    local str29=\"\"\n    local str30=\"\"\n    local str31=\"\"\
    \n    local str32=\"\"\n    local str33=\"\"\n    local str34=\"\"\n    local\
    \ str35=\"\"\n    local str36=\"\"\n    local str37=\"\"\n    local str38=\"\"\
    \n    local str39=\"\"\n    local str40=\"\"\n    local str41=\"\"\n    local\
    \ str42=\"\"\n    local str43=\"\"\n    local str44=\"\"\n    local str45=\"\"\
    \n    local str46=\"\"\n    local str47=\"\"\n    local str48=\"\"\n    local\
    \ str49=\"\"\n    local str50=\"\"\n    local str51=\"\"\n    local str52=\"\"\
    \n    local str53=\"\"\n    local str54=\"\"\n    local str55=\"\"\n    local\
    \ str56=\"\"\n    local str57=\"\"\n    local str58=\"\"\n    local str59=\"\"\
    \n    local str60=\"\"\n    local str61=\"\"\n    local str62=\"\"\n    local\
    \ str63=\"\"\n    local str64=\"\"\n    local str65=\"\"\n    local str66=\"\"\
    \n    local str67=\"\"\n    local str68=\"\"\n    local str69=\"\"\n    local\
    \ str70=\"\"\n    local str71=\"\"\n    local str72=\"\"\n    local str73=\"\"\
    \n    local str74=\"\"\n    local str75=\"\"\n    local str76=\"\"\n    local\
    \ str77=\"\"\n    local str78=\"\"\n    local str79=\"\"\n    local str80=\"\"\
    \n    local str81=\"\"\n    local str82=\"\"\n    local str83=\"\"\n\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local -a parens\n  local -i i\n  local -i j\n  local\
    \ -i k\n  local -i l\n  local -i m\n  local -i n\n  local -i o\n  local -i p\n\
    \  local -i q\n  local -i r\n  local -i s\n  local -i t\n  local -i u\n  local\
    \ -i v\n  local -i w\n  local -i x\n  local -i y\n  local -i z\n  local -i aa\n\
    \  local -i bb\n  local -i cc\n  local -i dd\n  local -i ee\n  local -i ff\n \
    \ local -i gg\n  local -i hh\n  local -i ii\n  local -i jj\n  local -i kk\n  local\
    \ -i ll\n  local -i mm\n  local -i nn\n  local -i oo\n  local -i pp\n  local -i\
    \ qq\n  local -i rr\n  local -i ss\n  local -i tt\n  local -i uu\n  local -i vv\n\
    \  local -i ww\n  local -i xx\n  local -i yy\n  local -i zz\n  local -i aaa\n\
    \  local -i bbb\n  local -i ccc\n  local -i ddd\n  local -i eee\n  local -i fff\n\
    \  local -i ggg\n  local -i hhh\n  local -i iii\n  local -i jjj\n  local -i kkk\n\
    \  local -i lll\n  local -i mmm\n  local -i nnn\n  local -i ooo\n  local -i ppp\n\
    \  local -i qqq\n  local -i rrr\n  local -i sss\n  local -i ttt\n  local -i uuu\n\
    \  local -i vvv\n  local -i www\n  local -i xxx\n  local -i yyy\n  local -i zzz\n\
    \  local -i aaaa\n  local -i bbbb\n  local -i cccc\n  local -i dddd\n  local -i\
    \ eeee\n  local -\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\n\
    run_test() {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) )\") = \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[\
    \ $(candidate \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\"\
    ) = \"Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()( ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n\
    \    [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\")\
    \ = \"No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \"\
    ) (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=$1\n  local str2=$2\n  local str3=$str1$str2\n\
    \  local str4=$str2$str1\n  local str5=$(echo $str3 | sed 's/[()]//g')\n  local\
    \ str6=$(echo $str4 | sed 's/[()]//g')\n  if [[ $str5 == \"\" ]]; then\n    echo\
    \ \"Yes\"\n  elif [[ $str6 == \"\" ]]; then\n    echo \"Yes\"\n  else\n    echo\
    \ \"No\"\n  fi\n}\n\ncandidate() {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test()\
    \ {\n    [[ $(candidate \"()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") =\
    \ \"No\" ]]\n    [[ $(candidate \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate\
    \ \")()) (()()(\") = \"Yes\" ]]\n    [[ $(candidate \"(()))) (()())((\") = \"\
    Yes\" ]]\n    [[ $(candidate \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()(\
    \ ()))()\") = \"Yes\" ]]\n    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n   \
    \ [[ $(candidate \")(() (()(\") = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"\
    No\" ]]\n    [[ $(candidate \"( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\"\
    ) = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n    local str1=$1\n    local str2=$2\n    local str3=\"\
    $str1$str2\"\n    local str4=\"$str2$str1\"\n    local count1=$(echo \"$str1\"\
    \ | grep -o '(' | wc -l)\n    local count2=$(echo \"$str2\" | grep -o '(' | wc\
    \ -l)\n    local count3=$(echo \"$str3\" | grep -o '(' | wc -l)\n    local count4=$(echo\
    \ \"$str4\" | grep -o '(' | wc -l)\n    local count5=$(echo \"$str1\" | grep -o\
    \ ')' | wc -l)\n    local count6=$(echo \"$str2\" | grep -o ')' | wc -l)\n   \
    \ local count7=$(echo \"$str3\" | grep -o ')' | wc -l)\n    local count8=$(echo\
    \ \"$str4\" | grep -o ')' | wc -l)\n    if [ $count1 -eq $count5 ] && [ $count2\
    \ -eq $count6 ] && [ $count3 -eq $count7 ] && [ $count4 -eq $count8 ]; then\n\
    \        echo \"Yes\"\n    else\n        echo \"No\"\n    fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995715
- exit_code: 1
  program: "#!/bin/bash\n# You are given a list of two strings, both strings consist\
    \ of open\n# parentheses '(' or close parentheses ')' only.\n# Your job is to\
    \ check if it is possible to concatenate the two strings in\n# some order, that\
    \ the resulting string will be good.\n# A string S is considered to be good if\
    \ and only if all parentheses in S\n# are balanced. For example: the string '(())()'\
    \ is good, while the string\n# '())' is not.\n# Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n# Examples:\n# match_parens(['()(',\
    \ ')']) == 'Yes'\n# match_parens([')', ')']) == 'No'\n#\n# $1 is a space-separated\
    \ list\nmatch_parens() {\n  local str1=\"$1\"\n  local str2=\"$2\"\n  local str3=\"\
    $str1$str2\"\n  local count=0\n  local i=0\n  local len=${#str3}\n  while [ $i\
    \ -lt $len ]; do\n    if [ \"${str3:$i:1}\" == \"(\" ]; then\n      count=$((count+1))\n\
    \    else\n      count=$((count-1))\n    fi\n    if [ $count -lt 0 ]; then\n \
    \     echo \"No\"\n      return\n    fi\n    i=$((i+1))\n  done\n  if [ $count\
    \ -eq 0 ]; then\n    echo \"Yes\"\n  else\n    echo \"No\"\n  fi\n}\n\ncandidate()\
    \ {\n    match_parens \"$@\"\n}\n\nset -e\nrun_test() {\n    [[ $(candidate \"\
    ()( )\") = \"Yes\" ]]\n    [[ $(candidate \") )\") = \"No\" ]]\n    [[ $(candidate\
    \ \"(()(()) ())())\") = \"No\" ]]\n    [[ $(candidate \")()) (()()(\") = \"Yes\"\
    \ ]]\n    [[ $(candidate \"(()))) (()())((\") = \"Yes\" ]]\n    [[ $(candidate\
    \ \"() ())\") = \"No\" ]]\n    [[ $(candidate \"(()( ()))()\") = \"Yes\" ]]\n\
    \    [[ $(candidate \"(((( ((())\") = \"No\" ]]\n    [[ $(candidate \")(() (()(\"\
    ) = \"No\" ]]\n    [[ $(candidate \")( )(\") = \"No\" ]]\n    [[ $(candidate \"\
    ( )\") = \"Yes\" ]]\n    [[ $(candidate \") (\") = \"Yes\" ]]\n}\n\nrun_test"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659995714
