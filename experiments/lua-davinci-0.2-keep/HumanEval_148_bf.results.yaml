name: HumanEval_148_bf
language: lua
results:
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = 0\n\
    \  local p2 = 0\n  for i = 1, #planets do\n    if planets[i] == planet1 then\n\
    \      p1 = i\n    end\n    if planets[i] == planet2 then\n      p2 = i\n    end\n\
    \  end\n  if p1 == 0 or p2 == 0 then\n    return {}\n  end\n  local result = {}\n\
    \  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n      table.insert(result,\
    \ planets[i])\n    end\n  else\n    for i = p2 + 1, p1 - 1 do\n      table.insert(result,\
    \ planets[i])\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local p1,\
    \ p2 = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i\
    \ end\n    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then\
    \ return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n  \
    \  lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
    \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local min, max = math.min(p1, p2), math.max(p1,\
    \ p2)\n  local res = {}\n  for i = min + 1, max - 1 do\n    table.insert(res,\
    \ planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0pei2lxu.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp0pei2lxu.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local result = {}\n  for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(result, planets[i])\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpkjfyorl2.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpkjfyorl2.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return unpack(t)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphq4gihk8.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmphq4gihk8.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return unpack(t)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpth_ltiys.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpth_ltiys.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  if p1 < p2 then\n    for i =\
    \ p1 + 1, p2 - 1 do\n      table.insert(res, planets[i])\n    end\n  else\n  \
    \  for i = p2 + 1, p1 - 1 do\n      table.insert(res, planets[i])\n    end\n \
    \ end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjdaedni2.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpjdaedni2.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1, p2 = planets[planet1], planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and p1 < v and v < p2) or (p1 > p2 and p1 > v and v > p2)\
    \ then\n      table.insert(res, k)\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6bxlq48v.lua:39:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmp6bxlq48v.lua:39: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local p1,\
    \ p2 = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1\
    \ or not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) +\
    \ 1, math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpezlcvptq.lua:18:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpezlcvptq.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return table.unpack(t)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe0yu3in3.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpe0yu3in3.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) - 1\
    \ do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1 = 0\n  local p2 = 0\n  for i, planet in ipairs(planets)\
    \ do\n    if planet == planet1 then\n      p1 = i\n    end\n    if planet == planet2\
    \ then\n      p2 = i\n    end\n  end\n  if p1 == 0 or p2 == 0 then\n    return\
    \ {}\n  end\n  local result = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 -\
    \ 1 do\n      table.insert(result, planets[i])\n    end\n  else\n    for i = p2\
    \ + 1, p1 - 1 do\n      table.insert(result, planets[i])\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local index1,\
    \ index2 = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n\
    \            index1 = i\n        end\n        if v == planet2 then\n         \
    \   index2 = i\n        end\n    end\n    if index1 == 0 or index2 == 0 then\n\
    \        return {}\n    end\n    if index1 > index2 then\n        index1, index2\
    \ = index2, index1\n    end\n    local res = {}\n    for i = index1 + 1, index2\
    \ - 1 do\n        table.insert(res, planets[i])\n    end\n    return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1 =\
    \ nil\n    local p2 = nil\n    for i, v in ipairs(planets) do\n        if v ==\
    \ planet1 then\n            p1 = i\n        end\n        if v == planet2 then\n\
    \            p2 = i\n        end\n    end\n    if p1 == nil or p2 == nil then\n\
    \        return {}\n    end\n    if p1 > p2 then\n        p1, p2 = p2, p1\n  \
    \  end\n    local res = {}\n    for i = p1 + 1, p2 - 1 do\n        table.insert(res,\
    \ planets[i])\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpg3_yw9c3.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpg3_yw9c3.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local res = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2)\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n    return unpack(res)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpntf13a7l.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpntf13a7l.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = table.indexof(planets,\
    \ planet1)\n  local p2 = table.indexof(planets, planet2)\n  if p1 == nil or p2\
    \ == nil then\n    return {}\n  end\n  if p1 > p2 then\n    p1, p2 = p2, p1\n\
    \  end\n  return table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5te56nl1.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp5te56nl1.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    if p1 < p2 then\n      for i = p1 + 1, p2 - 1 do\n\
    \        table.insert(t, planets[i])\n      end\n    else\n      for i = p2 +\
    \ 1, p1 - 1 do\n        table.insert(t, planets[i])\n      end\n    end\n    return\
    \ table.unpack(t)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp02xohln7.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp02xohln7.lua:35:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  for i = p1 + 1, p2 - 1 do\n    table.insert(res,\
    \ planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpkr9ou6v_.lua:33:\
    \ expected: {\"Venus\"}\\nactual: {}\\nstack traceback:\\n\\t/tmp/tmpkr9ou6v_.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpai273cva.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpai273cva.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2)\
    \ then\n      table.insert(res, k)\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpxdrc7bjk.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpxdrc7bjk.lua:40: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local result = {}\n  for k, v in\
    \ pairs(planets) do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v\
    \ < p1 and v > p2) then\n      table.insert(result, k)\n    end\n  end\n  table.sort(result,\
    \ function(a, b) return planets[a] < planets[b] end)\n  return result\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n  \
    \  lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n  \
    \  lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp44irxhqp.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp44irxhqp.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyzc0g6e5.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpyzc0g6e5.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local i1, i2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           i1 = i\n        end\n        if v == planet2 then\n            i2\
    \ = i\n        end\n    end\n    if i1 == 0 or i2 == 0 then\n        return {}\n\
    \    end\n    local result = {}\n    if i1 < i2 then\n        for i = i1 + 1,\
    \ i2 - 1 do\n            table.insert(result, planets[i])\n        end\n    else\n\
    \        for i = i2 + 1, i1 - 1 do\n            table.insert(result, planets[i])\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1_index\
    \ = 0\n  local planet2_index = 0\n  for i, planet in ipairs(planets) do\n    if\
    \ planet == planet1 then\n      planet1_index = i\n    end\n    if planet == planet2\
    \ then\n      planet2_index = i\n    end\n  end\n  if planet1_index == 0 or planet2_index\
    \ == 0 then\n    return {}\n  end\n  local result = {}\n  if planet1_index < planet2_index\
    \ then\n    for i = planet1_index + 1, planet2_index - 1 do\n      table.insert(result,\
    \ planets[i])\n    end\n  else\n    for i = planet2_index + 1, planet1_index -\
    \ 1 do\n      table.insert(result, planets[i])\n    end\n  end\n  return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local res = {}\n    for i = math.min(p1, p2), math.max(p1, p2) do\n\
    \      table.insert(res, planets[i])\n    end\n    return table.unpack(res)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmps56nwjne.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmps56nwjne.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = 0, 0\n  for i, v in ipairs(planets)\
    \ do\n    if v == planet1 then\n      p1 = i\n    end\n    if v == planet2 then\n\
    \      p2 = i\n    end\n  end\n  if p1 == 0 or p2 == 0 then\n    return {}\n \
    \ end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n  \
    \    table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1 -\
    \ 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1_index\
    \ = table.indexOf(planets, planet1)\n  local planet2_index = table.indexOf(planets,\
    \ planet2)\n  if planet1_index == -1 or planet2_index == -1 then return {} end\n\
    \  local start_index = math.min(planet1_index, planet2_index)\n  local end_index\
    \ = math.max(planet1_index, planet2_index)\n  local result = {}\n  for i = start_index\
    \ + 1, end_index - 1 do\n    table.insert(result, planets[i])\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8vl1i6wr.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp8vl1i6wr.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local t = {}\n  for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(t, planets[i])\n  end\n \
    \ return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphfmdv9ac.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmphfmdv9ac.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  if p1 < p2 then\n\
    \    for k, v in pairs(planets) do\n      if v > p1 and v < p2 then\n        table.insert(res,\
    \ k)\n      end\n    end\n  else\n    for k, v in pairs(planets) do\n      if\
    \ v > p2 and v < p1 then\n        table.insert(res, k)\n      end\n    end\n \
    \ end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_cygffy2.lua:48:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmp_cygffy2.lua:48: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpcycb_5m_.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpcycb_5m_.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = table.find(planets, planet1), table.find(planets,\
    \ planet2)\n  if not p1 or not p2 then return {} end\n  local t = {}\n  for i\
    \ = math.min(p1, p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(t, planets[i])\n\
    \  end\n  return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpcvnezv_7.lua:25:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpcvnezv_7.lua:37:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if p1\
    \ and p2 then\n    local t = {}\n    if p1 < p2 then\n      for i = p1+1, p2-1\
    \ do\n        table.insert(t, planets[i])\n      end\n    else\n      for i =\
    \ p2+1, p1-1 do\n        table.insert(t, planets[i])\n      end\n    end\n   \
    \ return unpack(t)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpup2yl_ra.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpup2yl_ra.lua:35:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1 = 0\n\
    \tlocal p2 = 0\n\tfor i, v in ipairs(planets) do\n\t\tif v == planet1 then\n\t\
    \t\tp1 = i\n\t\tend\n\t\tif v == planet2 then\n\t\t\tp2 = i\n\t\tend\n\tend\n\t\
    if p1 == 0 or p2 == 0 then\n\t\treturn {}\n\tend\n\tlocal t = {}\n\tif p1 < p2\
    \ then\n\t\tfor i = p1 + 1, p2 - 1 do\n\t\t\ttable.insert(t, planets[i])\n\t\t\
    end\n\telse\n\t\tfor i = p2 + 1, p1 - 1 do\n\t\t\ttable.insert(t, planets[i])\n\
    \t\tend\n\tend\n\treturn t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local start, finish = math.min(p1, p2),\
    \ math.max(p1, p2)\n  local result = {}\n  for i = start + 1, finish do\n    table.insert(result,\
    \ planets[i])\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplf_seepp.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmplf_seepp.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpz25eyewp.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpz25eyewp.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return unpack(t)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3rpnz3ht.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp3rpnz3ht.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 > p2 then\n    for i = p2, p1 do\n      table.insert(res,\
    \ planets[i])\n    end\n  else\n    for i = p1, p2 do\n      table.insert(res,\
    \ planets[i])\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp73on0jpl.lua:38:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\\nstack traceback:\\n\\t/tmp/tmp73on0jpl.lua:38: in function \\\
    'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\\
    n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    }\n\
    \    local p1, p2 = 0, 0\n    for i, v in ipairs(planets) do\n        if v ==\
    \ planet1 then\n            p1 = i\n        end\n        if v == planet2 then\n\
    \            p2 = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n  \
    \      return {}\n    end\n    local res = {}\n    if p1 < p2 then\n        for\
    \ i = p1 + 1, p2 - 1 do\n            table.insert(res, planets[i])\n        end\n\
    \    else\n        for i = p2 + 1, p1 - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8hf_hzz6.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp8hf_hzz6.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = table.indexof(planets,\
    \ planet1)\n  local p2 = table.indexof(planets, planet2)\n  if p1 == nil or p2\
    \ == nil then return {} end\n  if p1 > p2 then\n    p1, p2 = p2, p1\n  end\n \
    \ return table.slice(planets, p1+1, p2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgylwf5lt.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpgylwf5lt.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = nil\n\
    \  local p2 = nil\n  for i, v in ipairs(planets) do\n    if v == planet1 then\n\
    \      p1 = i\n    end\n    if v == planet2 then\n      p2 = i\n    end\n  end\n\
    \  if p1 == nil or p2 == nil then\n    return {}\n  end\n  local res = {}\n  if\
    \ p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n      table.insert(res, planets[i])\n\
    \    end\n  else\n    for i = p2 + 1, p1 - 1 do\n      table.insert(res, planets[i])\n\
    \    end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    if p1 > p2 then\n      p1, p2 = p2, p1\n    end\n    return table.slice(planets,\
    \ p1 + 1, p2)\n  end\n  return {}\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsloekjoq.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpsloekjoq.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n  }\n  local p1,\
    \ p2\n  for i, p in ipairs(planets) do\n    if p == planet1 then p1 = i end\n\
    \    if p == planet2 then p2 = i end\n  end\n  if not p1 or not p2 then return\
    \ {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = table.indexof(planets,\
    \ planet1)\n  local p2 = table.indexof(planets, planet2)\n  if p1 == nil or p2\
    \ == nil then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpi620c3uj.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpi620c3uj.lua:26:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0ox1akqa.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp0ox1akqa.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local p = {}\n  for i = math.min(p1, p2), math.max(p1, p2) do\n  \
    \  table.insert(p, planets[i])\n  end\n  return p\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf3bgu7t4.lua:32:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\\nstack traceback:\\n\\t/tmp/tmpf3bgu7t4.lua:32: in function \\\
    'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\\
    n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local result = {}\n    if p1 < p2 then\n        for i = p1 + 1,\
    \ p2 - 1 do\n            table.insert(result, planets[i])\n        end\n    else\n\
    \        for i = p2 + 1, p1 - 1 do\n            table.insert(result, planets[i])\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local res = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2\
    \ - 1 do\n            table.insert(res, planets[i])\n        end\n    else\n \
    \       for i = p2 + 1, p1 - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    local p1,\
    \ p2 = table.find(planets, planet1), table.find(planets, planet2)\n    if p1 and\
    \ p2 then\n        local t = {}\n        for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n            table.insert(t, planets[i])\n        end\n        return\
    \ t\n    end\n    return {}\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn648rwww.lua:25:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpn648rwww.lua:39:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local result = {}\n  for i = math.min(p1, p2) +\
    \ 1, math.max(p1, p2) - 1 do\n    table.insert(result, planets[i])\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpttnj2mu0.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpttnj2mu0.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if p1 and\
    \ p2 then\n        local t = {}\n        if p1 < p2 then\n            for i =\
    \ p1 + 1, p2 - 1 do\n                table.insert(t, planets[i])\n           \
    \ end\n        else\n            for i = p2 + 1, p1 - 1 do\n                table.insert(t,\
    \ planets[i])\n            end\n        end\n        return table.unpack(t)\n\
    \    end\n    return ()\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: "b\"lua: /tmp/tmpaifib6ia.lua:30: unexpected symbol near ')'\\n\""
  exit_code: 1
  status: SyntaxError
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if p1\
    \ == nil or p2 == nil then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n\
    \  return table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpl1_akjzy.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpl1_akjzy.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = table.indexOf(planets, planet1), table.indexOf(planets,\
    \ planet2)\n  if p1 == -1 or p2 == -1 then return {} end\n  if p1 > p2 then p1,\
    \ p2 = p2, p1 end\n  local res = {}\n  for i = p1 + 1, p2 - 1 do\n    table.insert(res,\
    \ planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpa4vbbdb5.lua:25:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpa4vbbdb5.lua:38:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = table.find(planets, planet1), table.find(planets,\
    \ planet2)\n  if not p1 or not p2 then return {} end\n  local res = {}\n  for\
    \ i = math.min(p1, p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n\
    \  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpv16tsr69.lua:25:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpv16tsr69.lua:37:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2)\
    \ then\n      table.insert(res, k)\n    end\n  end\n  table.sort(res, function(a,\
    \ b) return planets[a] < planets[b] end)\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return unpack(t)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpynpo6tgw.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpynpo6tgw.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local planet1_idx,\
    \ planet2_idx\n    for i, planet in ipairs(planets) do\n        if planet == planet1\
    \ then\n            planet1_idx = i\n        end\n        if planet == planet2\
    \ then\n            planet2_idx = i\n        end\n    end\n    if planet1_idx\
    \ == nil or planet2_idx == nil then\n        return {}\n    end\n    local start_idx\
    \ = math.min(planet1_idx, planet2_idx)\n    local end_idx = math.max(planet1_idx,\
    \ planet2_idx)\n    local result = {}\n    for i = start_idx + 1, end_idx - 1\
    \ do\n        table.insert(result, planets[i])\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return table.unpack(t)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpya4h7fvf.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpya4h7fvf.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i = 1, #planets do\n        if planets[i] == planet1 then\n\
    \            p1 = i\n        end\n        if planets[i] == planet2 then\n    \
    \        p2 = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n      \
    \  return {}\n    end\n    local res = {}\n    if p1 < p2 then\n        for i\
    \ = p1 + 1, p2 - 1 do\n            table.insert(res, planets[i])\n        end\n\
    \    else\n        for i = p2 + 1, p1 - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = table.find(planets, planet1), table.find(planets,\
    \ planet2)\n  if p1 and p2 then\n    local res = {}\n    for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n      table.insert(res, planets[i])\n    end\n\
    \    return unpack(res)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvo7cgnrz.lua:25:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpvo7cgnrz.lua:38:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = p1, p2 do\n      table.insert(t, planets[i])\n\
    \    end\n    return table.unpack(t)\n  end\n  return ()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: "b\"lua: /tmp/tmpkbf0whh5.lua:24: unexpected symbol near ')'\\n\""
  exit_code: 1
  status: SyntaxError
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7x8nwav0.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp7x8nwav0.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    local p1\
    \ = nil\n    local p2 = nil\n    for i, v in ipairs(planets) do\n        if v\
    \ == planet1 then\n            p1 = i\n        end\n        if v == planet2 then\n\
    \            p2 = i\n        end\n    end\n    if p1 == nil or p2 == nil then\n\
    \        return {}\n    end\n    if p1 > p2 then\n        local tmp = p1\n   \
    \     p1 = p2\n        p2 = tmp\n    end\n    local res = {}\n    for i = p1 +\
    \ 1, p2 - 1 do\n        table.insert(res, planets[i])\n    end\n    return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    if p1 < p2 then\n    \
    \    for i = p1 + 1, p2 - 1 do\n            table.insert(res, planets[i])\n  \
    \      end\n    else\n        for i = p2 + 1, p1 - 1 do\n            table.insert(res,\
    \ planets[i])\n        end\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3uau4zna.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp3uau4zna.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  if not planets[planet1] or not planets[planet2]\
    \ then return {} end\n  local start, finish = planets[planet1], planets[planet2]\n\
    \  if start > finish then start, finish = finish, start end\n  local res = {}\n\
    \  for k, v in pairs(planets) do\n    if v > start and v < finish then\n     \
    \ table.insert(res, k)\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplv8rb0u_.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmplv8rb0u_.lua:40: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local start,\
    \ finish = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then start\
    \ = i end\n    if v == planet2 then finish = i end\n  end\n  if start == 0 or\
    \ finish == 0 then return {} end\n  if start > finish then start, finish = finish,\
    \ start end\n  local res = {}\n  for i = start + 1, finish - 1 do\n    table.insert(res,\
    \ planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if p1 and\
    \ p2 then\n        local t = {}\n        for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n            table.insert(t, planets[i])\n        end\n        return\
    \ table.unpack(t)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphvqzazvy.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmphvqzazvy.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1, p2\
    \ = 0, 0\n\tfor i,v in ipairs(planets) do\n\t\tif v == planet1 then p1 = i end\n\
    \t\tif v == planet2 then p2 = i end\n\tend\n\tif p1 == 0 or p2 == 0 then return\
    \ {} end\n\tif p1 > p2 then p1, p2 = p2, p1 end\n\tlocal res = {}\n\tfor i = p1+1,\
    \ p2-1 do\n\t\ttable.insert(res, planets[i])\n\tend\n\treturn res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local t = {}\n  for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(t, planets[i])\n  end\n \
    \ return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgyw3psng.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpgyw3psng.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local result = {}\n  if p1 < p2 then\n\
    \    for k, v in pairs(planets) do\n      if v > p1 and v < p2 then\n        table.insert(result,\
    \ k)\n      end\n    end\n  else\n    for k, v in pairs(planets) do\n      if\
    \ v > p2 and v < p1 then\n        table.insert(result, k)\n      end\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpum_gxsxu.lua:48:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpum_gxsxu.lua:48: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2)\
    \ then\n      table.insert(res, k)\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmprla2f36w.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmprla2f36w.lua:40: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1 =\
    \ 0\n    local p2 = 0\n    for i, v in ipairs(planets) do\n        if v == planet1\
    \ then\n            p1 = i\n        end\n        if v == planet2 then\n      \
    \      p2 = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return\
    \ {}\n    end\n    local res = {}\n    if p1 < p2 then\n        for i = p1 + 1,\
    \ p2 - 1 do\n            table.insert(res, planets[i])\n        end\n    else\n\
    \        for i = p2 + 1, p1 - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    local function\
    \ get_index(planet)\n        for i, v in ipairs(planets) do\n            if v\
    \ == planet then\n                return i\n            end\n        end\n   \
    \     return nil\n    end\n    local function get_planets(p1, p2)\n        local\
    \ p1_index = get_index(p1)\n        local p2_index = get_index(p2)\n        if\
    \ p1_index == nil or p2_index == nil then\n            return {}\n        end\n\
    \        local start_index = math.min(p1_index, p2_index)\n        local end_index\
    \ = math.max(p1_index, p2_index)\n        local result = {}\n        for i = start_index\
    \ + 1, end_index - 1 do\n            table.insert(result, planets[i])\n      \
    \  end\n        return result\n    end\n    return get_planets(planet1, planet2)\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2)\
    \ then\n      table.insert(res, k)\n    end\n  end\n  table.sort(res, function(a,\
    \ b) return planets[a] < planets[b] end)\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.index_of(planets, planet1), table.index_of(planets, planet2)\n  if p1\
    \ == nil or p2 == nil then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n\
    \  return table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjlmvbgtl.lua:16:\
    \ attempt to call field 'index_of' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpjlmvbgtl.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = p1 + 1, p2 - 1 do\n      table.insert(t,\
    \ planets[i])\n    end\n    return table.unpack(t)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpc8bvqcju.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpc8bvqcju.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = 0\n\
    \  local p2 = 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then\n\
    \      p1 = i\n    end\n    if v == planet2 then\n      p2 = i\n    end\n  end\n\
    \  if p1 == 0 or p2 == 0 then\n    return {}\n  end\n  local res = {}\n  if p1\
    \ < p2 then\n    for i = p1 + 1, p2 do\n      table.insert(res, planets[i])\n\
    \    end\n  else\n    for i = p1 - 1, p2, -1 do\n      table.insert(res, planets[i])\n\
    \    end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpq2jq86ba.lua:45:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\\nstack traceback:\\n\\t/tmp/tmpq2jq86ba.lua:45: in function \\'test_humaneval\\\
    '\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpzikz1rcy.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpzikz1rcy.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local res = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2\
    \ - 1 do\n            table.insert(res, planets[i])\n        end\n    else\n \
    \       for i = p2 + 1, p1 - 1 do\n            table.insert(res, planets[i])\n\
    \        end\n    end\n    return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr3p9em53.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpr3p9em53.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    local function\
    \ get_index(planet)\n        for i, p in ipairs(planets) do\n            if p\
    \ == planet then\n                return i\n            end\n        end\n   \
    \     return nil\n    end\n    local p1_index = get_index(planet1)\n    local\
    \ p2_index = get_index(planet2)\n    if p1_index == nil or p2_index == nil then\n\
    \        return {}\n    end\n    local start = math.min(p1_index, p2_index)\n\
    \    local stop = math.max(p1_index, p2_index)\n    local result = {}\n    for\
    \ i = start + 1, stop - 1 do\n        table.insert(result, planets[i])\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local res = {}\n  if p1 < p2 then\n\
    \    for i = p1 + 1, p2 do\n      table.insert(res, planets[i])\n    end\n  else\n\
    \    for i = p1 - 1, p2, -1 do\n      table.insert(res, planets[i])\n    end\n\
    \  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5a2ho8kf.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp5a2ho8kf.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpc3tm0hae.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpc3tm0hae.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == nil or p2 == nil then return {} end\n  local res = {}\n  for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpd0p2degs.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpd0p2degs.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.pack(table.unpack(planets,\
    \ p1 + 1, p2 - 1))\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpna1t3hb2.lua:23:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpna1t3hb2.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\n    }\n\
    \    local p1, p2 = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n\
    \    if p1 == -1 or p2 == -1 then return {} end\n    local result = {}\n    for\
    \ i = math.min(p1, p2) + 1, math.max(p1, p2) - 1 do\n        table.insert(result,\
    \ planets[i])\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8d_o2ejc.lua:18:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp8d_o2ejc.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  if p1 < p2 then\n    for i =\
    \ p1 + 1, p2 - 1 do\n      table.insert(res, planets[i])\n    end\n  else\n  \
    \  for i = p2 + 1, p1 - 1 do\n      table.insert(res, planets[i])\n    end\n \
    \ end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpog15_5_g.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpog15_5_g.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 > p2 then\n    for i = p2 + 1, p1 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p1 + 1, p2\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = table.indexof(planets,\
    \ planet1)\n  local p2 = table.indexof(planets, planet2)\n  if p1 == nil or p2\
    \ == nil then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdupff9nw.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpdupff9nw.lua:26:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {'Mercury', 'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn', 'Uranus', 'Neptune'}\n  local p1, p2 = table.find(planets,\
    \ planet1), table.find(planets, planet2)\n  if not p1 or not p2 then return {}\
    \ end\n  local res = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) - 1\
    \ do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmps9utfg6_.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmps9utfg6_.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = table.indexof(planets,\
    \ planet1)\n  local p2 = table.indexof(planets, planet2)\n  if p1 == nil or p2\
    \ == nil then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp50l5qlfb.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp50l5qlfb.lua:26:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppvnlfiax.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmppvnlfiax.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 == nil\
    \ or p2 == nil then return {} end\n  local res = {}\n  for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6zlf448f.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp6zlf448f.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return unpack(t)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgzo1wdik.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpgzo1wdik.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpw_txxneb.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpw_txxneb.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local index1,\
    \ index2 = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then\n\
    \      index1 = i\n    end\n    if v == planet2 then\n      index2 = i\n    end\n\
    \  end\n  if index1 == 0 or index2 == 0 then\n    return {}\n  end\n  local result\
    \ = {}\n  if index1 < index2 then\n    for i = index1 + 1, index2 - 1 do\n   \
    \   table.insert(result, planets[i])\n    end\n  else\n    for i = index2 + 1,\
    \ index1 - 1 do\n      table.insert(result, planets[i])\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local min, max = math.min(p1, p2), math.max(p1,\
    \ p2)\n  local res = {}\n  for i = min + 1, max - 1 do\n    table.insert(res,\
    \ planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpkm3snvg2.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpkm3snvg2.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) - 1\
    \ do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1, i2\
    \ = 0, 0\n  for i = 1, #planets do\n    if planets[i] == planet1 then i1 = i end\n\
    \    if planets[i] == planet2 then i2 = i end\n  end\n  if i1 == 0 or i2 == 0\
    \ then return {} end\n  if i1 > i2 then i1, i2 = i2, i1 end\n  local res = {}\n\
    \  for i = i1 + 1, i2 - 1 do\n    res[#res + 1] = planets[i]\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = 0, 0\n  for i, v in ipairs(planets)\
    \ do\n    if v == planet1 then\n      p1 = i\n    end\n    if v == planet2 then\n\
    \      p2 = i\n    end\n  end\n  if p1 == 0 or p2 == 0 then\n    return {}\n \
    \ end\n  local res = {}\n  for i = math.min(p1, p2), math.max(p1, p2) do\n   \
    \ if i ~= p1 and i ~= p2 then\n      table.insert(res, planets[i])\n    end\n\
    \  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local start, finish = math.min(p1, p2),\
    \ math.max(p1, p2)\n  local result = {}\n  for i = start + 1, finish do\n    table.insert(result,\
    \ planets[i])\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_ofsvu5q.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp_ofsvu5q.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpy33h41og.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpy33h41og.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if p1 == nil or p2 == nil then\n    return {}\n  end\n  local result = {}\n\
    \  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n      for k, v in pairs(planets)\
    \ do\n        if v == i then\n          table.insert(result, k)\n        end\n\
    \      end\n    end\n  else\n    for i = p2 + 1, p1 - 1 do\n      for k, v in\
    \ pairs(planets) do\n        if v == i then\n          table.insert(result, k)\n\
    \        end\n      end\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1, i2\
    \ = 0, 0\n  for i, planet in ipairs(planets) do\n    if planet == planet1 then\
    \ i1 = i end\n    if planet == planet2 then i2 = i end\n  end\n  if i1 == 0 or\
    \ i2 == 0 then return {} end\n  local res = {}\n  for i = math.min(i1, i2) + 1,\
    \ math.max(i1, i2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if p1\
    \ and p2 then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n      table.insert(t, planets[i])\n    end\n    return table.unpack(t)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe67autha.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpe67autha.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then\n    p1, p2 = p2, p1\n  end\n  local res = {}\n  for\
    \ i = p1 + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i = 1, #planets do\n    if planets[i] == planet1 then p1 = i end\n\
    \    if planets[i] == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0\
    \ then return {} end\n  local res = {}\n  for i = p1 + 1, p2 - 1 do\n    res[#res\
    \ + 1] = planets[i]\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphwxh1i8t.lua:33:\
    \ expected: {\"Venus\"}\\nactual: {}\\nstack traceback:\\n\\t/tmp/tmphwxh1i8t.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpo2m_lmv_.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpo2m_lmv_.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\n\
    \  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n    if\
    \ v == planet2 then p2 = i end\n  end\n  if not p1 or not p2 then return {} end\n\
    \  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1 + 1, p2\
    \ - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0yew49do.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp0yew49do.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n    if p1\
    \ == -1 or p2 == -1 then return {} end\n    local res = {}\n    for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n  \
    \  end\n    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3xia0l41.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp3xia0l41.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local res = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2)\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n    return unpack(res)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpna6wujka.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpna6wujka.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpti1z6f3z.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpti1z6f3z.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\n\
    \  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n    if\
    \ v == planet2 then p2 = i end\n  end\n  if not p1 or not p2 then return {} end\n\
    \  local t = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n      table.insert(t,\
    \ planets[i])\n    end\n  else\n    for i = p2 + 1, p1 - 1 do\n      table.insert(t,\
    \ planets[i])\n    end\n  end\n  return t\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  return table.slice(planets,\
    \ p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp21ui82bm.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp21ui82bm.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local t = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2)\
    \ then\n      table.insert(t, k)\n    end\n  end\n  table.sort(t, function(a,\
    \ b)\n    return planets[a] < planets[b]\n  end)\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\n\
    \  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n    if\
    \ v == planet2 then p2 = i end\n  end\n  if not p1 or not p2 then return {} end\n\
    \  local res = {}\n  for i = p1 + 1, p2 - 1 do\n    table.insert(res, planets[i])\n\
    \  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7jb700ul.lua:33:\
    \ expected: {\"Venus\"}\\nactual: {}\\nstack traceback:\\n\\t/tmp/tmp7jb700ul.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  local start, finish = math.min(p1, p2),\
    \ math.max(p1, p2)\n  local res = {}\n  for i = start + 1, finish do\n    table.insert(res,\
    \ planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptr3deyuc.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmptr3deyuc.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local res = {}\n    for i = p1, p2 do\n      table.insert(res, planets[i])\n\
    \    end\n    return res\n  end\n  return {}\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpssb5a0yo.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpssb5a0yo.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == nil or p2 == nil then return {} end\n  local t = {}\n  local min, max = math.min(p1,\
    \ p2), math.max(p1, p2)\n  for i = min + 1, max - 1 do\n    table.insert(t, planets[i])\n\
    \  end\n  return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp4taz3ttq.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp4taz3ttq.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local res = {}\n  for i = math.min(p1, p2) + 1,\
    \ math.max(p1, p2) - 1 do\n    table.insert(res, planets[i])\n  end\n  return\
    \ res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdgwwante.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpdgwwante.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local t = {}\n  for i = p1, p2 do\n    table.insert(t, planets[i])\n\
    \  end\n  return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqen3_87h.lua:32:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"}\\nstack traceback:\\n\\t/tmp/tmpqen3_87h.lua:32: in function \\\
    'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 failure\\\
    n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if p1\
    \ == nil or p2 == nil then return {} end\n  local t = {}\n  for i = math.min(p1,\
    \ p2) + 1, math.max(p1, p2) - 1 do\n    table.insert(t, planets[i])\n  end\n \
    \ return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqw9pyhi3.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpqw9pyhi3.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local result = {}\n  for k, v in\
    \ pairs(planets) do\n    if (p1 < p2 and p1 < v and v < p2) or (p1 > p2 and p1\
    \ > v and v > p2) then\n      table.insert(result, k)\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpve2k696a.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpve2k696a.lua:40: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local first,\
    \ last = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then first\
    \ = i end\n    if v == planet2 then last = i end\n  end\n  if first == 0 or last\
    \ == 0 then return {} end\n  if first > last then first, last = last, first end\n\
    \  local res = {}\n  for i = first + 1, last - 1 do\n    table.insert(res, planets[i])\n\
    \  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmprkggb44o.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmprkggb44o.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1,\
    \ p2) - 1 do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn8jijxu5.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpn8jijxu5.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if p1 == nil or p2 == nil then\n    return {}\n  end\n  local result = {}\n\
    \  for k, v in pairs(planets) do\n    if p1 < p2 then\n      if v > p1 and v <\
    \ p2 then\n        table.insert(result, k)\n      end\n    else\n      if v <\
    \ p1 and v > p2 then\n        table.insert(result, k)\n      end\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpi7_bve4h.lua:48:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpi7_bve4h.lua:48: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) - 1\
    \ do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1, i2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then i1 = i end\n\
    \    if v == planet2 then i2 = i end\n  end\n  if i1 == 0 or i2 == 0 then return\
    \ {} end\n  if i1 > i2 then i1, i2 = i2, i1 end\n  local res = {}\n  for i = i1\
    \ + 1, i2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    \"Mercury\",\n    \"Venus\",\n\
    \    \"Earth\",\n    \"Mars\",\n    \"Jupiter\",\n    \"Saturn\",\n    \"Uranus\"\
    ,\n    \"Neptune\"\n  }\n  local p1, p2 = 0, 0\n  for i, v in ipairs(planets)\
    \ do\n    if v == planet1 then\n      p1 = i\n    end\n    if v == planet2 then\n\
    \      p2 = i\n    end\n  end\n  if p1 == 0 or p2 == 0 then\n    return {}\n \
    \ end\n  local t = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n    \
    \  table.insert(t, planets[i])\n    end\n  else\n    for i = p2 + 1, p1 - 1 do\n\
    \      table.insert(t, planets[i])\n    end\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local result = {}\n  for i = math.min(p1, p2) +\
    \ 1, math.max(p1, p2) - 1 do\n    table.insert(result, planets[i])\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6ex6sm_5.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp6ex6sm_5.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local pos1,\
    \ pos2 = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n\
    \            pos1 = i\n        end\n        if v == planet2 then\n           \
    \ pos2 = i\n        end\n    end\n    if pos1 == 0 or pos2 == 0 then\n       \
    \ return {}\n    end\n    local res = {}\n    if pos1 < pos2 then\n        for\
    \ i = pos1 + 1, pos2 - 1 do\n            table.insert(res, planets[i])\n     \
    \   end\n    else\n        for i = pos2 + 1, pos1 - 1 do\n            table.insert(res,\
    \ planets[i])\n        end\n    end\n    return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = p1 + 1, p2 - 1 do\n      table.insert(t,\
    \ planets[i])\n    end\n    return table.unpack(t)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpad79_8el.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpad79_8el.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexOf(planets, planet1), table.indexOf(planets, planet2)\n  if p1\
    \ == -1 or p2 == -1 then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n\
    \  return table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf77wm0kg.lua:16:\
    \ attempt to call field 'indexOf' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpf77wm0kg.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if p1 == nil or p2 == nil then\n    return {}\n  end\n  local res = {}\n  for\
    \ k, v in pairs(planets) do\n    if v > p1 and v < p2 then\n      table.insert(res,\
    \ k)\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp870ebc27.lua:42:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmp870ebc27.lua:42: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1, i2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then i1 = i end\n\
    \    if v == planet2 then i2 = i end\n  end\n  if i1 == 0 or i2 == 0 then return\
    \ {} end\n  if i1 > i2 then i1, i2 = i2, i1 end\n  return table.move(planets,\
    \ i1 + 1, i2 - 1, 1, {})\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpayxt4lh_.lua:23:\
    \ attempt to call field 'move' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpayxt4lh_.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local result = {}\n  for i = math.min(p1, p2) +\
    \ 1, math.max(p1, p2) - 1 do\n    table.insert(result, planets[i])\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpm4_whvvs.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpm4_whvvs.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if p1\
    \ == nil or p2 == nil then return {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n\
    \  return table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe2czk_an.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpe2czk_an.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then\n    p1, p2 = p2, p1\n  end\n  local res = {}\n  for\
    \ i = p1 + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local planet1_index,\
    \ planet2_index = 0, 0\n  for i, planet in ipairs(planets) do\n    if planet ==\
    \ planet1 then planet1_index = i end\n    if planet == planet2 then planet2_index\
    \ = i end\n  end\n  if planet1_index == 0 or planet2_index == 0 then return {}\
    \ end\n  local result = {}\n  for i = planet1_index + 1, planet2_index - 1 do\n\
    \    table.insert(result, planets[i])\n  end\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0ahssq78.lua:33:\
    \ expected: {\"Venus\"}\\nactual: {}\\nstack traceback:\\n\\t/tmp/tmp0ahssq78.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local i1, i2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then i1 = i end\n\
    \    if v == planet2 then i2 = i end\n  end\n  if i1 == 0 or i2 == 0 then return\
    \ {} end\n  local res = {}\n  for i = math.min(i1, i2) + 1, math.max(i1, i2) -\
    \ 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if p1 < p2 then\n      if v > p1 and v < p2 then table.insert(res, k)\
    \ end\n    else\n      if v < p1 and v > p2 then table.insert(res, k) end\n  \
    \  end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsh6of0rr.lua:42:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpsh6of0rr.lua:42: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    for i = p1 + 1, p2 - 1 do\n        table.insert(t,\
    \ planets[i])\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpawql5_v_.lua:39:\
    \ expected: {\"Venus\"}\\nactual: {}\\nstack traceback:\\n\\t/tmp/tmpawql5_v_.lua:39:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = p1, p2 do\n      table.insert(t, planets[i])\n\
    \    end\n    return table.unpack(t)\n  end\n  return ()\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: "b\"lua: /tmp/tmp066p2wt4.lua:24: unexpected symbol near ')'\\n\""
  exit_code: 1
  status: SyntaxError
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local t = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n \
    \     table.insert(t, planets[i])\n    end\n  else\n    for i = p2 + 1, p1 - 1\
    \ do\n      table.insert(t, planets[i])\n    end\n  end\n  return t\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local t = {}\n    for i = math.min(p1, p2) + 1, math.max(p1, p2) -\
    \ 1 do\n      table.insert(t, planets[i])\n    end\n    return table.unpack(t)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpzb5t4b22.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpzb5t4b22.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\n\t\t\"Mercury\",\n\t\t\"Venus\",\n\
    \t\t\"Earth\",\n\t\t\"Mars\",\n\t\t\"Jupiter\",\n\t\t\"Saturn\",\n\t\t\"Uranus\"\
    ,\n\t\t\"Neptune\"\n\t}\n\tlocal p1, p2 = 0, 0\n\tfor i, v in ipairs(planets)\
    \ do\n\t\tif v == planet1 then\n\t\t\tp1 = i\n\t\tend\n\t\tif v == planet2 then\n\
    \t\t\tp2 = i\n\t\tend\n\tend\n\tif p1 == 0 or p2 == 0 then\n\t\treturn {}\n\t\
    end\n\tlocal t = {}\n\tif p1 < p2 then\n\t\tfor i = p1 + 1, p2 - 1 do\n\t\t\t\
    table.insert(t, planets[i])\n\t\tend\n\telse\n\t\tfor i = p2 + 1, p1 - 1 do\n\t\
    \t\ttable.insert(t, planets[i])\n\t\tend\n\tend\n\treturn t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1, Venus = 2, Earth\
    \ = 3, Mars = 4, Jupiter = 5, Saturn = 6, Uranus = 7, Neptune = 8\n  }\n  local\
    \ p1 = planets[planet1]\n  local p2 = planets[planet2]\n  if not p1 or not p2\
    \ then return {} end\n  local result = {}\n  for k, v in pairs(planets) do\n \
    \   if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2) then\n\
    \      table.insert(result, k)\n    end\n  end\n  table.sort(result, function(a,\
    \ b) return planets[a] < planets[b] end)\n  return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n  if p1\
    \ and p2 then\n    if p1 > p2 then\n      p1, p2 = p2, p1\n    end\n    return\
    \ table.sub(planets, p1 + 1, p2 - 1)\n  end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpis5srfte.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpis5srfte.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1 = 0\n\
    \  local p2 = 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then\n\
    \      p1 = i\n    end\n    if v == planet2 then\n      p2 = i\n    end\n  end\n\
    \  if p1 == 0 or p2 == 0 then\n    return {}\n  end\n  local res = {}\n  if p1\
    \ < p2 then\n    for i = p1 + 1, p2 do\n      table.insert(res, planets[i])\n\
    \    end\n  else\n    for i = p1 - 1, p2, -1 do\n      table.insert(res, planets[i])\n\
    \    end\n  end\n  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1gxb_nqu.lua:45:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Saturn\", \"Uranus\", \"Neptune\"\
    }\\nstack traceback:\\n\\t/tmp/tmp1gxb_nqu.lua:45: in function \\'test_humaneval\\\
    '\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 == nil\
    \ or p2 == nil then return {} end\n  local t = {}\n  for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n    table.insert(t, planets[i])\n  end\n  return\
    \ t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpua7rbank.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpua7rbank.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqz3px6gk.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpqz3px6gk.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if v > p1 and v < p2 then\n      table.insert(res, k)\n    end\n  end\n\
    \  return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppq_kxjgl.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmppq_kxjgl.lua:40: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n\tlocal planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n\tlocal p1, p2\
    \ = table.indexof(planets, planet1), table.indexof(planets, planet2)\n\tif p1\
    \ == nil or p2 == nil then return {} end\n\tif p1 > p2 then p1, p2 = p2, p1 end\n\
    \treturn table.slice(planets, p1 + 1, p2)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptwu19b66.lua:16:\
    \ attempt to call field 'indexof' (a nil value)\\nstack traceback:\\n\\t/tmp/tmptwu19b66.lua:25:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = 0, 0\n    for i, v in ipairs(planets) do\n        if v == planet1 then\n \
    \           p1 = i\n        end\n        if v == planet2 then\n            p2\
    \ = i\n        end\n    end\n    if p1 == 0 or p2 == 0 then\n        return {}\n\
    \    end\n    local t = {}\n    if p1 < p2 then\n        for i = p1 + 1, p2 -\
    \ 1 do\n            table.insert(t, planets[i])\n        end\n    else\n     \
    \   for i = p2 + 1, p1 - 1 do\n            table.insert(t, planets[i])\n     \
    \   end\n    end\n    return t\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local res = {}\n  if p1 < p2 then\n    for i = p1 + 1, p2 - 1 do\n\
    \      table.insert(res, planets[i])\n    end\n  else\n    for i = p2 + 1, p1\
    \ - 1 do\n      table.insert(res, planets[i])\n    end\n  end\n  return res\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n\
    \    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  if p1 > p2 then p1, p2 = p2, p1 end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\n        \"Mercury\",\n        \"\
    Venus\",\n        \"Earth\",\n        \"Mars\",\n        \"Jupiter\",\n      \
    \  \"Saturn\",\n        \"Uranus\",\n        \"Neptune\"\n    }\n    local start,\
    \ finish = 0, 0\n    for i, planet in ipairs(planets) do\n        if planet ==\
    \ planet1 then\n            start = i\n        end\n        if planet == planet2\
    \ then\n            finish = i\n        end\n    end\n    if start == 0 or finish\
    \ == 0 then\n        return {}\n    end\n    if start > finish then\n        start,\
    \ finish = finish, start\n    end\n    local result = {}\n    for i = start +\
    \ 1, finish - 1 do\n        table.insert(result, planets[i])\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\n\
    \  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n    if\
    \ v == planet2 then p2 = i end\n  end\n  if not p1 or not p2 then return {} end\n\
    \  if p1 > p2 then\n    p1, p2 = p2, p1\n  end\n  local res = {}\n  for i = p1\
    \ + 1, p2 - 1 do\n    table.insert(res, planets[i])\n  end\n  return res\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = bf\n \
    \   lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n \
    \   lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if not p1 or\
    \ not p2 then return {} end\n  local result = {}\n  for i = math.min(p1, p2) +\
    \ 1, math.max(p1, p2) - 1 do\n    table.insert(result, planets[i])\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn', 'Uranus'})\n\
    \    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n    lu.assertEquals(candidate('Mercury',\
    \ 'Uranus'), {'Venus', 'Earth', 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune',\
    \ 'Venus'), {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp07at0e54.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp07at0e54.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1 = planets[planet1]\n  local p2 = planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if (p1 < p2 and v > p1 and v < p2) or (p1 > p2 and v < p1 and v > p2)\
    \ then\n      table.insert(res, k)\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsj9c_jre.lua:40:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpsj9c_jre.lua:40: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = 0, 0\n  for i, v in ipairs(planets) do\n    if v == planet1 then p1 = i end\n\
    \    if v == planet2 then p2 = i end\n  end\n  if p1 == 0 or p2 == 0 then return\
    \ {} end\n  local t = {}\n  for i = math.min(p1, p2) + 1, math.max(p1, p2) - 1\
    \ do\n    table.insert(t, planets[i])\n  end\n  return t\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n    local planets = {\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n    local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n    if not p1\
    \ or not p2 then return {} end\n    local res = {}\n    for i = math.min(p1, p2)\
    \ + 1, math.max(p1, p2) - 1 do\n        table.insert(res, planets[i])\n    end\n\
    \    return res\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = bf\n    lu.assertEquals(candidate('Jupiter', 'Neptune'), {'Saturn',\
    \ 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'), {'Venus'})\n\
    \    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth', 'Mars',\
    \ 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'), {'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmph_ek405z.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmph_ek405z.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\"Mercury\", \"Venus\", \"Earth\",\
    \ \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"}\n  local p1, p2\
    \ = table.find(planets, planet1), table.find(planets, planet2)\n  if p1 and p2\
    \ then\n    local res = {}\n    for i = p1, p2 do\n      table.insert(res, planets[i])\n\
    \    end\n    return res\n  end\n  return {}\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpp7e0hu9w.lua:16:\
    \ attempt to call field 'find' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpp7e0hu9w.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- There are eight planets in our solar system: the closerst to the Sun\
    \ \n-- is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n\
    -- Uranus, Neptune.\n-- Write a function that takes two planet names as strings\
    \ planet1 and planet2. \n-- The function should return a tuple containing all\
    \ planets whose orbits are \n-- located between the orbit of planet1 and the orbit\
    \ of planet2, sorted by \n-- the proximity to the sun. \n-- The function should\
    \ return an empty tuple if planet1 or planet2\n-- are not correct planet names.\
    \ \n-- Examples\n-- bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n\
    -- bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n-- bf(\"Mercury\", \"Uranus\")\
    \ ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\nlocal function\
    \ bf(planet1, planet2)\n  local planets = {\n    Mercury = 1,\n    Venus = 2,\n\
    \    Earth = 3,\n    Mars = 4,\n    Jupiter = 5,\n    Saturn = 6,\n    Uranus\
    \ = 7,\n    Neptune = 8\n  }\n  local p1, p2 = planets[planet1], planets[planet2]\n\
    \  if not p1 or not p2 then return {} end\n  local res = {}\n  for k, v in pairs(planets)\
    \ do\n    if p1 < p2 then\n      if v > p1 and v < p2 then\n        table.insert(res,\
    \ k)\n      end\n    else\n      if v < p1 and v > p2 then\n        table.insert(res,\
    \ k)\n      end\n    end\n  end\n  return res\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = bf\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Neptune'), {'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth', 'Mercury'),\
    \ {'Venus'})\n    lu.assertEquals(candidate('Mercury', 'Uranus'), {'Venus', 'Earth',\
    \ 'Mars', 'Jupiter', 'Saturn'})\n    lu.assertEquals(candidate('Neptune', 'Venus'),\
    \ {'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus'})\n    lu.assertEquals(candidate('Earth',\
    \ 'Earth'), {})\n    lu.assertEquals(candidate('Mars', 'Earth'), {})\n    lu.assertEquals(candidate('Jupiter',\
    \ 'Makemake'), {})\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpy5keowce.lua:45:\
    \ expected: {\"Saturn\", \"Uranus\"}\\nactual: {\"Uranus\", \"Saturn\"}\\nstack\
    \ traceback:\\n\\t/tmp/tmpy5keowce.lua:45: in function \\'test_humaneval\\'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
