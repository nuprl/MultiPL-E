name: HumanEval_156_int_to_mini_roman
language: lua
results:
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpwefee3t1.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpwefee3t1.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpwefee3t1.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    assert(number >= 1 and number <= 1000, \"Number must be between 1 and 1000\"\
    )\n    local result = \"\"\n    for _, numeral in ipairs(mini_roman_numerals)\
    \ do\n        while number >= numeral[1] do\n            result = result .. numeral[2]\n\
    \            number = number - numeral[1]\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpp6_r6byf.lua:11:\
    \ bad argument #1 to 'ipairs' (table expected, got nil)\\nstack traceback:\\n\\\
    t/tmp/tmpp6_r6byf.lua:11: in function 'candidate'\\n\\t/tmp/tmpp6_r6byf.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {'m', 1000},\n    {'cm', 900},\n    {'d', 500},\n\
    \    {'cd', 400},\n    {'c', 100},\n    {'xc', 90},\n    {'l', 50},\n    {'xl',\
    \ 40},\n    {'x', 10},\n    {'ix', 9},\n    {'v', 5},\n    {'iv', 4},\n    {'i',\
    \ 1}\n  }\n  local roman_string = ''\n  for _, numeral in ipairs(roman_numerals)\
    \ do\n    local letter, value = numeral[1], numeral[2]\n    while number >= value\
    \ do\n      roman_string = roman_string .. letter\n      number = number - value\n\
    \    end\n  end\n  return roman_string\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 0\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    local digit_roman = ''\n        if digit_value == 9 then\n            digit_roman\
    \ = roman_numerals[digit + 1][1] .. roman_numerals[digit + 2][1]\n        elseif\
    \ digit_value >= 5 then\n            digit_roman = roman_numerals[digit + 1][2]\n\
    \            digit_value = digit_value - 5\n        elseif digit_value == 4 then\n\
    \            digit_roman = roman_numerals[digit + 1][1] .. roman_numerals[digit\
    \ + 1][2]\n        end\n        for i = 1, digit_value do\n            digit_roman\
    \ = digit_roman .. roman_numerals[digit + 1][1]\n        end\n        result =\
    \ digit_roman .. result\n        number = (number - (number % 10)) / 10\n    \
    \    digit = digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp91eexahw.lua:41:\
    \ expected: \"xix\"\\nactual: \"xixiiiiiiiii\"\\nstack traceback:\\n\\t/tmp/tmp91eexahw.lua:41:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_numeral\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            roman_numeral\
    \ = roman_numeral .. roman\n            number = number - arabic\n        end\n\
    \    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpzirtntls.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpzirtntls.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpzirtntls.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ roman_string = ''\n    for _, numeral in ipairs(roman_numerals) do\n       \
    \ local letter, value = numeral[1], numeral[2]\n        while number >= value\
    \ do\n            roman_string = roman_string .. letter\n            number =\
    \ number - value\n        end\n    end\n    return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local num =\
    \ number\n    local i = 1\n    while num > 0 do\n        local digit = num % 10\n\
    \        local roman_digit = ''\n        if digit == 9 then\n            roman_digit\
    \ = roman_numerals[i][1] .. roman_numerals[i + 1][1]\n        elseif digit ==\
    \ 4 then\n            roman_digit = roman_numerals[i][1] .. roman_numerals[i][2]\n\
    \        else\n            if digit >= 5 then\n                roman_digit = roman_numerals[i][2]\n\
    \                digit = digit - 5\n            end\n            roman_digit =\
    \ roman_digit .. string.rep(roman_numerals[i][1], digit)\n        end\n      \
    \  result = roman_digit .. result\n        num = math.floor(num / 10)\n      \
    \  i = i + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local symbols = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l',\
    \ 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n    local values = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n    for i = 1, #values do\n        while number\
    \ >= values[i] do\n            roman = roman .. symbols[i]\n            number\
    \ = number - values[i]\n        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local\
    \ numeral_letter, numeral_value = numeral[1], numeral[2]\n        while number\
    \ >= numeral_value do\n            result = result .. numeral_letter\n       \
    \     number = number - numeral_value\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local value, numeral\
    \ = unpack(pair)\n        while number >= value do\n            result = result\
    \ .. numeral\n            number = number - value\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        { 'm', 1000 },\n        { 'cm', 900 },\n\
    \        { 'd', 500 },\n        { 'cd', 400 },\n        { 'c', 100 },\n      \
    \  { 'xc', 90 },\n        { 'l', 50 },\n        { 'xl', 40 },\n        { 'x',\
    \ 10 },\n        { 'ix', 9 },\n        { 'v', 5 },\n        { 'iv', 4 },\n   \
    \     { 'i', 1 }\n    }\n    local result = ''\n    for _, numeral in ipairs(roman_numerals)\
    \ do\n        local numeral_string, numeral_value = numeral[1], numeral[2]\n \
    \       while number >= numeral_value do\n            result = result .. numeral_string\n\
    \            number = number - numeral_value\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'d', 500},\n   \
    \     {'c', 100},\n        {'l', 50},\n        {'x', 10},\n        {'v', 5},\n\
    \        {'i', 1}\n    }\n    local roman_string = ''\n    local remainder = number\n\
    \    for i, numeral in ipairs(roman_numerals) do\n        local numeral_string,\
    \ numeral_value = numeral[1], numeral[2]\n        local numeral_count = math.floor(remainder\
    \ / numeral_value)\n        remainder = remainder % numeral_value\n        if\
    \ numeral_count > 0 then\n            roman_string = roman_string .. numeral_string:rep(numeral_count)\n\
    \        end\n    end\n    return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpusjo44k5.lua:34:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmpusjo44k5.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    local roman_digit = roman_numerals[digit]\n        if digit_value == 9 then\n\
    \            result = roman_digit[1] .. roman_numerals[digit + 1][1] .. result\n\
    \        elseif digit_value == 4 then\n            result = roman_digit[1] ..\
    \ roman_digit[2] .. result\n        else\n            if digit_value >= 5 then\n\
    \                result = roman_digit[2] .. result\n                digit_value\
    \ = digit_value - 5\n            end\n            result = result .. string.rep(roman_digit[1],\
    \ digit_value)\n        end\n        number = (number - digit_value) / 10\n  \
    \      digit = digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpads5cmeb.lua:40:\
    \ expected: \"xix\"\\nactual: \"ixx\"\\nstack traceback:\\n\\t/tmp/tmpads5cmeb.lua:40:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local numeral = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l',\
    \ 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  local value = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n  for i = 1, #value do\n    while number >= value[i]\
    \ do\n      result = result .. numeral[i]\n      number = number - value[i]\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    local roman_numerals = {\n\
    \        {'m', 1000},\n        {'cm', 900},\n        {'d', 500},\n        {'cd',\
    \ 400},\n        {'c', 100},\n        {'xc', 90},\n        {'l', 50},\n      \
    \  {'xl', 40},\n        {'x', 10},\n        {'ix', 9},\n        {'v', 5},\n  \
    \      {'iv', 4},\n        {'i', 1}\n    }\n    for _, numeral in ipairs(roman_numerals)\
    \ do\n        local roman, value = numeral[1], numeral[2]\n        while num >=\
    \ value do\n            result = result .. roman\n            num = num - value\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = table.unpack(pair)\n    while number >= arabic do\n\
    \      result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpstkbfldr.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpstkbfldr.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpstkbfldr.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local i = 1\n\
    \    while number > 0 do\n        local digit = number % 10\n        if digit\
    \ == 9 then\n            result = roman_numerals[i][1] .. roman_numerals[i + 1][1]\
    \ .. result\n        elseif digit == 4 then\n            result = roman_numerals[i][1]\
    \ .. roman_numerals[i][2] .. result\n        else\n            local fives = digit\
    \ >= 5 and roman_numerals[i][2] or ''\n            local ones = digit % 5\n  \
    \          result = fives .. string.rep(roman_numerals[i][1], ones) .. result\n\
    \        end\n        number = math.floor(number / 10)\n        i = i + 1\n  \
    \  end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpmy584o4b.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpmy584o4b.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpmy584o4b.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local\
    \ numeral_string, numeral_value = numeral[1], numeral[2]\n        while number\
    \ >= numeral_value do\n            result = result .. numeral_string\n       \
    \     number = number - numeral_value\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ roman_string = ''\n    for _, numeral in ipairs(roman_numerals) do\n       \
    \ local numeral_string, value = numeral[1], numeral[2]\n        while number >=\
    \ value do\n            roman_string = roman_string .. numeral_string\n      \
    \      number = number - value\n        end\n    end\n    return roman_string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmptklhn5t6.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmptklhn5t6.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmptklhn5t6.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    while num > 0 do\n       \
    \ if num >= 1000 then\n            result = result .. 'm'\n            num = num\
    \ - 1000\n        elseif num >= 900 then\n            result = result .. 'cm'\n\
    \            num = num - 900\n        elseif num >= 500 then\n            result\
    \ = result .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            result = result .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            result = result .. 'c'\n            num = num -\
    \ 100\n        elseif num >= 90 then\n            result = result .. 'xc'\n  \
    \          num = num - 90\n        elseif num >= 50 then\n            result =\
    \ result .. 'l'\n            num = num - 50\n        elseif num >= 40 then\n \
    \           result = result .. 'xl'\n            num = num - 40\n        elseif\
    \ num >= 10 then\n            result = result .. 'x'\n            num = num -\
    \ 10\n        elseif num >= 9 then\n            result = result .. 'ix'\n    \
    \        num = num - 9\n        elseif num >= 5 then\n            result = result\
    \ .. 'v'\n            num = num - 5\n        elseif num >= 4 then\n          \
    \  result = result .. 'iv'\n            num = num - 4\n        elseif num >= 1\
    \ then\n            result = result .. 'i'\n            num = num - 1\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    while num > 0 do\n       \
    \ if num >= 1000 then\n            result = result .. 'm'\n            num = num\
    \ - 1000\n        elseif num >= 900 then\n            result = result .. 'cm'\n\
    \            num = num - 900\n        elseif num >= 500 then\n            result\
    \ = result .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            result = result .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            result = result .. 'c'\n            num = num -\
    \ 100\n        elseif num >= 90 then\n            result = result .. 'xc'\n  \
    \          num = num - 90\n        elseif num >= 50 then\n            result =\
    \ result .. 'l'\n            num = num - 50\n        elseif num >= 40 then\n \
    \           result = result .. 'xl'\n            num = num - 40\n        elseif\
    \ num >= 10 then\n            result = result .. 'x'\n            num = num -\
    \ 10\n        elseif num >= 9 then\n            result = result .. 'ix'\n    \
    \        num = num - 9\n        elseif num >= 5 then\n            result = result\
    \ .. 'v'\n            num = num - 5\n        elseif num >= 4 then\n          \
    \  result = result .. 'iv'\n            num = num - 4\n        elseif num >= 1\
    \ then\n            result = result .. 'i'\n            num = num - 1\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, numeral in ipairs(roman_numerals) do\n\
    \    local value, letter = numeral[1], numeral[2]\n    while number >= value do\n\
    \      result = result .. letter\n      number = number - value\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpnby_c0zy.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpnby_c0zy.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpnby_c0zy.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    while num > 0 do\n       \
    \ if num >= 1000 then\n            result = result .. 'm'\n            num = num\
    \ - 1000\n        elseif num >= 900 then\n            result = result .. 'cm'\n\
    \            num = num - 900\n        elseif num >= 500 then\n            result\
    \ = result .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            result = result .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            result = result .. 'c'\n            num = num -\
    \ 100\n        elseif num >= 90 then\n            result = result .. 'xc'\n  \
    \          num = num - 90\n        elseif num >= 50 then\n            result =\
    \ result .. 'l'\n            num = num - 50\n        elseif num >= 40 then\n \
    \           result = result .. 'xl'\n            num = num - 40\n        elseif\
    \ num >= 10 then\n            result = result .. 'x'\n            num = num -\
    \ 10\n        elseif num >= 9 then\n            result = result .. 'ix'\n    \
    \        num = num - 9\n        elseif num >= 5 then\n            result = result\
    \ .. 'v'\n            num = num - 5\n        elseif num >= 4 then\n          \
    \  result = result .. 'iv'\n            num = num - 4\n        elseif num >= 1\
    \ then\n            result = result .. 'i'\n            num = num - 1\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, pair in ipairs(roman_numerals) do\n        local numeral,\
    \ value = pair[1], pair[2]\n        while number >= value do\n            result\
    \ = result .. numeral\n            number = number - value\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local num = number\n  while num > 0 do\n    if num >= 1000\
    \ then\n      roman = roman .. 'm'\n      num = num - 1000\n    elseif num >=\
    \ 900 then\n      roman = roman .. 'cm'\n      num = num - 900\n    elseif num\
    \ >= 500 then\n      roman = roman .. 'd'\n      num = num - 500\n    elseif num\
    \ >= 400 then\n      roman = roman .. 'cd'\n      num = num - 400\n    elseif\
    \ num >= 100 then\n      roman = roman .. 'c'\n      num = num - 100\n    elseif\
    \ num >= 90 then\n      roman = roman .. 'xc'\n      num = num - 90\n    elseif\
    \ num >= 50 then\n      roman = roman .. 'l'\n      num = num - 50\n    elseif\
    \ num >= 40 then\n      roman = roman .. 'xl'\n      num = num - 40\n    elseif\
    \ num >= 10 then\n      roman = roman .. 'x'\n      num = num - 10\n    elseif\
    \ num >= 9 then\n      roman = roman .. 'ix'\n      num = num - 9\n    elseif\
    \ num >= 5 then\n      roman = roman .. 'v'\n      num = num - 5\n    elseif num\
    \ >= 4 then\n      roman = roman .. 'iv'\n      num = num - 4\n    elseif num\
    \ >= 1 then\n      roman = roman .. 'i'\n      num = num - 1\n    end\n  end\n\
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpefmnhrry.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpefmnhrry.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpefmnhrry.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    local numeral_map = {\n  \
    \      {1000, 'm'},\n        {900, 'cm'},\n        {500, 'd'},\n        {400,\
    \ 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n        {50, 'l'},\n     \
    \   {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n        {5, 'v'},\n \
    \       {4, 'iv'},\n        {1, 'i'},\n    }\n    for _, pair in ipairs(numeral_map)\
    \ do\n        local value = pair[1]\n        local numeral = pair[2]\n       \
    \ while num >= value do\n            result = result .. numeral\n            num\
    \ = num - value\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {'m', 1000},\n    {'cm', 900},\n    {'d', 500},\n\
    \    {'cd', 400},\n    {'c', 100},\n    {'xc', 90},\n    {'l', 50},\n    {'xl',\
    \ 40},\n    {'x', 10},\n    {'ix', 9},\n    {'v', 5},\n    {'iv', 4},\n    {'i',\
    \ 1}\n  }\n  local result = ''\n  for _, numeral in ipairs(roman_numerals) do\n\
    \    local letter, value = numeral[1], numeral[2]\n    while number >= value do\n\
    \      result = result .. letter\n      number = number - value\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpq3bfx9ny.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpq3bfx9ny.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpq3bfx9ny.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpkfzvejqk.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpkfzvejqk.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpkfzvejqk.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = unpack(numeral)\n        while number >= value do\n            result\
    \ = result .. symbol\n            number = number - value\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local num =\
    \ number\n    for i = 1, #roman_numerals do\n        local numeral = roman_numerals[i]\n\
    \        local digit = num % 10\n        num = math.floor(num / 10)\n        if\
    \ digit == 9 then\n            result = numeral[1] .. roman_numerals[i + 1][1]\
    \ .. result\n        elseif digit >= 5 then\n            result = numeral[2] ..\
    \ numeral[1]:rep(digit - 5) .. result\n        elseif digit == 4 then\n      \
    \      result = numeral[1] .. numeral[2] .. result\n        else\n           \
    \ result = numeral[1]:rep(digit) .. result\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local num = number\n  while num > 0 do\n    if num >= 1000\
    \ then\n      roman = roman .. 'm'\n      num = num - 1000\n    elseif num >=\
    \ 900 then\n      roman = roman .. 'cm'\n      num = num - 900\n    elseif num\
    \ >= 500 then\n      roman = roman .. 'd'\n      num = num - 500\n    elseif num\
    \ >= 400 then\n      roman = roman .. 'cd'\n      num = num - 400\n    elseif\
    \ num >= 100 then\n      roman = roman .. 'c'\n      num = num - 100\n    elseif\
    \ num >= 90 then\n      roman = roman .. 'xc'\n      num = num - 90\n    elseif\
    \ num >= 50 then\n      roman = roman .. 'l'\n      num = num - 50\n    elseif\
    \ num >= 40 then\n      roman = roman .. 'xl'\n      num = num - 40\n    elseif\
    \ num >= 10 then\n      roman = roman .. 'x'\n      num = num - 10\n    elseif\
    \ num >= 9 then\n      roman = roman .. 'ix'\n      num = num - 9\n    elseif\
    \ num >= 5 then\n      roman = roman .. 'v'\n      num = num - 5\n    elseif num\
    \ >= 4 then\n      roman = roman .. 'iv'\n      num = num - 4\n    elseif num\
    \ >= 1 then\n      roman = roman .. 'i'\n      num = num - 1\n    end\n  end\n\
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ roman_numeral = ''\n    for _, pair in ipairs(roman_numerals) do\n        local\
    \ numeral, value = pair[1], pair[2]\n        while number >= value do\n      \
    \      roman_numeral = roman_numeral .. numeral\n            number = number -\
    \ value\n        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local arabic,\
    \ roman = numeral[1], numeral[2]\n        while number >= arabic do\n        \
    \    result = result .. roman\n            number = number - arabic\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp8rxv1aed.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp8rxv1aed.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp8rxv1aed.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numeral = ''\n  local number_to_roman_numeral = {\n    {1000, 'm'},\n\
    \    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90,\
    \ 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n  \
    \  {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n  }\n  for _, pair in ipairs(number_to_roman_numeral)\
    \ do\n    local arabic, roman = table.unpack(pair)\n    while number >= arabic\
    \ do\n      roman_numeral = roman_numeral .. roman\n      number = number - arabic\n\
    \    end\n  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpe_m268tg.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpe_m268tg.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpe_m268tg.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 0\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    if digit_value > 0 then\n            local roman_numeral = roman_numerals[digit\
    \ + 1]\n            if digit_value == 9 then\n                result = roman_numeral[1]\
    \ .. roman_numeral[2] .. result\n            elseif digit_value >= 5 then\n  \
    \              result = roman_numeral[2] .. string.rep(roman_numeral[1], digit_value\
    \ - 5) .. result\n            elseif digit_value == 4 then\n                result\
    \ = roman_numeral[1] .. roman_numeral[2] .. result\n            else\n       \
    \         result = string.rep(roman_numeral[1], digit_value) .. result\n     \
    \       end\n        end\n        number = math.floor(number / 10)\n        digit\
    \ = digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_h7phk55.lua:40:\
    \ expected: \"xix\"\\nactual: \"xiv\"\\nstack traceback:\\n\\t/tmp/tmp_h7phk55.lua:40:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_numeral\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local arabic,\
    \ roman = numeral[1], numeral[2]\n        while number >= arabic do\n        \
    \    roman_numeral = roman_numeral .. roman\n            number = number - arabic\n\
    \        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, v in ipairs(roman_numerals) do\n        while number >= v[1]\
    \ do\n            result = result .. v[2]\n            number = number - v[1]\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = table.unpack(pair)\n    while number >= arabic do\n\
    \      result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmptmavafx0.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmptmavafx0.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmptmavafx0.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_string\
    \ = ''\n    for i, v in ipairs(roman_numerals) do\n        local num = v[1]\n\
    \        local roman = v[2]\n        while number >= num do\n            roman_string\
    \ = roman_string .. roman\n            number = number - num\n        end\n  \
    \  end\n    return roman_string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numeral = ''\n  local symbols = {'m', 'cm', 'd', 'cd', 'c', 'xc',\
    \ 'l', 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  local values = {1000, 900, 500, 400,\
    \ 100, 90, 50, 40, 10, 9, 5, 4, 1}\n  for i, v in ipairs(values) do\n    while\
    \ number >= v do\n      roman_numeral = roman_numeral .. symbols[i]\n      number\
    \ = number - v\n    end\n  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local symbols = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l',\
    \ 'xl', 'x', 'ix', 'v', 'iv', 'i'}\n  local values = {1000, 900, 500, 400, 100,\
    \ 90, 50, 40, 10, 9, 5, 4, 1}\n  for i = 1, #values do\n    while number >= values[i]\
    \ do\n      result = result .. symbols[i]\n      number = number - values[i]\n\
    \    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for i = 1, #roman_numerals do\n        local arabic, roman = table.unpack(roman_numerals[i])\n\
    \        while number >= arabic do\n            result = result .. roman\n   \
    \         number = number - arabic\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpyzeouybu.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpyzeouybu.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpyzeouybu.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local\
    \ letter, value = numeral[1], numeral[2]\n        while number >= value do\n \
    \           result = result .. letter\n            number = number - value\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    local numeral_map = {\n   \
    \     {1000, 'm'},\n        {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n\
    \        {100, 'c'},\n        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n\
    \        {10, 'x'},\n        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n\
    \        {1, 'i'},\n    }\n    for _, pair in ipairs(numeral_map) do\n       \
    \ local value = pair[1]\n        local numeral = pair[2]\n        while num >=\
    \ value do\n            roman = roman .. numeral\n            num = num - value\n\
    \        end\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n\
    \    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50,\
    \ 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4,\
    \ 'iv'},\n    {1, 'i'}\n  }\n  for _, numeral in ipairs(roman_numerals) do\n \
    \   while number >= numeral[1] do\n      roman = roman .. numeral[2]\n      number\
    \ = number - numeral[1]\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local i = 1\n\
    \    while number > 0 do\n        local digit = number % 10\n        if digit\
    \ > 0 then\n            local roman_digit = ''\n            if digit == 9 then\n\
    \                roman_digit = roman_numerals[i][1] .. roman_numerals[i + 1][1]\n\
    \            elseif digit >= 5 then\n                roman_digit = roman_numerals[i][2]\n\
    \                for j = 1, digit - 5 do\n                    roman_digit = roman_digit\
    \ .. roman_numerals[i][1]\n                end\n            elseif digit == 4\
    \ then\n                roman_digit = roman_numerals[i][1] .. roman_numerals[i][2]\n\
    \            else\n                for j = 1, digit do\n                    roman_digit\
    \ = roman_digit .. roman_numerals[i][1]\n                end\n            end\n\
    \            result = roman_digit .. result\n        end\n        number = math.floor(number\
    \ / 10)\n        i = i + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    local digit_roman = ''\n        if digit_value == 9 then\n            digit_roman\
    \ = roman_numerals[digit][1] .. roman_numerals[digit + 1][1]\n        elseif digit_value\
    \ == 4 then\n            digit_roman = roman_numerals[digit][1] .. roman_numerals[digit][2]\n\
    \        else\n            if digit_value >= 5 then\n                digit_roman\
    \ = roman_numerals[digit][2]\n                digit_value = digit_value - 5\n\
    \            end\n            digit_roman = digit_roman .. string.rep(roman_numerals[digit][1],\
    \ digit_value)\n        end\n        result = digit_roman .. result\n        number\
    \ = math.floor(number / 10)\n        digit = digit + 1\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numeral = ''\n  local numeral_table = {\n    {'m', 1000},\n   \
    \ {'d', 500},\n    {'c', 100},\n    {'l', 50},\n    {'x', 10},\n    {'v', 5},\n\
    \    {'i', 1}\n  }\n  for i = 1, #numeral_table do\n    local numeral, value =\
    \ numeral_table[i][1], numeral_table[i][2]\n    while number >= value do\n   \
    \   roman_numeral = roman_numeral .. numeral\n      number = number - value\n\
    \    end\n  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphyknam0d.lua:32:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmphyknam0d.lua:32:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local numeral_map = {\n    {1000, 'm'},\n    {900, 'cm'},\n\
    \    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50,\
    \ 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4,\
    \ 'iv'},\n    {1, 'i'},\n  }\n  for _, numeral in ipairs(numeral_map) do\n   \
    \ local value, letters = numeral[1], numeral[2]\n    while number >= value do\n\
    \      result = result .. letters\n      number = number - value\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpy2zm9a0r.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpy2zm9a0r.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpy2zm9a0r.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = table.unpack(pair)\n    while number >= arabic do\n\
    \      result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpwnfoguw9.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpwnfoguw9.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpwnfoguw9.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local romans = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n   \
    \ {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n\
    \    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n\
    \  }\n  local result = ''\n  for _, v in ipairs(romans) do\n    while number >=\
    \ v[1] do\n      result = result .. v[2]\n      number = number - v[1]\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local num = number\n  local numeral_map = {\n    {1000,\
    \ 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n\
    \    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n\
    \    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'},\n  }\n  for _, numeral in ipairs(numeral_map)\
    \ do\n    local value, letter = numeral[1], numeral[2]\n    while num >= value\
    \ do\n      result = result .. letter\n      num = num - value\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpmxi1syy5.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpmxi1syy5.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpmxi1syy5.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ roman_string = ''\n    for i = 1, #roman_numerals do\n        local roman_numeral\
    \ = roman_numerals[i]\n        local roman_letter = roman_numeral[1]\n       \
    \ local roman_value = roman_numeral[2]\n        while number >= roman_value do\n\
    \            roman_string = roman_string .. roman_letter\n            number =\
    \ number - roman_value\n        end\n    end\n    return roman_string\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local\
    \ numeral_string, numeral_value = numeral[1], numeral[2]\n        while number\
    \ >= numeral_value do\n            result = result .. numeral_string\n       \
    \     number = number - numeral_value\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local num = number\n    local numeral_map = {\n \
    \       {1000, \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n      \
    \  {400, \"cd\"},\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50,\
    \ \"l\"},\n        {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n\
    \        {5, \"v\"},\n        {4, \"iv\"},\n        {1, \"i\"},\n    }\n    for\
    \ _, pair in ipairs(numeral_map) do\n        local arabic, roman_numeral = pair[1],\
    \ pair[2]\n        while num >= arabic do\n            roman = roman .. roman_numeral\n\
    \            num = num - arabic\n        end\n    end\n    return roman\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  for i = 1, #mini_roman_numerals do\n    local numeral =\
    \ mini_roman_numerals[i]\n    local value = mini_roman_values[i]\n    while number\
    \ >= value do\n      roman = roman .. numeral\n      number = number - value\n\
    \    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpikma7zo4.lua:10:\
    \ attempt to get length of global 'mini_roman_numerals' (a nil value)\\nstack\
    \ traceback:\\n\\t/tmp/tmpikma7zo4.lua:10: in function 'candidate'\\n\\t/tmp/tmpikma7zo4.lua:24:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local num = number\n  local numeral_map = {\n    {1000,\
    \ 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n\
    \    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n\
    \    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'},\n  }\n  for _, n in ipairs(numeral_map)\
    \ do\n    local value, numeral = n[1], n[2]\n    while num >= value do\n     \
    \ roman = roman .. numeral\n      num = num - value\n    end\n  end\n  return\
    \ roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_numeral\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, numeral\
    \ = table.unpack(pair)\n        while number >= arabic do\n            roman_numeral\
    \ = roman_numeral .. numeral\n            number = number - arabic\n        end\n\
    \    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpayewf7m8.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpayewf7m8.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpayewf7m8.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_numeral\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local decimal, numeral\
    \ = table.unpack(pair)\n        while number >= decimal do\n            roman_numeral\
    \ = roman_numeral .. numeral\n            number = number - decimal\n        end\n\
    \    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp1pdnr3_s.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp1pdnr3_s.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp1pdnr3_s.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp78u83g6a.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp78u83g6a.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp78u83g6a.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = table.unpack(pair)\n    while number >= arabic do\n\
    \      result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmphuhaha8h.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmphuhaha8h.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmphuhaha8h.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'d', 500},\n   \
    \     {'c', 100},\n        {'l', 50},\n        {'x', 10},\n        {'v', 5},\n\
    \        {'i', 1}\n    }\n    local result = ''\n    for _, numeral in ipairs(roman_numerals)\
    \ do\n        local letter, value = numeral[1], numeral[2]\n        while number\
    \ >= value do\n            result = result .. letter\n            number = number\
    \ - value\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7f3g2bv_.lua:32:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmp7f3g2bv_.lua:32:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 0\n    while number > 0 do\n        local remainder = number % 10\n      \
    \  if remainder == 9 then\n            result = roman_numerals[digit + 1][1] ..\
    \ roman_numerals[digit + 2][1] .. result\n        elseif remainder >= 5 then\n\
    \            result = roman_numerals[digit + 1][2] .. string.rep(roman_numerals[digit\
    \ + 1][1], remainder - 5) .. result\n        elseif remainder == 4 then\n    \
    \        result = roman_numerals[digit + 1][1] .. roman_numerals[digit + 1][2]\
    \ .. result\n        else\n            result = string.rep(roman_numerals[digit\
    \ + 1][1], remainder) .. result\n        end\n        number = math.floor(number\
    \ / 10)\n        digit = digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local i = 1\n    while number > 0 do\n        local\
    \ digit = number % 10\n        number = (number - digit) / 10\n        if digit\
    \ == 9 then\n            roman = roman .. mini_roman_digits[i][9]\n        elseif\
    \ digit == 4 then\n            roman = roman .. mini_roman_digits[i][4]\n    \
    \    else\n            if digit >= 5 then\n                roman = roman .. mini_roman_digits[i][5]\n\
    \                digit = digit - 5\n            end\n            for j = 1, digit\
    \ do\n                roman = roman .. mini_roman_digits[i][1]\n            end\n\
    \        end\n        i = i + 1\n    end\n    return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmplxzenzr0.lua:15:\
    \ attempt to index global 'mini_roman_digits' (a nil value)\\nstack traceback:\\\
    n\\t/tmp/tmplxzenzr0.lua:15: in function 'candidate'\\n\\t/tmp/tmplxzenzr0.lua:35:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_string\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ letter = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    roman_string = roman_string .. letter\n            number = number - value\n\
    \        end\n    end\n    return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_string\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local value = pair[1]\n\
    \        local numeral = pair[2]\n        while number >= value do\n         \
    \   roman_string = roman_string .. numeral\n            number = number - value\n\
    \        end\n    end\n    return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local arabic_to_roman = {\n        {1000, 'm'},\n\
    \        {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100,\
    \ 'c'},\n        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n      \
    \  {10, 'x'},\n        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n   \
    \     {1, 'i'},\n    }\n    for _, pair in ipairs(arabic_to_roman) do\n      \
    \  local arabic, roman = table.unpack(pair)\n        while number >= arabic do\n\
    \            result = result .. roman\n            number = number - arabic\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmps7zmu7wt.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmps7zmu7wt.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmps7zmu7wt.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local value, numeral\
    \ = pair[1], pair[2]\n        while number >= value do\n            result = result\
    \ .. numeral\n            number = number - value\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    local digit_roman = ''\n        if digit_value == 9 then\n            digit_roman\
    \ = roman_numerals[digit][1] .. roman_numerals[digit + 1][1]\n        elseif digit_value\
    \ == 4 then\n            digit_roman = roman_numerals[digit][1] .. roman_numerals[digit][2]\n\
    \        else\n            if digit_value >= 5 then\n                digit_roman\
    \ = roman_numerals[digit][2]\n                digit_value = digit_value - 5\n\
    \            end\n            digit_roman = digit_roman .. string.rep(roman_numerals[digit][1],\
    \ digit_value)\n        end\n        result = digit_roman .. result\n        number\
    \ = math.floor(number / 10)\n        digit = digit + 1\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local roman_numerals = {\n    {'i', 'v'},\n    {'x', 'l'},\n\
    \    {'c', 'd'},\n    {'m'}\n  }\n  local digit = 1\n  while number > 0 do\n \
    \   local digit_value = number % 10\n    local roman_digit = ''\n    if digit_value\
    \ == 9 then\n      roman_digit = roman_numerals[digit][1] .. roman_numerals[digit\
    \ + 1][1]\n    elseif digit_value >= 5 then\n      roman_digit = roman_numerals[digit][2]\n\
    \      for i = 1, digit_value - 5 do\n        roman_digit = roman_digit .. roman_numerals[digit][1]\n\
    \      end\n    elseif digit_value == 4 then\n      roman_digit = roman_numerals[digit][1]\
    \ .. roman_numerals[digit][2]\n    else\n      for i = 1, digit_value do\n   \
    \     roman_digit = roman_digit .. roman_numerals[digit][1]\n      end\n    end\n\
    \    roman = roman_digit .. roman\n    number = math.floor(number / 10)\n    digit\
    \ = digit + 1\n  end\n  return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local digits = {1000, 900, 500, 400, 100, 90, 50, 40,\
    \ 10, 9, 5, 4, 1}\n  local roman = {'m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl',\
    \ 'x', 'ix', 'v', 'iv', 'i'}\n  for i = 1, #digits do\n    while number >= digits[i]\
    \ do\n      result = result .. roman[i]\n      number = number - digits[i]\n \
    \   end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp936lrcjo.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp936lrcjo.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp936lrcjo.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    local numeral = {\n       \
    \ {'m', 1000},\n        {'cm', 900},\n        {'d', 500},\n        {'cd', 400},\n\
    \        {'c', 100},\n        {'xc', 90},\n        {'l', 50},\n        {'xl',\
    \ 40},\n        {'x', 10},\n        {'ix', 9},\n        {'v', 5},\n        {'iv',\
    \ 4},\n        {'i', 1}\n    }\n    for i = 1, #numeral do\n        local n =\
    \ numeral[i][1]\n        local v = numeral[i][2]\n        while num >= v do\n\
    \            roman = roman .. n\n            num = num - v\n        end\n    end\n\
    \    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_numeral\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, numeral\
    \ = table.unpack(pair)\n        while number >= arabic do\n            roman_numeral\
    \ = roman_numeral .. numeral\n            number = number - arabic\n        end\n\
    \    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpv0ibzknb.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpv0ibzknb.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpv0ibzknb.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = \"\"\n  local num_to_roman = {\n    [1] = \"i\", [2] = \"ii\"\
    , [3] = \"iii\", [4] = \"iv\", [5] = \"v\",\n    [6] = \"vi\", [7] = \"vii\",\
    \ [8] = \"viii\", [9] = \"ix\", [10] = \"x\",\n    [20] = \"xx\", [30] = \"xxx\"\
    , [40] = \"xl\", [50] = \"l\",\n    [60] = \"lx\", [70] = \"lxx\", [80] = \"lxxx\"\
    , [90] = \"xc\", [100] = \"c\",\n    [200] = \"cc\", [300] = \"ccc\", [400] =\
    \ \"cd\", [500] = \"d\",\n    [600] = \"dc\", [700] = \"dcc\", [800] = \"dccc\"\
    , [900] = \"cm\", [1000] = \"m\"\n  }\n  local num_to_roman_keys = {1000, 900,\
    \ 800, 700, 600, 500, 400, 300, 200, 100,\n                             90, 80,\
    \ 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5,\n                             4,\
    \ 3, 2, 1}\n  for _, key in ipairs(num_to_roman_keys) do\n    while number >=\
    \ key do\n      result = result .. num_to_roman[key]\n      number = number -\
    \ key\n    end\n  end\n  return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    local digit_roman = ''\n        if digit_value == 9 then\n            digit_roman\
    \ = roman_numerals[digit][1] .. roman_numerals[digit + 1][1]\n        elseif digit_value\
    \ == 4 then\n            digit_roman = roman_numerals[digit][1] .. roman_numerals[digit][2]\n\
    \        else\n            if digit_value >= 5 then\n                digit_roman\
    \ = roman_numerals[digit][2]\n                digit_value = digit_value - 5\n\
    \            end\n            digit_roman = digit_roman .. string.rep(roman_numerals[digit][1],\
    \ digit_value)\n        end\n        result = digit_roman .. result\n        number\
    \ = math.floor(number / 10)\n        digit = digit + 1\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for i = 1, #roman_numerals do\n        local arabic, roman = table.unpack(roman_numerals[i])\n\
    \        while number >= arabic do\n            result = result .. roman\n   \
    \         number = number - arabic\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp8yapv9zb.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp8yapv9zb.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp8yapv9zb.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {'m', 1000},\n    {'cm', 900},\n    {'d', 500},\n\
    \    {'cd', 400},\n    {'c', 100},\n    {'xc', 90},\n    {'l', 50},\n    {'xl',\
    \ 40},\n    {'x', 10},\n    {'ix', 9},\n    {'v', 5},\n    {'iv', 4},\n    {'i',\
    \ 1}\n  }\n  local result = ''\n  for i = 1, #roman_numerals do\n    local numeral,\
    \ value = roman_numerals[i][1], roman_numerals[i][2]\n    while number >= value\
    \ do\n      result = result .. numeral\n      number = number - value\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        while number\
    \ >= numeral[1] do\n            result = result .. numeral[2]\n            number\
    \ = number - numeral[1]\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numeral = ''\n  local roman_numerals = {\n    {1000, 'm'},\n  \
    \  {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n    {90,\
    \ 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n  \
    \  {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'}\n  }\n  for _, pair in ipairs(roman_numerals)\
    \ do\n    local arabic, roman = table.unpack(pair)\n    while number >= arabic\
    \ do\n      roman_numeral = roman_numeral .. roman\n      number = number - arabic\n\
    \    end\n  end\n  return roman_numeral\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmplq7lhi09.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmplq7lhi09.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmplq7lhi09.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, v in ipairs(roman_numerals) do\n  \
    \  local num, roman = v[1], v[2]\n    while number >= num do\n      result = result\
    \ .. roman\n      number = number - num\n    end\n  end\n  return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \tlocal roman = ''\n\tlocal num = number\n\tlocal numeral = {\n\t\t{ 'm', 1000\
    \ },\n\t\t{ 'cm', 900 },\n\t\t{ 'd', 500 },\n\t\t{ 'cd', 400 },\n\t\t{ 'c', 100\
    \ },\n\t\t{ 'xc', 90 },\n\t\t{ 'l', 50 },\n\t\t{ 'xl', 40 },\n\t\t{ 'x', 10 },\n\
    \t\t{ 'ix', 9 },\n\t\t{ 'v', 5 },\n\t\t{ 'iv', 4 },\n\t\t{ 'i', 1 }\n\t}\n\tfor\
    \ _, v in ipairs(numeral) do\n\t\twhile num >= v[2] do\n\t\t\troman = roman ..\
    \ v[1]\n\t\t\tnum = num - v[2]\n\t\tend\n\tend\n\treturn roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    if digit_value == 9 then\n            result = roman_numerals[digit][1] ..\
    \ roman_numerals[digit + 1][1] .. result\n        elseif digit_value == 4 then\n\
    \            result = roman_numerals[digit][1] .. roman_numerals[digit][2] ..\
    \ result\n        else\n            local five_value = digit_value >= 5 and roman_numerals[digit][2]\
    \ or ''\n            digit_value = digit_value % 5\n            result = five_value\
    \ .. string.rep(roman_numerals[digit][1], digit_value) .. result\n        end\n\
    \        number = math.floor(number / 10)\n        digit = digit + 1\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpvy82h9z6.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpvy82h9z6.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpvy82h9z6.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local numeral_map = {\n        {1000, 'm'},\n    \
    \    {900, 'cm'},\n        {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n\
    \        {90, 'xc'},\n        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n\
    \        {9, 'ix'},\n        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'},\n\
    \    }\n    for _, numeral in ipairs(numeral_map) do\n        local value, letter\
    \ = numeral[1], numeral[2]\n        while number >= value do\n            result\
    \ = result .. letter\n            number = number - value\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'d', 500},\n   \
    \     {'c', 100},\n        {'l', 50},\n        {'x', 10},\n        {'v', 5},\n\
    \        {'i', 1}\n    }\n    local result = ''\n    local i = 1\n    while number\
    \ > 0 do\n        local numeral = roman_numerals[i]\n        local numeral_value\
    \ = numeral[2]\n        local numeral_letter = numeral[1]\n        local numeral_count\
    \ = math.floor(number / numeral_value)\n        number = number - numeral_count\
    \ * numeral_value\n        if numeral_count == 4 then\n            result = result\
    \ .. numeral_letter .. roman_numerals[i - 1][1]\n        else\n            result\
    \ = result .. numeral_letter:rep(numeral_count)\n        end\n        i = i +\
    \ 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp74pno33k.lua:39:\
    \ expected: \"xix\"\\nactual: \"xviv\"\\nstack traceback:\\n\\t/tmp/tmp74pno33k.lua:39:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local num = number\n  while num > 0 do\n    if num >=\
    \ 1000 then\n      result = result .. 'm'\n      num = num - 1000\n    elseif\
    \ num >= 900 then\n      result = result .. 'cm'\n      num = num - 900\n    elseif\
    \ num >= 500 then\n      result = result .. 'd'\n      num = num - 500\n    elseif\
    \ num >= 400 then\n      result = result .. 'cd'\n      num = num - 400\n    elseif\
    \ num >= 100 then\n      result = result .. 'c'\n      num = num - 100\n    elseif\
    \ num >= 90 then\n      result = result .. 'xc'\n      num = num - 90\n    elseif\
    \ num >= 50 then\n      result = result .. 'l'\n      num = num - 50\n    elseif\
    \ num >= 40 then\n      result = result .. 'xl'\n      num = num - 40\n    elseif\
    \ num >= 10 then\n      result = result .. 'x'\n      num = num - 10\n    elseif\
    \ num >= 9 then\n      result = result .. 'ix'\n      num = num - 9\n    elseif\
    \ num >= 5 then\n      result = result .. 'v'\n      num = num - 5\n    elseif\
    \ num >= 4 then\n      result = result .. 'iv'\n      num = num - 4\n    elseif\
    \ num >= 1 then\n      result = result .. 'i'\n      num = num - 1\n    end\n\
    \  end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    if digit_value == 4 then\n            result = roman_numerals[digit][1] ..\
    \ roman_numerals[digit][2] .. result\n        elseif digit_value == 9 then\n \
    \           result = roman_numerals[digit][1] .. roman_numerals[digit + 1][1]\
    \ .. result\n        else\n            local digit_string = ''\n            if\
    \ digit_value >= 5 then\n                digit_string = roman_numerals[digit][2]\n\
    \                digit_value = digit_value - 5\n            end\n            digit_string\
    \ = digit_string .. string.rep(roman_numerals[digit][1], digit_value)\n      \
    \      result = digit_string .. result\n        end\n        number = math.floor(number\
    \ / 10)\n        digit = digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for i = 1, #roman_numerals do\n        local arabic, roman = table.unpack(roman_numerals[i])\n\
    \        while number >= arabic do\n            result = result .. roman\n   \
    \         number = number - arabic\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpla1z91df.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpla1z91df.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpla1z91df.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = table.unpack(pair)\n    while number >= arabic do\n\
    \      result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpcxm0yfli.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpcxm0yfli.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpcxm0yfli.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, numeral in ipairs(roman_numerals) do\n\
    \    local value, letter = numeral[1], numeral[2]\n    while number >= value do\n\
    \      result = result .. letter\n      number = number - value\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = unpack(numeral)\n        while number >= value do\n            result\
    \ = result .. symbol\n            number = number - value\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'d', 500},\n   \
    \     {'c', 100},\n        {'l', 50},\n        {'x', 10},\n        {'v', 5},\n\
    \        {'i', 1}\n    }\n    local roman_string = ''\n    local remainder = number\n\
    \    for i = 1, #roman_numerals do\n        local numeral, value = unpack(roman_numerals[i])\n\
    \        local count = math.floor(remainder / value)\n        remainder = remainder\
    \ % value\n        if count == 4 then\n            if i == #roman_numerals then\n\
    \                roman_string = roman_string .. numeral .. 'v'\n            else\n\
    \                local next_numeral = roman_numerals[i + 1][1]\n             \
    \   roman_string = roman_string .. numeral .. next_numeral\n            end\n\
    \        else\n            roman_string = roman_string .. numeral:rep(count)\n\
    \        end\n    end\n    return roman_string\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7d00_hsx.lua:41:\
    \ expected: \"xix\"\\nactual: \"xviv\"\\nstack traceback:\\n\\t/tmp/tmp7d00_hsx.lua:41:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local roman_string\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        while number\
    \ >= numeral[1] do\n            roman_string = roman_string .. numeral[2]\n  \
    \          number = number - numeral[1]\n        end\n    end\n    return roman_string\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local num =\
    \ number\n    local digit = 0\n    while num > 0 do\n        local digit_value\
    \ = num % 10\n        local digit_numeral = ''\n        if digit_value == 4 then\n\
    \            digit_numeral = roman_numerals[digit + 1][1] .. roman_numerals[digit\
    \ + 1][2]\n        elseif digit_value == 9 then\n            digit_numeral = roman_numerals[digit\
    \ + 1][1] .. roman_numerals[digit + 2][1]\n        else\n            if digit_value\
    \ >= 5 then\n                digit_numeral = roman_numerals[digit + 1][2]\n  \
    \              digit_value = digit_value - 5\n            end\n            for\
    \ i = 1, digit_value do\n                digit_numeral = digit_numeral .. roman_numerals[digit\
    \ + 1][1]\n            end\n        end\n        result = digit_numeral .. result\n\
    \        num = math.floor(num / 10)\n        digit = digit + 1\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpbd3ydwo_.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpbd3ydwo_.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpbd3ydwo_.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local num = number\n  local numeral = {\n    {'m', 1000},\n\
    \    {'d', 500},\n    {'c', 100},\n    {'l', 50},\n    {'x', 10},\n    {'v', 5},\n\
    \    {'i', 1}\n  }\n  for i = 1, #numeral do\n    local letter, value = numeral[i][1],\
    \ numeral[i][2]\n    while num >= value do\n      roman = roman .. letter\n  \
    \    num = num - value\n    end\n  end\n  return roman\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpz71th1iv.lua:33:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmpz71th1iv.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, v in ipairs(roman_numerals) do\n        local value, roman\
    \ = v[1], v[2]\n        while number >= value do\n            result = result\
    \ .. roman\n            number = number - value\n        end\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local num = number\n  while num > 0 do\n    if num >= 1000\
    \ then\n      roman = roman .. 'm'\n      num = num - 1000\n    elseif num >=\
    \ 900 then\n      roman = roman .. 'cm'\n      num = num - 900\n    elseif num\
    \ >= 500 then\n      roman = roman .. 'd'\n      num = num - 500\n    elseif num\
    \ >= 400 then\n      roman = roman .. 'cd'\n      num = num - 400\n    elseif\
    \ num >= 100 then\n      roman = roman .. 'c'\n      num = num - 100\n    elseif\
    \ num >= 90 then\n      roman = roman .. 'xc'\n      num = num - 90\n    elseif\
    \ num >= 50 then\n      roman = roman .. 'l'\n      num = num - 50\n    elseif\
    \ num >= 40 then\n      roman = roman .. 'xl'\n      num = num - 40\n    elseif\
    \ num >= 10 then\n      roman = roman .. 'x'\n      num = num - 10\n    elseif\
    \ num >= 9 then\n      roman = roman .. 'ix'\n      num = num - 9\n    elseif\
    \ num >= 5 then\n      roman = roman .. 'v'\n      num = num - 5\n    elseif num\
    \ >= 4 then\n      roman = roman .. 'iv'\n      num = num - 4\n    elseif num\
    \ >= 1 then\n      roman = roman .. 'i'\n      num = num - 1\n    end\n  end\n\
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local num = number\n    while num > 0 do\n        if\
    \ num >= 1000 then\n            roman = roman .. 'm'\n            num = num -\
    \ 1000\n        elseif num >= 900 then\n            roman = roman .. 'cm'\n  \
    \          num = num - 900\n        elseif num >= 500 then\n            roman\
    \ = roman .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            roman = roman .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            roman = roman .. 'c'\n            num = num - 100\n\
    \        elseif num >= 90 then\n            roman = roman .. 'xc'\n          \
    \  num = num - 90\n        elseif num >= 50 then\n            roman = roman ..\
    \ 'l'\n            num = num - 50\n        elseif num >= 40 then\n           \
    \ roman = roman .. 'xl'\n            num = num - 40\n        elseif num >= 10\
    \ then\n            roman = roman .. 'x'\n            num = num - 10\n       \
    \ elseif num >= 9 then\n            roman = roman .. 'ix'\n            num = num\
    \ - 9\n        elseif num >= 5 then\n            roman = roman .. 'v'\n      \
    \      num = num - 5\n        elseif num >= 4 then\n            roman = roman\
    \ .. 'iv'\n            num = num - 4\n        elseif num >= 1 then\n         \
    \   roman = roman .. 'i'\n            num = num - 1\n        end\n    end\n  \
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp2de3l_q_.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp2de3l_q_.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp2de3l_q_.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpmipofnxu.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpmipofnxu.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpmipofnxu.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  assert(type(number) == 'number', 'number must be a number')\n  assert(number\
    \ >= 1 and number <= 1000, 'number must be between 1 and 1000')\n  local result\
    \ = ''\n  for i, v in ipairs(mini_roman_numerals) do\n    while number >= v[1]\
    \ do\n      result = result .. v[2]\n      number = number - v[1]\n    end\n \
    \ end\n  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpq55ovyn8.lua:12:\
    \ bad argument #1 to 'ipairs' (table expected, got nil)\\nstack traceback:\\n\\\
    t/tmp/tmpq55ovyn8.lua:12: in function 'candidate'\\n\\t/tmp/tmpq55ovyn8.lua:24:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local current_digit = number % 10\n  \
    \      local current_numeral = roman_numerals[digit]\n        if current_digit\
    \ == 0 then\n            digit = digit + 1\n        elseif current_digit == 4\
    \ then\n            result = current_numeral[1] .. current_numeral[2] .. result\n\
    \            digit = digit + 1\n        elseif current_digit == 9 then\n     \
    \       result = current_numeral[1] .. roman_numerals[digit + 1][1] .. result\n\
    \            digit = digit + 2\n        else\n            local numeral = current_numeral[1]\n\
    \            if current_digit >= 5 then\n                numeral = current_numeral[2]\n\
    \                current_digit = current_digit - 5\n            end\n        \
    \    result = numeral .. string.rep(current_numeral[1], current_digit) .. result\n\
    \            digit = digit + 1\n        end\n        number = math.floor(number\
    \ / 10)\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_asv14cs.lua:45:\
    \ expected: \"xix\"\\nactual: \"ccix\"\\nstack traceback:\\n\\t/tmp/tmp_asv14cs.lua:45:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = unpack(numeral)\n        while number >= value do\n            result\
    \ = result .. symbol\n            number = number - value\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpe6cpgxj1.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpe6cpgxj1.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpe6cpgxj1.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit\
    \ = 1\n    while number > 0 do\n        local digit_value = number % 10\n    \
    \    local digit_char = roman_numerals[digit][1]\n        if digit_value == 9\
    \ then\n            result = digit_char .. roman_numerals[digit + 1][1] .. result\n\
    \        elseif digit_value == 4 then\n            result = digit_char .. roman_numerals[digit][2]\
    \ .. result\n        else\n            local digit_5 = roman_numerals[digit][2]\
    \ or ''\n            result = digit_5:rep(digit_value // 5) .. digit_char:rep(digit_value\
    \ % 5) .. result\n        end\n        number = number // 10\n        digit =\
    \ digit + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: "b\"lua: /tmp/tmp7ed2er8b.lua:26: unexpected symbol near '/'\\n\""
  exit_code: 1
  status: SyntaxError
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, roman_numeral in ipairs(roman_numerals) do\n        local decimal,\
    \ numeral = unpack(roman_numeral)\n        while number >= decimal do\n      \
    \      result = result .. numeral\n            number = number - decimal\n   \
    \     end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numeral = ''\n    local numeral_map = {\n        {'m', 1000},\n\
    \        {'d', 500},\n        {'c', 100},\n        {'l', 50},\n        {'x', 10},\n\
    \        {'v', 5},\n        {'i', 1}\n    }\n    for i, numeral in ipairs(numeral_map)\
    \ do\n        local letter, value = numeral[1], numeral[2]\n        local count\
    \ = math.floor(number / value)\n        number = number % value\n        roman_numeral\
    \ = roman_numeral .. letter:rep(count)\n    end\n    return roman_numeral\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqrpr80ah.lua:31:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmpqrpr80ah.lua:31:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local roman_string = ''\n    local\
    \ digit = 0\n    while number > 0 do\n        local digit_value = number % 10\n\
    \        local digit_string = ''\n        if digit_value == 9 then\n         \
    \   digit_string = roman_numerals[digit + 1][1] .. roman_numerals[digit + 2][1]\n\
    \        elseif digit_value >= 5 then\n            digit_string = roman_numerals[digit\
    \ + 1][2]\n            for i = 1, digit_value - 5 do\n                digit_string\
    \ = digit_string .. roman_numerals[digit + 1][1]\n            end\n        elseif\
    \ digit_value == 4 then\n            digit_string = roman_numerals[digit + 1][1]\
    \ .. roman_numerals[digit + 1][2]\n        else\n            for i = 1, digit_value\
    \ do\n                digit_string = digit_string .. roman_numerals[digit + 1][1]\n\
    \            end\n        end\n        roman_string = digit_string .. roman_string\n\
    \        number = math.floor(number / 10)\n        digit = digit + 1\n    end\n\
    \    return roman_string\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local i = 1\n    while number > 0 do\n        local\
    \ digit = number % 10\n        if digit == 9 then\n            roman = mini_roman_numerals[i]\
    \ .. mini_roman_numerals[i + 1] .. roman\n        elseif digit == 4 then\n   \
    \         roman = mini_roman_numerals[i] .. mini_roman_numerals[i + 1] .. roman\n\
    \        else\n            if digit >= 5 then\n                roman = mini_roman_numerals[i\
    \ + 1] .. roman\n                digit = digit - 5\n            end\n        \
    \    for j = 1, digit do\n                roman = mini_roman_numerals[i] .. roman\n\
    \            end\n        end\n        number = (number - digit) / 10\n      \
    \  i = i + 2\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpswrrvb3v.lua:14:\
    \ attempt to index global 'mini_roman_numerals' (a nil value)\\nstack traceback:\\\
    n\\t/tmp/tmpswrrvb3v.lua:14: in function 'candidate'\\n\\t/tmp/tmpswrrvb3v.lua:35:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = table.unpack(pair)\n    while number >= arabic do\n\
    \      result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpd_pfzzep.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpd_pfzzep.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpd_pfzzep.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        { 1000, 'm' },\n        { 900, 'cm' },\n\
    \        { 500, 'd' },\n        { 400, 'cd' },\n        { 100, 'c' },\n      \
    \  { 90, 'xc' },\n        { 50, 'l' },\n        { 40, 'xl' },\n        { 10, 'x'\
    \ },\n        { 9, 'ix' },\n        { 5, 'v' },\n        { 4, 'iv' },\n      \
    \  { 1, 'i' },\n    }\n    local roman_numeral = ''\n    for _, pair in ipairs(roman_numerals)\
    \ do\n        local arabic, numeral = table.unpack(pair)\n        while number\
    \ >= arabic do\n            roman_numeral = roman_numeral .. numeral\n       \
    \     number = number - arabic\n        end\n    end\n    return roman_numeral\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpw9q2ogzu.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpw9q2ogzu.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpw9q2ogzu.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, v in ipairs(roman_numerals) do\n        local num, roman =\
    \ v[1], v[2]\n        while number >= num do\n            result = result .. roman\n\
    \            number = number - num\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = ''\n    local i = 1\n    while number > 0 do\n        local\
    \ digit = number % 10\n        if digit == 9 then\n            roman = mini_roman_digits[i][9]\
    \ .. roman\n        elseif digit == 4 then\n            roman = mini_roman_digits[i][4]\
    \ .. roman\n        else\n            if digit >= 5 then\n                roman\
    \ = mini_roman_digits[i][5] .. roman\n                digit = digit - 5\n    \
    \        end\n            roman = string.rep(mini_roman_digits[i][1], digit) ..\
    \ roman\n        end\n        number = math.floor(number / 10)\n        i = i\
    \ + 1\n    end\n    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp41di1gnm.lua:14:\
    \ attempt to index global 'mini_roman_digits' (a nil value)\\nstack traceback:\\\
    n\\t/tmp/tmp41di1gnm.lua:14: in function 'candidate'\\n\\t/tmp/tmp41di1gnm.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.002 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local num = number\n    while num >= 1000 do\n  \
    \      roman = roman .. \"m\"\n        num = num - 1000\n    end\n    while num\
    \ >= 900 do\n        roman = roman .. \"cm\"\n        num = num - 900\n    end\n\
    \    while num >= 500 do\n        roman = roman .. \"d\"\n        num = num -\
    \ 500\n    end\n    while num >= 400 do\n        roman = roman .. \"cd\"\n   \
    \     num = num - 400\n    end\n    while num >= 100 do\n        roman = roman\
    \ .. \"c\"\n        num = num - 100\n    end\n    while num >= 90 do\n       \
    \ roman = roman .. \"xc\"\n        num = num - 90\n    end\n    while num >= 50\
    \ do\n        roman = roman .. \"l\"\n        num = num - 50\n    end\n    while\
    \ num >= 40 do\n        roman = roman .. \"xl\"\n        num = num - 40\n    end\n\
    \    while num >= 10 do\n        roman = roman .. \"x\"\n        num = num - 10\n\
    \    end\n    while num >= 9 do\n        roman = roman .. \"ix\"\n        num\
    \ = num - 9\n    end\n    while num >= 5 do\n        roman = roman .. \"v\"\n\
    \        num = num - 5\n    end\n    while num >= 4 do\n        roman = roman\
    \ .. \"iv\"\n        num = num - 4\n    end\n    while num >= 1 do\n        roman\
    \ = roman .. \"i\"\n        num = num - 1\n    end\n    return roman\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numeral = \"\"\n    local roman_numerals = {\n        {1000,\
    \ \"m\"},\n        {900, \"cm\"},\n        {500, \"d\"},\n        {400, \"cd\"\
    },\n        {100, \"c\"},\n        {90, \"xc\"},\n        {50, \"l\"},\n     \
    \   {40, \"xl\"},\n        {10, \"x\"},\n        {9, \"ix\"},\n        {5, \"\
    v\"},\n        {4, \"iv\"},\n        {1, \"i\"}\n    }\n    for _, numeral in\
    \ ipairs(roman_numerals) do\n        while number >= numeral[1] do\n         \
    \   roman_numeral = roman_numeral .. numeral[2]\n            number = number -\
    \ numeral[1]\n        end\n    end\n    return roman_numeral\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    local i = 1\n    while num\
    \ > 0 do\n        local digit = num % 10\n        num = math.floor(num / 10)\n\
    \        local roman = ''\n        if digit == 9 then\n            roman = roman_numerals[i]\
    \ .. roman_numerals[i + 2]\n        elseif digit >= 5 then\n            roman\
    \ = roman_numerals[i + 1] .. string.rep(roman_numerals[i], digit - 5)\n      \
    \  elseif digit == 4 then\n            roman = roman_numerals[i] .. roman_numerals[i\
    \ + 1]\n        else\n            roman = string.rep(roman_numerals[i], digit)\n\
    \        end\n        result = roman .. result\n        i = i + 2\n    end\n \
    \   return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpu0ajekqt.lua:17:\
    \ attempt to index global 'roman_numerals' (a nil value)\\nstack traceback:\\\
    n\\t/tmp/tmpu0ajekqt.lua:17: in function 'candidate'\\n\\t/tmp/tmpu0ajekqt.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    local numeral_map = {\n  \
    \      {1000, 'm'},\n        {900, 'cm'},\n        {500, 'd'},\n        {400,\
    \ 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n        {50, 'l'},\n     \
    \   {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n        {5, 'v'},\n \
    \       {4, 'iv'},\n        {1, 'i'},\n    }\n    for _, pair in ipairs(numeral_map)\
    \ do\n        local value = pair[1]\n        local numeral = pair[2]\n       \
    \ while num >= value do\n            result = result .. numeral\n            num\
    \ = num - value\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local mini_roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n\
    \        {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local i\
    \ = 1\n    while number > 0 do\n        local digit = number % 10\n        if\
    \ digit > 0 then\n            local mini_roman_numeral = mini_roman_numerals[i]\n\
    \            if digit < 4 then\n                result = mini_roman_numeral[1]:rep(digit)\
    \ .. result\n            elseif digit == 4 then\n                result = mini_roman_numeral[1]\
    \ .. mini_roman_numeral[2] .. result\n            elseif digit < 9 then\n    \
    \            result = mini_roman_numeral[2] .. mini_roman_numeral[1]:rep(digit\
    \ - 5) .. result\n            else\n                result = mini_roman_numeral[1]\
    \ .. mini_roman_numerals[i + 1][1] .. result\n            end\n        end\n \
    \       number = math.floor(number / 10)\n        i = i + 1\n    end\n    return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit_index\
    \ = 1\n    while number > 0 do\n        local digit = number % 10\n        if\
    \ digit > 0 then\n            local roman_numeral = roman_numerals[digit_index]\n\
    \            if digit == 4 then\n                result = roman_numeral[1] ..\
    \ roman_numeral[2] .. result\n            elseif digit == 9 then\n           \
    \     result = roman_numeral[1] .. roman_numerals[digit_index + 1][1] .. result\n\
    \            else\n                local numeral = roman_numeral[2] or roman_numeral[1]\n\
    \                result = numeral:rep(digit) .. result\n            end\n    \
    \    end\n        number = math.floor(number / 10)\n        digit_index = digit_index\
    \ + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpc7so60h6.lua:39:\
    \ expected: \"xix\"\\nactual: \"lix\"\\nstack traceback:\\n\\t/tmp/tmpc7so60h6.lua:39:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    while num > 0 do\n       \
    \ if num >= 1000 then\n            result = result .. 'm'\n            num = num\
    \ - 1000\n        elseif num >= 900 then\n            result = result .. 'cm'\n\
    \            num = num - 900\n        elseif num >= 500 then\n            result\
    \ = result .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            result = result .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            result = result .. 'c'\n            num = num -\
    \ 100\n        elseif num >= 90 then\n            result = result .. 'xc'\n  \
    \          num = num - 90\n        elseif num >= 50 then\n            result =\
    \ result .. 'l'\n            num = num - 50\n        elseif num >= 40 then\n \
    \           result = result .. 'xl'\n            num = num - 40\n        elseif\
    \ num >= 10 then\n            result = result .. 'x'\n            num = num -\
    \ 10\n        elseif num >= 9 then\n            result = result .. 'ix'\n    \
    \        num = num - 9\n        elseif num >= 5 then\n            result = result\
    \ .. 'v'\n            num = num - 5\n        elseif num >= 4 then\n          \
    \  result = result .. 'iv'\n            num = num - 4\n        elseif num >= 1\
    \ then\n            result = result .. 'i'\n            num = num - 1\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local\
    \ letter, value = numeral[1], numeral[2]\n        while number >= value do\n \
    \           result = result .. letter\n            number = number - value\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'i', 'v'},\n        {'x', 'l'},\n    \
    \    {'c', 'd'},\n        {'m'}\n    }\n    local result = ''\n    local digit_index\
    \ = 1\n    while number > 0 do\n        local digit = number % 10\n        if\
    \ digit > 0 then\n            local roman_digit = roman_numerals[digit_index]\n\
    \            if digit <= 3 then\n                result = roman_digit[1]:rep(digit)\
    \ .. result\n            elseif digit == 4 then\n                result = roman_digit[1]\
    \ .. roman_digit[2] .. result\n            elseif digit == 5 then\n          \
    \      result = roman_digit[2] .. result\n            elseif digit <= 8 then\n\
    \                result = roman_digit[2] .. roman_digit[1]:rep(digit - 5) .. result\n\
    \            else\n                result = roman_digit[1] .. roman_numerals[digit_index\
    \ + 1][1] .. result\n            end\n        end\n        number = math.floor(number\
    \ / 10)\n        digit_index = digit_index + 1\n    end\n    return result\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for _, pair in ipairs(roman_numerals) do\n\
    \    local arabic, roman = pair[1], pair[2]\n    while number >= arabic do\n \
    \     result = result .. roman\n      number = number - arabic\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local result = ''\n  local num = number\n  local numeral_map = {\n    {1000,\
    \ 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n    {400, 'cd'},\n    {100, 'c'},\n\
    \    {90, 'xc'},\n    {50, 'l'},\n    {40, 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n\
    \    {5, 'v'},\n    {4, 'iv'},\n    {1, 'i'},\n  }\n  for _, numeral in ipairs(numeral_map)\
    \ do\n    local value, letter = numeral[1], numeral[2]\n    while num >= value\
    \ do\n      result = result .. letter\n      num = num - value\n    end\n  end\n\
    \  return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpjymthhiv.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpjymthhiv.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpjymthhiv.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmptu8duin6.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmptu8duin6.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmptu8duin6.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {'m', 1000},\n        {'cm', 900},\n  \
    \      {'d', 500},\n        {'cd', 400},\n        {'c', 100},\n        {'xc',\
    \ 90},\n        {'l', 50},\n        {'xl', 40},\n        {'x', 10},\n        {'ix',\
    \ 9},\n        {'v', 5},\n        {'iv', 4},\n        {'i', 1}\n    }\n    local\
    \ result = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local\
    \ letter, value = numeral[1], numeral[2]\n        while number >= value do\n \
    \           result = result .. letter\n            number = number - value\n \
    \       end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = pair[1], pair[2]\n        while number >= arabic do\n            result =\
    \ result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, v in ipairs(roman_numerals) do\n        while number >= v[1]\
    \ do\n            result = result .. v[2]\n            number = number - v[1]\n\
    \        end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    while num > 0 do\n       \
    \ if num >= 1000 then\n            result = result .. 'm'\n            num = num\
    \ - 1000\n        elseif num >= 900 then\n            result = result .. 'cm'\n\
    \            num = num - 900\n        elseif num >= 500 then\n            result\
    \ = result .. 'd'\n            num = num - 500\n        elseif num >= 400 then\n\
    \            result = result .. 'cd'\n            num = num - 400\n        elseif\
    \ num >= 100 then\n            result = result .. 'c'\n            num = num -\
    \ 100\n        elseif num >= 90 then\n            result = result .. 'xc'\n  \
    \          num = num - 90\n        elseif num >= 50 then\n            result =\
    \ result .. 'l'\n            num = num - 50\n        elseif num >= 40 then\n \
    \           result = result .. 'xl'\n            num = num - 40\n        elseif\
    \ num >= 10 then\n            result = result .. 'x'\n            num = num -\
    \ 10\n        elseif num >= 9 then\n            result = result .. 'ix'\n    \
    \        num = num - 9\n        elseif num >= 5 then\n            result = result\
    \ .. 'v'\n            num = num - 5\n        elseif num >= 4 then\n          \
    \  result = result .. 'iv'\n            num = num - 4\n        elseif num >= 1\
    \ then\n            result = result .. 'i'\n            num = num - 1\n      \
    \  end\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ letter = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. letter\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp6hcb124b.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp6hcb124b.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp6hcb124b.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local num = number\n    local numeral_map = {\n  \
    \      {'m', 1000},\n        {'d', 500},\n        {'c', 100},\n        {'l', 50},\n\
    \        {'x', 10},\n        {'v', 5},\n        {'i', 1}\n    }\n    for _, numeral\
    \ in ipairs(numeral_map) do\n        local letter, value = numeral[1], numeral[2]\n\
    \        while num >= value do\n            result = result .. letter\n      \
    \      num = num - value\n        end\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmprngl4v84.lua:33:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmprngl4v84.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, numeral in ipairs(roman_numerals) do\n        local value,\
    \ symbol = numeral[1], numeral[2]\n        while number >= value do\n        \
    \    result = result .. symbol\n            number = number - value\n        end\n\
    \    end\n    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        [1] = 'i',\n        [5] = 'v',\n      \
    \  [10] = 'x',\n        [50] = 'l',\n        [100] = 'c',\n        [500] = 'd',\n\
    \        [1000] = 'm',\n    }\n    local result = ''\n    local num = number\n\
    \    local digit = 1\n    while num > 0 do\n        local digit_value = num %\
    \ 10\n        if digit_value == 9 then\n            result = roman_numerals[digit]\
    \ .. roman_numerals[digit * 10] .. result\n        elseif digit_value >= 5 then\n\
    \            result = roman_numerals[5 * digit] .. string.rep(roman_numerals[digit],\
    \ digit_value - 5) .. result\n        elseif digit_value == 4 then\n         \
    \   result = roman_numerals[digit] .. roman_numerals[5 * digit] .. result\n  \
    \      else\n            result = string.rep(roman_numerals[digit], digit_value)\
    \ .. result\n        end\n        num = math.floor(num / 10)\n        digit =\
    \ digit * 10\n    end\n    return result\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman = \"\"\n    local digits = {1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1}\n    local romans = {\"m\", \"cm\", \"d\", \"cd\", \"c\"\
    , \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"}\n    for i = 1,\
    \ #digits do\n        while number >= digits[i] do\n            number = number\
    \ - digits[i]\n            roman = roman .. romans[i]\n        end\n    end\n\
    \    return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for _, pair in ipairs(roman_numerals) do\n        local arabic, roman\
    \ = table.unpack(pair)\n        while number >= arabic do\n            result\
    \ = result .. roman\n            number = number - arabic\n        end\n    end\n\
    \    return result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n\
    \    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmp3cgtnvsa.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmp3cgtnvsa.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmp3cgtnvsa.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman = ''\n  local num = number\n  while num > 0 do\n    if num >= 1000\
    \ then\n      roman = roman .. 'm'\n      num = num - 1000\n    elseif num >=\
    \ 900 then\n      roman = roman .. 'cm'\n      num = num - 900\n    elseif num\
    \ >= 500 then\n      roman = roman .. 'd'\n      num = num - 500\n    elseif num\
    \ >= 400 then\n      roman = roman .. 'cd'\n      num = num - 400\n    elseif\
    \ num >= 100 then\n      roman = roman .. 'c'\n      num = num - 100\n    elseif\
    \ num >= 90 then\n      roman = roman .. 'xc'\n      num = num - 90\n    elseif\
    \ num >= 50 then\n      roman = roman .. 'l'\n      num = num - 50\n    elseif\
    \ num >= 40 then\n      roman = roman .. 'xl'\n      num = num - 40\n    elseif\
    \ num >= 10 then\n      roman = roman .. 'x'\n      num = num - 10\n    elseif\
    \ num >= 9 then\n      roman = roman .. 'ix'\n      num = num - 9\n    elseif\
    \ num >= 5 then\n      roman = roman .. 'v'\n      num = num - 5\n    elseif num\
    \ >= 4 then\n      roman = roman .. 'iv'\n      num = num - 4\n    elseif num\
    \ >= 1 then\n      roman = roman .. 'i'\n      num = num - 1\n    end\n  end\n\
    \  return roman\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n \
    \   lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local numeral_table = {\n        {'m', 1000},\n  \
    \      {'d', 500},\n        {'c', 100},\n        {'l', 50},\n        {'x', 10},\n\
    \        {'v', 5},\n        {'i', 1}\n    }\n    for _, numeral in ipairs(numeral_table)\
    \ do\n        local numeral_string, value = numeral[1], numeral[2]\n        while\
    \ number >= value do\n            result = result .. numeral_string\n        \
    \    number = number - value\n        end\n    end\n    return result\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7ae0i3k6.lua:32:\
    \ expected: \"xix\"\\nactual: \"xviiii\"\\nstack traceback:\\n\\t/tmp/tmp7ae0i3k6.lua:32:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local roman_numerals = {\n        {1000, 'm'},\n        {900, 'cm'},\n  \
    \      {500, 'd'},\n        {400, 'cd'},\n        {100, 'c'},\n        {90, 'xc'},\n\
    \        {50, 'l'},\n        {40, 'xl'},\n        {10, 'x'},\n        {9, 'ix'},\n\
    \        {5, 'v'},\n        {4, 'iv'},\n        {1, 'i'}\n    }\n    local result\
    \ = ''\n    for i = 1, #roman_numerals do\n        local arabic, roman = table.unpack(roman_numerals[i])\n\
    \        while number >= arabic do\n            result = result .. roman\n   \
    \         number = number - arabic\n        end\n    end\n    return result\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n\
    \    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nTests with errors:\\n------------------\\n1) test_humaneval\\n/tmp/tmpcf5z24bi.lua:26:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpcf5z24bi.lua:26:\
    \ in function 'candidate'\\n\\t/tmp/tmpcf5z24bi.lua:38: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.001 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \  local roman_numerals = {\n    {1000, 'm'},\n    {900, 'cm'},\n    {500, 'd'},\n\
    \    {400, 'cd'},\n    {100, 'c'},\n    {90, 'xc'},\n    {50, 'l'},\n    {40,\
    \ 'xl'},\n    {10, 'x'},\n    {9, 'ix'},\n    {5, 'v'},\n    {4, 'iv'},\n    {1,\
    \ 'i'}\n  }\n  local result = ''\n  for i = 1, #roman_numerals do\n    local arabic,\
    \ roman = unpack(roman_numerals[i])\n    while number >= arabic do\n      result\
    \ = result .. roman\n      number = number - arabic\n    end\n  end\n  return\
    \ result\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = int_to_mini_roman\n    lu.assertEquals(candidate(19), 'xix')\n    lu.assertEquals(candidate(152),\
    \ 'clii')\n    lu.assertEquals(candidate(251), 'ccli')\n    lu.assertEquals(candidate(426),\
    \ 'cdxxvi')\n    lu.assertEquals(candidate(500), 'd')\n    lu.assertEquals(candidate(1),\
    \ 'i')\n    lu.assertEquals(candidate(4), 'iv')\n    lu.assertEquals(candidate(43),\
    \ 'xliii')\n    lu.assertEquals(candidate(90), 'xc')\n    lu.assertEquals(candidate(94),\
    \ 'xciv')\n    lu.assertEquals(candidate(532), 'dxxxii')\n    lu.assertEquals(candidate(900),\
    \ 'cm')\n    lu.assertEquals(candidate(994), 'cmxciv')\n    lu.assertEquals(candidate(1000),\
    \ 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Given a positive integer, obtain its roman numeral equivalent as a\
    \ string,\n-- and return it in lowercase.\n-- Restrictions: 1 <= num <= 1000\n\
    -- Examples:\n-- >>> int_to_mini_roman(19) == 'xix'\n-- >>> int_to_mini_roman(152)\
    \ == 'clii'\n-- >>> int_to_mini_roman(426) == 'cdxxvi'\nlocal function int_to_mini_roman(number)\n\
    \    local result = ''\n    local numeral_map = {\n        {'i', 'v'},\n     \
    \   {'x', 'l'},\n        {'c', 'd'},\n        {'m', 'v'}\n    }\n    local numeral_index\
    \ = 1\n    while number > 0 do\n        local digit = number % 10\n        if\
    \ digit == 4 then\n            result = numeral_map[numeral_index][1] .. numeral_map[numeral_index][2]\
    \ .. result\n        elseif digit == 9 then\n            result = numeral_map[numeral_index][1]\
    \ .. numeral_map[numeral_index + 1][1] .. result\n        else\n            local\
    \ numeral = ''\n            if digit >= 5 then\n                numeral = numeral_map[numeral_index][2]\n\
    \                digit = digit - 5\n            end\n            numeral = numeral\
    \ .. string.rep(numeral_map[numeral_index][1], digit)\n            result = numeral\
    \ .. result\n        end\n        number = math.floor(number / 10)\n        numeral_index\
    \ = numeral_index + 1\n    end\n    return result\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = int_to_mini_roman\n    lu.assertEquals(candidate(19),\
    \ 'xix')\n    lu.assertEquals(candidate(152), 'clii')\n    lu.assertEquals(candidate(251),\
    \ 'ccli')\n    lu.assertEquals(candidate(426), 'cdxxvi')\n    lu.assertEquals(candidate(500),\
    \ 'd')\n    lu.assertEquals(candidate(1), 'i')\n    lu.assertEquals(candidate(4),\
    \ 'iv')\n    lu.assertEquals(candidate(43), 'xliii')\n    lu.assertEquals(candidate(90),\
    \ 'xc')\n    lu.assertEquals(candidate(94), 'xciv')\n    lu.assertEquals(candidate(532),\
    \ 'dxxxii')\n    lu.assertEquals(candidate(900), 'cm')\n    lu.assertEquals(candidate(994),\
    \ 'cmxciv')\n    lu.assertEquals(candidate(1000), 'm')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
