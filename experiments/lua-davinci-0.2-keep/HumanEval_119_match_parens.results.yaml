name: HumanEval_119_match_parens
language: lua
results:
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjv87t8l6.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjv87t8l6.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local cnt = 0\n    for i = 1, #s do\n \
    \     if s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt\
    \ = cnt - 1\n      end\n      if cnt < 0 then\n        return -1\n      end\n\
    \    end\n    return cnt\n  end\n  local cnt1 = count_parens(lst[1])\n  local\
    \ cnt2 = count_parens(lst[2])\n  if cnt1 < 0 or cnt2 < 0 then\n    return 'No'\n\
    \  end\n  if cnt1 == cnt2 then\n    return 'Yes'\n  end\n  return 'No'\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpc7uwsacc.lua:41:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpc7uwsacc.lua:41:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for c in s:gmatch('.') do\n\
    \      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return (is_good(s1\
    \ .. s2) or is_good(s2 .. s1)) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6d6ve268.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp6d6ve268.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9g6yh1a8.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp9g6yh1a8.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpl0_dea1z.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpl0_dea1z.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmcx056kf.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpmcx056kf.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6b3hr1zl.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp6b3hr1zl.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function balanced(s)\n    local count = 0\n    for i = 1, #s do\n   \
    \   if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n      \
    \  count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return balanced(s1 .. s2) or balanced(s2 .. s1) and 'Yes' or 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpm09yfxmr.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpm09yfxmr.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local cnt = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return 'No'\n    end\n  end\n  return cnt == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpi8y5a8_n.lua:34:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpi8y5a8_n.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpnj_8nony.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpnj_8nony.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpppt28xw9.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpppt28xw9.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp27za7zh0.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp27za7zh0.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6ghlt91x.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp6ghlt91x.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5n2qa4ly.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp5n2qa4ly.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3in0e8x5.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp3in0e8x5.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptrfz9jqa.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmptrfz9jqa.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfthhw_cf.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpfthhw_cf.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local cnt = 0\n    for i = 1, #s do\n  \
    \      if s:sub(i, i) == '(' then\n            cnt = cnt + 1\n        else\n \
    \           cnt = cnt - 1\n        end\n        if cnt < 0 then\n            return\
    \ 'No'\n        end\n    end\n    return cnt == 0 and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpiw5if9_t.lua:34:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpiw5if9_t.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local cnt = 0\n    for _, s in ipairs(lst) do\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return 'No'\n            end\n        end\n    end\n\
    \    return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpaimldoum.lua:35:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpaimldoum.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr3qynfn3.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpr3qynfn3.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function helper(s)\n    local count = 0\n    for i = 1, #s do\n     \
    \ if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return (helper(s1 .. s2) or helper(s2 .. s1)) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3efubpjv.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp3efubpjv.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptnn5zx3g.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmptnn5zx3g.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpm0kgfqnr.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpm0kgfqnr.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpkmg__kq4.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpkmg__kq4.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpayxt2lvh.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpayxt2lvh.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  local c = s:sub(i, i)\n      if c == '(' then\n        count = count + 1\n\
    \      else\n        count = count - 1\n      end\n      if count < 0 then\n \
    \       return false\n      end\n    end\n    return count == 0\n  end\n  local\
    \ s1, s2 = lst[1], lst[2]\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1ul9aelt.lua:35:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp1ul9aelt.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local stack = {}\n    for i = 1, #str do\n\
    \      local c = str:sub(i, i)\n      if c == '(' then\n        table.insert(stack,\
    \ c)\n      else\n        if #stack == 0 then\n          return false\n      \
    \  end\n        table.remove(stack)\n      end\n    end\n    return #stack ==\
    \ 0\n  end\n  local function dfs(lst, cur)\n    if #lst == 0 then\n      return\
    \ is_good(cur)\n    end\n    local a, b = lst[1], lst[2]\n    return dfs(table.slice(lst,\
    \ 2), cur .. a) or\n           dfs(table.slice(lst, 2), cur .. b)\n  end\n  return\
    \ dfs(lst, '') and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpxvjeoz4r.lua:33:\
    \ attempt to call field 'slice' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpxvjeoz4r.lua:36:\
    \ in function 'candidate'\\n\\t/tmp/tmpxvjeoz4r.lua:42: in function 'test_humaneval'\\\
    n\\nRan 1 tests in 0.000 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp53zdp6_k.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp53zdp6_k.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpewgsq0y6.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpewgsq0y6.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local cnt = 0\n    for _, s in ipairs(lst) do\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return 'No'\n            end\n        end\n    end\n\
    \    return cnt == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf7npaxkh.lua:35:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpf7npaxkh.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvqzdcz7q.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpvqzdcz7q.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    return is_good(lst[1] .. lst[2]) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpffjeir9t.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpffjeir9t.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1],\
    \ lst[2]\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3dvilo2u.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp3dvilo2u.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjfq59jkn.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjfq59jkn.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpnoegboal.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpnoegboal.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppr6xj222.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmppr6xj222.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpj18qyra4.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpj18qyra4.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpbn088bn5.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpbn088bn5.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3hwe8wvh.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp3hwe8wvh.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local cnt = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt =\
    \ cnt - 1\n      end\n    end\n    return cnt\n  end\n  local cnt1, cnt2 = count_parens(lst[1]),\
    \ count_parens(lst[2])\n  if cnt1 == 0 and cnt2 == 0 then\n    return 'Yes'\n\
    \  elseif cnt1 == 0 and cnt2 < 0 then\n    return 'Yes'\n  elseif cnt1 > 0 and\
    \ cnt2 == 0 then\n    return 'Yes'\n  elseif cnt1 < 0 and cnt2 == 0 then\n   \
    \ return 'Yes'\n  elseif cnt1 > 0 and cnt2 < 0 and cnt1 + cnt2 == 0 then\n   \
    \ return 'Yes'\n  elseif cnt1 < 0 and cnt2 > 0 and cnt1 + cnt2 == 0 then\n   \
    \ return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfdb3kcbe.lua:50:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpfdb3kcbe.lua:50:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmoo0kz9o.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpmoo0kz9o.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for c in str:gmatch('%(')\
    \ do\n      count = count + 1\n    end\n    for c in str:gmatch('%)') do\n   \
    \   count = count - 1\n    end\n    return count == 0\n  end\n  return is_good(lst[1]\
    \ .. lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe4u5h41_.lua:38:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpe4u5h41_.lua:38:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdr6o115z.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpdr6o115z.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2uoc1t_1.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp2uoc1t_1.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppkz2ey9_.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmppkz2ey9_.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr8vxzo56.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpr8vxzo56.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s = table.concat(lst)\n  local cnt = 0\n  for i = 1, #s do\n    if s:sub(i,\
    \ i) == '(' then\n      cnt = cnt + 1\n    else\n      cnt = cnt - 1\n    end\n\
    \    if cnt < 0 then\n      return 'No'\n    end\n  end\n  return cnt == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpt73alod7.lua:34:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpt73alod7.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp__q0fbac.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp__q0fbac.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgoljk4fk.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpgoljk4fk.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2wk6_409.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp2wk6_409.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return check(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmzmb_8z4.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpmzmb_8z4.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpj_fme43o.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpj_fme43o.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  if is_good(lst[1]) and is_good(lst[2]) then\n\
    \    return 'Yes'\n  end\n  if is_good(lst[1] .. lst[2]) then\n    return 'Yes'\n\
    \  end\n  if is_good(lst[2] .. lst[1]) then\n    return 'Yes'\n  end\n  return\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpibov20iq.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpibov20iq.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7qssqts3.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp7qssqts3.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpihe2m8fe.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpihe2m8fe.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgcw25a_z.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpgcw25a_z.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpa1c_khjb.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpa1c_khjb.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpibk7rv7h.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpibk7rv7h.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return\
    \ is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpla_k2egl.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpla_k2egl.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6tsqymbr.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp6tsqymbr.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(str)\n        local count = 0\n        for i = 1,\
    \ #str do\n            if str:sub(i, i) == '(' then\n                count = count\
    \ + 1\n            else\n                count = count - 1\n            end\n\
    \            if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplnd1auyq.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmplnd1auyq.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    if is_good(lst[1]) and is_good(lst[2]) then\n\
    \        return 'Yes'\n    end\n    if is_good(lst[1] .. lst[2]) then\n      \
    \  return 'Yes'\n    end\n    if is_good(lst[2] .. lst[1]) then\n        return\
    \ 'Yes'\n    end\n    return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppnznuuul.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmppnznuuul.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpuo51dk2m.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpuo51dk2m.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(str)\n        local count = 0\n        for i = 1,\
    \ #str do\n            if str:sub(i, i) == '(' then\n                count = count\
    \ + 1\n            else\n                count = count - 1\n            end\n\
    \            if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    local str1, str2 = lst[1],\
    \ lst[2]\n    return is_good(str1 .. str2) or is_good(str2 .. str1) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppepl5qno.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmppepl5qno.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgjfwpxdx.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpgjfwpxdx.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp517qx8la.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp517qx8la.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5vvljgq4.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp5vvljgq4.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp34hoo8fi.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp34hoo8fi.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjton8x12.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjton8x12.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjhwh1s5l.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjhwh1s5l.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp___jp1gi.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp___jp1gi.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 == 0 and c2 ~= 0 then\n        return 'No'\n\
    \    elseif c1 ~= 0 and c2 == 0 then\n        return 'No'\n    elseif c1 > 0 and\
    \ c2 < 0 then\n        return 'Yes'\n    elseif c1 < 0 and c2 > 0 then\n     \
    \   return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpa_t_eycv.lua:49:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpa_t_eycv.lua:49:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyah0923a.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpyah0923a.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6r90dvai.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp6r90dvai.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function count_parens(s)\n    local c = 0\n    for i = 1, #s do\n   \
    \   if s:sub(i, i) == '(' then\n        c = c + 1\n      else\n        c = c -\
    \ 1\n      end\n      if c < 0 then\n        return false\n      end\n    end\n\
    \    return c == 0\n  end\n  return count_parens(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpir6v77mn.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpir6v77mn.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphkidwprm.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmphkidwprm.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return check(s1\
    \ .. s2) or check(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpli2db_iq.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpli2db_iq.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvrc962ug.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpvrc962ug.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmuzy9331.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpmuzy9331.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local str = lst[1]\
    \ .. lst[2]\n  return is_good(str) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5c_6mapf.lua:37:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp5c_6mapf.lua:37:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpv1qieigi.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpv1qieigi.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n\
    \    return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjf32d8ek.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpjf32d8ek.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdfmg7jq9.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpdfmg7jq9.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpm6cr6ikj.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpm6cr6ikj.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local s1, s2 = lst[1], lst[2]\n  local c1, c2 = 0, 0\n  for i = 1, #s1 do\n\
    \    if s1:sub(i, i) == '(' then\n      c1 = c1 + 1\n    else\n      c1 = c1 -\
    \ 1\n    end\n  end\n  for i = 1, #s2 do\n    if s2:sub(i, i) == '(' then\n  \
    \    c2 = c2 + 1\n    else\n      c2 = c2 - 1\n    end\n  end\n  if c1 == 0 and\
    \ c2 == 0 then\n    return 'Yes'\n  elseif c1 == 0 and c2 < 0 then\n    return\
    \ 'Yes'\n  elseif c1 < 0 and c2 == 0 then\n    return 'Yes'\n  elseif c1 < 0 and\
    \ c2 < 0 then\n    return 'Yes'\n  else\n    return 'No'\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpbo00804_.lua:45:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpbo00804_.lua:45:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      local\
    \ c = s:sub(i, i)\n      if c == '(' then\n        cnt = cnt + 1\n      else\n\
    \        cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n\
    \      end\n    end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp44gu2xeg.lua:35:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp44gu2xeg.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmprvsiroji.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmprvsiroji.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvtnx59yn.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpvtnx59yn.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpu27huh_x.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpu27huh_x.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local n = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        n = n + 1\n      else\n        n = n - 1\n\
    \      end\n      if n < 0 then\n        return false\n      end\n    end\n  \
    \  return n == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpz_zi3qc3.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpz_zi3qc3.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmproq0oe6j.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmproq0oe6j.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 > 0 and c2 < 0 and c1 + c2 == 0 then\n    \
    \    return 'Yes'\n    elseif c1 < 0 and c2 > 0 and c1 + c2 == 0 then\n      \
    \  return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpchw09mh4.lua:52:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpchw09mh4.lua:52:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function count_parens(s)\n        local cnt = 0\n        for i = 1,\
    \ #s do\n            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n\
    \            else\n                cnt = cnt - 1\n            end\n        end\n\
    \        return cnt\n    end\n    local s1, s2 = lst[1], lst[2]\n    local cnt1,\
    \ cnt2 = count_parens(s1), count_parens(s2)\n    if cnt1 == 0 and cnt2 == 0 then\n\
    \        return 'Yes'\n    elseif cnt1 == 0 and cnt2 ~= 0 then\n        return\
    \ 'No'\n    elseif cnt1 ~= 0 and cnt2 == 0 then\n        return 'No'\n    elseif\
    \ cnt1 > 0 and cnt2 > 0 then\n        return 'No'\n    elseif cnt1 < 0 and cnt2\
    \ < 0 then\n        return 'No'\n    else\n        return 'Yes'\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpk6raps_1.lua:46:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpk6raps_1.lua:46:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp68prds20.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp68prds20.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpx5mxou_m.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpx5mxou_m.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 == 0 and c2 < 0 then\n        return 'Yes'\n\
    \    elseif c1 < 0 and c2 == 0 then\n        return 'Yes'\n    elseif c1 < 0 and\
    \ c2 < 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmxnqqwgb.lua:45:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpmxnqqwgb.lua:45:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpg88v581s.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpg88v581s.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjfznlw90.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpjfznlw90.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(str)\n        local cnt = 0\n        for i = 1, #str\
    \ do\n            if str:sub(i, i) == '(' then\n                cnt = cnt + 1\n\
    \            else\n                cnt = cnt - 1\n            end\n          \
    \  if cnt < 0 then\n                return false\n            end\n        end\n\
    \        return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return\
    \ is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpzu3den0o.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpzu3den0o.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplz226ovk.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmplz226ovk.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function count_parens(s)\n        local count = 0\n        for c in\
    \ s:gmatch('.') do\n            if c == '(' then\n                count = count\
    \ + 1\n            else\n                count = count - 1\n            end\n\
    \        end\n        return count\n    end\n    local count1 = count_parens(lst[1])\n\
    \    local count2 = count_parens(lst[2])\n    if count1 == 0 and count2 == 0 then\n\
    \        return 'Yes'\n    elseif count1 == 0 or count2 == 0 then\n        return\
    \ 'No'\n    elseif count1 == count2 then\n        return 'Yes'\n    else\n   \
    \     return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjdpf9a1y.lua:40:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjdpf9a1y.lua:40:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpblu5leya.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpblu5leya.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpwwgu58_g.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpwwgu58_g.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpojk1ildb.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpojk1ildb.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpldakt3fh.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpldakt3fh.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpq98p3b7x.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpq98p3b7x.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmqrg7ooh.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpmqrg7ooh.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2x0etc49.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp2x0etc49.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function balance(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return balance(s1\
    \ .. s2) or balance(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpeqdesxuz.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpeqdesxuz.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpg3g1ojnw.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpg3g1ojnw.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7ja92mmz.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp7ja92mmz.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpugke0wuw.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpugke0wuw.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8bh8f4ea.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp8bh8f4ea.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    return is_good(lst[1] .. lst[2]) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmprdn1ycoh.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmprdn1ycoh.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n\
    \    return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyxkml4ji.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpyxkml4ji.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function _match_parens(lst, acc)\n    if #lst == 0 then\n      return\
    \ acc == 0 and 'Yes' or 'No'\n    end\n    local s = lst[1]\n    local n = #s\n\
    \    for i = 1, n do\n      local c = s:sub(i, i)\n      if c == '(' then\n  \
    \      acc = acc + 1\n      else\n        acc = acc - 1\n      end\n      if acc\
    \ < 0 then\n        return 'No'\n      end\n    end\n    return _match_parens({table.unpack(lst,\
    \ 2)}, acc)\n  end\n  return _match_parens(lst, 0)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7t78xyme.lua:30:\
    \ attempt to call field 'unpack' (a nil value)\\nstack traceback:\\n\\t(tail call):\
    \ ?\\n\\t/tmp/tmp7t78xyme.lua:38: in function 'test_humaneval'\\n\\nRan 1 tests\
    \ in 0.000 seconds, 0 successes, 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9n9x9odc.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp9n9x9odc.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local cnt = 0\n    for i = 1, #s do\n  \
    \      if s:sub(i, i) == '(' then\n            cnt = cnt + 1\n        else\n \
    \           cnt = cnt - 1\n        end\n        if cnt < 0 then\n            return\
    \ 'No'\n        end\n    end\n    return cnt == 0 and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgid9ypa1.lua:34:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpgid9ypa1.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function check(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (check(lst[1]) and check(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplu57miov.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmplu57miov.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpft9kjs37.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpft9kjs37.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2qnhsthc.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp2qnhsthc.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    if is_good(s1)\
    \ then\n        return 'Yes'\n    end\n    if is_good(s2) then\n        return\
    \ 'Yes'\n    end\n    if is_good(s1 .. s2) then\n        return 'Yes'\n    end\n\
    \    if is_good(s2 .. s1) then\n        return 'Yes'\n    end\n    return 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpv2qqvacd.lua:51:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpv2qqvacd.lua:51:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1],\
    \ lst[2]\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqxnpjqca.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpqxnpjqca.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpv_nxyoqt.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpv_nxyoqt.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6cz9v8uc.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp6cz9v8uc.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpbml2p93p.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpbml2p93p.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjzi9h0c1.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpjzi9h0c1.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjz_ug_yl.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjz_ug_yl.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpxhgmg2oe.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpxhgmg2oe.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpft4lo7bm.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpft4lo7bm.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2gctr3xx.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp2gctr3xx.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local c = 0\n    for i = 1, #s do\n    \
    \    if s:sub(i, i) == '(' then\n            c = c + 1\n        else\n       \
    \     c = c - 1\n        end\n        if c < 0 then\n            return 'No'\n\
    \        end\n    end\n    return c == 0 and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsd9xu9wz.lua:34:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpsd9xu9wz.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpwqzfkr5_.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpwqzfkr5_.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5ocabyxe.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp5ocabyxe.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9oxszus7.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp9oxszus7.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpk_um1n_q.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpk_um1n_q.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function check_parens(str)\n    local count = 0\n    for i = 1, #str\
    \ do\n      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n\
    \        count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1],\
    \ lst[2]\n  return check_parens(s1 .. s2) or check_parens(s2 .. s1) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp96op20yj.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp96op20yj.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpix1axvq_.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpix1axvq_.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp36k6261u.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp36k6261u.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9tf5nzde.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp9tf5nzde.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpm8rb50ij.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpm8rb50ij.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      local c = str:sub(i, i)\n      if c == '(' then\n        count = count\
    \ + 1\n      else\n        count = count - 1\n      end\n      if count < 0 then\n\
    \        return false\n      end\n    end\n    return count == 0\n  end\n  local\
    \ s1, s2 = lst[1], lst[2]\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvpjho_uk.lua:35:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpvpjho_uk.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpemu8x3_2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpemu8x3_2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for c in s:gmatch('.') do\n\
    \      if c == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp66vde4vn.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp66vde4vn.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s = table.concat(lst)\n    local cnt = 0\n    for i = 1, #s do\n  \
    \      local c = s:sub(i, i)\n        if c == '(' then\n            cnt = cnt\
    \ + 1\n        else\n            cnt = cnt - 1\n        end\n        if cnt <\
    \ 0 then\n            return 'No'\n        end\n    end\n    return cnt == 0 and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpacjivqf_.lua:35:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpacjivqf_.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return\
    \ is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7v0n91x_.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp7v0n91x_.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpc6ru59mr.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpc6ru59mr.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open = 0\n    local close = 0\n    for _, v in ipairs(lst) do\n   \
    \     for _, c in ipairs(v:split()) do\n            if c == '(' then\n       \
    \         open = open + 1\n            else\n                close = close + 1\n\
    \            end\n        end\n    end\n    if open == close then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"E\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpnp8gxsqo.lua:16:\
    \ attempt to call method 'split' (a nil value)\\nstack traceback:\\n\\t/tmp/tmpnp8gxsqo.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 error\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9frn239x.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp9frn239x.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpnkxyrea4.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpnkxyrea4.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpv5kwcwyi.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpv5kwcwyi.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjucz_g4s.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpjucz_g4s.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpysm02mdj.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpysm02mdj.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpo68syruj.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpo68syruj.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2pk3_9r_.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp2pk3_9r_.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local balance = 0\n    for i = 1, #str do\n\
    \      local c = str:sub(i, i)\n      if c == '(' then\n        balance = balance\
    \ + 1\n      else\n        balance = balance - 1\n      end\n      if balance\
    \ < 0 then\n        return false\n      end\n    end\n    return balance == 0\n\
    \  end\n  local s1, s2 = lst[1], lst[2]\n  return is_good(s1 .. s2) or is_good(s2\
    \ .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8dmq8fd9.lua:35:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp8dmq8fd9.lua:35:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for c in s:gmatch('.')\
    \ do\n      if c == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplt1tjxe2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmplt1tjxe2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp371vb_j9.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp371vb_j9.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local left, right = 0, 0\n    for _, s in ipairs(lst) do\n        for c in\
    \ s:gmatch('.') do\n            if c == '(' then\n                left = left\
    \ + 1\n            else\n                right = right + 1\n            end\n\
    \        end\n    end\n    return left == right and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyfk87bod.lua:38:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmpyfk87bod.lua:38:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp646tmxtc.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp646tmxtc.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn1we6ewp.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpn1we6ewp.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphdks2qjy.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmphdks2qjy.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local count = 0\n    for i = 1, #str do\n\
    \      if str:sub(i, i) == '(' then\n        count = count + 1\n      else\n \
    \       count = count - 1\n      end\n      if count < 0 then\n        return\
    \ false\n      end\n    end\n    return count == 0\n  end\n  local str1, str2\
    \ = lst[1], lst[2]\n  return is_good(str1 .. str2) or is_good(str2 .. str1) and\
    \ 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_vr1xe3h.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp_vr1xe3h.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpnkjogqqd.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpnkjogqqd.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function count_parens(s)\n        local cnt = 0\n        for i = 1,\
    \ #s do\n            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n\
    \            else\n                cnt = cnt - 1\n            end\n        end\n\
    \        return cnt\n    end\n    local cnt1, cnt2 = count_parens(lst[1]), count_parens(lst[2])\n\
    \    if cnt1 == 0 and cnt2 == 0 then\n        return 'Yes'\n    elseif cnt1 ==\
    \ 0 and cnt2 > 0 then\n        return 'No'\n    elseif cnt1 > 0 and cnt2 == 0\
    \ then\n        return 'No'\n    elseif cnt1 > 0 and cnt2 > 0 then\n        return\
    \ 'Yes'\n    elseif cnt1 < 0 and cnt2 < 0 then\n        return 'Yes'\n    elseif\
    \ cnt1 < 0 and cnt2 > 0 then\n        return 'No'\n    elseif cnt1 > 0 and cnt2\
    \ < 0 then\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpa81s2hol.lua:45:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpa81s2hol.lua:45:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpttuj4csm.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpttuj4csm.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for c in s:gmatch('.')\
    \ do\n            if c == '(' then\n                count = count + 1\n      \
    \      else\n                count = count - 1\n            end\n            if\
    \ count < 0 then\n                return false\n            end\n        end\n\
    \        return count == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return\
    \ (is_good(s1 .. s2) or is_good(s2 .. s1)) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyvg567bj.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpyvg567bj.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpw51cp2b1.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpw51cp2b1.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local balance = 0\n    for i = 1, #s do\n  \
    \    if s:sub(i, i) == '(' then\n        balance = balance + 1\n      else\n \
    \       balance = balance - 1\n      end\n      if balance < 0 then\n        return\
    \ false\n      end\n    end\n    return balance == 0\n  end\n  local s1, s2 =\
    \ lst[1], lst[2]\n  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or\
    \ 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmph6voz1ve.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmph6voz1ve.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppnsr3dx2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmppnsr3dx2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpymvciqot.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpymvciqot.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3t6p2x37.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp3t6p2x37.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpexbwv3v2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpexbwv3v2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 == 0 and c2 < 0 then\n        return 'Yes'\n\
    \    elseif c1 < 0 and c2 == 0 then\n        return 'Yes'\n    elseif c1 < 0 and\
    \ c2 < 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp04l1w6or.lua:45:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp04l1w6or.lua:45:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpd5bxun9p.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpd5bxun9p.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe1svs8ic.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpe1svs8ic.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppo1tv5z2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmppo1tv5z2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function helper(s)\n    local count = 0\n    for i = 1, #s do\n     \
    \ if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n        count\
    \ = count - 1\n      end\n      if count < 0 then\n        return false\n    \
    \  end\n    end\n    return count == 0\n  end\n  return helper(lst[1] .. lst[2])\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6_fouff2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp6_fouff2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    return is_good(s1\
    \ .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphaq3kti7.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmphaq3kti7.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local open, close = 0, 0\n    for i = 1, #lst[1] do\n        if lst[1]:sub(i,\
    \ i) == '(' then\n            open = open + 1\n        else\n            close\
    \ = close + 1\n        end\n    end\n    for i = 1, #lst[2] do\n        if lst[2]:sub(i,\
    \ i) == '(' then\n            open = open + 1\n        else\n            close\
    \ = close + 1\n        end\n    end\n    if open == close then\n        return\
    \ 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp190rx6_o.lua:47:\
    \ expected: \"No\"\\nactual: \"Yes\"\\nstack traceback:\\n\\t/tmp/tmp190rx6_o.lua:47:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmprdrdj9qo.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmprdrdj9qo.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(str)\n    local cnt = 0\n    for i = 1, #str do\n  \
    \    if str:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n       \
    \ cnt = cnt - 1\n      end\n      if cnt < 0 then\n        return false\n    \
    \  end\n    end\n    return cnt == 0\n  end\n  local function concat(str1, str2)\n\
    \    if is_good(str1 .. str2) then\n      return 'Yes'\n    elseif is_good(str2\
    \ .. str1) then\n      return 'Yes'\n    else\n      return 'No'\n    end\n  end\n\
    \  return concat(lst[1], lst[2])\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjxwnei_w.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpjxwnei_w.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpj678k4sw.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpj678k4sw.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpg_mvbek2.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpg_mvbek2.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn8iz2r3r.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpn8iz2r3r.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_atsf6yj.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp_atsf6yj.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local cnt = 0\n        for i = 1, #s do\n\
    \            if s:sub(i, i) == '(' then\n                cnt = cnt + 1\n     \
    \       else\n                cnt = cnt - 1\n            end\n            if cnt\
    \ < 0 then\n                return false\n            end\n        end\n     \
    \   return cnt == 0\n    end\n    local s1, s2 = lst[1], lst[2]\n    if is_good(s1\
    \ .. s2) then\n        return 'Yes'\n    elseif is_good(s2 .. s1) then\n     \
    \   return 'Yes'\n    else\n        return 'No'\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = match_parens\n    lu.assertEquals(candidate({'()(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return (is_good(lst[1]) and is_good(lst[2]))\
    \ and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_4a3z5zq.lua:33:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp_4a3z5zq.lua:33:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local function is_good(s)\n        local count = 0\n        for i = 1, #s\
    \ do\n            if s:sub(i, i) == '(' then\n                count = count +\
    \ 1\n            else\n                count = count - 1\n            end\n  \
    \          if count < 0 then\n                return false\n            end\n\
    \        end\n        return count == 0\n    end\n    return is_good(lst[1] ..\
    \ lst[2]) and 'Yes' or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1wtfaip4.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmp1wtfaip4.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n  if is_good(s1)\
    \ and is_good(s2) then\n    return 'Yes'\n  end\n  if is_good(s1 .. s2) then\n\
    \    return 'Yes'\n  end\n  if is_good(s2 .. s1) then\n    return 'Yes'\n  end\n\
    \  return 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n\
    \    lu.assertEquals(candidate({')', ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())',\
    \ '())())'}), 'No')\n    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n\
    \    lu.assertEquals(candidate({'(())))', '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()',\
    \ '())'}), 'No')\n    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n\
    \    lu.assertEquals(candidate({'((((', '((())'}), 'No')\n    lu.assertEquals(candidate({')(()',\
    \ '(()('}), 'No')\n    lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local cnt = 0\n    for i = 1, #s do\n      if\
    \ s:sub(i, i) == '(' then\n        cnt = cnt + 1\n      else\n        cnt = cnt\
    \ - 1\n      end\n      if cnt < 0 then\n        return false\n      end\n   \
    \ end\n    return cnt == 0\n  end\n  return is_good(lst[1] .. lst[2]) and 'Yes'\
    \ or 'No'\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = match_parens\n    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvjoiw99u.lua:36:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpvjoiw99u.lua:36:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2h9glre9.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmp2h9glre9.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \  local function is_good(s)\n    local count = 0\n    for i = 1, #s do\n    \
    \  if s:sub(i, i) == '(' then\n        count = count + 1\n      else\n       \
    \ count = count - 1\n      end\n      if count < 0 then\n        return false\n\
    \      end\n    end\n    return count == 0\n  end\n  local s1, s2 = lst[1], lst[2]\n\
    \  return is_good(s1 .. s2) or is_good(s2 .. s1) and 'Yes' or 'No'\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdpzoo8j6.lua:34:\
    \ expected: \"Yes\"\\nactual: true\\nstack traceback:\\n\\t/tmp/tmpdpzoo8j6.lua:34:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- You are given a list of two strings, both strings consist of open\n\
    -- parentheses '(' or close parentheses ')' only.\n-- Your job is to check if\
    \ it is possible to concatenate the two strings in\n-- some order, that the resulting\
    \ string will be good.\n-- A string S is considered to be good if and only if\
    \ all parentheses in S\n-- are balanced. For example: the string '(())()' is good,\
    \ while the string\n-- '())' is not.\n-- Return 'Yes' if there's a way to make\
    \ a good string, and return 'No' otherwise.\n-- Examples:\n-- match_parens(['()(',\
    \ ')']) == 'Yes'\n-- match_parens([')', ')']) == 'No'\nlocal function match_parens(lst)\n\
    \    local s1, s2 = lst[1], lst[2]\n    local c1, c2 = 0, 0\n    for i = 1, #s1\
    \ do\n        if s1:sub(i, i) == '(' then\n            c1 = c1 + 1\n        else\n\
    \            c1 = c1 - 1\n        end\n    end\n    for i = 1, #s2 do\n      \
    \  if s2:sub(i, i) == '(' then\n            c2 = c2 + 1\n        else\n      \
    \      c2 = c2 - 1\n        end\n    end\n    if c1 == 0 and c2 == 0 then\n  \
    \      return 'Yes'\n    elseif c1 == 0 and c2 < 0 then\n        return 'Yes'\n\
    \    elseif c1 < 0 and c2 == 0 then\n        return 'Yes'\n    elseif c1 < 0 and\
    \ c2 < 0 then\n        return 'Yes'\n    else\n        return 'No'\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = match_parens\n\
    \    lu.assertEquals(candidate({'()(', ')'}), 'Yes')\n    lu.assertEquals(candidate({')',\
    \ ')'}), 'No')\n    lu.assertEquals(candidate({'(()(())', '())())'}), 'No')\n\
    \    lu.assertEquals(candidate({')())', '(()()('}), 'Yes')\n    lu.assertEquals(candidate({'(())))',\
    \ '(()())(('}), 'Yes')\n    lu.assertEquals(candidate({'()', '())'}), 'No')\n\
    \    lu.assertEquals(candidate({'(()(', '()))()'}), 'Yes')\n    lu.assertEquals(candidate({'((((',\
    \ '((())'}), 'No')\n    lu.assertEquals(candidate({')(()', '(()('}), 'No')\n \
    \   lu.assertEquals(candidate({')(', ')('}), 'No')\n    lu.assertEquals(candidate({'(',\
    \ ')'}), 'Yes')\n    lu.assertEquals(candidate({')', '('}), 'Yes')\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b'F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpep5p1l8n.lua:45:\
    \ expected: \"Yes\"\\nactual: \"No\"\\nstack traceback:\\n\\t/tmp/tmpep5p1l8n.lua:45:\
    \ in function \\'test_humaneval\\'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n'"
  stderr: b''
  exit_code: 1
  status: Exception
