name: HumanEval_99_closest_integer
language: lua
results:
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpemap16k2.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpemap16k2.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1nod_m7d.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp1nod_m7d.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int,\
    \ frac = math.modf(num)\n  if frac >= 0.5 then\n    return int + 1\n  else\n \
    \   return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpajkp2kmh.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpajkp2kmh.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    return math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgygounqa.lua:27:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpgygounqa.lua:27:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5jm8jn9d.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp5jm8jn9d.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn4n0fogn.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpn4n0fogn.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqixejv4z.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpqixejv4z.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    return math.floor(num + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmps9k7fqkk.lua:27:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmps9k7fqkk.lua:27:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local int_part = math.floor(number)\n    local frac_part = number\
    \ - int_part\n    if frac_part < 0.5 then\n        return int_part\n    else\n\
    \        return int_part + 1\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8te55x0v.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp8te55x0v.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local n\
    \ = tonumber(value)\n  if n == nil then\n    return nil\n  end\n  if n >= 0 then\n\
    \    return math.floor(n + 0.5)\n  else\n    return math.ceil(n - 0.5)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpl8288u1d.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpl8288u1d.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    if num >= 0 then\n        return math.floor(num + 0.5)\n    else\n      \
    \  return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- TODO:\
    \ Implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmyp54zc9.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpmyp54zc9.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    integer = integer\
    \ + 1\n  end\n  return integer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_ji7fl8h.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp_ji7fl8h.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfwdpvmk2.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpfwdpvmk2.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpu_nr3p5a.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpu_nr3p5a.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num > 0 then\n        return math.floor(num +\
    \ 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp92r0k0ke.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp92r0k0ke.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1np_gllk.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp1np_gllk.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  if num - int >= 0.5 then\n\
    \    return int + 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpycvb3ia2.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpycvb3ia2.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ int = math.floor(tonumber(value))\n    local dec = tonumber(value) - int\n \
    \   if dec >= 0.5 then\n        return int + 1\n    else\n        return int\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1s1evrms.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp1s1evrms.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvjz54e1d.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpvjz54e1d.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local integer = math.floor(number)\n  if number - integer\
    \ >= 0.5 then\n    return integer + 1\n  else\n    return integer\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpscjwvq5b.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpscjwvq5b.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    local int = math.floor(num)\n    local frac = num\
    \ - int\n    if frac < 0.5 then\n        return int\n    else\n        return\
    \ int + 1\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpbtu7h31v.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpbtu7h31v.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer < 0.5\
    \ then\n        return integer\n    else\n        return integer + 1\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpzm_z2n94.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpzm_z2n94.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppywrg9h7.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmppywrg9h7.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1atgo6_k.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp1atgo6_k.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8rg3ks0l.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp8rg3ks0l.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == math.floor(num) then\n    return num\n  else\n\
    \    local floor = math.floor(num)\n    local ceil = math.ceil(num)\n    if num\
    \ - floor < ceil - num then\n      return floor\n    else\n      return ceil\n\
    \    end\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsmf9cknp.lua:34:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpsmf9cknp.lua:34:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe3nqf_c3.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpe3nqf_c3.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpubq6r77n.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpubq6r77n.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int < 0.5 then\n        return\
    \ int\n    else\n        return int + 1\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpodbxqe_o.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpodbxqe_o.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  if num - int >= 0.5 then\n\
    \    return int + 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpga3rrdf6.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpga3rrdf6.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr4og7dqa.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpr4og7dqa.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfdclzj4e.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpfdclzj4e.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local integer = math.floor(number)\n  local decimal = number\
    \ - integer\n  if decimal >= 0.5 then\n    return integer + 1\n  else\n    return\
    \ integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfl_npgmd.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpfl_npgmd.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int < 0.5 then\n    return int\n  else\n    return\
    \ int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqs50yo7c.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpqs50yo7c.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn2x422_4.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpn2x422_4.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num < 0 then\n    return math.ceil(num)\n  else\n  \
    \  return math.floor(num)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpiarkyrns.lua:27:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmpiarkyrns.lua:27: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpzq6l_gmq.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpzq6l_gmq.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgbqqzek3.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpgbqqzek3.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8eq23932.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp8eq23932.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpxq0sezzw.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpxq0sezzw.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptvdw5_1p.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmptvdw5_1p.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptkrot26o.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmptkrot26o.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  local fraction = number - integer\n  if fraction >=\
    \ 0.5 then\n    return integer + 1\n  else\n    return integer\n  end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3s0cr3yy.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp3s0cr3yy.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpn5co1x2w.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpn5co1x2w.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int < 0.5 then\n    return int\n  else\n    return\
    \ int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp47xybk7l.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp47xybk7l.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpac92sg3_.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpac92sg3_.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- TODO:\
    \ implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmtco8m58.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpmtco8m58.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpijrvb476.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpijrvb476.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num > 0 then\n        return math.floor(num +\
    \ 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    local frac = num - int\n    if frac < 0.5\
    \ then\n        return int\n    else\n        return int + 1\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdthi9sct.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdthi9sct.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num % 1 >= 0.5 then\n    return math.ceil(num)\n  else\n\
    \    return math.floor(num)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr9rtnkda.lua:28:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpr9rtnkda.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp1dt7i8ii.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp1dt7i8ii.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsmfo94ip.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpsmfo94ip.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(number)\n  local frac = number - int\n  if frac < 0.5 then\n  \
    \  return int\n  else\n    return int + 1\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp53uc2b8n.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp53uc2b8n.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpz3w_4hxi.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpz3w_4hxi.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpeses395l.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpeses395l.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpbcqr5yoi.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpbcqr5yoi.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  if num < 0\
    \ then\n    return math.ceil(num)\n  else\n    return math.floor(num)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpcvj6v7qr.lua:30:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmpcvj6v7qr.lua:30: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    local frac = num - int\n    if frac >= 0.5\
    \ then\n        return int + 1\n    else\n        return int\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpu367q2mq.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpu367q2mq.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpho3ngxp_.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpho3ngxp_.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer > 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpw_6dk0fo.lua:30:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmpw_6dk0fo.lua:30: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9bs6e0c1.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp9bs6e0c1.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    integer = integer\
    \ + 1\n  end\n  return integer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpuxbwscpv.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpuxbwscpv.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpiqc3yr_i.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpiqc3yr_i.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  if num % 1\
    \ >= 0.5 then\n    return math.ceil(num)\n  else\n    return math.floor(num)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjarl7pjy.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpjarl7pjy.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    if decimal >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpwtu7dl6j.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpwtu7dl6j.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr_763j07.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpr_763j07.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    local frac = num - int\n    if frac >= 0.5\
    \ then\n        return int + 1\n    else\n        return int\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdn7mgy1o.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdn7mgy1o.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmd0qvrpx.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpmd0qvrpx.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int < 0.5 then\n        return\
    \ int\n    else\n        return int + 1\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf0j_lx5z.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpf0j_lx5z.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    local frac = num - int\n    if frac >= 0.5\
    \ then\n        return int + 1\n    else\n        return int\n    end\nend\nlu\
    \ = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpicm852xy.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpicm852xy.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9fpid8jq.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp9fpid8jq.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local integer = math.floor(number)\n  local fraction =\
    \ number - integer\n  if fraction >= 0.5 then\n    return integer + 1\n  else\n\
    \    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpy4mczhf4.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpy4mczhf4.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdqo6imjf.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdqo6imjf.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer > 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8zply9od.lua:30:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmp8zply9od.lua:30: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdi_l_rdt.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdi_l_rdt.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpx4hcr0ed.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpx4hcr0ed.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvm15l7su.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpvm15l7su.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdgrp0t1j.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdgrp0t1j.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmphcc5vo_q.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmphcc5vo_q.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpr2thcyub.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpr2thcyub.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfsjogafk.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpfsjogafk.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    if num % 1 >= 0.5 then\n        return math.ceil(num)\n    else\n       \
    \ return math.floor(num)\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp06f6wd_7.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp06f6wd_7.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdvrcg349.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdvrcg349.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  local frac = num - int\n  if frac >= 0.5 then\n    return\
    \ int + 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0ho56j00.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp0ho56j00.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num > 0 then\n        return math.floor(num +\
    \ 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp17vfss52.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp17vfss52.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpulxtpeer.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpulxtpeer.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  if num >=\
    \ 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num -\
    \ 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer < 0.5\
    \ then\n        return integer\n    else\n        return integer + 1\n    end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpohk8_mwt.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpohk8_mwt.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local int,\
    \ frac = math.modf(number)\n  if frac >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmph_eoihcb.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmph_eoihcb.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    integer = integer\
    \ + 1\n  end\n  return integer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9nkwrgmp.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp9nkwrgmp.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    local integer = math.floor(number)\n    if number\
    \ - integer >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpkcp33v25.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpkcp33v25.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmxtnxm8u.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpmxtnxm8u.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpezru4msh.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpezru4msh.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpzopwlldm.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpzopwlldm.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpknaestnp.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpknaestnp.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppzpw3g9o.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmppzpw3g9o.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8r5tpwgf.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp8r5tpwgf.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpngvfrw80.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpngvfrw80.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number > 0 then\n    return math.floor(number + 0.5)\n\
    \  else\n    return math.ceil(number - 0.5)\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp45200jf4.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp45200jf4.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int,\
    \ frac = math.modf(num)\n  if frac >= 0.5 then\n    return int + 1\n  else\n \
    \   return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7q2e92zj.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp7q2e92zj.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then return nil end\n  local int = math.floor(num)\n\
    \  if num - int < 0.5 then\n    return int\n  else\n    return int + 1\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpa7blx_ar.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpa7blx_ar.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp67n0v0n3.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp67n0v0n3.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  if num >=\
    \ 0 then\n    return math.floor(num + 0.5)\n  else\n    return math.ceil(num -\
    \ 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpuvm6y9m7.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpuvm6y9m7.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    local decimal = number - integer\n\
    \    if decimal >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppw57etp3.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmppw57etp3.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ Implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9dxbqp5f.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmp9dxbqp5f.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfyjxty88.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpfyjxty88.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ value = tonumber(value)\n    if value % 1 >= 0.5 then\n        return math.ceil(value)\n\
    \    else\n        return math.floor(value)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpmwfvd3d4.lua:28:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpmwfvd3d4.lua:28:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    integer = integer\
    \ + 1\n  end\n  return integer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpl1e9rnpy.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpl1e9rnpy.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyy4pqqxy.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpyy4pqqxy.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmppj84uw6_.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmppj84uw6_.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    local frac = num - int\n    if frac > 0.5\
    \ then\n        return int + 1\n    elseif frac < -0.5 then\n        return int\
    \ - 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\n\
    function test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf7sfzziu.lua:34:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmpf7sfzziu.lua:34: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptiukkuwb.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmptiukkuwb.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num > 0 then\n        return math.floor(num +\
    \ 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0j9btpx2.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp0j9btpx2.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  local integer = math.floor(number)\n  if number - integer\
    \ >= 0.5 then\n    return integer + 1\n  else\n    return integer\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp002jthk7.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp002jthk7.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpq6rnuk9t.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpq6rnuk9t.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpeoxc5anx.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpeoxc5anx.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmps6yrmwqi.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmps6yrmwqi.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  local frac = num - int\n\
    \  if frac >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdw_msdv8.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdw_msdv8.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp3p3znb62.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp3p3znb62.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == math.floor(num) then\n    return num\n  else\n\
    \    local int = math.floor(num)\n    if num - int < 0.5 then\n      return int\n\
    \    else\n      return int + 1\n    end\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp8nvcy2xh.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp8nvcy2xh.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    local int = math.floor(num)\n    if num - int >=\
    \ 0.5 then\n        return int + 1\n    else\n        return int\n    end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgw2a3px6.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpgw2a3px6.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- TODO:\
    \ Implement this function.\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpu9vvswgj.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpu9vvswgj.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    local fraction = number -\
    \ integer\n    if fraction >= 0.5 then\n        return integer + 1\n    else\n\
    \        return integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpa10u5zhp.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpa10u5zhp.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    return math.floor(num + 0.5)\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf31k6_fa.lua:24:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpf31k6_fa.lua:24:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_d34r_o7.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp_d34r_o7.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number < 0 then\n    return math.ceil(number)\n  else\n\
    \    return math.floor(number)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpwm6lm1gk.lua:27:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmpwm6lm1gk.lua:27: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpvqmo4jei.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpvqmo4jei.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe6zxq83p.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpe6zxq83p.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number < 0 then\n        return math.ceil(number)\n\
    \    else\n        return math.floor(number)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpnjpk0le6.lua:27:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmpnjpk0le6.lua:27: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    return integer\
    \ + 1\n  else\n    return integer\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpfxx9fsre.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpfxx9fsre.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpyqimd248.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpyqimd248.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local int = math.floor(num)\n    if num - int >= 0.5 then\n        return\
    \ int + 1\n    else\n        return int\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6st8rsy1.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp6st8rsy1.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer > 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmplf3jpdt8.lua:30:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmplf3jpdt8.lua:30: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp2yfk1_od.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp2yfk1_od.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  return\
    \ math.floor(number + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpw17dyb_v.lua:27:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpw17dyb_v.lua:27:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp02qid9i2.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp02qid9i2.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    if num > 0 then\n        return math.floor(num + 0.5)\n    else\n       \
    \ return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp6qldvvo7.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp6qldvvo7.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    local int = math.floor(number)\n    local frac\
    \ = number - int\n    if frac >= 0.5 then\n        return int + 1\n    else\n\
    \        return int\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp18340a6z.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp18340a6z.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local int\
    \ = math.floor(tonumber(value))\n  local frac = tonumber(value) - int\n  if frac\
    \ < 0.5 then\n    return int\n  else\n    return int + 1\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpqnepa061.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpqnepa061.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe20_ko2o.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpe20_ko2o.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    local integer = math.floor(number)\n    if number - integer >= 0.5\
    \ then\n        integer = integer + 1\n    end\n    return integer\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpxk2c17vz.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpxk2c17vz.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjflnq6m_.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpjflnq6m_.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer < 0.5 then\n    return integer\n\
    \  else\n    return integer + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpsv_u8l3p.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpsv_u8l3p.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    local integer = math.floor(number)\n    if number\
    \ - integer >= 0.5 then\n        return integer + 1\n    else\n        return\
    \ integer\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpwlivn_xn.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpwlivn_xn.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpe00dq0q3.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpe00dq0q3.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp4678yamd.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp4678yamd.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(value\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpk0p_pqcq.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpk0p_pqcq.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  if number\
    \ > 0 then\n    return math.floor(number + 0.5)\n  else\n    return math.ceil(number\
    \ - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local floor\
    \ = math.floor(number)\n  local ceil = math.ceil(number)\n  if number - floor\
    \ < ceil - number then\n    return floor\n  else\n    return ceil\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmptwt0488k.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmptwt0488k.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  local dec = num - int\n\
    \  if dec >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmps2zfn2rj.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmps2zfn2rj.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  if num - int >= 0.5 then\n\
    \    return int + 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9f2kawk1.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp9f2kawk1.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number > 0 then\n        return math.floor(number\
    \ + 0.5)\n    else\n        return math.ceil(number - 0.5)\n    end\nend\nlu =\
    \ require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0_evbhrb.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp0_evbhrb.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num > 0 then\n    return math.floor(num + 0.5)\n  else\n\
    \    return math.ceil(num - 0.5)\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  if number\
    \ % 1 >= 0.5 then\n    return math.ceil(number)\n  else\n    return math.floor(number)\n\
    \  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpg5hzras9.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpg5hzras9.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num > 0 then\n        return math.floor(num +\
    \ 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpihd1vxad.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpihd1vxad.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpc0o5cgg1.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpc0o5cgg1.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num then\n    return math.floor(num + 0.5)\n  end\n\
    end\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp9wm4zds_.lua:26:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp9wm4zds_.lua:26:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdijzdzh8.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdijzdzh8.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  local frac = num - int\n  if frac < 0.5 then\n    return\
    \ int\n  else\n    return int + 1\n  end\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpx22ls97m.lua:33:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpx22ls97m.lua:33:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- TODO:\
    \ Implement this function\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpjvmva9mx.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpjvmva9mx.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- your\
    \ code here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal\
    \ candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdg2i_2f6.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpdg2i_2f6.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp030gmafw.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp030gmafw.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5bvtngrx.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp5bvtngrx.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(tonumber(value) + 0.5)\nend\nlu = require('luaunit')\n\nfunction\
    \ test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpdllcvyn8.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpdllcvyn8.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpf3mhqvwk.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpf3mhqvwk.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  if num == nil then\n    return nil\n  end\n  local int\
    \ = math.floor(num)\n  if num - int >= 0.5 then\n    return int + 1\n  else\n\
    \    return int\n  end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp_6jqepc0.lua:32:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp_6jqepc0.lua:32:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ v = tonumber(value)\n    if v == nil then\n        return nil\n    end\n   \
    \ local i = math.floor(v)\n    if v - i > 0.5 then\n        return i + 1\n   \
    \ else\n        return i\n    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp4n_nknq6.lua:31:\
    \ expected: 15, actual: 14\\nstack traceback:\\n\\t/tmp/tmp4n_nknq6.lua:31: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp0nnph5yq.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp0nnph5yq.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  -- TODO:\
    \ implement the function here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpcgog5ef2.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmpcgog5ef2.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.000 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  if num - int >= 0.5 then\n\
    \    return int + 1\n  else\n    return int\n  end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpb4srbhve.lua:29:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpb4srbhve.lua:29:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    -- TODO:\
    \ Implement the function here\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp5_i9htn8.lua:21:\
    \ expected: 10, actual: nil\\nstack traceback:\\n\\t/tmp/tmp5_i9htn8.lua:21: in\
    \ function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes, 1\
    \ failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num == nil then\n        return nil\n    end\n\
    \    local floor = math.floor(num)\n    local ceil = math.ceil(num)\n    if num\
    \ - floor == 0.5 then\n        if floor > 0 then\n            return ceil\n  \
    \      else\n            return floor\n        end\n    else\n        return floor\n\
    \    end\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    if number > 0 then\n        return math.floor(number + 0.5)\n    else\n\
    \        return math.ceil(number - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.001 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local num\
    \ = tonumber(value)\n  local int = math.floor(num)\n  local frac = num - int\n\
    \  if frac >= 0.5 then\n    return int + 1\n  else\n    return int\n  end\nend\n\
    lu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate = closest_integer\n\
    \    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmp7sra6xyc.lua:30:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmp7sra6xyc.lua:30:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  local number\
    \ = tonumber(value)\n  if number == nil then\n    return nil\n  end\n  local integer\
    \ = math.floor(number)\n  if number - integer >= 0.5 then\n    integer = integer\
    \ + 1\n  end\n  return integer\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpgxjl_evs.lua:31:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpgxjl_evs.lua:31:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    return\
    \ math.floor(value + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\n\
    local candidate = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n\
    \    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpplp2snf0.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpplp2snf0.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ number = tonumber(value)\n    if number == nil then\n        return nil\n  \
    \  end\n    if number >= 0 then\n        return math.floor(number + 0.5)\n   \
    \ else\n        return math.ceil(number - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n  return math.floor(tonumber(value)\
    \ + 0.5)\nend\nlu = require('luaunit')\n\nfunction test_humaneval()\nlocal candidate\
    \ = closest_integer\n    lu.assertEquals(candidate('10'), 10)\n    lu.assertEquals(candidate('14.5'),\
    \ 15)\n    lu.assertEquals(candidate('-15.5'), -16)\n    lu.assertEquals(candidate('15.3'),\
    \ 15)\n    lu.assertEquals(candidate('0'), 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: "b\"F\\nFailed tests:\\n-------------\\n1) test_humaneval\\n/tmp/tmpbkt_ojjv.lua:23:\
    \ expected: -16, actual: -15\\nstack traceback:\\n\\t/tmp/tmpbkt_ojjv.lua:23:\
    \ in function 'test_humaneval'\\n\\nRan 1 tests in 0.001 seconds, 0 successes,\
    \ 1 failure\\n\""
  stderr: b''
  exit_code: 1
  status: Exception
- program: "-- Create a function that takes a value (string) representing a number\n\
    -- and returns the closest integer to it. If the number is equidistant\n-- from\
    \ two integers, round it away from zero.\n-- Examples\n-- >>> closest_integer(\"\
    10\")\n-- 10\n-- >>> closest_integer(\"15.3\")\n-- 15\n-- Note:\n-- Rounding away\
    \ from zero means that if the given number is equidistant\n-- from two integers,\
    \ the one you should return is the one that is the\n-- farthest from zero. For\
    \ example closest_integer(\"14.5\") should\n-- return 15 and closest_integer(\"\
    -14.5\") should return -15.\nlocal function closest_integer(value)\n    local\
    \ num = tonumber(value)\n    if num > 0 then\n        return math.floor(num +\
    \ 0.5)\n    else\n        return math.ceil(num - 0.5)\n    end\nend\nlu = require('luaunit')\n\
    \nfunction test_humaneval()\nlocal candidate = closest_integer\n    lu.assertEquals(candidate('10'),\
    \ 10)\n    lu.assertEquals(candidate('14.5'), 15)\n    lu.assertEquals(candidate('-15.5'),\
    \ -16)\n    lu.assertEquals(candidate('15.3'), 15)\n    lu.assertEquals(candidate('0'),\
    \ 0)\nend\n\nos.exit(lu.LuaUnit.run())"
  stdout: b''
  stderr: b'.\nRan 1 tests in 0.000 seconds, 1 success, 0 failures\nOK\n'
  exit_code: 0
  status: OK
