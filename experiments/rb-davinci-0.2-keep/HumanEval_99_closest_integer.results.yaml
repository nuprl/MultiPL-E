name: HumanEval_99_closest_integer
language: ruby
results:
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9d0gzb_8\nStarted\n.\nFinished in 0.000588829 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1698.29 tests/s, 8491.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc_dqk1xm\nStarted\n.\nFinished in 0.000489781 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2041.73 tests/s, 10208.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp01zr93xz\nStarted\n.\nFinished in 0.001012393 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    987.76 tests/s, 4938.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpln7uuk0n\nStarted\n.\nFinished in 0.000521177 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1918.73 tests/s, 9593.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpa1418vdy\nStarted\n.\nFinished in 0.000510195 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1960.03 tests/s, 9800.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpiwcylpt8\nStarted\n.\nFinished in 0.000740746 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1349.99 tests/s, 6749.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp06ijh_jo\nStarted\n.\nFinished in 0.000583614 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1713.46 tests/s, 8567.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpks2hp2um\nStarted\n.\nFinished in 0.001277525 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    782.76 tests/s, 3913.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd8qeb82g\nStarted\n.\nFinished in 0.000795343 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1257.32 tests/s, 6286.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpijnh24x1\nStarted\n.\nFinished in 0.000676709 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1477.74 tests/s, 7388.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpplll843b\nStarted\n.\nFinished in 0.000584332 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1711.36 tests/s, 8556.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpke83st3x\nStarted\n.\nFinished in 0.000520264 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1922.10 tests/s, 9610.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfxqnv4wj\nStarted\n.\nFinished in 0.000865411 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1155.52 tests/s, 5777.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value.to_i\
    \ == value\n    value.to_i\n  else\n    value.to_i + (value > 0 ? 1 : -1)\n  end\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpoblnb0n6\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpoblnb0n6.rb:29:in `test_closest_integer'\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n     27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n  => 29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n     31:   end\n     32: end\n<15>\
    \ expected but was\n<16>\n\ndiff:\n? 15\n?  6\n===============================================================================\n\
    \nFinished in 0.008850038 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    112.99 tests/s, 451.98 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb5ufifql\nStarted\n.\nFinished in 0.000864677 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1156.50 tests/s, 5782.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmhh_jul3\nStarted\n.\nFinished in 0.000854941 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1169.67 tests/s, 5848.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1wc0kuvd\nStarted\n.\nFinished in 0.000554208 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1804.38 tests/s, 9021.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4e0h0o9t\nStarted\n.\nFinished in 0.000507313 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1971.17 tests/s, 9855.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl3xcuqbe\nStarted\n.\nFinished in 0.001016554 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    983.72 tests/s, 4918.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyige0u88\nStarted\n.\nFinished in 0.000578939 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1727.30 tests/s, 8636.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpja9griv9\nStarted\n.\nFinished in 0.000506878 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1972.86 tests/s, 9864.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5xtcp7ea\nStarted\n.\nFinished in 0.00054367 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1839.35 tests/s, 9196.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp12sikzeh\nStarted\n.\nFinished in 0.001055897 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    947.06 tests/s, 4735.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc0muojsj\nStarted\n.\nFinished in 0.000761779 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1312.72 tests/s, 6563.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvbl1xoq_\nStarted\n.\nFinished in 0.000870525 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1148.73 tests/s, 5743.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprktkdptx\nStarted\n.\nFinished in 0.000494838 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2020.86 tests/s, 10104.32 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl4indbom\nStarted\n.\nFinished in 0.000622327 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1606.87 tests/s, 8034.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpev4jasj9\nStarted\n.\nFinished in 0.000763202 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1310.27 tests/s, 6551.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgskwqsxk\nStarted\n.\nFinished in 0.000537428 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1860.71 tests/s, 9303.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4x7qaag0\nStarted\n.\nFinished in 0.00116998 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    854.72 tests/s, 4273.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4dvsutpr\nStarted\n.\nFinished in 0.001286447 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    777.33 tests/s, 3886.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqg4dgath\nStarted\n.\nFinished in 0.001266082 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    789.84 tests/s, 3949.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzdgi7_vh\nStarted\n.\nFinished in 0.001187988 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    841.76 tests/s, 4208.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo8t62k_s\nStarted\n.\nFinished in 0.00070457 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1419.31 tests/s, 7096.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6yskmtcd\nStarted\n.\nFinished in 0.000916949 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1090.57 tests/s, 5452.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpumvwurha\nStarted\n.\nFinished in 0.000544103 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1837.89 tests/s, 9189.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmso7llbj\nStarted\n.\nFinished in 0.001890648 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    528.92 tests/s, 2644.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpaj6og8pg\nStarted\n.\nFinished in 0.001125713 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    888.33 tests/s, 4441.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4ob86032\nStarted\n.\nFinished in 0.001695569 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    589.77 tests/s, 2948.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphn815ia5\nStarted\n.\nFinished in 0.000749813 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1333.67 tests/s, 6668.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph15gyppw\nStarted\n.\nFinished in 0.001224567 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    816.62 tests/s, 4083.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpi3qh75gx\nStarted\n.\nFinished in 0.000902717 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1107.77 tests/s, 5538.83 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3dfu5pua\nStarted\n.\nFinished in 0.000510736 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1957.96 tests/s, 9789.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyr98f5ny\nStarted\n.\nFinished in 0.001242103 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    805.09 tests/s, 4025.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpaoj4jkoj\nStarted\n.\nFinished in 0.000904972 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1105.01 tests/s, 5525.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwreby85l\nStarted\n.\nFinished in 0.001348521 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    741.55 tests/s, 3707.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptyr62ux2\nStarted\n.\nFinished in 0.001084449 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    922.13 tests/s, 4610.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp47mofk5q\nStarted\n.\nFinished in 0.000913232 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1095.01 tests/s, 5475.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyi_r47rs\nStarted\n.\nFinished in 0.000612438 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1632.82 tests/s, 8164.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp664aorw\nStarted\n.\nFinished in 0.000839835 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1190.71 tests/s, 5953.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2e6a635_\nStarted\n.\nFinished in 0.000710844 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1406.78 tests/s, 7033.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppkyuu3lv\nStarted\n.\nFinished in 0.000969299 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1031.67 tests/s, 5158.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc_rkmceg\nStarted\n.\nFinished in 0.000551688 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1812.62 tests/s, 9063.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps_k9t9kr\nStarted\n.\nFinished in 0.001000061 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    999.94 tests/s, 4999.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8_ju20iq\nStarted\n.\nFinished in 0.001061218 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    942.31 tests/s, 4711.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    return value.to_i\n  elsif value % 1 < 0.5\n    return value.to_i\n\
    \  else\n    return value.to_i + 1\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n\
    \    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"\
    14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15,\
    \ candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\n\
    end\n"
  stdout: "Loaded suite /tmp/tmpq9hd8g_0\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpq9hd8g_0.rb:30:in `test_closest_integer'\n\
    \     27:     candidate = method(:closest_integer)\n     28:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     29:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 30:     assert_equal(-16, candidate.call(\"-15.5\"))\n     31:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     32:     assert_equal(0, candidate.call(\"0\"\
    ))\n     33:   end\n<-16> expected but was\n<-14>\n\ndiff:\n? -16\n?   4\n===============================================================================\n\
    \nFinished in 0.010663001 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    93.78 tests/s, 281.35 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp738lz9wg\nStarted\n.\nFinished in 0.000641122 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1559.77 tests/s, 7798.83 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpufn78hf_\nStarted\n.\nFinished in 0.000576452 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1734.75 tests/s, 8673.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp936a_0ie\nStarted\n.\nFinished in 0.000601457 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1662.63 tests/s, 8313.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp73hozadt\nStarted\n.\nFinished in 0.000948712 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1054.06 tests/s, 5270.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplr2jlobd\nStarted\n.\nFinished in 0.00066666 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1500.02 tests/s, 7500.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value.round\
    \ == value\n    value.round\n  else\n    value.round > value ? value.round - 1\
    \ : value.round\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2_vl_pws\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp2_vl_pws.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.013656316 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    73.23 tests/s, 146.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvtpq3_g8\nStarted\n.\nFinished in 0.001060426 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    943.02 tests/s, 4715.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu_cg75av\nStarted\n.\nFinished in 0.00056892 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1757.72 tests/s, 8788.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfu2j0xk_\nStarted\n.\nFinished in 0.000694363 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1440.17 tests/s, 7200.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppqycyg_0\nStarted\n.\nFinished in 0.001349875 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    740.81 tests/s, 3704.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvlurki64\nStarted\n.\nFinished in 0.000794128 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1259.24 tests/s, 6296.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprhs_88ga\nStarted\n.\nFinished in 0.000671514 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1489.17 tests/s, 7445.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ - value.to_i >= 0.5\n    value.ceil\n  else\n    value.floor\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2q23ysnb\nStarted\n.\nFinished in 0.000639986 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1562.53 tests/s, 7812.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    return value.to_i\n  elsif value % 1 > 0.5\n    return value.ceil\n\
    \  else\n    return value.floor\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n\
    \    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"\
    14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15,\
    \ candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\n\
    end\n"
  stdout: "Loaded suite /tmp/tmpuqt20bjr\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpuqt20bjr.rb:29:in `test_closest_integer'\n\
    \     26:   def test_closest_integer\n     27:     candidate = method(:closest_integer)\n\
    \     28:     assert_equal(10, candidate.call(\"10\"))\n  => 29:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     30:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     31:     assert_equal(15, candidate.call(\"15.3\"))\n     32: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.013293233 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    75.23 tests/s, 150.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkhvrlera\nStarted\n.\nFinished in 0.000855045 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1169.53 tests/s, 5847.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplt7swlky\nStarted\n.\nFinished in 0.000876344 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1141.10 tests/s, 5705.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppu2bu6hb\nStarted\n.\nFinished in 0.000599733 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1667.41 tests/s, 8337.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphhvixj8c\nStarted\n.\nFinished in 0.00090872 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1100.45 tests/s, 5502.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8nwqsp6z\nStarted\n.\nFinished in 0.000592835 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1686.81 tests/s, 8434.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6dji2v1i\nStarted\n.\nFinished in 0.000824116 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1213.42 tests/s, 6067.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfuxxuc0n\nStarted\n.\nFinished in 0.000598872 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1669.81 tests/s, 8349.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz5evsyxi\nStarted\n.\nFinished in 0.000742452 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1346.89 tests/s, 6734.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_67eck1a\nStarted\n.\nFinished in 0.000641508 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1558.83 tests/s, 7794.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9ud6agq9\nStarted\n.\nFinished in 0.000591424 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1690.83 tests/s, 8454.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpah2e74qv\nStarted\n.\nFinished in 0.000534878 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1869.59 tests/s, 9347.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpe1aol60i\nStarted\n.\nFinished in 0.000578505 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1728.59 tests/s, 8642.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpahm3aa1t\nStarted\n.\nFinished in 0.001387193 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    720.88 tests/s, 3604.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6dxcmf5m\nStarted\n.\nFinished in 0.001153324 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    867.06 tests/s, 4335.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqfvrh406\nStarted\n.\nFinished in 0.000572105 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1747.93 tests/s, 8739.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjleiidi5\nStarted\n.\nFinished in 0.000542396 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1843.67 tests/s, 9218.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpe_qa01a4\nStarted\n.\nFinished in 0.000744727 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1342.77 tests/s, 6713.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2j_b3kk5\nStarted\n.\nFinished in 0.000862566 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1159.33 tests/s, 5796.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3n3rxdwa\nStarted\n.\nFinished in 0.000792339 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1262.09 tests/s, 6310.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1o42co2g\nStarted\n.\nFinished in 0.001294544 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    772.47 tests/s, 3862.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkh7q4ov4\nStarted\n.\nFinished in 0.000578081 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1729.86 tests/s, 8649.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz6yokc7k\nStarted\n.\nFinished in 0.000718251 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1392.27 tests/s, 6961.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0sppdk8b\nStarted\n.\nFinished in 0.000664411 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1505.09 tests/s, 7525.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvi8mxhrc\nStarted\n.\nFinished in 0.000848498 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1178.55 tests/s, 5892.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp18j3fiuz\nStarted\n.\nFinished in 0.000752326 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1329.21 tests/s, 6646.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcjl36lu8\nStarted\n.\nFinished in 0.001027299 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    973.43 tests/s, 4867.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprczwjhgd\nStarted\n.\nFinished in 0.000951956 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1050.47 tests/s, 5252.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_hxkq2ec\nStarted\n.\nFinished in 0.000628504 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1591.08 tests/s, 7955.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd5fncrzy\nStarted\n.\nFinished in 0.000785533 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1273.02 tests/s, 6365.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppsdjpy2y\nStarted\n.\nFinished in 0.000783998 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1275.51 tests/s, 6377.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8yf0yflf\nStarted\n.\nFinished in 0.001393488 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    717.62 tests/s, 3588.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6s5am73p\nStarted\n.\nFinished in 0.000873864 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1144.34 tests/s, 5721.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp89_knx0x\nStarted\n.\nFinished in 0.001062169 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    941.47 tests/s, 4707.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz2726821\nStarted\n.\nFinished in 0.001044565 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    957.34 tests/s, 4786.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ - value.to_i >= 0.5\n    value.to_i + 1\n  else\n    value.to_i\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptcamlj8u\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmptcamlj8u.rb:28:in `test_closest_integer'\n\
    \     25:     candidate = method(:closest_integer)\n     26:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     27:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 28:     assert_equal(-16, candidate.call(\"-15.5\"))\n     29:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     30:     assert_equal(0, candidate.call(\"0\"\
    ))\n     31:   end\n<-16> expected but was\n<-15>\n\ndiff:\n? -16\n?   5\n===============================================================================\n\
    \nFinished in 0.013589985 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    73.58 tests/s, 220.75 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl3z3yg5s\nStarted\n.\nFinished in 0.001536115 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    650.99 tests/s, 3254.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdmct14ef\nStarted\n.\nFinished in 0.000605446 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1651.67 tests/s, 8258.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw2v3com3\nStarted\n.\nFinished in 0.00075769 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1319.80 tests/s, 6599.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxp6jdnkh\nStarted\n.\nFinished in 0.000724146 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1380.94 tests/s, 6904.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3k3hx5_z\nStarted\n.\nFinished in 0.001228939 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    813.71 tests/s, 4068.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt9ezn1gn\nStarted\n.\nFinished in 0.00080925 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1235.71 tests/s, 6178.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzjv74zbj\nStarted\n.\nFinished in 0.000662975 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1508.35 tests/s, 7541.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps4f05dhp\nStarted\n.\nFinished in 0.000861755 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1160.42 tests/s, 5802.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5p38m72h\nStarted\n.\nFinished in 0.00061774 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1618.80 tests/s, 8094.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_srj9f0v\nStarted\n.\nFinished in 0.000797217 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1254.36 tests/s, 6271.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkvvidtbu\nStarted\n.\nFinished in 0.001030962 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    969.97 tests/s, 4849.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_f6y1d03\nStarted\n.\nFinished in 0.000575241 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1738.40 tests/s, 8692.01 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpeu7um1qb\nStarted\n.\nFinished in 0.000700186 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1428.19 tests/s, 7140.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgbg79h5k\nStarted\n.\nFinished in 0.000521034 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1919.26 tests/s, 9596.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvyfoi6kw\nStarted\n.\nFinished in 0.000852217 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1173.41 tests/s, 5867.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6q2gni7z\nStarted\n.\nFinished in 0.000618296 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1617.35 tests/s, 8086.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps38nhicc\nStarted\n.\nFinished in 0.001107503 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    902.93 tests/s, 4514.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvnl_rtc8\nStarted\n.\nFinished in 0.000488497 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2047.10 tests/s, 10235.48 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7f4mdds2\nStarted\n.\nFinished in 0.000935114 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1069.39 tests/s, 5346.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl6ipwv4e\nStarted\n.\nFinished in 0.000558478 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1790.58 tests/s, 8952.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxk6v2dj2\nStarted\n.\nFinished in 0.001000501 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    999.50 tests/s, 4997.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc0xdac77\nStarted\n.\nFinished in 0.001486318 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    672.80 tests/s, 3364.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdirm7ac6\nStarted\n.\nFinished in 0.001253422 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    797.82 tests/s, 3989.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value < 0 ? value.ceil : value.floor\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2msq3170\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp2msq3170.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.009280467 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    107.75 tests/s, 215.51 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkqj0m76c\nStarted\n.\nFinished in 0.000999934 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1000.07 tests/s, 5000.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjv8pqm66\nStarted\n.\nFinished in 0.000610407 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1638.25 tests/s, 8191.26 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz0_fwhtt\nStarted\n.\nFinished in 0.000635986 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1572.36 tests/s, 7861.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp63fj1c52\nStarted\n.\nFinished in 0.001281348 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    780.43 tests/s, 3902.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfxf0g3t4\nStarted\n.\nFinished in 0.001225343 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    816.10 tests/s, 4080.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph7a45y5a\nStarted\n.\nFinished in 0.000558087 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1791.84 tests/s, 8959.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4a6n2d3m\nStarted\n.\nFinished in 0.000989368 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1010.75 tests/s, 5053.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwv66m945\nStarted\n.\nFinished in 0.000531705 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1880.74 tests/s, 9403.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5mi3tnrk\nStarted\n.\nFinished in 0.000546059 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1831.30 tests/s, 9156.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq0zpvvfl\nStarted\n.\nFinished in 0.000856229 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1167.91 tests/s, 5839.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8alvshpy\nStarted\n.\nFinished in 0.001381 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    724.11 tests/s, 3620.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp91l73zjx\nStarted\n.\nFinished in 0.000909607 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1099.38 tests/s, 5496.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ == value.to_i\n    value.to_i\n  elsif value > value.to_i\n    value.to_i +\
    \ 1\n  else\n    value.to_i - 1\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_closest_integer\n    candidate = method(:closest_integer)\n\
    \    assert_equal(10, candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"\
    14.5\"))\n    assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15,\
    \ candidate.call(\"15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\n\
    end\n"
  stdout: "Loaded suite /tmp/tmplo9hgtjs\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmplo9hgtjs.rb:31:in `test_closest_integer'\n\
    \     28:     assert_equal(10, candidate.call(\"10\"))\n     29:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     30:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n  => 31:     assert_equal(15, candidate.call(\"15.3\"))\n     32: \
    \    assert_equal(0, candidate.call(\"0\"))\n     33:   end\n     34: end\n<15>\
    \ expected but was\n<16>\n\ndiff:\n? 15\n?  6\n===============================================================================\n\
    \nFinished in 0.011163559 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 4 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    89.58 tests/s, 358.31 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmlq9uvhi\nStarted\n.\nFinished in 0.001352825 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    739.19 tests/s, 3695.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8nugqxh7\nStarted\n.\nFinished in 0.001020433 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    979.98 tests/s, 4899.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2x7cvd1d\nStarted\n.\nFinished in 0.000744224 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1343.68 tests/s, 6718.41 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8qf2_2_w\nStarted\n.\nFinished in 0.000744118 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1343.87 tests/s, 6719.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz_o2pu24\nStarted\n.\nFinished in 0.00164107 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    609.36 tests/s, 3046.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 >= 0.5\n    value.ceil\n  else\n    value.floor\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpsa6lnrct\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpsa6lnrct.rb:28:in `test_closest_integer'\n\
    \     25:     candidate = method(:closest_integer)\n     26:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     27:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 28:     assert_equal(-16, candidate.call(\"-15.5\"))\n     29:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     30:     assert_equal(0, candidate.call(\"0\"\
    ))\n     31:   end\n<-16> expected but was\n<-15>\n\ndiff:\n? -16\n?   5\n===============================================================================\n\
    \nFinished in 0.007693435 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    129.98 tests/s, 389.94 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2u9arv6t\nStarted\n.\nFinished in 0.001317094 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    759.25 tests/s, 3796.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzfiqhyga\nStarted\n.\nFinished in 0.000767667 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1302.65 tests/s, 6513.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpeabl_v83\nStarted\n.\nFinished in 0.001075998 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    929.37 tests/s, 4646.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6dz_nir3\nStarted\n.\nFinished in 0.001142562 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    875.23 tests/s, 4376.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcd2oxamo\nStarted\n.\nFinished in 0.001054251 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    948.54 tests/s, 4742.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpndujktvn\nStarted\n.\nFinished in 0.001006827 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    993.22 tests/s, 4966.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  # your code here\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp8soxiaap\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp8soxiaap.rb:21:in `test_closest_integer'\n\
    \     18: class TestHumanEval < Test::Unit::TestCase\n     19:   def test_closest_integer\n\
    \     20:     candidate = method(:closest_integer)\n  => 21:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     22:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n     23:     assert_equal(-16, candidate.call(\"-15.5\"))\n     24:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n<10> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.01547343 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    64.63 tests/s, 64.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprqc065gw\nStarted\n.\nFinished in 0.001633579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    612.15 tests/s, 3060.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc_54c5bi\nStarted\n.\nFinished in 0.000836709 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1195.16 tests/s, 5975.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppc2kog22\nStarted\n.\nFinished in 0.000686654 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1456.34 tests/s, 7281.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8j6htjm2\nStarted\n.\nFinished in 0.000629163 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1589.41 tests/s, 7947.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5p_yyjhh\nStarted\n.\nFinished in 0.000584536 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1710.76 tests/s, 8553.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjx5okvt0\nStarted\n.\nFinished in 0.000562803 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1776.82 tests/s, 8884.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1f5n1qfj\nStarted\n.\nFinished in 0.000974282 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1026.40 tests/s, 5131.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6l4m1_0p\nStarted\n.\nFinished in 0.000962965 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1038.46 tests/s, 5192.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9gyy5o4g\nStarted\n.\nFinished in 0.001138101 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    878.66 tests/s, 4393.28 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzoyolrsj\nStarted\n.\nFinished in 0.000877499 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1139.60 tests/s, 5698.01 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcdszag43\nStarted\n.\nFinished in 0.000529682 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1887.93 tests/s, 9439.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpj06yixvm\nStarted\n.\nFinished in 0.001485925 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    672.98 tests/s, 3364.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprxm8dm8z\nStarted\n.\nFinished in 0.000784211 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1275.17 tests/s, 6375.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ - value.to_i > 0.5\n    value.to_i + 1\n  else\n    value.to_i\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpiz0jw2sx\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpiz0jw2sx.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.013063899 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    76.55 tests/s, 153.09 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  # Your code here\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4su8xaq2\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp4su8xaq2.rb:21:in `test_closest_integer'\n\
    \     18: class TestHumanEval < Test::Unit::TestCase\n     19:   def test_closest_integer\n\
    \     20:     candidate = method(:closest_integer)\n  => 21:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     22:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n     23:     assert_equal(-16, candidate.call(\"-15.5\"))\n     24:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n<10> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.01177514 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    84.92 tests/s, 84.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp7a0_s1w\nStarted\n.\nFinished in 0.000715196 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1398.22 tests/s, 6991.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpe4d47oiv\nStarted\n.\nFinished in 0.000696968 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1434.79 tests/s, 7173.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6swfntb_\nStarted\n.\nFinished in 0.000660981 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1512.90 tests/s, 7564.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpd4610isq\nStarted\n.\nFinished in 0.000536011 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1865.63 tests/s, 9328.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpm5qbfpxj\nStarted\n.\nFinished in 0.001218518 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    820.67 tests/s, 4103.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 >= 0.5\n    value = value.ceil\n  else\n    value = value.floor\n  end\n\
    \  value\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr16g3z6v\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpr16g3z6v.rb:29:in `test_closest_integer'\n\
    \     26:     candidate = method(:closest_integer)\n     27:     assert_equal(10,\
    \ candidate.call(\"10\"))\n     28:     assert_equal(15, candidate.call(\"14.5\"\
    ))\n  => 29:     assert_equal(-16, candidate.call(\"-15.5\"))\n     30:     assert_equal(15,\
    \ candidate.call(\"15.3\"))\n     31:     assert_equal(0, candidate.call(\"0\"\
    ))\n     32:   end\n<-16> expected but was\n<-15>\n\ndiff:\n? -16\n?   5\n===============================================================================\n\
    \nFinished in 0.008186983 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 3 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    122.15 tests/s, 366.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4ih5wvox\nStarted\n.\nFinished in 0.000513555 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1947.21 tests/s, 9736.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp1h9kton\nStarted\n.\nFinished in 0.000638994 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1564.96 tests/s, 7824.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value\n  elsif value % 1 > 0.5\n    value.ceil\n  else\n    value.floor\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_closest_integer\n    candidate = method(:closest_integer)\n    assert_equal(10,\
    \ candidate.call(\"10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n  \
    \  assert_equal(-16, candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"\
    15.3\"))\n    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpz8l_99k5\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpz8l_99k5.rb:29:in `test_closest_integer'\n\
    \     26:   def test_closest_integer\n     27:     candidate = method(:closest_integer)\n\
    \     28:     assert_equal(10, candidate.call(\"10\"))\n  => 29:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     30:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     31:     assert_equal(15, candidate.call(\"15.3\"))\n     32: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.014322676 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    69.82 tests/s, 139.64 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2mt1kmap\nStarted\n.\nFinished in 0.000685502 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1458.78 tests/s, 7293.92 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjsvr5y1a\nStarted\n.\nFinished in 0.001128826 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    885.88 tests/s, 4429.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ < 0\n    value = value.ceil\n  else\n    value = value.floor\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpc6u420wz\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmpc6u420wz.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14>\n\ndiff:\n\
    ? 15\n?  4\n===============================================================================\n\
    \nFinished in 0.009764107 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    102.42 tests/s, 204.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpigvav3mp\nStarted\n.\nFinished in 0.000830634 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1203.90 tests/s, 6019.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2ogxaura\nStarted\n.\nFinished in 0.000625909 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1597.68 tests/s, 7988.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4mtfjdie\nStarted\n.\nFinished in 0.000586857 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1703.99 tests/s, 8519.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvrhhz_o8\nStarted\n.\nFinished in 0.000599007 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1669.43 tests/s, 8347.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_l76yc9v\nStarted\n.\nFinished in 0.000735353 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1359.89 tests/s, 6799.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyxh3lq_z\nStarted\n.\nFinished in 0.00079139 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1263.60 tests/s, 6318.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp72jbz3m_\nStarted\n.\nFinished in 0.001441775 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    693.59 tests/s, 3467.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6gttgopk\nStarted\n.\nFinished in 0.001323563 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    755.54 tests/s, 3777.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value.round\
    \ == value\n    value.round\n  else\n    value.round(1)\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_phdehch\nStarted\nF\n===============================================================================\n\
    Failure: test_closest_integer(TestHumanEval)\n/tmp/tmp_phdehch.rb:27:in `test_closest_integer'\n\
    \     24:   def test_closest_integer\n     25:     candidate = method(:closest_integer)\n\
    \     26:     assert_equal(10, candidate.call(\"10\"))\n  => 27:     assert_equal(15,\
    \ candidate.call(\"14.5\"))\n     28:     assert_equal(-16, candidate.call(\"\
    -15.5\"))\n     29:     assert_equal(15, candidate.call(\"15.3\"))\n     30: \
    \    assert_equal(0, candidate.call(\"0\"))\n<15> expected but was\n<14.5>\n\n\
    diff:\n? 14.5\n===============================================================================\n\
    \nFinished in 0.012403506 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    80.62 tests/s, 161.24 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqb7b9q5m\nStarted\n.\nFinished in 0.0004838 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2066.97 tests/s, 10334.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdeug2hho\nStarted\n.\nFinished in 0.000489371 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2043.44 tests/s, 10217.20 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5tdkcyi6\nStarted\n.\nFinished in 0.000519154 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1926.21 tests/s, 9631.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnf3q63gv\nStarted\n.\nFinished in 0.00079777 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1253.49 tests/s, 6267.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value = value.to_f\n  if value\
    \ % 1 == 0\n    value.to_i\n  else\n    value.round\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n    candidate\
    \ = method(:closest_integer)\n    assert_equal(10, candidate.call(\"10\"))\n \
    \   assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16, candidate.call(\"\
    -15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n    assert_equal(0,\
    \ candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxauqygbi\nStarted\n.\nFinished in 0.000500327 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1998.69 tests/s, 9993.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr7c9ekke\nStarted\n.\nFinished in 0.000521398 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1917.92 tests/s, 9589.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqw68zh1e\nStarted\n.\nFinished in 0.000475653 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2102.37 tests/s, 10511.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8p7l2rs0\nStarted\n.\nFinished in 0.000563415 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1774.89 tests/s, 8874.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Create a function that takes a value (string) representing a number\n\
    # and returns the closest integer to it. If the number is equidistant\n# from\
    \ two integers, round it away from zero.\n# Examples\n# >>> closest_integer(\"\
    10\")\n# 10\n# >>> closest_integer(\"15.3\")\n# 15\n# Note:\n# Rounding away from\
    \ zero means that if the given number is equidistant\n# from two integers, the\
    \ one you should return is the one that is the\n# farthest from zero. For example\
    \ closest_integer(\"14.5\") should\n# return 15 and closest_integer(\"-14.5\"\
    ) should return -15.\ndef closest_integer(value)\n  value.to_f.round\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_closest_integer\n\
    \    candidate = method(:closest_integer)\n    assert_equal(10, candidate.call(\"\
    10\"))\n    assert_equal(15, candidate.call(\"14.5\"))\n    assert_equal(-16,\
    \ candidate.call(\"-15.5\"))\n    assert_equal(15, candidate.call(\"15.3\"))\n\
    \    assert_equal(0, candidate.call(\"0\"))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3myerklk\nStarted\n.\nFinished in 0.000449471 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 5 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2224.84 tests/s, 11124.19 assertions/s\n"
  exit_code: 0
  status: OK
