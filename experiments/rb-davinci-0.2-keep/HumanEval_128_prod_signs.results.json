{
  "name": "HumanEval_128_prod_signs",
  "language": "ruby",
  "results": [
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdnji8x6v\nStarted\n.\nFinished in 0.000926044 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1079.86 tests/s, 8638.90 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpo8g0i3x8\nStarted\n.\nFinished in 0.000534915 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1869.46 tests/s, 14955.65 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpj3do1yul\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpj3do1yul.rb:11:in `block in prod_signs'\n/tmp/tmpj3do1yul.rb:11:in `map'\n/tmp/tmpj3do1yul.rb:11:in `prod_signs'\n/tmp/tmpj3do1yul.rb:17:in `call'\n/tmp/tmpj3do1yul.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.009020496 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n110.86 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmplnymyw33\nStarted\n.\nFinished in 0.000742789 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1346.28 tests/s, 10770.22 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpye92vfab\nStarted\n.\nFinished in 0.000548817 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1822.10 tests/s, 14576.81 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpsgy5wgs3\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpsgy5wgs3.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.013676592 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n73.12 tests/s, 73.12 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmptsljzmle\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmptsljzmle.rb:11:in `block in prod_signs'\n/tmp/tmptsljzmle.rb:11:in `map'\n/tmp/tmptsljzmle.rb:11:in `prod_signs'\n/tmp/tmptsljzmle.rb:17:in `call'\n/tmp/tmptsljzmle.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.011404916 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n87.68 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6vnecmoy\nStarted\n.\nFinished in 0.000952811 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1049.53 tests/s, 8396.21 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp37y6uoo7\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp37y6uoo7.rb:11:in `block in prod_signs'\n/tmp/tmp37y6uoo7.rb:11:in `map'\n/tmp/tmp37y6uoo7.rb:11:in `prod_signs'\n/tmp/tmp37y6uoo7.rb:17:in `call'\n/tmp/tmp37y6uoo7.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008062692 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n124.03 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp86h5gxua\nStarted\n.\nFinished in 0.00093525 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1069.23 tests/s, 8553.86 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp0b5qzsp7\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp0b5qzsp7.rb:11:in `block in prod_signs'\n/tmp/tmp0b5qzsp7.rb:11:in `map'\n/tmp/tmp0b5qzsp7.rb:11:in `prod_signs'\n/tmp/tmp0b5qzsp7.rb:17:in `call'\n/tmp/tmp0b5qzsp7.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.003996617 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n250.21 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp96jj9vyb\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp96jj9vyb.rb:11:in `block in prod_signs'\n/tmp/tmp96jj9vyb.rb:11:in `map'\n/tmp/tmp96jj9vyb.rb:11:in `prod_signs'\n/tmp/tmp96jj9vyb.rb:17:in `call'\n/tmp/tmp96jj9vyb.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007423213 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n134.71 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6qz53fuk\nStarted\n.\nFinished in 0.001647652 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n606.92 tests/s, 4855.39 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp927gnkba\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp927gnkba.rb:11:in `block in prod_signs'\n/tmp/tmp927gnkba.rb:11:in `map'\n/tmp/tmp927gnkba.rb:11:in `prod_signs'\n/tmp/tmp927gnkba.rb:17:in `call'\n/tmp/tmp927gnkba.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.009583545 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n104.35 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpj8b8uesi\nStarted\n.\nFinished in 0.000644077 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1552.61 tests/s, 12420.88 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpvwuds1j0\nStarted\n.\nFinished in 0.000626076 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1597.25 tests/s, 12778.00 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  if arr.empty?\n    return nil\n  end\n  product = 1\n  sum = 0\n  arr.each do |num|\n    if num > 0\n      product *= 1\n      sum += num\n    elsif num < 0\n      product *= -1\n      sum += num.abs\n    end\n  end\n  sum * product\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpzsgqon_y\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpzsgqon_y.rb:31:in `test_prod_signs'\n     28:   def test_prod_signs\n     29:     candidate = method(:prod_signs)\n     30:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n  => 31:     assert_equal(0, candidate.call([0, 1]))\n     32:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     33:     assert_equal(nil, candidate.call([]))\n     34:     assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n<0> expected but was\n<1>\n===============================================================================\n\nFinished in 0.008066124 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n123.98 tests/s, 247.95 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp6r8iha53\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp6r8iha53.rb:11:in `block in prod_signs'\n/tmp/tmp6r8iha53.rb:11:in `map'\n/tmp/tmp6r8iha53.rb:11:in `prod_signs'\n/tmp/tmp6r8iha53.rb:17:in `call'\n/tmp/tmp6r8iha53.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.012622511 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n79.22 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp8ma6hvhn\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp8ma6hvhn.rb:11:in `block in prod_signs'\n/tmp/tmp8ma6hvhn.rb:11:in `map'\n/tmp/tmp8ma6hvhn.rb:11:in `prod_signs'\n/tmp/tmp8ma6hvhn.rb:17:in `call'\n/tmp/tmp8ma6hvhn.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004412725 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n226.62 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpnv8u_a6v\nStarted\n.\nFinished in 0.000800377 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1249.41 tests/s, 9995.29 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpss1btldd\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpss1btldd.rb:11:in `block in prod_signs'\n/tmp/tmpss1btldd.rb:11:in `map'\n/tmp/tmpss1btldd.rb:11:in `prod_signs'\n/tmp/tmpss1btldd.rb:17:in `call'\n/tmp/tmpss1btldd.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004097602 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n244.05 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpezvloa7j\nStarted\n.\nFinished in 0.000579152 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1726.66 tests/s, 13813.30 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp56ydkb1h\nStarted\n.\nFinished in 0.000655231 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1526.18 tests/s, 12209.43 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpftk0hagg\nStarted\n.\nFinished in 0.000623156 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1604.73 tests/s, 12837.88 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpz65qa9g2\nStarted\n.\nFinished in 0.000718442 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1391.90 tests/s, 11135.21 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxy6cjzzt\nStarted\n.\nFinished in 0.000567157 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1763.18 tests/s, 14105.44 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpf19elzc_\nStarted\n.\nFinished in 0.000617855 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1618.50 tests/s, 12948.02 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7lm85xkr\nStarted\n.\nFinished in 0.001316416 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n759.64 tests/s, 6077.11 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp33n6muxe\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp33n6muxe.rb:11:in `block in prod_signs'\n/tmp/tmp33n6muxe.rb:11:in `map'\n/tmp/tmp33n6muxe.rb:11:in `prod_signs'\n/tmp/tmp33n6muxe.rb:17:in `call'\n/tmp/tmp33n6muxe.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008138091 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n122.88 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpf6jb10jf\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpf6jb10jf.rb:11:in `block in prod_signs'\n/tmp/tmpf6jb10jf.rb:11:in `map'\n/tmp/tmpf6jb10jf.rb:11:in `prod_signs'\n/tmp/tmpf6jb10jf.rb:17:in `call'\n/tmp/tmpf6jb10jf.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008664108 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n115.42 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmprlbmekur\nStarted\n.\nFinished in 0.000924614 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1081.53 tests/s, 8652.26 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpj1bfc202\nStarted\n.\nFinished in 0.001027756 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n972.99 tests/s, 7783.95 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpeyoqlb5t\nStarted\n.\nFinished in 0.001395767 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n716.45 tests/s, 5731.62 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpfum8b04x\nStarted\n.\nFinished in 0.000591496 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1690.63 tests/s, 13525.03 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpiiprjv88\nStarted\n.\nFinished in 0.000646848 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1545.96 tests/s, 12367.67 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqg9wyb3j\nStarted\n.\nFinished in 0.000647224 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1545.06 tests/s, 12360.48 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmptyfu3u4h\nStarted\n.\nFinished in 0.00076503 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1307.14 tests/s, 10457.11 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpukzyifzx\nStarted\n.\nFinished in 0.001135167 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n880.93 tests/s, 7047.42 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqmu6zf2a\nStarted\n.\nFinished in 0.001442935 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n693.03 tests/s, 5544.26 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpwgufmlag\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpwgufmlag.rb:11:in `block in prod_signs'\n/tmp/tmpwgufmlag.rb:11:in `map'\n/tmp/tmpwgufmlag.rb:11:in `prod_signs'\n/tmp/tmpwgufmlag.rb:17:in `call'\n/tmp/tmpwgufmlag.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007109598 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.65 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map(&:abs).reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxj5h1yzy\nStarted\n.\nFinished in 0.000934062 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1070.59 tests/s, 8564.74 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmph4_0ujhp\nStarted\n.\nFinished in 0.000772993 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1293.67 tests/s, 10349.38 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpvx43lnp7\nStarted\n.\nFinished in 0.00081796 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1222.55 tests/s, 9780.43 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmppv0cnppg\nStarted\n.\nFinished in 0.000917344 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1090.10 tests/s, 8720.83 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp1a8g6w71\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp1a8g6w71.rb:11:in `block in prod_signs'\n/tmp/tmp1a8g6w71.rb:11:in `map'\n/tmp/tmp1a8g6w71.rb:11:in `prod_signs'\n/tmp/tmp1a8g6w71.rb:17:in `call'\n/tmp/tmp1a8g6w71.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007484526 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n133.61 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpapsc_syw\nStarted\n.\nFinished in 0.000743412 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1345.15 tests/s, 10761.19 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpll7z9w89\nStarted\n.\nFinished in 0.000610006 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1639.33 tests/s, 13114.63 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp50120rk7\nStarted\n.\nFinished in 0.000947795 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1055.08 tests/s, 8440.64 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp7k5t3qz4\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp7k5t3qz4.rb:11:in `block in prod_signs'\n/tmp/tmp7k5t3qz4.rb:11:in `map'\n/tmp/tmp7k5t3qz4.rb:11:in `prod_signs'\n/tmp/tmp7k5t3qz4.rb:17:in `call'\n/tmp/tmp7k5t3qz4.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.00663815 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n150.64 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmptm19bvy6\nStarted\n.\nFinished in 0.001137871 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n878.83 tests/s, 7030.67 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp380vd67v\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp380vd67v.rb:11:in `block in prod_signs'\n/tmp/tmp380vd67v.rb:11:in `map'\n/tmp/tmp380vd67v.rb:11:in `prod_signs'\n/tmp/tmp380vd67v.rb:17:in `call'\n/tmp/tmp380vd67v.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.006845366 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n146.08 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpu280snt4\nStarted\n.\nFinished in 0.000709585 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1409.27 tests/s, 11274.20 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmprrls62jo\nStarted\n.\nFinished in 0.001042324 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n959.39 tests/s, 7675.16 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4fdhe3v6\nStarted\n.\nFinished in 0.000799381 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1250.97 tests/s, 10007.74 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpup9dgr5u\nStarted\n.\nFinished in 0.000633938 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1577.44 tests/s, 12619.53 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmps2u8evk9\nStarted\n.\nFinished in 0.00117286 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n852.62 tests/s, 6820.93 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmppsis8e90\nStarted\n.\nFinished in 0.001299861 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n769.31 tests/s, 6154.50 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpy4l9j94q\nStarted\n.\nFinished in 0.000912879 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1095.44 tests/s, 8763.48 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_wvm0w2k\nStarted\n.\nFinished in 0.001378395 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n725.48 tests/s, 5803.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpo0xh5b7q\nStarted\n.\nFinished in 0.00119785 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n834.83 tests/s, 6678.63 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp2azib967\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp2azib967.rb:11:in `block in prod_signs'\n/tmp/tmp2azib967.rb:11:in `map'\n/tmp/tmp2azib967.rb:11:in `prod_signs'\n/tmp/tmp2azib967.rb:17:in `call'\n/tmp/tmp2azib967.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.00820105 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n121.94 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmptblmxare\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmptblmxare.rb:11:in `block in prod_signs'\n/tmp/tmptblmxare.rb:11:in `map'\n/tmp/tmptblmxare.rb:11:in `prod_signs'\n/tmp/tmptblmxare.rb:17:in `call'\n/tmp/tmptblmxare.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004667394 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n214.25 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpzjgtp0_f\nStarted\n.\nFinished in 0.000888404 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1125.61 tests/s, 9004.91 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpsg0583vl\nStarted\n.\nFinished in 0.000869127 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1150.58 tests/s, 9204.64 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpfd7nfe3o\nStarted\n.\nFinished in 0.000748731 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1335.59 tests/s, 10684.75 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpy7aqik19\nStarted\n.\nFinished in 0.000621498 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1609.02 tests/s, 12872.13 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpf5yaxnck\nStarted\n.\nFinished in 0.001185535 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n843.50 tests/s, 6748.01 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp9rcfnqu3\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmp9rcfnqu3.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.00775342 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n128.98 tests/s, 128.98 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpkq5x2kat\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpkq5x2kat.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.013592244 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n73.57 tests/s, 73.57 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpij1lsl9q\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpij1lsl9q.rb:11:in `block in prod_signs'\n/tmp/tmpij1lsl9q.rb:11:in `map'\n/tmp/tmpij1lsl9q.rb:11:in `prod_signs'\n/tmp/tmpij1lsl9q.rb:17:in `call'\n/tmp/tmpij1lsl9q.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.003855839 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n259.35 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpc29n3zjx\nStarted\n.\nFinished in 0.000699118 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1430.37 tests/s, 11442.99 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5sbu0_gv\nStarted\n.\nFinished in 0.001320436 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n757.33 tests/s, 6058.60 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpef2m719q\nStarted\n.\nFinished in 0.001522665 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n656.74 tests/s, 5253.95 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp12w6fysx\nStarted\n.\nFinished in 0.000579261 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1726.34 tests/s, 13810.70 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpr09bna6f\nStarted\n.\nFinished in 0.00068959 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1450.14 tests/s, 11601.10 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp1x7x37xv\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmp1x7x37xv.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007967808 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.51 tests/s, 125.51 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmprnk8t5tr\nStarted\n.\nFinished in 0.000846003 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1182.03 tests/s, 9456.23 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpwxpk25xd\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpwxpk25xd.rb:11:in `block in prod_signs'\n/tmp/tmpwxpk25xd.rb:11:in `map'\n/tmp/tmpwxpk25xd.rb:11:in `prod_signs'\n/tmp/tmpwxpk25xd.rb:17:in `call'\n/tmp/tmpwxpk25xd.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.011400889 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n87.71 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpcs7n04qq\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpcs7n04qq.rb:11:in `block in prod_signs'\n/tmp/tmpcs7n04qq.rb:11:in `map'\n/tmp/tmpcs7n04qq.rb:11:in `prod_signs'\n/tmp/tmpcs7n04qq.rb:17:in `call'\n/tmp/tmpcs7n04qq.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005341173 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n187.22 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmptp_z194c\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmptp_z194c.rb:11:in `block in prod_signs'\n/tmp/tmptp_z194c.rb:11:in `map'\n/tmp/tmptp_z194c.rb:11:in `prod_signs'\n/tmp/tmptp_z194c.rb:17:in `call'\n/tmp/tmptp_z194c.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005410394 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n184.83 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  prod = 1\n  sum = 0\n  arr.each do |num|\n    prod *= num.sign\n    sum += num.abs\n  end\n  prod * sum\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpkh7wzxj3\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpkh7wzxj3.rb:14:in `block in prod_signs'\n/tmp/tmpkh7wzxj3.rb:13:in `each'\n/tmp/tmpkh7wzxj3.rb:13:in `prod_signs'\n/tmp/tmpkh7wzxj3.rb:23:in `call'\n/tmp/tmpkh7wzxj3.rb:23:in `test_prod_signs'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_prod_signs\n     22:     candidate = method(:prod_signs)\n  => 23:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     24:     assert_equal(0, candidate.call([0, 1]))\n     25:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     26:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.00489193 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n204.42 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpg8eoovgm\nStarted\n.\nFinished in 0.000812259 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1231.13 tests/s, 9849.08 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpd2w2pxmp\nStarted\n.\nFinished in 0.000946058 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1057.02 tests/s, 8456.14 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpet29mian\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpet29mian.rb:11:in `block in prod_signs'\n/tmp/tmpet29mian.rb:11:in `map'\n/tmp/tmpet29mian.rb:11:in `prod_signs'\n/tmp/tmpet29mian.rb:17:in `call'\n/tmp/tmpet29mian.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005644033 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n177.18 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpfi8esr8o\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpfi8esr8o.rb:11:in `block in prod_signs'\n/tmp/tmpfi8esr8o.rb:11:in `map'\n/tmp/tmpfi8esr8o.rb:11:in `prod_signs'\n/tmp/tmpfi8esr8o.rb:17:in `call'\n/tmp/tmpfi8esr8o.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004224357 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n236.72 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpcw__1n2g\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpcw__1n2g.rb:11:in `block in prod_signs'\n/tmp/tmpcw__1n2g.rb:11:in `map'\n/tmp/tmpcw__1n2g.rb:11:in `prod_signs'\n/tmp/tmpcw__1n2g.rb:17:in `call'\n/tmp/tmpcw__1n2g.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.010144793 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n98.57 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmbnp0b7d\nStarted\n.\nFinished in 0.000944036 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1059.28 tests/s, 8474.25 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp12qw8hct\nStarted\n.\nFinished in 0.001003997 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n996.02 tests/s, 7968.15 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_t6i0ect\nStarted\n.\nFinished in 0.000889392 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1124.36 tests/s, 8994.91 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5cou4a3a\nStarted\n.\nFinished in 0.001649967 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n606.07 tests/s, 4848.58 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpw_9s42gj\nStarted\n.\nFinished in 0.000594728 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1681.44 tests/s, 13451.53 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpolgk45cb\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpolgk45cb.rb:11:in `block in prod_signs'\n/tmp/tmpolgk45cb.rb:11:in `map'\n/tmp/tmpolgk45cb.rb:11:in `prod_signs'\n/tmp/tmpolgk45cb.rb:17:in `call'\n/tmp/tmpolgk45cb.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004074727 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n245.42 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp8lltu_mz\nStarted\n.\nFinished in 0.000991222 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1008.86 tests/s, 8070.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpak72htgi\nStarted\n.\nFinished in 0.001325095 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n754.66 tests/s, 6037.30 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp8pdjh2ge\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp8pdjh2ge.rb:11:in `block in prod_signs'\n/tmp/tmp8pdjh2ge.rb:11:in `map'\n/tmp/tmp8pdjh2ge.rb:11:in `prod_signs'\n/tmp/tmp8pdjh2ge.rb:17:in `call'\n/tmp/tmp8pdjh2ge.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.006416806 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n155.84 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmzeylzqp\nStarted\n.\nFinished in 0.001434985 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n696.87 tests/s, 5574.97 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num.zero? ? 1 : num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpzw6hogmm\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpzw6hogmm.rb:11:in `block in prod_signs'\n/tmp/tmpzw6hogmm.rb:11:in `map'\n/tmp/tmpzw6hogmm.rb:11:in `prod_signs'\n/tmp/tmpzw6hogmm.rb:17:in `call'\n/tmp/tmpzw6hogmm.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004463157 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n224.06 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp819zlbvk\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp819zlbvk.rb:11:in `block in prod_signs'\n/tmp/tmp819zlbvk.rb:11:in `map'\n/tmp/tmp819zlbvk.rb:11:in `prod_signs'\n/tmp/tmp819zlbvk.rb:17:in `call'\n/tmp/tmp819zlbvk.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005428605 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n184.21 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpao4__5xy\nStarted\n.\nFinished in 0.001627406 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n614.47 tests/s, 4915.80 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |i| i.abs }.reduce(:+) * arr.map { |i| i <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdqloli58\nStarted\n.\nFinished in 0.00074801 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1336.88 tests/s, 10695.04 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxks2pyyu\nStarted\n.\nFinished in 0.001157817 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n863.69 tests/s, 6909.55 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7da9w2gr\nStarted\n.\nFinished in 0.000715481 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1397.66 tests/s, 11181.29 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpc4aqkz3h\nStarted\n.\nFinished in 0.000614204 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1628.12 tests/s, 13024.99 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpwl49jecw\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpwl49jecw.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007767464 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n128.74 tests/s, 128.74 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpplkaatey\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpplkaatey.rb:11:in `block in prod_signs'\n/tmp/tmpplkaatey.rb:11:in `map'\n/tmp/tmpplkaatey.rb:11:in `prod_signs'\n/tmp/tmpplkaatey.rb:17:in `call'\n/tmp/tmpplkaatey.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008049561 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n124.23 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmplwsgv0e4\nStarted\n.\nFinished in 0.000916582 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1091.01 tests/s, 8728.08 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpy4j9hrv9\nStarted\n.\nFinished in 0.000778415 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1284.66 tests/s, 10277.29 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpg70b9mw0\nStarted\n.\nFinished in 0.000844794 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1183.72 tests/s, 9469.76 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpk0djodkl\nStarted\n.\nFinished in 0.000788418 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1268.36 tests/s, 10146.90 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpfwaf7slu\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpfwaf7slu.rb:11:in `block in prod_signs'\n/tmp/tmpfwaf7slu.rb:11:in `map'\n/tmp/tmpfwaf7slu.rb:11:in `prod_signs'\n/tmp/tmpfwaf7slu.rb:17:in `call'\n/tmp/tmpfwaf7slu.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008746722 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n114.33 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5tmd1hf7\nStarted\n.\nFinished in 0.000935717 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1068.70 tests/s, 8549.59 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpbnbk23gs\nStarted\n.\nFinished in 0.00081099 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1233.06 tests/s, 9864.49 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5ynx2lql\nStarted\n.\nFinished in 0.00086525 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1155.74 tests/s, 9245.88 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpwnouavrx\nStarted\n.\nFinished in 0.000938605 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1065.41 tests/s, 8523.29 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpokg49mhg\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpokg49mhg.rb:11:in `block in prod_signs'\n/tmp/tmpokg49mhg.rb:11:in `map'\n/tmp/tmpokg49mhg.rb:11:in `prod_signs'\n/tmp/tmpokg49mhg.rb:17:in `call'\n/tmp/tmpokg49mhg.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005094939 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n196.27 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmppej43_x0\nStarted\n.\nFinished in 0.001258811 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n794.40 tests/s, 6355.20 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp2j9_qjw_\nStarted\n.\nFinished in 0.00073992 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1351.50 tests/s, 10811.98 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpy_4r2e39\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpy_4r2e39.rb:11:in `block in prod_signs'\n/tmp/tmpy_4r2e39.rb:11:in `map'\n/tmp/tmpy_4r2e39.rb:11:in `prod_signs'\n/tmp/tmpy_4r2e39.rb:17:in `call'\n/tmp/tmpy_4r2e39.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008468493 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n118.08 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp54im6bzd\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp54im6bzd.rb:11:in `block in prod_signs'\n/tmp/tmp54im6bzd.rb:11:in `map'\n/tmp/tmp54im6bzd.rb:11:in `prod_signs'\n/tmp/tmp54im6bzd.rb:17:in `call'\n/tmp/tmp54im6bzd.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004032895 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n247.96 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpnbl8ke9v\nStarted\n.\nFinished in 0.001401834 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n713.35 tests/s, 5706.81 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpp25_oi5t\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpp25_oi5t.rb:11:in `block in prod_signs'\n/tmp/tmpp25_oi5t.rb:11:in `map'\n/tmp/tmpp25_oi5t.rb:11:in `prod_signs'\n/tmp/tmpp25_oi5t.rb:17:in `call'\n/tmp/tmpp25_oi5t.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.003798874 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n263.24 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp8ymaibo4\nStarted\n.\nFinished in 0.001137425 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n879.18 tests/s, 7033.43 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp8ib9tag_\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp8ib9tag_.rb:11:in `block in prod_signs'\n/tmp/tmp8ib9tag_.rb:11:in `map'\n/tmp/tmp8ib9tag_.rb:11:in `prod_signs'\n/tmp/tmp8ib9tag_.rb:17:in `call'\n/tmp/tmp8ib9tag_.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.00832237 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n120.16 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpa9orf6ef\nStarted\n.\nFinished in 0.001420246 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n704.10 tests/s, 5632.83 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp9jkofe75\nStarted\n.\nFinished in 0.000988539 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1011.59 tests/s, 8092.75 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpo8sok0tg\nStarted\n.\nFinished in 0.000578586 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1728.35 tests/s, 13826.81 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpmm1tbfvv\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpmm1tbfvv.rb:11:in `block in prod_signs'\n/tmp/tmpmm1tbfvv.rb:11:in `map'\n/tmp/tmpmm1tbfvv.rb:11:in `prod_signs'\n/tmp/tmpmm1tbfvv.rb:17:in `call'\n/tmp/tmpmm1tbfvv.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007032295 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n142.20 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpj4ezb618\nStarted\n.\nFinished in 0.00094064 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1063.11 tests/s, 8504.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp46gj1i0e\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp46gj1i0e.rb:11:in `block in prod_signs'\n/tmp/tmp46gj1i0e.rb:11:in `map'\n/tmp/tmp46gj1i0e.rb:11:in `prod_signs'\n/tmp/tmp46gj1i0e.rb:17:in `call'\n/tmp/tmp46gj1i0e.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004008927 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n249.44 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpb6ns4y0o\nStarted\n.\nFinished in 0.000681958 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1466.37 tests/s, 11730.93 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  if arr.empty?\n    return nil\n  end\n  sum = 0\n  prod = 1\n  arr.each do |num|\n    if num > 0\n      prod *= 1\n      sum += num\n    elsif num < 0\n      prod *= -1\n      sum += num.abs\n    end\n  end\n  sum * prod\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpxd8i1ow9\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpxd8i1ow9.rb:31:in `test_prod_signs'\n     28:   def test_prod_signs\n     29:     candidate = method(:prod_signs)\n     30:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n  => 31:     assert_equal(0, candidate.call([0, 1]))\n     32:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     33:     assert_equal(nil, candidate.call([]))\n     34:     assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n<0> expected but was\n<1>\n===============================================================================\n\nFinished in 0.009551579 seconds.\n-------------------------------------------------------------------------------\n1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n104.69 tests/s, 209.39 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdn767_8o\nStarted\n.\nFinished in 0.000568695 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1758.41 tests/s, 14067.29 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpgjf_i29c\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpgjf_i29c.rb:11:in `block in prod_signs'\n/tmp/tmpgjf_i29c.rb:11:in `map'\n/tmp/tmpgjf_i29c.rb:11:in `prod_signs'\n/tmp/tmpgjf_i29c.rb:17:in `call'\n/tmp/tmpgjf_i29c.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.011505062 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n86.92 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp2ln3cbw9\nStarted\n.\nFinished in 0.000726555 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1376.36 tests/s, 11010.87 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpff2y41nc\nStarted\n.\nFinished in 0.000652339 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1532.95 tests/s, 12263.56 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp7k_7f682\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp7k_7f682.rb:11:in `block in prod_signs'\n/tmp/tmp7k_7f682.rb:11:in `map'\n/tmp/tmp7k_7f682.rb:11:in `prod_signs'\n/tmp/tmp7k_7f682.rb:17:in `call'\n/tmp/tmp7k_7f682.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.008491756 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n117.76 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpc03suf4b\nStarted\n.\nFinished in 0.001816736 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n550.44 tests/s, 4403.50 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp67ll0g5w\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmp67ll0g5w.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.010751643 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n93.01 tests/s, 93.01 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpw0t03jww\nStarted\n.\nFinished in 0.000628202 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1591.84 tests/s, 12734.76 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxn_1tewb\nStarted\n.\nFinished in 0.00061909 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1615.27 tests/s, 12922.19 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7jcqgwm8\nStarted\n.\nFinished in 0.00082431 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1213.14 tests/s, 9705.09 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpj8t8809o\nStarted\n.\nFinished in 0.00084816 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1179.02 tests/s, 9432.18 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_sct4a8n\nStarted\n.\nFinished in 0.000687142 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1455.30 tests/s, 11642.43 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp1dsmvofm\nStarted\n.\nFinished in 0.00120897 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n827.15 tests/s, 6617.20 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpu6lkqdx7\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpu6lkqdx7.rb:11:in `block in prod_signs'\n/tmp/tmpu6lkqdx7.rb:11:in `map'\n/tmp/tmpu6lkqdx7.rb:11:in `prod_signs'\n/tmp/tmpu6lkqdx7.rb:17:in `call'\n/tmp/tmpu6lkqdx7.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004197924 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n238.21 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp9lvr05bz\nStarted\n.\nFinished in 0.000931221 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1073.86 tests/s, 8590.87 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp5ninc4ll\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmp5ninc4ll.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.007294537 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n137.09 tests/s, 137.09 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6snenkl8\nStarted\n.\nFinished in 0.000621072 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1610.12 tests/s, 12880.95 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpu9d1dakd\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpu9d1dakd.rb:11:in `block in prod_signs'\n/tmp/tmpu9d1dakd.rb:11:in `map'\n/tmp/tmpu9d1dakd.rb:11:in `prod_signs'\n/tmp/tmpu9d1dakd.rb:17:in `call'\n/tmp/tmpu9d1dakd.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007218737 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n138.53 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpl6bnj2iw\nStarted\n.\nFinished in 0.000885993 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1128.68 tests/s, 9029.42 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.sum * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmphchc8hdq\nStarted\n.\nFinished in 0.001062066 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n941.56 tests/s, 7532.49 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpprd02cg4\nStarted\n.\nFinished in 0.00060247 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1659.83 tests/s, 13278.67 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5rgzeylf\nStarted\n.\nFinished in 0.000809938 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1234.66 tests/s, 9877.30 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpkrn22gxq\nStarted\n.\nFinished in 0.000806323 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1240.20 tests/s, 9921.58 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_6st61be\nStarted\n.\nFinished in 0.001435259 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n696.74 tests/s, 5573.91 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqcwlh326\nStarted\n.\nFinished in 0.001233536 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n810.68 tests/s, 6485.42 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp64x_tf21\nStarted\n.\nFinished in 0.00107034 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n934.28 tests/s, 7474.26 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpeig4myls\nStarted\n.\nFinished in 0.000817918 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1222.62 tests/s, 9780.93 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp1t2uphs2\nStarted\n.\nFinished in 0.000890175 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1123.37 tests/s, 8987.00 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpy9i7gq62\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpy9i7gq62.rb:11:in `block in prod_signs'\n/tmp/tmpy9i7gq62.rb:11:in `map'\n/tmp/tmpy9i7gq62.rb:11:in `prod_signs'\n/tmp/tmpy9i7gq62.rb:17:in `call'\n/tmp/tmpy9i7gq62.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.006534029 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n153.04 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpq4j83_u0\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpq4j83_u0.rb:11:in `block in prod_signs'\n/tmp/tmpq4j83_u0.rb:11:in `map'\n/tmp/tmpq4j83_u0.rb:11:in `prod_signs'\n/tmp/tmpq4j83_u0.rb:17:in `call'\n/tmp/tmpq4j83_u0.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.006410362 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n156.00 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpviwncnk0\nStarted\n.\nFinished in 0.000920025 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1086.93 tests/s, 8695.42 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpuredyy8r\nStarted\n.\nFinished in 0.00110453 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n905.36 tests/s, 7242.90 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_s2esngm\nStarted\n.\nFinished in 0.001129656 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n885.23 tests/s, 7081.80 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpse3k0lyn\nStarted\n.\nFinished in 0.000822306 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1216.09 tests/s, 9728.74 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp7ru47dyr\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp7ru47dyr.rb:11:in `block in prod_signs'\n/tmp/tmp7ru47dyr.rb:11:in `map'\n/tmp/tmp7ru47dyr.rb:11:in `prod_signs'\n/tmp/tmp7ru47dyr.rb:17:in `call'\n/tmp/tmp7ru47dyr.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.01058253 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n94.50 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpz7v3wmt_\nStarted\n.\nFinished in 0.001098029 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n910.72 tests/s, 7285.78 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpvfpvcrei\nStarted\n.\nFinished in 0.000833928 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1199.14 tests/s, 9593.15 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpk5odobvp\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpk5odobvp.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.010611081 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n94.24 tests/s, 94.24 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp6gva64_h\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmp6gva64_h.rb:11:in `block in prod_signs'\n/tmp/tmp6gva64_h.rb:11:in `map'\n/tmp/tmp6gva64_h.rb:11:in `prod_signs'\n/tmp/tmp6gva64_h.rb:17:in `call'\n/tmp/tmp6gva64_h.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.010328829 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n96.82 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpk5ya2bg2\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpk5ya2bg2.rb:11:in `block in prod_signs'\n/tmp/tmpk5ya2bg2.rb:11:in `map'\n/tmp/tmpk5ya2bg2.rb:11:in `prod_signs'\n/tmp/tmpk5ya2bg2.rb:17:in `call'\n/tmp/tmpk5ya2bg2.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004832318 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n206.94 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpw89gjy_4\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpw89gjy_4.rb:11:in `block in prod_signs'\n/tmp/tmpw89gjy_4.rb:11:in `map'\n/tmp/tmpw89gjy_4.rb:11:in `prod_signs'\n/tmp/tmpw89gjy_4.rb:17:in `call'\n/tmp/tmpw89gjy_4.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007784649 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n128.46 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpt6lz4k_l\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpt6lz4k_l.rb:11:in `block in prod_signs'\n/tmp/tmpt6lz4k_l.rb:11:in `map'\n/tmp/tmpt6lz4k_l.rb:11:in `prod_signs'\n/tmp/tmpt6lz4k_l.rb:17:in `call'\n/tmp/tmpt6lz4k_l.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004736377 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n211.13 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqcz3vhxn\nStarted\n.\nFinished in 0.000621314 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1609.49 tests/s, 12875.94 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.reduce(1) { |a, e| a * e.sign }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpclxau566\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpclxau566.rb:11:in `block in prod_signs'\n/tmp/tmpclxau566.rb:11:in `each'\n/tmp/tmpclxau566.rb:11:in `reduce'\n/tmp/tmpclxau566.rb:11:in `prod_signs'\n/tmp/tmpclxau566.rb:17:in `call'\n/tmp/tmpclxau566.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.007968193 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.50 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpwv1n_56t\nStarted\n.\nFinished in 0.000911441 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1097.16 tests/s, 8777.31 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpngws0ycb\nStarted\n.\nFinished in 0.001013551 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n986.63 tests/s, 7893.04 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpr47g2eda\nStarted\nF\n===============================================================================\nFailure: test_prod_signs(TestHumanEval)\n/tmp/tmpr47g2eda.rb:16:in `test_prod_signs'\n     13: class TestHumanEval < Test::Unit::TestCase\n     14:   def test_prod_signs\n     15:     candidate = method(:prod_signs)\n  => 16:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     17:     assert_equal(0, candidate.call([0, 1]))\n     18:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     19:     assert_equal(nil, candidate.call([]))\n<-9> expected but was\n<nil>\n===============================================================================\n\nFinished in 0.01337585 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n74.76 tests/s, 74.76 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpx4z7r4dp\nStarted\n.\nFinished in 0.000921699 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1084.95 tests/s, 8679.62 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpyk7ujc8_\nStarted\n.\nFinished in 0.000863785 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1157.70 tests/s, 9261.56 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  prod = 1\n  sum = 0\n  arr.each do |num|\n    prod *= num <=> 0\n    sum += num.abs\n  end\n  prod * sum\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqdv77anm\nStarted\n.\nFinished in 0.001026855 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n973.85 tests/s, 7790.78 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpih8t4upv\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpih8t4upv.rb:11:in `block in prod_signs'\n/tmp/tmpih8t4upv.rb:11:in `map'\n/tmp/tmpih8t4upv.rb:11:in `prod_signs'\n/tmp/tmpih8t4upv.rb:17:in `call'\n/tmp/tmpih8t4upv.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.004439723 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n225.24 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpctejo36n\nStarted\n.\nFinished in 0.000885785 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1128.94 tests/s, 9031.54 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp9tmujeo_\nStarted\n.\nFinished in 0.000550618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1816.14 tests/s, 14529.13 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpk60trhqq\nStarted\n.\nFinished in 0.001208812 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n827.26 tests/s, 6618.07 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map { |num| num <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmppr5e57fh\nStarted\n.\nFinished in 0.001245413 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n802.95 tests/s, 6423.57 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp3ohp2z98\nStarted\n.\nFinished in 0.000958502 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1043.29 tests/s, 8346.36 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpcfmcwgrp\nStarted\n.\nFinished in 0.001287836 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n776.50 tests/s, 6211.97 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmps6z497__\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmps6z497__.rb:11:in `block in prod_signs'\n/tmp/tmps6z497__.rb:11:in `map'\n/tmp/tmps6z497__.rb:11:in `prod_signs'\n/tmp/tmps6z497__.rb:17:in `call'\n/tmp/tmps6z497__.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005045213 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n198.21 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmphyxzubxq\nStarted\n.\nFinished in 0.001085209 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n921.48 tests/s, 7371.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqfwfiavm\nStarted\n.\nFinished in 0.000798055 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1253.05 tests/s, 10024.37 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x.sign }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpk3hupzx8\nStarted\nE\n===============================================================================\nError: test_prod_signs(TestHumanEval): NoMethodError: undefined method `sign' for 1:Integer\n/tmp/tmpk3hupzx8.rb:11:in `block in prod_signs'\n/tmp/tmpk3hupzx8.rb:11:in `map'\n/tmp/tmpk3hupzx8.rb:11:in `prod_signs'\n/tmp/tmpk3hupzx8.rb:17:in `call'\n/tmp/tmpk3hupzx8.rb:17:in `test_prod_signs'\n     14: class TestHumanEval < Test::Unit::TestCase\n     15:   def test_prod_signs\n     16:     candidate = method(:prod_signs)\n  => 17:     assert_equal(-9, candidate.call([1, 2, 2, -4]))\n     18:     assert_equal(0, candidate.call([0, 1]))\n     19:     assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n     20:     assert_equal(nil, candidate.call([]))\n===============================================================================\n\nFinished in 0.005694488 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n175.61 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.reduce(:+) * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpcqo65hnl\nStarted\n.\nFinished in 0.000561633 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1780.52 tests/s, 14244.18 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdkptpgse\nStarted\n.\nFinished in 0.001304625 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n766.50 tests/s, 6132.03 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpm37tdj73\nStarted\n.\nFinished in 0.000505173 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1979.52 tests/s, 15836.16 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmt_b83g7\nStarted\n.\nFinished in 0.00070695 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1414.53 tests/s, 11316.22 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpvm23hrks\nStarted\n.\nFinished in 0.000661727 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1511.20 tests/s, 12089.58 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |e| e.abs }.sum * arr.map { |e| e <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_39wpbo2\nStarted\n.\nFinished in 0.000528591 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1891.82 tests/s, 15134.57 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.sum * arr.map { |n| n <=> 0 }.inject(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4bujpaqo\nStarted\n.\nFinished in 0.000526393 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1899.72 tests/s, 15197.77 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# You are given an array arr of integers and you need to return\n# sum of magnitudes of integers multiplied by product of all signs\n# of each number in the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n# >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([]) == None\ndef prod_signs(arr)\n  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2, 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1, 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20, candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1, 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0, candidate.call([-1, 1, 1, 0]))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpm8qfy_3x\nStarted\n.\nFinished in 0.000529523 seconds.\n-------------------------------------------------------------------------------\n1 tests, 8 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1888.49 tests/s, 15107.94 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}