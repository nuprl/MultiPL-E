{
  "name": "HumanEval_156_int_to_mini_roman",
  "language": "ruby",
  "results": [
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = ''\n  roman_numeral << 'm' * (number / 1000)\n  roman_numeral << 'd' * (number % 1000 / 500)\n  roman_numeral << 'c' * (number % 500 / 100)\n  roman_numeral << 'l' * (number % 100 / 50)\n  roman_numeral << 'x' * (number % 50 / 10)\n  roman_numeral << 'v' * (number % 10 / 5)\n  roman_numeral << 'i' * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp_516z1a4\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_516z1a4.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.011441471 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n87.40 tests/s, 87.40 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp6bc7yhw9\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp6bc7yhw9.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.012537717 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n79.76 tests/s, 79.76 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result = ''\n  roman_numerals.keys.reverse.each do |divisor|\n    quotient, modulus = number.divmod(divisor)\n    result << roman_numerals[divisor] * quotient\n    number = modulus\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpzy_9aihv\nStarted\n.\nFinished in 0.001228851 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n813.77 tests/s, 11392.76 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmposdikpeo\nStarted\n.\nFinished in 0.00075897 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1317.58 tests/s, 18446.05 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = \"\"\n  roman_numerals.each do |key, value|\n    while number >= key\n      result << value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7wbno5h1\nStarted\n.\nFinished in 0.001147006 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n871.84 tests/s, 12205.69 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  roman_numerals.keys.reverse.each_with_object('') do |key, result|\n    while number >= key\n      result << roman_numerals[key]\n      number -= key\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7ms760li\nStarted\n.\nFinished in 0.000798783 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1251.90 tests/s, 17526.66 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpncf0ovao\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpncf0ovao.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.017469997 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n57.24 tests/s, 57.24 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxrjc37p_\nStarted\n.\nFinished in 0.000887334 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1126.97 tests/s, 15777.60 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpw4zpvuxf\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpw4zpvuxf.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007569909 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n132.10 tests/s, 132.10 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpy6p5wq35\nStarted\n.\nFinished in 0.001618302 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n617.93 tests/s, 8651.04 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7gspe03h\nStarted\n.\nFinished in 0.000923583 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1082.74 tests/s, 15158.36 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmppkh9br_j\nStarted\n.\nFinished in 0.000742013 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1347.69 tests/s, 18867.59 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpf5thtalt\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpf5thtalt.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.00848877 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n117.80 tests/s, 117.80 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmprhmmwhot\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmprhmmwhot.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010928051 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n91.51 tests/s, 91.51 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpbu2txc5o\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpbu2txc5o.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007942342 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.91 tests/s, 125.91 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp05s5dauy\nStarted\n.\nFinished in 0.000812076 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1231.41 tests/s, 17239.77 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpbj2jqmd5\nStarted\n.\nFinished in 0.0006431 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1554.97 tests/s, 21769.55 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_298h1pi\nStarted\n.\nFinished in 0.001264161 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n791.04 tests/s, 11074.54 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpc4biuoe0\nStarted\n.\nFinished in 0.001083135 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n923.25 tests/s, 12925.44 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpa9xoxv7l\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpa9xoxv7l.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01415924 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n70.63 tests/s, 70.63 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpq54_x5ni\nStarted\n.\nFinished in 0.000946584 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1056.43 tests/s, 14790.02 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpp8pvv3an\nStarted\n.\nFinished in 0.001160828 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n861.45 tests/s, 12060.36 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpk5to2u1g\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpk5to2u1g.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.00710518 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.74 tests/s, 140.74 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object(\"\") do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpb01exs_v\nStarted\n.\nFinished in 0.000742416 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1346.95 tests/s, 18857.35 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpbxthz4xd\nStarted\n.\nFinished in 0.000763881 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1309.10 tests/s, 18327.46 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp1pp_mw1q\nStarted\n.\nFinished in 0.000963721 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1037.64 tests/s, 14527.03 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpff_jc4n2\nStarted\n.\nFinished in 0.00064257 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1556.25 tests/s, 21787.51 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('') do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpti67y0iu\nStarted\n.\nFinished in 0.000767225 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1303.40 tests/s, 18247.58 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpcab5bm5u\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpcab5bm5u.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.018611511 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n53.73 tests/s, 53.73 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpj8ejtp02\nStarted\n.\nFinished in 0.001404343 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n712.08 tests/s, 9969.07 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpzrfm5u1k\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpzrfm5u1k.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01253342 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n79.79 tests/s, 79.79 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmlc6vmpo\nStarted\n.\nFinished in 0.001709249 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n585.05 tests/s, 8190.73 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp3p_dfl4i\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp3p_dfl4i.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008025923 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n124.60 tests/s, 124.60 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp2kqb4s3k\nStarted\n.\nFinished in 0.000750924 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1331.69 tests/s, 18643.70 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpukj6uj73\nStarted\n.\nFinished in 0.001562189 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n640.13 tests/s, 8961.78 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp3v8b2mun\nStarted\n.\nFinished in 0.000754632 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1325.15 tests/s, 18552.09 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6__3tdh9\nStarted\n.\nFinished in 0.000902579 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1107.94 tests/s, 15511.11 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  roman_numerals.keys.reverse.each_with_object(\"\") do |key, roman|\n    roman << roman_numerals[key] * (number / key)\n    number %= key\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp10fhrw2c\nStarted\n.\nFinished in 0.001968558 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n507.99 tests/s, 7111.80 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp10r3xrhh\nStarted\n.\nFinished in 0.001443333 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n692.84 tests/s, 9699.77 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmprsh9bg29\nStarted\n.\nFinished in 0.000711767 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1404.95 tests/s, 19669.36 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpdhrt085c\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpdhrt085c.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.009051086 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n110.48 tests/s, 110.48 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |k, v|\n    (number / k).times { result << v; number -= k }\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpvhcuo03k\nStarted\n.\nFinished in 0.000718414 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1391.96 tests/s, 19487.37 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdgpw33_q\nStarted\n.\nFinished in 0.000691387 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1446.37 tests/s, 20249.15 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmphg7l7m37\nStarted\n.\nFinished in 0.001254071 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n797.40 tests/s, 11163.64 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp488ujw0y\nStarted\n.\nFinished in 0.001181971 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n846.04 tests/s, 11844.62 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp31bppifw\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp31bppifw.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.012772118 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n78.30 tests/s, 78.30 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmppd4gzngv\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmppd4gzngv.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010060455 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n99.40 tests/s, 99.40 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp_ssoa985\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_ssoa985.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.013117628 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n76.23 tests/s, 76.23 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpehibuany\nStarted\n.\nFinished in 0.000912425 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1095.98 tests/s, 15343.73 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpqfh4jyed\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpqfh4jyed.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01038719 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n96.27 tests/s, 96.27 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmph328to7r\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmph328to7r.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.010823122 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n92.39 tests/s, 92.39 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpp4quo3hh\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpp4quo3hh.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007669345 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n130.39 tests/s, 130.39 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpv6wc0r6_\nStarted\n.\nFinished in 0.001164991 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n858.38 tests/s, 12017.26 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpubb092km\nStarted\n.\nFinished in 0.001168669 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n855.67 tests/s, 11979.44 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmppxjml4uj\nStarted\n.\nFinished in 0.000901923 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1108.74 tests/s, 15522.39 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpx9ez0lv9\nStarted\n.\nFinished in 0.001953417 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n511.92 tests/s, 7166.93 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4cv_svaw\nStarted\n.\nFinished in 0.000763279 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1310.14 tests/s, 18341.92 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number / key > 0\n      return value * (number / key) + int_to_mini_roman(number % key)\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmplq33nj09\nStarted\nE\n===============================================================================\nError: test_int_to_mini_roman(TestHumanEval): TypeError: no implicit conversion of Hash into String\n/tmp/tmplq33nj09.rb:26:in `+'\n/tmp/tmplq33nj09.rb:26:in `block in int_to_mini_roman'\n/tmp/tmplq33nj09.rb:24:in `each'\n/tmp/tmplq33nj09.rb:24:in `int_to_mini_roman'\n/tmp/tmplq33nj09.rb:26:in `block in int_to_mini_roman'\n/tmp/tmplq33nj09.rb:24:in `each'\n/tmp/tmplq33nj09.rb:24:in `int_to_mini_roman'\n/tmp/tmplq33nj09.rb:34:in `call'\n/tmp/tmplq33nj09.rb:34:in `test_int_to_mini_roman'\n     31: class TestHumanEval < Test::Unit::TestCase\n     32:   def test_int_to_mini_roman\n     33:     candidate = method(:int_to_mini_roman)\n  => 34:     assert_equal(\"xix\", candidate.call(19))\n     35:     assert_equal(\"clii\", candidate.call(152))\n     36:     assert_equal(\"ccli\", candidate.call(251))\n     37:     assert_equal(\"cdxxvi\", candidate.call(426))\n===============================================================================\n\nFinished in 0.002392641 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n417.95 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmponz3fzj4\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmponz3fzj4.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.017703298 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n56.49 tests/s, 56.49 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman = \"\"\n  roman << \"m\" * (number / 1000)\n  roman << \"d\" * (number % 1000 / 500)\n  roman << \"c\" * (number % 500 / 100)\n  roman << \"l\" * (number % 100 / 50)\n  roman << \"x\" * (number % 50 / 10)\n  roman << \"v\" * (number % 10 / 5)\n  roman << \"i\" * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpub_2vpdn\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpub_2vpdn.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.015951435 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n62.69 tests/s, 62.69 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmphp8by7ru\nStarted\n.\nFinished in 0.001105169 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n904.84 tests/s, 12667.75 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp21ze633p\nStarted\n.\nFinished in 0.001120725 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n892.28 tests/s, 12491.91 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpujbh6q00\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpujbh6q00.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.011724356 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n85.29 tests/s, 85.29 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp_2o0eqjt\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_2o0eqjt.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010922855 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n91.55 tests/s, 91.55 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpn2ry698d\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpn2ry698d.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008111621 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n123.28 tests/s, 123.28 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpv6uir5id\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpv6uir5id.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.012289602 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n81.37 tests/s, 81.37 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_string = ''\n  roman_numerals.each do |key, value|\n    roman_string << value * (number / key)\n    number = number % key\n  end\n  roman_string\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5zbp147c\nStarted\n.\nFinished in 0.002003523 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n499.12 tests/s, 6987.69 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpnri93oe8\nStarted\n.\nFinished in 0.001551643 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n644.48 tests/s, 9022.69 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpaoxja2ug\nStarted\n.\nFinished in 0.001237033 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n808.39 tests/s, 11317.40 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  output = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      output << value\n      number -= key\n    end\n  end\n  output\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmph126t1fq\nStarted\n.\nFinished in 0.002027851 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n493.13 tests/s, 6903.86 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('') do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpogjksekp\nStarted\n.\nFinished in 0.000755794 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1323.11 tests/s, 18523.57 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpk66ntzh_\nStarted\n.\nFinished in 0.000850467 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1175.82 tests/s, 16461.54 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmprr70ju4j\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmprr70ju4j.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.014754433 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n67.78 tests/s, 67.78 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpr3vllyrv\nStarted\n.\nFinished in 0.00175961 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n568.31 tests/s, 7956.31 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp6_3jd3fy\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp6_3jd3fy.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010953622 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n91.29 tests/s, 91.29 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpviyosiy0\nStarted\n.\nFinished in 0.000702107 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1424.28 tests/s, 19939.98 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpwb324li4\nStarted\n.\nFinished in 0.001216022 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n822.35 tests/s, 11512.95 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp_pdixwz8\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_pdixwz8.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.009716487 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n102.92 tests/s, 102.92 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_rpa6val\nStarted\n.\nFinished in 0.000805687 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1241.18 tests/s, 17376.47 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpgw54uya1\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpgw54uya1.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010460301 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n95.60 tests/s, 95.60 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpwzqzq8cy\nStarted\n.\nFinished in 0.001316092 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n759.83 tests/s, 10637.55 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral += \"m\" * (number / 1000)\n  roman_numeral += \"d\" * (number % 1000 / 500)\n  roman_numeral += \"c\" * (number % 500 / 100)\n  roman_numeral += \"l\" * (number % 100 / 50)\n  roman_numeral += \"x\" * (number % 50 / 10)\n  roman_numeral += \"v\" * (number % 10 / 5)\n  roman_numeral += \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp_4stbvi2\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_4stbvi2.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.007091487 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n141.01 tests/s, 141.01 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmphy7bedw7\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmphy7bedw7.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01676118 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n59.66 tests/s, 59.66 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp_yctttcd\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_yctttcd.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01386939 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n72.10 tests/s, 72.10 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpwduprzcb\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpwduprzcb.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.010855848 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n92.12 tests/s, 92.12 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp9s4xfolf\nStarted\n.\nFinished in 0.001561682 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n640.34 tests/s, 8964.69 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral += \"m\" * (number / 1000)\n  roman_numeral += \"d\" * (number % 1000 / 500)\n  roman_numeral += \"c\" * (number % 500 / 100)\n  roman_numeral += \"l\" * (number % 100 / 50)\n  roman_numeral += \"x\" * (number % 50 / 10)\n  roman_numeral += \"v\" * (number % 10 / 5)\n  roman_numeral += \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpgjan448z\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpgjan448z.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.009120698 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n109.64 tests/s, 109.64 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp58uwyqwd\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp58uwyqwd.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.018521577 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n53.99 tests/s, 53.99 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpiz2sfg5t\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpiz2sfg5t.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008618878 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n116.02 tests/s, 116.02 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmposuv4ej8\nStarted\n.\nFinished in 0.001015907 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n984.34 tests/s, 13780.79 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    return value + int_to_mini_roman(number - key) if number >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpu6xweiii\nStarted\n.\nFinished in 0.000837629 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1193.85 tests/s, 16713.84 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number / key > 0\n      return value * (number / key) + int_to_mini_roman(number % key)\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp2mttgtne\nStarted\nE\n===============================================================================\nError: test_int_to_mini_roman(TestHumanEval): TypeError: no implicit conversion of Hash into String\n/tmp/tmp2mttgtne.rb:26:in `+'\n/tmp/tmp2mttgtne.rb:26:in `block in int_to_mini_roman'\n/tmp/tmp2mttgtne.rb:24:in `each'\n/tmp/tmp2mttgtne.rb:24:in `int_to_mini_roman'\n/tmp/tmp2mttgtne.rb:26:in `block in int_to_mini_roman'\n/tmp/tmp2mttgtne.rb:24:in `each'\n/tmp/tmp2mttgtne.rb:24:in `int_to_mini_roman'\n/tmp/tmp2mttgtne.rb:34:in `call'\n/tmp/tmp2mttgtne.rb:34:in `test_int_to_mini_roman'\n     31: class TestHumanEval < Test::Unit::TestCase\n     32:   def test_int_to_mini_roman\n     33:     candidate = method(:int_to_mini_roman)\n  => 34:     assert_equal(\"xix\", candidate.call(19))\n     35:     assert_equal(\"clii\", candidate.call(152))\n     36:     assert_equal(\"ccli\", candidate.call(251))\n     37:     assert_equal(\"cdxxvi\", candidate.call(426))\n===============================================================================\n\nFinished in 0.001961612 seconds.\n-------------------------------------------------------------------------------\n1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n509.78 tests/s, 0.00 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpuzmp6j3h\nStarted\n.\nFinished in 0.000868112 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1151.93 tests/s, 16126.95 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpvwiuhx7m\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpvwiuhx7m.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010686058 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n93.58 tests/s, 93.58 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp5l31m4_h\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp5l31m4_h.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.009188946 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n108.83 tests/s, 108.83 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4bfpjbc4\nStarted\n.\nFinished in 0.00085186 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1173.90 tests/s, 16434.63 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpwz2dpam1\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpwz2dpam1.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.011638148 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n85.92 tests/s, 85.92 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpi8j2shzg\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpi8j2shzg.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01483879 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n67.39 tests/s, 67.39 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmptsc660m_\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmptsc660m_.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01184115 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n84.45 tests/s, 84.45 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4yt8jbnv\nStarted\n.\nFinished in 0.000775793 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1289.00 tests/s, 18046.05 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6amhbtb5\nStarted\n.\nFinished in 0.000678746 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1473.31 tests/s, 20626.27 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpm4d5q36m\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpm4d5q36m.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.010497194 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n95.26 tests/s, 95.26 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpe6yy5vss\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpe6yy5vss.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01568726 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n63.75 tests/s, 63.75 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp3_p188ts\nStarted\n.\nFinished in 0.001244077 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n803.81 tests/s, 11253.32 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmplv3u3lf4\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmplv3u3lf4.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.013354881 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n74.88 tests/s, 74.88 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp30k7y4uo\nStarted\n.\nFinished in 0.001095345 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n912.95 tests/s, 12781.36 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqz5up4rd\nStarted\n.\nFinished in 0.001443789 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n692.62 tests/s, 9696.71 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number / key > 0\n      return value * (number / key) + int_to_mini_roman(number % key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpzac2cci6\nStarted\n.\nFinished in 0.000824958 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1212.18 tests/s, 16970.56 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqi6d4_my\nStarted\n.\nFinished in 0.00075661 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1321.68 tests/s, 18503.59 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Write your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmptjx9402h\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmptjx9402h.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.015258541 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n65.54 tests/s, 65.54 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp28gsjy1i\nStarted\n.\nFinished in 0.00123491 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n809.78 tests/s, 11336.86 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpfprdoedl\nStarted\n.\nFinished in 0.000930004 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1075.26 tests/s, 15053.70 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpiouz1ep4\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpiouz1ep4.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.011372423 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n87.93 tests/s, 87.93 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp8wrkip9d\nStarted\n.\nFinished in 0.001686619 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n592.90 tests/s, 8300.63 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpd2y2pghr\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpd2y2pghr.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.014446939 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n69.22 tests/s, 69.22 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4iy6psll\nStarted\n.\nFinished in 0.000942163 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1061.39 tests/s, 14859.42 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp1jwmeh50\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp1jwmeh50.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.009214588 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n108.52 tests/s, 108.52 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    return value + int_to_mini_roman(number - key) if number >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7zr8_wl1\nStarted\n.\nFinished in 0.001229699 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n813.21 tests/s, 11384.90 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpzcvae1vk\nStarted\n.\nFinished in 0.000858634 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1164.64 tests/s, 16304.97 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpnwl1vp38\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpnwl1vp38.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.014784767 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n67.64 tests/s, 67.64 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp9djgv6ai\nStarted\n.\nFinished in 0.001402227 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n713.15 tests/s, 9984.12 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      roman_numeral << value\n      number -= key\n    end\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp3lzerebm\nStarted\n.\nFinished in 0.001259123 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n794.20 tests/s, 11118.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpj49tg517\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpj49tg517.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007133461 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n140.18 tests/s, 140.18 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp41bumw87\nStarted\n.\nFinished in 0.001431172 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n698.73 tests/s, 9782.19 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpb03h8ill\nStarted\n.\nFinished in 0.000762814 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1310.94 tests/s, 18353.10 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp6wml07zl\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp6wml07zl.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.0078976 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n126.62 tests/s, 126.62 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    return value + int_to_mini_roman(number - key) if number >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp4dec2838\nStarted\n.\nFinished in 0.000985865 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1014.34 tests/s, 14200.73 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpbnuxaw4_\nStarted\n.\nFinished in 0.00091583 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1091.91 tests/s, 15286.68 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpka6eh0h9\nStarted\n.\nFinished in 0.000712186 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1404.13 tests/s, 19657.79 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_q9gjzwj\nStarted\n.\nFinished in 0.00107062 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n934.04 tests/s, 13076.54 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp0tpam314\nStarted\n.\nFinished in 0.001187508 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n842.10 tests/s, 11789.39 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6kdrxlut\nStarted\n.\nFinished in 0.001073258 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n931.74 tests/s, 13044.39 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp2fdono_i\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp2fdono_i.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.01241829 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n80.53 tests/s, 80.53 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp3huc6kmy\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp3huc6kmy.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.014601194 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n68.49 tests/s, 68.49 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500 => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50 => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp1hkowc8v\nStarted\n.\nFinished in 0.000805739 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1241.10 tests/s, 17375.35 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpzebx806h\nStarted\n.\nFinished in 0.001541034 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n648.91 tests/s, 9084.81 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxa4av8a0\nStarted\n.\nFinished in 0.000994027 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1006.01 tests/s, 14084.12 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpo580cxaz\nStarted\n.\nFinished in 0.001093677 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n914.35 tests/s, 12800.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpsnw2mmd1\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpsnw2mmd1.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.012549322 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n79.69 tests/s, 79.69 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('') do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmm8dh536\nStarted\n.\nFinished in 0.001221157 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n818.90 tests/s, 11464.54 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpot0vo0h3\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpot0vo0h3.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.017613658 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n56.77 tests/s, 56.77 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpam0vl6xf\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpam0vl6xf.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.017626092 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n56.73 tests/s, 56.73 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmplmqx2dfz\nStarted\n.\nFinished in 0.001208762 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n827.29 tests/s, 11582.10 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp9qw0_2yu\nStarted\n.\nFinished in 0.001271611 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n786.40 tests/s, 11009.66 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman = ''\n  roman << 'm' * (number / 1000)\n  roman << 'd' * (number % 1000 / 500)\n  roman << 'c' * (number % 500 / 100)\n  roman << 'l' * (number % 100 / 50)\n  roman << 'x' * (number % 50 / 10)\n  roman << 'v' * (number % 10 / 5)\n  roman << 'i' * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpy_nm8j05\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpy_nm8j05.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.012282677 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n81.42 tests/s, 81.42 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdpd3yy8j\nStarted\n.\nFinished in 0.001258882 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n794.36 tests/s, 11120.98 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpc_rmkmr5\nStarted\n.\nFinished in 0.001647301 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n607.05 tests/s, 8498.75 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpydo6595z\nStarted\n.\nFinished in 0.001352913 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n739.15 tests/s, 10348.04 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |k, v|\n    result << v * (number / k)\n    number = number % k\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmswoaqhe\nStarted\n.\nFinished in 0.000821843 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1216.78 tests/s, 17034.88 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpbenlqym4\nStarted\n.\nFinished in 0.000875628 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1142.04 tests/s, 15988.52 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpqawvdoao\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpqawvdoao.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008859139 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n112.88 tests/s, 112.88 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpll09irsw\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpll09irsw.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008613306 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n116.10 tests/s, 116.10 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpg10pu1vz\nStarted\n.\nFinished in 0.001089988 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n917.44 tests/s, 12844.18 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpjv7cpxea\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpjv7cpxea.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.019519683 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n51.23 tests/s, 51.23 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpucg8j9jm\nStarted\n.\nFinished in 0.001881833 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n531.40 tests/s, 7439.55 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp_e2zklyz\nStarted\n.\nFinished in 0.000734488 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1361.49 tests/s, 19060.90 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpfkn2q4yw\nStarted\n.\nFinished in 0.001999574 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n500.11 tests/s, 7001.49 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpotwpzawx\nStarted\n.\nFinished in 0.000751403 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1330.84 tests/s, 18631.81 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpxvjlsfq6\nStarted\n.\nFinished in 0.002181982 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n458.30 tests/s, 6416.18 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpn4nwo04s\nStarted\n.\nFinished in 0.000816745 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1224.37 tests/s, 17141.21 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    return value + int_to_mini_roman(number - key) if number >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5m6llsgf\nStarted\n.\nFinished in 0.001299863 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n769.31 tests/s, 10770.37 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500 => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50 => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpmajtfomp\nStarted\n.\nFinished in 0.001005682 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n994.35 tests/s, 13920.90 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpscn1eujc\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpscn1eujc.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.013518638 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n73.97 tests/s, 73.97 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    return value + int_to_mini_roman(number - key) if number >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp6md8slcp\nStarted\n.\nFinished in 0.001292019 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n773.98 tests/s, 10835.75 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpdh6odqv5\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpdh6odqv5.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008406149 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n118.96 tests/s, 118.96 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  return '' if number == 0\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |k, v|\n    return v + int_to_mini_roman(number - k) if number >= k\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp3sh5qk6b\nStarted\n.\nFinished in 0.001101982 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n907.46 tests/s, 12704.38 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp3flbrjy5\nStarted\n.\nFinished in 0.001057015 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n946.06 tests/s, 13244.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpornw9roh\nStarted\n.\nFinished in 0.001937945 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n516.01 tests/s, 7224.15 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement this function\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpfhs3_gq8\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpfhs3_gq8.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.012688225 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n78.81 tests/s, 78.81 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpdxic3ybt\nStarted\n.\nFinished in 0.001719719 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n581.49 tests/s, 8140.86 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpw8zamjxa\nStarted\n.\nFinished in 0.00109992 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n909.16 tests/s, 12728.20 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 => 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n    400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpqchrxabu\nStarted\n.\nFinished in 0.000726158 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1377.11 tests/s, 19279.55 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\" * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n  roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral << \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpkuwtrelc\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpkuwtrelc.rb:23:in `test_int_to_mini_roman'\n     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n? x ix  \n?  v iii\n===============================================================================\n\nFinished in 0.012531028 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n79.80 tests/s, 79.80 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpgoqoln1_\nStarted\n.\nFinished in 0.001492002 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n670.24 tests/s, 9383.37 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('') do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp7rl0bobi\nStarted\n.\nFinished in 0.001351155 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n740.11 tests/s, 10361.51 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp4t7k6ycg\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp4t7k6ycg.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.01213025 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n82.44 tests/s, 82.44 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500 => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50 => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n    while number >= key\n      roman_numeral << value\n      number -= key\n    end\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpa5a98ngg\nStarted\n.\nFinished in 0.000740867 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1349.77 tests/s, 18896.78 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpne1c2z8u\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpne1c2z8u.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007992185 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.12 tests/s, 125.12 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpt4x4emvu\nStarted\n.\nFinished in 0.00136905 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n730.43 tests/s, 10226.07 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpzpii0jdk\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpzpii0jdk.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.00909947 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n109.90 tests/s, 109.90 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpnizlrfig\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpnizlrfig.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.009841022 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n101.62 tests/s, 101.62 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpctsvhncg\nStarted\n.\nFinished in 0.001145253 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n873.17 tests/s, 12224.37 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('') do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpckmltyp3\nStarted\n.\nFinished in 0.001157149 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n864.19 tests/s, 12098.70 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpr3tik1qo\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpr3tik1qo.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007627689 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n131.10 tests/s, 131.10 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp46i6s22l\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp46i6s22l.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010854586 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n92.13 tests/s, 92.13 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp2rm_klsv\nStarted\n.\nFinished in 0.001188427 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n841.45 tests/s, 11780.28 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp5hm9zw0q\nStarted\n.\nFinished in 0.000880194 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1136.11 tests/s, 15905.58 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpr844enfw\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpr844enfw.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007955105 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n125.71 tests/s, 125.71 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('') do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmphso_ce9o\nStarted\n.\nFinished in 0.001535618 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n651.20 tests/s, 9116.85 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmplhpjr9sq\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmplhpjr9sq.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007796207 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n128.27 tests/s, 128.27 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement the method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpoq1a4uk4\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpoq1a4uk4.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.006468635 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n154.59 tests/s, 154.59 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    'M' => 1000,\n    'CM' => 900,\n    'D' => 500,\n    'CD' => 400,\n    'C' => 100,\n    'XC' => 90,\n    'L' => 50,\n    'XL' => 40,\n    'X' => 10,\n    'IX' => 9,\n    'V' => 5,\n    'IV' => 4,\n    'I' => 1\n  }\n  roman_numerals.each do |key, value|\n    if number >= value\n      return key + int_to_mini_roman(number - value)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp98n6terd\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp98n6terd.rb:35:in `test_int_to_mini_roman'\n     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_int_to_mini_roman\n     34:     candidate = method(:int_to_mini_roman)\n  => 35:     assert_equal(\"xix\", candidate.call(19))\n     36:     assert_equal(\"clii\", candidate.call(152))\n     37:     assert_equal(\"ccli\", candidate.call(251))\n     38:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"XIX\">\n===============================================================================\n\nFinished in 0.01199322 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n83.38 tests/s, 83.38 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n      result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpx4zz3g5h\nStarted\n.\nFinished in 0.000590227 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1694.26 tests/s, 23719.69 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpc9hoh63o\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpc9hoh63o.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.014264629 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n70.10 tests/s, 70.10 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmpyiosm1f1\nStarted\n.\nFinished in 0.001968529 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n507.99 tests/s, 7111.91 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmppyurblp_\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmppyurblp_.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007810429 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n128.03 tests/s, 128.03 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpqyr1roqb\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpqyr1roqb.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.007811013 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n128.02 tests/s, 128.02 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result = ''\n  roman_numerals.each do |key, value|\n    result << value * (number / key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "",
      "stderr": "Loaded suite /tmp/tmp1st5w3ps\nStarted\n.\nFinished in 0.000664654 seconds.\n-------------------------------------------------------------------------------\n1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n100% passed\n-------------------------------------------------------------------------------\n1504.54 tests/s, 21063.59 assertions/s\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmp41vkjeov\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp41vkjeov.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.010720997 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n93.27 tests/s, 93.27 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "# Given a positive integer, obtain its roman numeral equivalent as a string,\n# and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n# >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n# >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO: implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n",
      "stdout": "Loaded suite /tmp/tmpvuz7d4s2\nStarted\nF\n===============================================================================\nFailure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpvuz7d4s2.rb:15:in `test_int_to_mini_roman'\n     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n? \"xix\"\n? n  l \n===============================================================================\n\nFinished in 0.008029642 seconds.\n-------------------------------------------------------------------------------\n1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n0% passed\n-------------------------------------------------------------------------------\n124.54 tests/s, 124.54 assertions/s\n",
      "stderr": "",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}