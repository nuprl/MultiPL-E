name: HumanEval_156_int_to_mini_roman
language: ruby
results:
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = ''\n  roman_numeral << 'm' * (number / 1000)\n  roman_numeral << 'd' * (number\
    \ % 1000 / 500)\n  roman_numeral << 'c' * (number % 500 / 100)\n  roman_numeral\
    \ << 'l' * (number % 100 / 50)\n  roman_numeral << 'x' * (number % 50 / 10)\n\
    \  roman_numeral << 'v' * (number % 10 / 5)\n  roman_numeral << 'i' * (number\
    \ % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_516z1a4\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_516z1a4.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.011441471 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    87.40 tests/s, 87.40 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6bc7yhw9\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp6bc7yhw9.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.012537717 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    79.76 tests/s, 79.76 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |divisor|\n    quotient, modulus\
    \ = number.divmod(divisor)\n    result << roman_numerals[divisor] * quotient\n\
    \    number = modulus\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzy_9aihv\nStarted\n.\nFinished in 0.001228851 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    813.77 tests/s, 11392.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmposdikpeo\nStarted\n.\nFinished in 0.00075897 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1317.58 tests/s, 18446.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = \"\"\n  roman_numerals.each do |key, value|\n    while number >= key\n   \
    \   result << value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7wbno5h1\nStarted\n.\nFinished in 0.001147006 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    871.84 tests/s, 12205.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  roman_numerals.keys.reverse.each_with_object('')\
    \ do |key, result|\n    while number >= key\n      result << roman_numerals[key]\n\
    \      number -= key\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7ms760li\nStarted\n.\nFinished in 0.000798783 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1251.90 tests/s, 17526.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpncf0ovao\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpncf0ovao.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.017469997 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    57.24 tests/s, 57.24 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxrjc37p_\nStarted\n.\nFinished in 0.000887334 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1126.97 tests/s, 15777.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpw4zpvuxf\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpw4zpvuxf.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007569909 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    132.10 tests/s, 132.10 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpy6p5wq35\nStarted\n.\nFinished in 0.001618302 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    617.93 tests/s, 8651.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7gspe03h\nStarted\n.\nFinished in 0.000923583 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1082.74 tests/s, 15158.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppkh9br_j\nStarted\n.\nFinished in 0.000742013 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1347.69 tests/s, 18867.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpf5thtalt\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpf5thtalt.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.00848877 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    117.80 tests/s, 117.80 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprhmmwhot\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmprhmmwhot.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010928051 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    91.51 tests/s, 91.51 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpbu2txc5o\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpbu2txc5o.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007942342 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    125.91 tests/s, 125.91 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp05s5dauy\nStarted\n.\nFinished in 0.000812076 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1231.41 tests/s, 17239.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbj2jqmd5\nStarted\n.\nFinished in 0.0006431 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1554.97 tests/s, 21769.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_298h1pi\nStarted\n.\nFinished in 0.001264161 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    791.04 tests/s, 11074.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc4biuoe0\nStarted\n.\nFinished in 0.001083135 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    923.25 tests/s, 12925.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpa9xoxv7l\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpa9xoxv7l.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01415924 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    70.63 tests/s, 70.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq54_x5ni\nStarted\n.\nFinished in 0.000946584 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1056.43 tests/s, 14790.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp8pvv3an\nStarted\n.\nFinished in 0.001160828 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    861.45 tests/s, 12060.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpk5to2u1g\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpk5to2u1g.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.00710518 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    140.74 tests/s, 140.74 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object(\"\
    \") do |(arabic, roman), result|\n    while number >= arabic\n      result <<\
    \ roman\n      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate\
    \ = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb01exs_v\nStarted\n.\nFinished in 0.000742416 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1346.95 tests/s, 18857.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbxthz4xd\nStarted\n.\nFinished in 0.000763881 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1309.10 tests/s, 18327.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1pp_mw1q\nStarted\n.\nFinished in 0.000963721 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1037.64 tests/s, 14527.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpff_jc4n2\nStarted\n.\nFinished in 0.00064257 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1556.25 tests/s, 21787.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpti67y0iu\nStarted\n.\nFinished in 0.000767225 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1303.40 tests/s, 18247.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcab5bm5u\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpcab5bm5u.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.018611511 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    53.73 tests/s, 53.73 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpj8ejtp02\nStarted\n.\nFinished in 0.001404343 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    712.08 tests/s, 9969.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzrfm5u1k\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpzrfm5u1k.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01253342 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    79.79 tests/s, 79.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmlc6vmpo\nStarted\n.\nFinished in 0.001709249 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    585.05 tests/s, 8190.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3p_dfl4i\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp3p_dfl4i.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008025923 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    124.60 tests/s, 124.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2kqb4s3k\nStarted\n.\nFinished in 0.000750924 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1331.69 tests/s, 18643.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpukj6uj73\nStarted\n.\nFinished in 0.001562189 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    640.13 tests/s, 8961.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3v8b2mun\nStarted\n.\nFinished in 0.000754632 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1325.15 tests/s, 18552.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6__3tdh9\nStarted\n.\nFinished in 0.000902579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1107.94 tests/s, 15511.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  roman_numerals.keys.reverse.each_with_object(\"\
    \") do |key, roman|\n    roman << roman_numerals[key] * (number / key)\n    number\
    \ %= key\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp10fhrw2c\nStarted\n.\nFinished in 0.001968558 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    507.99 tests/s, 7111.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp10r3xrhh\nStarted\n.\nFinished in 0.001443333 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    692.84 tests/s, 9699.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprsh9bg29\nStarted\n.\nFinished in 0.000711767 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1404.95 tests/s, 19669.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpdhrt085c\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpdhrt085c.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.009051086 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    110.48 tests/s, 110.48 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |k, v|\n    (number / k).times { result << v;\
    \ number -= k }\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvhcuo03k\nStarted\n.\nFinished in 0.000718414 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1391.96 tests/s, 19487.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdgpw33_q\nStarted\n.\nFinished in 0.000691387 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1446.37 tests/s, 20249.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphg7l7m37\nStarted\n.\nFinished in 0.001254071 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    797.40 tests/s, 11163.64 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp488ujw0y\nStarted\n.\nFinished in 0.001181971 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    846.04 tests/s, 11844.62 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp31bppifw\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp31bppifw.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.012772118 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    78.30 tests/s, 78.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppd4gzngv\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmppd4gzngv.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010060455 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    99.40 tests/s, 99.40 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_ssoa985\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_ssoa985.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.013117628 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    76.23 tests/s, 76.23 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpehibuany\nStarted\n.\nFinished in 0.000912425 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1095.98 tests/s, 15343.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqfh4jyed\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpqfh4jyed.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01038719 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    96.27 tests/s, 96.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmph328to7r\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmph328to7r.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.010823122 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    92.39 tests/s, 92.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp4quo3hh\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpp4quo3hh.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007669345 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    130.39 tests/s, 130.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpv6wc0r6_\nStarted\n.\nFinished in 0.001164991 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    858.38 tests/s, 12017.26 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpubb092km\nStarted\n.\nFinished in 0.001168669 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    855.67 tests/s, 11979.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppxjml4uj\nStarted\n.\nFinished in 0.000901923 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1108.74 tests/s, 15522.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx9ez0lv9\nStarted\n.\nFinished in 0.001953417 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    511.92 tests/s, 7166.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4cv_svaw\nStarted\n.\nFinished in 0.000763279 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1310.14 tests/s, 18341.92 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number / key > 0\n      return value * (number / key)\
    \ + int_to_mini_roman(number % key)\n    end\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmplq33nj09\nStarted\nE\n===============================================================================\n\
    Error: test_int_to_mini_roman(TestHumanEval): TypeError: no implicit conversion\
    \ of Hash into String\n/tmp/tmplq33nj09.rb:26:in `+'\n/tmp/tmplq33nj09.rb:26:in\
    \ `block in int_to_mini_roman'\n/tmp/tmplq33nj09.rb:24:in `each'\n/tmp/tmplq33nj09.rb:24:in\
    \ `int_to_mini_roman'\n/tmp/tmplq33nj09.rb:26:in `block in int_to_mini_roman'\n\
    /tmp/tmplq33nj09.rb:24:in `each'\n/tmp/tmplq33nj09.rb:24:in `int_to_mini_roman'\n\
    /tmp/tmplq33nj09.rb:34:in `call'\n/tmp/tmplq33nj09.rb:34:in `test_int_to_mini_roman'\n\
    \     31: class TestHumanEval < Test::Unit::TestCase\n     32:   def test_int_to_mini_roman\n\
    \     33:     candidate = method(:int_to_mini_roman)\n  => 34:     assert_equal(\"\
    xix\", candidate.call(19))\n     35:     assert_equal(\"clii\", candidate.call(152))\n\
    \     36:     assert_equal(\"ccli\", candidate.call(251))\n     37:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n===============================================================================\n\
    \nFinished in 0.002392641 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    417.95 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmponz3fzj4\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmponz3fzj4.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.017703298 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    56.49 tests/s, 56.49 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = \"\"\n  roman << \"m\" * (number / 1000)\n  roman << \"d\" * (number % 1000\
    \ / 500)\n  roman << \"c\" * (number % 500 / 100)\n  roman << \"l\" * (number\
    \ % 100 / 50)\n  roman << \"x\" * (number % 50 / 10)\n  roman << \"v\" * (number\
    \ % 10 / 5)\n  roman << \"i\" * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmpub_2vpdn\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpub_2vpdn.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.015951435 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    62.69 tests/s, 62.69 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphp8by7ru\nStarted\n.\nFinished in 0.001105169 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    904.84 tests/s, 12667.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp21ze633p\nStarted\n.\nFinished in 0.001120725 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    892.28 tests/s, 12491.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpujbh6q00\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpujbh6q00.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.011724356 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    85.29 tests/s, 85.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_2o0eqjt\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_2o0eqjt.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010922855 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    91.55 tests/s, 91.55 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpn2ry698d\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpn2ry698d.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008111621 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    123.28 tests/s, 123.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpv6uir5id\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpv6uir5id.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.012289602 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    81.37 tests/s, 81.37 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_string\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_string << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_string\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5zbp147c\nStarted\n.\nFinished in 0.002003523 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    499.12 tests/s, 6987.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnri93oe8\nStarted\n.\nFinished in 0.001551643 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    644.48 tests/s, 9022.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpaoxja2ug\nStarted\n.\nFinished in 0.001237033 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    808.39 tests/s, 11317.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  output\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ output << value\n      number -= key\n    end\n  end\n  output\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph126t1fq\nStarted\n.\nFinished in 0.002027851 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    493.13 tests/s, 6903.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpogjksekp\nStarted\n.\nFinished in 0.000755794 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1323.11 tests/s, 18523.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk66ntzh_\nStarted\n.\nFinished in 0.000850467 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1175.82 tests/s, 16461.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprr70ju4j\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmprr70ju4j.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.014754433 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    67.78 tests/s, 67.78 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr3vllyrv\nStarted\n.\nFinished in 0.00175961 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    568.31 tests/s, 7956.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6_3jd3fy\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp6_3jd3fy.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010953622 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    91.29 tests/s, 91.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpviyosiy0\nStarted\n.\nFinished in 0.000702107 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1424.28 tests/s, 19939.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwb324li4\nStarted\n.\nFinished in 0.001216022 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    822.35 tests/s, 11512.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me!\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_pdixwz8\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_pdixwz8.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.009716487 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    102.92 tests/s, 102.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_rpa6val\nStarted\n.\nFinished in 0.000805687 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1241.18 tests/s, 17376.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpgw54uya1\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpgw54uya1.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010460301 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    95.60 tests/s, 95.60 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwzqzq8cy\nStarted\n.\nFinished in 0.001316092 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    759.83 tests/s, 10637.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral += \"m\" * (number / 1000)\n  roman_numeral += \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral += \"c\" * (number % 500 / 100)\n \
    \ roman_numeral += \"l\" * (number % 100 / 50)\n  roman_numeral += \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral += \"v\" * (number % 10 / 5)\n  roman_numeral +=\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_4stbvi2\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_4stbvi2.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.007091487 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    141.01 tests/s, 141.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmphy7bedw7\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmphy7bedw7.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01676118 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    59.66 tests/s, 59.66 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_yctttcd\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp_yctttcd.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01386939 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    72.10 tests/s, 72.10 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwduprzcb\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpwduprzcb.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.010855848 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    92.12 tests/s, 92.12 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9s4xfolf\nStarted\n.\nFinished in 0.001561682 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    640.34 tests/s, 8964.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral += \"m\" * (number / 1000)\n  roman_numeral += \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral += \"c\" * (number % 500 / 100)\n \
    \ roman_numeral += \"l\" * (number % 100 / 50)\n  roman_numeral += \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral += \"v\" * (number % 10 / 5)\n  roman_numeral +=\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpgjan448z\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpgjan448z.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.009120698 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    109.64 tests/s, 109.64 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp58uwyqwd\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp58uwyqwd.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.018521577 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    53.99 tests/s, 53.99 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpiz2sfg5t\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpiz2sfg5t.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008618878 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    116.02 tests/s, 116.02 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmposuv4ej8\nStarted\n.\nFinished in 0.001015907 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    984.34 tests/s, 13780.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu6xweiii\nStarted\n.\nFinished in 0.000837629 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1193.85 tests/s, 16713.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number / key > 0\n      return value * (number / key)\
    \ + int_to_mini_roman(number % key)\n    end\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2mttgtne\nStarted\nE\n===============================================================================\n\
    Error: test_int_to_mini_roman(TestHumanEval): TypeError: no implicit conversion\
    \ of Hash into String\n/tmp/tmp2mttgtne.rb:26:in `+'\n/tmp/tmp2mttgtne.rb:26:in\
    \ `block in int_to_mini_roman'\n/tmp/tmp2mttgtne.rb:24:in `each'\n/tmp/tmp2mttgtne.rb:24:in\
    \ `int_to_mini_roman'\n/tmp/tmp2mttgtne.rb:26:in `block in int_to_mini_roman'\n\
    /tmp/tmp2mttgtne.rb:24:in `each'\n/tmp/tmp2mttgtne.rb:24:in `int_to_mini_roman'\n\
    /tmp/tmp2mttgtne.rb:34:in `call'\n/tmp/tmp2mttgtne.rb:34:in `test_int_to_mini_roman'\n\
    \     31: class TestHumanEval < Test::Unit::TestCase\n     32:   def test_int_to_mini_roman\n\
    \     33:     candidate = method(:int_to_mini_roman)\n  => 34:     assert_equal(\"\
    xix\", candidate.call(19))\n     35:     assert_equal(\"clii\", candidate.call(152))\n\
    \     36:     assert_equal(\"ccli\", candidate.call(251))\n     37:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n===============================================================================\n\
    \nFinished in 0.001961612 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    509.78 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpuzmp6j3h\nStarted\n.\nFinished in 0.000868112 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1151.93 tests/s, 16126.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvwiuhx7m\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpvwiuhx7m.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010686058 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    93.58 tests/s, 93.58 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5l31m4_h\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp5l31m4_h.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.009188946 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    108.83 tests/s, 108.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4bfpjbc4\nStarted\n.\nFinished in 0.00085186 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1173.90 tests/s, 16434.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwz2dpam1\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpwz2dpam1.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.011638148 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    85.92 tests/s, 85.92 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpi8j2shzg\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpi8j2shzg.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01483879 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    67.39 tests/s, 67.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptsc660m_\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmptsc660m_.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01184115 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    84.45 tests/s, 84.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4yt8jbnv\nStarted\n.\nFinished in 0.000775793 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1289.00 tests/s, 18046.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6amhbtb5\nStarted\n.\nFinished in 0.000678746 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1473.31 tests/s, 20626.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpm4d5q36m\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpm4d5q36m.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.010497194 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    95.26 tests/s, 95.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpe6yy5vss\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpe6yy5vss.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01568726 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    63.75 tests/s, 63.75 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3_p188ts\nStarted\n.\nFinished in 0.001244077 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    803.81 tests/s, 11253.32 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number\
    \ % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman\
    \ + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman\
    \ = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n\
    \  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplv3u3lf4\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmplv3u3lf4.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.013354881 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    74.88 tests/s, 74.88 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp30k7y4uo\nStarted\n.\nFinished in 0.001095345 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    912.95 tests/s, 12781.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqz5up4rd\nStarted\n.\nFinished in 0.001443789 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    692.62 tests/s, 9696.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number / key > 0\n      return value * (number / key)\
    \ + int_to_mini_roman(number % key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzac2cci6\nStarted\n.\nFinished in 0.000824958 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1212.18 tests/s, 16970.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqi6d4_my\nStarted\n.\nFinished in 0.00075661 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1321.68 tests/s, 18503.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Write\
    \ your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptjx9402h\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmptjx9402h.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.015258541 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    65.54 tests/s, 65.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp28gsjy1i\nStarted\n.\nFinished in 0.00123491 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    809.78 tests/s, 11336.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfprdoedl\nStarted\n.\nFinished in 0.000930004 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1075.26 tests/s, 15053.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpiouz1ep4\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpiouz1ep4.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.011372423 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    87.93 tests/s, 87.93 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8wrkip9d\nStarted\n.\nFinished in 0.001686619 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    592.90 tests/s, 8300.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpd2y2pghr\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpd2y2pghr.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.014446939 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    69.22 tests/s, 69.22 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4iy6psll\nStarted\n.\nFinished in 0.000942163 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1061.39 tests/s, 14859.42 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1jwmeh50\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp1jwmeh50.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.009214588 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    108.52 tests/s, 108.52 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7zr8_wl1\nStarted\n.\nFinished in 0.001229699 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    813.21 tests/s, 11384.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzcvae1vk\nStarted\n.\nFinished in 0.000858634 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1164.64 tests/s, 16304.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number\
    \ % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman\
    \ + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman\
    \ = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n\
    \  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpnwl1vp38\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpnwl1vp38.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.014784767 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    67.64 tests/s, 67.64 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9djgv6ai\nStarted\n.\nFinished in 0.001402227 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    713.15 tests/s, 9984.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ roman_numeral << value\n      number -= key\n    end\n  end\n  roman_numeral\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3lzerebm\nStarted\n.\nFinished in 0.001259123 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    794.20 tests/s, 11118.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpj49tg517\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpj49tg517.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007133461 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    140.18 tests/s, 140.18 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp41bumw87\nStarted\n.\nFinished in 0.001431172 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    698.73 tests/s, 9782.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb03h8ill\nStarted\n.\nFinished in 0.000762814 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1310.94 tests/s, 18353.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6wml07zl\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp6wml07zl.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.0078976 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    126.62 tests/s, 126.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4dec2838\nStarted\n.\nFinished in 0.000985865 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1014.34 tests/s, 14200.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbnuxaw4_\nStarted\n.\nFinished in 0.00091583 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1091.91 tests/s, 15286.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpka6eh0h9\nStarted\n.\nFinished in 0.000712186 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1404.13 tests/s, 19657.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_q9gjzwj\nStarted\n.\nFinished in 0.00107062 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    934.04 tests/s, 13076.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0tpam314\nStarted\n.\nFinished in 0.001187508 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    842.10 tests/s, 11789.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6kdrxlut\nStarted\n.\nFinished in 0.001073258 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    931.74 tests/s, 13044.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2fdono_i\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp2fdono_i.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.01241829 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    80.53 tests/s, 80.53 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3huc6kmy\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp3huc6kmy.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.014601194 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    68.49 tests/s, 68.49 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500\
    \ => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50\
    \ => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"\
    v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n\
    \    roman_numeral << value * (number / key)\n    number = number % key\n  end\n\
    \  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1hkowc8v\nStarted\n.\nFinished in 0.000805739 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1241.10 tests/s, 17375.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzebx806h\nStarted\n.\nFinished in 0.001541034 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    648.91 tests/s, 9084.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxa4av8a0\nStarted\n.\nFinished in 0.000994027 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1006.01 tests/s, 14084.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo580cxaz\nStarted\n.\nFinished in 0.001093677 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    914.35 tests/s, 12800.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpsnw2mmd1\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpsnw2mmd1.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.012549322 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    79.69 tests/s, 79.69 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmm8dh536\nStarted\n.\nFinished in 0.001221157 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    818.90 tests/s, 11464.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman = roman + 'm' * (number / 1000)\n  roman = roman + 'd' * (number\
    \ % 1000 / 500)\n  roman = roman + 'c' * (number % 500 / 100)\n  roman = roman\
    \ + 'l' * (number % 100 / 50)\n  roman = roman + 'x' * (number % 50 / 10)\n  roman\
    \ = roman + 'v' * (number % 10 / 5)\n  roman = roman + 'i' * (number % 5 / 1)\n\
    \  roman\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpot0vo0h3\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpot0vo0h3.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.017613658 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    56.77 tests/s, 56.77 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpam0vl6xf\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpam0vl6xf.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.017626092 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    56.73 tests/s, 56.73 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplmqx2dfz\nStarted\n.\nFinished in 0.001208762 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    827.29 tests/s, 11582.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9qw0_2yu\nStarted\n.\nFinished in 0.001271611 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    786.40 tests/s, 11009.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman\
    \ = ''\n  roman << 'm' * (number / 1000)\n  roman << 'd' * (number % 1000 / 500)\n\
    \  roman << 'c' * (number % 500 / 100)\n  roman << 'l' * (number % 100 / 50)\n\
    \  roman << 'x' * (number % 50 / 10)\n  roman << 'v' * (number % 10 / 5)\n  roman\
    \ << 'i' * (number % 5 / 1)\n  roman\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpy_nm8j05\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpy_nm8j05.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.012282677 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    81.42 tests/s, 81.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdpd3yy8j\nStarted\n.\nFinished in 0.001258882 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    794.36 tests/s, 11120.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc_rmkmr5\nStarted\n.\nFinished in 0.001647301 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    607.05 tests/s, 8498.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpydo6595z\nStarted\n.\nFinished in 0.001352913 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    739.15 tests/s, 10348.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |k, v|\n    result << v * (number / k)\n    number\
    \ = number % k\n  end\n  result\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmswoaqhe\nStarted\n.\nFinished in 0.000821843 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1216.78 tests/s, 17034.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbenlqym4\nStarted\n.\nFinished in 0.000875628 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1142.04 tests/s, 15988.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqawvdoao\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpqawvdoao.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008859139 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    112.88 tests/s, 112.88 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpll09irsw\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpll09irsw.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008613306 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    116.10 tests/s, 116.10 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpg10pu1vz\nStarted\n.\nFinished in 0.001089988 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    917.44 tests/s, 12844.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjv7cpxea\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpjv7cpxea.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.019519683 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    51.23 tests/s, 51.23 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpucg8j9jm\nStarted\n.\nFinished in 0.001881833 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    531.40 tests/s, 7439.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_e2zklyz\nStarted\n.\nFinished in 0.000734488 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1361.49 tests/s, 19060.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfkn2q4yw\nStarted\n.\nFinished in 0.001999574 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    500.11 tests/s, 7001.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpotwpzawx\nStarted\n.\nFinished in 0.000751403 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1330.84 tests/s, 18631.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numeral\
    \ = ''\n  roman_numerals.each do |key, value|\n    roman_numeral << value * (number\
    \ / key)\n    number = number % key\n  end\n  roman_numeral\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxvjlsfq6\nStarted\n.\nFinished in 0.002181982 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    458.30 tests/s, 6416.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpn4nwo04s\nStarted\n.\nFinished in 0.000816745 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1224.37 tests/s, 17141.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5m6llsgf\nStarted\n.\nFinished in 0.001299863 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    769.31 tests/s, 10770.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500\
    \ => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50\
    \ => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"\
    v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n\
    \    roman_numeral << value * (number / key)\n    number = number % key\n  end\n\
    \  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmajtfomp\nStarted\n.\nFinished in 0.001005682 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    994.35 tests/s, 13920.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpscn1eujc\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpscn1eujc.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.013518638 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    73.97 tests/s, 73.97 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    return value + int_to_mini_roman(number - key) if number\
    \ >= key\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6md8slcp\nStarted\n.\nFinished in 0.001292019 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    773.98 tests/s, 10835.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpdh6odqv5\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpdh6odqv5.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008406149 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    118.96 tests/s, 118.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  return\
    \ '' if number == 0\n  roman_numerals = {\n    1000 => 'm',\n    900 => 'cm',\n\
    \    500 => 'd',\n    400 => 'cd',\n    100 => 'c',\n    90 => 'xc',\n    50 =>\
    \ 'l',\n    40 => 'xl',\n    10 => 'x',\n    9 => 'ix',\n    5 => 'v',\n    4\
    \ => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each do |k, v|\n    return v +\
    \ int_to_mini_roman(number - k) if number >= k\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3sh5qk6b\nStarted\n.\nFinished in 0.001101982 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    907.46 tests/s, 12704.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3flbrjy5\nStarted\n.\nFinished in 0.001057015 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    946.06 tests/s, 13244.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpornw9roh\nStarted\n.\nFinished in 0.001937945 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    516.01 tests/s, 7224.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this function\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfhs3_gq8\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpfhs3_gq8.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.012688225 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    78.81 tests/s, 78.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= key\n      return value + int_to_mini_roman(number\
    \ - key)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdxic3ybt\nStarted\n.\nFinished in 0.001719719 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    581.49 tests/s, 8140.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw8zamjxa\nStarted\n.\nFinished in 0.00109992 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    909.16 tests/s, 12728.20 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1 => 'i',\n    4 => 'iv',\n    5 => 'v',\n    9 => 'ix',\n    10 =>\
    \ 'x',\n    40 => 'xl',\n    50 => 'l',\n    90 => 'xc',\n    100 => 'c',\n  \
    \  400 => 'cd',\n    500 => 'd',\n    900 => 'cm',\n    1000 => 'm'\n  }\n  result\
    \ = ''\n  roman_numerals.keys.reverse.each do |key|\n    while number >= key\n\
    \      result += roman_numerals[key]\n      number -= key\n    end\n  end\n  result\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqchrxabu\nStarted\n.\nFinished in 0.000726158 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1377.11 tests/s, 19279.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numeral << \"m\" * (number / 1000)\n  roman_numeral << \"d\"\
    \ * (number % 1000 / 500)\n  roman_numeral << \"c\" * (number % 500 / 100)\n \
    \ roman_numeral << \"l\" * (number % 100 / 50)\n  roman_numeral << \"x\" * (number\
    \ % 50 / 10)\n  roman_numeral << \"v\" * (number % 10 / 5)\n  roman_numeral <<\
    \ \"i\" * (number % 5 / 1)\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpkuwtrelc\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpkuwtrelc.rb:23:in `test_int_to_mini_roman'\n\
    \     20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_int_to_mini_roman\n\
    \     22:     candidate = method(:int_to_mini_roman)\n  => 23:     assert_equal(\"\
    xix\", candidate.call(19))\n     24:     assert_equal(\"clii\", candidate.call(152))\n\
    \     25:     assert_equal(\"ccli\", candidate.call(251))\n     26:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"xviiii\">\n\ndiff:\n\
    ? x ix  \n?  v iii\n===============================================================================\n\
    \nFinished in 0.012531028 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    79.80 tests/s, 79.80 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgoqoln1_\nStarted\n.\nFinished in 0.001492002 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    670.24 tests/s, 9383.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7rl0bobi\nStarted\n.\nFinished in 0.001351155 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    740.11 tests/s, 10361.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4t7k6ycg\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp4t7k6ycg.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.01213025 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    82.44 tests/s, 82.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numeral\
    \ = \"\"\n  roman_numerals = {\n    1000 => \"m\",\n    900 => \"cm\",\n    500\
    \ => \"d\",\n    400 => \"cd\",\n    100 => \"c\",\n    90 => \"xc\",\n    50\
    \ => \"l\",\n    40 => \"xl\",\n    10 => \"x\",\n    9 => \"ix\",\n    5 => \"\
    v\",\n    4 => \"iv\",\n    1 => \"i\"\n  }\n  roman_numerals.each do |key, value|\n\
    \    while number >= key\n      roman_numeral << value\n      number -= key\n\
    \    end\n  end\n  roman_numeral\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpa5a98ngg\nStarted\n.\nFinished in 0.000740867 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1349.77 tests/s, 18896.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpne1c2z8u\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpne1c2z8u.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007992185 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    125.12 tests/s, 125.12 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt4x4emvu\nStarted\n.\nFinished in 0.00136905 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    730.43 tests/s, 10226.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzpii0jdk\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpzpii0jdk.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.00909947 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    109.90 tests/s, 109.90 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpnizlrfig\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpnizlrfig.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.009841022 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    101.62 tests/s, 101.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpctsvhncg\nStarted\n.\nFinished in 0.001145253 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    873.17 tests/s, 12224.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpckmltyp3\nStarted\n.\nFinished in 0.001157149 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    864.19 tests/s, 12098.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr3tik1qo\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpr3tik1qo.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007627689 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    131.10 tests/s, 131.10 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp46i6s22l\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp46i6s22l.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010854586 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    92.13 tests/s, 92.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2rm_klsv\nStarted\n.\nFinished in 0.001188427 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    841.45 tests/s, 11780.28 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5hm9zw0q\nStarted\n.\nFinished in 0.000880194 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1136.11 tests/s, 15905.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr844enfw\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpr844enfw.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007955105 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    125.71 tests/s, 125.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  roman_numerals.each_with_object('')\
    \ do |(arabic, roman), result|\n    while number >= arabic\n      result << roman\n\
    \      number -= arabic\n    end\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphso_ce9o\nStarted\n.\nFinished in 0.001535618 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    651.20 tests/s, 9116.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplhpjr9sq\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmplhpjr9sq.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007796207 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    128.27 tests/s, 128.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement the method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpoq1a4uk4\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpoq1a4uk4.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.006468635 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    154.59 tests/s, 154.59 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    'M' => 1000,\n    'CM' => 900,\n    'D' => 500,\n    'CD' => 400,\n\
    \    'C' => 100,\n    'XC' => 90,\n    'L' => 50,\n    'XL' => 40,\n    'X' =>\
    \ 10,\n    'IX' => 9,\n    'V' => 5,\n    'IV' => 4,\n    'I' => 1\n  }\n  roman_numerals.each\
    \ do |key, value|\n    if number >= value\n      return key + int_to_mini_roman(number\
    \ - value)\n    end\n  end\n  ''\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n\
    \    assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp98n6terd\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp98n6terd.rb:35:in `test_int_to_mini_roman'\n\
    \     32: class TestHumanEval < Test::Unit::TestCase\n     33:   def test_int_to_mini_roman\n\
    \     34:     candidate = method(:int_to_mini_roman)\n  => 35:     assert_equal(\"\
    xix\", candidate.call(19))\n     36:     assert_equal(\"clii\", candidate.call(152))\n\
    \     37:     assert_equal(\"ccli\", candidate.call(251))\n     38:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<\"XIX\">\n===============================================================================\n\
    \nFinished in 0.01199322 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    83.38 tests/s, 83.38 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    while number >= key\n     \
    \ result += value\n      number -= key\n    end\n  end\n  result\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n\
    \    candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx4zz3g5h\nStarted\n.\nFinished in 0.000590227 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1694.26 tests/s, 23719.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpc9hoh63o\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpc9hoh63o.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.014264629 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    70.10 tests/s, 70.10 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyiosm1f1\nStarted\n.\nFinished in 0.001968529 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    507.99 tests/s, 7111.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppyurblp_\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmppyurblp_.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007810429 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    128.03 tests/s, 128.03 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ Implement this method\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqyr1roqb\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpqyr1roqb.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.007811013 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    128.02 tests/s, 128.02 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  roman_numerals\
    \ = {\n    1000 => 'm',\n    900 => 'cm',\n    500 => 'd',\n    400 => 'cd',\n\
    \    100 => 'c',\n    90 => 'xc',\n    50 => 'l',\n    40 => 'xl',\n    10 =>\
    \ 'x',\n    9 => 'ix',\n    5 => 'v',\n    4 => 'iv',\n    1 => 'i'\n  }\n  result\
    \ = ''\n  roman_numerals.each do |key, value|\n    result << value * (number /\
    \ key)\n    number = number % key\n  end\n  result\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_int_to_mini_roman\n   \
    \ candidate = method(:int_to_mini_roman)\n    assert_equal(\"xix\", candidate.call(19))\n\
    \    assert_equal(\"clii\", candidate.call(152))\n    assert_equal(\"ccli\", candidate.call(251))\n\
    \    assert_equal(\"cdxxvi\", candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n\
    \    assert_equal(\"i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n\
    \    assert_equal(\"xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n\
    \    assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\",\
    \ candidate.call(532))\n    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"\
    cmxciv\", candidate.call(994))\n    assert_equal(\"m\", candidate.call(1000))\n\
    \  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1st5w3ps\nStarted\n.\nFinished in 0.000664654 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 14 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1504.54 tests/s, 21063.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # Your\
    \ code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp41vkjeov\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmp41vkjeov.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.010720997 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    93.27 tests/s, 93.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n\
    # >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n\
    # >>> int_to_mini_roman(426) == 'cdxxvi'\ndef int_to_mini_roman(number)\n  # TODO:\
    \ implement me\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_int_to_mini_roman\n    candidate = method(:int_to_mini_roman)\n  \
    \  assert_equal(\"xix\", candidate.call(19))\n    assert_equal(\"clii\", candidate.call(152))\n\
    \    assert_equal(\"ccli\", candidate.call(251))\n    assert_equal(\"cdxxvi\"\
    , candidate.call(426))\n    assert_equal(\"d\", candidate.call(500))\n    assert_equal(\"\
    i\", candidate.call(1))\n    assert_equal(\"iv\", candidate.call(4))\n    assert_equal(\"\
    xliii\", candidate.call(43))\n    assert_equal(\"xc\", candidate.call(90))\n \
    \   assert_equal(\"xciv\", candidate.call(94))\n    assert_equal(\"dxxxii\", candidate.call(532))\n\
    \    assert_equal(\"cm\", candidate.call(900))\n    assert_equal(\"cmxciv\", candidate.call(994))\n\
    \    assert_equal(\"m\", candidate.call(1000))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpvuz7d4s2\nStarted\nF\n===============================================================================\n\
    Failure: test_int_to_mini_roman(TestHumanEval)\n/tmp/tmpvuz7d4s2.rb:15:in `test_int_to_mini_roman'\n\
    \     12: class TestHumanEval < Test::Unit::TestCase\n     13:   def test_int_to_mini_roman\n\
    \     14:     candidate = method(:int_to_mini_roman)\n  => 15:     assert_equal(\"\
    xix\", candidate.call(19))\n     16:     assert_equal(\"clii\", candidate.call(152))\n\
    \     17:     assert_equal(\"ccli\", candidate.call(251))\n     18:     assert_equal(\"\
    cdxxvi\", candidate.call(426))\n<\"xix\"> expected but was\n<nil>\n\ndiff:\n?\
    \ \"xix\"\n? n  l \n===============================================================================\n\
    \nFinished in 0.008029642 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    124.54 tests/s, 124.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
