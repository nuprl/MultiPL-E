name: HumanEval_87_get_row
language: ruby
results:
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |col, col_index|\n      result << [row_index, col_index] if col == x\n  \
    \  end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdyy96su5\nStarted\n.\nFinished in 0.00042002 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2380.84 tests/s, 14285.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |el, j|\n\
    \      [i, j] if el == x\n    end\n  end.flatten(1).compact.sort_by { |i, j| [i,\
    \ -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcq0pegnl\nStarted\n.\nFinished in 0.000451539 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2214.65 tests/s, 13287.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3h012_oz\nStarted\n.\nFinished in 0.000458383 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2181.58 tests/s, 13089.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |column, column_index|\n      [row_index, column_index] if column == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphwiap70b\nStarted\n.\nFinished in 0.000416755 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2399.49 tests/s, 14396.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3kxtxuf8\nStarted\n.\nFinished in 0.000437662 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2284.87 tests/s, 13709.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpf3yxdjwg\nStarted\n.\nFinished in 0.000390744 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2559.22 tests/s, 15355.32 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by do\
    \ |elem|\n    [elem[0], -elem[1]]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw83qwajm\nStarted\n.\nFinished in 0.000406294 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2461.27 tests/s, 14767.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzuyqw299\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpzuyqw299.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005945901 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    168.18 tests/s, 168.18 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |col, j|\n\
    \      [i, j] if col == x\n    end\n  end.flatten(1).compact.sort_by { |x, y|\
    \ [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbukgv78u\nStarted\n.\nFinished in 0.000428576 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2333.31 tests/s, 13999.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |col, col_index|\n      result << [row_index, col_index] if col == x\n  \
    \  end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjd8b5o40\nStarted\n.\nFinished in 0.000372771 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2682.61 tests/s, 16095.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |col, col_index|\n      [row_index, col_index] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp765n0r0c\nStarted\n.\nFinished in 0.00042044 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2378.46 tests/s, 14270.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |a,\
    \ b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7y2pboi0\nStarted\n.\nFinished in 0.000510109 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1960.37 tests/s, 11762.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxyzau7tl\nStarted\n.\nFinished in 0.000374785 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2668.20 tests/s, 16009.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmparc0uobp\nStarted\n.\nFinished in 0.000439326 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2276.21 tests/s, 13657.28 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6yyascq0\nStarted\n.\nFinished in 0.00038258 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2613.83 tests/s, 15682.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprnj10762\nStarted\n.\nFinished in 0.000457009 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2188.14 tests/s, 13128.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |a,\
    \ b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp1w2afua\nStarted\n.\nFinished in 0.000509617 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1962.26 tests/s, 11773.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx5490m_s\nStarted\n.\nFinished in 0.00080309 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1245.19 tests/s, 7471.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, row_index|\n    row.each_with_index.map { |column,\
    \ column_index|\n      [row_index, column_index] if column == x\n    }\n  }.flatten(1).compact.sort_by\
    \ { |row, column| [row, -column] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5f_vm0k8\nStarted\n.\nFinished in 0.000591591 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1690.36 tests/s, 10142.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpphwnei4y\nStarted\n.\nFinished in 0.000602733 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1659.11 tests/s, 9954.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpv34v9ro3\nStarted\n.\nFinished in 0.000406975 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2457.15 tests/s, 14742.92 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt70kwiqd\nStarted\n.\nFinished in 0.000399301 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2504.38 tests/s, 15026.26 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2nzfonvf\nStarted\n.\nFinished in 0.000487336 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2051.97 tests/s, 12311.83 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |el, j|\n      result << [i, j] if el == x\n    end\n  end\n  result.sort_by\
    \ { |el| [el[0], -el[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbc_0ujsb\nStarted\n.\nFinished in 0.000498207 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2007.20 tests/s, 12043.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjqne4oty\nStarted\n.\nFinished in 0.000521822 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1916.36 tests/s, 11498.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |col, j|\n\
    \      [i, j] if col == x\n    end\n  end.flatten(1).compact.sort_by { |x, y|\
    \ [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_1to5ait\nStarted\n.\nFinished in 0.000459023 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2178.54 tests/s, 13071.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |item, item_index|\n      [row_index, item_index] if item == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, _| row }.map do |row, item|\n    [row, item].sort_by { |_, item| -item\
    \ }\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5kk4t6xp\nStarted\nE\n===============================================================================\n\
    Error: test_get_row(TestHumanEval): NoMethodError: undefined method `-@' for nil:NilClass\n\
    /tmp/tmp5kk4t6xp.rb:23:in `block (2 levels) in get_row'\n/tmp/tmp5kk4t6xp.rb:23:in\
    \ `each'\n/tmp/tmp5kk4t6xp.rb:23:in `sort_by'\n/tmp/tmp5kk4t6xp.rb:23:in `block\
    \ in get_row'\n/tmp/tmp5kk4t6xp.rb:22:in `map'\n/tmp/tmp5kk4t6xp.rb:22:in `get_row'\n\
    /tmp/tmp5kk4t6xp.rb:30:in `call'\n/tmp/tmp5kk4t6xp.rb:30:in `test_get_row'\n \
    \    27: class TestHumanEval < Test::Unit::TestCase\n     28:   def test_get_row\n\
    \     29:     candidate = method(:get_row)\n  => 30:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     31:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     32:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     33: \
    \    assert_equal([], candidate.call([], 1))\n===============================================================================\n\
    \nFinished in 0.00115435 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    866.29 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqbu7_cpg\nStarted\n.\nFinished in 0.000476797 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2097.33 tests/s, 12583.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcbx2u4sz\nStarted\n.\nFinished in 0.000437423 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2286.12 tests/s, 13716.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |a, b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcmefjqg7\nStarted\n.\nFinished in 0.0003993 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2504.38 tests/s, 15026.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |item, item_index|\n      [row_index, item_index] if item == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, _| row }.map do |row, item|\n    [row, item].sort.reverse\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5ate2b_i\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmp5ate2b_i.rb:30:in `test_get_row'\n\
    \     27: class TestHumanEval < Test::Unit::TestCase\n     28:   def test_get_row\n\
    \     29:     candidate = method(:get_row)\n  => 30:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     31:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     32:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     33: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<[[0, 0], [1, 0], [4, 1], [2, 0], [5, 2]]>\n\ndiff:\n\
    ? [[0, 0], [1, 4], [1, 0],         [2, 5], [   2, 0]]\n?                     \
    \     [4, 1],     0    5,       \n===============================================================================\n\
    \nFinished in 0.007202192 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    138.85 tests/s, 138.85 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |a,\
    \ b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpoajbr08u\nStarted\n.\nFinished in 0.000419359 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2384.59 tests/s, 14307.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptzlb518h\nStarted\n.\nFinished in 0.000458793 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2179.63 tests/s, 13077.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprfru8wu2\nStarted\n.\nFinished in 0.000428906 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2331.51 tests/s, 13989.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7s6klqa8\nStarted\n.\nFinished in 0.000384584 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2600.21 tests/s, 15601.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvsx8iul1\nStarted\n.\nFinished in 0.000561626 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1780.54 tests/s, 10683.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpn_7nbwxn\nStarted\n.\nFinished in 0.000385093 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2596.78 tests/s, 15580.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |i, j| [i, -j] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmput1xxqwp\nStarted\n.\nFinished in 0.000465605 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2147.74 tests/s, 12886.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0rkkw3b4\nStarted\n.\nFinished in 0.000428215 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2335.28 tests/s, 14011.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |i, j| [i, -j] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpma3qlmih\nStarted\n.\nFinished in 0.000442862 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2258.04 tests/s, 13548.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp36d8wbat\nStarted\n.\nFinished in 0.000465666 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2147.46 tests/s, 12884.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, column_index|\n      result << [row_index, column_index] if element\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl_ume683\nStarted\n.\nFinished in 0.000508385 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1967.01 tests/s, 11802.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |column, column_index|\n      [row_index, column_index] if column == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpn172lqra\nStarted\n.\nFinished in 0.000464383 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2153.39 tests/s, 12920.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb443q6qr\nStarted\n.\nFinished in 0.00039348 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2541.43 tests/s, 15248.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |el, j|\n      result << [i, j] if el == x\n    end\n  end\n  result.sort_by\
    \ { |x, y| [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptpm38m3s\nStarted\n.\nFinished in 0.000459133 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2178.02 tests/s, 13068.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |item, col_index|\n      result << [row_index, col_index] if item == x\n\
    \    end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk_rm6mee\nStarted\n.\nFinished in 0.00067508 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1481.31 tests/s, 8887.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpci4u4gbg\nStarted\n.\nFinished in 0.000496694 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2013.31 tests/s, 12079.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpj4qvc9o6\nStarted\n.\nFinished in 0.000407817 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2452.08 tests/s, 14712.48 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1b3isqac\nStarted\n.\nFinished in 0.000375747 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2661.37 tests/s, 15968.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  res = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |el,\
    \ j|\n      res << [i, j] if el == x\n    end\n  end\n  res.sort_by { |e| [e[0],\
    \ -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8kas_zsy\nStarted\n.\nFinished in 0.000393579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2540.79 tests/s, 15244.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, column_index|\n      result << [row_index, column_index] if element\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4e08di9_\nStarted\n.\nFinished in 0.000370918 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2696.01 tests/s, 16176.08 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |item, j|\n      result << [i, j] if item == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjdqojcq3\nStarted\n.\nFinished in 0.000395443 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2528.81 tests/s, 15172.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu_p3s1al\nStarted\n.\nFinished in 0.000402116 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2486.84 tests/s, 14921.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |i, j| [i, -j] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpm7d39wig\nStarted\n.\nFinished in 0.000431361 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2318.24 tests/s, 13909.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp6kx2trr\nStarted\n.\nFinished in 0.000405803 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2464.25 tests/s, 14785.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |col, j|\n\
    \      [i, j] if col == x\n    end\n  end.flatten(1).compact.sort_by { |i, j|\
    \ [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpoduhshm1\nStarted\n.\nFinished in 0.000733789 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1362.79 tests/s, 8176.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.map.with_index { |e, j| [i, j]\
    \ if e == x }\n  end.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0_bn6v8w\nStarted\n.\nFinished in 0.00044143 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2265.36 tests/s, 13592.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk04j8osw\nStarted\n.\nFinished in 0.000397357 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2516.63 tests/s, 15099.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb5n65zk4\nStarted\n.\nFinished in 0.000392959 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2544.79 tests/s, 15268.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7mnjzx0q\nStarted\n.\nFinished in 0.000414048 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2415.18 tests/s, 14491.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |element, column_index|\n      [row_index, column_index] if element == x\n \
    \   end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphe20y3__\nStarted\n.\nFinished in 0.000436741 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2289.69 tests/s, 13738.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |col, j|\n\
    \      [i, j] if col == x\n    end\n  end.flatten(1).compact.sort_by { |x, y|\
    \ [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3j6thwyd\nStarted\n.\nFinished in 0.000427815 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2337.46 tests/s, 14024.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp430to5ai\nStarted\n.\nFinished in 0.000483399 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2068.68 tests/s, 12412.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpk5okyt42\nStarted\n.\nFinished in 0.000411173 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2432.07 tests/s, 14592.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplc6o5hg8\nStarted\n.\nFinished in 0.000391676 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2553.13 tests/s, 15318.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph1ae67bf\nStarted\n.\nFinished in 0.000405733 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2464.68 tests/s, 14788.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |a,\
    \ b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpuewhb_rv\nStarted\n.\nFinished in 0.000432894 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2310.03 tests/s, 13860.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |row,\
    \ col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjvx_6mzy\nStarted\n.\nFinished in 0.000617992 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1618.14 tests/s, 9708.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpg1fegn_o\nStarted\n.\nFinished in 0.000526891 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1897.93 tests/s, 11387.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6xhsyad0\nStarted\n.\nFinished in 0.000833387 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1199.92 tests/s, 7199.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |i, j| [i, -j]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprku9a5i9\nStarted\n.\nFinished in 0.000479361 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2086.11 tests/s, 12516.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |element, column_index|\n      [row_index, column_index] if element == x\n \
    \   end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnx15d16k\nStarted\n.\nFinished in 0.000436931 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2288.69 tests/s, 13732.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, index|\n    row.each_with_index\
    \ do |element, index2|\n      result << [index, index2] if element == x\n    end\n\
    \  end\n  result.sort_by { |a, b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb2e2h6u_\nStarted\n.\nFinished in 0.000444356 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2250.45 tests/s, 13502.69 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |item, j|\n      result << [i, j] if item == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6pdgdgwv\nStarted\n.\nFinished in 0.000437883 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2283.72 tests/s, 13702.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpujrq_w9a\nStarted\n.\nFinished in 0.000874835 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1143.07 tests/s, 6858.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1hxvdnj9\nStarted\n.\nFinished in 0.000431782 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2315.98 tests/s, 13895.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprieniqq8\nStarted\n.\nFinished in 0.000402015 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2487.47 tests/s, 14924.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |col, col_index|\n      [row_index, col_index] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqp1x3mr1\nStarted\n.\nFinished in 0.000417575 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2394.78 tests/s, 14368.68 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgpdc8mmf\nStarted\n.\nFinished in 0.000390344 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2561.84 tests/s, 15371.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu5tgrt1q\nStarted\n.\nFinished in 0.000410141 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2438.19 tests/s, 14629.12 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2kxhmfau\nStarted\n.\nFinished in 0.000424859 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2353.72 tests/s, 14122.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |column, column_index|\n      [row_index, column_index] if column == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps2c9zbp5\nStarted\n.\nFinished in 0.000426201 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2346.31 tests/s, 14077.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjmhhc1i2\nStarted\n.\nFinished in 0.000424659 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2354.83 tests/s, 14128.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0kjjkz79\nStarted\n.\nFinished in 0.0003828 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2612.33 tests/s, 15673.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |value, column_index|\n      [row_index, column_index] if value == x\n    end\n\
    \  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu9hawg3r\nStarted\n.\nFinished in 0.000449505 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2224.67 tests/s, 13348.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |row,\
    \ col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9eh8n0wx\nStarted\n.\nFinished in 0.000445868 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2242.82 tests/s, 13456.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgiws2i74\nStarted\n.\nFinished in 0.000476004 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2100.82 tests/s, 12604.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6oa_4lpm\nStarted\n.\nFinished in 0.000397057 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2518.53 tests/s, 15111.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |col, col_index|\n      [row_index, col_index] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1h71gz1x\nStarted\n.\nFinished in 0.000439537 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2275.12 tests/s, 13650.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |col, col_index|\n      result << [row_index, col_index] if col == x\n  \
    \  end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_oufjrl0\nStarted\n.\nFinished in 0.000394863 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2532.52 tests/s, 15195.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |e|\
    \ [e[0], -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp0j63xdx\nStarted\n.\nFinished in 0.000446489 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2239.70 tests/s, 13438.18 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsln0_5a4\nStarted\n.\nFinished in 0.000415631 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2405.98 tests/s, 14435.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index do |row, row_index|\n    row.map.with_index do |elem, column_index|\n\
    \      [row_index, column_index] if elem == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, column| [row, -column] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6h92jycm\nStarted\n.\nFinished in 0.000443293 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2255.84 tests/s, 13535.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpl2vgfuon\nStarted\n.\nFinished in 0.000423436 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2361.63 tests/s, 14169.79 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |value, column_index|\n      result << [row_index, column_index] if value\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprsy5vja4\nStarted\n.\nFinished in 0.000408028 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2450.81 tests/s, 14704.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpoohxdsjj\nStarted\n.\nFinished in 0.000401164 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2492.75 tests/s, 14956.48 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpysijed3y\nStarted\n.\nFinished in 0.000429769 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2326.83 tests/s, 13960.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpz0gdtbmp\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpz0gdtbmp.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.006047361 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    165.36 tests/s, 165.36 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |cell, j|\n      result << [i, j] if cell == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4v7_39f2\nStarted\n.\nFinished in 0.000370357 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2700.10 tests/s, 16200.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp915eg0yy\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmp915eg0yy.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005252225 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    190.40 tests/s, 190.40 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqr_ffjfn\nStarted\n.\nFinished in 0.000423877 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2359.17 tests/s, 14155.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2la4abdn\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmp2la4abdn.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005127802 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    195.02 tests/s, 195.02 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr6bcse_r\nStarted\n.\nFinished in 0.000445699 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2243.67 tests/s, 13462.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |item, item_index|\n      result << [row_index, item_index] if item == x\n\
    \    end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp183vyf4o\nStarted\n.\nFinished in 0.000376047 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2659.24 tests/s, 15955.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpngum2kux\nStarted\n.\nFinished in 0.000400072 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2499.55 tests/s, 14997.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |item, item_index|\n      result << [row_index, item_index] if item == x\n\
    \    end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptnoh2ph_\nStarted\n.\nFinished in 0.000380054 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2631.21 tests/s, 15787.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |a,\
    \ b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpktomddf1\nStarted\n.\nFinished in 0.000464453 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2153.07 tests/s, 12918.42 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |column, column_index|\n      [row_index, column_index] if column == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbz0xuh89\nStarted\n.\nFinished in 0.000439055 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2277.62 tests/s, 13665.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7aqmixs_\nStarted\n.\nFinished in 0.00039875 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2507.84 tests/s, 15047.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, col_index|\n      result << [row_index, col_index] if element ==\
    \ x\n    end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo_0pom2y\nStarted\n.\nFinished in 0.000436923 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2288.73 tests/s, 13732.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |column, column_index|\n      [row_index, column_index] if column == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpemrphnr6\nStarted\n.\nFinished in 0.000431711 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2316.36 tests/s, 13898.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwm41_s95\nStarted\n.\nFinished in 0.000419779 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2382.21 tests/s, 14293.24 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, row_index|\n    row.each_with_index.map { |element,\
    \ column_index|\n      [row_index, column_index] if element == x\n    }\n  }.flatten(1).compact.sort_by\
    \ { |row, column| [row, -column] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvsro87_e\nStarted\n.\nFinished in 0.000453472 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2205.21 tests/s, 13231.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by do\
    \ |row, col|\n    [row, -col]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpuwq0ydm9\nStarted\n.\nFinished in 0.000470966 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2123.30 tests/s, 12739.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxflh9i00\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpxflh9i00.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.00550455 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    181.67 tests/s, 181.67 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcd3is6ki\nStarted\n.\nFinished in 0.000576785 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1733.75 tests/s, 10402.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkw8zvqsi\nStarted\n.\nFinished in 0.000507715 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1969.61 tests/s, 11817.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index do |row, i|\n    row.map.with_index { |e, j| [i, j] if e\
    \ == x }\n  end.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpltehm9uc\nStarted\n.\nFinished in 0.000492977 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2028.49 tests/s, 12170.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpaaquu_uc\nStarted\n.\nFinished in 0.000474913 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2105.65 tests/s, 12633.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprqmwexcc\nStarted\n.\nFinished in 0.000432102 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2314.27 tests/s, 13885.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |a, b| [a, -b] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpis3de2vu\nStarted\n.\nFinished in 0.000461377 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2167.42 tests/s, 13004.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |a, b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_96qoo4c\nStarted\n.\nFinished in 0.000407366 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2454.79 tests/s, 14728.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfa7b6jsu\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpfa7b6jsu.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005756884 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    173.71 tests/s, 173.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |i, j| [i, -j]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_3deki5o\nStarted\n.\nFinished in 0.00091491 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1093.00 tests/s, 6558.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |col, col_index|\n      result << [row_index, col_index] if col == x\n  \
    \  end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp56m4pkf6\nStarted\n.\nFinished in 0.000511613 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1954.60 tests/s, 11727.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |item, item_index|\n      result << [row_index, item_index] if item == x\n\
    \    end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx0wj1ugc\nStarted\n.\nFinished in 0.000426072 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2347.02 tests/s, 14082.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |i, j| [i, -j] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfwheosuf\nStarted\n.\nFinished in 0.000500321 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1998.72 tests/s, 11992.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplofjhb3p\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmplofjhb3p.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005404543 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    185.03 tests/s, 185.03 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp01ffspfv\nStarted\n.\nFinished in 0.00038286 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2611.92 tests/s, 15671.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxcwd2v4i\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpxcwd2v4i.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005886007 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    169.89 tests/s, 169.89 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps_3bc9qk\nStarted\n.\nFinished in 0.000367441 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2721.53 tests/s, 16329.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, row_index|\n    row.each_with_index.map { |elem,\
    \ col_index|\n      [row_index, col_index] if elem == x\n    }\n  }.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0hr9e5kl\nStarted\n.\nFinished in 0.00042034 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2379.03 tests/s, 14274.16 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |el, j| [i, j] if el ==\
    \ x } }.flatten(1).compact.sort_by { |el| [el[0], -el[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp12lmsbc8\nStarted\n.\nFinished in 0.000408759 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2446.43 tests/s, 14678.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, row_index|\n    row.each_with_index.map { |col,\
    \ col_index|\n      [row_index, col_index] if col == x\n    }\n  }.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7vuixjhd\nStarted\n.\nFinished in 0.000456538 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2190.40 tests/s, 13142.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |element, column_index|\n      [row_index, column_index] if element == x\n \
    \   end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7h6e1jcb\nStarted\n.\nFinished in 0.000407707 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2452.74 tests/s, 14716.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbl5wdabx\nStarted\n.\nFinished in 0.000485413 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2060.10 tests/s, 12360.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |i, j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzlsaf44t\nStarted\n.\nFinished in 0.000448784 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2228.24 tests/s, 13369.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  res = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |elem,\
    \ j|\n      res << [i, j] if elem == x\n    end\n  end\n  res.sort_by { |elem|\
    \ [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7m3e_rvf\nStarted\n.\nFinished in 0.000490041 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2040.65 tests/s, 12243.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpouf9z87s\nStarted\n.\nFinished in 0.000476425 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2098.97 tests/s, 12593.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |a, b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphmpxzk0u\nStarted\n.\nFinished in 0.000386026 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2590.50 tests/s, 15542.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpiuvbf178\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpiuvbf178.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.006501464 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    153.81 tests/s, 153.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |item, item_index|\n      [row_index, item_index] if item == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, _| row }.map do |row, item|\n    [row, item].sort_by { |_, item| -item\
    \ }.reverse\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5clrq2kg\nStarted\nE\n===============================================================================\n\
    Error: test_get_row(TestHumanEval): NoMethodError: undefined method `-@' for nil:NilClass\n\
    /tmp/tmp5clrq2kg.rb:23:in `block (2 levels) in get_row'\n/tmp/tmp5clrq2kg.rb:23:in\
    \ `each'\n/tmp/tmp5clrq2kg.rb:23:in `sort_by'\n/tmp/tmp5clrq2kg.rb:23:in `block\
    \ in get_row'\n/tmp/tmp5clrq2kg.rb:22:in `map'\n/tmp/tmp5clrq2kg.rb:22:in `get_row'\n\
    /tmp/tmp5clrq2kg.rb:30:in `call'\n/tmp/tmp5clrq2kg.rb:30:in `test_get_row'\n \
    \    27: class TestHumanEval < Test::Unit::TestCase\n     28:   def test_get_row\n\
    \     29:     candidate = method(:get_row)\n  => 30:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     31:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     32:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     33: \
    \    assert_equal([], candidate.call([], 1))\n===============================================================================\n\
    \nFinished in 0.001279376 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    781.63 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |i, j| [i, -j] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1zj6sumr\nStarted\n.\nFinished in 0.000470054 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2127.42 tests/s, 12764.49 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |col, j|\n\
    \      [i, j] if col == x\n    end\n  end.flatten(1).compact.sort_by { |x, y|\
    \ [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1uxr6scw\nStarted\n.\nFinished in 0.000496233 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2015.18 tests/s, 12091.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvma_vw2u\nStarted\n.\nFinished in 0.00040984 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2439.98 tests/s, 14639.86 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph2lwyf8j\nStarted\n.\nFinished in 0.000434597 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2300.98 tests/s, 13805.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzjwib_4_\nStarted\n.\nFinished in 0.00049476 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2021.18 tests/s, 12127.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |column, column_index|\n      [row_index, column_index] if column == x\n   \
    \ end\n  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkk9xmncj\nStarted\n.\nFinished in 0.000482246 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2073.63 tests/s, 12441.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index do |row, i|\n    row.map.with_index do |e, j|\n      [i,\
    \ j] if e == x\n    end\n  end.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpf3dvf9c0\nStarted\n.\nFinished in 0.000524225 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1907.58 tests/s, 11445.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpm8oj7ro3\nStarted\n.\nFinished in 0.000493186 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2027.63 tests/s, 12165.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |i, j| [i, -j] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpln8i0hgb\nStarted\n.\nFinished in 0.000402187 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2486.41 tests/s, 14918.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |x,\
    \ y| [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcnqvvdgw\nStarted\n.\nFinished in 0.000452843 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2208.27 tests/s, 13249.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt60w_wyd\nStarted\n.\nFinished in 0.000443565 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2254.46 tests/s, 13526.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfxspkjny\nStarted\n.\nFinished in 0.000406314 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2461.15 tests/s, 14766.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |i, j| [i, -j]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxcrcb2ig\nStarted\n.\nFinished in 0.000440328 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2271.03 tests/s, 13626.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |e, j|\n\
    \      [i, j] if e == x\n    }\n  }.flatten(1).compact.sort_by { |e| [e[0], -e[1]]\
    \ }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def\
    \ test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0], [1,\
    \ 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3,\
    \ 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5,\
    \ 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0],\
    \ [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3,\
    \ 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8zo8jd7x\nStarted\n.\nFinished in 0.000481135 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2078.42 tests/s, 12470.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8m2gj45p\nStarted\n.\nFinished in 0.000627771 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1592.94 tests/s, 9557.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb7mrxfur\nStarted\n.\nFinished in 0.000432242 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2313.52 tests/s, 13881.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpiaf_as0h\nStarted\n.\nFinished in 0.000529957 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1886.95 tests/s, 11321.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphjy3st76\nStarted\n.\nFinished in 0.000436862 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2289.05 tests/s, 13734.31 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |e|\
    \ [e[0], -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdbl8ca4p\nStarted\n.\nFinished in 0.000415982 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2403.95 tests/s, 14423.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgvc4k_wy\nStarted\n.\nFinished in 0.000398269 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2510.87 tests/s, 15065.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |item,\
    \ j|\n      [i, j] if item == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpb6rctm_j\nStarted\n.\nFinished in 0.000440127 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2272.07 tests/s, 13632.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |col, col_index|\n      result << [row_index, col_index] if col == x\n  \
    \  end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7ks5mfdu\nStarted\n.\nFinished in 0.000522973 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1912.14 tests/s, 11472.87 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnmy10yzm\nStarted\n.\nFinished in 0.000600239 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1666.00 tests/s, 9996.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpjox3xz79\nStarted\n.\nFinished in 0.000486325 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2056.24 tests/s, 12337.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.map.with_index { |row, i| row.map.with_index { |e, j| [i, j] if e == x\
    \ } }\n    .flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5lk501p0\nStarted\n.\nFinished in 0.000489151 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2044.36 tests/s, 12266.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |x,\
    \ y| [x, -y] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmposui1fh5\nStarted\n.\nFinished in 0.000439376 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2275.95 tests/s, 13655.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by do\
    \ |row, col|\n    [row, -col]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpz9alhbiu\nStarted\n.\nFinished in 0.000488899 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2045.41 tests/s, 12272.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpc873pvsj\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpc873pvsj.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005386097 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    185.66 tests/s, 185.66 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvynczpms\nStarted\n.\nFinished in 0.000584469 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1710.95 tests/s, 10265.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |item, col_index|\n      [row_index, col_index] if item == x\n    end\n  end.flatten(1).compact.sort_by\
    \ do |row, col|\n    [row, -col]\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2htlscfq\nStarted\n.\nFinished in 0.000581133 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1720.78 tests/s, 10324.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |element, column_index|\n      [row_index, column_index] if element == x\n \
    \   end\n  end.flatten(1).compact.sort_by do |row, column|\n    [row, -column]\n\
    \  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpoo014cle\nStarted\n.\nFinished in 0.000863363 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1158.26 tests/s, 6949.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |e|\
    \ [e[0], -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptuuhgzky\nStarted\n.\nFinished in 0.000550664 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1815.99 tests/s, 10895.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |elem|\
    \ [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp9mjsggw\nStarted\n.\nFinished in 0.000512584 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1950.90 tests/s, 11705.40 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppqkwwwyl\nStarted\n.\nFinished in 0.001016912 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    983.37 tests/s, 5900.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  # your code here\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpe2z2wd1x\nStarted\nF\n===============================================================================\n\
    Failure: test_get_row(TestHumanEval)\n/tmp/tmpe2z2wd1x.rb:24:in `test_get_row'\n\
    \     21: class TestHumanEval < Test::Unit::TestCase\n     22:   def test_get_row\n\
    \     23:     candidate = method(:get_row)\n  => 24:     assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     25:     assert_equal([[0, 1], [1,\
    \ 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6]], 2))\n     26:     assert_equal([[0, 0], [1, 0], [2, 1],\
    \ [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n     27: \
    \    assert_equal([], candidate.call([], 1))\n<[[0, 0], [1, 4], [1, 0], [2, 5],\
    \ [2, 0]]> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.005600962 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    178.54 tests/s, 178.54 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |col, col_index|\n      [row_index, col_index] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo1fioecd\nStarted\n.\nFinished in 0.000457911 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2183.83 tests/s, 13102.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |col, j|\n      result << [i, j] if col == x\n    end\n  end\n  result.sort_by\
    \ { |a, b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppfksi8z_\nStarted\n.\nFinished in 0.000410342 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2436.99 tests/s, 14621.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |item, j|\n      result << [i, j] if item == x\n    end\n  end\n  result.sort_by\
    \ { |x| [x[0], -x[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbipv_20_\nStarted\n.\nFinished in 0.000394101 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2537.42 tests/s, 15224.52 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |col, col_index|\n      [row_index, col_index] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmg7ku2fn\nStarted\n.\nFinished in 0.000466056 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2145.66 tests/s, 12873.99 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |e|\
    \ [e[0], -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmptse7bkm6\nStarted\n.\nFinished in 0.000371468 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2692.02 tests/s, 16152.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |a,\
    \ b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpj75zjsfr\nStarted\n.\nFinished in 0.00042578 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2348.63 tests/s, 14091.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |e|\
    \ [e[0], -e[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzn5bwt0e\nStarted\n.\nFinished in 0.000396636 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2521.20 tests/s, 15127.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |col, col_index|\n      [row_index, col_index] if col == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpm0k602ck\nStarted\n.\nFinished in 0.000480033 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2083.19 tests/s, 12499.14 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |e, i| e.each_with_index.map { |e, j| [i, j] if e\
    \ == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8v5meb32\nStarted\n.\nFinished in 0.000505199 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1979.42 tests/s, 11876.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |i,\
    \ j| [i, -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpg4cpmyei\nStarted\n.\nFinished in 0.000443714 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2253.70 tests/s, 13522.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, element_index|\n      result << [row_index, element_index] if element\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2sg0bq8y\nStarted\n.\nFinished in 0.000431391 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2318.08 tests/s, 13908.50 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp9lipe139\nStarted\n.\nFinished in 0.000346321 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2887.49 tests/s, 17324.97 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |item, j|\n\
    \      [i, j] if item == x\n    }\n  }.flatten(1).compact.sort_by { |i, j| [i,\
    \ -j] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphz3z1t63\nStarted\n.\nFinished in 0.000392207 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2549.67 tests/s, 15298.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do\
    \ |elem, j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbs1q2vsh\nStarted\n.\nFinished in 0.000580902 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1721.46 tests/s, 10328.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.map.with_index { |e, j| [i, j]\
    \ if e == x }\n  end.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2_2noq2v\nStarted\n.\nFinished in 0.000431612 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2316.90 tests/s, 13901.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |item, item_index|\n      [row_index, item_index] if item == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |a, b| [a, -b] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkjh5lk2s\nStarted\n.\nFinished in 0.000434087 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2303.69 tests/s, 13822.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |item, column_index|\n      [row_index, column_index] if item == x\n    end\n\
    \  end.flatten(1).compact.sort_by { |row, column| [row, -column] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp203an17_\nStarted\n.\nFinished in 0.000413378 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2419.09 tests/s, 14514.56 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map { |row, i| row.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt7_wzzzg\nStarted\n.\nFinished in 0.000441761 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2263.67 tests/s, 13582.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, column_index|\n      result << [row_index, column_index] if element\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps9u6c_xy\nStarted\n.\nFinished in 0.000421913 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2370.16 tests/s, 14220.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, index|\n    row.each_with_index\
    \ do |item, index2|\n      result << [index, index2] if item == x\n    end\n \
    \ end\n  result.sort_by { |item| [item[0], -item[1]] }\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n    candidate\
    \ = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]],\
    \ candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]],\
    \ 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1,\
    \ 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5],\
    \ [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4,\
    \ 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
    \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
    \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
    \ [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpew039kr1\nStarted\n.\nFinished in 0.000384793 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2598.80 tests/s, 15592.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, i|\n    row.each_with_index.map do |elem,\
    \ j|\n      [i, j] if elem == x\n    end\n  end.flatten(1).compact.sort_by { |elem|\
    \ [elem[0], -elem[1]] }\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_get_row\n    candidate = method(:get_row)\n    assert_equal([[0, 0],\
    \ [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2,\
    \ 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3,\
    \ 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3,\
    \ 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2,\
    \ 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1,\
    \ 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp550xq9am\nStarted\n.\nFinished in 0.000426853 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2342.73 tests/s, 14056.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  lst.each_with_index.map do |row, row_index|\n    row.each_with_index.map do\
    \ |el, col_index|\n      [row_index, col_index] if el == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |row, col| [row, -col] }\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_get_row\n    candidate = method(:get_row)\n\
    \    assert_equal([[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([[0,\
    \ 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1]], candidate.call([[1, 2, 3, 4, 5,\
    \ 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0, 0], [1, 0], [2, 1], [2,\
    \ 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1,\
    \ 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6],\
    \ [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([],\
    \ candidate.call([], 1))\n    assert_equal([], candidate.call([[1]], 2))\n   \
    \ assert_equal([[2, 2]], candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6ikwrijk\nStarted\n.\nFinished in 0.000449575 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2224.32 tests/s, 13345.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
    \ to matrix, however, unlike matrices,\n# each row may contain a different number\
    \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a\
    \ coordinate - (row, columns), starting with 0.\n# Sort coordinates initially\
    \ by rows in ascending order.\n# Also, sort coordinates of the row by columns\
    \ in descending order.\n# Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n\
    # [1,2,3,4,5,1]\n# ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([],\
    \ 1) == []\n# get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n\
    \  result = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |element, element_index|\n      result << [row_index, element_index] if element\
    \ == x\n    end\n  end\n  result.sort_by { |row, column| [row, -column] }\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
    \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
    \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2,\
    \ 3, 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1],\
    \ [5, 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4,\
    \ 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n  \
    \  assert_equal([[0, 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0],\
    \ [5, 4], [5, 0], [6, 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2,\
    \ 3, 4, 5, 6], [1, 1, 3, 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1,\
    \ 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1))\n    assert_equal([], candidate.call([],\
    \ 1))\n    assert_equal([], candidate.call([[1]], 2))\n    assert_equal([[2, 2]],\
    \ candidate.call([[], [1], [1, 2, 3]], 3))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpphxbesi7\nStarted\n.\nFinished in 0.000432382 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 6 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    2312.77 tests/s, 13876.62 assertions/s\n"
  exit_code: 0
  status: OK
