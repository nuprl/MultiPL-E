name: HumanEval_49_modp
language: ruby
results:
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return (modp(n/2, p)**2 * 2) % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp3ovi8pqe\nStarted\n.\nFinished in 0.000882111 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1133.64 tests/s, 7935.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdx676g_7\nStarted\n.\nFinished in 0.000565621 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1767.97 tests/s, 12375.78 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return modp(n / 2, p) ** 2 * 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0nep3acl\nStarted\n.\nFinished in 0.000595719 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1678.64 tests/s, 11750.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n % 2 ==\
    \ 0\n    modp(n/2, p)**2 % p\n  else\n    (modp(n/2, p)**2 * 2) % p\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4kzwasg1\nStarted\n.\nFinished in 0.000906545 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1103.09 tests/s, 7721.62 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpfjxw0ojx\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpfjxw0ojx.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.01460799 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    68.46 tests/s, 68.46 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmisjt10u\nStarted\n.\nFinished in 0.000735809 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1359.05 tests/s, 9513.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return (modp(n/2, p)**2 * 2) % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpiltgofwp\nStarted\n.\nFinished in 0.001173625 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    852.06 tests/s, 5964.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8x6_iazd\nStarted\n.\nFinished in 0.000619863 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1613.26 tests/s, 11292.82 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (2 * modp(n/2, p)**2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8_jqsy_p\nStarted\n.\nFinished in 0.000922739 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1083.73 tests/s, 7586.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpg_p2wg5q\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpg_p2wg5q.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.007353898 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    135.98 tests/s, 135.98 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n/2, p)) % p if n % 2 == 0\n  return (2 * modp(n/2,\
    \ p) + 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp83_qlybg\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp83_qlybg.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.022513339 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    44.42 tests/s, 88.84 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement this function\n\
    \  return 1 if n == 0\n  return (2 * modp(n - 1, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpn04m4fgu\nStarted\n.\nFinished in 0.000947623 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1055.27 tests/s, 7386.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpj8xmeqsp\nStarted\n.\nFinished in 0.001372066 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    728.83 tests/s, 5101.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n/2, p)) % p if n.even?\n  return (2 * modp(n/2,\
    \ p) + 1) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzz72cqf3\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpzz72cqf3.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.007638274 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    130.92 tests/s, 261.84 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n if\
    \ n == 1\n  return n if n == p\n  return (n * modp(n, p - 2)) % p\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprazbqjfl\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmprazbqjfl.rb:22:in `test_modp'\n   \
    \  19: class TestHumanEval < Test::Unit::TestCase\n     20:   def test_modp\n\
    \     21:     candidate = method(:modp)\n  => 22:     assert_equal(3, candidate.call(3,\
    \ 5))\n     23:     assert_equal(2, candidate.call(1101, 101))\n     24:     assert_equal(1,\
    \ candidate.call(0, 101))\n     25:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<4>\n===============================================================================\n\
    \nFinished in 0.01771455 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    56.45 tests/s, 56.45 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n % 2 ==\
    \ 0\n    (modp(n/2, p)**2) % p\n  else\n    (modp(n-1, p) * 2) % p\n  end\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4yvicai2\nStarted\n.\nFinished in 0.001351419 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    739.96 tests/s, 5179.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return 2 if\
    \ n == 1\n  return modp(n-1, p)**2 % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4f__l_ap\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp4f__l_ap.rb:21:in `test_modp'\n   \
    \  18: class TestHumanEval < Test::Unit::TestCase\n     19:   def test_modp\n\
    \     20:     candidate = method(:modp)\n  => 21:     assert_equal(3, candidate.call(3,\
    \ 5))\n     22:     assert_equal(2, candidate.call(1101, 101))\n     23:     assert_equal(1,\
    \ candidate.call(0, 101))\n     24:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<1>\n===============================================================================\n\
    \nFinished in 0.012514899 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    79.90 tests/s, 79.90 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return 2 * modp(n/2, p)**2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpe4hk8n1d\nStarted\n.\nFinished in 0.001100396 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    908.76 tests/s, 6361.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpih1qnsq7\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpih1qnsq7.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.012343545 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    81.01 tests/s, 81.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return modp(n / 2, p) ** 2 * 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_sld3wam\nStarted\n.\nFinished in 0.000639088 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1564.73 tests/s, 10953.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpc6q6pb7p\nStarted\n.\nFinished in 0.000676541 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1478.11 tests/s, 10346.75 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqat79cx4\nStarted\n.\nFinished in 0.000968042 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1033.01 tests/s, 7231.09 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpr4rpt6j5\nStarted\n.\nFinished in 0.000603739 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1656.34 tests/s, 11594.41 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n % 2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpektcpo5_\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpektcpo5_.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.00831541 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    120.26 tests/s, 240.52 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return 0 if\
    \ n < 0\n  return 1 if n == 1\n  return modp(n/2, p)**2 % p if n % 2 == 0\n  return\
    \ modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmptj4r6z99\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmptj4r6z99.rb:23:in `test_modp'\n   \
    \  20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_modp\n\
    \     22:     candidate = method(:modp)\n  => 23:     assert_equal(3, candidate.call(3,\
    \ 5))\n     24:     assert_equal(2, candidate.call(1101, 101))\n     25:     assert_equal(1,\
    \ candidate.call(0, 101))\n     26:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<2>\n===============================================================================\n\
    \nFinished in 0.013077061 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    76.47 tests/s, 76.47 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp69y388ar\nStarted\n.\nFinished in 0.000894163 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1118.36 tests/s, 7828.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmz0fexfk\nStarted\n.\nFinished in 0.000631826 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1582.71 tests/s, 11079.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return 2 * modp(n/2, p)**2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8cxnnl_h\nStarted\n.\nFinished in 0.001224903 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    816.39 tests/s, 5714.74 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return 2 if\
    \ n == 1\n  return modp(n/2, p)**2 % p if n.even?\n  return 2 * modp(n-1, p) %\
    \ p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_ogvgdt9\nStarted\n.\nFinished in 0.000881445 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1134.50 tests/s, 7941.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1hzuw5hg\nStarted\n.\nFinished in 0.000803636 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1244.34 tests/s, 8710.41 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr55i_1yg\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpr55i_1yg.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.008835098 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    113.18 tests/s, 113.18 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n / 2, p) ** 2 * (n % 2 == 0 ? 1 : 2)) % p\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0tyk396t\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp0tyk396t.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.007904847 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    126.50 tests/s, 253.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpiwljw6h5\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpiwljw6h5.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.016219026 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    61.66 tests/s, 61.66 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2iz9rjkj\nStarted\n.\nFinished in 0.001238532 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    807.41 tests/s, 5651.85 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n / 2, p)) % p if n.even?\n  return (2 * modp(n\
    \ / 2, p) + 1) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3,\
    \ candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1,\
    \ candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1,\
    \ candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3,\
    \ candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp43bdq2oz\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp43bdq2oz.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.016086788 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    62.16 tests/s, 124.33 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return (modp(n / 2, p) ** 2 * 2) % p if n\
    \ % 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpff0y9_7o\nStarted\n.\nFinished in 0.000754183 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1325.94 tests/s, 9281.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    return 1\n  end\n\
    \  if n % 2 == 0\n    return (modp(n / 2, p) ** 2) % p\n  else\n    return (modp(n\
    \ - 1, p) * 2) % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfg975izt\nStarted\n.\nFinished in 0.000598329 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1671.32 tests/s, 11699.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5lvwgr9p\nStarted\n.\nFinished in 0.00121241 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    824.80 tests/s, 5773.62 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * (n%2 == 0 ? 1 : n)) % p\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpam0q8opv\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpam0q8opv.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<99>\n===============================================================================\n\
    \nFinished in 0.010972872 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    91.13 tests/s, 182.27 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  raise ArgumentError, \"n must be\
    \ non-negative\" if n < 0\n  raise ArgumentError, \"p must be prime\" unless p.prime?\n\
    \  return 1 if n == 0\n  return 2 if n == 1\n  return 4 if n == 2\n  return 8\
    \ if n == 3\n  return 16 if n == 4\n  return 32 if n == 5\n  return 64 if n ==\
    \ 6\n  return 128 if n == 7\n  return 256 if n == 8\n  return 512 if n == 9\n\
    \  return 1024 if n == 10\n  return 2048 if n == 11\n  return 4096 if n == 12\n\
    \  return 8192 if n == 13\n  return 16384 if n == 14\n  return 32768 if n == 15\n\
    \  return 65536 if n == 16\n  return 131072 if n == 17\n  return 262144 if n ==\
    \ 18\n  return 524288 if n == 19\n  return 1048576 if n == 20\n  return 2097152\
    \ if n == 21\n  return 4194304 if n == 22\n  return 8388608 if n == 23\n  return\
    \ 16777216 if n == 24\n  return 33554432 if n == 25\n  return 67108864 if n ==\
    \ 26\n  return 134217728 if n == 27\n  return 268435456 if n == 28\n  return 536870912\
    \ if n == 29\n  return 1073741824 if n == 30\n  return 2147483648 if n == 31\n\
    \  return 4294967296 if n == 32\n  return 8589934592 if n == 33\n  return 17179869184\
    \ if n == 34\n  return 34359738368 if n == 35\n  return 68719476736 if n == 36\n\
    \  return 137438953472 if n == 37\n  return 274877906944 if n == 38\n  return\
    \ 549755813888 if n == 39\n  return 1099511627776 if n == 40\n  return 2199023255552\
    \ if n == 41\n  return 4398046511104 if n == 42\n  return 8796093022208 if n ==\
    \ 43\n  return 17592186044416 if n == 44\n  return 35184372088832 if n == 45\n\
    \  return\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n \
    \ def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "/tmp/tmpbxqf5cgw.rb:63: class definition in method body\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpbxqf5cgw.rb:74: syntax\
    \ error, unexpected end-of-input, expecting `end'\n"
  exit_code: 1
  status: SyntaxError
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n/2, p)) % p if n.even?\n  return (2 * modp(n/2,\
    \ p) + 1) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr4pago29\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpr4pago29.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.015980311 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    62.58 tests/s, 125.15 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n.even?\n\
    \    (modp(n/2, p)**2) % p\n  else\n    (modp(n-1, p) * 2) % p\n  end\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyi4mywen\nStarted\n.\nFinished in 0.00098307 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1017.22 tests/s, 7120.55 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxda5flbg\nStarted\n.\nFinished in 0.000965633 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1035.59 tests/s, 7249.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n.odd? ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpknrx06f1\nStarted\n.\nFinished in 0.00055199 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1811.63 tests/s, 12681.39 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return 0 if\
    \ n == 1\n  return (2 * modp(n-1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpugb05wkx\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpugb05wkx.rb:21:in `test_modp'\n   \
    \  18: class TestHumanEval < Test::Unit::TestCase\n     19:   def test_modp\n\
    \     20:     candidate = method(:modp)\n  => 21:     assert_equal(3, candidate.call(3,\
    \ 5))\n     22:     assert_equal(2, candidate.call(1101, 101))\n     23:     assert_equal(1,\
    \ candidate.call(0, 101))\n     24:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.01200373 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    83.31 tests/s, 83.31 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpt1alr18g\nStarted\n.\nFinished in 0.000942246 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1061.29 tests/s, 7429.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpeyqi1l_l\nStarted\n.\nFinished in 0.000548778 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1822.23 tests/s, 12755.61 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    return 1\n  end\n\
    \  if n % 2 == 0\n    return (modp(n/2, p) ** 2) % p\n  else\n    return (modp(n-1,\
    \ p) * 2) % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcneg6rid\nStarted\n.\nFinished in 0.000939559 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1064.33 tests/s, 7450.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpab8myo5d\nStarted\n.\nFinished in 0.000738237 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1354.58 tests/s, 9482.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * (2 % p)) % p if n % 2 == 0\n  return\
    \ (modp(n/2, p)**2 * (2 % p) * (n % p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqjz3ee3d\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpqjz3ee3d.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<13>\n===============================================================================\n\
    \nFinished in 0.008877717 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    112.64 tests/s, 225.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return 2 if\
    \ n == 1\n  return modp(n/2, p)**2 % p if n % 2 == 0\n  return 2 * modp(n-1, p)\
    \ % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfyakv7d5\nStarted\n.\nFinished in 0.000939321 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1064.60 tests/s, 7452.19 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n / 2, p)) % p if n.even?\n  return (2 * modp(n\
    \ / 2, p) + 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3tm5apwc\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp3tm5apwc.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.007688399 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    130.07 tests/s, 260.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * modp(n%2, p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp9v2qs5s1\nStarted\nE\n===============================================================================\n\
    Error: test_modp(TestHumanEval): SystemStackError: stack level too deep\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n\
    /tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in `modp'\n/tmp/tmp9v2qs5s1.rb:14:in\
    \ `modp'\n/tmp/tmp"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement\n  if n == 0\n\
    \    return 1\n  end\n  if n % 2 == 0\n    return (modp(n/2, p)**2) % p\n  else\n\
    \    return (modp(n-1, p) * 2) % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpxv8zmkko\nStarted\n.\nFinished in 0.001449471 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    689.91 tests/s, 4829.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p) ** 2) % p if n % 2 == 0\n  return (modp(n/2,\
    \ p) ** 2 * n) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpkudisqdg\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpkudisqdg.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<99>\n===============================================================================\n\
    \nFinished in 0.00754585 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    132.52 tests/s, 265.05 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmphfztresy\nStarted\n.\nFinished in 0.00063709 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1569.64 tests/s, 10987.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n%2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxv5h14_9\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpxv5h14_9.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.012788721 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    78.19 tests/s, 156.39 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n if\
    \ n == 1\n  if n % 2 == 0\n    modp(n/2, p)**2 % p\n  else\n    n * modp(n-1,\
    \ p) % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4ftsnn1s\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp4ftsnn1s.rb:26:in `test_modp'\n   \
    \  23:   def test_modp\n     24:     candidate = method(:modp)\n     25:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 26:     assert_equal(2, candidate.call(1101, 101))\n\
    \     27:     assert_equal(1, candidate.call(0, 101))\n     28:     assert_equal(8,\
    \ candidate.call(3, 11))\n     29:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<94>\n===============================================================================\n\
    \nFinished in 0.014073113 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    71.06 tests/s, 142.11 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * (n % 2 == 0 ? 1 : 2)) % p\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxz2z0iew\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpxz2z0iew.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.009524289 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    104.99 tests/s, 209.99 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppt1xh04w\nStarted\n.\nFinished in 0.002468881 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    405.04 tests/s, 2835.29 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpuf4hsi8e\nStarted\n.\nFinished in 0.000978696 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1021.77 tests/s, 7152.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return modp(n / 2, p) ** 2 * 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_glu8_mt\nStarted\n.\nFinished in 0.000518901 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1927.15 tests/s, 13490.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp83tt6zpg\nStarted\n.\nFinished in 0.000953991 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1048.23 tests/s, 7337.60 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp0qw2bp9h\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp0qw2bp9h.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.014860343 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    67.29 tests/s, 67.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmplvzcrxii\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmplvzcrxii.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.010636983 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    94.01 tests/s, 94.01 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement this function\n\
    \  return 1 if n == 0\n  return 2 if n == 1\n  return (2 * modp(n - 1, p)) % p\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq8jnxih5\nStarted\n.\nFinished in 0.001935526 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    516.66 tests/s, 3616.59 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n / 2, p) ** 2 * (n % 2 == 0 ? 1 : 2)) % p\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpf_alkik8\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpf_alkik8.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.010652197 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    93.88 tests/s, 187.75 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvce7fjhd\nStarted\n.\nFinished in 0.001111882 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    899.38 tests/s, 6295.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement me\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp_qqix681\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp_qqix681.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.013809066 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    72.42 tests/s, 72.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return modp(n / 2, p) ** 2 * 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4vb3k03w\nStarted\n.\nFinished in 0.000567752 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1761.33 tests/s, 12329.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  modp(n/2, p)**2 * modp(n%2, p) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpeo14thbi\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpeo14thbi.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.008279824 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    120.78 tests/s, 241.55 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (n % p) * (modp(n - 1, p) % p) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpovbs4ra8\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpovbs4ra8.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.012198312 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    81.98 tests/s, 163.96 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n / 2, p)) % p if n.even?\n  return (2 * modp(n\
    \ / 2, p) + 1) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3,\
    \ candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1,\
    \ candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1,\
    \ candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3,\
    \ candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6qlk6_sy\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp6qlk6_sy.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.007239158 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    138.14 tests/s, 276.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp0271k87e\nStarted\n.\nFinished in 0.001359957 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    735.32 tests/s, 5147.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return (modp(n/2, p)**2 * 2) % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkil54sng\nStarted\n.\nFinished in 0.000545755 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1832.32 tests/s, 12826.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_p0wjj42\nStarted\n.\nFinished in 0.001298852 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    769.91 tests/s, 5389.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n / 2, p)) % p if n % 2 == 0\n  return (2 * modp(n\
    \ / 2, p) + 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpi7qm2u7h\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpi7qm2u7h.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.00848146 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    117.90 tests/s, 235.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement me\n  return 1\
    \ if n == 0\n  return n if n == 1\n  return 2 if n == 2\n  return (modp(n-1, p)\
    \ * 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpli42flwg\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpli42flwg.rb:23:in `test_modp'\n   \
    \  20: class TestHumanEval < Test::Unit::TestCase\n     21:   def test_modp\n\
    \     22:     candidate = method(:modp)\n  => 23:     assert_equal(3, candidate.call(3,\
    \ 5))\n     24:     assert_equal(2, candidate.call(1101, 101))\n     25:     assert_equal(1,\
    \ candidate.call(0, 101))\n     26:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<4>\n===============================================================================\n\
    \nFinished in 0.007339528 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    136.25 tests/s, 136.25 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp27kxhq7r\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp27kxhq7r.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.014266672 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    70.09 tests/s, 70.09 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    return 1\n  end\n\
    \  if n % 2 == 0\n    return (modp(n/2, p) ** 2) % p\n  else\n    return (modp(n/2,\
    \ p) ** 2 * 2) % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp34ujrj1c\nStarted\n.\nFinished in 0.000557981 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1792.18 tests/s, 12545.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    return 1\n  elsif\
    \ n == 1\n    return 2 % p\n  else\n    return (modp(n - 1, p) ** 2) % p\n  end\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpkfs4vr81\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpkfs4vr81.rb:25:in `test_modp'\n   \
    \  22: class TestHumanEval < Test::Unit::TestCase\n     23:   def test_modp\n\
    \     24:     candidate = method(:modp)\n  => 25:     assert_equal(3, candidate.call(3,\
    \ 5))\n     26:     assert_equal(2, candidate.call(1101, 101))\n     27:     assert_equal(1,\
    \ candidate.call(0, 101))\n     28:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<1>\n===============================================================================\n\
    \nFinished in 0.015680546 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    63.77 tests/s, 63.77 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n%2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5q76dbqc\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp5q76dbqc.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.012980895 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    77.04 tests/s, 154.07 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement\n  if n == 0\n\
    \    return 1\n  end\n  if n % 2 == 0\n    return (modp(n/2, p)**2) % p\n  else\n\
    \    return (modp(n-1, p) * 2) % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppm304l9e\nStarted\n.\nFinished in 0.000594576 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1681.87 tests/s, 11773.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n if\
    \ n == 1\n  return modp(n/2, p)**2 % p if n.even?\n  return modp(n/2, p)**2 *\
    \ 2 % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpqx0vr8em\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpqx0vr8em.rb:22:in `test_modp'\n   \
    \  19: class TestHumanEval < Test::Unit::TestCase\n     20:   def test_modp\n\
    \     21:     candidate = method(:modp)\n  => 22:     assert_equal(3, candidate.call(3,\
    \ 5))\n     23:     assert_equal(2, candidate.call(1101, 101))\n     24:     assert_equal(1,\
    \ candidate.call(0, 101))\n     25:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<2>\n===============================================================================\n\
    \nFinished in 0.007680308 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    130.20 tests/s, 130.20 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpgvj79eh4\nStarted\n.\nFinished in 0.00073429 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1361.86 tests/s, 9533.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpef8t5ok5\nStarted\n.\nFinished in 0.00076944 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1299.65 tests/s, 9097.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp79dhq7fo\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp79dhq7fo.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.009115047 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    109.71 tests/s, 109.71 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzq0h72gu\nStarted\n.\nFinished in 0.000849559 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1177.08 tests/s, 8239.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpx_8umiy1\nStarted\n.\nFinished in 0.000559759 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1786.48 tests/s, 12505.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4bbx8smx\nStarted\n.\nFinished in 0.001454977 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    687.30 tests/s, 4811.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return 2 if\
    \ n == 1\n  return 4 if n == 2\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "/tmp/tmpg0vqmg17.rb:17: class definition in method body\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n^~~~~~~~~~~~~~~~~~~\n/tmp/tmpg0vqmg17.rb:28: syntax\
    \ error, unexpected end-of-input, expecting `end'\n"
  exit_code: 1
  status: SyntaxError
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p) ** 2 * (n % 2 == 0 ? 1 : n)) % p\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp7f7_l2_d\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp7f7_l2_d.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<99>\n===============================================================================\n\
    \nFinished in 0.016633268 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    60.12 tests/s, 120.24 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n if\
    \ n == 1\n  return modp(n/2, p)**2 % p if n % 2 == 0\n  return n * modp(n-1, p)\
    \ % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjtxnm7jn\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpjtxnm7jn.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<94>\n===============================================================================\n\
    \nFinished in 0.011564356 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    86.47 tests/s, 172.95 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmploi7yl1y\nStarted\n.\nFinished in 0.001899579 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    526.43 tests/s, 3685.03 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2ckev2p7\nStarted\n.\nFinished in 0.000775704 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1289.15 tests/s, 9024.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * (n % 2 == 0 ? 1 : 2)) % p\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxjh_pmjc\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpxjh_pmjc.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.009484876 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    105.43 tests/s, 210.86 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6l2e0r5k\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp6l2e0r5k.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.01315937 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    75.99 tests/s, 75.99 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpewsxw788\nStarted\n.\nFinished in 0.00051783 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1931.14 tests/s, 13517.95 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpsv1vpke1\nStarted\n.\nFinished in 0.000877999 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1138.95 tests/s, 7972.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n % 2 ==\
    \ 0\n    (modp(n/2, p) ** 2) % p\n  else\n    (modp(n/2, p) ** 2 * 2) % p\n  end\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkkp17j5w\nStarted\n.\nFinished in 0.000866182 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1154.49 tests/s, 8081.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n / 2, p) ** 2 * (n % 2 == 0 ? 1 : n)) % p\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp62gy810k\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp62gy810k.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<99>\n===============================================================================\n\
    \nFinished in 0.014105706 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    70.89 tests/s, 141.79 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqohl6xfg\nStarted\n.\nFinished in 0.001379309 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    725.00 tests/s, 5075.00 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p if n.even?\n  return (2 * modp(n - 1, p) - 1) % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpuvqfclcc\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpuvqfclcc.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<1>\n===============================================================================\n\
    \nFinished in 0.011825567 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    84.56 tests/s, 169.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpwh7bk4id\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpwh7bk4id.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.012130093 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    82.44 tests/s, 82.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n.odd? ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8zt3evqc\nStarted\n.\nFinished in 0.000630828 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1585.22 tests/s, 11096.53 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu_z6k_9i\nStarted\n.\nFinished in 0.000702315 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1423.86 tests/s, 9967.04 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyn41ifmw\nStarted\n.\nFinished in 0.000558634 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1790.08 tests/s, 12530.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (n % p) * modp(n / p, p) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprmz8y0bp\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmprmz8y0bp.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<1>\n===============================================================================\n\
    \nFinished in 0.008951513 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    111.71 tests/s, 223.43 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps5vkd7nj\nStarted\n.\nFinished in 0.001256232 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    796.03 tests/s, 5572.22 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprcjkl4ap\nStarted\n.\nFinished in 0.000957732 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1044.13 tests/s, 7308.93 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqtgcfhxj\nStarted\n.\nFinished in 0.000772834 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1293.94 tests/s, 9057.57 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpo4vc016f\nStarted\n.\nFinished in 0.000701156 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1426.22 tests/s, 9983.51 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n if\
    \ n == 1\n  return modp(n/2, p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2\
    \ * n % p if n % 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpflymj4ew\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpflymj4ew.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<94>\n===============================================================================\n\
    \nFinished in 0.009503678 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    105.22 tests/s, 210.44 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpur7936to\nStarted\n.\nFinished in 0.000545841 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1832.04 tests/s, 12824.25 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4kqwjiqb\nStarted\n.\nFinished in 0.001267274 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    789.10 tests/s, 5523.67 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8mhoyoh5\nStarted\n.\nFinished in 0.001123106 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    890.39 tests/s, 6232.72 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmph6a2ux5a\nStarted\n.\nFinished in 0.001600388 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    624.85 tests/s, 4373.94 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpxwi66mk7\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpxwi66mk7.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.012153267 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    82.28 tests/s, 82.28 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 * (n % 2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5vj8wawm\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp5vj8wawm.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.009860821 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    101.41 tests/s, 101.41 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpzlqfc_fb\nStarted\n.\nFinished in 0.000597623 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1673.30 tests/s, 11713.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return (2 * modp(n/2, p)**2) % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnxkepbqn\nStarted\n.\nFinished in 0.000563033 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1776.09 tests/s, 12432.66 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement this function\n\
    \  return 1 if n == 0\n  return (2 * modp(n - 1, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpp4bcewij\nStarted\n.\nFinished in 0.001141116 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    876.34 tests/s, 6134.35 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpdeym41z9\nStarted\n.\nFinished in 0.000865711 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1155.12 tests/s, 8085.84 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpaoe7ep3k\nStarted\n.\nFinished in 0.002619949 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    381.69 tests/s, 2671.81 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp00lrk7ar\nStarted\n.\nFinished in 0.000547306 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1827.13 tests/s, 12789.92 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvc304igp\nStarted\n.\nFinished in 0.000578881 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1727.47 tests/s, 12092.30 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1rmou66h\nStarted\n.\nFinished in 0.001330635 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    751.52 tests/s, 5260.65 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyrbf1w6q\nStarted\n.\nFinished in 0.000642965 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1555.29 tests/s, 10887.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return modp(n / 2, p) ** 2 * 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwmgce66u\nStarted\n.\nFinished in 0.000778438 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1284.62 tests/s, 8992.37 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return (2 *\
    \ modp(n - 1, p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfjqaao45\nStarted\n.\nFinished in 0.001168686 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    855.66 tests/s, 5989.63 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p) ** 2) % p if n.even?\n  return (modp(n/2,\
    \ p) ** 2 * n) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3,\
    \ candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1,\
    \ candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1,\
    \ candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3,\
    \ candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpzd0ekx3a\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpzd0ekx3a.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<99>\n===============================================================================\n\
    \nFinished in 0.008353561 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    119.71 tests/s, 239.42 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpuy2i4o6d\nStarted\n.\nFinished in 0.000969291 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1031.68 tests/s, 7221.77 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp1yb8lo10\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp1yb8lo10.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.00815432 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    122.63 tests/s, 122.63 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpmtbcfkxw\nStarted\n.\nFinished in 0.000738986 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1353.21 tests/s, 9472.44 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (2 * modp(n/2, p)**2) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpggzyouy1\nStarted\n.\nFinished in 0.001459821 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    685.02 tests/s, 4795.11 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return modp(n / 2, p) ** 2 * 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpeq04gcav\nStarted\n.\nFinished in 0.000640998 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1560.07 tests/s, 10920.47 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return 2 * modp(n / 2, p) ** 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpci43feuw\nStarted\n.\nFinished in 0.000717956 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1392.84 tests/s, 9749.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n == 1\n\
    \    n % p\n  else\n    (modp(n / 2, p) ** 2) % p\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmprra_grcv\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmprra_grcv.rb:25:in `test_modp'\n   \
    \  22: class TestHumanEval < Test::Unit::TestCase\n     23:   def test_modp\n\
    \     24:     candidate = method(:modp)\n  => 25:     assert_equal(3, candidate.call(3,\
    \ 5))\n     26:     assert_equal(2, candidate.call(1101, 101))\n     27:     assert_equal(1,\
    \ candidate.call(0, 101))\n     28:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<1>\n===============================================================================\n\
    \nFinished in 0.009355004 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    106.89 tests/s, 106.89 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  raise ArgumentError, \"n must be\
    \ non-negative\" if n < 0\n  raise ArgumentError, \"p must be prime\" unless p.prime?\n\
    \  return 1 if n == 0\n  return n % p if n < p\n  return (modp(n/2, p)**2 * modp(n%2,\
    \ p)) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3jz5tmof\nStarted\nE\n===============================================================================\n\
    Error: test_modp(TestHumanEval): NoMethodError: undefined method `prime?' for\
    \ 5:Integer\n/tmp/tmp3jz5tmof.rb:14:in `modp'\n/tmp/tmp3jz5tmof.rb:23:in `call'\n\
    /tmp/tmp3jz5tmof.rb:23:in `test_modp'\n     20: class TestHumanEval < Test::Unit::TestCase\n\
    \     21:   def test_modp\n     22:     candidate = method(:modp)\n  => 23:  \
    \   assert_equal(3, candidate.call(3, 5))\n     24:     assert_equal(2, candidate.call(1101,\
    \ 101))\n     25:     assert_equal(1, candidate.call(0, 101))\n     26:     assert_equal(8,\
    \ candidate.call(3, 11))\n===============================================================================\n\
    \nFinished in 0.008661407 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 0 assertions, 0 failures, 1 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    115.45 tests/s, 0.00 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpqezhq_0n\nStarted\n.\nFinished in 0.000743247 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1345.45 tests/s, 9418.13 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp5e83s42o\nStarted\n.\nFinished in 0.000861371 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1160.94 tests/s, 8126.58 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkic51gck\nStarted\n.\nFinished in 0.00094532 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1057.84 tests/s, 7404.90 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n / 2, p) ** 2 * (n % 2 == 0 ? 1 : 2)) % p\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmppytps7xj\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmppytps7xj.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.016983092 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    58.88 tests/s, 117.76 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmparp6efio\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmparp6efio.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.012847986 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    77.83 tests/s, 77.83 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n == 1\n\
    \    n % p\n  else\n    if n % 2 == 0\n      modp(n/2, p)**2 % p\n    else\n \
    \     (modp(n/2, p)**2 * n) % p\n    end\n  end\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp4iddgc2u\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp4iddgc2u.rb:30:in `test_modp'\n   \
    \  27:   def test_modp\n     28:     candidate = method(:modp)\n     29:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 30:     assert_equal(2, candidate.call(1101, 101))\n\
    \     31:     assert_equal(1, candidate.call(0, 101))\n     32:     assert_equal(8,\
    \ candidate.call(3, 11))\n     33:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<94>\n===============================================================================\n\
    \nFinished in 0.01686046 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    59.31 tests/s, 118.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmps21iwxgk\nStarted\n.\nFinished in 0.000697971 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1432.72 tests/s, 10029.07 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp_0u5ube_\nStarted\n.\nFinished in 0.000556231 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1797.81 tests/s, 12584.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n / 2, p) ** 2 * (n % 2 == 0 ? 1 : 2)) % p\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp9uwdf_a9\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp9uwdf_a9.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.011755936 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    85.06 tests/s, 170.13 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpcrktm3rj\nStarted\n.\nFinished in 0.000576351 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1735.05 tests/s, 12145.38 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpu8lbruom\nStarted\n.\nFinished in 0.001075895 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    929.46 tests/s, 6506.21 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpziddht3t\nStarted\n.\nFinished in 0.000554022 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1804.98 tests/s, 12634.88 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n%2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpn2km1zgd\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpn2km1zgd.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.007259766 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    137.75 tests/s, 275.49 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfdjgn4e8\nStarted\n.\nFinished in 0.000793646 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1260.01 tests/s, 8820.05 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpq6k62uc9\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpq6k62uc9.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.011857763 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    84.33 tests/s, 84.33 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp7ufway5g\nStarted\n.\nFinished in 0.000868773 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1151.05 tests/s, 8057.34 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp6th0hcq5\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp6th0hcq5.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.011202936 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    89.26 tests/s, 89.26 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return (modp(n/2, p)**2 * 2) % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1o8a2eqn\nStarted\n.\nFinished in 0.000653509 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1530.20 tests/s, 10711.41 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp6unoznno\nStarted\n.\nFinished in 0.000604842 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1653.32 tests/s, 11573.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppchgm00d\nStarted\n.\nFinished in 0.000532194 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1879.01 tests/s, 13153.10 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpii7k2eg9\nStarted\n.\nFinished in 0.001166139 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    857.53 tests/s, 6002.71 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n / 2, p) ** 2) % p if n.even?\n  return (modp(n\
    \ / 2, p) ** 2 * 2) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpweozu6xa\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpweozu6xa.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<10>\n===============================================================================\n\
    \nFinished in 0.013380058 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    74.74 tests/s, 149.48 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpfuslwaly\nStarted\n.\nFinished in 0.00061572 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1624.11 tests/s, 11368.80 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n % 2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp078zufu0\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp078zufu0.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.01345176 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    74.34 tests/s, 148.68 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (n % p) * modp(n - 1, p) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp2xnyuk3x\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp2xnyuk3x.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.014617352 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    68.41 tests/s, 136.82 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    return 1\n  elsif\
    \ n == 1\n    return 2 % p\n  elsif n % 2 == 0\n    return (modp(n/2, p) ** 2)\
    \ % p\n  else\n    return (2 * modp(n-1, p)) % p\n  end\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp1gndzpl3\nStarted\n.\nFinished in 0.001599378 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    625.24 tests/s, 4376.70 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (2 * modp(n / 2, p)) % p if n.even?\n  return (2 * modp(n\
    \ / 2, p) + 1) % p if n.odd?\nend\nrequire 'test/unit'\nclass TestHumanEval <\
    \ Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n    assert_equal(3,\
    \ candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1,\
    \ candidate.call(0, 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1,\
    \ candidate.call(100, 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3,\
    \ candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpmzrix4j8\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpmzrix4j8.rb:23:in `test_modp'\n   \
    \  20:   def test_modp\n     21:     candidate = method(:modp)\n     22:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 23:     assert_equal(2, candidate.call(1101, 101))\n\
    \     24:     assert_equal(1, candidate.call(0, 101))\n     25:     assert_equal(8,\
    \ candidate.call(3, 11))\n     26:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<91>\n===============================================================================\n\
    \nFinished in 0.015541173 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    64.35 tests/s, 128.69 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpup4v46h1\nStarted\n.\nFinished in 0.000959041 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1042.71 tests/s, 7298.96 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpw40y0w0w\nStarted\n.\nFinished in 0.000927357 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1078.33 tests/s, 7548.33 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp4183zji7\nStarted\n.\nFinished in 0.00064238 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1556.71 tests/s, 10896.98 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  modp(n/2, p)**2 * modp(n%2, p)\nend\nrequire 'test/unit'\nclass\
    \ TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpygae8pqc\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpygae8pqc.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<208998227690370098316628197376>\n\ndiff:\n? 208998227690370098316628197376\n\
    ===============================================================================\n\
    \nFinished in 0.008842722 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    113.09 tests/s, 226.17 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n%2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjujaiz11\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpjujaiz11.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.006550984 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    152.65 tests/s, 305.30 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmplz7sk9hr\nStarted\n.\nFinished in 0.000797093 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1254.56 tests/s, 8781.91 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement\n  return 1 if\
    \ n == 0\n  return 2 if n == 1\n  return modp(n-1, p) * 2 % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpi_csrfz2\nStarted\n.\nFinished in 0.00105676 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    946.29 tests/s, 6624.02 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpyqznu9f8\nStarted\n.\nFinished in 0.000693116 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1442.76 tests/s, 10099.32 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpllet74cg\nStarted\n.\nFinished in 0.001632361 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    612.61 tests/s, 4288.27 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpbd1sgqfh\nStarted\n.\nFinished in 0.000829145 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1206.06 tests/s, 8442.43 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * modp(n%2, p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpcqi58822\nStarted\nE\n===============================================================================\n\
    Error: test_modp(TestHumanEval): SystemStackError: stack level too deep\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n\
    /tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in `modp'\n/tmp/tmpcqi58822.rb:14:in\
    \ `modp'\n/tmp/tmp"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n.even? ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp87j5fd5y\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp87j5fd5y.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.011958828 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    83.62 tests/s, 83.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp2jg5pqhz\nStarted\n.\nFinished in 0.000567466 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1762.22 tests/s, 12335.54 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpnb4qa5h6\nStarted\n.\nFinished in 0.000708089 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1412.25 tests/s, 9885.76 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : 2) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpexb1p68f\nStarted\n.\nFinished in 0.000877164 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1140.04 tests/s, 7980.26 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return modp(n / 2, p) ** 2 * 2 % p if n %\
    \ 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpi7v_jouj\nStarted\n.\nFinished in 0.000558907 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1789.21 tests/s, 12524.45 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return (modp(n/2, p)**2 * 2) % p if n % 2 == 1\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpvos_d6lp\nStarted\n.\nFinished in 0.000608922 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1642.25 tests/s, 11495.73 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp8dpta_yc\nStarted\n.\nFinished in 0.000592013 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1689.15 tests/s, 11824.06 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 1 ? 2 : 1) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpq0nsekm7\nStarted\n.\nFinished in 0.000548411 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1823.45 tests/s, 12764.15 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # TODO: implement me\n  return 1\
    \ if n == 0\n  return n if n == 1\n  return modp(n-1, p) * n % p\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp3bp97n35\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp3bp97n35.rb:22:in `test_modp'\n   \
    \  19: class TestHumanEval < Test::Unit::TestCase\n     20:   def test_modp\n\
    \     21:     candidate = method(:modp)\n  => 22:     assert_equal(3, candidate.call(3,\
    \ 5))\n     23:     assert_equal(2, candidate.call(1101, 101))\n     24:     assert_equal(1,\
    \ candidate.call(0, 101))\n     25:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<1>\n===============================================================================\n\
    \nFinished in 0.008604442 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    116.22 tests/s, 116.22 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpn2rhe_mu\nStarted\n.\nFinished in 0.001610912 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    620.77 tests/s, 4345.36 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    return 1\n  elsif\
    \ n % 2 == 0\n    return modp(n/2, p)**2 % p\n  else\n    return modp(n-1, p)\
    \ * modp(n-1, p) * 2 % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp261het70\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp261het70.rb:25:in `test_modp'\n   \
    \  22: class TestHumanEval < Test::Unit::TestCase\n     23:   def test_modp\n\
    \     24:     candidate = method(:modp)\n  => 25:     assert_equal(3, candidate.call(3,\
    \ 5))\n     26:     assert_equal(2, candidate.call(1101, 101))\n     27:     assert_equal(1,\
    \ candidate.call(0, 101))\n     28:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<2>\n===============================================================================\n\
    \nFinished in 0.006743708 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    148.29 tests/s, 148.29 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return (modp(n/2, p)**2 * 2) % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpwvxkpu9g\nStarted\n.\nFinished in 0.001567938 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    637.78 tests/s, 4464.46 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n % 2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpp4vlp2so\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpp4vlp2so.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.011652844 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    85.82 tests/s, 85.82 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n % 2 == 0\n  return (modp(n / 2, p) ** 2 * 2) % p if n\
    \ % 2 == 1\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpkxjpxnbz\nStarted\n.\nFinished in 0.000658273 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1519.13 tests/s, 10633.89 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n\
    \ / 2, p) ** 2 % p if n.even?\n  return 2 * modp(n / 2, p) ** 2 % p if n.odd?\n\
    end\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmppnqz5mrq\nStarted\n.\nFinished in 0.001056726 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    946.32 tests/s, 6624.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return modp(n/2, p)**2 * 2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmpahyhlvdm\nStarted\n.\nFinished in 0.000696159 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1436.45 tests/s, 10055.17 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpr48phsk4\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpr48phsk4.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.00878219 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    113.87 tests/s, 113.87 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return n %\
    \ p if n < p\n  return (modp(n/2, p)**2 * modp(n%2, p)) % p\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpx81u1olg\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpx81u1olg.rb:22:in `test_modp'\n   \
    \  19:   def test_modp\n     20:     candidate = method(:modp)\n     21:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 22:     assert_equal(2, candidate.call(1101, 101))\n\
    \     23:     assert_equal(1, candidate.call(0, 101))\n     24:     assert_equal(8,\
    \ candidate.call(3, 11))\n     25:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<56>\n===============================================================================\n\
    \nFinished in 0.008627816 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    115.90 tests/s, 231.81 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n.even?\n  return 2 * modp(n/2, p)**2 % p if n.odd?\nend\nrequire\
    \ 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n \
    \   candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n   \
    \ assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmprko4c9g4\nStarted\n.\nFinished in 0.000516787 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1935.03 tests/s, 13545.23 assertions/s\n"
  exit_code: 0
  status: OK
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 * (n%2 == 0 ? 1 : p) % p\nend\nrequire 'test/unit'\nclass TestHumanEval\
    \ < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n   \
    \ assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmpjto6y570\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmpjto6y570.rb:20:in `test_modp'\n   \
    \  17: class TestHumanEval < Test::Unit::TestCase\n     18:   def test_modp\n\
    \     19:     candidate = method(:modp)\n  => 20:     assert_equal(3, candidate.call(3,\
    \ 5))\n     21:     assert_equal(2, candidate.call(1101, 101))\n     22:     assert_equal(1,\
    \ candidate.call(0, 101))\n     23:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<0>\n===============================================================================\n\
    \nFinished in 0.011412456 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    87.62 tests/s, 87.62 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  # your code here\nend\nrequire 'test/unit'\n\
    class TestHumanEval < Test::Unit::TestCase\n  def test_modp\n    candidate = method(:modp)\n\
    \    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2, candidate.call(1101,\
    \ 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8, candidate.call(3,\
    \ 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4, candidate.call(30,\
    \ 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp5cy709wx\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp5cy709wx.rb:19:in `test_modp'\n   \
    \  16: class TestHumanEval < Test::Unit::TestCase\n     17:   def test_modp\n\
    \     18:     candidate = method(:modp)\n  => 19:     assert_equal(3, candidate.call(3,\
    \ 5))\n     20:     assert_equal(2, candidate.call(1101, 101))\n     21:     assert_equal(1,\
    \ candidate.call(0, 101))\n     22:     assert_equal(8, candidate.call(3, 11))\n\
    <3> expected but was\n<nil>\n===============================================================================\n\
    \nFinished in 0.006983149 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 1 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    143.20 tests/s, 143.20 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  if n == 0\n    1\n  elsif n == 1\n\
    \    n\n  elsif n.even?\n    modp(n/2, p)**2 % p\n  else\n    n * modp(n-1, p)\
    \ % p\n  end\nend\nrequire 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n\
    \  def test_modp\n    candidate = method(:modp)\n    assert_equal(3, candidate.call(3,\
    \ 5))\n    assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: "Loaded suite /tmp/tmp270smkox\nStarted\nF\n===============================================================================\n\
    Failure: test_modp(TestHumanEval)\n/tmp/tmp270smkox.rb:28:in `test_modp'\n   \
    \  25:   def test_modp\n     26:     candidate = method(:modp)\n     27:     assert_equal(3,\
    \ candidate.call(3, 5))\n  => 28:     assert_equal(2, candidate.call(1101, 101))\n\
    \     29:     assert_equal(1, candidate.call(0, 101))\n     30:     assert_equal(8,\
    \ candidate.call(3, 11))\n     31:     assert_equal(1, candidate.call(100, 101))\n\
    <2> expected but was\n<94>\n===============================================================================\n\
    \nFinished in 0.007446726 seconds.\n-------------------------------------------------------------------------------\n\
    1 tests, 2 assertions, 1 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    0% passed\n-------------------------------------------------------------------------------\n\
    134.29 tests/s, 268.57 assertions/s\n"
  stderr: ''
  exit_code: 1
  status: Exception
- program: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n\
    # >>> modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n\
    # >>> modp(100, 101)\n# 1\ndef modp(n, p)\n  return 1 if n == 0\n  return modp(n/2,\
    \ p)**2 % p if n % 2 == 0\n  return modp(n/2, p)**2 * 2 % p if n % 2 == 1\nend\n\
    require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
    \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n  \
    \  assert_equal(2, candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0,\
    \ 101))\n    assert_equal(8, candidate.call(3, 11))\n    assert_equal(1, candidate.call(100,\
    \ 101))\n    assert_equal(4, candidate.call(30, 5))\n    assert_equal(3, candidate.call(31,\
    \ 5))\n  end\nend\n"
  stdout: ''
  stderr: "Loaded suite /tmp/tmp45sdc5cr\nStarted\n.\nFinished in 0.000760656 seconds.\n\
    -------------------------------------------------------------------------------\n\
    1 tests, 7 assertions, 0 failures, 0 errors, 0 pendings, 0 omissions, 0 notifications\n\
    100% passed\n-------------------------------------------------------------------------------\n\
    1314.65 tests/s, 9202.58 assertions/s\n"
  exit_code: 0
  status: OK
