name: HumanEval_145_order_by_points
language: rb
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11,\
  \ 1, -12, 11]\n# >>> order_by_points([]) == []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  sums = []\n  sums_with_index = []\n  sums_with_index_sorted = []\n\
    \  i = 0\n  nums.each do |num|\n    sum = num.to_s.chars.map(&:to_i).reduce(:+)\n\
    \    sums << sum\n    sums_with_index << [sum, i]\n    i += 1\n  end\n  sums_with_index_sorted\
    \ = sums_with_index.sort_by{|e| [e[0], e[1]]}\n  sorted_nums = []\n  sums_with_index_sorted.each\
    \ do |e|\n    sorted_nums << nums[e[1]]\n  end\n  sorted_nums\nend", "  nums.sort_by{|x|\
    \ [x.abs.digits.sum, nums.index(x)]}\nend", "  # your code here\nend", "    nums.sort_by.with_index{|i,j|\
    \ [i.digits.sum, j]}\nend", "  # Your code here\nend", "  # TODO: Implement me!\n\
    end", "  nums.sort_by.with_index { |n, i| [n.digits.sum, i] }\nend", "  nums.sort_by\
    \ { |num| [num.abs.digits.sum, nums.index(num)] }\nend", "  nums.sort_by { |n|\
    \ [n.digits.sum, nums.index(n)] }\nend", "  nums.sort_by { |i| [i.abs.digits.sum,\
    \ nums.index(i)] }\nend", "  # your code here\nend", "  nums.sort_by{|x| [x.digits.sum,\
    \ nums.index(x)]}\nend", "  sums = []\n  nums.each_with_index do |n, i|\n    sums[i]\
    \ = n.to_s.split('').map(&:to_i).reduce(:+)\n  end\n  # I now have an array of\
    \ arrays, where the inner array is [original index, sum of digits]\n  # I need\
    \ to sort the outer array based on the sum of digits, while preserving\n  # the\
    \ original index of each array.\n  # If the sum of digits is equal, sort by index\
    \ of the original array.\n  sums.sort_by! { |a| [a[1], a[0]] }\n  # I have now\
    \ sorted the array\n  # I need to map the sorted array to return the original\
    \ value of the original array\n  # at the index stored in the array\n  sums.map!\
    \ { |arr| nums[arr[0]] }\nend", "  return [] if nums.empty?\n  nums.sort_by {\
    \ |num| [num.digits.sum, nums.index(num)] }\nend", "  nums.sort_by.with_index\
    \ { |num, index| [num.to_s.chars.map(&:to_i).sum, index] }\nend", "  nums.sort_by.with_index\
    \ { |n, i| [sum_of_digits(n), i] }\nend", "  nums.sort_by.with_index { |num, i|\
    \ [num.digits.sum, i] }\nend", "\t\nend", "  nums.sort_by.with_index do |x, i|\n\
    \    [sum_of_digits(x), i]\n  end\nend", "  nums.sort_by { |num| [num.digits.sum,\
    \ nums.index(num)] }\nend", "  nums.sort_by { |num| [num.abs.digits.sum, nums.index(num)]\
    \ }\nend", "  return [] if nums.empty?\n  return nums if nums.size == 1\n  # nums.map\
    \ { |i| i.to_s.chars.map(&:to_i).sum }\n  nums.map { |i| i.to_s.chars.map(&:to_i).sum\
    \ }.sort\nend", "  nums.sort_by.with_index { |v, i| [v.digits.sum, i] }\nend",
  "  if nums.length == 0\n    return []\n  end\n  if nums.length == 1\n    return\
    \ nums\n  end\n  array = []\n  sum_list = []\n  nums.each_with_index do |num,\
    \ index|\n    array.push(num)\n    sum_list.push(num.to_s.split('').map(&:to_i).sum)\n\
    \  end\n  new_array = []\n  length = array.length\n  array.each_with_index do\
    \ |num, index|\n    idx = sum_list.index(sum_list.min)\n    array.delete_at(idx)\n\
    \    sum_list.delete_at(idx)\n    new_array.push(num)\n  end\n  return new_array\n\
    end", "  sum_dict = {}\n  nums.each_with_index do |i, index|\n    sum_dict[i]\
    \ = i.to_s.chars.map(&:to_i).sum + index\n  end\n  sum_dict.sort_by { |k, v| v\
    \ }.map(&:first)\nend", "  nums.sort_by.with_index do |num, i|\n    [num.digits.sum,\
    \ i]\n  end\nend", "  nums.sort_by { |n| [n.abs.digits.sum, nums.index(n)] }\n\
    end", "  sums = {}\n  nums.each_with_index do |n, i|\n    sums[n] = n.abs.to_s.chars.map(&:to_i).inject(:+)\n\
    \  end\n  nums.sort do |a, b|\n    s_a = sums[a]\n    s_b = sums[b]\n    if s_a\
    \ == s_b\n      nums.index(a) <=> nums.index(b)\n    else\n      s_a <=> s_b\n\
    \    end\n  end\nend", "  nums.each_with_index.to_a.sort_by { |num, index| [num.digits.sum,\
    \ index] }.map { |el| el[0] }\nend", "  # nums.sort { |a, b| a.digits.sum == b.digits.sum\
    \ ? a <=> b : a.digits.sum <=> b.digits.sum }\n  nums.sort_by { |x| [x.digits.sum,\
    \ nums.index(x)] }\nend", "\tnums.sort_by.with_index { |x, i| [x.to_s.split('').map(&:to_i).sum,\
    \ i] }\nend", "  nums.sort_by.with_index do |num, index|\n    # 1.4 use Enumerable#sum\
    \ to calculate the sum of the digits of an integer\n    sum = num.to_s.chars.map(&:to_i).sum\n\
    \    [sum, index]\n  end\nend", "  nums.sort_by.with_index do |n, i|\n    [sum_of_digits(n),\
    \ i]\n  end\nend", "  nums.sort_by.with_index do |v, i|\n    v.digits.sum * 10\
    \ + i\n  end\nend", "  if nums.empty?\n    []\n  else\n    nums.sort_by.with_index\
    \ do |num, i|\n      [sum_digits(num), i]\n    end\n  end\nend", "  nums.sort_by.with_index\
    \ { |v, i| [v.to_s.chars.map(&:to_i).reduce(:+), i] }\nend", "  nums.sort_by.with_index\
    \ { |num, i| [sum_of_digits(num), i] }\nend", "  return [] if nums.empty?\n  sums\
    \ = Hash.new(0)\n  nums.each_with_index do |num, idx|\n    sums[idx] = num.abs.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  end\n  sorted_sums = sums.sort_by { |_, sum| sum }\n  result = []\n  sorted_sums.each\
    \ do |idx, _|\n    result << nums[idx]\n  end\n  result\nend", "  nums.sort_by\
    \ { |num| [num.abs.digits.sum, nums.index(num)] }\nend", "  # your code here\n\
    end", "  nums.sort_by.with_index { |n,i| [n.digits.sum, i] }\nend", "  nums.sort_by.with_index\
    \ { |n, i| [sum_of_digits(n), i] }\nend", "  nums.sort_by.with_index { |n, i|\
    \ [sum_of_digits(n), i] }\nend", "  nums.sort { |a, b| [digits_sum(a), a] <=>\
    \ [digits_sum(b), b] }\nend", "  nums.sort_by.with_index do |num, index|\n   \
    \ [num.digits.sum, index]\n  end\nend", "  nums.sort_by.with_index { |num, i|\
    \ [sum_of_digits(num), i] }\nend", "  arr = []\n  nums.each_with_index { |x, i|\
    \ arr.push([x, sum_digits(x), i]) }\n  arr.sort_by { |x| [x[1], x[2]] }.map {\
    \ |x| x[0] }\nend", "  sum = []\n  nums.each_with_index do |n, i|\n    sum <<\
    \ [n, (n.abs / 10) + (n.abs % 10)]\n  end\n  sum.sort_by! { |n| n[1] }\n  sum.map\
    \ { |n| n[0] }\nend", "  sum = nums.map { |num| num.abs.to_s.split('').map(&:to_i).sum\
    \ }\n  nums.zip(sum).sort_by { |num, s| [s, nums.index(num)] }.map(&:first)\n\
    end", "  nums.sort_by { |num| [num.abs.digits.sum, nums.index(num)] }\nend", " \
    \ sum_of_digits = {}\n  sum_of_index = {}\n  nums.each_with_index do |num, index|\n\
    \    sum_of_digits[num] = num.to_s.chars.map(&:to_i).sum\n    sum_of_index[index]\
    \ = index\n  end\n  sum_of_digits = sum_of_digits.sort_by { |a,b| b }\n  sum_of_index\
    \ = sum_of_index.sort_by { |a,b| a }\n  sum_of_digits.collect { |elem| elem[0]\
    \ }\nend", "  nums.sort_by { |number| [number.digits.sum, nums.index(number)]\
    \ }\nend", "  nums.sort_by.with_index { |num, i| [num.digits.sum, i] }\nend",
  "  nums.sort_by { |x| [x.abs.digits.sum, nums.index(x)] }\nend", "  nums.sort_by.with_index\
    \ { |n, i| [-sum_of_digits(n), i] }\nend", "  # TODO: implement this function!\n\
    \  if nums.empty?\n    []\n  else\n    nums.sort_by { |element| [element.to_s.split('').map(&:to_i).inject(:+),\
    \ nums.index(element)] }\n  end\nend", "  nums.sort_by.with_index { |num, index|\
    \ [num.digits.sum, index] }\nend", "  # Fill in the missing code\nend", "  # your\
    \ code goes here\nend", "  # code here\nend", "  hash = {}\n  nums.each_with_index\
    \ do |x, index|\n    hash[index] = sum_of_digits(x)\n  end\n  sorted_by_points\
    \ = hash.sort_by { |index, points| [points, index] }\n  sorted_by_points.map {\
    \ |index, points| nums[index] }\nend", "  hash = {}\n  nums.each_with_index do\
    \ |item, index|\n    # sum = item.to_s.split('').map(&:to_i).reduce(:+)\n    sum\
    \ = 0\n    item.to_s.split('').each { |s| sum += s.to_i }\n    hash[item] = sum\n\
    \  end\n  # hash.sort { |a, b| a[1] <=> b[1] }.to_h.keys\n  # hash.sort { |a,\
    \ b| a[1] <=> b[1] }.to_h.keys\n  nums.sort_by { |item| hash[item] }\nend", " \
    \ nums.sort_by { |num| [num.digits.reduce(:+), nums.index(num)] }\nend", "  sum\
    \ = []\n  result = []\n  nums.each_with_index do |num, i|\n    sum[i] = num.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  end\n  i = 0\n  while i < nums.length\n    j = 0\n    while j < nums.length\n\
    \      if sum[i] <= sum[j]\n        sum[i], sum[j] = sum[j], sum[i]\n        nums[i],\
    \ nums[j] = nums[j], nums[i]\n      end\n      j += 1\n    end\n    i += 1\n \
    \ end\n  nums\nend", "  nums.sort_by.with_index { |num, idx| [sum_of_digits(num),\
    \ idx] }\nend", "  points = nums.map { |n| [n, n.to_s.chars.map(&:to_i).sum] }\n\
    \  points.sort_by { |a| [a[1], a[0]] }.map { |a| a[0] }\nend", "  nums.sort_by.with_index\
    \ { |num, i| [num.digits.sum, i] }\nend", "  return [] if nums.empty?\n  sorted_nums\
    \ = nums.sort_by { |num| [num.digits.sum, nums.index(num)] }\n  sorted_nums\n\
    end", "  # replace this for solution\n  nums.sort_by.with_index { |n, i| [n.digits.sum,\
    \ i] }\nend", "  nums.sort_by.with_index { |_, idx| [nums.map(&:to_s).map { |num|\
    \ num.split('').map(&:to_i).sum }, idx] }\nend", "\thash_nums = {}\n\tresult =\
    \ []\n\tnums.each do |num|\n\t\thash_nums[num] = num.to_s.split('').map{|c| c.to_i}.reduce(:+)\n\
    \tend\n\thash_nums.sort_by{|key, value| value}.each do |k, v|\n\t\tresult << k\n\
    \tend\n\treturn result\nend", "  return [] if nums.empty?\n  nums.sort_by.with_index\
    \ { |num, i| [num.digits.sum, i] }\nend", "  # your code here\nend", "    return\
    \ nums.sort_by.with_index { |num, i| [sum_of_digits(num), i] }\nend", "  sum_list\
    \ = []\n  nums.each_with_index do |n, i|\n    sum_list.push(i)\n    sum_list.push(n.abs.to_s.chars.map(&:to_i).reduce(:+))\n\
    \  end\n  sum_list.sort_by!(&:last)\n  sum_list.each_slice(2).map(&:first)\nend",
  "  if nums.length == 0\n    []\n  else\n    # make a hash where key is the sum of\
    \ the digits\n    # and value is the number itself\n    sums = {}\n    nums.each\
    \ do |num|\n      sum = 0\n      # convert number to array of digits\n      num.to_s.split('').each\
    \ do |x|\n        sum += x.to_i\n      end\n      # add to hash\n      sums[sum]\
    \ = num\n    end\n    # sort the keys and return a new array that is sorted\n\
    \    sums.keys.sort.map { |num| sums[num] }\n  end\nend", "  if nums.empty?\n\
    \    return []\n  end\n  nums.sort_by { |num|\n    num.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  }\nend", "    indices = (0...nums.length).to_a\n    sums = indices.map { |i|\
    \ nums[i].abs.digits.sum }\n    nums.sort_by.with_index { |_, i| [sums[i], i]\
    \ }\nend", "  return [] if nums.length == 0\n  sums = []\n  nums.each do |num|\n\
    \    sum = num.abs.to_s.split('').map(&:to_i).inject(:+)\n    sums << sum\n  end\n\
    \  new_arr = sums.zip(nums).sort.map(&:last)\nend", "  nums.sort_by.with_index\
    \ { |x, i| [sum_of_digits(x), i] }\nend", "  nums.sort { |a, b| a.to_s.split('').map(&:to_i).sum\
    \ <=> b.to_s.split('').map(&:to_i).sum }\nend", "    nums.sort_by.with_index{|num,\
    \ i| [num.digits.sum, i]}\nend", "  nums.sort_by { |x| [x.digits.sum, nums.index(x)]\
    \ }\nend", "  sums = []\n  nums.each do |num|\n    sum = 0\n    num.to_s.split('').each\
    \ do |d|\n      sum += d.to_i\n    end\n    sums << sum\n  end\n  hash = {}\n\
    \  nums.each_with_index do |num, idx|\n    hash[num] = sums[idx]\n  end\n  nums.sort_by\
    \ do |num|\n    [hash[num], nums.index(num)]\n  end\nend", "  sums = nums.each_with_index.map\
    \ do |num, index|\n    [num, index, num.to_s.split('').map(&:to_i).sum]\n  end\n\
    \  sums.sort_by { |num, index, sum| [sum, index] }.map { |num, index, sum| num\
    \ }\nend", "  nums.sort_by { |e| [e.digits.sum, nums.index(e)] }\nend", "  nums.sort_by\
    \ { |num| [num.abs.digits.sum, nums.index(num)] }\nend", "  if nums.empty?\n \
    \   return []\n  end\n  points = []\n  nums.each_with_index do |num, index|\n\
    \    points << [num, index]\n  end\n  points.sort_by { |point| [point[0].to_s.chars.map(&:to_i).reduce(:+),\
    \ point[1]] }.map { |point| point[0] }\nend", "  nums.sort_by { |num| [num.abs.digits.sum,\
    \ nums.index(num)] }\nend", "  return [] if nums.empty?\n  nums.sort_by { |num|\
    \ [num.abs.digits.sum, nums.index(num)] }\nend", "\tnums.sort_by.with_index {\
    \ |n, i| [n.digits.sum, i] }\nend", "    nums.sort_by.with_index { |num, i| [num.to_s.split('').map(&:to_i).reduce(:+),\
    \ i] }\nend", "  # TODO: implement this function\n  sum = nums.map do |i|\n  \
    \  i.to_s.split('').map { |e| e.to_i }.reduce(:+)\n  end\n  array = nums.map.with_index\
    \ { |e, i| e = [e, i] }\n  array.sort_by! { |e| [sum[e[1]], e[1]] }\n  array.map\
    \ { |e| e[0] }\nend", "  nums.sort_by.with_index { |num, index| [num.digits.sum,\
    \ index] }\nend", "  # your code here\nend", "  nums.sort_by.with_index { |n,\
    \ i| [-n.digits.sum, i] }\nend", "  return [] if nums.empty?\n  nums.sort_by{|n|\
    \ [n.digits.sum, nums.index(n)]}\nend", "  # your code here\nend", "  nums.sort_by\
    \ { |num| [sum_of_digits(num.abs), nums.index(num)] }\nend", "  nums.sort_by.with_index\
    \ { |n, i| [sum_of_digits(n), i] }\nend", "  nums.sort_by.with_index { |num, i|\
    \ [-num.digits.sum, i] }\nend", "  def sum_of_digits(num)\n    sum = 0\n    while\
    \ num > 0\n      sum += num % 10\n      num /= 10\n    end\n    sum\n  end", " \
    \ nums.sort_by.with_index { |num, i| [sum_digits(num), i] }\nend", "  nums.sort_by\
    \ { |n| [n.digits.sum, nums.index(n)] }\nend", "  nums.sort_by.with_index do |num,\
    \ index|\n    sum = 0\n    until num == 0\n      num, r = num.divmod(10)\n   \
    \   sum += r\n    end\n    [sum, index]\n  end\nend", "  nums.sort_by.with_index\
    \ { |num, index| [num.digits.sum, index] }\nend", "  nums.sort_by.with_index {\
    \ |number, index| [number.digits.sum, index] }\nend", "\treturn [] if nums.empty?\n\
    \tnums.sort_by{|x| [x.to_s.chars.map(&:to_i).inject(:+), nums.index(x)]}\nend",
  "  return [] if nums.empty?\n  nums.sort_by { |num| [num.abs.digits.sum, nums.index(num)]\
    \ }\nend", "  sums = []\n  nums.each_with_index do |n, i|\n    sums << [n, i,\
    \ n.to_s.chars.inject(0) { |sum, c| sum + c.to_i }]\n  end\n  sums.sort_by { |s|\
    \ [s[2], s[1]] }.map { |s| s[0] }\nend", "  nums.sort_by.with_index { |x, _| x.abs.digits.sum\
    \ }\nend", "  nums.sort_by.with_index do |num, idx|\n    [num.digits.reduce(:+),\
    \ idx]\n  end\nend", "  raise NotImplementedError\nend", "  # your code here\n\
    end", "  return [] if nums.empty?\n  a = nums.map.with_index { |num, i| [num,\
    \ num.abs.digits.sum, i] }\n  a.sort_by! { |arr| [arr[1], arr[2]] }\n  a.map {\
    \ |arr| arr[0] }\nend", "  # write your code here\nend", "  nums.sort_by{|num|\
    \ [num.abs.digits.sum, nums.index(num)]}\nend", "  nums.sort_by { |x| x.abs.digits.sum\
    \ }\nend", "  return [] if nums.empty?\n  sum_nums = Hash.new\n  sum_value = Array.new\n\
    \  nums.each_with_index do |num, index|\n    sum_value << num.abs.to_s.chars.map(&:to_i).sum\n\
    \    sum_nums[sum_value[index]] = num\n  end\n  sum_value.sort!.map { |num| sum_nums[num]\
    \ }\nend", "  sorted_nums = nums.sort_by.with_index { |num, idx| [(num.to_s.chars.map(&:to_i).sum),\
    \ idx] }\nend", "  return [] if nums.empty?\n  nums.sort_by { |num| [sum_of_digits(num),\
    \ nums.index(num)] }\nend", "  nums.sort_by.with_index do |num, index|\n    [(num.abs.to_s.chars.map(&:to_i).reduce(:+)).to_s.to_i,\
    \ index]\n  end\nend", "  return [] if nums.empty?\n  nums.sort_by.with_index\
    \ { |num, index| [sum_of_digits(num), index] }\nend", "  nums.sort_by.with_index\
    \ do |num, idx|\n    [sum_digits(num), idx]\n  end\nend", "  nums.sort_by.with_index\
    \ { |num, idx| [num.digits.sum, idx] }\nend", "  nums.sort_by { |num| [num.digits.sum,\
    \ nums.index(num)] }\nend", "  nums.each_with_index.sort { |a, b| a[0].digits.sum\
    \ <=> b[0].digits.sum }.map(&:first)\nend", "  nums.sort_by { |n| [n.abs.digits.sum,\
    \ nums.index(n)] }\nend", "  nums.sort_by.with_index do |num, index|\n    sum\
    \ = num.to_s.split('').map(&:to_i).reduce(:+)\n    [sum, index]\n  end\nend",
  "  nums.sort_by.with_index { |_, i| [sum_of_digits(nums[i]), i] }\nend", "  # your\
    \ code here\nend", "  sum_of_digits = []\n  nums.each do |x|\n    sum_of_digits\
    \ << [x, x.abs.to_s.chars.map(&:to_i).reduce(:+)]\n  end\n  sorted_array = sum_of_digits.sort_by\
    \ { |arr| arr[1] }\n  sorted_array.map { |arr| arr[0] }\nend", "\tnums.sort_by{|x|\
    \ [x.abs.to_s.chars.map(&:to_i).reduce(:+), nums.index(x)]}\nend", "  # converts\
    \ nums to array of arrays\n  # each array has a sum of digits at index 0 and the\
    \ number at index 1\n  # sorts by the first index of each array\n  nums.map {\
    \ |num| [num.digits.sum, num] }.sort_by { |arr| arr[0] }.map { |arr| arr[1] }\n\
    end", "  nums.sort_by.with_index { |num, i| [num.digits.sum, i] }\nend", "  nums.each_with_index.sort_by\
    \ { |num, idx| sum_of_digits(num) + idx }.map(&:first)\nend", end, "  return []\
    \ if nums.empty?\n  nums.sort_by { |num| [num.digits.sum, nums.index(num)] }\n\
    end", "  return [] if nums.empty?\n  nums.sort_by { |num| [num.abs.digits.sum,\
    \ nums.index(num)] }\nend", "  return [] if nums.empty?\n  nums.sort_by { |num|\
    \ [num.abs.digits.sum, nums.index(num)] }\nend", "  nums.sort_by.with_index do\
    \ |x, i|\n    [x.to_s.chars.map(&:to_i).sum, i]\n  end\nend", "  nums.sort_by.with_index\
    \ do |x, index|\n    [x.digits.sum, index]\n  end\nend", "  nums.sort_by.with_index\
    \ { |num, idx| [sum_of_digits(num), idx] }\nend", "  nums.sort_by.with_index {\
    \ |n, i| [sum_of_digits(n), i] }\nend", "  sum_arr = []\n  nums.each_with_index\
    \ do |num, index|\n    sum_arr << [num, num.to_s.chars.map { |char| char.to_i\
    \ }.reduce(:+), index]\n  end\n  sorted_arr = sum_arr.sort { |a, b| (a[1] <=>\
    \ b[1]).nonzero? || (a[2] <=> b[2]) }\n  sorted_arr.map { |arr| arr[0] }\nend",
  "  nums.sort_by.with_index { |n, _| n.digits.sum }\nend", "  # your code here\n\
    end", "  nums.sort_by.with_index do |num, index|\n    [num.digits.sum, index]\n\
    \  end\nend", "  nums.sort_by { |num| [num.digits.sum, nums.index(num)] }\nend",
  "  raise ArgumentError, 'nums should be an array of integers' if nums.any? { |num|\
    \ !num.is_a?(Integer) }\n  return nums if nums.empty?", "  nums.sort_by.with_index\
    \ { |num, index| [num.digits.sum, index] }\nend", "  nums.sort_by.with_index {\
    \ |num, index| [sum_digits(num), index] }\nend", "  if nums.empty?\n    return\
    \ []\n  else\n    nums.sort_by { |x| [x.abs.digits.sum, nums.index(x)] }\n  end\n\
    end", "  nums.sort_by { |num| [num.digits.sum, nums.index(num)] }\nend", "  nums.sort_by.with_index\
    \ { |num, idx| [sum_of_digits(num), idx] }\nend", "    sums = {}\n    nums.each_with_index\
    \ do |el, ind|\n        sums[el] = el.abs.to_s.split('').map(&:to_i).reduce(:+)\n\
    \    end\n    nums.sort_by { |el| [sums[el], ind] }\nend", "  nums.sort_by.with_index\
    \ do |_, index|\n    [nums.map { |num| num.digits.sum }, index]\n  end\nend",
  "  sums = nums.sort_by { |n| n.to_s.chars.map(&:to_i).sum }\n  sums.select { |n|\
    \ nums.index(n) == sums.index(n) } + sums.select { |n| nums.index(n) != sums.index(n)\
    \ }\nend", "  nums.sort_by { |num| [num.abs.digits.sum, nums.index(num)] }\nend",
  "  d_nums = {}\n  nums.each do |num|\n    d_nums[num] = num.to_s.split('').map(&:to_i).reduce(:+)\n\
    \  end\n  d_nums.sort_by { |k, v| [v, nums.index(k)] }.to_h.keys\nend", "  nums.sort_by.with_index\
    \ { |num, i| [num.digits.sum, i] }\nend", "  return [] if nums.empty?\n  nums.sort_by\
    \ do |num|\n    [num.digits.reduce(:+), nums.index(num)]\n  end\nend", "  sort_nums\
    \ = nums.sort_by.with_index do |num, index|\n    [num.digits.reduce(:+), index]\n\
    \  end\n  p sort_nums\nend", "  points = nums.map { |num| [num, num.abs.to_s.chars.map(&:to_i).reduce(:+)]\
    \ }\n  points.sort_by { |pair| [pair[1], pair[0]] }.map { |pair| pair[0] }\nend",
  "  # TODO\nend", "  nums.sort_by.with_index do |num, index|\n    [num.digits.sum,\
    \ index]\n  end\nend", "\tnums.sort_by { |i| [i.abs.digits.sum, nums.index(i)]\
    \ }\nend", "\tnums.sort_by{|num| num.to_s.chars.map(&:to_i).inject(:+)}\nend",
  "  sum_of_digits = nums.map{|num| num.to_s.chars.map(&:to_i).sum }\n  nums.zip(sum_of_digits).sort_by{|x|\
    \ x[1]}.map{|x| x[0]}\nend", "  nums.sort_by.with_index { |num, index| [sum_of_digits(num),\
    \ index] }\nend", "  nums.sort_by.with_index { |num, i| [num.digits.sum, i] }\n\
    end", "  nums.sort_by.with_index { |num, idx| [num.digits.sum, idx] }\nend", " \
    \ # TODO: Write this function\n  nums.sort_by{|n| n.to_s.chars.map(&:to_i).inject(:+)}\n\
    end", "  # your code here\nend", "  nums.sort_by { |x| [x.abs.digits.sum, nums.index(x)]\
    \ }\nend", "  nums.sort_by.with_index { |num, i| [sum_of_digits(num), i] }\nend",
  "  nums.sort_by.with_index { |n, i| [sum_of_digits(n), i] }\nend", "  nums.sort_by.with_index\
    \ { |num, idx| [num.digits.sum, idx] }\nend", "  sum_of_digits = nums.map do |n|\n\
    \    sum = 0\n    n.to_s.each_char { |i| sum += i.to_i }\n    sum\n  end\n  sorted_indexes\
    \ = sum_of_digits.each_with_index.sort.map { |i| i[1] }\n  result = []\n  sorted_indexes.each\
    \ { |i| result << nums[i] }\n  result\nend", "  return [] if nums.empty?\n  sorted\
    \ = nums.sort_by { |n| [n.digits.sum, nums.index(n)] }\n  sorted\nend", "  nums.sort_by{|x|\
    \ [x.abs.digits.sum, nums.index(x)]}\nend", "  # Write your code here\nend", "\t\
    nums.sort_by{|i| [i.to_s.split('').inject(0){|acc, i| acc + i.to_i}, nums.index(i)]}\n\
    end", "  nums.sort_by.with_index { |num, idx| [num.digits.sum, idx] }\nend", " \
    \ values = nums.map do |num|\n    arr = num.to_s.split('')\n    sum = 0\n    arr.each\
    \ do |str|\n      sum += str.to_i\n    end\n    sum\n  end\n  nums.sort_by.with_index\
    \ do |num, index|\n    [values[index], index]\n  end\nend", "  counter = 0\n \
    \ result = []\n  ordered_arr = []\n  nums.each do |n|\n    if n < 0\n      result\
    \ << n.abs.to_s.split('').map(&:to_i).inject(:+)\n    else\n      result << n.to_s.split('').map(&:to_i).inject(:+)\n\
    \    end\n  end\n  ordered_arr = result.sort\n  ordered_arr.map do |n|\n    if\
    \ nums[counter] < 0\n      n - nums[counter].abs\n    else\n      n - nums[counter]\n\
    \    end\n    counter += 1\n  end\nend", "  nums.sort_by.with_index do |n, i|\n\
    \    [n.digits.sum, i]\n  end\nend", "  nums.sort_by.with_index { |num, i| [num.digits.sum,\
    \ i] }\nend", "  nums.sort_by { |num| [num.abs.digits.sum, nums.index(num)] }\n\
    end", "  return [] if nums.empty?\n  sorted = nums.sort_by { |num| [num.digits.sum,\
    \ nums.index(num)] }\n  p sorted\nend", "  nums.sort_by.with_index { |num, i|\
    \ [num.digits.sum, i] }\nend", "  sum_of_digits = nums.map { |num| num.abs.to_s.split('').map(&:to_i).sum\
    \ }\n  nums.zip(sum_of_digits).sort_by { |num, sum| [sum, nums.index(num)] }.map(&:first)\n\
    end", "  # write your code here\nend", "  nums.sort_by{|num| num.abs.digits.sum\
    \ }\nend", "  if nums.empty?\n    nums\n  else\n    nums.sort_by do |num|\n  \
    \    digits = num.abs.to_s.split('').map(&:to_i)\n      sum = digits.inject(:+)\n\
    \      [sum, nums.index(num)]\n    end\n  end\nend", "  return [] if nums.empty?\n\
    \  nums.sort_by{|num| [sum_digits(num), nums.index(num)]}\nend", "  # Your code\
    \ here\nend", "  # your code here\nend", "  nums.sort_by.with_index { |n, i| [sum_of_digits(n),\
    \ i] }\nend", "  nums.sort_by.with_index { |num, index| [sum_digits(num), index]\
    \ }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
