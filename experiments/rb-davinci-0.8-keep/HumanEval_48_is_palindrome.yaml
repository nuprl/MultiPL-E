name: HumanEval_48_is_palindrome
language: rb
prompt: "# Checks if given string is a palindrome\n# >>> is_palindrome('')\n# True\n\
  # >>> is_palindrome('aba')\n# True\n# >>> is_palindrome('aaaaa')\n# True\n# >>>\
  \ is_palindrome('zbcd')\n# False\ndef is_palindrome(text)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_palindrome\n\
  \    candidate = method(:is_palindrome)\n    assert_equal(true, candidate.call(\"\
  \"))\n    assert_equal(true, candidate.call(\"aba\"))\n    assert_equal(true, candidate.call(\"\
  aaaaa\"))\n    assert_equal(false, candidate.call(\"zbcd\"))\n    assert_equal(true,\
  \ candidate.call(\"xywyx\"))\n    assert_equal(false, candidate.call(\"xywyz\"))\n\
  \    assert_equal(false, candidate.call(\"xywzx\"))\n  end\nend\n"
completions: ["  return true if text.empty?\n  return false if text[0] != text[-1]\n\
    \  is_palindrome(text[1..-2])\nend", "  i = 0\n  while i < text.length\n    if\
    \ text[i] != text[-(i + 1)]\n      return false\n    end", "  if text == ''\n\
    \    true\n  elsif text.length == 1\n    true\n  elsif text[0] == text[-1]\n \
    \   is_palindrome(text[1..-2])\n  else\n    false\n  end\nend", "  text == text.reverse\n\
    end", "  p text.chars.reverse == text.chars\nend", "  text == text.reverse\nend",
  "    text.length.times do |n|\n        return false if text[n] != text[-n-1]\n \
    \   end\n    true\nend", "  return true if text.length <= 1\n  if text[0] == text[-1]\n\
    \    is_palindrome(text[1..-2])\n  else\n    false\n  end\nend", '  return true
    if text.empty?', "  return true if text.length <= 1\n  return false if text[0]\
    \ != text[-1]\n  is_palindrome(text[1..-2])\nend", '  text.downcase!', "  text.downcase!\n\
    \  i = 0\n  j = text.length - 1\n  while i < j\n    if text[i] != text[j]\n  \
    \    return false\n    end\n    i += 1\n    j -= 1\n  end\n  return true\nend",
  "  text == text.reverse\nend", "  text == text.reverse\nend", "  # Your code here\n\
    end", "  # Write your code here\nend", "  len = text.length\n  half_len = len\
    \ / 2\n  len.odd? ? text[0..half_len-1] == text[half_len+1..-1].reverse : text[0..half_len-1]\
    \ == text[half_len..-1].reverse\nend", "  return true if text.length <= 1\n  return\
    \ false if text[0] != text[-1]\n  is_palindrome(text[1..-2])\nend", "  return\
    \ true if text.empty?\n  return text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  return false if text.nil?\n  return true if text.length == 0\n  last_index\
    \ = text.length - 1\n  (0..(text.length / 2)).each do |index|\n    return false\
    \ if text[index] != text[last_index - index]\n  end\n  true\nend", "  text.downcase!\n\
    \  text.gsub!(/[^a-z]/, '')\n  letters = text.split('')\n  rev = []\n  while letters.length\
    \ > 0\n    rev.push(letters.pop)\n  end\n  text == rev.join('')\nend", "    #\
    \ If string is empty or only has one letter, it is a palindrome\n    if text.length\
    \ <= 1\n        return true\n    end\n    # If the first and last letter are the\
    \ same, check the substring in between\n    if text[0] == text[-1]\n        return\
    \ is_palindrome(text[1..-2])\n    else\n        return false\n    end\nend", " \
    \ text == text.reverse\nend", "  text.size <= 1 || text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  return text == text.reverse\nend", "    if text.length <= 1 \n      \
    \  return true\n    end\n    if text[0] == text[-1]\n        return is_palindrome(text[1...-1])\n\
    \    else\n        return false\n    end\nend", "  return false if text.nil?\n\
    \  text.squeeze == text.squeeze.reverse\nend", "\treturn true if text.length ==\
    \ 0\n\treturn text[0] == text[-1] && is_palindrome(text[1..-2])\nend", "  text\
    \ == text.reverse\nend", "  if text.length > 1\n    text.downcase == text.downcase.reverse\n\
    \  else\n    true\n  end\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  return text == text.reverse\nend", "  palindrome = \"\"\n  i = 0\n  while\
    \ i < text.length\n    palindrome = text[i] + palindrome\n    i += 1\n  end\n\
    \  palindrome == text\nend", "  text == text.reverse\nend", "  #palindrome function\n\
    \  text = text.downcase\n  text = text.gsub(/\\W/, '')", "  return text == text.reverse\n\
    end", "\t#TODO: return true/false depending on if text is a palindrome\n\tnew_array\
    \ = text.downcase.split('')", "    word = text.downcase\n    word == word.reverse\n\
    end", "  text.reverse == text\nend", "  text.downcase!\n  text.gsub!(/[^a-z]/,\
    \ '')\n  text == text.reverse\nend", "  last_index = text.length - 1\n  middle_index\
    \ = last_index / 2\n  last_index.downto(middle_index).each do |index|\n    return\
    \ false if text[index] != text[last_index - index]\n  end\n  true\nend", "  len\
    \ = text.length\n  mid = len/2\n  i = 0\n  while i < mid\n    if text[i] != text[len-i-1]\n\
    \      return false\n    end\n    i += 1\n  end\n  return true\nend", "  text\
    \ == text.reverse\nend", "  text == text.reverse\nend", "\tif text == text.reverse\n\
    \t\ttrue\n\telse\n\t\tfalse\n\tend\nend", "  text == text.reverse\nend", "  palindrome\
    \ = text.reverse\n  if text == palindrome\n    return true\n  else\n    return\
    \ false\n  end\nend", "  # just like is_palindrome_n, but now with a loop\n  len\
    \ = text.length\n  if len == 0\n    return true\n  end\n  left = 0\n  right =\
    \ len - 1\n  while left < right\n    if text[left] != text[right]\n      return\
    \ false\n    end\n    left += 1\n    right -= 1\n  end\n  return true\nend", "\t\
    if text == text.reverse\n\t\ttrue\n\telse\n\t\tfalse\n\tend\nend", "  text.length\
    \ == 0 || text.length == 1 || (text[0] == text[-1] && is_palindrome(text[1..-2]))\n\
    end", "  text.size <= 1 ||\n    text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  text ==\
    \ text.reverse\nend", "    if text.length == 0 || text.length == 1\n        return\
    \ true\n    end\n    if text[0] == text[-1]\n        return is_palindrome(text[1..-2])\n\
    \    else\n        return false\n    end\nend", "  # YOUR CODE HERE\nend", '  raise
    ArgumentError.new("Invalid text") if text.nil? || text.empty?', "  text == text.reverse\n\
    end", "  text.reverse == text\nend", "  string_len = text.length\n  return true\
    \ if string_len <= 1\n  mid = string_len / 2\n  (0...mid).each do |i|\n    return\
    \ false if text[i] != text[string_len - i - 1]\n  end\n  true\nend", "  text ==\
    \ text.reverse\nend", "  text.downcase == text.downcase.reverse\nend", "\treturn\
    \ true if text.empty?", "  new_text = text.downcase.delete('^a-z')\n  return new_text\
    \ == new_text.reverse\nend", "  if text == nil || text.empty?\n    return false\n\
    \  end\n  text = text.downcase\n  text = text.gsub(/[^a-z0-9]/, '')\n  return\
    \ text == text.reverse\nend", "\t# Do something\nend", "  text.reverse == text\n\
    end", "  if text == nil\n    return true\n  end\n  # Remove all non-word characters\
    \ (everything except numbers and letters)\n  text = text.gsub(/\\W/,\"\")\n  #\
    \ Check if string is a palindrome\n  if text.reverse == text\n    return true\n\
    \  else\n    return false\n  end\nend", "  # your code goes here\nend", "  return\
    \ text == text.reverse\nend", "  if text.empty?\n    return true\n  end\n  # Ignore\
    \ case and punctuation\n  clean_text = text.downcase.gsub(/[^a-z]/, '')\n  # Reverse\
    \ text and check if still the same\n  clean_text == clean_text.reverse\nend",
  "  return text.nil? || text.length <= 1 || text.downcase.chars.join == text.downcase.chars.reverse.join\n\
    end", "  text == text.reverse\nend", "\treturn text.reverse == text\nend", "\t\
    text = text.downcase\n\tleft = 0\n\tright = text.length - 1\n\twhile left < right\n\
    \t\tif text[left] != text[right]\n\t\t\treturn false\n\t\tend\n\t\tleft += 1\n\
    \t\tright -= 1\n\tend\n\treturn true\nend", "  return true if text.empty?\n  is_palindrome(text[1..-2])\
    \ && text[0] == text[-1]\nend", "  if text.size <= 1\n    return true\n  elsif\
    \ text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n  else\n    return\
    \ false\n  end\nend", end, "  # your implementation here\n  text.size == 0 ||\
    \ text.size == 1 || (text[0] == text[-1] && is_palindrome(text[1..-2]))\nend",
  "  text == text.reverse\nend", "  # TODO: implement this!\n  reverse = text.reverse\n\
    \  reverse == text\nend", "  # FILL IN YOUR CODE HERE\nend", "  return false if\
    \ text.nil? || text.length == 0\n  return true if text.length == 1\n  return text.reverse\
    \ == text\nend", "  return false if text.length == 0\n  return text.length ==\
    \ 1 || text.length == 2 && text[0] == text[1] if text.length <= 2\n  text[0] ==\
    \ text[-1] && is_palindrome(text[1..-2])\nend", "  return text.reverse == text\n\
    end", "  # If the string is a single character then it is a palindrome\n  if text.length\
    \ == 1\n    return true\n  end", "  return true if text.length == 0\n  return\
    \ text[0] == text[-1] ? is_palindrome(text[1..-2]) : false\nend", "  if text.length\
    \ == 0\n    return true\n  end\n  if text[0] == text[-1]\n    is_palindrome(text[1..-2])\n\
    \  else\n    return false\n  end\nend", "  if (text.length == 0) || (text.length\
    \ == 1)\n    return true\n  end\n  if text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n\
    \  else\n    return false\n  end\nend", "  text.downcase == text.downcase.reverse\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  (text.length\
    \ == 0) or (text.length == 1) or (text[0] == text[-1] and is_palindrome(text[1..-2]))\n\
    end", "  text == text.reverse\nend", "  # DONE: implement the algorithm here\n\
    \  # return True if text is a palindrome\n  # else return False\n  if text.empty?\n\
    \    return true\n  elsif text.length == 1\n    return true\n  elsif text[0] ==\
    \ text[-1]\n    text.slice!(0)\n    text.slice!(-1)\n    is_palindrome(text)\n\
    \  else\n    return false\n  end\nend", "  return false if text.nil? || text.empty?\n\
    \  return true if text.length == 1\n  is_palindrome(text[1..-2]) && text[0] ==\
    \ text[-1]\nend", "  # text = text.delete(' ')\n  text = text.delete(' ').downcase\n\
    \  reversed_text = text.reverse\n  return text == reversed_text\nend", "  if (text\
    \ == text.reverse)\n    return true\n  else\n    return false\n  end\nend", " \
    \ length = text.length\n  text[0, length / 2] == text[-length / 2, length / 2].reverse\n\
    end", "  reversed = \"\"\n  chars = text.chars\n  while chars.length > 0\n   \
    \ reversed += chars.pop\n  end\n  text == reversed\nend", "  if text == text.reverse\n\
    \    return true\n  else\n    return false\n  end\nend", "  text == text.reverse\n\
    end", "  if text.length == 0\n    return true\n  end\n  if text[0] == text[-1]\n\
    \    is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend", "  text.downcase!\n\
    \  text.delete!(' ')\n  text == text.reverse\nend", "  s = text.split('')\n  pal\
    \ = true\n  0.upto(s.length/2 - 1) do |i|\n    if s[i] != s[s.length - 1 - i]\n\
    \      pal = false\n      break\n    end\n  end\n  return pal\nend", "  text ==\
    \ text.reverse\nend", "\t# Initialize variables for left and right pointers\n\t\
    l = 0\n\tr = text.length - 1", "  return text == text.reverse\nend", "  text ==\
    \ text.reverse\nend", "  lower_case_text = text.downcase.gsub(/\\W/, '')\n  is_equal(lower_case_text)\n\
    end", "  i = 0\n  j = text.length - 1\n  while (i < j) do\n    return false if\
    \ text[i] != text[j]\n    i += 1\n    j -= 1\n  end\n  return true\nend", "\t\
    i = 0\n\tj = text.length - 1\n\t\n\t# Keep checking until i meets j\n\twhile i\
    \ < j\n\t\tif text[i] != text[j]\n\t\t\treturn false\n\t\tend\n\t\ti += 1\n\t\t\
    j -= 1\n\tend\n\t\n\treturn true\nend", "  text.gsub!(/\\W/,\"\")\n  (0..(text.length/2-1)).each\
    \ do |i|\n    if text[i] != text[-(i+1)]\n      return false\n    end\n  end\n\
    \  return true\nend", "    return text.reverse == text\nend", "\tarr = text.split('')\n\
    \tarr.reverse == arr\nend", "  text == text.reverse\nend", "  palindrome = true\n\
    \  text.downcase!\n  (0..text.length / 2).each do |i|\n    if text[i] != text[text.length\
    \ - i - 1]\n      palindrome = false\n      break\n    end\n  end\n  palindrome\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  text ==\
    \ text.reverse\nend", "  # TODO: return True if text is a palindrome, False otherwise.\n\
    \  # To solve this problem, you'll need to implement the function\n  # check_palindrome\
    \ which returns True if text is a palindrome and\n  # False otherwise\n  check_palindrome(text)\n\
    end", "  return true if text.length == 0\n  return text[0] == text[-1] && is_palindrome(text[1..-2])\n\
    end", "  text == text.reverse\nend", "  return text.eql?(text.reverse)\nend",
  "  #n is size of text\n  #smaller text for easier comparison\n  n = text.length\
    \ / 2\n  for i in 0..n\n    if text[i] != text[text.length - 1 - i]\n      return\
    \ false\n    end\n  end\n  return true\nend", "  if text.length == 0\n    return\
    \ true\n  end\n  if text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n\
    \  else\n    return false\n  end\nend", "  return true if text.length <= 1\n \
    \ return false if text[0] != text[-1]\n  is_palindrome(text[1..-2])\nend", " \
    \ if text.empty?\n    return true\n  end\n  i = 0\n  j = text.length - 1\n  while\
    \ i < j\n    if text[i] != text[j]\n      return false\n    end\n    i += 1\n\
    \    j -= 1\n  end\n  return true\nend", "  if text.empty?\n    return true\n\
    \  end\n  if text.length == 1\n    return true\n  end\n  if text[0] == text[-1]\n\
    \    text = text[1..-2]\n    return is_palindrome(text)\n  else\n    return false\n\
    \  end\nend", "  text.length <= 1 or (text[0] == text[-1] and is_palindrome(text[1..-2]))\n\
    end", "  text.reverse == text\nend", "  text.reverse == text\nend", "  text =\
    \ text.gsub(/\\W+/, '').downcase\n  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  str = text.chars.map(&:downcase)\n\
    \  str_reversed = str.reverse\n  arr = str.zip(str_reversed)\n  count = 0\n  while\
    \ count < str.length\n    if arr[count][0] == arr[count][1]\n      count += 1\n\
    \    else\n      return false\n    end\n  end\n  true\nend", "  s = 0\n  e = text.length\
    \ - 1\n  while s < e\n    if text[s] != text[e]\n      return false\n    end\n\
    \    s += 1\n    e -= 1\n  end\n  return true\nend", '  return false if text.length
    < 2', "\ti = 0\n\tj = text.length - 1\n\twhile i < j\n\t\tif text[i] != text[j]\n\
    \t\t\treturn false\n\t\tend\n\t\ti += 1\n\t\tj -= 1\n\tend\n\treturn true\nend",
  "    text.gsub(/\\W/,\"\").downcase == text.gsub(/\\W/,\"\").downcase.reverse\n\
    end", "  string = text.downcase\n  string == string.reverse\nend", "  text.downcase\
    \ == text.downcase.reverse\nend", "  text.eql?(text.reverse)\nend", "  arr = text.split('')\n\
    \  left_index = 0\n  right_index = arr.length - 1\n  while left_index < right_index\n\
    \    if arr[left_index] != arr[right_index]\n      return false\n    end\n   \
    \ left_index += 1\n    right_index -= 1\n  end\n  return true\nend", "    if text.empty?\n\
    \        return true\n    elsif text.length == 1\n        return true\n    elsif\
    \ text[0] == text[-1]\n        return is_palindrome(text[1..-2])\n    else\n \
    \       return false\n    end\nend", "  if text.length == 0\n    return true\n\
    \  elsif text.length == 1\n    return true\n  elsif text[0] == text[-1]\n    return\
    \ is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend", "  text =\
    \ text.downcase.gsub(/\\W/,'')\n  text == text.reverse\nend", "  text = text.downcase\n\
    \  return text == text.reverse\nend", "  return text == text.reverse\nend", " \
    \ text == text.reverse\nend", "  text.gsub!(/\\W/, '')\n  text.casecmp(text.reverse)\
    \ == 0\nend", "  #...\nend", "  palindrome = true\n  for i in 0..text.length/2\n\
    \    if text[i] != text[text.length-1-i]\n      palindrome = false\n    end\n\
    \  end\n  return palindrome\nend", "\t(text.length == 0) || (text.length == 1)\
    \ || ((text[0] == text[-1]) && is_palindrome(text[1..-2]))\nend", "  text == text.reverse\n\
    end", "  text == text.reverse\nend", '  return true if text.empty?', '    return
    false if text.length < 2', "  text == text.reverse\nend", "  text = text.downcase.scan(/\\\
    w/)\n  text == text.reverse\nend", "  text == text.reverse\nend", "  text.reverse\
    \ == text\nend", "  # TODO: return True or False if text is or isn't a palindrome\n\
    \  text == text.reverse\nend", "  length = text.length\n  mid = length / 2\n \
    \ (0...mid).each do |i|\n    return false if text[i] != text[length - i - 1]\n\
    \  end\n  true\nend", "  text.reverse == text\nend", "  text == text.reverse\n\
    end", "  l, r = 0, text.length - 1\n  while l < r\n    return false if text[l]\
    \ != text[r]\n    l += 1\n    r -= 1\n  end\n  true\nend", "  text.length > 1\
    \ && text == text.reverse\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  # TODO: Implement this method\n  text.downcase!\n  text.gsub!(/[^a-z]/,\
    \ '')\n  text == text.reverse\nend", "  text == text.reverse\nend", "  if text.length\
    \ < 2\n    return true\n  end\n  if text[0] == text[-1]\n    return is_palindrome(text[1..-2])\n\
    \  else\n    return false\n  end\nend", "  text.downcase == text.downcase.reverse\n\
    end", "  text == text.reverse\nend", "  text == text.reverse\nend", "  # Check\
    \ if input is empty string\n  if text.length() == 0\n    return true\n  end\n\
    \  # Get the length of the string\n  n = text.length()\n  # Check if first and\
    \ last characters are the same and\n  # if the inner substring is also a palindrome\n\
    \  return (text[0] == text[n-1]) && is_palindrome(text[1..n-2])\nend", "  # Implement\
    \ your solution here\nend", "    return true if text.length <= 1\n    return false\
    \ if text[0] != text[-1]\n    is_palindrome(text[1..-2])\nend", "  return true\
    \ if text.length <= 1\n  text[0] == text[-1] ? is_palindrome(text[1..-2]) : false\n\
    end", "\t# TODO: return True if text is a palindrome, False otherwise\n\tif text.empty?\n\
    \t\treturn true\n\telsif text.length == 1\n\t\treturn true\n\telse\n\t\tif text[0]\
    \ == text[-1]\n\t\t\treturn is_palindrome(text[1..-2])\n\t\telse\n\t\t\treturn\
    \ false\n\t\tend\n\tend\nend", "  text == text.reverse\nend", "  text == text.reverse\n\
    end", "  text = text.strip\n  text.downcase!\n  text.gsub!(/[^a-z]/, '')\n  text.reverse\
    \ == text\nend", "  return text == text.reverse\nend", "  return true if text.size\
    \ == 0\n  if text[0] == text[-1]\n    is_palindrome(text[1..-2])\n  else\n   \
    \ false\n  end\nend", "  lo = 0\n  hi = text.length - 1\n  while lo < hi\n   \
    \ if text[lo] != text[hi]\n      return false\n    end\n    lo += 1\n    hi -=\
    \ 1\n  end\n  return true\nend", "  text = text.downcase\n  size = text.length\
    \ - 1\n  half = size / 2\n  half.times do |i|\n    return false if text[i] !=\
    \ text[size - i]\n  end\n  true\nend", "  return true if text.empty?\n  text =\
    \ text.downcase\n  text = text.gsub(/[^0-9a-z]/i, '')\n  half = text.length /\
    \ 2\n  left = text[0..half - 1]\n  right = text[text.length - half..text.length]\n\
    \  return left == right.reverse\nend", "  return text == text.reverse\nend", " \
    \ string=text.downcase.gsub(/\\W/,'')\n  if string.length==0\n    return true\n\
    \  end\n  for i in 0..string.length/2\n    if string[i]!=string[string.length-1-i]\n\
    \      return false\n    end\n  end\n  return true\nend", "  text == text.reverse\n\
    end", "  if text == \"\"\n    return true\n  elsif text[0] == text[-1]\n    return\
    \ is_palindrome(text[1..-2])\n  else\n    return false\n  end\nend", "  return\
    \ true if text.length == 0\n  return false if text[0] != text[-1]\n  is_palindrome(text[1..-2])\n\
    end", "  text == text.reverse\nend", "  if text.length == 0\n    return true\n\
    \  elsif text.length == 1\n    return true\n  elsif text[0] == text[-1]\n    return\
    \ is_palindrome(text[1...-1])\n  else\n    return false\n  end\nend", "  text.downcase\
    \ == text.downcase.reverse\nend", "\ttext == text.reverse\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
