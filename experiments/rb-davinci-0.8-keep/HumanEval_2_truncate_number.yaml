name: HumanEval_2_truncate_number
language: rb
prompt: "# Given a positive floating point number, it can be decomposed into\n# and\
  \ integer part (largest integer smaller than given number) and decimals\n# (leftover\
  \ part always smaller than 1).\n# Return the decimal part of the number.\n# >>>\
  \ truncate_number(3.5)\n# 0.5\ndef truncate_number(number)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_truncate_number\n\
  \    candidate = method(:truncate_number)\n    assert_equal(0.5, candidate.call(3.5))\n\
  \    assert_equal(0.25, candidate.call(1.25))\n    assert_equal(0.0, candidate.call(123.0))\n\
  \  end\nend\n"
completions: ["  leftover = number % 1\n  return leftover\nend", "  number.to_i !=\
    \ number ? number - number.to_i : 0\nend", "  number.to_i # TODO\nend", "  number.to_i\n\
    end", '  remainder = number.to_i', "  number % 1\nend", "  # TODO: write code\
    \ here\nend", "  number.to_i.to_f\nend", "  # not sure what this is supposed to\
    \ do\nend", "  return (number - number.to_i)\nend", "  # number.to_s.split(\"\
    .\")[1].to_f\n  # 0.3\n  number - number.to_i\nend", "  number.to_i % number\n\
    end", "  if number < 0\n    truncate_number(number * -1)\n  else\n    number -\
    \ number.floor\n  end\nend", "  # Your code here\nend", "  number.to_i\nend",
  "  # your code here\nend", "  # Decomposing the number into a string, splitting\
    \ the string by the\n  # '.' (floating point separator), and returning the decimal\
    \ part (index 1).\n  return number.to_s.split('.')[1].to_f\nend", "  if (number\
    \ >= 0)\n    # extract the decimal part of the number\n    number -= number.to_i\n\
    \  else\n    # remove the negative sign, extract the decimal part and then add\
    \ negative sign\n    -1 * (number.abs - number.abs.to_i)\n  end\nend", "  # TODO\n\
    end", "  number - number.to_i\nend", "  # YOUR CODE HERE\nend", "  number.to_i\n\
    end", "  if number.is_a? Integer\n    0\n  else\n    number % 1\n  end\nend",
  "  str = number.to_s\n  index = str.index('.')\n  decimal = str[index..-1]\n  decimal.to_f\n\
    end", "  (number % 1)\nend", "  number - number.floor\nend", "  return number\
    \ % 1\nend", "  number.to_i % 1\nend", "  # <YOUR CODE HERE>\nend", "  # TODO\n\
    end", "\nend", "  # --------------------------\n  # Your code goes here.\n  #\
    \ --------------------------\nend", "\tnumber.modulo(1)\nend", "  number.floor\
    \ - number\nend", "  number - number.to_i\nend", "  number.modulo(1)\nend", "\n\
    end", "  leftover = number - number.to_i\n  return leftover\nend", "  number %\
    \ 1\nend", "  number - number.to_i\nend", "  0.5\nend", "\nend", "  #your code\
    \ here\nend", "  # TODO: Your code here\nend", "  return number - number.to_i\n\
    end", "  # TODO: implement this method\nend", "  decimal = number - number.to_i\n\
    \  decimal\nend", "  number.to_i\nend", "  # TODO: write code here\nend", "  number\
    \ % 1\nend", "  number.to_i\nend", "  return number.to_i\nend", "  str = (number\
    \ - number.to_i).to_s\n  str.slice(2..-1).to_f\nend", "  # Hint: the floor method\
    \ may come in handy.\n  # You may also want to make use of the % operator\n  #\
    \ ... your code here\nend", "  number.divmod(1)[1]\nend", "  number.modulo(1)\n\
    end", "  number.to_i\nend", "  return number - number.to_i\nend", end, "  (number\
    \ % 1)\nend", "\treturn number.to_i\nend", "  number.floor - number\nend", " \
    \ number - number.floor\nend", "  number.floor % 1\nend", "\tnumber.to_i - number\n\
    end", "  # number.to_s.split(\".\")[1].to_f\n  # number.modulo(1)\n  # number.truncate(1)\n\
    \  number - number.truncate\nend", "  number.to_i - number\nend", "  number.to_i\n\
    end", "  return number - number.floor\nend", "  number = number.to_s\n  number.split(\"\
    .\")[1].to_f\nend", "  number - number.to_i\nend", "  # split the number into\
    \ an array, with the first element as the integer\n  # part and the second element\
    \ as the decimal part. Return the decimal part.\n  number.to_s.split('.')[1].to_f\n\
    end", "  number.to_i\nend", "  number.to_i\nend", "  number - number.to_i\nend",
  "  # TODO: Write number truncation code here\n  # Hint:\n  # - Assign a variable\
    \ (integer_part) to the integer part of the number.\n  # - Assign a variable (decimal_part)\
    \ to the decimal part of the number.\n  # - Return decimal_part.\n  integer_part\
    \ = number.to_i\n  decimal_part = number - integer_part\n  decimal_part\nend",
  "  # Your code here\nend", '  # TODO: Implement this method', "  number.to_i - number\n\
    end", "  number % 1\nend", "  return number - number.to_i\nend", "  # Hint: You\
    \ can multiply a number by a power of 10 and\n  # then get its integer part by\
    \ using the `div` method.\n  # E.g.: 1.0 == 10.0.div(10)\n  # ... 0.0\nend", " \
    \ number.to_i\nend", "  # TODO: return the decimal part of the number\n  return\
    \ number - number.to_i\nend", "  number.to_i - number\nend", "  # Hint: You can\
    \ create an array of chars from the number\n  # NOTE: There is a built-in function\
    \ for this but we haven't covered it yet.\n  # return number.to_s.split(\".\"\
    )[1].to_f", "  number.to_i - number\nend", "  # Get the integer and truncate the\
    \ number\n  number.truncate\n  # Finally return the difference between the 2 results\n\
    \  number - number.truncate\nend", end, "  number.to_i\nend", "  decimal = number\
    \ - number.to_i\n  return decimal\nend", end, "  integer, decimals = number.divmod(1)\n\
    \  decimals\nend", "  # write your code here\nend", end, "  number.to_i\nend",
  "  # Integers have no decimals, so return 0\n  return 0 if number.is_a? Integer",
  "  # num = number\n  # whole = num.to_i\n  # decimals = num - whole\n  # return\
    \ decimals\n  whole = number.to_i\n  number - whole\nend", "  if number > 0\n\
    \    number -= number.floor\n  else\n    number -= number.ceil\n  end\nend", " \
    \ return (number % 1)\nend", "  # number.to_i.to_f\n  return number - number.to_i\n\
    end", "  number.to_i\nend", "  if number.nil? || number.to_i == number\n    0\n\
    \  else\n    number - number.to_i\n  end\nend", "  # hint: to_i will truncate\n\
    end", "  number.to_i - number\nend", end, "  return number.to_i - number\nend",
  "  # TODO: return integer part of a number\n  # number = number.to_i\n  number.truncate\n\
    end", "\tdecimal = number % 1\n\treturn decimal\nend", "  # TODO\nend", end, " \
    \ num = number.to_s.split('.')\n  num[1].to_f / 10\nend", "\nend", "  return number\
    \ - number.to_i\nend", "  # you code here\nend", "  puts \"Original number: #{number}.\"\
    \n  trunc_num = (number * 100).to_i\n  puts \"Truncated number: #{trunc_num}\"\
    \n  puts \"Decimal part: #{trunc_num.to_f / 100}\"\nend", "  # your code here\n\
    end", "  # TODO: return decimal part of number\n  # (1) split by .\n  # (2) get\
    \ the part of the array with the decimals\n  # (3) transform to string and substract\
    \ the first character", "  # TODO: Implement this method.\n  number.modulo(1)\n\
    end", end, "  num = number.to_s.split('.')\n  num[1].to_f / 10 ** num[1].length\n\
    end", "  if number > 0\n    number = number - number.floor\n  else\n    number\
    \ = 0 - (number - number.floor)\n  end\n  number\nend", "  truncate_number = number.to_i\n\
    \  x = number - truncate_number\n  x.round(2)\nend", "\nend", "  number.to_i\n\
    end", "  # your code here\nend", "  number.to_i.to_f != number ? number - number.to_i\
    \ : 0\nend", "  number.to_i\nend", "  # your code here\nend", "  number - number.floor\n\
    end", "  number.modulo(1)\nend", "  # write your code here\nend", "\nend", " \
    \ number.to_i - number\nend", "\tint_part = number.floor\n\tdecimal_part = number\
    \ - int_part\n\treturn decimal_part\nend", "\nend", "  number.to_i\nend", "\n\
    end", "  # YOUR CODE HERE\nend", "  number - number.floor\nend", "  # --- Your\
    \ code here ---\nend", end, "  p number\n  p number.to_i\n  p number - number.to_i\n\
    end", "  # your code here\nend", "  decimals = number - number.to_i\n  decimals\n\
    end", "  #using the modulus operator\n  puts number % 1\nend", "\tnumber -= number.floor\n\
    end", "  return number - number.to_i\nend", "  number - number.to_i\nend", " \
    \ return number - number.to_i\nend", "  return number % 1\nend", "  # The method\
    \ String#to_i converts to number, but discards the\n  # decimal part of the number.\n\
    \  return number - number.to_i\nend", "  number.to_i - number\nend", "  if number\
    \ < 0\n    number.to_s.reverse.to_i.to_s.reverse.to_f\n  else\n    (number - number.to_i).round(3)\n\
    \  end\nend", "\nend", "  number.to_i\nend", "\treturn number - number.to_i\n\
    end", "  # number.to_i is the integer part\n  number - number.to_i\nend", "  number.to_i\n\
    end", "\nend", "  #divmod(1) -> [1, 0.5]\n  # [3, 0.5] -> 0.5\n  number.divmod(1)[1]\n\
    end", "  number.to_i\nend", "  return number - number.to_i\nend", "  # TODO: implement\
    \ me\nend", "  return number.to_i\nend", "  # => In a series of steps, replace\
    \ the ??? with the method you need to fix the test.\n  number.to_i.to_f\nend",
  "  number.to_i\nend", "\tres = number.to_i\n\tres = number - res\n\tres\nend", " \
    \ if number > 0\n    number - number.to_i\n  else\n    number.to_i - number\n\
    \  end\nend", "\nend", "  # TODO: return the decimal part of the number\n  return\
    \ number - number.floor\nend", "  number.to_i - number\nend", "  num, dec = number.divmod(1)\n\
    \  dec\nend", "  # raise 'not implemented'\n  if number >= 0\n    number -= number.to_i\n\
    \  else\n    number -= number.to_i\n    number = -number\n  end\nend", end, " \
    \ number % 1\nend", "  # your code here\nend", "  number - number.to_i\nend",
  "  raise TypeError.new('Not a number') unless number.is_a?(Numeric)\n  raise ArgumentError.new('Can\\\
    't work with negative numbers') if number < 0\n  number.to_i.to_f == number ?\
    \ 0 : number - number.to_i\nend", end, "  # strip off the integer part and return\
    \ the fractional part\n  number.to_s.split('.').last.to_f\nend", "\tn = number.to_i\n\
    \tdecimals = number - n\n\tdecimals\nend", "  a = number.to_i\n  b = number -\
    \ a\n  return b\nend", "  # TODO\nend", "  (number % 1).to_f\nend", "  # TODO:\
    \ Your code here.\nend", "  number.to_i\nend", end, "  # TODO: return the decimal\
    \ part\n  if number % 1 == 0\n    0\n  else\n    (number % 1).round(1)\n  end\n\
    end", "  number - number.to_i\nend", "  number - number.to_i\nend", "  number.to_i.to_f\
    \ == number ? 0 : number - number.to_i\nend", "\nend", "  number.to_i != number\
    \ ? number - number.to_i : 0\nend", "  number - number.floor\nend", "  return\
    \ number - number.floor()\nend", "  number.to_i == number ? 0 : number - number.to_i\n\
    end", "  integer, decimals = number.divmod(1)\n  decimals\nend", "  number.to_i\n\
    end", "  # return number - number.to_i\n  # return number % 1\n  # return number\
    \ - number.floor\n  return number.modulo(1)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
