name: HumanEval_131_digits
language: rb
prompt: "# Given a positive integer n, return the product of the odd digits.\n# Return\
  \ 0 if all digits are even.\n# For example:\n# digits(1)  == 1\n# digits(4)  ==\
  \ 0\n# digits(235) == 15\ndef digits(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_digits\n\
  \    candidate = method(:digits)\n    assert_equal(5, candidate.call(5))\n    assert_equal(5,\
  \ candidate.call(54))\n    assert_equal(1, candidate.call(120))\n    assert_equal(5,\
  \ candidate.call(5014))\n    assert_equal(315, candidate.call(98765))\n    assert_equal(2625,\
  \ candidate.call(5576543))\n    assert_equal(0, candidate.call(2468))\n  end\nend\n"
completions: ["  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.chars.map { |c| c.to_i }.select { |x| x.odd? }.reduce(:*) || 0\nend",
  "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).reduce(1,\
    \ :*) if n.to_s.split('').map(&:to_i).any? { |x| x.odd? }\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  digits = n.to_s.split('').map { |digit| digit.to_i }\n  digits.select\
    \ { |digit| digit.odd? }.reduce(:*) || 0\nend", "  numbers = n.to_s.split('').map(&:to_i)\n\
    \  total = 1\n  numbers.each do |num|\n    if num.odd?\n      total *= num\n \
    \   end\n  end\n  total\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  sum = 1\n  loop do\n    break if n == 0\n    digit = n % 10\n\
    \    sum *= digit if digit.odd?\n    n /= 10\n  end\n  sum\nend", "  n.to_s.split('').inject(1)\
    \ { |product, i| i.to_i.odd? ? product * i.to_i : product }\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |num| num.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "    return 0 if n == 0\n    n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\n\
    end", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  digits\
    \ = []\n  until n == 0\n    digits << n % 10\n    n /= 10\n  end\n  digits.select!\
    \ { |digit| digit.odd? }\n  product = 1\n  digits.each { |digit| product *= digit\
    \ }\n  product\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  nums = n.to_s.split('')\n  result = nums.select { |num| num.to_i.odd?\
    \ }\n  result.empty? ? 0 : result.reduce(:*).to_i\nend", "  arr = n.to_s.split('')\n\
    \  product = arr.map { |e| e.to_i }.select { |e| e.odd? }.reduce(:*)\n  product.nil?\
    \ ? 0 : product\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) ||\
    \ 0\nend", "  return 0 if n.to_s.split('').map(&:to_i).all?(&:even?)\n  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\n\
    end", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", " \
    \ # your code here\n  answer = 1\n  n.to_s.split('').each do |x|\n    answer *=\
    \ x.to_i if x.to_i.odd?\n  end\n  answer\nend", "  arr = n.to_s.split('')\n  arr.map!\
    \ { |x| x.to_i }\n  arr.select! { |i| i.odd? }\n  arr.inject(:*) || 0\nend", " \
    \   return 0 if n < 0\n    return n if n < 10", "\tar = []\n\treturn 0 if n <=\
    \ 0\n\tar = n.to_s.split('').map(&:to_i)\n\tar.select!{|x| x%2 != 0}.inject(:*)\n\
    end", "  n.to_s.chars.map(&:to_i).select { |x| x.odd? }.reduce(:*) || 0\nend",
  "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |x| x % 2 != 0 }.reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).reject(&:even?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.inject(1) { |product, number| number.to_i.odd? ?\
    \ product * number.to_i : product }\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |x| x % 2 != 0 }.reduce(:*) || 0\nend", "  n.to_s.chars.reduce(1) { |acc,\
    \ cur| cur.to_i.odd? ? acc * cur.to_i : acc }\nend", "  num = n.to_s.split('')\n\
    \  num.delete_if { |x| x.to_i.even? }\n  num.empty? ? 0 : num.map(&:to_i).reduce(:*)\n\
    end", "  num = n.to_s.split('')\n  result = 1\n  num.each do |i|\n    if i.to_i.odd?\n\
    \      result *= i.to_i\n    end\n  end\n  result\nend", "  return 0 if n == 0\n\
    \  answer = 1\n  n.to_s.split('').each do |i|\n    if i.to_i.odd?\n      answer\
    \ *= i.to_i\n    end\n  end\n  answer\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  prod = 1\n  str_n = n.to_s\n  str_n.chars.each\
    \ do |ch|\n    prod *= ch.to_i if ch.to_i.odd?\n  end\n  prod == 1 ? 0 : prod\n\
    end", "  n.to_s.chars.map(&:to_i).reject(&:even?).reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |digit| digit.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |num| num.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map { |x| x.to_i }.select\
    \ { |y| y.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').inject(1) { |prod,\
    \ num| (num.to_i.odd?) ? prod * num.to_i : prod }\nend", "\tn = n.to_s.split('')\n\
    \tarr = []\n\tn.each do |i|\n\t\tarr << i.to_i\n\tend\n\tarr.each do |i|\n\t\t\
    if i % 2 == 0\n\t\t\tarr.delete(i)\n\t\tend\n\tend\n\tif arr.length == 0\n\t\t\
    0\n\telse\n\t\tarr.inject(:*)\n\tend\nend", "  n.to_s.split('').map { |digit|\
    \ digit.to_i }.reduce(1) { |result, digit| digit.odd? ? result * digit : result\
    \ }\nend", "\tn.to_s.chars.inject(1) { |product, n| n.to_i.odd? ? product * n.to_i\
    \ : product }\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) ||\
    \ 0\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  res = 1\n\
    \  while n > 0\n    d = n % 10\n    res *= d if d.odd?\n    n /= 10\n  end\n \
    \ res == 1 ? 0 : res\nend", "  return 0 if n == 0\n  d = n % 10\n  d = digits(n\
    \ / 10) if d.even?\n  d\nend", "  n.to_s.scan(/\\d/).map(&:to_i).select { |i|\
    \ i.odd? }.reduce(:*) || 0\nend", "    n.to_s.split('').map(&:to_i).select { |num|\
    \ num.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "    return 0 if n == 0\n    (n % 10).odd? ? digits(n / 10) * (n % 10) : digits(n\
    \ / 10)\nend", "  n.to_s.chars.select { |x| x.to_i.odd? }.inject(1) { |result,\
    \ number| result * number.to_i }\nend", "  n.to_s.split('').map(&:to_i).inject(1)\
    \ { |a, b| b.odd? ? a * b : a }\nend", "  str = n.to_s\n  num = []\n  str.each_char\
    \ do |v|\n    num << v.to_i\n  end\n  product = num.select { |v| v.odd? }.reduce(:*)\n\
    \  product || 0\nend", "    # Your code here\nend", "  digits = n.to_s.split('').map\
    \ { |x| x.to_i }\n  products = []\n  digits.each do |digit|\n    if digit.odd?\n\
    \      products << digit\n    end\n  end\n  if products.size > 0\n    products.inject(:*)\n\
    \  else\n    0\n  end\nend", "    n.to_s.chars.map(&:to_i).select { |x| x.odd?\
    \ }.reduce(:*) || 0\nend", "  n.to_s.scan(/\\d/).map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select { |x| x.odd? }.reduce(:*) ||\
    \ 0\nend", "  a = n.to_s.split('').map(&:to_i)\n  b = a.select { |i| i.odd? }\n\
    \  b.size > 0 ? b.reduce(:*) : 0\nend", "  n.to_s.chars.map { |x| x.to_i }.select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  x = n.to_s.split('').map { |i| i.to_i\
    \  }\n  y = x.select { |i| i % 2 != 0 }\n  return 0 if y.empty?\n  y.reduce(:*)\n\
    end", "  prod = 1\n  until n == 0\n    digit = n % 10\n    prod *= digit if digit.odd?\n\
    \    n /= 10\n  end\n  prod\nend", "  n.to_s.split('').select{|i| i.to_i.odd?}.map(&:to_i).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select { |i| i.odd? }.reduce(:*) ||\
    \ 0\nend", "  digits = n.to_s.split('').map(&:to_i)\n  digit_product = 1\n  digits.each\
    \ do |i|\n    digit_product *= i if i.odd?\n  end\n  digit_product == 1 ? 0 :\
    \ digit_product\nend", "  n.to_s.chars.map(&:to_i).select { |x| x.odd? }.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.chars.reduce(1) { |product, elem| elem.to_i.odd? ? product * elem.to_i\
    \ : product }\nend", "    return 0 if n.digits.all?(&:even?)\n    n.digits.select(&:odd?).reduce(:*)\n\
    end", "  n.to_s.chars.inject(1) { |result, el| el.to_i.odd? ? result * el.to_i\
    \ : result }\nend", "  n.to_s.split('').map(&:to_i).select { |x| x.odd? }.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.select { |num| num.to_i.odd? }.join.to_i\nend",
  "  return 0 if n == 0\n  (n % 10) % 2 == 1 ? digits(n / 10) * (n % 10) : digits(n\
    \ / 10)\nend", "  a = n.to_s.chars.map(&:to_i)\n  b = []\n  a.each do |n|\n  \
    \  if n.odd?\n      b << n\n    end\n  end\n  if b.count > 0\n    c = b.inject(:*)\n\
    \  else\n    c = 0\n  end\n  puts c\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "    return 0 if n.digits.all? { |digit|\
    \ digit.even? }\n    n.digits.map { |digit| digit.odd? ? digit : nil }.compact.reduce(:*)\n\
    end", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  # Your\
    \ code here\nend", "  n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }.reduce(:*)\
    \ || 0\nend", "  arr = n.to_s.split('')\n  product = 1\n  arr.each do |num|\n\
    \    if num.to_i.odd?\n      product *= num.to_i\n    end\n  end\n  product ==\
    \ 1 ? 0 : product\nend", "  n.to_s.split('').map(&:to_i).select { |digit| digit.odd?\
    \ }.reduce(:*) || 0\nend", "  n.to_s.chars.map { |e| e.to_i }.select { |e| e.odd?\
    \ }.reduce(:*) || 0\nend", "    n.to_s.split('').map(&:to_i).select{|i| i.odd?}.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  answer = 1\n  n.to_s.split('').each do |x|\n    if x.to_i % 2 != 0\n      answer\
    \ *= x.to_i\n    end\n  end\n  answer\nend", "  arr = n.to_s.split('')\n  result\
    \ = 1\n  arr.each do |digit|\n    if digit.to_i.odd?\n      result *= digit.to_i\n\
    \    end\n  end\n  if result == 1\n    0\n  else\n    result\n  end\nend", " \
    \ n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |number| number.odd? }.reduce(:*) || 0\nend", "  p n.to_s.split('').select\
    \ { |e| e.to_i.odd? }.inject(1) { |s, e| s * e.to_i }\nend", "  # solve the problem\
    \ here\n  (n % 10).odd? ? (n / 10).odd? ? (n % 10) * (n / 10) : n % 10 : (n /\
    \ 10).odd? ? n / 10 : 0\nend", "  n.to_s.split('').map(&:to_i).select { |i| i.odd?\
    \ }.reduce(:*) || 0\nend", "    n.to_s.chars.map(&:to_i).select{|x| x.odd?}.reduce(:*)\
    \ || 0\nend", "  count = 0\n  n.to_s.chars.map(&:to_i).each do |i|\n    if i %\
    \ 2 != 0\n      count += i\n    end\n  end\n  count\nend", "  n.to_s.split('').select\
    \ { |i| i.to_i.odd? }.reduce(1) { |prod, i| prod * i.to_i }\nend", "  return 0\
    \ if n == 0\n  digit = n % 10\n  digit.odd? ? digit * digits(n / 10) : digits(n\
    \ / 10)\nend", "  n.to_s.split('').map { |x| x.to_i }.select { |x| x.odd? }.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.reduce(1) { |a, e| e.to_i.odd? ? a * e.to_i : a\
    \ }\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  (n.to_s.split('').map(&:to_i).select\
    \ { |i| i.odd? }).inject(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |dig| dig.odd? }.reduce(:*) || 0\nend", "  # n.to_s.split('').map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\n  n.to_s.split('').map(&:to_i).reduce(1) { |product,\
    \ i| i.odd? ? product * i : product }\nend", "  n.to_s.chars.select { |digit|\
    \ digit.to_i.odd? }.map(&:to_i).reduce(:*) || 0\nend", "  p = 1\n  while n > 0\n\
    \    d = n % 10\n    if d.odd?\n      p *= d\n    end\n    n /= 10\n  end\n  p\n\
    end", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", " \
    \ n.to_s.split('').map(&:to_i).select { |i| i.odd? }.reduce(:*) || 0\nend", " \
    \ return 0 if n.digits.all?(&:even?)\n  n.digits.find_all(&:odd?).reduce(:*)\n\
    end", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.inject(1) { |acc, n| n.to_i.odd? ? acc * n.to_i\
    \ : acc }\nend", "  n.to_s.chars.inject(1) { |product, n| n.to_i.odd? ? product\
    \ * n.to_i : product }\nend", "  n.to_s.chars.map(&:to_i).select { |i| i.odd?\
    \ }.reduce(:*) || 0\nend", "  n.to_s.chars.inject(1) { |a, e| e.to_i.odd? ? a\
    \ * e.to_i : a }\nend", "  n.to_s.split('').map(&:to_i).reduce(1, :*) { |p, n|\
    \ n.odd? ? p * n : p }\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  # Your code goes here\nend", "  return 0 if n.even?\n  n = n.to_s.split('').map(&:to_i)\n\
    \  n.select!(&:odd?)\n  n.reduce(:*)\nend", "  nums = n.to_s.split('')\n  odd_nums\
    \ = nums.select { |num| num.to_i.odd? }\n  product = 1\n  odd_nums.each { |num|\
    \ product *= num.to_i }\n  product == 1 ? 0 : product\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |v| v.odd? }.reduce(:*) || 0\nend", "  n.to_s.scan(/\\d/).map(&:to_i).inject(1){|r,\
    \ x| x.odd? ? r * x : r}\nend", "  n.to_s.scan(/\\d/).map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.split('').map(&:to_i).select { |x| x.odd? }.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |num| num.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').map { |i| i.to_i\
    \ }.select { |i| i.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').reduce(1)\
    \ { |memo, item| memo *= item.to_i if item.to_i.odd?; memo } || 0\nend", "  #your\
    \ code here\n  answer = []\n  n = n.to_s.split('')\n  n.each do |i|\n    answer\
    \ << i.to_i if i.to_i.odd?\n  end\n  answer.empty? ? 0 : answer.inject(:*)\nend",
  "  n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }.reduce(:*) || 0\nend",
  "  n.to_s.chars.reduce(1) { |r, c| c.to_i.odd? ? r * c.to_i : r }\nend", "  n.to_s.chars.map\
    \ { |c| c.to_i }.inject(1) { |prod, n| n.odd? ? prod * n : prod }\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "  # n.to_s.gsub(/[02468]/, '').split('').map(&:to_i).reduce(:*)\
    \ || 0\n  n.to_s.gsub(/[02468]/, '').split('').map(&:to_i).inject(:*) || 0\nend",
  "  n.to_s.split('').select{|x| x.to_i.odd?}.inject(1){|m,n| m*n.to_i}\nend\nputs\
    \ \"digits(235) returns #{digits(235)}\"", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  arr = n.to_s.split('')\n  total = 1\n  arr.each do |i|\n    if\
    \ i.to_i.odd?\n      total *= i.to_i\n    end\n  end\n  total.zero? ? 0 : total\n\
    end", "  n.to_s.split('').map(&:to_i).select { |x| x.odd? }.reduce(:*) || 0\n\
    end", "  return 0 if n.digits.all?(&:even?)\n  n.digits.select(&:odd?).reduce(:*)\n\
    end", "  n.to_s.split('').select { |d| d.to_i.odd? }.map(&:to_i).reduce(:*) ||\
    \ 0\nend", "  n.to_s.chars.reduce(1) { |a,e| e.to_i.odd? ? a * e.to_i : a }\n\
    end", "  return 0 if n < 1\n  n.to_s.split('').inject(1) { |s, i| i.to_i.odd?\
    \ ? s * i.to_i : s }\nend", "  # Your code here\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |n| n.odd? }.reduce(:*) || 0\nend", "  n.to_s.scan(/\\d/).map(&:to_i).reduce(1)\
    \ { |sum, a| a.odd? ? sum * a : sum }\nend", "  arr = n.to_s.split('')\n  sum\
    \ = 1\n  arr.each do |num|\n    if num.to_i.odd?\n      sum *= num.to_i\n    end\n\
    \  end\n  sum\nend", "  n.to_s.split('').map { |x| x.to_i }.select { |x| x.odd?\
    \ }.reduce(:*) || 0\nend", "  # n.to_s.chars.map(&:to_i).select { |x| x.odd? }.reduce(:*)\
    \ || 0\n  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  n.to_s.chars.select\
    \ { |i| i.to_i.odd? }.join.to_i\nend", "  n.to_s.split('').select { |i| i.to_i.odd?\
    \ }.map(&:to_i).reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  result = 1\n  num_array = n.to_s.split('')\n  num_array.each\
    \ do |a|\n    if a.to_i % 2 != 0\n      result *= a.to_i\n    end\n  end\n  result\n\
    end", "  nums = n.to_s.split('')\n  nums.keep_if { |x| x.to_i.odd? }\n  if nums.length\
    \ == 0\n    return 0\n  else\n    nums.map! { |x| x.to_i }\n    nums.reduce(:*)\n\
    \  end\nend", "  n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }.reduce(:*)\
    \ || 0\nend", "  # ...\n  if n > 0\n    sum = 1\n    n.to_s.split('').each do\
    \ |num|\n      if num.to_i.odd?\n        sum *= num.to_i\n      end\n    end\n\
    \    sum\n  else\n    n\n  end\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.split('').map { |digit| digit.to_i}.select { |digit| digit.odd?\
    \ }.reduce(:*) || 0\nend", "  if n == 0\n    return 0\n  else\n    odds = []\n\
    \    while n > 0\n      x = n % 10\n      if x % 2 != 0\n        odds << x\n \
    \     end\n      n = n / 10\n    end\n    if odds.empty?\n      return 0\n   \
    \ else\n      odds.inject(:*)\n    end\n  end\nend", "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  #your code here\n  digits = n.to_s.split('')\n  result = 1\n\
    \  digits.each do |d|\n    if d.to_i.odd?\n      result *= d.to_i\n    end\n \
    \ end\n  result\nend", "  n.to_s.chars.map(&:to_i).reduce(1) { |acc, el| el.odd?\
    \ ? acc * el : acc }\nend", "  return 0 if n == 0\n  n.digits.reject(&:even?).reduce(:*)\n\
    end", "  n.to_s.split('').map { |x| x.to_i }.select { |x| x.odd? }.reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select { |num| num.odd? }.reduce(:*)\
    \ || 0\nend", "  digits = n.to_s.split('').map(&:to_i)\n  digits.select { |digit|\
    \ digit.odd? }.reduce(:*) || 0\nend", "  return 0 if n < 0\n  arr = n.to_s.split('').map(&:to_i)\n\
    \  arr.delete_if { |n| n.even? }\n  arr.reduce(:*)\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*) || 0\nend",
  "  product = 1\n  n.to_s.each_char do |c|\n    product *= c.to_i if c.to_i.odd?\n\
    \  end\n  product == 1 ? 0 : product\nend", "  return 0 if n.digits.all?(&:even?)\n\
    \  n.digits.select(&:odd?).reduce(:*)\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |i| i.odd? }.reduce(:*) || 0\nend", "  # TODO\nend", "  # happy coding\n \
    \ n.to_s.split('').map(&:to_i).inject(0) { |x, y| y.odd? ? x * y : x }\nend",
  "  n.to_s.split('').map(&:to_i).delete_if{|x| x % 2 == 0}.inject(:*) || 0\nend",
  "  return 0 if n.digits.all?(&:even?)\n  n.digits.select(&:odd?).reduce(:*)\nend",
  "  n.to_s.chars.map(&:to_i).select { |digit| digit.odd? }.reduce(:*) || 0\nend",
  "  return 0 if n.digits.all?(&:even?)\n  n.digits.select(&:odd?).reduce(:*)\nend",
  "  n.to_s.chars.map(&:to_i).select { |i| i.odd? }.reduce(:*) || 0\nend", "  n.to_s.split('').select\
    \ { |i| i.to_i.odd? }.map(&:to_i).reduce(:*) || 0\nend", "  n.to_s.split('').map\
    \ { |x| x.to_i }.select { |x| x.odd? }.reduce(:*) || 0\nend", "  i = 0\n  array\
    \ = []\n  array_odds = []\n  while i < n.to_s.length\n    array << n.to_s[i].to_i\n\
    \    i += 1\n  end\n  array.each do |n|\n    if n.odd?\n      array_odds << n\n\
    \    end\n  end\n  puts array_odds.reduce(:*)\nend\ndigits(235)\ndigits(1)\ndigits(4)",
  "  n.to_s.split('').map(&:to_i).select(&:odd?).reduce(:*) || 0\nend", "  return\
    \ 0 if n == 0\n  product = 1\n  while n > 0\n    product *= n % 10 if n % 2 !=\
    \ 0\n    n /= 10\n  end\n  product\nend", "  # your code here\n  sum = 1\n  n.to_s.each_char\
    \ do |i|\n    if i.to_i % 2 != 0\n    sum *= i.to_i\n    end\n  end\n  sum\nend",
  "  return n.to_s.scan(/\\d/).select { |x| x.to_i.odd? }.inject(1) { |a,b| a * b.to_i\
    \ }\nend", "  res = 0\n  n.to_s.split('').each do |char|\n    if char.to_i.odd?\n\
    \      res *= char.to_i\n    end\n  end\n  res\nend", "  n.to_s.split('').map(&:to_i).select\
    \ { |num| num.odd? }.reduce(:*) || 0\nend", "  n.to_s.chars.map(&:to_i).select\
    \ { |x| x.odd? }.reduce(:*) || 0\nend", "    n.to_s.chars.map(&:to_i).select{|n|\
    \ n.odd?}.reduce(:*) || 0\nend", "  return 0 if n.zero?\n  n.to_s.chars.map(&:to_i).select(&:odd?).reduce(:*)\
    \ || 0\nend", "  n.to_s.chars.map { |num| num.to_i }.select { |num| num.odd? }.reduce(:*)\
    \ || 0\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
