name: HumanEval_46_fib4
language: rb
prompt: "# The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece\
  \ that's defined as follows:\n# fib4(0) -> 0\n# fib4(1) -> 0\n# fib4(2) -> 2\n#\
  \ fib4(3) -> 0\n# fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n# Please\
  \ write a function to efficiently compute the n-th element of the fib4 number sequence.\
  \  Do not use recursion.\n# >>> fib4(5)\n# 4\n# >>> fib4(6)\n# 8\n# >>> fib4(7)\n\
  # 14\ndef fib4(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_fib4\n\
  \    candidate = method(:fib4)\n    assert_equal(4, candidate.call(5))\n    assert_equal(28,\
  \ candidate.call(8))\n    assert_equal(104, candidate.call(10))\n    assert_equal(386,\
  \ candidate.call(12))\n  end\nend\n"
completions: ["  nums = [0, 0, 2, 0]\n  return nums[n] if n < 4\n  (4..n).each do\
    \ |index|\n    nums << nums[index-1] + nums[index-2] + nums[index-3] + nums[index-4]\n\
    \  end\n  nums[n]\nend", "  if n == 0\n    return 0\n  elsif n == 1\n    return\
    \ 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n    return 0\n  end\n  a =\
    \ [0, 0, 2, 0]\n  i = 4\n  while i <= n\n    a << a[i-1] + a[i-2] + a[i-3] + a[i-4]\n\
    \    i += 1\n  end\n  return a[n]\nend", "  return 0 if n == 0\n  return 0 if\
    \ n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  arr = [0, 0, 2, 0]\n \
    \ (n-3).times do\n    arr << arr[0] + arr[1] + arr[2] + arr[3]\n    arr.shift\n\
    \  end\n  arr[3]\nend", "  # your code here\nend", end, "  return 0 if n == 0\n\
    \  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", end, end, "  # YOUR CODE HERE\nend",
  end, "  seq = [0, 0, 2, 0]\n  if n <= 3\n    return seq[n]\n  end\n  x = 4\n  while\
    \ x <= n\n    seq << seq[-1] + seq[-2] + seq[-3] + seq[-4]\n    x += 1\n  end\n\
    \  seq[-1]\nend", "  return n if n < 2\n  fib4_minus_1 = 0\n  fib4_minus_2 = 0\n\
    \  fib4_minus_3 = 0\n  fib4_minus_4 = 0\n  for i in 2..n\n    fib4_minus_4 = fib4_minus_3\n\
    \    fib4_minus_3 = fib4_minus_2\n    fib4_minus_2 = fib4_minus_1\n    fib4_minus_1\
    \ = fib4_minus_1 + fib4_minus_2 + fib4_minus_3 + fib4_minus_4\n  end\n  fib4_minus_1\n\
    end", "  return n if n <= 1\n  fib4_minus_1 = 1\n  fib4_minus_2 = 1\n  fib4_minus_3\
    \ = 2\n  fib4_minus_4 = 0\n  current_fib = 0\n  3.upto(n) do\n    current_fib\
    \ = fib4_minus_1 + fib4_minus_2 + fib4_minus_3 + fib4_minus_4\n    fib4_minus_4\
    \ = fib4_minus_3\n    fib4_minus_3 = fib4_minus_2\n    fib4_minus_2 = fib4_minus_1\n\
    \    fib4_minus_1 = current_fib\n  end\n  current_fib\nend", "\nend", "  return\
    \ 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n ==\
    \ 3\n  sum = 0\n  i = 4\n  while i <= n\n    sum += fib4(i - 1) + fib4(i - 2)\
    \ + fib4(i - 3) + fib4(i - 4)\n    i += 1\n  end\n  sum\nend", "\t#TODO: implement\
    \ me\n\treturn 0 if n==0\n\treturn 0 if n==1\n\treturn 2 if n==2\n\treturn 0 if\
    \ n==3\n\tfib_minus_1 = 1\n\tfib_minus_2 = 1\n\tfib_minus_3 = 2\n\tfib_minus_4\
    \ = 0\n\t(n-4).times do\n\t\tresult = fib_minus_1 + fib_minus_2 + fib_minus_3\
    \ + fib_minus_4\n\t\tfib_minus_4 = fib_minus_3\n\t\tfib_minus_3 = fib_minus_2\n\
    \t\tfib_minus_2 = fib_minus_1\n\t\tfib_minus_1 = result\n\tend\n\treturn fib_minus_1\n\
    end", end, "  n < 3 ? n : fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend",
  "  a, b, c, d = 0, 0, 2, 0\n  n.times do\n    a, b, c, d = b, c, d, a + b + c +\
    \ d\n  end\n  d\nend", "  fibs = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fibs[i\
    \ % 4] = fibs.sum\n  end\n  fibs[n % 4]\nend", "\t\nend", "  return 0 if n ==\
    \ 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "\nend", "    if n == 0\n       \
    \ return 0\n    elsif n == 1\n        return 0\n    elsif n == 2\n        return\
    \ 2\n    elsif n == 3\n        return 0\n    end\n    if n > 3\n        return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n    end\nend\nputs fib4(5)\n\
    puts fib4(6)\nputs fib4(7)", "\tnum1 = 0\n\tnum2 = 0\n\tnum3 = 2\n\tnum4 = 0\n\
    \ti = 4\n\twhile i <= n do\n\t\tnum1 = num2\n\t\tnum2 = num3\n\t\tnum3 = num4\n\
    \t\tnum4 = num1 + num2 + num3 + num4\n\t\ti = i + 1\n\tend\n\treturn num4\nend",
  end, "\treturn 0 if n == 0\n\treturn 0 if n == 1\n\treturn 2 if n == 2\n\treturn\
    \ 0 if n == 3\n\ta = 0\n\tb = 0\n\tc = 2\n\td = 0\n\tif n > 4\n\t\tfor i in 1..n-4\n\
    \t\t\ta = b\n\t\t\tb = c\n\t\t\tc = d\n\t\t\td = a + b + c + d\n\t\tend\n\tend\n\
    \treturn d\nend", "  # This \"memo\" technique is known as \"dynamic programming\"\
    \ and is a common technique used in computer science.\n  # See also: https://en.wikipedia.org/wiki/Dynamic_programming\n\
    \  return 0 if n <= 1\n  return 2 if n == 2\n  return 0 if n == 3\n  memo = [0,\
    \ 0, 2, 0]\n  # Loop through index 4 to n, each time we'll add the previous 4\
    \ elements in the sequence to the current element.\n  # Notice how by using memo,\
    \ we speed up the calculation of a fib4 number by reusing the previous computations.\n\
    \  # In general, the time complexity for a dynamic programming solution is O(n)\
    \ for an input of size n.\n  for i in 4..n\n    memo[i % 4] = memo[(i - 1) % 4]\
    \ + memo[(i - 2) % 4] + memo[(i - 3) % 4] + memo[(i - 4) % 4]\n  end\n  memo[n\
    \ % 4]\nend", "  if n == 0\n    return 0\n  elsif n == 1\n    return 0\n  elsif\
    \ n == 2\n    return 2\n  elsif n == 3\n    return 0\n  else\n    a, b, c, d =\
    \ 0, 0, 2, 0\n    for i in 4..n\n      e = a + b + c + d\n      a = b\n      b\
    \ = c\n      c = d\n      d = e\n    end\n    return d\n  end\nend", "  return\
    \ n if n < 2\n  a, b, c, d = 0, 0, 2, 0\n  (n - 2).times do\n    d = a + b + c\
    \ + d\n    a = b\n    b = c\n    c = d\n  end\n  d\nend", end, "  # your code\
    \ here\nend", "  a = 0\n  b = 0\n  c = 2\n  d = 0\n  i = 3\n  while i <= n\n \
    \   a = b\n    b = c\n    c = d\n    d = a + b + c\n    i += 1\n  end\n  return\
    \ d\nend", "\nend", "\tif n == 0\n\t\treturn 0\n\telsif n == 1\n\t\treturn 0\n\
    \telsif n == 2\n\t\treturn 2\n\telsif n == 3\n\t\treturn 0\n\tend\n\ta = 0\n\t\
    b = 0\n\tc = 2\n\td = 0\n\ti = 4\n\twhile i <= n\n\t\ttemp = d\n\t\td = a + b\
    \ + c + d\n\t\ta = b\n\t\tb = c\n\t\tc = temp\n\t\ti += 1\n\tend\n\treturn d\n\
    end", "  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return\
    \ 0 if n == 3\n  a = [0, 0, 2, 0]\n  while n > 3\n    a << a[0] + a[1] + a[2]\
    \ + a[3]\n    a.shift\n    n -= 1\n  end\n  a[3]\nend", "  return 0 if n == 0\n\
    \  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  # base case\n  if n == 0\n   \
    \ return 0\n  elsif n == 1\n    return 0\n  elsif n == 2\n    return 2\n  elsif\
    \ n == 3\n    return 0\n  end", "  # TODO\nend", "  fib4 = [0, 0, 2, 0]\n  return\
    \ fib4[n] if n < 4\n  for i in 4..n\n    fib4[i] = fib4[i-1] + fib4[i-2] + fib4[i-3]\
    \ + fib4[i-4]\n  end\n  fib4[n]\nend", "\treturn 0 if n <= 1\n\treturn 2 if n\
    \ == 2\n\treturn 0 if n == 3\n\t\n\ti = 0\n\tj = 0\n\tk = 2\n\tl = 0\n\t(n-3).times\
    \ do\n\t\tl = i + j + k\n\t\ti = j\n\t\tj = k\n\t\tk = l\n\tend\n\tl\nend", "\t\
    if n == 0\n\t\treturn 0\n\telsif n == 1\n\t\treturn 0\n\telsif n == 2\n\t\treturn\
    \ 2\n\telsif n == 3\n\t\treturn 0\n\telse\n\t\treturn fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\n\tend\nend", "  return 0 if n < 1\n  return 2 if n ==\
    \ 2\n  return 0 if n == 3\n  if n == 4\n    return 4\n  end\n  fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nend", "  return 0 if n < 2\n  return 2 if n == 2\n\
    \  return 0 if n == 3\n  return 4 if n == 4\n  return 8 if n == 5\n  fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend\np fib4(5)\np fib4(6)\np fib4(7)",
  "  return 0 if n < 2\n  return 2 if n == 2\n  return 0 if n == 3\n  # Now we need\
    \ to compute the rest of the fib4 sequence\n  prev1 = 0\n  prev2 = 0\n  prev3\
    \ = 2\n  prev4 = 0\n  for i in (4..n)\n    curr = prev1 + prev2 + prev3 + prev4\n\
    \    prev1 = prev2\n    prev2 = prev3\n    prev3 = prev4\n    prev4 = curr\n \
    \ end\n  return curr\nend", "  fib_nums = [0, 0, 2, 0]\n  i = 3\n  while i < n\n\
    \    fib_nums.unshift(fib_nums.reduce(:+))\n    fib_nums.pop\n    i += 1\n  end\n\
    \  fib_nums.reduce(:+)\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return\
    \ 2 if n == 2\n  return 0 if n == 3\n  array = [0, 0, 2, 0]\n  (4..n).each do\
    \ |num|\n    array << array[num-1] + array[num-2] + array[num-3] + array[num-4]\n\
    \  end\n  array[n]\nend", "  raise ArgumentError.new(\"n must be >= 0\") if n\
    \ < 0\n  return 0 if n == 0\n  n = n - 1\n  a, b, c, d = 0, 0, 2, 0\n  while n\
    \ > 0\n    a, b, c, d = b, c, d, (a + b + c + d)\n    n -= 1\n  end\n  d\nend",
  "  return 0 if n <= 1\n  return 2 if n == 2\n  return 0 if n == 3\n  fib1 = 0\n\
    \  fib2 = 0\n  fib3 = 2\n  fib4 = 0\n  (n-3).times do\n    fib4 = fib1 + fib2\
    \ + fib3 + fib4\n    fib1 = fib2\n    fib2 = fib3\n    fib3 = fib4\n  end\n  fib4\n\
    end", "\t#your code here\n\treturn nil if n < 0\n\treturn 0 if n <= 1\n\treturn\
    \ 2 if n == 2\n\treturn 0 if n == 3\n\ta = [0, 0, 2, 0]\n\t4.upto(n) do |i|\n\t\
    \ta << a[0] + a[1] + a[2] + a[3]\n\t\ta.shift\n\tend\n\ta[3]\nend", end, "  nth_fib_seq\
    \ = [0, 0, 2, 0]\n  return nth_fib_seq[n] if n < 4\n  until nth_fib_seq.length\
    \ > n\n    nth_fib_seq << nth_fib_seq[-1] + nth_fib_seq[-2] + nth_fib_seq[-3]\
    \ + nth_fib_seq[-4]\n  end\n  nth_fib_seq[n]\nend", "\t# x + y + z + n = n - 1\n\
    \t# x + y + z = n - 1 - n\n\t# x + y = n - 1 - n - z\n\t# x = n - 1 - n - z -\
    \ y\n\t# x + y + z + n = n\n\t# x + y + z = n - n\n\t# x + y = n - n - z\n\t#\
    \ x = n - n - z - y\n\t# x + y + z + n = n + 1\n\t# x + y + z = n + 1 - n\n\t\
    # x + y = n + 1 - n - z\n\t# x = n + 1 - n - z - y\n\t# x + y + z + n = n + 2\n\
    \t# x + y + z = n + 2 - n\n\t# x + y = n + 2 - n - z\n\t# x = n + 2 - n - z -\
    \ y\n\t# x + y + z + n = n + 3\n\t# x + y + z = n + 3 - n\n\t# x + y = n + 3 -\
    \ n - z\n\t# x = n + 3 - n - z - y\n\tif n == 0\n\t\t0\n\telsif n == 1\n\t\t0\n\
    \telsif n == 2\n\t\t2\n\telsif n == 3\n\t\t0\n\telse\n\t\tb, c, d, n = n - 3,\
    \ n - 2, n - 1, n\n\t\tfib4(n) = fib4(b) + fib4(c) + fib4(d) + fib4(n)\n\tend\n\
    end", "  # your code here\nend", "  fibs = [0, 0, 2, 0]\n  return fibs[n] if n\
    \ < 4\n  (4..n).each do |i|\n    fibs[i] = fibs[i-1] + fibs[i-2] + fibs[i-3] +\
    \ fibs[i-4]\n  end\n  fibs[n]\nend", "\tfib = [0, 0, 2, 0]\n\tfor i in 4..n\n\t\
    \tfib[i % 4] = fib[0] + fib[1] + fib[2] + fib[3]\n\tend\n\treturn fib[n % 4]\n\
    end", "  arr = [0, 0, 2, 0]\n  return arr[n] if n < 4\n  return arr if n < 4\n\
    \  (4..n).each do |index|\n    arr << arr[index-1] + arr[index-2] + arr[index-3]\
    \ + arr[index-4]\n  end\n  arr[n]\nend", "  nth_fib4(n)\nend", "    # your code\
    \ here\nend", "  s = [0, 0, 2, 0]\n  return s[n] if n < 4\n  s << s[-1] + s[-2]\
    \ + s[-3] + s[-4] until s.length == n + 1\n  s[-1]\nend", "  return 0 if n ==\
    \ 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  return\
    \ 4 if n == 4\n  a = 4\n  b = 8\n  c = 14\n  d = 25\n  for i in 5..n\n    a, b,\
    \ c, d = b, c, d, a + b + c + d\n  end\n  d\nend", "  if n < 4\n    n == 2 ? 2\
    \ : 0\n  else\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    4.upto(n) do\n\
    \      d = a + b + c\n      a = b\n      b = c\n      c = d\n    end\n    d\n\
    \  end\nend", "  return 0 if n < 2\n  return 2 if n == 2\n  return 0 if n == 3\n\
    \  n1 = 0\n  n2 = 0\n  n3 = 2\n  n4 = 0\n  n5 = 0\n  n5 = n1 + n2 + n3 + n4\n\
    \  (n-3).times do\n    n1 = n2\n    n2 = n3\n    n3 = n4\n    n4 = n5\n    n5\
    \ = n1 + n2 + n3 + n4\n  end\n  n5\nend", end, "  # Your code here\nend", end,
  "  raise \"not defined for #{n}\" if n < 0\n  return 0 if n == 0 || n == 1\n  return\
    \ 2 if n == 2\n  return 0 if n == 3\n  t0 = 0\n  t1 = 0\n  t2 = 2\n  t3 = 0\n\
    \  t4 = 0\n  (n-4).times do\n    t0 = t1\n    t1 = t2\n    t2 = t3\n    t3 = t4\n\
    \    t4 = t0 + t1 + t2 + t3\n  end\n  t4\nend", "  # Type your code here\nend",
  "  # your code here\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return\
    \ 2 if n == 2\n  return 0 if n == 3\n  a, b, c, d = 0, 0, 2, 0\n  (n-4).times\
    \ do\n    e = a + b + c + d\n    a, b, c, d = b, c, d, e\n  end\n  return d\n\
    end", "  fib = [0, 0, 2, 0]\n  if n <= 3\n    return fib[n]\n  end\n  for i in\
    \ 4..n\n    fib[i] = fib[i-1] + fib[i-2] + fib[i-3] + fib[i-4]\n  end\n  return\
    \ fib[n]\nend", "\treturn 0 if n == 0\n\treturn 0 if n == 1\n\treturn 2 if n ==\
    \ 2\n\treturn 0 if n == 3\n\tfib4_table = [0, 0, 2, 0]\n\tresult = 0\n\tfor i\
    \ in 4..n\n\t\tresult = fib4_table[0] + fib4_table[1] + fib4_table[2] + fib4_table[3]\n\
    \t\tfib4_table.delete_at(0)\n\t\tfib4_table.push(result)\n\tend\n\tresult\nend",
  "\nend", "\t(0..3).each { |i| return i if n == i }\n\ta, b, c, d = 0, 0, 2, 0\n\t\
    (4..n).each do\n\t\ta, b, c, d = b, c, d, a + b + c + d\n\tend\n\td\nend", " \
    \ return 0 if n == 0 || n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n \
    \ f1 = 0\n  f2 = 0\n  f3 = 2\n  f4 = 0\n  sum = f1 + f2 + f3 + f4\n  (n-4).times\
    \ do\n    f1 = f2\n    f2 = f3\n    f3 = f4\n    f4 = sum\n    sum = f1 + f2 +\
    \ f3 + f4\n  end\n  sum\nend", "  a, b, c, d = 0, 0, 2, 0\n  (n-2).times do |i|\n\
    \    a, b, c, d = b, c, d, a + b + c + d\n  end\n  a + b + c + d\nend", "  return\
    \ 0 if n <= 1\n  return 2 if n == 2\n  return 0 if n == 3\n  last_last_last_last,\
    \ last_last_last, last_last, last = 0, 0, 2, 0\n  (n - 3).times do\n    last_last_last_last,\
    \ last_last_last, last_last, last = last_last_last, last_last, last, last_last_last\
    \ + last_last + last_last_last + last\n  end\n  last_last_last + last_last + last_last_last\
    \ + last\nend", "  raise ArgumentError if n < 0\n  return 0 if n <= 1\n  return\
    \ 2 if n == 2\n  return 0 if n == 3\n  current = [0, 0, 2, 0]\n  (n - 3).times\
    \ do\n    first = current.shift\n    current << (first + current[0] + current[1]\
    \ + current[2])\n  end\n  current[-1]\nend", "  if n == 0\n    return 0\n  elsif\
    \ n == 1\n    return 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n    return\
    \ 0\n  else\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\n\
    end", "  # REPLACE ME\nend", "\nend", "  # TODO: implement me\nend", "  a, b,\
    \ c, d = 0, 0, 2, 0\n  return n if n < 3\n  3.upto(n) do |i|\n    e = a + b +\
    \ c + d\n    a, b, c, d = b, c, d, e\n  end\n  d\nend", "  raise \"n must be >=\
    \ 0\" if n < 0\n  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n ==\
    \ 2\n  return 0 if n == 3\n  a, b, c, d = 2, 0, 0, 0\n  (4..n).each do |i|\n \
    \   d = a + b + c\n    a, b, c = d, a, b\n  end\n  d\nend", "  return 0 if n ==\
    \ 0 || n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  fib4 = [0, 0, 2,\
    \ 0]\n  (4..n).each do |i|\n    fib4[i % 4] = fib4[(i-1) % 4] + fib4[(i-2) % 4]\
    \ + fib4[(i-3) % 4] + fib4[(i-4) % 4]\n  end\n  fib4[n % 4]\nend", end, "  #TODO:\
    \ Implement me!\nend", "\tfib_list = []\n\tfib_list[0] = 0\n\tfib_list[1] = 0\n\
    \tfib_list[2] = 2\n\tfib_list[3] = 0\n\tif n < 4\n\t\treturn fib_list[n]\n\telse\n\
    \t\t(4..n).each do |i|\n\t\t\tfib_list[i] = fib_list[i-1] + fib_list[i-2] + fib_list[i-3]\
    \ + fib_list[i-4]\n\t\tend\n\tend\n\treturn fib_list[n]\nend", "\nend", "  dp\
    \ = []\n  0.upto(n) do |i|\n    if i == 0\n      dp[i] = 0\n    elsif i == 1\n\
    \      dp[i] = 0\n    elsif i == 2\n      dp[i] = 2\n    elsif i == 3\n      dp[i]\
    \ = 0\n    else\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3] + dp[i-4]\n    end\n\
    \  end\n  dp[n]\nend", "  if n <= 1\n    return 0\n  elsif n == 2\n    return\
    \ 2\n  elsif n == 3\n    return 0\n  end\n  n1 = 0\n  n2 = 0\n  n3 = 2\n  n4 =\
    \ 0\n  n5 = 0\n  for x in 4..n\n    n5 = n1 + n2 + n3 + n4\n    n1 = n2\n    n2\
    \ = n3\n    n3 = n4\n    n4 = n5\n  end\n  return n5\nend", "  n = n.to_i\n  return\
    \ n if n <= 1\n  i = 1\n  f0 = 0\n  f1 = 0\n  f2 = 2\n  f3 = 0\n  while i < n\n\
    \    f0 = f1\n    f1 = f2\n    f2 = f3\n    f3 = f0 + f1 + f2 + f3\n    i += 1\n\
    \  end\n  f3\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if\
    \ n == 2\n  return 0 if n == 3\n  result = [0, 0, 2, 0]\n  (4..n).each do |i|\n\
    \    result << result[-1] + result[-2] + result[-3] + result[-4]\n  end\n  result[-1]\n\
    end", "  # YOUR CODE HERE\nend", "  f1 = 0\n  f2 = 0\n  f3 = 2\n  f4 = 0\n  n.times\
    \ do |i|\n    if i <= 2\n      f4 = 2\n    else\n      f4 = f1 + f2 + f3 + f4\n\
    \      f1 = f2\n      f2 = f3\n      f3 = f4\n    end\n  end\n  f4\nend", "  \
    \  return 0 if n == 0\n    return 0 if n == 1\n    return 2 if n == 2\n    return\
    \ 0 if n == 3\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend",
  "\nend", "    n == 0 ? 0 : n == 1 ? 0 : n == 2 ? 2 : n == 3 ? 0 : fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\nend", "    return 0 if n == 0\n    return 0 if n ==\
    \ 1\n    return 2 if n == 2\n    return 0 if n == 3\n    # fn[n] = fn[n-1] + fn[n-2]\
    \ + fn[n-3] + fn[n-4]\n    # a[n] = a[n-1] + a[n-2] + a[n-3] + a[n-4]\n    # \
    \      a[n-4] + a[n-3] + a[n-2] + a[n-1]\n    # a[n-4] a[n-3] a[n-2] a[n-1]\n\
    \    # a[n-3] a[n-2] a[n-1] a[n]\n    # a[n-2] a[n-1] a[n] a[n+1]\n    # a[n-1]\
    \ a[n] a[n+1] a[n+2]\n    # 0 0 2 0\n    # 0 2 0 4\n    # 2 0 4 8\n    # 0 4 8\
    \ 14\n    prev_a = 0\n    prev_b = 0\n    prev_c = 2\n    prev_d = 0\n    # prev_a\
    \ = a[n-4]\n    # prev_b = a[n-3]\n    # prev_c = a[n-2]\n    # prev_d = a[n-1]\n\
    \    current = 4\n    (4..n).each do |i|\n        current = prev_a + prev_b +\
    \ prev_c + prev_d\n        prev_a = prev_b\n        prev_b = prev_c\n        prev_c\
    \ = prev_d\n        prev_d = current\n    end\n    current\nend", "  fib4_series\
    \ = [0, 0, 2, 0]\n  return fib4_series[n] if n < 4\n  for i in 4..n\n    fib4_series\
    \ << fib4_series[i-1] + fib4_series[i-2] + fib4_series[i-3] + fib4_series[i-4]\n\
    \  end\n  fib4_series[n]\nend", "\t@fib4 ||= { 0 => 0, 1 => 0, 2 => 2, 3 => 0\
    \ }\n\treturn @fib4[n] if @fib4[n]\n\t4.upto(n) do |i|\n\t\t@fib4[i] = @fib4[i-1]\
    \ + @fib4[i-2] + @fib4[i-3] + @fib4[i-4]\n\tend\n\t@fib4[n]\nend", "  return n\
    \ if n < 2\n  fibs = [0,0,2,0]\n  (n-3).times do |i|\n    fibs << fibs[i] + fibs[i+1]\
    \ + fibs[i+2] + fibs[i+3]\n  end\n  fibs.last\nend", "    if n == 0\n        return\
    \ 0\n    elsif n == 1\n        return 0\n    elsif n == 2\n        return 2\n\
    \    elsif n == 3\n        return 0\n    else\n        return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n    end\nend", "  if n == 0 || n == 1\n    return 0\n\
    \  elsif n == 2\n    return 2\n  elsif n == 3\n    return 0\n  end\n  a = 0\n\
    \  b = 0\n  c = 2\n  d = 0\n  count = 4\n  while count <= n\n    a = b\n    b\
    \ = c\n    c = d\n    d = a + b + c\n    count += 1\n  end\n  return d\nend",
  "\nend", "  # To be written\nend", "  arr = [0, 0, 2, 0]\n  (4..n).each do |i|\n\
    \    arr[i % 4] = arr[(i - 1) % 4] + arr[(i - 2) % 4] + arr[(i - 3) % 4] + arr[(i\
    \ - 4) % 4]\n  end\n  arr[n % 4]\nend", "  # TODO\nend", "  return 0 if n == 0\n\
    \  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  return fib4(n-1)\
    \ + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  fib = [0, 0, 2, 0]\n  if n <=\
    \ 3\n    return fib[n]\n  end\n  (4..n).each do |i|\n    fib[i % 4] = fib[(i -\
    \ 1) % 4] + fib[(i - 2) % 4] + fib[(i - 3) % 4] + fib[(i - 4) % 4]\n  end\n  fib[n\
    \ % 4]\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n ==\
    \ 2\n  return 0 if n == 3\n  a = 0\n  b = 0\n  c = 2\n  d = 0\n  (n-4).times do\n\
    \    a, b, c, d = b, c, d, a + b + c + d\n  end\n  d\nend", "\treturn 0 if n ==\
    \ 0 || n == 1\n\treturn 2 if n == 2\n\treturn 0 if n == 3\n\tprev_four = [0, 0,\
    \ 2, 0]\n\ti = 4\n\twhile i <= n\n\t\tx = prev_four[3] + prev_four[2] + prev_four[1]\
    \ + prev_four[0]\n\t\tprev_four[0] = prev_four[1]\n\t\tprev_four[1] = prev_four[2]\n\
    \t\tprev_four[2] = prev_four[3]\n\t\tprev_four[3] = x\n\t\ti += 1\n\tend\n\tprev_four[3]\n\
    end", "  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return\
    \ 0 if n == 3\n  fib4_sequence = [0, 0, 2, 0]\n  4.upto(n) do |i|\n    fib4_sequence\
    \ << fib4_sequence[i-1] + fib4_sequence[i-2] + fib4_sequence[i-3] + fib4_sequence[i-4]\n\
    \  end\n  fib4_sequence[n]\nend", "  a = 0\n  b = 0\n  c = 2\n  d = 0\n  if n\
    \ <= 2\n    return n\n  else\n    (n-3).times do\n      d = a + b + c\n      a\
    \ = b\n      b = c\n      c = d\n    end\n    return d\n  end\nend", "\nend",
  "  a, b, c, d = 0, 0, 2, 0\n  3.upto(n) do\n    a, b, c, d = b, c, d, a + b + c\
    \ + d\n  end\n  return d\nend", "  if n == 0\n    return 0\n  elsif n == 1\n \
    \   return 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n    return 0\n  else\n\
    \    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n  end\nend", '  raise
    RangeError if n <= 0', "  # Your code here\nend", "  # this is a more efficient\
    \ implementation\n  # because it only stores the last 4 elements\n  # of the fib4\
    \ sequence.  Compare this to the\n  # implementation of fib4_less_efficient which\n\
    \  # stores the entire fib4 sequence up to the nth element\n  #\n  # this solution\
    \ would be optimal if we stored\n  # just the last 4 elements of the fib4 sequence\n\
    \  # within an array\n  f4s = [0, 0, 2, 0]\n  if n < 4\n    return f4s[n]\n  end\n\
    \  (4..n).each do |i|\n    f4s[3] = f4s[2] + f4s[1] + f4s[0] + f4s[3]\n    f4s[0]\
    \ = f4s[1]\n    f4s[1] = f4s[2]\n    f4s[2] = f4s[3]\n  end\n  f4s[3]\nend", " \
    \ 0\nend", "\tif n==0\n\t\treturn 0\n\telsif n==1\n\t\treturn 0\n\telsif n==2\n\
    \t\treturn 2\n\telsif n==3\n\t\treturn 0\n\telse\n\t\ta=0\n\t\tb=0\n\t\tc=2\n\t\
    \td=0\n\t\tn.times do |i|\n\t\t\ta=b\n\t\t\tb=c\n\t\t\tc=d\n\t\t\td=a+b+c\n\t\t\
    end\n\t\treturn d\n\tend\nend", "  fib4_results = [0, 0, 2, 0]\n  return fib4_results[n]\
    \ if n < 4\n  (4..n).each do |x|\n    fib4_results[x] = fib4_results[x-1] + fib4_results[x-2]\
    \ + fib4_results[x-3] + fib4_results[x-4]\n  end\n  fib4_results[n]\nend", "\n\
    end", "  a = 0\n  b = 0\n  c = 2\n  d = 0\n  return d if n == 0\n  return a if\
    \ n == 1\n  return b if n == 2\n  return c if n == 3\n  i = 4\n  while i <= n\n\
    \    d = a + b + c + d\n    a = b\n    b = c\n    c = d\n    i += 1\n  end\n \
    \ d\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n\
    \  return 0 if n == 3\n  i = 4\n  first = 0\n  second = 0\n  third = 2\n  fourth\
    \ = 0\n  fib4 = 0\n  until i == n\n    fib4 = first + second + third + fourth\n\
    \    first = second\n    second = third\n    third = fourth\n    fourth = fib4\n\
    \    i += 1\n  end\n  fib4\nend", "  return 0 if n == 0\n  return 0 if n == 1\n\
    \  return 2 if n == 2\n  return 0 if n == 3\n  s, s2, s3, s4 = 0, 0, 2, 0\n  n.times\
    \ do |n|\n    s, s2, s3, s4 = s2, s3, s4, s+s2+s3+s4\n  end\n  s\nend", "\nend",
  "\nend", end, "\tf1, f2, f3, f4 = 0, 0, 2, 0", "  fib_numbers = []\n  n.times do\
    \ |num|\n    fib_numbers << fib4_helper(num)\n  end\n  fib_numbers[n]\nend", " \
    \ a, b, c, d = 0, 0, 2, 0\n  (n-3).times do\n    a, b, c, d = b, c, d, a+b+c+d\n\
    \  end\n  d\nend", "  f0 = 0\n  f1 = 0\n  f2 = 2\n  f3 = 0\n  curr = 0\n  (n-3).times\
    \ do |i|\n    curr = f0 + f1 + f2 + f3\n    f0 = f1\n    f1 = f2\n    f2 = f3\n\
    \    f3 = curr\n  end\n  curr\nend", "  first = 0\n  second = 0\n  third = 2\n\
    \  fourth = 0\n  if n == 0\n    return first\n  elsif n == 1\n    return second\n\
    \  elsif n == 2\n    return third\n  else\n    (n-3).times do\n      first = second\n\
    \      second = third\n      third = fourth\n      fourth = first + second + third\
    \ + fourth\n    end\n    return fourth\n  end\nend", "\t\nend", "  arr = [0, 0,\
    \ 2, 0]\n  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return\
    \ 0 if n == 3\n  (n-3).times do\n    arr[3] = arr[0] + arr[1] + arr[2] + arr[3]\n\
    \    arr.shift\n  end\n  arr[3]\nend", "  if n == 0\n    return 0\n  elsif n ==\
    \ 1\n    return 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n    return 0\n\
    \  end\n  seq = [0, 0, 2, 0]\n  i = 4\n  while i <= n\n    new_term = seq[i-1]\
    \ + seq[i-2] + seq[i-3] + seq[i-4]\n    seq << new_term\n    i += 1\n  end\n \
    \ return seq[n]\nend", "  if n < 3\n    fib4_arr = [0, 0, 2]\n  else\n    fib4_arr\
    \ = [0, 0, 2, 0]\n    (4..n).each do |i|\n      fib4_arr[i % 4] = fib4_arr[(i\
    \ - 1) % 4] + fib4_arr[(i - 2) % 4] + fib4_arr[(i - 3) % 4] + fib4_arr[(i - 4)\
    \ % 4]\n    end\n  end\n  fib4_arr[n % 4]\nend", end, "  f_1 = 0\n  f_2 = 0\n\
    \  f_3 = 2\n  f_4 = 0\n  (n-3).times do\n    result = f_1 + f_2 + f_3 + f_4\n\
    \    f_1 = f_2\n    f_2 = f_3\n    f_3 = f_4\n    f_4 = result\n  end\n  f_1 +\
    \ f_2 + f_3 + f_4\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return\
    \ 2 if n == 2\n  return 0 if n == 3\n  n1 = 0\n  n2 = 0\n  n3 = 2\n  n4 = 0\n\
    \  sum = 2\n  n.times do\n    n1 = n2\n    n2 = n3\n    n3 = n4\n    n4 = sum\n\
    \    sum = n1 + n2 + n3 + n4\n  end\n  sum\nend", "  return 0 if n <= 1\n  return\
    \ 2 if n == 2\n  a = [0, 0, 2, 0]\n  for i in 4..n\n    a[i%4] = a[(i-1)%4] +\
    \ a[(i-2)%4] + a[(i-3)%4] + a[(i-4)%4]\n  end\n  a[n%4]\nend", "\nend", "\nend",
  "  if n == 0 || n == 1\n    return 0\n  elsif n == 2\n    return 2\n  elsif n ==\
    \ 3\n    return 0\n  end\n  x = 0\n  y = 0\n  z = 2\n  a = 0\n  i = 4\n  until\
    \ i == n do\n    temp = x + y + z + a\n    x = y\n    y = z\n    z = a\n    a\
    \ = temp\n    i += 1\n  end\n  a\nend", "\treturn 0 if n <= 1\n\treturn 2 if n\
    \ == 2\n\treturn 0 if n == 3\n\t\n\tfib_minus_1 = 2\n\tfib_minus_2 = 0\n\tfib_minus_3\
    \ = 0\n\tfib_minus_4 = 0\n\t\n\t(n-3).times do\n\t\tfib_minus_4 = fib_minus_3\n\
    \t\tfib_minus_3 = fib_minus_2\n\t\tfib_minus_2 = fib_minus_1\n\t\tfib_minus_1\
    \ = fib_minus_1 + fib_minus_2 + fib_minus_3 + fib_minus_4\n\tend\n\t\n\tfib_minus_1\n\
    end", "  a = [0, 0, 2, 0]\n  return a[n] if a[n]\n  (n-4).times do |i|\n    a\
    \ << a[i] + a[i+1] + a[i+2] + a[i+3]\n  end\n  a[n]\nend", "  # In this problem,\
    \ we are using recursion which is not practical\n  if n == 0\n    return 0\n \
    \ elsif n == 1\n    return 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n \
    \   return 0\n  else\n    return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\n\
    \  end\nend", "\tn = n-1\n\ta = 0\n\tb = 0\n\tc = 2\n\td = 0\n\te = 0\n\twhile\
    \ n > 0 do\n\t\te = d\n\t\td = c\n\t\tc = b\n\t\tb = a\n\t\ta = d + c + b + e\n\
    \t\tn = n - 1\n\tend\n\treturn a\nend", "\tif n == 0\n\t\treturn 0\n\telsif n\
    \ == 1\n\t\treturn 0\n\telsif n == 2\n\t\treturn 2\n\telsif n == 3\n\t\treturn\
    \ 0\n\tend\n\ta, b, c, d = 0, 0, 2, 0\n\tfor i in 4..n\n\t\te = a + b + c + d\n\
    \t\ta = b\n\t\tb = c\n\t\tc = d\n\t\td = e\n\tend\n\treturn e\nend", "  numbers\
    \ = [0, 0, 2, 0]\n  if n < 4\n    return numbers[n]\n  end\n  (n - 3).times do\n\
    \    numbers.shift\n    numbers << numbers.inject(:+)\n  end\n  numbers.last\n\
    end", "  if n == 0\n    return 0\n  elsif n == 1\n    return 0\n  elsif n == 2\n\
    \    return 2\n  elsif n == 3\n    return 0\n  else\n    return fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n  end\nend", "  raise \"Implement me!\"\nend", "\t\
    if n == 0\n\t\treturn 0\n\telsif n == 1\n\t\treturn 0\n\telsif n == 2\n\t\treturn\
    \ 2\n\telsif n == 3\n\t\treturn 0\n\tend\n\t\n\tif n < 0\n\t\tputs \"Invalid input\"\
    \n\t\treturn\n\tend\n\t\n\tf4_1 = 2\n\tf4_2 = 0\n\tf4_3 = 0\n\tf4_4 = 0\n\tfor\
    \ i in 4..n\n\t\tf4_1, f4_2, f4_3, f4_4 = f4_1 + f4_2 + f4_3 + f4_4, f4_1, f4_2,\
    \ f4_3\n\tend\n\treturn f4_1\nend", end, "    if n == 0\n        return 0\n  \
    \  elsif n == 1\n        return 0\n    elsif n == 2\n        return 2\n    elsif\
    \ n == 3\n        return 0\n    else\n        return fib4(n-1) + fib4(n-2) + fib4(n-3)\
    \ + fib4(n-4)\n    end\nend\nputs fib4(6)", "  list = [0, 0, 2, 0]\n  (4..n).each\
    \ do |index|\n    list << list[index-1] + list[index-2] + list[index-3] + list[index-4]\n\
    \  end\n  list[n]\nend", "  n == 0 ? 0 : n == 1 ? 0 : n == 2 ? 2 : n == 3 ? 0\
    \ : fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  assert_equal_types(n,\
    \ Integer)\n  raise ArgumentError if n < 0\n  raise ArgumentError if n == 1",
  end, "    return 0 if n == 0\n    return 0 if n == 1\n    return 2 if n == 2\n \
    \   return 0 if n == 3\n    fib4_seq = [0, 0, 2, 0]\n    (4..n).each do |i|\n\
    \        fib4_seq << fib4_seq[i-1] + fib4_seq[i-2] + fib4_seq[i-3] + fib4_seq[i-4]\n\
    \    end\n    fib4_seq[n]\nend", "\ti = 0\n\tj = 0\n\tk = 2\n\tl = 0\n\t\n\tif\
    \ n == 0\n\t\treturn 0\n\telsif n == 1\n\t\treturn 0\n\telsif n == 2\n\t\treturn\
    \ 2\n\telsif n == 3\n\t\treturn 0\n\telse\n\t\t(n-3).times do\n\t\t\ti = j\n\t\
    \t\tj = k\n\t\t\tk = l\n\t\t\tl = i + j + k\n\t\tend\n\t\treturn l\n\tend\nend",
  "  # using memoization\n  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if\
    \ n == 2\n  return 0 if n == 3\n  fib4_arr = [0, 0, 2, 0]\n  4.upto(n) do |i|\n\
    \    fib4_arr[i] = fib4_arr[i-1] + fib4_arr[i-2] + fib4_arr[i-3] + fib4_arr[i-4]\n\
    \  end\n  fib4_arr[n]\nend", "  if n <= 3\n    n\n  else\n    fib4(n-1) + fib4(n-2)\
    \ + fib4(n-3) + fib4(n-4)\n  end\nend", "  # your code here\nend", "\tif n ==\
    \ 0\n\t\treturn 0\n\telsif n == 1\n\t\treturn 0\n\telsif n == 2\n\t\treturn 2\n\
    \telsif n == 3\n\t\treturn 0\n\telse\n\t\tseq = [0, 0, 2, 0]\n\t\t(n-3).times\
    \ do\n\t\t\tseq.push(seq[-1] + seq[-2] + seq[-3] + seq[-4])\n\t\t\tseq.shift\n\
    \t\tend\n\t\treturn seq[-1]\n\tend\nend", end, "  if n < 2\n    return 0\n  elsif\
    \ n == 2\n    return 2\n  else\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n \
    \   (n-3).times do\n      d = a + b + c\n      a = b\n      b = c\n      c = d\n\
    \    end\n    return d\n  end\nend", "  return 0 if n < 2\n  return 2 if n ==\
    \ 2\n  return 0 if n == 3\n  x = 0\n  y = 0\n  z = 2\n  a = 0\n  4.upto(n) do\
    \ |i|\n    x = y\n    y = z\n    z = a\n    a = x + y + z + a\n  end\n  a\nend",
  "  fn1 = 0\n  fn2 = 0\n  fn3 = 2\n  fn4 = 0\n  if n < 2\n    fn1\n  elsif n == 2\n\
    \    fn3\n  else\n    (n-2).times do\n      fn4 = fn1 + fn2 + fn3 + fn4\n    \
    \  fn1 = fn2\n      fn2 = fn3\n      fn3 = fn4\n    end\n    fn4\n  end\nend",
  "  # YOUR CODE HERE\nend", "  return 0 if n == 0\n  return 0 if n == 1\n  return\
    \ 2 if n == 2\n  return 0 if n == 3\n  n_1 = 0\n  n_2 = 0\n  n_3 = 2\n  n_4 =\
    \ 0\n  result = 0\n  (4..n).each do |num|\n    result = n_1 + n_2 + n_3 + n_4\n\
    \    n_1 = n_2\n    n_2 = n_3\n    n_3 = n_4\n    n_4 = result\n  end\n  result\n\
    end", "  n<=2 ? n : fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  return\
    \ 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if n ==\
    \ 3\n  a = 0\n  b = 0\n  c = 2\n  d = 0\n  (n-4).times do\n    temp = a + b +\
    \ c + d\n    a = b\n    b = c\n    c = d\n    d = temp\n  end\n  a + b + c + d\n\
    end", "  ary = [0, 0, 2, 0]\n  return ary[n] if n < 4\n  while n > 3\n    sum\
    \ = ary.inject(:+)\n    ary.shift\n    ary << sum\n    n -= 1\n  end\n  ary.last\n\
    end", "  return 0 if n == 0\n  return 0 if n == 1\n  return 2 if n == 2\n  return\
    \ 0 if n == 3\n  fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "  return\
    \ 0 if n == 0 || n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  return\
    \ fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\nend", "    first = 0\n    second\
    \ = 0\n    third = 2\n    fourth = 0\n    if n == 0 || n == 1\n        return\
    \ first\n    elsif n == 2\n        return second\n    elsif n == 3\n        return\
    \ third\n    end\n    (n-3).times do\n        first = second\n        second =\
    \ third\n        third = fourth\n        fourth = first + second + third + fourth\n\
    \    end\n    return fourth\nend", "  return 0 if n == 0\n  return 0 if n == 1\n\
    \  return 2 if n == 2\n  return 0 if n == 3\n  return fib4(n-1) + fib4(n-2) +\
    \ fib4(n-3) + fib4(n-4)\nend", "  return 0 if n == 0 || n == 1\n  return 2 if\
    \ n == 2\n  return 0 if n == 3\n  first, second, third, fourth = 0, 0, 2, 0\n\
    \  (n - 4).times do\n    first, second, third, fourth = second, third, fourth,\
    \ first + second + third + fourth\n  end\n  fourth\nend", "    nth_num = 0\n \
    \   nth_minus_one = 0\n    nth_minus_two = 0\n    nth_minus_three = 0\n    nth_minus_four\
    \ = 0\n    i = 1\n    while i <= n\n        if i == 1\n            nth_num = 0\n\
    \        elsif i == 2\n            nth_num = 0\n        elsif i == 3\n       \
    \     nth_num = 2\n        else\n            nth_num = nth_minus_one + nth_minus_two\
    \ + nth_minus_three + nth_minus_four\n        end\n        nth_minus_four = nth_minus_three\n\
    \        nth_minus_three = nth_minus_two\n        nth_minus_two = nth_minus_one\n\
    \        nth_minus_one = nth_num\n        i += 1\n    end\n    return nth_num\n\
    end", "  return 0 if n == 0 || n == 1\n  return 2 if n == 2\n  return 0 if n ==\
    \ 3\n  a, b, c, d = 0, 0, 2, 0\n  (n - 4).times do\n    temp = d\n    d = a +\
    \ b + c + d\n    a = b\n    b = c\n    c = temp\n  end\n  d\nend", end, "  # your\
    \ code here\nend", "\tfib_last_4 = [0, 0, 2, 0]\n\tn.times do\n\t\tfib_last_4\
    \ = [fib_last_4[1], fib_last_4[2], fib_last_4[3], fib_last_4[0] + fib_last_4[1]\
    \ + fib_last_4[2] + fib_last_4[3]]\n\tend\n\tfib_last_4[3]\nend", "  return 0\
    \ if n == 0 || n == 1\n  return 2 if n == 2\n  return 0 if n == 3\n  count = 4\n\
    \  seq = [0, 0, 2, 0]\n  (n - 3).times do\n    seq.push(seq[count - 1] + seq[count\
    \ - 2] + seq[count - 3] + seq[count - 4])\n    count += 1\n  end\n  seq[-1]\n\
    end", "  # TODO\nend", "  if n == 0\n    return 0\n  elsif n == 1\n    return\
    \ 0\n  elsif n == 2\n    return 2\n  elsif n == 3\n    return 0\n  else\n    n1\
    \ = 0\n    n2 = 0\n    n3 = 2\n    n4 = 0\n    i = 3\n    while i < n\n      n1\
    \ = n2\n      n2 = n3\n      n3 = n4\n      n4 = n1 + n2 + n3 + n4\n      i +=\
    \ 1\n    end\n    return n4\n  end\nend", "  # YOUR CODE HERE\nend", "  fib4_series\
    \ = [0, 0, 2, 0]\n  (4..n).each do |i|\n    fib4_series << fib4_series[i-1] +\
    \ fib4_series[i-2] + fib4_series[i-3] + fib4_series[i-4]\n  end\n  fib4_series[n]\n\
    end", "    a, b, c, d = 0, 0, 2, 0\n    if n > 3\n        (n-3).times do\n   \
    \         d = a + b + c + d\n            a = b\n            b = c\n          \
    \  c = d\n        end\n    end\n    d\nend", "  # Write your code here.\nend",
  "  return 0 if n < 1\n  return 0 if n == 1\n  return 2 if n == 2\n  return 0 if\
    \ n == 3\n  a, b, c, d = 0, 0, 2, 0\n  (n-4).times do\n    a, b, c, d = b, c,\
    \ d, (a + b + c + d)\n  end\n  d\nend", "  if n < 2\n    return 0\n  elsif n ==\
    \ 2\n    return 2\n  else\n    a = 0\n    b = 0\n    c = 2\n    d = 0\n    for\
    \ i in 3..n\n      d = a + b + c\n      a = b\n      b = c\n      c = d\n    end\n\
    \    return d\n  end\nend", "    if n < 2\n        return n\n    end\n    a, b,\
    \ c, d = 0, 0, 2, 0\n    result = 1\n    i = 2\n    while i < n\n        result\
    \ = a + b + c + d\n        a = b\n        b = c\n        c = d\n        d = result\n\
    \        i += 1\n    end\n    return result\nend", "  n1 = 0\n  n2 = 0\n  n3 =\
    \ 2\n  n4 = 0\n  n5 = 0\n  if n <= 2\n    return n2\n  end\n  (n-3).times do |x|\n\
    \    n5 = n1 + n2 + n3 + n4\n    n1 = n2\n    n2 = n3\n    n3 = n4\n    n4 = n5\n\
    \  end\n  return n5\nend", "  return 0 if n == 0 || n == 1\n  return 2 if n ==\
    \ 2\n  return 0 if n == 3\n  fib_prev = 0\n  fib_prev_prev = 0\n  fib_prev_prev_prev\
    \ = 0\n  fib_prev_prev_prev_prev = 0\n  curr_fib = 0\n  (4..n).each do |i|\n \
    \   curr_fib = fib_prev + fib_prev_prev + fib_prev_prev_prev + fib_prev_prev_prev_prev\n\
    \    fib_prev_prev_prev_prev = fib_prev_prev_prev\n    fib_prev_prev_prev = fib_prev_prev\n\
    \    fib_prev_prev = fib_prev\n    fib_prev = curr_fib\n  end\n  curr_fib\nend",
  "  x = 0\n  y = 0\n  z = 2\n  w = 0\n  3.upto(n) do\n    temp = x\n    x = y\n \
    \   y = z\n    z = w + y + z + temp\n    w = temp\n  end\n  z\nend", "  # TODO:\
    \ implement me.\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
