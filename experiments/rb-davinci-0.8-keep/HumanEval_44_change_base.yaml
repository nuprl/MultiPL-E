name: HumanEval_44_change_base
language: rb
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\n# >>> change_base(8,\
  \ 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'\n\
  def change_base(x, base)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_change_base\n\
  \    candidate = method(:change_base)\n    assert_equal(\"22\", candidate.call(8,\
  \ 3))\n    assert_equal(\"100\", candidate.call(9, 3))\n    assert_equal(\"11101010\"\
  , candidate.call(234, 2))\n    assert_equal(\"10000\", candidate.call(16, 2))\n\
  \    assert_equal(\"1000\", candidate.call(8, 2))\n    assert_equal(\"111\", candidate.call(7,\
  \ 2))\n    assert_equal(\"2\", candidate.call(2, 3))\n    assert_equal(\"3\", candidate.call(3,\
  \ 4))\n    assert_equal(\"4\", candidate.call(4, 5))\n    assert_equal(\"5\", candidate.call(5,\
  \ 6))\n    assert_equal(\"6\", candidate.call(6, 7))\n    assert_equal(\"7\", candidate.call(7,\
  \ 8))\n  end\nend\n"
completions: ["    x > 0 ? change_base(x / base, base) + (x % base).to_s : ''\nend",
  "  # your code here\nend", "    result = []\n    while x > 0\n        remainder\
    \ = x % base\n        result.unshift(remainder)\n        x = x / base\n    end\n\
    \    result.join(\"\")\nend", "  # your code here\n  return x.to_s if base ==\
    \ 10", "  raise unless base < 10\n  return '0' if x == 0\n  (x / base).zero? ?\
    \ x.to_s : change_base(x / base, base) + (x % base).to_s\nend", "  r = \"\"\n\
    \  while (x > 0)\n    r += (x % base).to_s\n    x /= base\n  end\n  r.reverse\n\
    end", "    if x < base\n        return x.to_s\n    else\n        return change_base(x\
    \ / base, base) + (x % base).to_s\n    end\nend", "  x.to_s(base)\nend", "  a=x/base\n\
    \  b=x%base\n  c=b.to_s\n  if a==0\n    return c\n  else\n    return change_base(a,base)+c\n\
    \  end\nend", "  if x < base\n    x.to_s\n  else\n    change_base(x / base, base)\
    \ + (x % base).to_s\n  end\nend", "  # your code here\n  return \"0\" if x ==\
    \ 0\n  return x.to_s if base == 10\n  res = \"\"\n  while x > 0\n    res = (x\
    \ % base).to_s + res\n    x /= base\n  end\n  res\nend", "\tres = ''\n\twhile\
    \ x > 0\n\t\tres += (x % base).to_s\n\t\tx /= base\n\tend\n\tres.reverse\nend",
  "  if x < base\n    return x.to_s\n  else\n    return change_base(x / base, base)\
    \ + (x % base).to_s\n  end\nend", "  # Fill in your code here.\nend", end, " \
    \ if base <= 10\n    (base ** x).to_s(base)\n  else\n    \"base number greater\
    \ than 10 not supported\"\n  end\nend", "    x.to_s(base)\nend", "  output = \"\
    \"\n  while x > 0\n    output = (x % base).to_s + output\n    x = x / base\n \
    \ end\n  output\nend", "  if x < base\n    return x.to_s\n  else\n    return change_base(x\
    \ / base, base) + (x % base).to_s\n  end\nend", "  base_array = (0..base-1).to_a\n\
    \  new_base_array = base_array.map{|x| x.to_s}\n  new_base_array.reverse!\n  base_string\
    \ = new_base_array.join", '  raise "Unsupported base" if base > 10', "  x = x.to_s.split('')\n\
    \  y = []\n  while x.length != 0\n    y.unshift(x.pop.to_i % base)\n    x = (x.map!{|i|\
    \ i.to_i / base}).to_s.split('')\n  end\n  y.join('')\nend", "  str = \"\"\n \
    \ while x != 0\n    reminder = x % base\n    x = x / base\n    str = \"#{reminder}\"\
    \ + str\n  end\n  str\nend", "  # convert number to string in base 10\n  x = x.to_s\n\
    \  # initialize string result\n  result = \"\"\n  # initialize index i\n  i =\
    \ 0\n  # initialize string input number in base 10\n  number = \"\"\n  # convert\
    \ string to number in base 10\n  while i < x.length\n    number = number + (x[i].to_i\
    \ * 10**(x.length - i - 1)).to_s\n    i += 1\n  end\n  number = number.to_i\n\
    \  # while the input number is not equal to 0\n  while number != 0\n    # add\
    \ the remainder of the input number divided by the base to the result string\n\
    \    result = result + (number % base).to_s\n    # divide the input number by\
    \ the base\n    number = number / base\n  end\n  # reverse the result string and\
    \ return it\n  return result.reverse\nend", "  # in case we have to use the following\n\
    \  # (2*base)**i\n  raise ArgumentError, \"Base should be less than 10\" if base\
    \ > 10\n  raise ArgumentError, \"Base should be greater than 1\" if base < 1",
  "  # base is less than 10\n  return 'Error' if base > 10", "  string_representation\
    \ = \"\"\n  return \"0\" if x == 0\n  while x != 0\n    remainder = x % base\n\
    \    x = x / base\n    string_representation = remainder.to_s + string_representation\n\
    \  end\n  string_representation\nend", "  return \"0\" if x == 0\n  return \"\
    1\" if x == 1\n  res = []\n  while x > 0\n    res << x % base\n    x /= base\n\
    \  end\n  res.reverse.join(\"\")\nend", "  # TODO\nend", "  raise \"The argument\
    \ 'base' must be less than 10.\" if base >= 10\n  return x.to_s if base == 10\n\
    \  return \"\" if x == 0\n  return change_base(x / base, base) + (x % base).to_s\n\
    end", "  out = ''\n  pow = 0\n  until x < base ** pow\n    pow += 1\n  end\n \
    \ pow -= 1\n  until pow < 0\n    digit = x / (base ** pow)\n    x -= digit * (base\
    \ ** pow)\n    out += digit.to_s\n    pow -= 1\n  end\n  out\nend", "  #fill here\n\
    \  # 0 => '0'\n  # 1 => '1'\n  # 2 => '2'\n  # 3 => '3'\n  # 4 => '4'\n  # 5 =>\
    \ '5'\n  # 6 => '6'\n  # 7 => '7'\n  # 8 => '8'\n  # 9 => '9'\n  # 10 => 'A'\n\
    \  # 11 => 'B'\n  # 12 => 'C'\n  # 13 => 'D'\n  # 14 => 'E'\n  # 15 => 'F'\n \
    \ # 16 => 'G'\n  # 17 => 'H'\n  # 18 => 'I'\n  # 19 => 'J'\n  # 20 => 'K'\n  #\
    \ 21 => 'L'\n  # 22 => 'M'\n  # 23 => 'N'\n  # 24 => 'O'\n  # 25 => 'P'\n  # 26\
    \ => 'Q'\n  # 27 => 'R'\n  # 28 => 'S'\n  # 29 => 'T'\n  # 30 => 'U'\n  # 31 =>\
    \ 'V'\n  # 32 => 'W'\n  # 33 => 'X'\n  # 34 => 'Y'\n  # 35 => 'Z'\n  # 36 => 'a'\n\
    \  # 37 => 'b'\n  # 38 => 'c'\n  # 39 => 'd'\n  # 40 => 'e'\n  # 41 => 'f'\n \
    \ # 42 => 'g'\n  # 43 => 'h'\n  # 44 => 'i'\n  # 45 => 'j'\n  # 46 => 'k'\n  #\
    \ 47 => 'l'\n  # 48 => 'm'\n  # 49 => 'n'\n  # 50 => 'o'\n  # 51 => 'p'\n  # 52\
    \ => 'q'\n  # 53 => 'r'\n  # 54 => 's'\n  # 55 => 't'\n  # 56 => 'u'\n  # 57 =>\
    \ 'v'\n  # 58 => 'w'\n  # 59 => 'x'\n  # 60 => 'y'\n  # 61 => 'z'\nend", "   \
    \ if base < 2 || base > 10\n        return nil\n    end\n    x_str = ''\n    if\
    \ x == 0\n        return '0'\n    end\n    while x > 0\n        x_str = (x % base).to_s\
    \ + x_str\n        x = x / base\n    end\n    return x_str\nend", "  #your code\
    \ here\nend", "\tif x / base == 0\n\t\treturn x.to_s\n\telse\n\t\treturn change_base(x\
    \ / base, base) + (x % base).to_s\n\tend\nend", "  # Fill here!\n  result = []\n\
    \  while x > 0\n    result << x % base\n    x /= base\n  end\n  result.reverse.join\n\
    end", "  return '' if x == 0\n  change_base(x / base, base) + (x % base).to_s\n\
    end", "    quotient = x\n    remainder = x\n    array = Array.new\n    remainder\
    \ = quotient % base\n    quotient = quotient / base\n    array.push(remainder)\n\
    \    until quotient == 0\n        remainder = quotient % base\n        quotient\
    \ = quotient / base\n        array.push(remainder)\n    end\n    string = array.join\n\
    \    return string\nend", "  # TODO\nend", "  while x > 0\n    n = x % base\n\
    \    x = x / base\n    return \"#{change_base(x, base)}#{n}\"\n  end\n  return\
    \ \"\"\nend", "\treturn \"You can't change to base 0!\" if base <= 0\n\treturn\
    \ \"0\" if x == 0\n\tresult = []\n\ttemp = x\n\twhile temp > 0\n\t\tresult.unshift(temp\
    \ % base)\n\t\ttemp = temp / base\n\tend\n\tresult.join\nend", "  nums = [0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9]\n  powers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  digits\
    \ = []\n  i = 0\n  until x == 0 do\n    digits << nums[x % base ** powers[i]]\n\
    \    x = x / base ** powers[i]\n    i += 1\n  end\n  digits.reverse.join\nend",
  "  #raise NotImplementedError\n  ans = \"\"\n  if x == 0 \n    return \"0\"\n  end\n\
    \  while x > 0\n    ans = (x % base).to_s + ans\n    x = x / base\n  end\n  return\
    \ ans\nend", "  s = \"\"\n  while x != 0\n    s = (x % base).to_s + s\n    x /=\
    \ base\n  end\n  s\nend", "  # replace the line below with your code\n  return\
    \ nil\nend", "  if x < base\n    return x.to_s\n  else\n    return change_base(x\
    \ / base, base) + (x % base).to_s\n  end\nend", "    # BEGIN YOUR CODE\n    result\
    \ = []\n    while x > 0\n        result.unshift(x % base)\n        x /= base\n\
    \    end\n    result.join('')\n    # END YOUR CODE\nend", "  # your code here.\n\
    \  s = ''\n  while x > 0\n    s = \"#{x % base}\" + s\n    x /= base\n  end\n\
    \  s\nend", "  str = \"\"\n  if x == 0\n    return \"0\"\n  else\n    while x\
    \ != 0\n      str << (x % base).to_s\n      x /= base\n    end\n  end\n  str.reverse\n\
    end", "  raise 'base should be less than 10' if base > 10\n  raise 'base should\
    \ be greater than 1' if base < 1\n  n = x\n  result = []\n  while n > 0\n    n,\
    \ remainder = n.divmod(base)\n    result.push(remainder)\n  end\n  result.reverse.join('')\n\
    end", "  ret = ''\n  while x >= base\n    ret = x.modulo(base).to_s + ret\n  \
    \  x = x / base\n  end\n  ret = x.to_s + ret\nend", "  return '0' if x == 0\n\
    \  result = \"\"\n  while x > 0\n    remainder = x % base\n    x = x / base\n\
    \    result << remainder.to_s\n  end\n  result.reverse\nend", "  return x.to_s\
    \ if base < 2\n  answer = \"\"\n  while x > 0\n    answer = (x % base).to_s +\
    \ answer\n    x /= base\n  end\n  answer\nend", "  # TODO: implement this method\n\
    \  # \n  res = []\n  until x == 0\n    x, m = x.divmod(base)\n    res.unshift(m)\n\
    \  end\n  res.join\nend", "  return x.to_s if base == 10\n  return nil if x <\
    \ 0\n  return '0' if x == 0\n  digits = []\n  while x > 0\n    digits.unshift(x\
    \ % base)\n    x /= base\n  end\n  digits.join\nend", "  return '' if x.nil? ||\
    \ base.nil?\n  x_str = ''\n  #x_str << x % base\n  #x_str << change_base(x / base,\
    \ base)\n  while x != 0\n    x_str << x % base\n    x = x / base\n  end\n  x_str.reverse\n\
    end", "  output = \"\"\n  while x > 0\n    output.insert(0, (x % base).to_s)\n\
    \    x /= base\n  end\n  output\nend", "  return x.to_s if base == 10\n  s = \"\
    \"\n  while x > 0\n    s += (x % base).to_s\n    x /= base\n  end\n  s.reverse\n\
    end", "  if x < base\n    return x.to_s\n  else\n    change_base(x / base, base)\
    \ + (x % base).to_s\n  end\nend", "  # initialize empty string to store the digits\n\
    \  new_base = \"\"\n  # loop if the number is not zero\n  while x != 0\n    #\
    \ take the remainder\n    remainder = x % base\n    # add the remainder to the\
    \ string\n    new_base = remainder.to_s + new_base\n    # divide x by base\n \
    \   x = x / base\n  end\n  # return the string\n  new_base\nend", "  # TODO: Your\
    \ code here\nend", "  if x < base\n    x.to_s\n  else\n    change_base(x / base,\
    \ base) + (x % base).to_s\n  end\nend", '  return x.to_s if base == 10', "  ret\
    \ = \"\"\n  while x > 0\n    ret = (x % base).to_s + ret\n    x /= base\n  end\n\
    \  ret\nend", "  if x > base\n    return change_base(x / base, base) + (x % base).to_s\n\
    \  else\n    return x.to_s\n  end\nend", "  raise NotImplementedError\nend", " \
    \ return x.to_s if base == 10\n  return x.to_s(base) if base < 10\n  raise ArgumentError\
    \ if base > 36\n  raise ArgumentError if base < 2\n  # set up a lookup table for\
    \ bases greater than 10\n  table = {}\n  (10..36).each { |i| table[i] = i.to_s(36)\
    \ }\n  # get the representation in base 10 first\n  x = x.to_s(10)\n  # the digit_base\
    \ array is in the reverse order of the answer\n  digit_base = []\n  while x !=\
    \ '0'\n    digit_base.push((x.to_i % base).to_s)\n    x = (x.to_i / base).to_s\n\
    \  end\n  answer = ''\n  until digit_base.empty?\n    digit = digit_base.pop\n\
    \    answer += digit.to_i < 10 ? digit : table[digit.to_i]\n  end\n  answer\n\
    end", "  quotient = x\n  output = ''\n  while quotient > 0\n    remainder = quotient\
    \ % base\n    output += remainder.to_s\n    quotient = quotient / base\n  end\n\
    \  return output.reverse\nend", "  if base == 10\n    return x.to_s\n  elsif base\
    \ == 1\n    return \"0\"*x\n  else\n    res = \"\"\n    x = x.to_i\n    if x ==\
    \ 0\n      return \"0\"\n    end\n    while x != 0\n      res = (x % base).to_s\
    \ + res\n      x = x / base\n    end\n    return res\n  end\nend", "  res = []\n\
    \  while x > 0\n    r = x % base\n    res.unshift(r)\n    x = x / base\n  end\n\
    \  res.join\nend", "  if base == 0\n    return ''\n  end\n  digit = (x % base).to_s\n\
    \  return change_base(x / base, base) + digit\nend", "  raise \"numbers must be\
    \ less than 10\" if base > 10\n  quotient = x\n  binary = \"\"\n  while quotient\
    \ > 0\n    remainder = quotient % base\n    quotient = quotient / base\n    binary\
    \ << remainder.to_s\n  end\n  binary.reverse\nend", "  # your code here\nend",
  "  res = ''\n  if x == 0\n    return '0'\n  end\n  while x > 0\n    res = (x % base).to_s\
    \ + res\n    x = x / base\n  end\n  res\nend", "  a = \"\"\n  while x > 0\n  \
    \  r = x % base\n    a = r.to_s + a\n    x = x / base\n  end\n  a\nend", "  raise\
    \ NotImplementedError\nend", "  # complete this function\n  str = \"\"\n  while\
    \ x != 0\n    str = (x % base).to_s + str\n    x = x / base\n  end\n  return str\n\
    end", "    res=''\n    while x>0\n        res.insert(0,(x%base).to_s)\n      \
    \  x/=base\n    end\n    res\nend", "\tquotient = x\n\tres = \"\"\n\twhile quotient\
    \ != 0\n\t\tremainder = quotient % base\n\t\tquotient = quotient / base\n\t\t\
    res = res + remainder.to_s\n\tend\n\treturn res.reverse\nend", "    raise NotImplementedError\n\
    end", "  res = ''\n  while x > 0\n    res = (x % base).to_s + res\n    x /= base\n\
    \  end\n  res\nend", "  return '' if x == 0\n  x, remainder = x.divmod(base)\n\
    \  change_base(x, base) + remainder.to_s\nend", "  raise TypeError.new \"input\
    \ number must be an integer\" unless x.is_a? Integer\n  raise TypeError.new \"\
    base must be an integer\" unless base.is_a? Integer\n  raise TypeError.new \"\
    base must be greater than 1\" unless base > 1\n  raise TypeError.new \"base must\
    \ be less than 10\" unless base < 10\n  s = \"\"\n  while x > 0\n    s << (x %\
    \ base).to_s\n    x /= base\n  end\n  s.reverse\nend", "  # convert x to base\
    \ base.\n  # return string representation.\n  if x < 0\n    raise 'x must be non-negative.'\n\
    \  end\n  if base < 2\n    raise 'base must be greater than 1.'\n  end\n  if x\
    \ == 0\n    return '0'\n  end\n  result = ''\n  while x > 0\n    result = (x %\
    \ base).to_s + result\n    x /= base\n  end\n  result\nend", "  return '' if x\
    \ == 0\n  digits = '0123456789'\n  x, remainder = x.divmod(base)\n  digits[remainder]\
    \ + change_base(x, base)\nend", "  ret = ''\n  while x > 0\n    ret = (x % base).to_s\
    \ + ret\n    x /= base\n  end\n  ret\nend", "  s = ''\n  while x > 0\n    s =\
    \ x % base.to_s + s\n    x = x / base\n  end\n  s\nend", "  answer = \"\"\n  while\
    \ x > 0\n    answer = (x % base).to_s + answer\n    x = x / base\n  end\n  answer\n\
    end", "  # WRITE YOUR CODE HERE\nend", "  quotient = x / base\n  remainder = x\
    \ % base\n  if quotient == 0\n    remainder.to_s\n  else\n    change_base(quotient,\
    \ base) + remainder.to_s\n  end\nend", "  return '' if x == 0\n  change_base(x\
    \ / base, base) + (x % base).to_s\nend", "  raise \"base should be less than 10\"\
    \ if base > 10\n  output = []\n  while x > 0\n    n = x % base\n    x = x / base\n\
    \    output.unshift(n)\n  end\n  output.join\nend", "  return x.to_s if base ==\
    \ 10\n  digits = []\n  while x > 0\n    digits << x % base\n    x /= base\n  end\n\
    \  digits.reverse.join\nend", "  res = []\n  i = 0\n  while x > 0\n    res[i]\
    \ = x % base\n    x /= base\n    i += 1\n  end\n  res.reverse.join(\"\")\nend",
  "  # YOUR CODE HERE\n  output = \"\"\n  if x < base\n    return x.to_s\n  else\n\
    \    output += change_base(x/base, base)\n    output += (x%base).to_s\n  end\n\
    \  return output\nend", "  digits = []\n  while (x > 0)\n    digit = x % base\n\
    \    digits.unshift(digit)\n    x = x / base\n  end\n  digits.join\nend", "  r\
    \ = \"\"\n  while x > 0\n    n = x % base\n    r += n.to_s\n    x = x / base\n\
    \  end\n  return r.reverse\nend", "  raise 'base not supported' if base > 10\n\
    \  res = []\n  while x > 0\n    res << x % base\n    x /= base\n  end\n  res.reverse.join\n\
    end", "\tresult = []\n\tquotient = x\n\twhile quotient > 0\n\t\tremainder = quotient\
    \ % base\n\t\tquotient = quotient / base\n\t\tresult.unshift(remainder)\n\tend\n\
    \tresult.join()\nend", "  # base case\n  return '1' if x == 1\n  return '0' if\
    \ x == 0", "  if x == 0\n    return \"0\"\n  end\n  # enter your code here.\n\
    \  digits = []\n  while x > 0\n    #push the remainder from x / base into digits\n\
    \    digits.push(x % base)\n    #update x to be the quotient of the previous x\
    \ / base\n    x = x / base\n  end\n  #digits = digits.reverse\n  #joins the digits\
    \ array into a string.\n  return digits.join\nend", "  '11'\nend", "  quotient\
    \ = x\n  answer = \"\"\n  while quotient > 0\n    remainder = quotient % base\n\
    \    answer = remainder.to_s + answer\n    quotient = quotient / base\n  end\n\
    \  return answer\nend", "  raise ArgumentError, 'base should be less than 10'\
    \ if base > 10\n  raise ArgumentError, 'base should be greater than 1' if base\
    \ < 2\n  raise ArgumentError, 'input number must be positive' if x < 0", "   \
    \ ans = \"\"\n    while x > 0\n        ans = (x % base).to_s + ans\n        x\
    \ /= base\n    end\n    ans\nend", "  # if x < base\n  #   x.to_s\n  # else\n\
    \  #   change_base(x / base, base) + (x % base).to_s\n  # end\n  change_base_rec(x,\
    \ base, \"\")\nend", "  return x.to_s if base == 10\n  result = []\n  while x\
    \ > 0\n    result << x % base\n    x /= base\n  end\n  result.reverse.join(\"\"\
    )\nend", "  q = x.to_f\n  stack = []\n  loop do\n    q, r = q.divmod(base)\n \
    \   stack.push(r)\n    break if q == 0\n  end\n  stack.join\nend", "  if x < base\n\
    \    return x.to_s\n  else\n    return change_base(x / base, base) + (x % base).to_s\n\
    \  end\nend", "  # write here\n  base_array = []\n  while x > 0\n    result =\
    \ x % base\n    x = x / base\n    base_array.unshift(result)\n  end\n  base_array.join\n\
    end", "  str = \"\"\n  temp = x\n  while temp > 0\n    # get the last digit\n\
    \    digit = temp % base\n    # add to the string\n    str = str + digit.to_s\n\
    \    # get the remaining digits\n    temp = temp / base\n  end\n  str\nend", " \
    \ n = 1\n  y = 0\n  while x > 0\n    y += (x % base) * n\n    x /= base\n    n\
    \ *= 10\n  end\n  y.to_s\nend", "  # complete this function.\nend", "  x.to_s(base)\n\
    end", "  remainders = []\n  while x > 0\n    remainders << x % base\n    x /=\
    \ base\n  end\n  remainders.reverse.join\nend", "  return nil if x <= 0\n  return\
    \ '0' if x == 0\n  return '1' if x == 1\n  change_base(x / base, base) + (x %\
    \ base).to_s\nend", "  if x == 0\n    return ''\n  else\n    y = x % base\n  \
    \  change_base(x / base, base) + y.to_s\n  end\nend", "\treturn '0' if x.zero?\n\
    \t(x % base).to_s + change_base(x / base, base)\nend", "  return \"0\" if x ==\
    \ 0\n  binary = \"\"\n  while x != 0\n    binary = (x % base).to_s + binary\n\
    \    x /= base\n  end\n  binary\nend", "  x.to_s(base)\nend", "  res = \"\"\n\
    \  while x > 0\n    res += (x % base).to_s\n    x /= base\n  end\n  res.reverse\n\
    end", "\t# First, we need to find the quotient and remainder for number x,\n\t\
    # when it is divided by base.\n\tquotient = x / base\n\tremainder = x % base\n\
    \t# Then, combine the both to create a string representation of the base number.\n\
    \treturn quotient.to_s + remainder.to_s\nend", "  return \"\" if x == 0\n  change_base(x\
    \ / base, base) + (x % base).to_s\nend", "    # convert integer to string in base\n\
    \    # e.g. change_base(16, 2) ==> '10000'\n    # return string representation\n\
    \    # hint: use modulo operation\n    # e.g. change_base(16, 2) ==> '10000'\n\
    \    # => (16 % 2) + (16/2 % 2) + (16/4 % 2) + (16/8 % 2)", "  r = []\n  while\
    \ x > 0\n    r << x % base\n    x /= base\n  end\n  r.reverse.join\nend", "  raise\
    \ NotImplementedError\nend", "  return nil if x == 0\n  base_nums = %w(0 1 2 3\
    \ 4 5 6 7 8 9)\n  output = ''\n  while x > 0\n    output << base_nums[x % base]\n\
    \    x /= base\n  end\n  output.reverse\nend", "  return '' if x == 0\n  change_base(x\
    \ / base, base) + x.to_s[-1]\nend", "  raise NotImplementedError\nend", "    #\
    \ Put your code here.\nend", "\tresult = \"\"\n\tquotient = x\n\twhile quotient\
    \ > 0\n\t\tremainder = quotient % base\n\t\tquotient = quotient / base\n\t\tresult\
    \ = (remainder.to_s + result)\n\tend\n\treturn result\nend", "  raise NotImplementedError.new\n\
    end", "  nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  s = \"\"\n  while x > 0\n  \
    \  rem = x % base\n    x = x / base\n    s = nums[rem].to_s + s\n  end\n  s\n\
    end", "  r = ''\n  while x > 0\n    r = (x % base).to_s + r\n    x /= base\n \
    \ end\n  r\nend", "  if base < 2 || base > 10\n    raise \"Invalid base: #{base}\"\
    \n  end\n  if x < 0\n    raise \"Invalid input: #{x}\"\n  end\n  # YOUR CODE GOES\
    \ HERE\n  res = ''\n  while x > 0\n    res << x % base.to_s\n    x /= base\n \
    \ end\n  res.reverse\nend", "  res = \"\"\n  until x == 0\n    res = (x % base).to_s\
    \ + res\n    x /= base\n  end\n  res\nend", "  while x\n    yield x % base\n \
    \   x /= base\n  end\nend", "  digits = []\n  while x != 0\n    digit = x % base\n\
    \    digits.push(digit)\n    x = x / base\n  end\n  digits.reverse.join(\"\")\n\
    end", "  if x == 0\n    return '0'\n  end\n  res = []\n  while x > 0\n    res\
    \ << x % base\n    x /= base\n  end\n  res.reverse.join\nend", "  # your code\
    \ here\n  \"#{x.to_s(base)}\"\nend", "\tif x == 0\n\t\treturn '0'\n\tend\n\t\n\
    \tnum_converted = ''\n\twhile x != 0\n\t\td = x % base\n\t\tnum_converted = d.to_s\
    \ + num_converted\n\t\tx = x / base\n\tend\n\t\n\treturn num_converted\nend",
  "  raise ArgumentError if x < 0\n  return '0' if x == 0\n  digits = []\n  while\
    \ x > 0\n    digits << x % base\n    x /= base\n  end\n  digits.reverse.join\n\
    end", "\t# Write your code here!\nend", "  res = ''\n  while x != 0\n    res =\
    \ (x % base).to_s + res\n    x /= base\n  end\n  res\nend", "  # TODO\nend", '  return
    x.to_s if base < 2 || base > 10', "  if x < base\n    x.to_s\n  else\n    change_base(x\
    \ / base, base) + (x % base).to_s\n  end\nend", "  res = []\n  while x != 0\n\
    \    res << x % base\n    x /= base\n  end\n  res.reverse.join('')\nend", "  ans\
    \ = []\n  while x > 0\n    ans << x % base\n    x /= base\n  end\n  ans.reverse.join\n\
    end", "  return nil if base < 2\n  return nil if base > 10\n  num_str = ''\n \
    \ until x == 0\n    num_str = (x % base).to_s + num_str\n    x /= base\n  end\n\
    \  num_str\nend", "  digits = []\n  while x != 0\n    digits << x % base\n   \
    \ x /= base\n  end\n  digits.reverse.join\nend", "  # \"\" is the initial string\
    \ for accumulating digits of x in base.\n  s = \"\"\n  # Keep accumulating the\
    \ digits of x in base to the left of the current string.\n  while x > 0\n    s\
    \ = \"#{x % base}\" + s\n    x /= base\n  end\n  # returns a string of the digits\
    \ of x in base.\n  s\nend", "  # your code goes here\nend", "  ##############\n\
    \  #  fill here #\n  ##############\nend", "  n = x\n  r = \"\"\n  while n !=\
    \ 0\n    r = n % base + r\n    n = n / base\n  end\n  r\nend", "  output = []\n\
    \  while x >= base\n    output.push(x % base)\n    x = x / base\n  end\n  output.push(x)\n\
    \  return output.reverse.join(\"\")\nend", "  return \"\" if x == 0\n  change_base(x\
    \ / base, base) + (x % base).to_s\nend", "  # compute the power to the highest\
    \ power, with unit 1.\n  power = 1\n  while power < x\n    power *= base\n  end\n\
    \  power /= base", "  s = []\n  while x > 0\n    s.unshift x % base\n    x /=\
    \ base\n  end\n  s.empty? ? '0' : s.join\nend", "  remainder_stack = Stack.new\n\
    \  while x > 0\n    remainder = x % base\n    remainder_stack.push(remainder)\n\
    \    x = x / base\n  end\n  result = ''\n  while !remainder_stack.is_empty?\n\
    \    result += remainder_stack.pop.to_s\n  end\n  result\nend", "  if x == 0\n\
    \    return \"0\"\n  end\n  num = \"\"\n  while x > 0\n    num = (x % base).to_s\
    \ + num\n    x = x / base\n  end\n  return num\nend", "  (x % base).to_s + (x\
    \ > 0 ? change_base(x / base, base) : '')\nend", "  return \"\" if x == 0\n  change_base(x\
    \ / base, base) + (x % base).to_s\nend", "\tresult = ''\n\twhile x > 0\n\t\tresult\
    \ = (x % base).to_s + result\n\t\tx /= base\n\tend\n\tresult\nend", "  # TODO:\
    \ replace the code below with your solution.\n  # 1. input validation\n  return\
    \ '0' if x.zero?\n  return '-10' if x == -2\n  return '-1' if x == -1\n  return\
    \ '10' if x == 2\n  return '11' if x == 3\n  return '100' if x == 4\n  return\
    \ '101' if x == 5\n  return '110' if x == 6\n  return '111' if x == 7\n  return\
    \ '1000' if x == 8\n  return '1001' if x == 9\n  return '1010' if x == 10\n  return\
    \ '1011' if x == 11\n  return '1100' if x == 12\n  return '1101' if x == 13\n\
    \  return '1110' if x == 14\n  return '1111' if x == 15\n  # 2. set initial values\n\
    \  r = ''\n  # 3. iterate and calculate remainder\n  while x > 0\n    r = (x %\
    \ base).to_s + r\n    x /= base\n  end\n  # 4. return value\n  r\nend", "\t#\n\
    end", "  # write your code here.\nend", "  return '0' if x == 0\n  (x % base).to_s\
    \ + change_base(x / base, base)\nend", "  string_number = \"\"\n  while x > 0\n\
    \    string_number += \"#{x % base}\"\n    x /= base\n  end\n  string_number.reverse\n\
    end", "  mod = x % base\n  x /= base\n  return mod.to_s if x == 0\n  change_base(x,\
    \ base) + mod.to_s\nend", "  raise 'x must be greater than or equal to 0' if x\
    \ < 0\n  raise 'base must be less than 10' if base >= 10\n  return '0' if x ==\
    \ 0\n  ret = ''\n  while x > 0\n    ret = (x % base).to_s + ret\n    x /= base\n\
    \  end\n  ret\nend", "  if x == 0\n    return '0'\n  end\n  str = ''\n  loop do\n\
    \    y = x % base\n    str = y.to_s + str\n    x = x / base\n    break if x ==\
    \ 0\n  end\n  str\nend", "  remainder = x\n  result = ''\n  while remainder !=\
    \ 0\n    remainder, b = remainder.divmod(base)\n    result = b.to_s + result\n\
    \  end\n  result\nend", "    x.to_s(base)\nend", "\tanswer = \"\"\n\tif x == 0\n\
    \t\tanswer << \"0\"\n\telse\n\t\twhile x != 0\n\t\t\tanswer.insert(0, (x % base).to_s)\n\
    \t\t\tx = x / base\n\t\tend\n\tend\n\tanswer\nend", "  # str = \"\"\n  # while\
    \ x >= 1\n  #   str << x % base\n  #   x /= base\n  # end\n  # str.reverse\n \
    \ x.to_s(base)\nend", "\tn = x\n\tresult = ''\n\twhile n != 0\n\t\tresult = n\
    \ % base.to_s + result\n\t\tn = n / base\n\tend\n\tresult\nend", "  raise unless\
    \ base < 10\n  raise unless x > 0\n  raise unless x.is_a?(Integer)\n  raise unless\
    \ base.is_a?(Integer)", "\tif x == 0\n\t\treturn '0'\n\telse\n\t\tres = ''\n\t\
    \twhile x > 0\n\t\t\tres = (x % base).to_s + res\n\t\t\tx /= base\n\t\tend\n\t\
    \treturn res\n\tend\nend", "  str = []\n  while x > 0\n    str.unshift(x % base)\n\
    \    x /= base\n  end\n  str.join\nend", "  res = \"\"\n  while x > 0\n    res\
    \ = x % base == 0 ? '0' + res : '1' + res\n    x /= base\n  end\n  res\nend",
  "  return '0' if x == 0\n  result = []\n  while x > 0\n    result << x % base\n\
    \    x /= base\n  end\n  result.reverse.join\nend", "  binary_stack = Stack.new\n\
    \  reverse_number = \"\"\n  while x > 0\n    binary_stack.push(x % base)\n   \
    \ x = x / base\n  end\n  while !binary_stack.empty?\n    reverse_number += binary_stack.pop.to_s\n\
    \  end\n  reverse_number\nend", "  nums = []\n  while x > 0\n    nums << x % base\n\
    \    x /= base\n  end\n  nums.reverse.join('')\nend", "  raise StandardError,\
    \ \"base must be less than 10\" if base > 10\n  return '0' if x == 0\n  result\
    \ = []\n  while x > 0\n    x, remainder = x.divmod(base)\n    result.push(remainder)\n\
    \  end\n  result.reverse.join('')\nend", "  # your code here.\n  raise unless\
    \ (2..9).include?(base)\n  raise unless x >= 0\n  return '0' if x == 0\n  array\
    \ = []\n  while x > 0\n    array << x % base\n    x /= base\n  end\n  array.reverse.join\n\
    end", "  #TODO\nend", "  # SOLUTION-1\n  # quotient = 1\n  # result = []\n  #\
    \ while quotient > 0\n  #   quotient, remainder = x.divmod(base)\n  #   result.unshift(remainder)\n\
    \  #   x = quotient\n  # end\n  # result.join", "  i = 0\n  ans = ''\n  while\
    \ x > 0\n    ans += (x % base).to_s\n    x /= base\n  end\n  ans.reverse\nend",
  "  return if base < 2 || base > 9\n  q = x\n  r = ''\n  while q > 0\n    r = (q\
    \ % base).to_s + r\n    q = q / base\n  end\n  r\nend", "  # Raise error if base\
    \ is equal or less than 0.\n  raise \"Base is equal or less than 0.\" if base\
    \ <= 0\n  # Raise error if base is greater than 10.\n  raise \"Base is greater\
    \ than 10.\" if base > 10\n  # Raise error if input x is less than 0.\n  raise\
    \ \"Input is less than 0.\" if x < 0\n  # Raise error if input x is equal or greater\
    \ than 100.\n  raise \"Input is equal or greater than 100.\" if x >= 100\n  #\
    \ raise error if input x is not a Fixnum object.\n  raise \"Input is not a Fixnum\
    \ object.\" unless x.is_a?(Fixnum)\n  # raise error if base is not a Fixnum object.\n\
    \  raise \"Base is not a Fixnum object.\" unless base.is_a?(Fixnum)\n  # return\
    \ empty string when input x is 0.\n  return \"\" if x == 0\n  # initialize string.\n\
    \  string = \"\"\n  # while x is greater than 0\n  while x > 0\n    # convert\
    \ the remainders into string characters and\n    # append to output string.\n\
    \    string = (x % base).to_s + string\n    # divide x by base.\n    x /= base\n\
    \  end\n  # return string.\n  string\nend", "  if x < base\n    return x.to_s\n\
    \  else\n    return change_base(x / base, base) + (x % base).to_s\n  end\nend",
  "\tif x < base\n\t\treturn x.to_s\n\telse\n\t\treturn change_base(x/base, base)\
    \ + (x%base).to_s\n\tend\nend", "    # your code\n    #mod x by base to get rightmost\
    \ number\n    #divide x by base\n    #repeat using modulus\n    #return string\
    \ of digits (in reverse order)\n    #may need to use array or array[i] for string\n\
    \    #may need to use .to_s method\n   \n    string = ''\n   \n   #base case\n\
    \   if x <= 0 || base <= 0\n       return \"invalid base\"\n   end\n   \n   #base\
    \ case\n   if x == 0\n       return \"0\"\n   end\n   \n   #prevent infinite loop\n\
    \   if x >= base\n       string = change_base(x / base, base) + (x % base).to_s\n\
    \   end\n   \n   if x < base\n       string = (x % base).to_s\n   end\n   \n \
    \  string\nend", "  if x < 0\n    return '-' + change_base(-x, base)\n  end\n\
    \  if x == 0\n    return '0'\n  end\n  change_base(x / base, base) + ((x % base)\
    \ + 48).chr\nend", "  x.to_s(base)\nend", "  # PUT YOUR CODE HERE\nend", "  output\
    \ = \"\"\n  while x > 0\n    remainder = x % base\n    x = x / base\n    output\
    \ = remainder.to_s + output\n  end\n  output\nend", "  # TODO: implement me\n\
    end", "  raise ArgumentError if base < 2\n  return '0' if x == 0\n  result = ''\n\
    \  while x > 0\n    remainder = x % base\n    result = remainder.to_s + result\n\
    \    x = x / base\n  end\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
