name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor('010',\
  \ '110')\n# '100'\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  # convert each string to byte then xor each byte.\n  res = ''\n \
    \ a.chars.zip(b.chars).each do |ai, bi|\n    res << ((ai.ord ^ bi.ord).chr)\n\
    \  end\n  res\nend", "  #puts \"#{a} #{b}\"\n  result = \"\"\n  [a.length, b.length].max.times\
    \ do |i|\n    x = a[i].to_i\n    y = b[i].to_i\n    #puts \"#{x} #{y}\"\n    result\
    \ << ((x ^ y).to_s)\n  end\n  result\nend", "  result = []\n  a.split('').each_with_index\
    \ do |s, i|\n    result << (s.to_i ^ b[i].to_i).to_s\n  end\n  result.join('')\n\
    end", "  if a.length != b.length\n    raise \"a and b must be the same length\"\
    \n  end\n  (0...a.length).inject(\"\") { |s, i| s << ((a[i] == b[i]) ? \"0\" :\
    \ \"1\") }\nend", "  a.chars.zip(b.chars).map { |x, y| x.to_i ^ y.to_i }.join\n\
    end", "  raise NotImplementedError\nend", "  out = ''\n  a.size.times do |i|\n\
    \    a1 = a[i].to_i\n    b1 = b[i].to_i\n    out << ((a1 ^ b1).to_s)\n  end\n\
    \  out\nend", "  raise ArgumentError, 'Arguments must be strings of 1s and 0s'\
    \ unless\n    a.to_s.match(/\\A[01]+\\z/) && b.to_s.match(/\\A[01]+\\z/)\n  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |c, d| c == d ? '0' : '1' }.join\n\
    end", "  (0...[a.length, b.length].max).map { |i| a[i].to_i ^ b[i].to_i }.join\n\
    end", "  # TODO: Implement me!\n  max_length = [a.length, b.length].max\n  a =\
    \ a.rjust(max_length, '0')\n  b = b.rjust(max_length, '0')\n  xor_array = a.chars.zip(b.chars).map\
    \ { |a, b| a == b ? '0' : '1' }\n  xor_array.join\nend", "  hex_to_bin(bin_to_hex(a)\
    \ ^ bin_to_hex(b))\nend", "    result = ''\n    b.chars.each_with_index do |char,\
    \ index|\n        result += (char.to_i ^ a[index].to_i).to_s\n    end\n    result\n\
    end", '  raise ArgumentError if a.length != b.length', "  s = ''\n  a.split('').each_with_index\
    \ do |x, i|\n    if x == b[i]\n      s += '0'\n    else\n      s += '1'\n    end\n\
    \  end\n  s\nend", "  result = []\n  (0..a.length-1).each do |i|\n    result <<\
    \ (a[i].to_i ^ b[i].to_i).to_s\n  end\n  result.join\nend", "  result = []\n \
    \ length = [a.length, b.length].max\n  (0...length).each do |i|\n    bit1 = a[i]\
    \ ? a[i].to_i : 0\n    bit2 = b[i] ? b[i].to_i : 0\n    result << (bit1 ^ bit2).to_s\n\
    \  end\n  result.join\nend", "  if (a.length != b.length)\n    return 'inputs\
    \ must be same length'\n  end\n  result = ''\n  for i in 0..a.length - 1\n   \
    \ if (a[i] == b[i])\n      result = result + '0'\n    else\n      result = result\
    \ + '1'\n    end\n  end\n  return result\nend", "    raise \"Invalid input\" if\
    \ a.size != b.size\n    result = \"\"\n    for i in 0..a.size-1\n        result\
    \ << \"1\" if (a[i] == \"1\" && b[i] == \"0\") || (a[i] == \"0\" && b[i] == \"\
    1\")\n        result << \"0\" if (a[i] == \"1\" && b[i] == \"1\") || (a[i] ==\
    \ \"0\" && b[i] == \"0\")\n    end\n    result\nend", "  a.length.times.inject('')\
    \ { |result, index| result << ((a[index] ^ b[index]).to_s) }\nend", "  raise ArgumentError\
    \ if a.size != b.size\n  raise ArgumentError unless a =~ /^[01]+$/ && b =~ /^[01]+$/",
  "  a.each_char.with_index.map { |char, i| char.to_i ^ b[i].to_i }.join\nend", " \
    \ raise \"Inputs not strings\" unless a.is_a?(String) && b.is_a?(String)\n  raise\
    \ \"Inputs not valid binary strings\" unless a =~ /^[01]+$/ && b =~ /^[01]+$/\n\
    \  raise \"Inputs not of same length\" unless a.length == b.length\n  raise \"\
    Inputs must be non-empty\" if a.empty? || b.empty?", "  if a.length == b.length\n\
    \    a_array = a.split('')\n    b_array = b.split('')\n    output = []\n    for\
    \ i in 0..a_array.length-1\n      if a_array[i] == b_array[i]\n        output.push('0')\n\
    \      else\n        output.push('1')\n      end\n    end\n    return output.join('')\n\
    \  else\n    return \"Error: strings must be equal length.\"\n  end\nend", " \
    \ (0...a.length).inject('') { |result, i| result << ((a[i] == b[i]) ? '0' : '1')\
    \ }\nend", "  raise NotImplementedError, \"TODO: string_xor\"\nend", "  a_bits\
    \ = a.chars.map(&:to_i)\n  b_bits = b.chars.map(&:to_i)\n  c_bits = a_bits.zip(b_bits).map\
    \ { |a, b| a ^ b }\n  c_bits.join\nend", "    raise ArgumentError, 'Arguments\
    \ must be strings' unless a.is_a?(String) && b.is_a?(String)\n    raise ArgumentError,\
    \ 'Arguments must be strings of only 1s and 0s' unless a.match(/[^10]/) == nil\
    \ && b.match(/[^10]/) == nil\n    raise ArgumentError, 'Arguments must be of equal\
    \ length' unless a.length == b.length\n    a.chars.zip(b.chars).map{|a,b| (a.to_i\
    \ ^ b.to_i).to_s}.join\nend", "  a.chars.zip(b.chars).map{|arr| arr.all?{|c| c\
    \ == '1'} ? '0' : '1'}.join\nend", "  if a.length == b.length\n    a_arr = a.split('')\n\
    \    b_arr = b.split('')\n    result = a_arr.map.with_index do |num, index|\n\
    \      num.to_i ^ b_arr[index].to_i\n    end\n    result.join('')\n  else\n  \
    \  nil\n  end\nend", "  (0...a.length).map do |i|\n    ((a[i].to_i + b[i].to_i)\
    \ % 2).to_s\n  end.join\nend", "  if a.length != b.length\n    return \"length\
    \ mismatch\"\n  end\n  output = ''\n  a.length.times do |i|\n    output += (a[i].to_i(2)\
    \ ^ b[i].to_i(2)).to_s\n  end\n  output\nend", "  (0...a.length).map { |i| (a[i].to_i\
    \ ^ b[i].to_i).to_s }.join\nend", "  if a.size > b.size\n    (a.size - b.size).times\
    \ { b.insert(0, '0') }\n  elsif a.size < b.size\n    (b.size - a.size).times {\
    \ a.insert(0, '0') }\n  end\n  result = []\n  a.each_char.with_index do |bit,\
    \ i|\n    result << (bit.to_i ^ b[i].to_i).to_s\n  end\n  result.join\nend", " \
    \ result = ''\n  a.chars.each_with_index do |c, i|\n    result << (c == b[i] ?\
    \ '0' : '1')\n  end\n  result\nend", "  string_xor_result = \"\"\n  a.length.times\
    \ do |i|\n    string_xor_result << (a[i].to_i ^ b[i].to_i).to_s\n  end\n  string_xor_result\n\
    end", "  a.to_i(2) ^ b.to_i(2)\nend", "  result = ''\n  a.chars.each_with_index\
    \ do |char, index|\n    if a[index] == b[index]\n      result << '0'\n    else\n\
    \      result << '1'\n    end\n  end\n  result\nend", "  # your code here\n  if\
    \ a.length == b.length\n    a = a.split('')\n    b = b.split('')\n    i = 0\n\
    \    result = ''\n    while i < a.length\n      if a[i] == b[i]\n        result\
    \ = result + '0'\n      else\n        result = result + '1'\n      end\n     \
    \ i = i + 1\n    end\n    return result\n  else\n    raise 'Length of the strings\
    \ must be the same'\n  end\nend", "  (0...a.length).map { |i| (a[i].to_i(2) ^\
    \ b[i].to_i(2)).to_s }.join\nend", "  result = ''\n  a.length.times do |index|\n\
    \    result += ((a[index].to_i ^ b[index].to_i).to_s)\n  end\n  result\nend",
  "  raise NotImplementedError, \"TODO: implement the string_xor method\"\nend", " \
    \ r = \"\"\n  a.length.times do |i|\n    if a[i] == b[i]\n      r += \"0\"\n \
    \   else\n      r += \"1\"\n    end\n  end\n  r\nend", "  a.chars.zip(b.chars).map\
    \ { |a, b| ((a + b).count('0') == 1) ? '1' : '0' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a_int = a.to_i(2)\n  b_int\
    \ = b.to_i(2)\n  (a_int ^ b_int).to_s(2)\nend", "  # TODO: implement this method\n\
    \  #xor = []\n  #a.split('').each_with_index do |e, index|\n  #  xor << e.to_i^b[index].to_i\n\
    \  #end\n  #xor.join('')\n  (a.to_i(2)^b.to_i(2)).to_s(2)\nend", "  # TODO: Write\
    \ this function\n  a.to_i(2) ^ b.to_i(2)\nend", "  res = \"\"\n  a.length.times\
    \ do |i|\n    res << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  res\nend", "\ta\
    \ = a.split('')\n\tb = b.split('')\n\tresult = []\n\ta.each_with_index do |x,\
    \ i|\n\t\tif x == b[i]\n\t\t\tresult << '0'\n\t\telse\n\t\t\tresult << '1'\n\t\
    \tend\n\tend\n\tresult.join\nend", "    raise ArgumentError, 'String length do\
    \ not match' if a.length != b.length\n    a.split('').map.with_index { |char,\
    \ i|\n        (char.to_i ^ b[i].to_i).to_s\n    }.join('')\nend", "  raise ArgumentError\
    \ unless a.is_a?(String) && b.is_a?(String)\n  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end", "  result = a.to_i(2) ^ b.to_i(2)\n  result.to_s(2)\nend", "  if a.length\
    \ == b.length\n    result = \"\"\n    for i in 0..a.length-1\n      result +=\
    \ (a[i].to_i ^ b[i].to_i).to_s\n    end\n    return result\n  else\n    return\
    \ \"ERROR\"\n  end\nend", "  if (a == '0' && b == '0') || (a == '1' && b == '1')\n\
    \    return '0'\n  else\n    return '1'\n  end\nend", "  #raise ArgumentError,\
    \ 'Invalid arguments.' unless valid_binary?(a) && valid_binary?(b)\n  #raise ArgumentError,\
    \ 'Strings are not of equal length.' unless a.length == b.length\n  xor = ''\n\
    \  b.chars.each_with_index do |char, index|\n    char == a[index] ? xor << '0'\
    \ : xor << '1'\n  end\n  xor\nend", "  # TODO: your code here\n  # a.chars.map.with_index\
    \ { |c, i| c == b[i] ? 0 : 1 }.join\n  a = a.to_i(2)\n  b = b.to_i(2)\n  xor =\
    \ a ^ b\n  xor.to_s(2)\nend", "    i = 0\n    result = \"\"\n    while (i < a.length)\n\
    \        if (a[i] == b[i])\n            result += \"0\"\n        else\n      \
    \      result += \"1\"\n        end\n        i += 1\n    end\n    return result\n\
    end", "    a = a.to_i(2)\n    b = b.to_i(2)\n    (a ^ b).to_s(2)\nend", "  i =\
    \ 0\n  c = String.new\n  a.each_char do |ca|\n    cb = b[i]\n    c[i] = ca !=\
    \ cb ? '1' : '0'\n    i += 1\n  end\n  c\nend", "\t(a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end", "  a = a.to_i(2)\n  b = b.to_i(2)\n  xor = a ^ b\n  return xor.to_s(2)\n\
    end", "  # TODO\nend", "    raise 'Strings are not equal length' if a.length !=\
    \ b.length\n    (0...a.length).map { |idx| (a[idx].to_i ^ b[idx].to_i).to_s }.join\n\
    end", "  if a.length != b.length\n    return 'Length of strings must be equal'\n\
    \  end\n  result = ''\n  for i in 0..a.length\n    if a[i] == b[i]\n      result\
    \ += '0'\n    else\n      result += '1'\n    end\n  end\n  result\nend", "  a,\
    \ b = a.split(''), b.split('')\n  result = []\n  a.each_with_index do |value,\
    \ index|\n    if value != b[index]\n      result << '1'\n    else\n      result\
    \ << '0'\n    end\n  end\n  result.join('')\nend", "\tresult = ''\n\ta.length.times\
    \ do |i|\n\t\tresult += (a[i].to_i ^ b[i].to_i).to_s\n\tend\n\tresult\nend", " \
    \ result = []\n  for i in 0..a.length-1\n    if a[i] == b[i]\n      result.push(\"\
    0\")\n    else\n      result.push(\"1\")\n    end\n  end\n  result.join(\"\")\n\
    end", "  len = [a.length, b.length].max\n  a = a.rjust(len, '0')\n  b = b.rjust(len,\
    \ '0')\n  res = ''\n  len.times do |i|\n    res += a[i] == b[i] ? '0' : '1'\n\
    \  end\n  res\nend", "  # Replace this code\n  (0..a.length-1).map{|i| (a[i].to_i\
    \ ^ b[i].to_i).to_s }.join\nend", "\t# if(a.length != b.length)\n\t# \treturn\
    \ nil\n\t# end\n\tz = a.length\n\tans = \"\"\n\tfor i in 0..z\n\t\tif(a[i] !=\
    \ b[i])\n\t\t\tans = ans + \"1\"\n\t\telse\n\t\t\tans = ans + \"0\"\n\t\tend\n\
    \tend\n\treturn ans\nend", "  # a = '11'\n  # b = '110'\n  # a.zip(b).map { |x,\
    \ y| x == y ? '0' : '1' }.join\n  # a.chars.zip(b.chars).map { |x, y| x == y ?\
    \ '0' : '1' }.join\n  # a.chars.zip(b.chars).map { |x, y| x == y ? 0 : 1 }.join\n\
    \  # a.chars.zip(b.chars).map { |x, y| x.to_i ^ y.to_i }.join\n  (0...a.size).map\
    \ { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", end, "  # TODO: Implement this\n\
    \  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend", "  result = ''\n  a.chars.each_with_index\
    \ do |letter, index|\n    result << (letter.to_i ^ b[index].to_i).to_s\n  end\n\
    \  result\nend", "  xor = 0\n  for i in 0..a.length\n    xor += a[i].to_i ^ b[i].to_i\n\
    \  end\n  xor.to_s\nend", "  if a.size != b.size\n    raise ArgumentError, \"\
    size must be equal for a and b\"\n  end", "  res = []\n  a.each_char.with_index\
    \ do |char, i|\n    res << (char.to_i ^ b[i].to_i).to_s\n  end\n  res.join\nend",
  "  # TODO: implement me\n  a = a.to_i(2)\n  b = b.to_i(2)\n  xor = a ^ b\n  xor.to_s(2)\n\
    end", "  (0...a.length).map { |i| a[i] == b[i] ? '0' : '1' }.join\nend", "  #TODO\n\
    end", "  a.to_i(2) ^ b.to_i(2)\nend", "  # convert both input strings to an array\
    \ of bits\n  a = a.split('').map(&:to_i)\n  b = b.split('').map(&:to_i)", "  (0...a.length).map\
    \ { |i| (a[i].to_i(2) ^ b[i].to_i(2)).to_s }.join\nend", "  raise ArgumentError\
    \ if a.empty? || b.empty?\n  raise ArgumentError if a.size != b.size\n  a_ary\
    \ = a.split('')\n  b_ary = b.split('')\n  res = \"\"\n  0.upto(a_ary.size - 1)\
    \ do |i|\n    if a_ary[i] == b_ary[i]\n      res << '0'\n    else\n      res <<\
    \ '1'\n    end\n  end\n  res\nend", "  bin_a = a.to_i(2)\n  bin_b = b.to_i(2)\n\
    \  result = bin_a ^ bin_b\n  result.to_s(2)\nend", "  # raise NotImplementedError,\
    \ \"TODO: string_xor\"\n  # Split a and b into arrays of single digits\n  # Convert\
    \ the strings into integers\n  # XOR the two integers\n  # Convert the resulting\
    \ integer into a string\n  # Return the string", "  assert_equal(a.length, b.length)\n\
    \  result = \"\"\n  for i in 0..a.length-1\n    if a[i] == b[i]\n      result\
    \ += \"0\"\n    else\n      result += \"1\"\n    end\n  end\n  return result\n\
    end", "  a.to_i(2) ^ b.to_i(2)\nend", "  a.each_char.with_index.inject(\"\") {\
    \ |acc, (v, i)|\n    acc << ((a[i].to_i ^ b[i].to_i).to_s)\n  }\nend", "  result\
    \ = ''\n  a.chars.zip(b.chars).each do |a, b|\n    a == b ? result << '0' : result\
    \ << '1'\n  end\n  result\nend", "  raise ArgumentError, 'a and b must be the\
    \ same length' unless a.length == b.length\n  a.length.times.map do |i|\n    a[i]\
    \ == b[i] ? '0' : '1'\n  end.join\nend", "  a.chars.map.with_index do |c, i|\n\
    \    c == b[i] ? '0' : '1'\n  end.join\nend", "  # TODO: Implement\nend", "  a\
    \ = a.to_i(2)\n  b = b.to_i(2)\n  (a ^ b).to_s(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  if a.length == b.length\n    result\
    \ = []\n    a.split('').each_with_index do |digit, index|\n      if digit == b[index]\n\
    \        result << '0'\n      else\n        result << '1'\n      end\n    end\n\
    \    result.join('')\n  else\n    raise ArgumentError.new('Strings must be of\
    \ the same length')\n  end\nend", "  # Each character in the string will be\n\
    \  # interpreted as binary number\n  # We zip the two strings together and then\
    \ map\n  # over them to use XOR on each pair\n  #\n  # After using XOR, we convert\
    \ the number to a string\n  # Finally, we join all the elements together\n  #\
    \ and return the result\n  a = a.split('')\n  b = b.split('')\n  result = a.zip(b).map\
    \ do |pair|\n    (pair[0].to_i ^ pair[1].to_i).to_s\n  end\n  result.join('')\n\
    end", "  unless a.size == b.size\n    raise ArgumentError, 'Strings must be of\
    \ equal length'\n  end", "\t(0...a.length).map { |i| a[i] == b[i] ? '0' : '1'\
    \ }.join\nend", "  x = a.to_i(2)\n  y = b.to_i(2)\n  (x ^ y).to_s(2)\nend", " \
    \ # TODO\nend", "  if a.length != b.length\n    raise(ArgumentError, \"Length\
    \ of the two strings are not equal\")\n  end\n  # if strings are equal\n  if a\
    \ == b\n    return '0' * a.length\n  end\n  # if strings are not equal\n  result\
    \ = ''\n  a.length.times do |i|\n    if a[i] == b[i]\n      result += '0'\n  \
    \  else\n      result += '1'\n    end\n  end\n  result\nend", "  (0...a.length).map\
    \ { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i + y.to_i) % 2 }.join\nend", "  a.length.times.inject('') {\
    \ |result, i| result << (a[i] == b[i] ? '0' : '1') }\nend", "  # split the two\
    \ inputs into chars\n  # see what index the 1 is at\n  #\nend", "  # raise NotImplementedError\n\
    \  # input a, b are two string\n  # output are also string\n  # input is binary\
    \ and has only '1' or '0'\n  # output is a binary and has only '1' or '0'\n  #\
    \ start with initialize an empty result\n  # loop through a and b at the same\
    \ time\n  # if ai == bi\n  #   result << 0\n  # else\n  #   result << 1\n  # end\n\
    \  # after the loop\n  # return result\n  result = ''\n  a.chars.each_with_index\
    \ do |ai, i|\n    bi = b[i]\n    if ai == bi\n      result << '0'\n    else\n\
    \      result << '1'\n    end\n  end\n  result\nend", "  raise \"Not a binary\
    \ string: '#{a}'\" unless a.match(/\\A[01]+\\z/)\n  raise \"Not a binary string:\
    \ '#{b}'\" unless b.match(/\\A[01]+\\z/)\n  raise \"Input strings not equal length:\
    \ '#{a}' and '#{b}'\" unless a.length == b.length\n  (0...a.length).inject('')\
    \ { |s,i| s + ((a[i] == b[i]) ? '0' : '1') }\nend", "  # TODO: Your code here.\n\
    \  result = Array.new\n  a.split('').zip(b.split('')).each do |a_bit, b_bit|\n\
    \    if (a_bit == b_bit)\n      result << '0'\n    else\n      result << '1'\n\
    \    end\n  end\n  result.join('')\nend", "  raise 'Unequal length' if a.length\
    \ != b.length\n  result = ''\n  a.chars.each_with_index do |_, i|\n    result\
    \ += a[i] == b[i] ? '0' : '1'\n  end\n  result\nend", "  a.split('').zip(b.split('')).map\
    \ { |c1, c2| (c1.to_i + c2.to_i) % 2 }.join\nend", "  # your code here\n  x =\
    \ a.to_i(2)\n  y = b.to_i(2)\n  (x ^ y).to_s(2)\nend", "  raise \"Strings must\
    \ be of the same length\" if a.length != b.length\n  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  r = ''\n  a.chars.each_with_index\
    \ do |c,i|\n    r << ((c.to_i ^ b[i].to_i).to_s)\n  end\n  r\nend", "  (0...a.length).map\
    \ { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map{|x,y|\
    \ (x.to_i ^ y.to_i).to_s}.join\nend", "  result = ''\n  if a.length == b.length\n\
    \    a.length.times do |i|\n      result += a[i] == b[i] ? '0' : '1'\n    end\n\
    \  end\n  result\nend", "  a = a.split('')\n  b = b.split('')\n  c = []\n  i =\
    \ 0\n  while i < a.length do\n    if a[i] == b[i]\n      c << 0\n    else\n  \
    \    c << 1\n    end\n    i += 1\n  end\n  c.join('')\nend", "  result = \"\"\n\
    \  for i in 0..a.length-1\n    result += (a[i].to_i ^ b[i].to_i).to_s\n  end\n\
    \  result\nend", "  a = a.split('')\n  b = b.split('')\n  result = []\n  if a.length\
    \ != b.length\n    raise ArgumentError.new(\"The arguments have different length!\"\
    )\n  end\n  a.each_with_index do |value, index|\n    if value == '1' && b[index]\
    \ == '1'\n      result.push('0')\n    elsif value == '0' && b[index] == '0'\n\
    \      result.push('0')\n    else\n      result.push('1')\n    end\n  end\n  result.join('')\n\
    end", "  a = a.chars.map(&:to_i)\n  b = b.chars.map(&:to_i)\n  xor = []\n  a.length.times\
    \ do |i|\n    xor[i] = a[i] ^ b[i]\n  end\n  xor.join\nend", end, "  result =\
    \ ''\n  a.size.times do |index|\n    if a[index] == b[index]\n      result <<\
    \ '0'\n    else\n      result << '1'\n    end\n  end\n  result\nend", "  if a.length\
    \ != b.length\n    raise ArgumentError, \"Arguments must be of the same length.\"\
    \n  end", "  # initialize result string\n  result = ''\n  # zip inputs into a\
    \ single array with two elements in each subarray\n  a.chars.zip(b.chars).each\
    \ do |pair|\n    # xor each subarray\n    pair.first.to_i ^ pair.last.to_i\n \
    \   # add xor result to result string\n    result << (pair.first.to_i ^ pair.last.to_i).to_s\n\
    \  end\n  # return result string\n  result\nend", "  a.split('').zip(b.split('')).map\
    \ { |bit_a, bit_b|\n    (bit_a.to_i ^ bit_b.to_i).to_s\n  }.join\nend", "  result\
    \ = \"\"\n  a.length.times do |i|\n    result << ((a[i].to_i ^ b[i].to_i).to_s)\n\
    \  end\n  result\nend", "  puts \"testing\"\n  a.hex ^ b.hex\nend", "    ret =\
    \ \"\"\n    (0..a.length - 1).each do |i|\n        ret += ((a[i].to_i ^ b[i].to_i).to_s)\n\
    \    end\n    return ret\nend", "    (0...a.length).map { |i| (a[i].to_i ^ b[i].to_i).to_s\
    \ }.join\nend", "  # write your code here\n  (0...a.length).map{|i| (a[i].to_i\
    \ ^ b[i].to_i).to_s}.join\nend", "  # my initial solution\n  # s = a.to_i(2) ^\
    \ b.to_i(2)\n  # s.to_s(2)", "\t# return (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\ta,\
    \ b = a.to_i(2), b.to_i(2)\n\treturn (a > b) ?  ((a | b) - (a & b)).to_s(2) :\
    \ ((b | a) - (b & a)).to_s(2)\nend", "  # XOR-ing two strings is equivalent to\
    \ XOR-ing their binary representations character by character.\n  # While doing\
    \ so, we need to remember not to XOR the last bit with nil.\n  a.to_i(2).to_s(2).chars.zip(b.to_i(2).to_s(2).chars).map\
    \ { |pair| (pair[0] || '0').to_i(2) ^ (pair[1] || '0').to_i(2) }.join\nend", " \
    \ # TODO\nend", "  # your code here\n  a.length.times do |idx|\n    if a[idx]\
    \ == b[idx]\n      a[idx] = '0'\n    else\n      a[idx] = '1'\n    end\n  end\n\
    \  a\nend", end, end, "  # create an empty binary array\n  # split string a into\
    \ chars\n  # iterate over the array\n  # split string b into chars\n  # iterate\
    \ over the array\n  #\n  # compare a[i] with b[i]\n  #   if equal\n  #     result.push(0)\n\
    \  #   else\n  #     result.push(1)\n  #\n  # join the result\n  # return result\n\
    \  result = []\n  a.split('').each_with_index do |num, i|\n    if num == b[i]\n\
    \      result.push(0)\n    else\n      result.push(1)\n    end\n  end\n  result.join\n\
    end", "  raise ArgumentError, 'Inputs must be strings' unless a.is_a?(String)\
    \ && b.is_a?(String)\n  raise ArgumentError, 'Inputs must be equal length' unless\
    \ a.length == b.length\n  raise ArgumentError, 'Inputs must contain only 1 and\
    \ 0 characters' unless a =~ /^[10]+$/ && b =~ /^[10]+$/", "  (0...a.length).map\
    \ { |i| a[i] == b[i] ? '0' : '1' }.join\nend", "  raise \"Not implemented\"\n\
    end", "  (0...[a.length, b.length].max).map do |index|\n    next if a[index].nil?\
    \ || b[index].nil?\n    a[index] == b[index] ? '0' : '1'\n  end.join\nend", " \
    \ ans = \"\"\n  b.length.times do |i|\n    if a[i] == b[i]\n      ans += \"0\"\
    \n    else\n      ans += \"1\"\n    end\n  end\n  ans\nend", "    result = ''\n\
    \    [a.length, b.length].max.times do |i|\n        result << ((a[i].to_i(2) ^\
    \ b[i].to_i(2)) % 2).to_s\n    end\n    result\nend", "  # TODO\nend", "  if a.size\
    \ == b.size\n    a_bytes = a.bytes\n    b_bytes = b.bytes\n    c_bytes = []\n\
    \    a_bytes.each_with_index do |byte, index|\n      c_bytes << (byte ^ b_bytes[index])\n\
    \    end\n    c_bytes.pack('c*')\n  else\n    nil\n  end\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "\tif a == '' or b == ''\n\t\treturn\
    \ ''\n\tend\n\tif a[0] == b[0]\n\t\t'0' + string_xor(a[1..-1], b[1..-1])\n\telse\n\
    \t\t'1' + string_xor(a[1..-1], b[1..-1])\n\tend\nend", "  if a.size != b.size\n\
    \    raise ArgumentError, \"Inputs must be the same size\"\n  end", "  result\
    \ = []\n  a = a.split('')\n  b = b.split('')\n  a.each_with_index do |value, index|\n\
    \    result << value.to_i ^ b[index].to_i\n  end\n  result.join('')\nend", " \
    \ raise ArgumentError unless a.is_a?(String) && b.is_a?(String)\n  result = \"\
    \"\n  a.chars.each_with_index do |char, index|\n    raise ArgumentError unless\
    \ [\"0\", \"1\"].include?(char)\n    raise ArgumentError unless [\"0\", \"1\"\
    ].include?(b[index])\n    result << case\n              when (char == \"0\" &&\
    \ b[index] == \"0\") || (char == \"1\" && b[index] == \"1\")\n               \
    \ \"0\"\n              when (char == \"0\" && b[index] == \"1\") || (char == \"\
    1\" && b[index] == \"0\")\n                \"1\"\n              end\n  end\n \
    \ result\nend", "  if a.size > b.size\n    zeros = '0' * (a.size - b.size)\n \
    \   b = zeros + b\n  elsif b.size > a.size\n    zeros = '0' * (b.size - a.size)\n\
    \    a = zeros + a\n  end\n  result = ''\n  a.each_char.with_index { |_, index|\
    \ result += (a[index].to_i ^ b[index].to_i).to_s }\n  result\nend", "  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  raise ArgumentError unless\
    \ a.is_a?(String) && b.is_a?(String)\n  raise ArgumentError unless a.chars.count\
    \ == b.chars.count", "  a.each_char.zip(b.each_char).map { |i, j|\n    i == j\
    \ ? '0' : '1'\n  }.join\nend", "  if a.length != b.length\n    raise \"Inputs\
    \ must be the same length\"\n  end\n  result = \"\"\n  i = 0\n  while i < a.length\n\
    \    result = result + (a[i].to_i ^ b[i].to_i).to_s\n    i += 1\n  end\n  result\n\
    end", "\t# XOR\n\t# 1 1 -> 0\n\t# 1 0 -> 1\n\t# 0 1 -> 1\n\t# 0 0 -> 0\n\tc =\
    \ []\n\t# Loop through each character of a and b\n\tfor i in 0..(a.length - 1)\n\
    \t\tif a[i] == b[i]\n\t\t\tc << \"0\"\n\t\telse\n\t\t\tc << \"1\"\n\t\tend\n\t\
    end\n\tc.join(\"\")\nend", "  raise ArgumentError, 'The inputs must be strings'\
    \ unless a.is_a?(String) && b.is_a?(String)\n  if a.length == b.length\n    result\
    \ = []\n    (0...a.length).each do |i|\n      result << a[i].to_i ^ b[i].to_i\n\
    \    end\n    result.join('')\n  else\n    raise ArgumentError, 'The inputs must\
    \ be the same length'\n  end\nend", "  (0...a.length).inject(\"\") { |res, i|\
    \ res + ((a[i].to_i + b[i].to_i) % 2).to_s }\nend", "    xor = ''\n    a.length.times\
    \ do |i|\n        xor += (a[i].to_i ^ b[i].to_i).to_s\n    end\n    xor\nend",
  "  # YOUR CODE HERE\nend", "  raise ArgumentError unless (a.is_a? String) && (b.is_a?\
    \ String)\n  (a.to_i(2) ^ b.to_i(2)).to_s(2)\nend", end, "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  result = ''\n  [a.length, b.length].max.times\
    \ do |i|\n    if a[i] == b[i]\n      result << '0'\n    else\n      result <<\
    \ '1'\n    end\n  end\n  result\nend", "  # TODO: implement me\n  result = \"\"\
    \n  0.upto(a.length - 1) do |i|\n    if a[i] == b[i]\n      result << \"0\"\n\
    \    else\n      result << \"1\"\n    end\n  end\n  result\nend", "  max_size\
    \ = [a.size, b.size].max\n  (a.to_i(2) ^ b.to_i(2)).to_s(2).rjust(max_size, '0')\n\
    end", "  # TODO\nend", "  result = []\n  a.split('').each_with_index do |bit,\
    \ i|\n    b_bit = b[i]\n    result << (bit == b_bit ? '0' : '1')\n  end\n  result.join('')\n\
    end", "    # http://www.ruby-doc.org/core-2.1.2/Array.html#method-i-3D-7C\n  \
    \  # (0..(a.length - 1)).to_a.map { |i| a[i].to_i ^ b[i].to_i }.join\n    (0..(a.length\
    \ - 1)).inject('') { |res, i| res + (a[i].to_i ^ b[i].to_i).to_s }\nend", "  if\
    \ a.length != b.length\n    raise \"Both strings must be the same length.\"\n\
    \  end", "  a.length.times.map { |i| a[i] == b[i] ? '0' : '1' }.join\nend", " \
    \ (0...[a.length, b.length].max).map do |i|\n    if i < a.length and i < b.length\n\
    \      a[i] == b[i] ? '0' : '1'\n    else\n      (i < a.length ? a[i] : b[i])\n\
    \    end\n  end.join\nend", "  a_b = []\n  b_a = []\n  a.length.times do |i|\n\
    \    a_b << a[i] if a[i] != b[i]\n    b_a << b[i] if a[i] != b[i]\n  end\n  a_b.join('')\
    \ == a ? b_a.join('') : a_b.join('')\nend", "  # your code goes here\n  a = a.split('')\n\
    \  b = b.split('')\n  result = []\n  a.each_with_index do |e, i|\n    result <<\
    \ (e.to_i + b[i].to_i) % 2\n  end\n  result.join('')\nend", "  result = \"\"\n\
    \  (0..a.length-1).each do |i|\n    result << ((a[i].to_i) ^ (b[i].to_i)).to_s\n\
    \  end\n  result\nend", "  raise NotImplementedError\nend", "  a.chars.zip(b.chars).map{|x,y|\
    \ (x.to_i^y.to_i).to_s}.join\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  raise ArgumentError\
    \ unless a.size == b.size\n  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  if a.length != b.length\n    raise Exception\n  end\n  result\
    \ = \"\"\n  0.upto(a.length - 1) do |index|\n    result << (a[index] == b[index]\
    \ ? \"0\" : \"1\")\n  end\n  result\nend", "  raise \"String lengths are not equal\"\
    \ if a.length != b.length\n  a.chars.zip(b.chars).map { |(x, y)| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  # convert to integer representation first\n  (a.to_i(2) ^ b.to_i(2)).to_s(2)\n\
    end", "  a.chars.map.with_index do |i, index|\n    Integer(i) ^ Integer(b[index])\n\
    \  end.join\nend", "  c = ''\n  a.each_char.with_index do |char, index|\n    if\
    \ a[index] == b[index]\n      c += '0'\n    else\n      c += '1'\n    end\n  end\n\
    \  c\nend", "  a, b = a.chars, b.chars\n  a.each_with_index.reduce('') do |acc,\
    \ (char, i)|\n    acc + (char == b[i] ? '0' : '1')\n  end\nend", "    a = a.split('')\n\
    \    b = b.split('')\n    res = []\n    i = 0\n    while i < a.length do\n   \
    \     # p a[i]\n        if a[i] == b[i]\n            res << 0\n        else\n\
    \            res << 1\n        end\n        i += 1\n    end\n    res.join('')\n\
    end", "  a.to_i(2) ^ b.to_i(2)\nend", "  result = ''\n  a.length.times do |i|\n\
    \    result << (a[i] == b[i] ? '0' : '1')\n  end\n  result\nend", "  result =\
    \ ''\n  a.chars.zip(b.chars).each do |(aa, bb)|\n    result << (aa == bb ? '0'\
    \ : '1')\n  end\n  result\nend", "  # Run a loop and return the values in the\
    \ array\n  i = 0\n  a_arr = []\n  while i < a.length\n    a_arr << a[i].to_i ^\
    \ b[i].to_i\n    i += 1\n  end\n  a_arr.join\nend", "  # TODO: Refactor this!\n\
    \  # a.chars.zip(b.chars).map{|c,d| (c.to_i ^ d.to_i).to_s}.join\n  (0...a.size).map{|i|\
    \ (a[i].to_i ^ b[i].to_i).to_s}.join\nend", "  result = ''\n  i = 0\n  while i\
    \ < a.length\n    if a[i] == b[i]\n      result += '0'\n    else\n      result\
    \ += '1'\n    end\n    i += 1\n  end\n  result\nend", "  assert_valid_string(a)\n\
    \  assert_valid_string(b)\n  result = []\n  a.split('').each_with_index do |c,\
    \ i|\n    result << (c.to_i ^ b[i].to_i).to_s\n  end\n  result.join('')\nend",
  "\ta.to_i(2) ^ b.to_i(2)\nend", "  # 0 is false and 1 is true.\n  # Not the same\
    \ as 1 == True and 0 == False\n  a.each_char.zip(b.each_char).map do |x, y|\n\
    \    if x == y\n      '0'\n    else\n      '1'\n    end\n  end.join\nend", " \
    \ raise 'Inputs must be the same length' unless a.length == b.length\n  (0...a.length).map\
    \ { |i| a[i] == b[i] ? '0' : '1' }.join\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
