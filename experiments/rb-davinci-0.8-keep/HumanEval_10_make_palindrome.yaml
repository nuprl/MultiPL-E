name: HumanEval_10_make_palindrome
language: rb
prompt: "# Find the shortest palindrome that begins with a supplied string.\n# Algorithm\
  \ idea is simple:\n# - Find the longest postfix of supplied string that is a palindrome.\n\
  # - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n# >>> make_palindrome('')\n# ''\n# >>> make_palindrome('cat')\n\
  # 'catac'\n# >>> make_palindrome('cata')\n# 'catac'\ndef make_palindrome(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_make_palindrome\n\
  \    candidate = method(:make_palindrome)\n    assert_equal(\"\", candidate.call(\"\
  \"))\n    assert_equal(\"x\", candidate.call(\"x\"))\n    assert_equal(\"xyzyx\"\
  , candidate.call(\"xyz\"))\n    assert_equal(\"xyx\", candidate.call(\"xyx\"))\n\
  \    assert_equal(\"jerryrrej\", candidate.call(\"jerry\"))\n  end\nend\n"
completions: ["  return string if string.empty?\n  len = string.length\n  stack =\
    \ [string]\n  while stack.any?\n    str = stack.pop\n    return string + str.reverse\
    \ if is_palindrome?(str)\n    stack << str[1..-1]\n  end\nend", '  return string
    if string.empty?', "  return string if string.length < 2\n  start_index = 0\n\
    \  max_length = 0\n  0.upto(string.length - 1) do |index|\n    # Odd palindrome.\n\
    \    # Check if the char at current index is a centre char of the palindrome.\n\
    \    # Move the start and end indices away from the centre and check\n    # if\
    \ the chars at start and end are the same.\n    # Keep moving the indices until\
    \ mismatch or the start index becomes less\n    # than 0 which means we are at\
    \ the start of the string.\n    left_index = index - 1\n    right_index = index\
    \ + 1\n    while left_index >= 0 && right_index < string.length && string[left_index]\
    \ == string[right_index]\n      left_index -= 1\n      right_index += 1\n    end\n\
    \    # We found a palindrome. Adjust the start_index and max_length.\n    if right_index\
    \ - left_index - 1 > max_length\n      start_index = left_index + 1\n      max_length\
    \ = right_index - left_index - 1\n    end\n    # Even palindrome.\n    # Check\
    \ if the current and next chars are the same.\n    # If so, move the start and\
    \ end indices away from the current index.\n    # Keep moving the indices until\
    \ mismatch or the start index becomes less\n    # than 0 which means we are at\
    \ the start of the string.\n    left_index = index\n    right_index = index +\
    \ 1\n    while left_index >= 0 && right_index < string.length && string[left_index]\
    \ == string[right_index]\n      left_index -= 1\n      right_index += 1\n    end\n\
    \    # We found a palindrome. Adjust the start_index and max_length.\n    if right_index\
    \ - left_index - 1 > max_length\n      start_index = left_index + 1\n      max_length\
    \ = right_index - left_index - 1\n    end\n  end\n  # Find the prefix of the string\
    \ that comes before the longest palindromic suffix.\n  string[0..start_index -\
    \ 1] + string + string[start_index - 1..-1].reverse\nend", "  string.size.downto(0)\
    \ do |i|\n    pal = string[i..-1]\n    return string + pal.reverse if pal == pal.reverse\n\
    \  end\nend", "  string.reverse + longest_palindrome_of_suffix(string)\nend",
  "    return string if is_palindrome?(string)\n    # Find the largest palindromic\
    \ suffix.\n    tail = string.length - 1\n    while tail >= 0 && !is_palindrome?(string[0..tail])\n\
    \        tail -= 1\n    end\n    return string + string[0..tail].reverse\nend",
  "  if string.length <= 1\n    return string\n  end", "  return string if string.length\
    \ <= 1\n  longest_palindrome_suffix_length = find_longest_palindrome_suffix_length(string)\n\
    \  string + string[0..-longest_palindrome_suffix_length-1].reverse\nend", "  return\
    \ string if palindrome?(string)\n  (1..string.length).each do |i|\n    return\
    \ string + string[0..(string.length - i - 1)].reverse if palindrome?(string[i..-1])\n\
    \  end\nend", '  return string if string.length <= 1', "    # Find the length\
    \ of the longest palindromic suffix of the string.\n    # For example, if the\
    \ string is abcdedcba, the largest palindromic suffix is abcdedcba.\n    # The\
    \ largest palindromic suffix can be found in O(n) time.\n    suffix_len = longest_palindromic_suffix(string)\n\
    \    return string + string[0...(string.length - suffix_len)].reverse\nend", " \
    \ return '' if string.empty?\n  return string if string.length == 1", "  return\
    \ '' if string.empty?\n  # ...\nend", "  if is_palindrome(string)\n    return\
    \ string\n  end\n  string_reversed = string.reverse\n  long = postfix(string)",
  "  return string if string.length <= 1\n  last_palindrome_length = 0\n  (1..string.length).reverse_each\
    \ do |substring_length|\n    substring = string[-substring_length..-1]\n    next\
    \ unless substring == substring.reverse\n    last_palindrome_length = substring_length\n\
    \    break\n  end\n  return string if last_palindrome_length == string.length\n\
    \  string + string[0..-last_palindrome_length - 1].reverse\nend", '  return string
    if string.empty?', "  return string if string.length <= 1\n  length = string.length\n\
    \  0.upto(length - 1) do |i|\n    suffix = string[i..length]\n    return string\
    \ + string[0...i].reverse if suffix == suffix.reverse\n  end\nend", '  return
    string if string.length <= 1', "  longest_palindrome_end = longest_palindrome_suffix(string)\n\
    \  string[longest_palindrome_end + 1..-1].reverse + string\nend", "  n = string.length\n\
    \  reversed_string = string.reverse\n  for i in 0..n\n    if string[0..n-i-1]\
    \ == reversed_string[i..n-1]\n      return string + reversed_string[0..i-1]\n\
    \    end\n  end\nend", '  return string if string.length <= 1', "  # Pre-condition:\
    \ String must be non-empty.\n  raise RuntimeError, 'String must be non-empty.'\
    \ if string.length.zero?", "  return string if string.empty?\n  return string\
    \ * 2 if string.length == 1\n  palindrome_suffix = string\n  loop do\n    break\
    \ if palindrome_suffix.length == 1\n    return string + reverse(string[0...-(palindrome_suffix.length)])\
    \ if palindrome?(palindrome_suffix)\n    palindrome_suffix = palindrome_suffix[1..-1]\n\
    \  end\nend", "    return '' if string.empty?\n    return string if palindrome?(string)\n\
    \    return make_palindrome(string[0..-2]) + string[-1]\nend", "    if string.empty?\n\
    \        return string\n    end\n    reverse_string = string.reverse\n    prefix\
    \ = reverse_string[string.length..-1]\n    \"#{string}#{prefix}\"\nend", "  #\
    \ Find the longest postfix of the string that is a palindrome.\n  # Iterate over\
    \ the string.\n  (0...string.length).each do |i|\n    # Take the postfix of the\
    \ string that is not longer than the remaining part of the string.\n    postfix\
    \ = string[i...string.length]\n    # If the postfix is a palindrome, return the\
    \ prefix of the string + postfix + reverse of the prefix.\n    return string +\
    \ postfix.reverse if is_palindrome?(postfix)\n  end\nend", "  postfix = is_palindrome?(string)\
    \ ? string : palindromic_postfix(string)\n  string + reverse(string[0..(string.length\
    \ - postfix.length - 1)])\nend", "  return string if string.length <= 1\n  longest_palindrome_index\
    \ = (0..string.length).to_a.reverse.find { |index| string[0..index] == string[0..index].reverse\
    \ }\n  string + string[longest_palindrome_index..-1].reverse\nend", "  #return\
    \ string if string.empty?\n  suffix = suffix_palindrome(string)\n  string + suffix.reverse\n\
    end", "  palindrome_suffix = longest_palindrome_suffix(string)\n  string_prefix\
    \ = string[0...(string.length - palindrome_suffix.length)]\n  string_prefix +\
    \ palindrome_suffix + string_prefix.reverse\nend", "  rev = string.reverse\n \
    \ prefix_len = string.length - 1\n  while prefix_len >= 0\n    if string[0..prefix_len]\
    \ == rev[rev.length - prefix_len - 1..rev.length - 1]\n      return string + rev[0..rev.length\
    \ - prefix_len - 2]\n    end\n    prefix_len -= 1\n  end\n  ''\nend", "  return\
    \ string if string.size < 2\n  # Find the longest palindromic substring that ends\
    \ at string[-1]\n  len = 0\n  while len < string.size\n    if string[-len-1] ==\
    \ string[-1] && string[-len-1, len+1] == string[-len-1, len+1].reverse\n     \
    \ break\n    end\n    len += 1\n  end\n  # Now, string[-len-1, len+1] is the longest\
    \ palindromic substring that ends at string[-1]\n  # The string prefix that comes\
    \ before the palindromic suffix is string[0, string.size-len-1]\n  # Append the\
    \ reverse of it to the end of the string\n  string + string[0, string.size-len-1].reverse\n\
    end", "  return '' if string.empty?\n  palindrome_suffix = get_longest_palindrome_suffix(string)\n\
    \  palindrome_prefix = palindrome_suffix[0...string.length - palindrome_suffix.length].reverse\n\
    \  string + palindrome_prefix\nend", "  return string if string.empty?\n  return\
    \ string if palindrome?(string)\n  return string + string.reverse unless string.length\
    \ < 2\n  return string + string[0..-3].reverse unless palindrome?(string[0..-2])\n\
    \  string + string[0..-3].reverse\nend", "  return string if string.length < 2\n\
    \  if palindrome?(string)\n    return string\n  else\n    reversed_prefix = string[0..(string.length/2-1)].reverse\n\
    \    return string + reversed_prefix\n  end\nend", "  # Array to be returned.\n\
    \  char_array = string.chars", "  if string.length == 0\n    return string\n \
    \ end\n  # \u0441\u0442\u0440\u043E\u043A\u0430 \u043F\u0435\u0440\u0435\u0432\
    \u0435\u0440\u043D\u0443\u0442\u0430\u044F \u043D\u0430\u043E\u0431\u043E\u0440\
    \u043E\u0442\n  reversed_str = string.reverse", "  return string if string.size\
    \ < 2\n  if is_palindrome?(string)\n    return string\n  end\n  string.size.downto(1)\
    \ do |n|\n    if is_palindrome?(string[string.size - n, n])\n      if string.size\
    \ == n\n        return string.reverse + string\n      else\n        return string\
    \ + string[0, string.size - n].reverse\n      end\n    end\n  end\nend", "  string_length\
    \ = string.length\n  longest_suffix_palindrome_length = 0\n  string_length.times\
    \ do |i|\n    suffix = string[i..string_length - 1]\n    longest_suffix_palindrome_length\
    \ = suffix.length if suffix == suffix.reverse && suffix.length > longest_suffix_palindrome_length\n\
    \  end\n  longest_suffix_palindrome_length == string_length ? string : string\
    \ + string[0..string_length - longest_suffix_palindrome_length - 1].reverse\n\
    end", "    return string if is_palindrome?(string)\n    longest_suffix = get_longest_palindromic_suffix(string)\n\
    \    rest = string[0, string.length - longest_suffix.length]\n    rest.reverse\
    \ + string\nend", "  string = string.split('')\n  i = string.length\n  while i\
    \ > 0\n    if is_palindrome(string[0..i-1])\n      return string.concat(string[0..i-2].reverse).join\n\
    \    end\n    i -= 1\n  end\n  return ''\nend", '  return string if string.length
    <= 1', "  reversed_prefix = string.reverse\n  postfix = find_postfix(string)\n\
    \  string + reversed_prefix[0..reversed_prefix.length - postfix.length - 1]\n\
    end", "  return string if string.length <= 1\n  palindrome_suffix = find_longest_palindrome_suffix(string)\n\
    \  palindrome_prefix = string[0..(string.length - palindrome_suffix.length - 1)].reverse\n\
    \  palindrome_prefix + string + palindrome_prefix\nend", "  return string if palindrome?(string)\n\
    \  string += reverse(string[0...(string.length - palindrome_postfix_length(string))])\n\
    end", "  len = string.length\n  1.upto(len).each do |i|\n    if string[len - i,\
    \ i] == string[len - i, i].reverse\n      return string + string[0, len - i].reverse\n\
    \    end\n  end\n  string + string.reverse\nend", "  return string if string.length\
    \ <= 1\n  string_reverse = string.reverse\n  string_doubled = string + '$' + string_reverse\n\
    \  lps = []\n  k = 0\n  0.upto(string_doubled.length-1) do |i|\n    if i == 0\n\
    \      lps[i] = 0\n    else\n      k = lps[i-1]\n      while k > 0 && string_doubled[i]\
    \ != string_doubled[k]\n        k = lps[k-1]\n      end\n      if string_doubled[i]\
    \ == string_doubled[k]\n        k += 1\n      end\n      lps[i] = k\n    end\n\
    \  end\n  string + string_reverse[lps[-1]..-1]\nend", "  return string if palindrome?(string)\n\
    \  # Find the longest postfix of supplied string that is a palindrome.\n  suffix\
    \ = longest_palindrome_suffix(string)\n  # Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n  string + string[0...-suffix.length].reverse\n\
    end", "  return string if string.size <= 1\n  palindrome_postfix =\n    string.size.downto(1).each_with_object('')\
    \ do |size, postfix|\n      break postfix if is_palindrome?(string[0..size])\n\
    \    end\n  string + reverse(string[0..-(palindrome_postfix.size + 1)])\nend",
  "  longest_palindrome_suffix = _longest_palindrome_suffix(string)\n  return string\
    \ if longest_palindrome_suffix == string\n  string + string[0...-longest_palindrome_suffix.length].reverse\n\
    end", "  palindrome_suffix = ''\n  index = 0\n  while index < string.length\n\
    \    palindrome_suffix = palindrome_suffix + string[index]\n    if palindrome?(palindrome_suffix)\n\
    \      return string + reverse(string[0..index - 1])\n    end\n    index += 1\n\
    \  end\n  return string + reverse(string)\nend", "  return string if string.length\
    \ <= 1\n  candidate = string[0..-2]\n  while !is_palindrome(candidate)\n    candidate\
    \ = candidate[0..-2]\n  end\n  string[-candidate.length-1..-1] + string\nend",
  "    return string if is_palindrome?(string)\n    if is_palindrome?(string[1..-1])\n\
    \        return string + string[0]\n    end\n    offset = get_offset(string)\n\
    \    return string + reverse(string[0..offset])\nend", "  p = find_palindrome(string)\n\
    \  p + reverse(string[0, string.length - p.length])\nend", "  len = string.length\n\
    \  if len == 0\n    return string\n  end\n  i = 0\n  j = len - 1\n  max_palin_len\
    \ = 0\n  max_palin_start = 0\n  while i < j\n    palin_len = 0\n    palin_start\
    \ = i\n    while string[i] == string[j]\n      palin_len += 1\n      i += 1\n\
    \      j -= 1\n      if i >= j\n        break\n      end\n    end\n    if palin_len\
    \ > max_palin_len\n      max_palin_len = palin_len\n      max_palin_start = palin_start\n\
    \    end\n    i = palin_start + 1\n    j = len - i\n  end\n  if max_palin_len\
    \ == len\n    return string\n  end\n  prefix = string[0..max_palin_start - 1]\n\
    \  suffix = string[max_palin_start + max_palin_len..len - 1]\n  prefix.reverse\
    \ + string + suffix\nend", "  return string if string.length < 2\n  string.reverse!\n\
    \  2.upto(string.length).each do |i|\n    if string[0..i-1] == string[i..string.length-1]\n\
    \      string << string[0..i-2]\n      break\n    end\n  end\n  string\nend",
  "  counter = 0\n  while string[counter] == string[counter - 1] && counter > 0\n\
    \    counter -= 1\n  end\n  string + string[0..counter - 1].reverse\nend", " \
    \ return string if palindrome?(string)\n  return string[0] if string.length ==\
    \ 1\n  return string[0] if palindrome?(string[1..-1])\n  longest_palindrome_suffix\
    \ = find_longest_palindrome_suffix(string)\n  prefix = string[0..-(longest_palindrome_suffix.length\
    \ + 1)]\n  prefix.reverse + string\nend", "  if string.empty?\n    ''\n  else\n\
    \    lps = longest_palindromic_suffix(string)\n    return string if lps == string\n\
    \    string + string[0..lps.length-2].reverse\n  end\nend", '  return string if
    string.length <= 1', "  string.length.downto(0) do |length|\n    prefix = string[0...length]\n\
    \    suffix = string[-length..-1]\n    if prefix == suffix\n      return string\
    \ + prefix.reverse[1..-1]\n    end\n  end\nend", "  if string.empty?\n    string\n\
    \  else\n    longest_palindrome_at_end(string) + string.reverse[0...string.length\
    \ - longest_palindrome_at_end(string).length]\n  end\nend", "  # Find the longest\
    \ postfix of supplied string that is a palindrome.\n  suffix = ''\n  (string.length\
    \ - 1).downto(0) do |i|\n    suffix = string[i..-1]\n    break if is_palindrome?(suffix)\n\
    \  end", "  return string if palindrome?(string)\n  (string.length - 1).downto(0)\
    \ do |index|\n    palindrome = string[index..-1]\n    return string + palindrome.reverse\
    \ if palindrome?(palindrome)\n  end\nend", "  palindrome = nil\n  for i in (0..string.length)\n\
    \    postfix = string[i..-1]\n    palindrome = postfix if palindrome_check(postfix)\n\
    \  end\n  string + palindrome.reverse[string.length..-1]\nend", "  prefix = find_palindrome_prefix(string)\n\
    \  prefix.nil? ? string + string.reverse : string + prefix.reverse\nend", "  if\
    \ string.size <= 1\n    return string\n  end", "  prefix = postfix = string\n\
    \  until postfix.empty?\n    return prefix.reverse + string if postfix == postfix.reverse\n\
    \    postfix = postfix[1..-1]\n    prefix = prefix[0..-2]\n  end\n  postfix =\
    \ prefix.reverse + string\nend", "  if string.nil? || string.length < 2\n    return\
    \ string\n  end", "  return '' if string.empty?\n  reversed_string = string.reverse\n\
    \  len = string.length\n  i = 0\n  while i < len\n    prefix = string[0..i]\n\
    \    if reversed_string.end_with?(prefix)\n      return string + reversed_string[0...len\
    \ - prefix.length]\n    end\n    i += 1\n  end\nend", "  if string.empty?\n  \
    \  return string\n  end", "    return string if string.length == 0\n    return\
    \ string + string.reverse if string.length == 1\n    return string if string ==\
    \ string.reverse\n    max_len = (string.length / 2).floor\n    palindrome_prefix_length\
    \ = find_palindrome_prefix_length(string, max_len)\n    (string[palindrome_prefix_length..-1]\
    \ + string[0...palindrome_prefix_length].reverse)\nend", "  return string if string.empty?\n\
    \  n = string.length\n  palindrome_idx = 0\n  n.times do |i|\n    if (palindrome?(string[0..i]))\n\
    \      palindrome_idx = i\n    end\n  end\n  string[0..palindrome_idx] + string[0..palindrome_idx].reverse\n\
    end", "  (find_palindrome_postfix(string) + string.reverse[find_palindrome_postfix(string).length..-1]).reverse\n\
    end", "  max = 0\n  max_center = 0\n  # Find the longest palindromic postfix of\
    \ the given string.\n  (0..string.length - 1).each do |i|\n    center = string.length\
    \ - 1 - i\n    # Don't step further than half of the string.\n    # If a new center\
    \ will be located on the left from the center of a current palindrome,\n    #\
    \ then the new palindrome will be smaller than the current one.\n    if center\
    \ >= max\n      expand_palindrome(string, center, center, max)\n      expand_palindrome(string,\
    \ center, center + 1, max)\n    end\n  end\n  # The palindromic postfix starts\
    \ at this position.\n  max_center -= max\n  # Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n  string\
    \ + string[0..max_center - 1].reverse\nend", "  i = string.length\n  while i >\
    \ 0\n    suffix = string[-i..-1]\n    if suffix == suffix.reverse\n      return\
    \ string + string[0...string.length - i].reverse\n    end\n    i -= 1\n  end\n\
    \  return string + string.reverse\nend", "  # find the longest postfix that is\
    \ a palindrome\n  i = 0\n  longest_postfix = ''\n  while i < string.length\n \
    \   postfix = string[i..-1]\n    if is_palindrome(postfix) && postfix.length >\
    \ longest_postfix.length\n      longest_postfix = postfix\n    end\n    i += 1\n\
    \  end", "  return '' if string.nil? or string.empty?\n  length = string.length\n\
    \  return string if is_palindrome?(string)\n  for i in (0..length/2).to_a\n  \
    \  return (string.slice!(0, length - i) + string.reverse) if is_palindrome?(string)\n\
    \  end\nend", "  string.reverse + (string.length > 1 ? string[string.length -\
    \ find_longest_palindrome_postfix(string):string.length].reverse : '')\nend",
  "  # find a substring that is a palindrome\n  string = \"z\" + string + \"z\"\n\
    \  # initialize the output string with string reversed\n  output = string.reverse.sub(/z+$/,\
    \ '')\n  for i in 0...string.length\n    for j in (i+1)...string.length\n    \
    \  # check to see if the substring from i to j is a palindrome\n      if is_palindrome(string[i..j])\n\
    \        # string from i to j is a palindrome, so don't include it in reverse\
    \ prefix\n        output = string[0..i-1].reverse + string[i..j] + output\n  \
    \      return output\n      end\n    end\n  end\n  return output\nend", "  if\
    \ string.empty?\n    string\n  else\n    string + (string[0...(string.length -\
    \ 1) - longest_palindrome_suffix(string)].reverse)\n  end\nend", "  palindrome\
    \ = string + '$' + string.reverse\n  l = z_algorithm(palindrome)\n  new_length\
    \ = l.size - l.last - 1\n  string[new_length..-1] + string\nend", "  # We check\
    \ if string is palindrome first.\n  return string if string == string.reverse\n\
    \  # Go through string in reverse order and find the longest palindromic suffix.\n\
    \  suffix = ''\n  string.reverse.each_char do |char|\n    suffix = char + suffix\n\
    \    break if string.start_with?(suffix)\n  end\n  # Append to string reverse\
    \ of the prefix that comes before the palindromic suffix.\n  string + suffix.reverse\n\
    end", "  postfix = longest_palindromic_suffix(string)\n  reverse_prefix = reverse_string(postfix_to_prefix(string,\
    \ postfix))\n  [string, reverse_prefix].join\nend", "  return string if string.length\
    \ <= 1\n  palindrome_suffix = string[0..-1]\n  while !is_palindrome?(palindrome_suffix)\n\
    \    palindrome_suffix = palindrome_suffix[1..-1]\n  end\n  string + reverse(string[0..-palindrome_suffix.length\
    \ - 1])\nend", "  palindrome_suffix_length = string.rindex(string.reverse)\n \
    \ return '' if palindrome_suffix_length.nil?\n  palindrome_suffix_length = string.length\
    \ - palindrome_suffix_length\n  string.reverse[0..palindrome_suffix_length-1]\
    \ + string\nend", "  return string if string.length <= 1\n  mid = string.length\
    \ / 2\n  prefix = string[0..mid-1]\n  suffix = string[mid..-1]\n  while !is_palindrome(suffix)\n\
    \    suffix = suffix[1..-1]\n  end\n  prefix.reverse + string\nend", "  string\
    \ + string[0...(string.length - lps(string))].reverse\nend", "  # Find the longest\
    \ postfix that is a palindrome.\n  until is_palindrome?(string)\n    string =\
    \ string[0...-1]\n  end\n  # Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n  return string + string[0...-string.length\
    \ / 2].reverse\nend", "  palindrome_postfix = find_palindrome_postfix(string)\n\
    \  string + reverse(string[0...(string.length - palindrome_postfix.length)])\n\
    end", "  return string if string.length < 2\n  (string.length - 1).downto(0) do\
    \ |index|\n    if is_palindrome?(string[index..-1])\n      return string + string[0...index].reverse\n\
    \    end\n  end\nend", "  reverse = string.reverse\n  i = string.size - 1\n  while\
    \ i >= 0\n    if string[0..i] == reverse[string.size - 1 - i..-1]\n      return\
    \ string + reverse[i + 1..-1]\n    end\n    i -= 1\n  end\n  return string + reverse[1..-1]\n\
    end", "  string_length = string.length\n  (string_length - 1).downto(0) do |i|\n\
    \    if string[0..i] == string[i].chr + string[0..i - 1]\n      return string\
    \ + string[0..i - 1].reverse\n    end\n  end\n  string + string.reverse\nend",
  "  return string if string.length <= 1\n  return \"#{string}#{string.reverse}\"\
    \ if is_palindrome?(string)\n  longest_suffix = string.length - 1\n  until is_palindrome?(string[longest_suffix..-1])\n\
    \    longest_suffix -= 1\n  end\n  string + string[0..longest_suffix - 1].reverse\n\
    end", "  return string if string.empty?\n  for i in 0..string.length-1\n    return\
    \ string + string[0..i-1].reverse if is_palindrome?(string[i..-1])\n  end\nend",
  "  str = string.dup\n  str << string[0...find_longest_palindrome_suffix(string)].reverse\n\
    end", "  return string if string.length <= 1\n  rev_str = string.reverse\n  length\
    \ = string.length\n  is_palindrome = false\n  i = length - 1\n  while i >= 0\n\
    \    if string[0..i] == rev_str[length - 1 - i..length - 1]\n      is_palindrome\
    \ = true\n      break\n    end\n    i -= 1\n  end\n  if is_palindrome\n    string\
    \ + rev_str[0..length - i - 2]\n  else\n    string + rev_str\n  end\nend", " \
    \ return string if string.length < 2\n  reversed_prefix = string[0..find_longest_palindromic_suffix(string)].reverse\n\
    \  string + reversed_prefix\nend", "  idx = 1\n  while idx <= string.length &&\
    \ !is_palindrome?(string[idx..-1])\n    idx += 1\n  end\n  string + string[0...-idx].reverse\n\
    end", "  string.concat(string[0...-find_longest_palindrome_suffix(string)].reverse)\n\
    end", "  return string if string.size <= 1\n  longest_palindrome = find_longest_palindrome(string)\n\
    \  if longest_palindrome == string\n    string\n  else\n    string + reverse(string[0..string.index(longest_palindrome)\
    \ - 1])\n  end\nend", "  return string if palindrome?(string)\n  string + string[0...(string.length\
    \ - 1) / 2].reverse\nend", "  string += string[0..-(longest_palindrome_prefix(string)\
    \ + 1)].reverse\nend", "  return string if string.empty?\n  string + string[0...(string.length\
    \ - find_longest_palindrome_postfix(string)).abs].reverse\nend", "  if string.length\
    \ < 2\n    return string\n  end\n  len = string.length\n  l = 0\n  r = string.length\
    \ - 1\n  while (l < r)\n    if string[l] != string[r]\n      if (l == 0)\n   \
    \     string = string[r] + string\n      else\n        string = string[0..(l-1)]\
    \ + string[r] + string\n      end\n      r = string.length - 1\n      l = 0\n\
    \    else\n      l += 1\n      r -= 1\n    end\n  end\n  return string\nend",
  "  return string if string.size <= 1\n  suff = longest_palindrome_suffix(string)\n\
    \  return string + string[0..suff-1].reverse if suff > 0\n  string + string[0..-2].reverse\n\
    end", "  return string if string.length < 2\n  string = string + 'X'\n  res =\
    \ []\n  (0..string.length).each do |substr_length|\n    substr = string[substr_length,string.length]\n\
    \    if is_palindrome(substr)\n      res << substr\n    end\n  end\n  return res.max\
    \ + res.max.reverse[1,res.max.length].chop\nend", "  palindrome_suffix = find_longest_palindrome_suffix(string)\n\
    \  prefix = string[0...string.length - palindrome_suffix.length]\n  string + prefix.reverse\n\
    end", "  string + string[0...-(longest_palindrome_postfix(string).length + 1)].reverse\n\
    end", "  return string if palindrome?(string)\n  string_array = string.split('')\n\
    \  l_index = -1\n  r_index = -1\n  mid = string_array.length / 2\n  i = mid\n\
    \  loop do\n    l_index, r_index = find_palindrome(string_array, i)\n    i -=\
    \ 1\n    break if l_index || i == -1\n  end\n  # if r_index is given then left\
    \ part of the string is a palindrome\n  unless r_index\n    l_index = -1\n   \
    \ r_index = -1\n    i = mid + 1\n    loop do\n      l_index, r_index = find_palindrome(string_array,\
    \ i)\n      i += 1\n      break if l_index || i > string_array.length\n    end\n\
    \  end\n  unless l_index\n    i = mid - 1\n    loop do\n      l_index, r_index\
    \ = find_palindrome(string_array, i)\n      i -= 1\n      break if l_index ||\
    \ i == -1\n    end\n  end\n  # string is already a palindrome\n  return string\
    \ if r_index == string_array.length\n  left_prefix = string_array[0..l_index]\n\
    \  left_prefix.reverse!\n  string_array << left_prefix\n  string_array.join('')\n\
    end", "  return string if string.length < 2\n  longest_palindrome_suffix = longest_palindrome_suffix(string)\n\
    \  # If supplied string is a palindrome - return it\n  if longest_palindrome_suffix\
    \ == string\n    return string\n  else\n    # Otherwise reverse the prefix before\
    \ the palindromic suffix and append it to the end of the string\n    return string\
    \ + string[0...(string.length - longest_palindrome_suffix.length)].reverse\n \
    \ end\nend", "  return string if string.length <= 1\n  return string + string.reverse\
    \ if string.length == 2", "  i = string.length - 1\n  while i >= 0 do\n    j =\
    \ string.length - 1\n    while j >= i do\n      if string[0..i] == string[j..-1].reverse\n\
    \        return string + string[0..i-1].reverse\n      end\n      j -= 1\n   \
    \ end\n    i -= 1\n  end\n  return string\nend", "  if string.empty?\n    return\
    \ string\n  end", "    prefix = ''\n    suffix = string.length\n    # trying to\
    \ find the longest prefix of a string that is a palindrome\n    # - iterate through\
    \ the suffixes of a string and check if the corresponding prefix is a palindrome\n\
    \    while suffix > 0 do\n        if is_palindrome(string[0..(suffix - 1)])\n\
    \            prefix = string[0..(suffix - 1)]\n            break\n        end\n\
    \        suffix -= 1\n    end\n    # if no palindromic prefix was found, then\
    \ prefix == '' and we return string + string.reverse\n    # if a palindromic prefix\
    \ was found, then prefix != '' and we return string + string[(suffix)..].reverse\n\
    \    if prefix == ''\n        return string + string.reverse\n    else\n     \
    \   return string + string[(suffix)..].reverse\n    end\nend", "  return string\
    \ if string.length <= 1\n  (string.length - 1).downto(0) do |i|\n    if is_palindrome?(string[i..-1])\n\
    \      return string + string[0..i-1].reverse\n    end\n  end\nend", "  return\
    \ string if string.size < 2\n  string << string[0..(string.size / 2)].reverse\n\
    end", "  # get the length of the supplied string\n  str_len = string.length\n\
    \  # get the reverse of the supplied string\n  reversed_string = string.reverse\n\
    \  # get the longest postfix\n  postfix = ''\n  str_len.times do |n|\n    postfix\
    \ = string[str_len - n..str_len - 1]\n    break if postfix == reversed_string[0..n\
    \ - 1]\n  end\n  # get the prefix\n  prefix = string[0..str_len - postfix.length\
    \ - 1]\n  # append the prefix to the end of the postfix\n  postfix << prefix.reverse\n\
    \  postfix\nend", "  palindrome = string.dup\n  (0..string.length-1).each do |i|\n\
    \    palindrome << string[string.length-1-i]\n  end\n  palindrome\nend", "  longest_palindrome_suffix\
    \ = find_longest_palindrome_suffix(string)\n  string[0..(-1 - longest_palindrome_suffix.length)]\
    \ +\n    string +\n    string[0..(-1 - longest_palindrome_suffix.length)].reverse\n\
    end", "  new_string = string\n  until is_palindrome?(new_string)\n    new_string\
    \ = \"#{string}#{reverse(string[0...-1])}\"\n  end\n  new_string\nend", "  string\
    \ << string[0...longest_palindrome_suffix(string).size].reverse\nend", "  return\
    \ string if string.length <= 1\n  max_pals = Hash.new\n  init_palindromes(max_pals,\
    \ string)\n  find_palindromes(max_pals, string)\n  max_pals[-1]\nend", "  reverse\
    \ = string.reverse\n  string.length.times do |index|\n    if string.end_with?\
    \ reverse[0..index]\n      prefix = string[0..-index-2]\n      return string +\
    \ prefix.reverse\n    end\n  end\n  return string + reverse\nend", "  return string\
    \ if palindrome?(string)\n  return string.reverse if string.size == 1\n  i = string.size\
    \ - 1\n  while i > 0\n    left_str = string[0..i]\n    if palindrome?(left_str)\n\
    \      prefix = string[i + 1..-1]\n      return string + prefix.reverse\n    end\n\
    \    i -= 1\n  end\nend", '  return string if string.size < 2', "  return string\
    \ if string.length < 2\n  longest_palindrome_suffix = find_longest_palindrome_suffix(string)\n\
    \  string + string[0...string.length - longest_palindrome_suffix.length].reverse\n\
    end", "  # Find the longest postfix of supplied string that is a palindrome.\n\
    \  longest_postfix = ''\n  string.length.times do |i|\n    current_substring =\
    \ string[i..-1]\n    if is_palindrome(current_substring)\n      longest_postfix\
    \ = current_substring\n      break\n    end\n  end", '  return string if string.length
    < 2', "  return string if string.length <= 1\n  suffix_length = suffix_len(string)\n\
    \  prefix = string[0...string.length - suffix_length]\n  palindrome = string +\
    \ prefix.reverse\n  palindrome\nend", "  string_length = string.length\n  min_palindrome_length\
    \ = string_length * 2\n  string_prefix = string.split('')\n  string_suffix = []\n\
    \  max_palindrome_length = 0\n  # Not optimal, of course, but works.\n  (0..string_length\
    \ - 1).each do |i|\n    string_suffix.push(string_prefix.pop)\n    # Compare prefix\
    \ with reversed suffix.\n    if string_prefix == string_suffix.reverse\n     \
    \ max_palindrome_length = string_prefix.length * 2\n      break\n    end\n  end\n\
    \  if max_palindrome_length < min_palindrome_length\n    string_prefix.concat(string_suffix.reverse)\n\
    \  end\n  return string_prefix.join\nend", '  return string if string.length <=
    1', "  if string.length < 2 || is_palindrome(string)\n    return string\n  end\n\
    \  candidate = find_palindrome_end(string)\n  candidate_length = candidate.length\n\
    \  candidate_reverse = candidate.reverse\n  if candidate_length > 0\n    palindrome\
    \ = candidate_reverse + string\n  else\n    palindrome = candidate_reverse + string\
    \ + candidate_reverse\n  end\n  return palindrome\nend", "  suffix = suffix_palindrome(string)\n\
    \  string[0..-(suffix.length + 1)].reverse + string\nend", "  reverse = string.reverse\n\
    \  (string.length - 1).downto(0) do |i|\n    if reverse[i..-1] == string[0..i]\n\
    \      return string + reverse[0...string.length - i - 1]\n    end\n  end\n  string\
    \ + reverse[1..-1]\nend", "  longest_palindrome_postfix = longest_palindrome_postfix(string)\n\
    \  return string if string.length == longest_palindrome_postfix.length\n  string\
    \ + string[0..string.length - longest_palindrome_postfix.length - 1].reverse\n\
    end", "  longest_postfix = ''\n  0.upto(string.length) do |i|\n    longest_postfix\
    \ = string[i..-1] if is_palindrome(string[i..-1])\n  end\n  string + reverse(string[0..-(longest_postfix.length\
    \ + 1)])\nend", "  length = string.length\n  for i in (0..length/2).to_a\n   \
    \ return \"#{string[0..-i-1]}#{string[0..-i-1].reverse}\" if (string[-i..-1] ==\
    \ string[-i..-1].reverse)\n  end\n  string\nend", "  raise ArgumentError, 'Input\
    \ string must be non-empty' if string.empty?\n  raise ArgumentError, 'Input string\
    \ must be non-empty' if string.nil?\n  string = string.strip\n  return string\
    \ if string.length == 1\n  return string + string.reverse if string.length ==\
    \ 2", '  return string if string.length <= 1', "  make_palindrome_helper(string,\
    \ 0, string.length - 1)\nend", "    return string if is_palindrome?(string)\n\
    \    return make_palindrome(string[0..-2]) + string[-1]\nend", "  return string\
    \ if string.size <= 1\n  string_size = string.size\n  palindrome_size = 0\n  for\
    \ i in 0..string_size-1\n    if string[0..i] == string[i..-1].reverse\n      palindrome_size\
    \ = i\n      break\n    end\n  end\n  string + string[palindrome_size+1..-1].reverse\n\
    end", "  return string if string.length <= 1\n  string_length = string.length\n\
    \  mid = string_length / 2\n  if string_length.even?\n    left_palindrome = string[0...mid]\n\
    \    right_palindrome = string[mid..-1]\n  else\n    left_palindrome = string[0...mid]\n\
    \    right_palindrome = string[mid+1..-1]\n  end\n  for i in 0..mid\n    if left_palindrome[0..mid-i-1]\
    \ == right_palindrome[i..-1]\n      if string_length.even?\n        return string\
    \ + left_palindrome[0..mid-i-1].reverse\n      else\n        return string + left_palindrome[0..mid-i-1].reverse[1..-1]\n\
    \      end\n    end\n  end\nend", "  suffix = longest_palindromic_suffix(string)\n\
    \  prefix = string[0...(string.length - suffix.length)]\n  prefix.reverse + string\n\
    end", "  len = string.length\n  # Find the last index of the longest possible\
    \ palindromic suffix.\n  last_index = (0..len-1).find { |i| string[0..i] == string[i..len-1].reverse\
    \ }\n  return string if last_index == len - 1\n  # Append the reverse of the string\
    \ prefix that came before the palindromic suffix.\n  string << string[0..last_index].reverse\n\
    end", "  suffix_length = find_longest_palindromic_suffix(string)\n  prefix = string[0...-suffix_length]\n\
    \  string + prefix.reverse\nend", "    return string if palindrome?(string)\n\
    \    make_palindrome(string[0...-1])\nend", "  # Validate arguments.\n  raise\
    \ ArgumentError, 'Wrong argument type. Expected string, but got ' + string.class.to_s\
    \ + '.' if string.class != String\n  # Find the longest palindromic suffix for\
    \ the string.\n  suffix = ''\n  string.length.times do |i|\n    suffix = string[i..-1]\n\
    \    break if is_palindrome?(suffix)\n  end\n  # Append to the string the reverse\
    \ of the string prefix that comes before the palindromic suffix.\n  string + suffix[0..(string.length\
    \ - suffix.length - 1)].reverse\nend", "  string << string[0...-largest_palindrome_suffix(string).length].reverse\n\
    end", "  string.size.downto(0) do |i|\n    return string + string[0...i].reverse\
    \ if is_palindrome?(string[i..-1])\n  end\nend", "  return string if string.size\
    \ == 0 || string.size == 1\n  if is_palindrome(string)\n    return string\n  end\n\
    \  index = 0\n  while index < string.size/2\n    if string[index] == string[-index-1]\n\
    \      index += 1\n    else\n      index -= 1\n      break\n    end\n  end\n \
    \ return string + reverse(string[0..index])\nend", "  return string if string.length\
    \ <= 1\n  # find longest palindromic suffix of string\n  suffix = longest_palindromic_suffix(string)\n\
    \  # find a part of the string that comes before the palindromic suffix\n  # and\
    \ reverse it\n  prefix = string[0...(string.length - suffix.length)].reverse\n\
    \  # append prefix to the end of the string\n  # and return it\n  string + prefix\n\
    end", "  # Your code here.\nend", "  return string if palindrome?(string)\n  #\
    \ find the longest suffix of the string that is a palindrome\n  for i in 0..string.length\
    \ - 1\n    if palindrome?(string[i..-1])\n      prefix = string[0..i-1]\n    \
    \  break\n    end\n  end\n  # append to the end reverse of the prefix\n  return\
    \ string + prefix.reverse\nend", "  # TODO: finish this function\nend", "  return\
    \ string if palindrome?(string)\n  return string+string.reverse if string.length\
    \ == 1\n  for i in (string.length-1).downto(0)\n    suffix = string[i..-1]\n \
    \   if palindrome?(suffix)\n      prefix = string[0..i-1]\n      return string+prefix.reverse\n\
    \    end\n  end\nend", "  if string.length < 2\n    return string\n  end\n  longest_palindrome_suffix_end\
    \ = longest_palindrome_suffix_end(string)\n  string + string[0..-longest_palindrome_suffix_end-2].reverse\n\
    end", "  raise ArgumentError, 'Wrong string' unless string.is_a?(String)\n  return\
    \ string if string.length == 0\n  if palindrome?(string)\n    return string\n\
    \  else\n    max_length = string.length - 1\n    (1..max_length).each do |i|\n\
    \      if palindrome?(string[-i..-1])\n        return \"#{string}#{string[0..-i-1].reverse}\"\
    \n      end\n    end\n  end\nend", "  return string if string.size < 2\n  return\
    \ string if string == string.reverse\n  postfix = find_longest_palindromic_suffix(string)\n\
    \  rev_prefix = find_rev_prefix(string, postfix)\n  string + rev_prefix\nend",
  "  string = string.dup\n  (string.length).downto(0) do |i|\n    prefix = string[0...i]\n\
    \    postfix = string[i..-1]\n    if prefix == postfix.reverse\n      string <<\
    \ prefix[0...-postfix.length].reverse\n      return string\n    end\n  end\n \
    \ return string\nend", "  length = string.length\n  length.downto(0) do |suffix_length|\n\
    \    prefix = string[0, length - suffix_length]\n    suffix = string[-suffix_length,\
    \ suffix_length]\n    return string + prefix.reverse if suffix == suffix.reverse\n\
    \  end\nend", "  if string.length <= 1\n    return string\n  end", '  return string
    if string.length <= 1', "  # Simple case for empty or one-character string.\n\
    \  return string if string.length <= 1", "  prefix = string[0..-2]\n  if is_palindrome(string)\n\
    \    string\n  else\n    string + prefix.reverse\n  end\nend", "  return string\
    \ if string.length < 2\n  return string * 2 if string.length == 2\n  return string\
    \ * 3 if string.length == 3", "  if string.empty?\n    return string\n  end",
  "  string + string[0...-palindrome_length(string)].reverse\nend", "    n = string.length\n\
    \    for i in 0..n\n        if is_palindrome(string[i, n - i])\n            return\
    \ string + string[0, i].reverse\n        end\n    end\nend", "  res = string.dup\n\
    \  res << reverse(res[0..-(palindrome_length(string)+1)])\nend", "  check_len\
    \ = 0\n  candidate = ''\n  string_len = string.length\n  while check_len < string_len\n\
    \    if is_palindrome(string[check_len..string_len])\n      candidate = string[check_len..string_len]\n\
    \    end\n    check_len += 1\n  end\n  candidate.length == string_len ? candidate\
    \ : string + string[0..(string_len - candidate.length - 1)].reverse\nend", " \
    \ return '' if string.empty?\n  longest_palindrome_suffix_size = longest_palindrome_size(string.reverse)\n\
    \  string + string[0...-(longest_palindrome_suffix_size + 1)].reverse\nend", " \
    \ # as no palindrome can have a length less than 2, if string length is less than\
    \ 2, there is nothing to do\n  return string if string.length < 2", "  reverse\
    \ = string.reverse\n  postfix = ''\n  for i in 0..string.length - 1\n    if string[0..i]\
    \ == reverse[0..i]\n      postfix = string[0..i]\n    end\n  end\n  return string\
    \ + reverse[postfix.length..reverse.length]\nend", "  len = string.length\n  return\
    \ string if len == 0\n  longest_postfix = ''\n  (0..len).each do |i|\n    postfix\
    \ = string[i..len-1]\n    if is_palindrome(postfix)\n      longest_postfix = postfix\n\
    \      break\n    end\n  end\n  return string + reverse(string[0..len-longest_postfix.length-1])\n\
    end", "  postfix = find_postfix(string)\n  prefix = string[0...-(postfix.length)]\n\
    \  \"#{prefix}#{postfix}#{prefix.reverse}\"\nend", "  return string if string.length\
    \ <= 1\n  suffix = suffix_palindrome(string)\n  (string[0..-(suffix.length + 1)].reverse\
    \ + string)\nend", "  len = string.length\n  return string if len <= 1\n  i =\
    \ 0\n  while i < len / 2\n    if string[i] != string[len - i - 1]\n      break\n\
    \    end\n    i += 1\n  end\n  return string if i == len / 2\n  return string\
    \ + string[0..len - i - 2].reverse\nend", "  n = string.length\n  i = 0\n  j =\
    \ n - 1\n  first_iteration = true\n  while true\n    if string[i] == string[j]\n\
    \      if first_iteration\n        first_iteration = false\n      else\n     \
    \   i += 1\n        j -= 1\n      end\n    else\n      i = 0\n      j = n - 2\n\
    \      n -= 1\n    end\n    break if (n == 0) || (j == 0)\n  end\n  if n == 0\n\
    \    ''\n  else\n    string + string[0..j].reverse\n  end\nend", "  # TODO: implement\
    \ this method.\nend", '  return string if string.nil? or string.empty?', "  if\
    \ string.nil? || string.empty?\n    return string\n  end", "    char_list = string.chars\n\
    \    best_i = 0\n    best_j = 0\n    longest_palindrome = 0\n    for i in 0..char_list.length-1\n\
    \        for j in i..char_list.length-1\n            if is_palindrome(char_list[i..j])\n\
    \                if j-i > longest_palindrome\n                    longest_palindrome\
    \ = j-i\n                    best_i = i\n                    best_j = j\n    \
    \            end\n            end\n        end\n    end\n    return char_list[0..best_i-1].reverse.join\
    \ + char_list.join\nend", "  return string if string.length < 2 || palindrome?(string)\n\
    \  string + reverse(string[0..-1 * suffix_length(string) - 1])\nend", "  longest_postfix\
    \ = longest_palindromic_suffix(string)\n  return string if longest_postfix ==\
    \ string\n  string + string[0...(string.length - longest_postfix.length)].reverse\n\
    end", "  return string if palindrome?(string)\n  postfix = find_postfix(string)\n\
    \  prefix = string[0..-postfix.length-1]\n  postfix + prefix.reverse\nend", " \
    \ string_len = string.length\n  right_index = string_len - 1\n  left_index = 0\n\
    \  while left_index < right_index\n    right_index = right_index - 1\n    if string[left_index]\
    \ == string[right_index]\n      left_index = left_index + 1\n    else\n      right_index\
    \ = string_len - 1\n      left_index = left_index + 1\n    end\n  end\n  sb =\
    \ string.slice(0, left_index)\n  string + sb.reverse\nend", "  string + string[0..find_postfix_palindrome(string)].reverse\n\
    end", "  postfix = palindromic_postfix(string)\n  prefix = postfix.reverse\n \
    \ prefix + string + postfix\nend", '  return string if string.empty?', "  if string.length\
    \ < 2\n    return string\n  end\n  suffix = suffix_palindrome(string)\n  prefix\
    \ = string[0, string.length - suffix.length]\n  prefix.reverse + string\nend",
  "  return string if string.length <= 1\n  string_reversed = string.reverse\n  last_index\
    \ = string.length - 1\n  # From the end of the string to the beginning, find the\
    \ point where the reversed string matches the string itself\n  while last_index\
    \ > 0\n    if string[0..last_index] == string_reversed[(string.length - last_index\
    \ - 1)..-1]\n      # We found a match, return original string plus the reverse\
    \ of the prefix\n      return string + string_reversed[0..(string.length - last_index\
    \ - 2)]\n    end\n    last_index -= 1\n  end\n  # If the whole string is a palindrome,\
    \ return string itself\n  return string + string_reversed[1..-1]\nend", "  string\
    \ = string.dup\n  suffix = longest_palindrome_suffix(string)\n  prefix = reverse(string[0...-suffix.length])\n\
    \  string + prefix\nend", "  return string if string.length <= 1\n  suffix_length\
    \ = longest_palindromic_suffix(string)\n  \"#{string}#{string[0...(string.length\
    \ - suffix_length)].reverse}\"\nend", "  suffix = suffix_palindrome(string)\n\
    \  prefix = string[0..-suffix.length-1]\n  prefix.reverse + string\nend", "  return\
    \ string if palindrome?(string)\n  reverse = string.reverse\n  string += reverse.sub(string,\
    \ '')\nend", "  return '' if string.empty?\n  return string if string.size ==\
    \ 1\n  # Find the longest postfix that is palindrome.\n  # Start with full string\
    \ as a postfix.\n  # Try to reduce this postfix by 1 character in each step until\n\
    \  # the postfix is either empty or a palindrome.\n  # In this example: 'cata'\n\
    \  # 1. postfix = 'cata'\n  # 2. postfix = 'ata'\n  # 3. postfix = 'ta'\n  # 4.\
    \ postfix = 'a' -> a is a palindrome, so stop.\n  postfix = string\n  loop do\n\
    \    break if postfix.empty? || is_palindrome(postfix)\n    postfix = postfix[0..-2]\n\
    \  end\n  # Reverse the prefix that precedes the palindromic postfix and\n  #\
    \ append it to the end of the supplied string.\n  # In this example: 'catac'\n\
    \  string + reverse(string[0..-(postfix.size + 1)])\nend", "  max_length = string.length\n\
    \  while max_length > 0\n    max_length -= 1\n    if string[0..max_length] ==\
    \ string[0..max_length].reverse\n      return string + string[0..max_length].reverse[max_length..-1].reverse\n\
    \    end\n  end\n  return string + string.reverse[1..-1]\nend", '  return string
    if string.size == 0']
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
