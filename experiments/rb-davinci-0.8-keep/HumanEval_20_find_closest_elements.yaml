name: HumanEval_20_find_closest_elements
language: rb
prompt: "# From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n# other and return them in order (smaller number,\
  \ larger number).\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n\
  # (2.0, 2.2)\n# >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n# (2.0,\
  \ 2.0)\ndef find_closest_elements(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_find_closest_elements\n\
  \    candidate = method(:find_closest_elements)\n    assert_equal([3.9, 4.0], candidate.call([1.0,\
  \ 2.0, 3.9, 4.0, 5.0, 2.2]))\n    assert_equal([5.0, 5.9], candidate.call([1.0,\
  \ 2.0, 5.9, 4.0, 5.0]))\n    assert_equal([2.0, 2.2], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.2]))\n    assert_equal([2.0, 2.0], candidate.call([1.0, 2.0,\
  \ 3.0, 4.0, 5.0, 2.0]))\n    assert_equal([2.2, 3.1], candidate.call([1.1, 2.2,\
  \ 3.1, 4.1, 5.1]))\n  end\nend\n"
completions: ["  numbers.combination(2).min_by{|x,y| (x-y).abs}\nend", "\tnumbers.combination(2).min_by{|x,y|\
    \ (x-y).abs}\nend", "  index = 0\n  numbers.each do |number|\n    if number ==\
    \ numbers[index+1]\n      return [number, numbers[index+1]]\n    end\n    index\
    \ += 1\n  end\nend", "  numbers.combination(2).map { |number_one, number_two|\
    \ [number_one, number_two, (number_one - number_two).abs] }.sort_by! { |number_one,\
    \ number_two, distance| distance }.first[0..1]\nend", "  # The first and second\
    \ element should be the closest\n  closest_element_pair = [numbers[0], numbers[1]]\n\
    \  # We will iterate through each number\n  numbers.each_with_index do |number,\
    \ index|\n    # We will skip the first element because we have done it already\n\
    \    if index > 0\n      # This is a quick check to see if we have a closer pair\n\
    \      if (number - numbers[index - 1]).abs < (closest_element_pair[1] - closest_element_pair[0]).abs\n\
    \        closest_element_pair = [numbers[index - 1], number]\n      end\n    end\n\
    \  end\n  closest_element_pair\nend", "  # Write your code here\n  sorted = numbers.sort\n\
    \  first = sorted[0]\n  last = sorted[1]\n  result = [first, last]\n  for i in\
    \ 1..sorted.length-1\n    if (sorted[i]-sorted[i-1]).abs < (last-first).abs\n\
    \      result = [sorted[i-1], sorted[i]]\n    end\n  end\n  result\nend", "  \
    \  # create a new array to store pairs\n    pairs = []\n    # iterate through\
    \ the numbers\n    numbers.each_with_index do |num1, index1|\n        # iterate\
    \ through numbers again\n        numbers.each_with_index do |num2, index2|\n \
    \           # check if the num1 is not the same as num2 and that the index for\
    \ num1 is not the same as num2\n            if num1 != num2 && index1 != index2\n\
    \                # push each pair into the new array\n                pairs <<\
    \ [num1, num2]\n            end\n        end\n    end\n    # sort the array of\
    \ arrays by difference between the first and second value\n    # since we're sorting\
    \ smallest to largest we'll use the difference of first and second value\n   \
    \ # instead of the difference of second and first value\n    # ex: [a, b]  a -\
    \ b = difference, so we'll use a - b instead of b - a\n    sorted_pairs = pairs.sort_by\
    \ { |x, y| x - y }\n    # return the pair that has the smallest difference between\
    \ the first and second value\n    sorted_pairs[0]\nend", "\nend", "  m=Float::INFINITY\n\
    \  n1=0\n  n2=0\n  (0..numbers.length-2).each do |i|\n    if (numbers[i+1]-numbers[i]).abs<m\n\
    \      m=(numbers[i+1]-numbers[i]).abs\n      n1=numbers[i]\n      n2=numbers[i+1]\n\
    \    end\n  end\n  (n1,n2)\nend", '  sorted_numbers = numbers.sort', "  # TODO:\
    \ return the two closest elements\n  numbers.combination(2).map { |elem| (elem[0]\
    \ - elem[1]).abs }.min\nend", "  numbers.combination(2).min_by { |x, y| (x - y).abs\
    \ }\nend", "  diffs = []\n  (numbers.length - 1).times do |i|\n    diffs << (numbers[i\
    \ + 1] - numbers[i]).abs\n  end\n  smallest_diff = diffs.min\n  smallest_diff_index\
    \ = diffs.index(smallest_diff)\n  [numbers[smallest_diff_index], numbers[smallest_diff_index\
    \ + 1]]\nend", "  #raise Exception.new(\"Not Implemented\")\n  result = numbers.sort.combination(2).to_a.min_by\
    \ { |x, y| (x - y).abs }", "  numbers.sort\n  x = numbers.combination(2).to_a\n\
    \  p x\n  diff = x[0][1] - x[0][0]\n  result = x[0]\n  x.each do |x|\n    ndiff\
    \ = x[1] - x[0]\n    if ndiff < diff\n      diff = ndiff\n      result = x\n \
    \   end\n  end\n  p result\nend", "  numbers.combination(2).map { |e| [e.reduce(:-).abs,\
    \ e] }.min[1]\nend", "  numbers.combination(2).min_by { |a, b| (a - b).abs }\n\
    end", "  sorted_numbers = numbers.sort\n  closest_gap = sorted_numbers[1] - sorted_numbers[0]\n\
    \  closest_elements = [sorted_numbers[0], sorted_numbers[1]]\n  sorted_numbers.each_with_index\
    \ do |number, index|\n    if index != sorted_numbers.length - 1\n      gap = sorted_numbers[index\
    \ + 1] - number\n      if gap < closest_gap\n        closest_gap = gap\n     \
    \   closest_elements = [number, sorted_numbers[index + 1]]\n      end\n    end\n\
    \  end\n  closest_elements\nend", "  result = []\n  numbers.each_with_index do\
    \ |number, index|\n    next if index == numbers.length - 1\n    if (numbers[index\
    \ + 1] - number).abs < (numbers[index + 2] - number).abs\n      result << number\n\
    \      result << numbers[index + 1]\n    end\n  end\n  result\nend", "  (1..numbers.length\
    \ - 1).inject([]) do |result, i|\n    if result.empty? || (numbers[i] - numbers[i\
    \ - 1]).abs < (result[1] - result[0]).abs\n      [numbers[i - 1], numbers[i]]\n\
    \    else\n      result\n    end\n  end\nend", "  # * loop through the numbers,\
    \ find the minimum difference between two numbers\n  # * save the minimum difference\
    \ and the two numbers in a hash\n  # * return the values in the hash", "  numbers.combination(2).to_a.sort_by\
    \ { |num| (num[0] - num[1]).abs }.first\nend", "  numbers = numbers.sort\n  final_difference\
    \ = numbers[-1]\n  new_array = []\n  for i in 0..numbers.length - 2\n    difference\
    \ = numbers[i+1] - numbers[i]\n    if difference < final_difference\n      final_difference\
    \ = difference\n      new_array = [numbers[i], numbers[i+1]]\n    end\n  end\n\
    \  new_array\nend", end, "  numbers.sort!\n  numbers.each_with_index do |number,\
    \ i|\n    if i == numbers.length - 1\n      return [numbers[i - 1], numbers[i]]\n\
    \    end\n    if number == numbers[i + 1]\n      return [number, numbers[i + 1]]\n\
    \    end\n    # if i == 0\n    #   if number - numbers[i + 1] < numbers[i + 1]\
    \ - numbers[i + 2]\n    #     return [number, numbers[i + 1]]\n    #   else\n\
    \    #     return [numbers[i + 1], numbers[i + 2]]\n    #   end\n    # end\n \
    \   if number - numbers[i - 1] < numbers[i + 1] - number\n      return [numbers[i\
    \ - 1], number]\n    elsif numbers[i + 1] - number < number - numbers[i - 1]\n\
    \      return [number, numbers[i + 1]]\n    end\n  end\nend", "  closest = numbers.sort_by.with_index\
    \ { |a, b| (a - numbers[b + 1]).abs }\n  if closest[0] == closest[1]\n    return\
    \ closest[0], closest[1]\n  else\n    return closest[0], closest[1]\n  end\nend",
  "  # Get the first number and create a variable to keep track of the closest difference\n\
    \  closest_difference = numbers[0]\n  # Create a variable for the first number\n\
    \  first_number = numbers[0]\n  # Create a variable for the second number\n  second_number\
    \ = numbers[1]\n  # Create a variable to keep track of the closest numbers\n \
    \ closest_numbers = [first_number, second_number]\n  # Iterate through the numbers\n\
    \  (1..numbers.length-1).each do |i|\n    # Get the difference between the current\
    \ number and the first number\n    difference = (numbers[i] - first_number).abs\n\
    \    # If the difference is less than the closest difference\n    if difference\
    \ < closest_difference\n      # Set the closest difference to the difference\n\
    \      closest_difference = difference\n      # Set the closest numbers to the\
    \ current number and the first number\n      closest_numbers = [first_number,\
    \ numbers[i]]\n    end\n    # Set the first number to the current number\n   \
    \ first_number = numbers[i]\n  end\n  # Return the closest numbers\n  closest_numbers\n\
    end", "    num_sorted = numbers.sort\n    closest_nums = [0, 0]\n    smallest_diff\
    \ = num_sorted[-1] - num_sorted[0]\n    if num_sorted.length == 2\n        return\
    \ num_sorted[0], num_sorted[1]\n    end\n    for i in 0..num_sorted.length - 2\n\
    \        if num_sorted[i + 1] - num_sorted[i] < smallest_diff\n            smallest_diff\
    \ = num_sorted[i + 1] - num_sorted[i]\n            closest_nums[0] = num_sorted[i]\n\
    \            closest_nums[1] = num_sorted[i + 1]\n        end\n    end\n    return\
    \ closest_nums[0], closest_nums[1]\nend", "  numbers = numbers.sort\n  closest\
    \ = [numbers[0], numbers[1]]\n  diff = closest[1] - closest[0]\n  numbers.each_with_index\
    \ do |num, i|\n    next if i == 0\n    prev = numbers[i - 1]\n    if num - prev\
    \ < diff\n      closest = [prev, num]\n      diff = num - prev\n    end\n  end\n\
    \  closest\nend", "  if numbers.length < 2\n    return nil\n  end\n  smallest_diff\
    \ = numbers[1] - numbers[0]\n  low_num = numbers[0]\n  high_num = numbers[1]\n\
    \  (0..numbers.length-2).each do |num|\n    ((num+1)..numbers.length-1).each do\
    \ |num2|\n      if numbers[num2] - numbers[num] < smallest_diff\n        smallest_diff\
    \ = numbers[num2] - numbers[num]\n        low_num = numbers[num]\n        high_num\
    \ = numbers[num2]\n      end\n    end\n  end\n  return low_num, high_num\nend",
  "  numbers.combination(2).to_a.each do |x|\n    if x[0] - x[1]\n  end\nend", " \
    \   small = numbers[0]\n    large = numbers[1]\n    difference = small - large\n\
    \    difference = difference.abs", "  return numbers[0], numbers[1] if numbers.length\
    \ == 2\n  index = numbers.index(numbers.min)\n  while index == 0 || index == numbers.length\
    \ - 1\n    numbers.delete_at(index)\n    index = numbers.index(numbers.min)\n\
    \  end\n  (index - 1), (index + 1)\nend", "  if numbers[0] == numbers[1]\n   \
    \ return [numbers[0], numbers[1]]\n  end\n  numbers.each_index do |i|\n    diff\
    \ = (numbers[i+1] - numbers[i]).abs\n    if diff < 0.1\n      return [numbers[i],\
    \ numbers[i+1]]\n    end\n  end\nend", "  numbers.sort!\n  differences = {}\n\
    \  #puts numbers[0]\n  index = 0\n  while index < numbers.length-1\n    diff =\
    \ numbers[index+1] - numbers[index]\n    differences[diff] = [numbers[index],\
    \ numbers[index+1]]\n    index += 1\n  end\n  differences.sort_by{|key, value|\
    \ key}[0][1]\nend", "  # Code goes here\n  closest_elements = [numbers[0], numbers[1]]\n\
    \  i = 0\n  while i < numbers.length - 1\n    j = i + 1\n    while j < numbers.length\n\
    \      closest_elements = [numbers[i], numbers[j]] if (numbers[i] - numbers[j]).abs\
    \ < (closest_elements[0] - closest_elements[1]).abs\n      j += 1\n    end\n \
    \   i += 1\n  end\n  closest_elements\nend", '  numbers.sort!', "  numbers = numbers.sort\n\
    \  diff_hash = {}\n  closest_diff = []\n  #numbers.each_with_index do |n, i|\n\
    \  #  diff_hash[numbers[i]] = numbers[i + 1]\n  #end\n  diff_hash[numbers[0]]\
    \ = numbers[1]\n  diff_hash[numbers[-1]] = numbers[-2]\n  numbers.each_with_index\
    \ do |n, i|\n    next if numbers[i - 1].nil?\n    diff_hash[numbers[i]] = numbers[i\
    \ - 1]\n  end\n  diff_hash.each_pair do |k, v|\n    closest_diff << [k, v, (k\
    \ - v).abs]\n  end\n  #sorted_diff = closest_diff.sort_by { |x| x[2] }\n  #sorted_diff.each\
    \ do |s|\n  #  puts s.inspect\n  #end\n  sorted_diff = closest_diff.sort_by {\
    \ |x| x[2] }\n  #sorted_diff.each do |s|\n  #  puts s.inspect\n  #end\n  return\
    \ sorted_diff[0][0], sorted_diff[0][1]\nend", "  numbers.sort!\n  index = 0\n\
    \  distance = (numbers[1] - numbers[0]).abs\n  for i in 1..numbers.length-2\n\
    \    if (numbers[i+1] - numbers[i]).abs < distance\n      distance = (numbers[i+1]\
    \ - numbers[i]).abs\n      index = i\n    end\n  end\n  return numbers[index],\
    \ numbers[index+1]\nend", "  numbers.sort!\n  closest = numbers[1] - numbers[0]\n\
    \  x = numbers[0]\n  y = numbers[1]\n  for i in 0..numbers.length-2\n    new_diff\
    \ = numbers[i+1] - numbers[i]\n    if new_diff < closest\n      closest = new_diff\n\
    \      x = numbers[i]\n      y = numbers[i+1]\n    end\n  end\n  return x, y\n\
    end", "  sorted_numbers = numbers.sort\n  closest_difference = sorted_numbers[1]\
    \ - sorted_numbers[0]\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n\
    \  i = 1\n  until i == sorted_numbers.length\n    if (sorted_numbers[i] - sorted_numbers[i\
    \ - 1]).abs < closest_difference\n      closest_difference = (sorted_numbers[i]\
    \ - sorted_numbers[i - 1]).abs\n      closest_pair = [sorted_numbers[i - 1], sorted_numbers[i]]\n\
    \    end\n    i += 1\n  end\n  closest_pair\nend", "  closest_numbers = []\n \
    \ distance = 0.0\n  numbers.each_with_index do |number, index|\n    if index ==\
    \ numbers.length - 1\n      return closest_numbers\n    end\n    if distance ==\
    \ 0.0\n      distance = numbers[index + 1] - number\n      closest_numbers = [number,\
    \ numbers[index + 1]]\n    elsif (numbers[index + 1] - number).abs < distance\n\
    \      distance = (numbers[index + 1] - number).abs\n      closest_numbers = [number,\
    \ numbers[index + 1]]\n    end\n  end\n  closest_numbers\nend", "\tnumbers = numbers.sort\n\
    \tmin = 1.0/0.0\n\tmin_element = []\n\tfor i in 0..numbers.length-2\n\t\tif numbers[i+1]\
    \ - numbers[i] < min\n\t\t\tmin = numbers[i+1] - numbers[i]\n\t\t\tmin_element\
    \ = [numbers[i], numbers[i+1]]\n\t\tend\n\tend\n\treturn min_element\nend", " \
    \ result = []\n  numbers.sort!\n  numbers.each_with_index do |x,i|\n    result\
    \ << (x - numbers[i-1]).abs\n  end\n  result.sort!\n  numbers[result.index(result[0])-1,2]\n\
    end", "  pairs = []\n  min_pair = [numbers[0], numbers[1]]\n  min_diff = (numbers[0]\
    \ - numbers[1]).abs\n  for i in 0..numbers.length-2\n    for j in i+1..numbers.length-1\n\
    \      diff = (numbers[i] - numbers[j]).abs\n      if diff < min_diff\n      \
    \  min_diff = diff\n        min_pair = [numbers[i], numbers[j]]\n      end\n \
    \   end\n  end\n  min_pair\nend", "  numbers.sort!\n  smallest_difference = numbers[1]\
    \ - numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  i = 0\n  while\
    \ i < numbers.length - 1\n    difference = numbers[i + 1] - numbers[i]\n    if\
    \ difference < smallest_difference\n      smallest_difference = difference\n \
    \     closest_elements = [numbers[i], numbers[i + 1]]\n    end\n    i += 1\n \
    \ end\n  closest_elements\nend", "  last_number = numbers.first\n  closest_elements\
    \ = [numbers.first, numbers.first]\n  numbers.each do |number|\n    if closest_elements.first\
    \ == closest_elements.last\n      if (number - last_number).abs < (closest_elements.last\
    \ - closest_elements.first).abs\n        closest_elements = [last_number, number]\n\
    \      end\n    else\n      if (number - last_number).abs < (closest_elements.last\
    \ - closest_elements.first).abs\n        closest_elements = [last_number, number]\n\
    \      end\n    end\n    last_number = number\n  end\n  closest_elements\nend",
  "  numbers = numbers.sort\n  pairs = []\n  numbers.each_with_index do |num, index|\n\
    \    pairs << [(num - numbers[index + 1]).abs, num, numbers[index + 1]] if index\
    \ < numbers.length - 1\n  end\n  pairs.sort!\n  pairs[0][1, 2]\nend", "  # there\
    \ is better solution but I was short on time\n  numbers.combination(2).map { |a,\
    \ b| [a, b, (a - b).abs] }.sort_by { |a, b, c| c }.first[0..1]\nend", "  numbers.combination(2).min_by\
    \ { |x, y| (x - y).abs }\nend", "  numbers.sort!\n  diff = []\n  for i in 0..numbers.length\
    \ - 2\n    diff << (numbers[i + 1] - numbers[i]).abs\n  end\n  return numbers[diff.index(diff.min)],\
    \ numbers[diff.index(diff.min) + 1]\nend", "  index_of_smallest_difference = 0\n\
    \  smallest_difference = Float::INFINITY\n  numbers.each_with_index do |number,\
    \ index|\n    if numbers[index + 1] != nil\n      if (numbers[index + 1] - number).abs\
    \ < smallest_difference\n        smallest_difference = (numbers[index + 1] - number).abs\n\
    \        index_of_smallest_difference = index\n      end\n    end\n  end\n  [numbers[index_of_smallest_difference],\
    \ numbers[index_of_smallest_difference + 1]]\nend", "  diff = 1e20\n  ret = nil\n\
    \  numbers.each_with_index do |num1, index1|\n    index2 = index1 + 1\n    numbers[index2..-1].each\
    \ do |num2|\n      d = (num1 - num2).abs\n      if d < diff\n        diff = d\n\
    \        ret = [num1, num2]\n      end\n    end\n  end\n  ret\nend", "\t# preprocess\
    \ numbers list into array of pairs, where each pair is the distance between two\
    \ consecutive numbers\n\tdistances = []\n\ti = 0\n\twhile i < numbers.length -\
    \ 1\n\t\tdistances.push([numbers[i], numbers[i+1], numbers[i+1] - numbers[i]])\n\
    \t\ti += 1\n\tend\n\t# sort the distances list by distance, ascending\n\tdistances.sort!\
    \ { |x,y| x[2] <=> y[2] }\n\t# return the pair with the smallest distance\n\t\
    return distances[0][0..1]\nend", "  # Math.sqrt(difference)\n  # Math.sqrt(1.0\
    \ - 0.0)\n  # Math.sqrt(1.0 - 1.0)\n  # Math.sqrt(1.0 - 2.0)\n  # Math.sqrt(1.0\
    \ - 3.0)\n  # Math.sqrt(1.0 - 4.0)\n  # Math.sqrt(1.0 - 5.0)\n  # Math.sqrt(1.0\
    \ - 2.2)\n  # Math.sqrt(1.0 - 0.0)\n  # Math.sqrt(1.0 - 1.0)\n  # Math.sqrt(1.0\
    \ - 2.0)\n  # Math.sqrt(1.0 - 3.0)\n  # Math.sqrt(1.0 - 4.0)\n  # Math.sqrt(1.0\
    \ - 5.0)\n  # Math.sqrt(1.0 - 2.2)\n  # Math.sqrt(1.0 - 0.0)\n  # Math.sqrt(1.0\
    \ - 1.0)\n  # Math.sqrt(1.0 - 2.0)\n  # Math.sqrt(1.0 - 3.0)\n  # Math.sqrt(1.0\
    \ - 4.0)\n  # Math.sqrt(1.0 - 5.0)\n  # Math.sqrt(1.0 - 2.2)\n  # Math.sqrt(1.0\
    \ - 0.0)\n  # Math.sqrt(1.0 - 1.0)\n  # Math.sqrt(1.0 - 2.0)\n  # Math.sqrt(1.0\
    \ - 3.0)\n  # Math.sqrt(1.0 - 4.0)\n  # Math.sqrt(1.0 - 5.0)\n  # Math.sqrt(1.0\
    \ - 2.2)\n  # Math.sqrt(1.0 - 0.0)\n  # Math.sqrt(1.0 - 1.0)\n  # Math.sqrt(1.0\
    \ - 2.0)\n  # Math.", "  # return the two numbers that are closest to each other\n\
    \  sorted_numbers = numbers.sort\n  x = sorted_numbers[0]\n  y = sorted_numbers[1]\n\
    \  min_num = (sorted_numbers[0] - sorted_numbers[1]).abs\n  for i in 0..sorted_numbers.length\
    \ - 2\n    difference = (sorted_numbers[i] - sorted_numbers[i + 1]).abs\n    if\
    \ difference < min_num\n      min_num = difference\n      x = sorted_numbers[i]\n\
    \      y = sorted_numbers[i + 1]\n    end\n  end\n  return [x, y]\nend", "  closest\
    \ = []\n  highest = 0\n  lowest = 0\n  numbers.each do |x|\n    if x > highest\n\
    \      highest = x\n    end\n    if x < lowest\n      lowest = x\n    end\n  end\n\
    \  closest.push(lowest)\n  closest.push(highest)\n  closest\nend", "  m = numbers.sort\n\
    \  closest_elements = [m[0], m[1]]\n  min_dist = (m[1] - m[0]).abs\n  for i in\
    \ 0..m.length-2\n    for j in i+1..m.length-1\n      dist = (m[j] - m[i]).abs\n\
    \      if dist < min_dist\n        min_dist = dist\n        closest_elements =\
    \ [m[i], m[j]]\n      end\n    end\n  end\n  return closest_elements\nend", "\t\
    result_number = []\n\tnumber_one = 0\n\tnumber_two = 0\n\ti = 0\n\twhile i < numbers.length\
    \ - 1\n\t\tif number_one == 0\n\t\t\tnumber_one = numbers[i]\n\t\t\tnumber_two\
    \ = numbers[i + 1]\n\t\t\tresult_number = [number_one, number_two]\n\t\tend\n\t\
    \tif numbers[i] - numbers[i + 1] < number_one - number_two\n\t\t\tnumber_one =\
    \ numbers[i]\n\t\t\tnumber_two = numbers[i + 1]\n\t\t\tresult_number = [number_one,\
    \ number_two]\n\t\tend\n\t\ti += 1\n\tend\n\tputs \"#{result_number}\"\nend",
  "\nend", "    closest_diff = 999999999999999999999999999\n    closest_pair = nil\n\
    \    numbers.each_with_index do |number, index|\n        if index + 1 == numbers.length\n\
    \            break\n        end\n        if numbers[index + 1] - number < closest_diff\n\
    \            closest_diff = numbers[index + 1] - number\n            closest_pair\
    \ = [number, numbers[index + 1]]\n        end\n    end\n    return closest_pair\n\
    end", "  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.min[0..1]\n\
    end", "  numbers.sort!\n  closest = numbers[0]\n  # puts \"closest: #{closest}\"\
    \n  diff = numbers[1] - numbers[0]\n  # puts \"diff: #{diff}\"\n  i = 0\n  while\
    \ i < numbers.length\n    # puts \"numbers: #{numbers}\"\n    if i < numbers.length\
    \ - 1\n      curr_diff = numbers[i + 1] - numbers[i]\n      # puts \"curr_diff:\
    \ #{curr_diff}\"\n      if curr_diff < diff\n        diff = curr_diff\n      \
    \  closest = numbers[i]\n        # puts \"closest: #{closest}\"\n      end\n \
    \   end\n    i += 1\n  end\n  return closest, closest + diff\nend", "\tdifferences\
    \ = Hash.new\n\tnumbers.sort!\n\tnumbers.each_with_index do |number, index|\n\t\
    \tif index < numbers.length - 1\n\t\t\tdifferences[number] = numbers[index + 1]\
    \ - number\n\t\tend\n\tend\n\tmin_diff = differences.values.min\n\tif min_diff\
    \ == 0\n\t\treturn numbers[0], numbers[1]\n\telse\n\t\treturn differences.key(min_diff),\
    \ differences.key(min_diff) + min_diff\n\tend\nend", "  diffs = []\n  while numbers.count\
    \ > 1\n    diffs << [numbers.first, numbers.last, numbers.last - numbers.first]\n\
    \    numbers.pop\n  end\n  diffs.sort_by! { |diff| diff[2] }\n  [diffs.first[0],\
    \ diffs.first[1]]\nend", "\tnumbers.sort!\n\tlowest_diff = Float::INFINITY\n\t\
    lowest_pair = []\n\ti = 0\n\twhile i < numbers.length - 1\n\t\tif (numbers[i +\
    \ 1] - numbers[i]) < lowest_diff\n\t\t\tlowest_diff = numbers[i + 1] - numbers[i]\n\
    \t\t\tlowest_pair = [numbers[i], numbers[i + 1]]\n\t\tend\n\t\ti += 1\n\tend\n\
    \treturn lowest_pair\nend", "  d = numbers[0] - numbers[1]\n  d = d.abs\n  min\
    \ = d\n  min_index = 0\n  for i in 0..numbers.length-2\n    d = numbers[i] - numbers[i+1]\n\
    \    d = d.abs\n    if d < min\n      min = d\n      min_index = i\n    end\n\
    \  end\n  return numbers[min_index], numbers[min_index+1]\nend", "\tnumbers.sort!\n\
    \tx = 1\n\tmin = 1000\n\tl1 = []\n\tl2 = []\n\twhile x < numbers.length\n\t\t\
    if (numbers[x] - numbers[x-1]).abs < min\n\t\t\tmin = (numbers[x] - numbers[x-1]).abs\n\
    \t\t\tl1 = [numbers[x-1], numbers[x]]\n\t\t\tl2 = [numbers[x-1], numbers[x]]\n\
    \t\telsif (numbers[x] - numbers[x-1]).abs == min\n\t\t\tl1 = [numbers[x-1], numbers[x]]\n\
    \t\tend\n\t\tx += 1\n\tend\n\treturn l1\nend", "  list = numbers.sort\n  if list[-1]\
    \ == list[-2]\n    return list[-1], list[-2]\n  else\n    list.reverse\n    count\
    \ = 0\n    closest = list[0] - list[1]\n    answer = []\n    while count < list.length\
    \ - 1\n      if list[count] - list[count + 1] < closest\n        closest = list[count]\
    \ - list[count + 1]\n        answer.clear\n        answer << list[count + 1]\n\
    \        answer << list[count]\n      end\n      count += 1\n    end\n    return\
    \ answer[0], answer[1]\n  end\nend", "  numbers.combination(2).map { |a, b| [a,\
    \ b, (a - b).abs] }.min_by { |x| x[2] }[0..1]\nend", "  numbers.sort!\n  min_distance\
    \ = Float::INFINITY\n  result = []\n  numbers.each_with_index do |number, i|\n\
    \    if i < numbers.length - 1 && (number - numbers[i + 1]).abs < min_distance\n\
    \      min_distance = (number - numbers[i + 1]).abs\n      result = [number, numbers[i\
    \ + 1]]\n    end\n  end\n  result\nend", "  diffs = {}\n  numbers.each_with_index\
    \ do |x,i|\n    numbers.each_with_index do |y,j|\n      if j > i\n        diffs[[x,y]]\
    \ = (x-y).abs\n      end\n    end\n  end\n  return diffs.key(diffs.values.min)\n\
    end", "\tclosest = [numbers[0], numbers[1]]\n\ti = 0\n\twhile i < numbers.length\
    \ - 1\n\t\tif (numbers[i+1] - numbers[i]).abs < (closest[1] - closest[0]).abs\n\
    \t\t\tclosest = [numbers[i], numbers[i+1]]\n\t\tend\n\t\ti += 1\n\tend\n\treturn\
    \ closest\nend", "  # TODO: find the closest two numbers in the list\n  num =\
    \ numbers.sort\n  closest = []\n  diff = 100000000\n  (0..num.length-2).each do\
    \ |i|\n    a = num[i]\n    b = num[i+1]\n    if (b-a).abs < diff\n      closest[0]\
    \ = a\n      closest[1] = b\n      diff = (b-a).abs\n    end\n  end\n  closest\n\
    end", "  closest_pair = nil\n  closest_distance = numbers.max\n  numbers.each_with_index\
    \ do |n1, i|\n    numbers.each_with_index do |n2, j|\n      if j > i\n       \
    \ diff = (n1 - n2).abs\n        if diff < closest_distance\n          closest_distance\
    \ = diff\n          closest_pair = [n1, n2]\n        end\n      end\n    end\n\
    \  end\n  closest_pair\nend", "  numbers.minmax\nend", "\tlen = numbers.length\n\
    \tsmallest = (numbers[0] - numbers[1]).abs\n\tn1 = numbers[0]\n\tn2 = numbers[1]\n\
    \tfor i in 0..len-2\n\t\tfor j in i+1..len-1\n\t\t\tdiff = (numbers[i] - numbers[j]).abs\n\
    \t\t\tif diff < smallest\n\t\t\t\tsmallest = diff\n\t\t\t\tn1 = numbers[i]\n\t\
    \t\t\tn2 = numbers[j]\n\t\t\tend\n\t\tend\n\tend\n\tif n1 > n2\n\t\treturn n2,\
    \ n1\n\telse\n\t\treturn n1, n2\n\tend\nend", "  closest_distance = Float::INFINITY\n\
    \  closest_values = []\n  numbers.each_with_index do |num1, i|\n    numbers.each_with_index\
    \ do |num2, j|\n      if i != j\n        if (num1 - num2).abs < closest_distance\n\
    \          closest_distance = (num1 - num2).abs\n          closest_values = [num1,\
    \ num2]\n        end\n      end\n    end\n  end\n  return closest_values.sort!\n\
    end", "  new_array = numbers.combination(2).to_a\n  temp_array = []\n  new_array.each\
    \ do |i|\n    temp_array << [i[0], i[1], (i[0] - i[1]).abs]\n  end\n  min = temp_array.min_by\
    \ { |arr| arr[2] }\n  [min[0], min[1]]\nend", "  # I need to find the smallest\
    \ difference between the numbers\n  # I need to sort the numbers\n  # I need to\
    \ do a loop that looks at the difference between the current and previous number\n\
    \  # I need to find the index number of the current and previous number\n  # I\
    \ need to put the smallest differences into an array\n  # I need to sort the array\n\
    \  # I need to grab the first number from the array\n  # I need to return the\
    \ original numbers\n  smallest_difference = []\n  numbers.sort!\n  for i in 0..numbers.length\
    \ - 2\n    difference = numbers[i + 1] - numbers[i]\n    smallest_difference <<\
    \ difference\n  end\n  smallest_difference.sort!\n  number = smallest_difference[0]\n\
    \  for i in 0..numbers.length - 2\n    difference = numbers[i + 1] - numbers[i]\n\
    \    if difference == number\n      index1 = numbers.index(numbers[i])\n     \
    \ index2 = numbers.index(numbers[i + 1])\n      return \"#{numbers[index1]}, #{numbers[index2]}\"\
    \n    end\n  end\nend", "  number_length = numbers.length\n  closest_numbers =\
    \ [numbers[0], numbers[1]]\n  difference = (numbers[0] - numbers[1]).abs\n  i\
    \ = 0\n  while i < number_length - 1\n    if (numbers[i] - numbers[i + 1]).abs\
    \ < difference\n      closest_numbers = [numbers[i], numbers[i + 1]]\n      difference\
    \ = (numbers[i] - numbers[i + 1]).abs\n    end\n    i += 1\n  end\n  closest_numbers\n\
    end", "  numbers.sort!\n  minimum = numbers[1] - numbers[0]\n  closest = [numbers[0],\
    \ numbers[1]]\n  (numbers.length - 1).times do |i|\n    if numbers[i + 1] - numbers[i]\
    \ < minimum\n      minimum = numbers[i + 1] - numbers[i]\n      closest = [numbers[i],\
    \ numbers[i + 1]]\n    end\n  end\n  closest\nend", "  n = numbers.length\n  numbers_diff\
    \ = []\n  for i in 0..n-2\n    for j in i+1..n-1\n      numbers_diff << (numbers[i]\
    \ - numbers[j]).abs\n    end\n  end\n  numbers_diff = numbers_diff.sort\n  m =\
    \ numbers_diff[0]\n  for i in 0..n-2\n    for j in i+1..n-1\n      if m == (numbers[i]\
    \ - numbers[j]).abs\n        return [numbers[i], numbers[j]]\n      end\n    end\n\
    \  end\nend", "\tsorted = numbers.sort\n\tdifferences = Array.new\n\tfor i in\
    \ (0..sorted.length-2)\n\t\tdiff = sorted[i+1] - sorted[i]\n\t\tdifferences.push(diff)\n\
    \tend\n\tmin = differences.min\n\ta = numbers.index(differences.index(min) + 1)\n\
    \tb = numbers.index(differences.index(min) + 2)\n\treturn [numbers[a], numbers[b]]\n\
    end", "  dist = (numbers[0] - numbers[1]).abs\n  closest = [numbers[0], numbers[1]]\n\
    \  (numbers.length - 1).times do |i|\n    if (numbers[i] - numbers[i + 1]).abs\
    \ < dist\n      dist = (numbers[i] - numbers[i + 1]).abs\n      closest = [numbers[i],\
    \ numbers[i + 1]]\n    end\n  end\n  return closest\nend", "  numbers.combination(2).map{|x,y|\
    \ [(x-y).abs, x, y]}.min[1..2]\nend", "  closest = numbers.minmax\n  numbers.each\
    \ do |n|\n    closest = [n, n] if n == n.round\n    next if n == n.round\n   \
    \ closest = [n, n+1] if (n-n.floor).abs < (closest[0]-closest[1]).abs\n  end\n\
    \  closest\nend", "\tlow_index = 0\n\thigh_index = numbers.length - 1\n\tlow =\
    \ numbers[low_index]\n\thigh = numbers[high_index]\n\t\n\tfor i in 0..numbers.length\
    \ - 1\n\t\tif numbers[i] < low\n\t\t\tlow = numbers[i]\n\t\t\tlow_index = i\n\t\
    \tend\n\t\tif numbers[i] > high\n\t\t\thigh = numbers[i]\n\t\t\thigh_index = i\n\
    \t\tend\n\tend\n\t\n\t#swap indexes if high is before low\n\tif high_index < low_index\n\
    \t\ttemp = high_index\n\t\thigh_index = low_index\n\t\tlow_index = temp\n\tend\n\
    \t\n\t#swap back if needed (if two numbers in the same index)\n\tif low_index\
    \ == high_index\n\t\thigh_index = low_index + 1\n\tend\n\t\n\t#ensure that the\
    \ indexes are within range\n\tif low_index < 0\n\t\tlow_index = 0\n\tend\n\tif\
    \ high_index >= numbers.length\n\t\thigh_index = numbers.length - 1\n\tend\n\t\
    \n\t#initialize the current differences\n\tsmaller_index = low_index\n\tlarger_index\
    \ = high_index\n\tsmaller_difference = numbers[larger_index] - numbers[smaller_index]\n\
    \t\n\t#loop from low_index to high_index\n\tfor i in low_index..high_index\n\t\
    \t#if the absolute difference is smaller, save the current indexes\n\t\tif (numbers[larger_index]\
    \ - numbers[i]).abs < smaller_difference\n\t\t\tsmaller_index = i\n\t\t\tlarger_index\
    \ = i + 1\n\t\t\tsmaller_difference = (numbers[larger_index] - numbers[smaller_index]).abs\n\
    \t\tend\n\t\t#if the absolute difference is equal, save the current indexes if\
    \ the distance is greater\n\t\tif (numbers[larger_index] - numbers[i]).abs ==\
    \ smaller_difference\n\t\t\tif (larger_index - smaller_index) < (i + 1 -", "\t\
    # make an array of the distances between the elements\n\tdiffs = []\n\tnumbers.each_with_index\
    \ do |n, i|\n\t\tnumbers.each_with_index do |m, j|\n\t\t\t# distance between element\
    \ and itself is 0 so skip it\n\t\t\tnext if i == j\n\t\t\t# add distance to array\n\
    \t\t\tdiffs << [numbers[i], numbers[j], (n - m).abs]\n\t\tend\n\tend\n\t# select\
    \ closest pair and sort them\n\tpair = diffs.min_by{|p| p[2]}\n\treturn pair[0]\
    \ > pair[1] ? [pair[1], pair[0]] : [pair[0], pair[1]]\nend", '', "  # Simply sort\
    \ the array and check the difference between each element and its subsequent one\
    \ to find the smallest\n  # difference. This will be the pair of numbers we want\
    \ to find.\n  difference = numbers[1] - numbers[0]\n  answer = [numbers[0], numbers[1]]\n\
    \  (0..numbers.length - 2).each do |i|\n    if numbers[i + 1] - numbers[i] < difference\n\
    \      difference = numbers[i + 1] - numbers[i]\n      answer = [numbers[i], numbers[i\
    \ + 1]]\n    end\n  end\n  return answer\nend", "  numbers.combination(2).map\
    \ { |x, y| [x, y, (x - y).abs] }.sort_by { |x, y, z| z }.first[0..1]\nend", " \
    \ index = 0\n  closest_elements = [numbers[0], numbers[1]]\n  smallest_difference\
    \ = closest_elements[1] - closest_elements[0]\n  numbers.each do |element|\n \
    \   next_index = index + 1\n    numbers[next_index..-1].each do |next_element|\n\
    \      difference = (next_element - element).abs\n      if difference < smallest_difference\n\
    \        smallest_difference = difference\n        closest_elements = [element,\
    \ next_element]\n      end\n    end\n    index += 1\n  end\n  closest_elements\n\
    end", "\tresult = [numbers[0], numbers[1]]\n\tnumbers.combination(2).each do |num1,\
    \ num2|\n\t\tif (num1 - num2).abs < (result[0] - result[1]).abs\n\t\t\tresult\
    \ = [num1, num2]\n\t\tend\n\tend\n\tresult\nend", "    diffs = []\n    numbers.each_with_index\
    \ do |num, index|\n        next if index == numbers.length - 1\n        diffs\
    \ << [numbers[index], numbers[index + 1]].sort\n    end\n    closest = diffs.sort_by{|arr|\
    \ arr[1] - arr[0]}.first\n    {closest: closest, diffs: diffs}\nend", "  numbers.sort!\n\
    \  smallest_difference = numbers[-1] - numbers[0]\n  closest_elements = [numbers[0],\
    \ numbers[1]]\n  for i in 0..numbers.length-2\n    difference = numbers[i+1] -\
    \ numbers[i]\n    if difference < smallest_difference\n      smallest_difference\
    \ = difference\n      closest_elements = [numbers[i], numbers[i+1]]\n    end\n\
    \  end\n  return closest_elements\nend", "\tnumbers.sort!\n\tclosest = numbers[1]\
    \ - numbers[0]\n\tnum1 = numbers[0]\n\tnum2 = numbers[1]\n\tfor i in 0..numbers.length-2\n\
    \t\tdiff = numbers[i+1] - numbers[i]\n\t\tif diff < closest\n\t\t\tclosest = diff\n\
    \t\t\tnum1 = numbers[i]\n\t\t\tnum2 = numbers[i+1]\n\t\tend\n\tend\n\treturn num1,\
    \ num2\nend", "  closest_pair = [numbers[0], numbers[1]]\n  numbers.each do |num|\n\
    \    i = numbers.index(num)\n    next if i == numbers.length - 1\n    if (num\
    \ - numbers[i + 1]).abs < (closest_pair[0] - closest_pair[1]).abs\n      closest_pair\
    \ = [num, numbers[i + 1]]\n    end\n  end\n  closest_pair\nend", "  numbers.min_by{|i|\
    \ (i - numbers.min).abs}\n  numbers.max_by{|i| (i - numbers.max).abs}\nend", " \
    \ numbers.sort.combination(2).min_by { |a, b| (a - b).abs }\nend", "  # first\
    \ get the pair with the smallest difference.\n  # This can be done by looking\
    \ at the differences of each pair\n  # and picking the smallest one.\n  diff =\
    \ Float::INFINITY\n  numbers.sort.each_cons(2) do |x, y|\n    if (y - x).abs <\
    \ diff\n      diff = (y - x).abs\n      # puts \"diff = #{diff}, x = #{x}, y =\
    \ #{y}\"\n      x_small = x\n      y_small = y\n    end\n  end\n  [x_small, y_small]\n\
    end", "  # how can we sort the numbers smallest to largest, or largest to smallest?\n\
    \  # if we can do that, then we can have the first number always be the one we\
    \ are comparing to\n  # and then we can compare the next number to the first number\n\
    \  # we can then store the distance between the two numbers in a variable\n  #\
    \ and if the next distance is smaller, then we know that the first and second\
    \ number is the smallest distance pair\n  numbers.sort!\n  sorted_numbers = numbers\n\
    \  i = 0\n  j = 1\n  diff = (sorted_numbers[i] - sorted_numbers[j]).abs\n  while\
    \ i < sorted_numbers.length-1\n    while j < sorted_numbers.length\n      diff\
    \ = (sorted_numbers[i] - sorted_numbers[j]).abs if (sorted_numbers[i] - sorted_numbers[j]).abs\
    \ < diff\n      j += 1\n    end\n    i += 1\n    j = i + 1\n  end\n  return [sorted_numbers[i],\
    \ sorted_numbers[j-1]]\nend", "  closest_pair = [numbers[0], numbers[1]]\n  smallest_difference\
    \ = (numbers[0] - numbers[1]).abs\n  numbers.each_with_index do |number1, index1|\n\
    \    numbers.each_with_index do |number2, index2|\n      if index1 != index2\n\
    \        if (number1 - number2).abs < smallest_difference\n          closest_pair\
    \ = [number1, number2]\n          smallest_difference = (number1 - number2).abs\n\
    \        end\n      end\n    end\n  end\n  closest_pair\nend", "  min_diff = nil\n\
    \  numbers.combination(2).map do |tuple|\n    diff = (tuple[0] - tuple[1]).abs\n\
    \    if min_diff.nil? || diff < min_diff\n      min_diff = diff\n      result\
    \ = tuple\n    end\n  end\n  result\nend", "  # initialise variables\n  largestDiff\
    \ = 0.0\n  lowestNumber = 0.0\n  highestNumber = 0.0\n  currentDiff = 0.0\n  #\
    \ first loop - to get smallest and largest numbers\n  numbers.each do |x|\n  \
    \  if x < lowestNumber\n      lowestNumber = x\n    end\n    if x > highestNumber\n\
    \      highestNumber = x\n    end\n  end\n  # second loop - to get largest difference\n\
    \  numbers.each do |x|\n    if x < highestNumber\n      currentDiff = highestNumber\
    \ - x\n      if currentDiff > largestDiff\n        largestDiff = currentDiff\n\
    \      end\n    end\n  end\n  # third loop - to get numbers with largest difference\n\
    \  numbers.each do |x|\n    if x < highestNumber\n      currentDiff = highestNumber\
    \ - x\n      if currentDiff == largestDiff\n        return [x, highestNumber]\n\
    \      end\n    end\n  end\nend", "  l = numbers.length - 1\n  max_diff = 100000000\n\
    \  closest_pair = []\n  while l > 0\n    (0..l - 1).each do |i|\n      diff =\
    \ (numbers[i] - numbers[l]).abs\n      if diff < max_diff\n        max_diff =\
    \ diff\n        closest_pair = [numbers[i], numbers[l]]\n      end\n    end\n\
    \    l -= 1\n  end\n  closest_pair\nend", "\nend", "  numbers.sort!\n  closest\
    \ = (numbers[1] - numbers[0]).abs\n  i = 0\n  pairs = []\n  while i < numbers.length\
    \ - 1\n    if (numbers[i + 1] - numbers[i]).abs < closest\n      closest = (numbers[i\
    \ + 1] - numbers[i]).abs\n      pairs = [numbers[i], numbers[i + 1]]\n    end\n\
    \    i += 1\n  end\n  pairs\nend", "  numbers.sort!\n  difference = numbers[-1]\
    \ - numbers[0]\n  closest_elements = [numbers[0], numbers[1]]\n  i = 0\n  while\
    \ i < numbers.length - 1\n    current_difference = numbers[i + 1] - numbers[i]\n\
    \    if current_difference < difference\n      difference = current_difference\n\
    \      closest_elements = [numbers[i], numbers[i + 1]]\n    end\n    i += 1\n\
    \  end\n  closest_elements\nend", "  numbers.sort!\n  i = 0\n  closest = numbers[1]\
    \ - numbers[0]\n  pair = [numbers[0], numbers[1]]\n  if closest == 0\n    return\
    \ numbers[0], numbers[1]\n  end\n  while i < numbers.length - 1\n    if numbers[i\
    \ + 1] - numbers[i] < closest\n      closest = numbers[i + 1] - numbers[i]\n \
    \     pair = [numbers[i], numbers[i + 1]]\n    end\n    i += 1\n  end\n  return\
    \ pair[0], pair[1]\nend", "  # first we need to sort the array\n  smallest = []\n\
    \  numbers.each do |number|\n    number\n  end\n  # then I need to find the closest\
    \ numbers and push them into the empty array\nend", "  num = 0\n  num1 = 0\n \
    \ diff = 0\n  diff1 = 0\n  (0..numbers.length - 1).each do |i|\n    (i + 1..numbers.length\
    \ - 1).each do |j|\n      diff1 = (numbers[i] - numbers[j]).abs\n      if diff1\
    \ < diff\n        diff = diff1\n        num = numbers[i]\n        num1 = numbers[j]\n\
    \      end\n    end\n  end\n  return [num, num1]\nend", "  return [numbers[0],\
    \ numbers[1]] if numbers.length == 2\n  min_distance = numbers[1] - numbers[0]\n\
    \  min_pair = [numbers[0], numbers[1]]\n  i = 0\n  while i < numbers.length -\
    \ 1\n    if numbers[i + 1] - numbers[i] < min_distance\n      min_distance = numbers[i\
    \ + 1] - numbers[i]\n      min_pair = [numbers[i], numbers[i + 1]]\n    end\n\
    \    i += 1\n  end\n  min_pair\nend", '    closest, index1, index2 = numbers[1]
    - numbers[0], 0, 1', "  numbers = numbers.sort\n  if numbers[0] == numbers[1]\n\
    \    (numbers[0], numbers[1])\n  else\n    smallest_diff = numbers[1] - numbers[0]\n\
    \    pair = (numbers[0], numbers[1])\n    (1..numbers.length-2).each do |x|\n\
    \      if numbers[x+1] - numbers[x] < smallest_diff\n        smallest_diff = numbers[x+1]\
    \ - numbers[x]\n        pair = (numbers[x], numbers[x+1])\n      end\n    end\n\
    \    pair\n  end\nend", "  numbers.sort!\n  diff = numbers[1] - numbers[0]\n \
    \ numbers.each_with_index do |number, index|\n    unless index == 0 || index ==\
    \ numbers.length - 1\n      if (numbers[index + 1] - number) < diff\n        diff\
    \ = numbers[index + 1] - number\n      end\n    end\n  end\n  new_diff = diff\n\
    \  numbers.each_with_index do |number, index|\n    unless index == 0 || index\
    \ == numbers.length - 1\n      if (numbers[index + 1] - number) == diff\n    \
    \    return number, numbers[index + 1]\n      end\n    end\n  end\nend", "  closest_pair\
    \ = [numbers[0], numbers[1]]\n  (numbers.length - 1).times do |i|\n    (i + 1).upto(numbers.length\
    \ - 1) do |j|\n      if (numbers[i] - numbers[j]).abs < (closest_pair[0] - closest_pair[1]).abs\n\
    \        closest_pair = [numbers[i], numbers[j]]\n      end\n    end\n  end\n\
    \  closest_pair.sort\nend", "  # write your code here\nend", "  min_delta = numbers[0]\
    \ - numbers[1]\n  numbers.each_with_index do |num, idx|\n    if idx < numbers.length\
    \ - 1\n      next_num = numbers[idx + 1]\n      delta = (num - next_num).abs\n\
    \      if delta < min_delta\n        min_delta = delta\n        closest_elements\
    \ = [num, next_num]\n      end\n    end\n  end\n  closest_elements\nend", "  closest1\
    \ = numbers[0]\n  closest2 = numbers[1]\n  closest_diff = (closest1 - closest2).abs\n\
    \  numbers.each do |num1|\n    numbers.each do |num2|\n      if num1 == num2\n\
    \        next\n      end\n      diff = (num1 - num2).abs\n      if diff < closest_diff\n\
    \        closest1 = num1\n        closest2 = num2\n        closest_diff = diff\n\
    \      end\n    end\n  end\n  return [closest1, closest2]\nend", "\nend", "  raise\
    \ TypeError, \"Not a list\" unless numbers.is_a?(Array)\n  raise ArgumentError,\
    \ \"numbers is empty\" if numbers.empty?\n  raise ArgumentError, \"numbers has\
    \ only one element\" if numbers.size == 1\n  numbers.sort!\n  min = 0\n  (0..numbers.size-2).each\
    \ do |index|\n    if index == 0\n      min = numbers[index+1] - numbers[index]\n\
    \    elsif (numbers[index+1] - numbers[index]) < min\n      min = numbers[index+1]\
    \ - numbers[index]\n    end\n  end\n  numbers.combination(2).each do |combo|\n\
    \    return combo if combo[1] - combo[0] == min\n  end\nend", "  sorted_numbers\
    \ = numbers.sort\n  closest_pair = [sorted_numbers[0], sorted_numbers[1]]\n  current_closest_distance\
    \ = (sorted_numbers[1] - sorted_numbers[0]).abs\n  sorted_numbers.each_with_index\
    \ do |num, index|\n    if index < sorted_numbers.length - 1\n      next_num =\
    \ sorted_numbers[index + 1]\n      next_num_distance = (next_num - num).abs\n\
    \      if next_num_distance < current_closest_distance\n        closest_pair =\
    \ [num, next_num]\n        current_closest_distance = next_num_distance\n    \
    \  end\n    end\n  end\n  closest_pair\nend", "\tnumbers.sort!\n\tclosest = 100000\n\
    \tnumbers.each_with_index do |x, i|\n\t\tif i == 0\n\t\t\tnext\n\t\tend\n\t\t\
    if closest > (x - numbers[i-1]).abs\n\t\t\tclosest = (x - numbers[i-1]).abs\n\t\
    \t\tnums = [numbers[i-1], x]\n\t\tend\n\tend\n\tnums\nend", "  numbers.sort!\n\
    \  closest_distance = Float::INFINITY\n  closest_pair = []\n  i = 0\n  j = 1\n\
    \  while j < numbers.length\n    distance = numbers[j] - numbers[i]\n    if distance\
    \ < closest_distance\n      closest_distance = distance\n      closest_pair =\
    \ [numbers[i], numbers[j]]\n    end\n    i += 1\n    j += 1\n  end\n  closest_pair\n\
    end", "  numbers.combination(2).map { |a, b| [a, b, (a - b).abs] }.sort_by(&:last).first[0..1]\n\
    end", "  numbers.combination(2).map { |x, y| [x, y, (x - y).abs] }.min_by { |x,\
    \ y, diff| diff }[0..1]\nend", "  pair = {}\n  numbers.each do |number|\n    numbers.each\
    \ do |number2|\n      if number != number2\n        if pair.keys[0] == nil\n \
    \         pair[number] = number2\n        elsif pair.keys[0] != nil\n        \
    \  if (number - number2).abs < (pair.keys[0] - pair.values[0]).abs\n         \
    \   pair.clear\n            pair[number] = number2\n          end\n        end\n\
    \      end\n    end\n  end\n  if pair.keys[0] > pair.values[0]\n    return pair.values[0],\
    \ pair.keys[0]\n  else\n    return pair.keys[0], pair.values[0]\n  end\nend",
  "  numbers.combination(2).min_by{|e| (e[0] - e[1]).abs}.to_a\nend", "  # TODO: write\
    \ your code here\n  # numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n  # numbers =\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n  closest_pair = [numbers[0], numbers[1]]\n\
    \  smallest_difference = (numbers[0] - numbers[1]).abs\n  numbers.each_with_index\
    \ do |number, index|\n    next if index + 1 == numbers.length\n    next_number\
    \ = numbers[index + 1]\n    difference = (number - next_number).abs\n    if difference\
    \ < smallest_difference\n      smallest_difference = difference\n      closest_pair\
    \ = [number, next_number]\n    end\n  end\n  closest_pair.sort\nend", '  # BEGIN
    YOUR CODE #', "  raise Exception, \"Expected more than 2 numbers\" if numbers.length\
    \ < 2\n  difference = numbers[1] - numbers[0]\n  closest_numbers = [numbers[0],\
    \ numbers[1]]\n  (1..numbers.length-1).each do |i|\n    difference_i = numbers[i]\
    \ - numbers[i-1]\n    if difference_i < difference\n      difference = difference_i\n\
    \      closest_numbers = [numbers[i-1], numbers[i]]\n    end\n  end\n  return\
    \ closest_numbers[0], closest_numbers[1]\nend", "  require 'byebug'\n  # byebug\n\
    \  start = 0\n  finish = numbers.length - 1\n  # byebug\n  if finish - start <\
    \ 2\n    return numbers\n  end\n  # byebug\n  while finish - start > 1\n    #\
    \ byebug\n    if numbers[start+1] - numbers[start] > numbers[finish] - numbers[finish-1]\n\
    \      finish -= 1\n    else\n      start += 1\n    end\n  end\n  return [numbers[start],\
    \ numbers[finish]]\nend", "  numbers.combination(2).min_by { |x, y| (x - y).abs\
    \ }\nend", "  closest1 = numbers[0]\n  closest2 = numbers[1]\n  smallest = closest1\
    \ - closest2\n  if smallest < 0\n    smallest = -smallest\n  end\n  for i in 0..numbers.length-1\n\
    \    for j in (i+1)..numbers.length-1\n      temp = numbers[i] - numbers[j]\n\
    \      if temp < 0\n        temp = -temp\n      end\n      if temp < smallest\n\
    \        smallest = temp\n        closest1 = numbers[i]\n        closest2 = numbers[j]\n\
    \      end\n    end\n  end\n  return closest1, closest2\nend", "  numbers.map.with_index\
    \ do |num, i|\n    [i, (numbers[i + 1] - num).abs]\n  end.sort_by{|index, num|\
    \ num}.take(2).map{|index, num| numbers[index]}\nend", "  # Your code here.\n\
    \  if numbers.length < 2\n    return nil\n  end\n  numbers = numbers.sort\n  closest_one\
    \ = numbers[0]\n  closest_two = numbers[1]\n  closest_diff = (closest_one - closest_two).abs\n\
    \  for i in 0..numbers.length-2\n    for j in i+1..numbers.length-1\n      temp_diff\
    \ = (numbers[i] - numbers[j]).abs\n      if temp_diff < closest_diff\n       \
    \ closest_diff = temp_diff\n        closest_one = numbers[i]\n        closest_two\
    \ = numbers[j]\n      end\n    end\n  end\n  return [closest_one, closest_two]\n\
    end", "  two_numbers = numbers.sort!.each_cons(2).min_by{|x,y| (x-y).abs}\n  return\
    \ two_numbers\nend", "  n = numbers.sort!\n  n.each_with_index do |num, index|\n\
    \    return [num, n[index + 1]] if n[index + 1] - num == n.min_by { |num| n[index\
    \ + 1] - num }\n  end\nend", "  numbers.sort!\n  small = 0\n  large = 1\n  closest\
    \ = large - small\n  for num in 0..numbers.length-2\n    if (numbers[num+1] -\
    \ numbers[num]) < closest\n      small = num\n      large = num + 1\n      closest\
    \ = large - small\n    end\n  end\n  puts (numbers[small], numbers[large])\nend",
  "  # hm, I can't seem to make this work\n  i = 1\n  diffs = []\n  while i < numbers.length\n\
    \    diffs.push((numbers[i - 1] - numbers[i]).abs)\n    i += 1\n  end\n  index\
    \ = diffs.find_index(diffs.min)\n  [numbers[index], numbers[index + 1]]\nend",
  "  numbers.combination(2).sort_by { |a, b| (a - b).abs }.first\nend", "  sorted_numbers\
    \ = numbers.sort\n  closest_distance = numbers[1] - numbers[0]\n  closest_pair\
    \ = [numbers[0], numbers[1]]\n  for i in 1..sorted_numbers.length - 1\n    if\
    \ (sorted_numbers[i] - sorted_numbers[i - 1]) < closest_distance\n      closest_distance\
    \ = sorted_numbers[i] - sorted_numbers[i - 1]\n      closest_pair = [sorted_numbers[i\
    \ - 1], sorted_numbers[i]]\n    end\n  end\n  return closest_pair\nend", "  sorted_numbers\
    \ = numbers.sort\n  closest_elements = []\n  0.upto(sorted_numbers.length - 2)\
    \ do |idx|\n    if (sorted_numbers[idx + 1] - sorted_numbers[idx]).abs < (closest_elements[1]\
    \ - closest_elements[0]).abs || closest_elements.empty?\n      closest_elements\
    \ = [sorted_numbers[idx], sorted_numbers[idx + 1]]\n    end\n  end\n  closest_elements\n\
    end", "  numbers.sort!\n  smallest_difference = (numbers[1] - numbers[0]).abs\n\
    \  smallest_difference_pair = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |number, i|\n    if i < numbers.length - 1\n      difference = (numbers[i\
    \ + 1] - number).abs\n      if difference < smallest_difference\n        smallest_difference\
    \ = difference\n        smallest_difference_pair = [number, numbers[i + 1]]\n\
    \      end\n    end\n  end\n  smallest_difference_pair\nend", "  diff = numbers[1]\
    \ - numbers[0]\n  x = numbers[0]\n  y = numbers[1]\n  numbers.each_with_index\
    \ do |number, i|\n    (i+1...numbers.length).each do |j|\n      if ((numbers[j]\
    \ - number).abs) < diff\n        diff = (numbers[j] - number).abs\n        x =\
    \ number\n        y = numbers[j]\n      end\n    end\n  end\n  return [x, y]\n\
    end", end, "  closest_elements = [numbers[0], numbers[1]]\n  distances = []\n\
    \  numbers.each do |number|\n    distances << (number - closest_elements[0]).abs\n\
    \  end\n  smallest_distance = distances.min\n  index = distances.index(smallest_distance)\n\
    \  closest_elements[0] = numbers[index]\n  closest_elements.sort!\n  return closest_elements\n\
    end", "\t\n\tnumbers_sorted = numbers.sort\n\t\n\tmin_diff = numbers_sorted[1]\
    \ - numbers_sorted[0]\n\tmin_pair = []\n\t\n\tnumbers_sorted.each_with_index do\
    \ |num, i|\n\t\tif i < numbers_sorted.length - 1\n\t\t\tdiff = numbers_sorted[i+1]\
    \ - numbers_sorted[i]\n\t\t\tif diff < min_diff\n\t\t\t\tmin_diff = diff\n\t\t\
    \t\tmin_pair = [numbers_sorted[i], numbers_sorted[i+1]]\n\t\t\tend\n\t\tend\n\t\
    end\n\t\n\treturn min_pair\nend", "  numbers = numbers.sort\n  closest = (numbers[0]\
    \ - numbers[1]).abs\n  smallest = numbers[0]\n  largest = numbers[1]\n  for i\
    \ in 0..numbers.length - 2\n    if ((numbers[i] - numbers[i + 1]).abs) < closest\n\
    \      closest = (numbers[i] - numbers[i + 1]).abs\n      smallest = numbers[i]\n\
    \      largest = numbers[i + 1]\n    end\n  end\n  return smallest, largest\n\
    end", '  sorted_numbers = numbers.sort', "\tclosest = numbers[1] - numbers[0]\n\
    \tindex = 0\n\t2.upto(numbers.length-1) do |i|\n\t\tif (numbers[i] - numbers[i-1])\
    \ < closest\n\t\t\tclosest = numbers[i] - numbers[i-1]\n\t\t\tindex = i-1\n\t\t\
    end\n\tend\n\treturn numbers[index], numbers[index+1]\nend", "  @numbers = numbers\n\
    \  @numbers.sort!\n  @i = 0\n  while @i < @numbers.length - 1\n    @j = @i + 1\n\
    \    while @j < @numbers.length\n      @differences.push(@numbers[@j] - @numbers[@i])\n\
    \      @j += 1\n    end\n    @i += 1\n  end\n  @least_difference = @differences.min\n\
    \  @least_difference_index = @differences.index(@least_difference)\n  @smaller_of_two\
    \ = @numbers[@least_difference_index]\n  @larger_of_two = @numbers[@least_difference_index\
    \ + 1]\n  return @smaller_of_two, @larger_of_two\nend", "  # TODO your implementation\
    \ here\n  return nil if numbers.nil?\n  if numbers.length < 2\n    return numbers\n\
    \  end\n  min_diff = numbers[0] - numbers[1]\n  first = numbers[0]\n  second =\
    \ numbers[1]\n  for i in (0..numbers.length-2)\n    diff = numbers[i] - numbers[i+1]\n\
    \    if diff.abs < min_diff.abs\n      min_diff = diff\n      first = numbers[i]\n\
    \      second = numbers[i+1]\n    end\n  end\n  return (first < second) ? [first,\
    \ second] : [second, first]\nend", "\tsorted_numbers = numbers.sort", "  numbers.sort!\n\
    \  closest = [numbers[0], numbers[1]]\n  (1..numbers.length-1).each do |i|\n \
    \   if (numbers[i] - numbers[i-1]).abs < (closest[1] - closest[0]).abs\n     \
    \ closest = [numbers[i-1], numbers[i]]\n    end\n  end\n  closest\nend", "  closest\
    \ = [numbers[0], numbers[1]].sort\n  if numbers.length > 2\n    (numbers.length\
    \ - 1).times do |i|\n      diff = (numbers[i + 1] - numbers[i]).abs\n      if\
    \ diff < (closest[1] - closest[0]).abs\n        closest = [numbers[i], numbers[i\
    \ + 1]].sort\n      end\n    end\n  end\n  closest\nend", "  numbers = numbers.sort\n\
    \  diff = Float::INFINITY\n  closest = nil\n  (0...numbers.length - 1).each do\
    \ |i|\n    if (numbers[i + 1] - numbers[i]).abs < diff\n      diff = (numbers[i\
    \ + 1] - numbers[i]).abs\n      closest = [numbers[i], numbers[i + 1]]\n    end\n\
    \  end\n  closest\nend", "  numbers.sort!\n  smallest = numbers[0]\n  greatest\
    \ = numbers[0]\n  numbers.each do |x|\n    if x - smallest < smallest - greatest\n\
    \      greatest = x\n    elsif x - smallest > smallest - greatest\n      smallest\
    \ = x\n    end\n  end\n  return smallest, greatest\nend", "\tclosest_number_pair\
    \ = [numbers[0], numbers[1]]\n\tnumbers[0..-2].each_with_index do |number1, index|\n\
    \t\tif closest_number_pair[1] - closest_number_pair[0] > numbers[index + 1] -\
    \ number1\n\t\t\tclosest_number_pair = [number1, numbers[index + 1]]\n\t\tend\n\
    \tend\n\treturn closest_number_pair\nend", "    first_num = numbers[0]\n    second_num\
    \ = numbers[1]\n    numbers.each do |num|\n        if num == numbers[0] \n   \
    \         next\n        elsif num > numbers[0] && num < numbers[1]\n         \
    \   second_num = num\n        elsif num < numbers[0] && num > numbers[1]\n   \
    \         first_num = num\n        elsif num > numbers[0] && num > numbers[1]\
    \ && (num - numbers[0]) < (numbers[1] - numbers[0])\n            second_num =\
    \ num\n        elsif num < numbers[0] && num < numbers[1] && (numbers[0] - num)\
    \ < (numbers[0] - numbers[1])\n            first_num = num\n        end\n    end\n\
    \    return first_num, second_num\nend", "  if numbers.length < 2\n    puts 'You\
    \ need a list of numbers with at least two elements.'\n  else\n    i=0\n    min=numbers[i+1]-numbers[i]\n\
    \    min_pos=i\n    loop do\n      if i >= numbers.length-1\n        break\n \
    \     else\n        if numbers[i+1]-numbers[i] < min\n          min = numbers[i+1]-numbers[i]\n\
    \          min_pos = i\n        end\n        i += 1\n      end\n    end\n    puts\
    \ \"#{numbers[min_pos]}, #{numbers[min_pos+1]}\"\n  end\nend", "  closest = numbers.combination(2).map\
    \ { |a, b| (a - b).abs }.min\n  numbers.combination(2).select { |a, b| (a - b).abs\
    \ == closest }.first\nend", "  return nil if numbers.length <= 1\n  numbers.sort\n\
    \  diff = numbers[1] - numbers[0]\n  closest = [numbers[0], numbers[1]]\n  numbers.each_with_index\
    \ do |num, i|\n    if i == numbers.length - 1\n      break\n    end\n    if (numbers[i\
    \ + 1] - num) < diff\n      diff = numbers[i + 1] - num\n      closest = [num,\
    \ numbers[i + 1]]\n    end\n  end\n  closest\nend", "  indexes = numbers.size\n\
    \  closest_elements = []\n  counter = 0\n  while counter < indexes\n    closest_element_index\
    \ = 0\n    while closest_element_index < indexes\n      if counter == closest_element_index\n\
    \        closest_element_index += 1\n      else\n        difference = (numbers[counter]\
    \ - numbers[closest_element_index]).abs\n        if closest_elements.empty?\n\
    \          closest_elements << numbers[counter]\n          closest_elements <<\
    \ numbers[closest_element_index]\n          closest_elements << difference\n \
    \       elsif difference < closest_elements[2]\n          closest_elements[0]\
    \ = numbers[counter]\n          closest_elements[1] = numbers[closest_element_index]\n\
    \          closest_elements[2] = difference\n        end\n        closest_element_index\
    \ += 1\n      end\n    end\n    counter += 1\n  end\n  closest_elements\nend",
  "  numbers.sort!\n  diff = numbers[1] - numbers[0]\n  x = 0\n  y = 1\n  for i in\
    \ 0..numbers.length-2\n    if numbers[i+1] - numbers[i] < diff\n      diff = numbers[i+1]\
    \ - numbers[i]\n      x = i\n      y = i+1\n    end\n  end\n  return numbers[x],\
    \ numbers[y]\nend", "  h = {}\n  i = 0\n  while i < numbers.length\n    j = i\
    \ + 1\n    while j < numbers.length\n      h[(numbers[i] - numbers[j]).abs] =\
    \ [numbers[i], numbers[j]]\n      j += 1\n    end\n    i += 1\n  end\n  smallest_number\
    \ = h.keys.min\n  h[smallest_number]\nend", "  #>>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\n  #(2.0, 2.2)\n  #>>> find_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0])\n  #(2.0, 2.0)\n  #[1.0, 2.0, 3.0, 4.0, 5.0, 2.2]",
  "  # base case\n  raise ArgumentError if numbers.length < 2", "\tnumbers = numbers.sort\n\
    \tdifferences = []\n\tclosest = []\n\tclosest_pair = []\n\tnumbers.each_with_index\
    \ do |number, index|\n\t\tif index == 0\n\t\t\tdifferences << numbers[index +\
    \ 1] - numbers[index]\n\t\t\tclosest << numbers[index]\n\t\t\tclosest << numbers[index\
    \ + 1]\n\t\telsif index == numbers.length - 1\n\t\t\tdifferences << numbers[index]\
    \ - numbers[index - 1]\n\t\t\tclosest << numbers[index - 1]\n\t\t\tclosest <<\
    \ numbers[index]\n\t\telse\n\t\t\tdifferences << numbers[index + 1] - numbers[index]\n\
    \t\t\tdifferences << numbers[index] - numbers[index - 1]\n\t\t\tclosest << numbers[index\
    \ - 1]\n\t\t\tclosest << numbers[index]\n\t\t\tclosest << numbers[index + 1]\n\
    \t\tend\n\tend\n\tclosest_index = differences.index(differences.min)\n\tclosest_pair\
    \ << closest[closest_index]\n\tclosest_pair << closest[closest_index + 1]\n\t\
    closest_pair\nend", "  numbers.combination(2).to_a.min_by { |combo| (combo[0]\
    \ - combo[1]).abs }\nend", "  # Convert the list of numbers into a list of pairs\
    \ of numbers.\n  # This list will contain N-1 pairs of numbers, where N is the\
    \ length of the list of numbers.\n  number_pairs = numbers.each_cons(2).to_a\n\
    \  # For example, [1.0, 2.0, 3.0, 4.0, 5.0, 2.2] will convert to [[1.0, 2.0],\
    \ [2.0, 3.0], [3.0, 4.0], [4.0, 5.0], [5.0, 2.2]]", "  # TODO\nend", "  # Keep\
    \ the numbers in order\n  numbers.sort!\n  lowest_difference = numbers[1] - numbers[0]\n\
    \  closest_elements = [numbers[0], numbers[1]]\n  numbers.each_with_index do |current_number,\
    \ index|\n    # Stop checking if we are at the end of the list\n    next_number\
    \ = numbers[index + 1]\n    break if next_number.nil?\n    current_difference\
    \ = next_number - current_number\n    if current_difference < lowest_difference\n\
    \      lowest_difference = current_difference\n      closest_elements = [current_number,\
    \ next_number]\n    end\n  end\n  closest_elements\nend", "  numbers.sort!\n \
    \ smallest_difference = numbers[1] - numbers[0]\n  closest_elements = [numbers[0],\
    \ numbers[1]]\n  for i in 0..numbers.length-2\n    difference = numbers[i+1] -\
    \ numbers[i]\n    if difference < smallest_difference\n      smallest_difference\
    \ = difference\n      closest_elements = [numbers[i], numbers[i+1]]\n    end\n\
    \  end\n  return closest_elements\nend", "    numbers.sort!\n    difference_numbers\
    \ = []\n    numbers.each_cons(2) do |a, b|\n      difference_numbers << ((a -\
    \ b).abs)\n    end\n    smallest_difference = difference_numbers.min\n    numbers.each_cons(2)\
    \ do |a, b|\n      if ((a - b).abs) == smallest_difference\n        return a,\
    \ b\n      end\n    end\nend", "  numbers.combination(2).min_by { |num_1, num_2|\
    \ (num_1 - num_2).abs }\nend", "  # TODO: Your solution here\n  if numbers ==\
    \ nil\n    return nil\n  elsif numbers.length == 2\n    return (numbers[0], numbers[1])\n\
    \  else\n    first_num = numbers[0]\n    second_num = numbers[1]\n    difference\
    \ = second_num - first_num\n    i = 2\n    while i < numbers.length\n      if\
    \ (second_num - numbers[i]) < difference\n        difference = second_num - numbers[i]\n\
    \        first_num = numbers[i]\n      end\n      i += 1\n    end\n    return\
    \ first_num, second_num\n  end\nend", "  numbers = numbers.sort\n  closest = (numbers[0]\
    \ - numbers[1]).abs\n  closest_elements = [numbers[0], numbers[1]]\n  for i in\
    \ 0..numbers.length - 2\n    if (numbers[i] - numbers[i + 1]).abs < closest\n\
    \      closest = (numbers[i] - numbers[i + 1]).abs\n      closest_elements = [numbers[i],\
    \ numbers[i + 1]]\n    end\n  end\n  return closest_elements\nend", "  result\
    \ = [9999999, 9999999]\n  for i in 0..numbers.length-1\n    for j in i+1..numbers.length-1\n\
    \      difference = (numbers[i] - numbers[j]).abs\n      if difference < (result[0]\
    \ - result[1]).abs\n        result = [numbers[i], numbers[j]]\n      end\n   \
    \ end\n  end\n  result\nend", "  # this is a short answer\n  numbers.sort!.combination(2).min_by\
    \ { |pair| (pair[0] - pair[1]).abs }\n  # this is a long answer\n  # numbers.sort!\n\
    \  # closest_num = numbers[0]\n  # closest_pair = [numbers[0], numbers[1]]\n \
    \ # count = 0\n  # numbers.each do |number|\n  #   count += 1\n  #   next if count\
    \ >= numbers.length\n  #   closest_num = number if closest_num > number\n  # \
    \  closest_pair = [number, numbers[count]] if (closest_pair[0] - closest_pair[1]).abs\
    \ > (number - numbers[count]).abs\n  # end\n  # closest_pair\nend", "  # return\
    \ nil if numbers.length < 2\n  diff = (numbers[0] - numbers[1]).abs\n  return\
    \ numbers[0], numbers[1] if diff == 0\n  numbers.each_with_index do |n, i|\n \
    \   break if i == numbers.length - 1\n    next_diff = (numbers[i + 1] - n).abs\n\
    \    diff = next_diff if next_diff < diff\n  end\n  min = numbers.min\n  max =\
    \ numbers.max\n  numbers.each do |n|\n    min = n if (n - diff).abs == min\n \
    \   max = n if (n - diff).abs == max\n  end\n  return min, max\nend", "  numbers.sort!\n\
    \  max_distance = Float::INFINITY\n  rtn = []\n  for i in 0..numbers.length-2\n\
    \    first_number = numbers[i]\n    second_number = numbers[i+1]\n    distance\
    \ = second_number - first_number\n    if distance < max_distance\n      max_distance\
    \ = distance\n      rtn = [first_number, second_number]\n    end\n  end\n  return\
    \ rtn\nend", "\tsorted_numbers = numbers.sort\n\tsmaller = nil\n\tbigger = nil\n\
    \tdifference = nil\n\tsmaller_num = nil\n\tbigger_num = nil\n\tnumber_index =\
    \ 0\n\tsorted_numbers.each do |number|\n\t\t# puts number\n\t\tif number_index\
    \ == 0\n\t\t\tputs number_index\n\t\t\tputs number\n\t\t\tbigger = sorted_numbers[number_index\
    \ + 1]\n\t\t\tbigger_num = number\n\t\t\tdifference = bigger - number\n\t\t\t\
    # puts difference\n\t\telsif number_index == sorted_numbers.length - 1\n\t\t\t\
    puts \"yay\"\n\t\t\tputs number_index\n\t\t\tputs number\n\t\t\tsmaller = sorted_numbers[number_index\
    \ - 1]\n\t\t\tsmaller_num = number\n\t\telse\n\t\t\tsmaller = sorted_numbers[number_index\
    \ - 1]\n\t\t\tbigger = sorted_numbers[number_index + 1]\n\t\t\tsmaller_difference\
    \ = number - smaller\n\t\t\tbigger_difference = bigger - number\n\t\t\tif smaller_difference\
    \ < bigger_difference\n\t\t\t\tif smaller_difference < difference\n\t\t\t\t\t\
    smaller_num = number\n\t\t\t\t\tbigger_num = smaller\n\t\t\t\t\tdifference = smaller_difference\n\
    \t\t\t\tend\n\t\t\telse\n\t\t\t\tif bigger_difference < difference\n\t\t\t\t\t\
    smaller_num = number\n\t\t\t\t\tbigger_num = bigger\n\t\t\t\t\tdifference = bigger_difference\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tnumber_index += 1\n\tend\n\t# puts sorted_numbers\n\
    \treturn [smaller_num, bigger_num]\nend", "\tsmall = numbers[0]\n\tbig = numbers[1]\n\
    \tif numbers[0] > numbers[1]\n\t\tsmall = numbers[1]\n\t\tbig = numbers[0]\n\t\
    end\n\tbig_big = nil\n\tnumbers.each do |num|\n\t\tif num < small\n\t\t\tbig_big\
    \ = small\n\t\t\tsmall = num\n\t\telsif num < big\n\t\t\tbig_big = num\n\t\tend\n\
    \tend\n\treturn [small, big_big]\nend", "    # YOUR CODE HERE\nend", "  numbers.combination(2).min_by{|x,y|\
    \ (x-y).abs}.to_a\nend", "  return numbers[0], numbers[1] if numbers.length <\
    \ 2\n  diff = (numbers[0] - numbers[1]).abs\n  n1, n2 = numbers[0], numbers[1]\n\
    \  i = 0\n  while i < numbers.length - 1\n    num1, num2 = numbers[i], numbers[i\
    \ + 1]\n    if (num1 - num2).abs < diff\n      diff = (num1 - num2).abs\n    \
    \  n1, n2 = num1, num2\n    end\n    i += 1\n  end\n  [n1, n2]\nend", "  #answer\
    \ = numbers.permutation(2).to_a.map { |a, b| [a, b, (a - b).abs] }.min_by { |a,\
    \ b, distance| distance }\n  answer = numbers.permutation(2).to_a.map { |a, b|\
    \ [a, b, (a - b).abs] }.min_by { |a, b, distance| distance }[0..1]\n  answer[0]\
    \ > answer[1] ? answer.reverse : answer\nend", "  # return numbers.minmax\n  return\
    \ numbers.combination(2).min { |a, b| (a[0] - a[1]).abs <=> (b[0] - b[1]).abs\
    \ }\nend", "  i = 0\n  mini = 0\n  min = numbers[1] - numbers[0]\n  while i <\
    \ numbers.length-1\n    if numbers[i+1] - numbers[i] < min\n      min = numbers[i+1]\
    \ - numbers[i]\n      mini = i\n    end\n    i += 1\n  end\n  return numbers[mini],\
    \ numbers[mini+1]\nend", "  numbers.sort\n  pairs = numbers.combination(2).to_a\n\
    \  result = pairs.min_by { |pair| (pair[0] - pair[1]).abs }\n  if result[0] >\
    \ result[1]\n    result.reverse!\n  end\n  result\nend", "  find_closest_elements_rec(numbers).flatten\n\
    end", "  p numbers\n  numbers.sort!\n  p numbers\n  x = numbers.pop\n  y = numbers.pop\n\
    \  result = []\n  x -= y\n  numbers.each do |num|\n    p num\n    if x > num.abs\n\
    \      x = num.abs\n      result = [y,num]\n    end\n  end\n  if result.empty?\n\
    \    p x\n    result = [x,y]\n  end\n  p result\nend\nfind_closest_elements([1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2])\nfind_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n\
    find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.1])", "\tsmallest = numbers[0]\n\
    \tlargest = numbers[0]\n\tnumbers.each do |number|\n\t\tif number < smallest\n\
    \t\t\tsmallest = number\n\t\telsif number > largest\n\t\t\tlargest = number\n\t\
    \tend\n\tend\n\tsmallest = largest if smallest == largest\n\treturn smallest,\
    \ largest\nend", "    lowest = 0\n    for i in 0..numbers.length - 1\n       \
    \ for j in i + 1..numbers.length - 1\n            if (numbers[i] - numbers[j]).abs\
    \ < (numbers[lowest] - numbers[lowest + 1]).abs\n                lowest = i\n\
    \            end\n        end\n    end\n    return numbers[lowest], numbers[lowest\
    \ + 1]\nend", "  # numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n  # numbers = [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]\n  distance = 0\n  diff = numbers[1] - numbers[0]\n\
    \  pair = []\n  numbers.combination(2).to_a.each do |x|\n    if (x[1] - x[0]).abs\
    \ < diff\n      distance = x[1] - x[0]\n      pair = x\n    end\n  end\n  return\
    \ pair\nend", "  list = numbers.combination(2).to_a\n  list.sort_by! { |item|\
    \ (item[0] - item[1]).abs }\n  list[0]\nend", "\nend", "  #your code here\n  min\
    \ = []\n  numbers.each_with_index do |num, index|\n    if index == numbers.length\
    \ - 1\n      return min.sort\n    else\n      if (num - numbers[index + 1]).abs\
    \ <= (min[0] - min[1]).abs || min.empty?\n        min = [num, numbers[index +\
    \ 1]]\n      end\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
