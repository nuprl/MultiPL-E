name: HumanEval_70_strange_sort_list
language: rb
prompt: "# Given list of integers, return list in strange order.\n# Strange sorting,\
  \ is when you start with the minimum value,\n# then maximum of the remaining integers,\
  \ then minimum and so on.\n# Examples:\n# strange_sort_list([1, 2, 3, 4]) == [1,\
  \ 4, 2, 3]\n# strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n# strange_sort_list([])\
  \ == []\ndef strange_sort_list(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_strange_sort_list\n\
  \    candidate = method(:strange_sort_list)\n    assert_equal([1, 4, 2, 3], candidate.call([1,\
  \ 2, 3, 4]))\n    assert_equal([5, 9, 6, 8, 7], candidate.call([5, 6, 7, 8, 9]))\n\
  \    assert_equal([1, 5, 2, 4, 3], candidate.call([1, 2, 3, 4, 5]))\n    assert_equal([1,\
  \ 9, 5, 8, 6, 7], candidate.call([5, 6, 7, 8, 9, 1]))\n    assert_equal([5, 5, 5,\
  \ 5], candidate.call([5, 5, 5, 5]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 8, 2, 7, 3, 6, 4, 5], candidate.call([1, 2, 3, 4, 5, 6, 7,\
  \ 8]))\n    assert_equal([-5, 5, -5, 5, 0, 2, 2, 2], candidate.call([0, 2, 2, 2,\
  \ 5, 5, -5, -5]))\n    assert_equal([111111], candidate.call([111111]))\n  end\n\
  end\n"
completions: ["    n = lst.size\n    return lst if n <= 1\n    lst = lst.sort\n  \
    \  max = n.odd? ? lst[n/2 + 1] : lst[n/2]\n    (n/2).times do |i|\n        lst[2*i],\
    \ lst[2*i+1] = lst[2*i+1], lst[2*i]\n    end\n    lst.insert(1, max) if n.odd?\n\
    \    lst\nend", "    # sorted_list = lst.sort # sort the list\n    # sorted_list.each_with_index\
    \ do |item, index|\n    #     if index.even?\n    #         min = sorted_list.shift\n\
    \    #         sorted_list.unshift(min)\n    #     else\n    #         max = sorted_list.pop\n\
    \    #         sorted_list.unshift(max)\n    #     end\n    # end\n    # sorted_list\n\
    \    # or\n    lst.sort { |a, b| lst.index(a).even? ? a <=> b : b <=> a }\nend",
  "  lst.sort { |a, b| a <=> b }.inject([]) { |result, i| result.insert(-2, i) }\n\
    end", "  sorted = []\n  until lst.empty?\n    min = lst.min\n    max = lst.max\n\
    \    sorted << min\n    sorted << max\n    lst.delete(min)\n    lst.delete(max)\n\
    \  end\n  sorted\nend", "  sorted = lst.sort\n  result = []\n  i = 0\n  while\
    \ result.size < lst.size\n    if i.even?\n      result << sorted.shift\n    else\n\
    \      result << sorted.pop\n    end\n    i += 1\n  end\n  result\nend", "  return\
    \ lst if lst.empty?\n  sorted = []\n  min = lst.min\n  max = lst.max\n  while\
    \ !lst.empty?\n    sorted << min\n    sorted << max\n    lst.delete(min)\n   \
    \ lst.delete(max)\n    max = lst.max\n    min = lst.min\n  end\n  sorted\nend",
  "  sorted = lst.sort\n  result = []\n  while !sorted.empty?\n    result << sorted.shift\n\
    \    result << sorted.pop\n  end\n  result\nend", "  sorted = lst.sort\n  result\
    \ = []\n  n = lst.length\n  n.times do\n    result << sorted.shift\n    result\
    \ << sorted.pop\n  end\n  n.odd? ? result.pop : result\nend", "  lst.sort[0..-2].sort_by\
    \ { |x| -x }.push(lst.min)\nend", "  lst.sort.map { |n| lst.delete(n) }\nend",
  "  sorted = lst.sort\n  left, right = sorted[0...(sorted.length / 2.0).ceil], sorted[(sorted.length\
    \ / 2.0).ceil..-1]\n  result = []\n  left.zip(right.reverse).each do |subarray|\n\
    \    subarray.compact.each { |x| result << x }\n  end\n  result\nend", "  return\
    \ lst if lst.empty?\n  i = 0\n  result = []\n  while lst.length > 0\n    result\
    \ << lst.delete_at(i)\n    if i == 0\n      i = lst.length - 1\n    else\n   \
    \   i -= 1\n    end\n  end\n  result\nend", "\nend", "  lst.sort.each_slice(2).flat_map\
    \ { |e| e.reverse }\nend", "  return lst if lst.length <= 1\n  x = lst.min\n \
    \ y = lst.max\n  strange_sort_list(lst - [x, y]) + [x, y]\nend", "  return lst\
    \ if lst.length <= 1\n  result = []\n  lst.sort!\n  first = lst.shift\n  result\
    \ << first\n  lst.reverse!\n  first = lst.shift\n  result << first\n  result +=\
    \ strange_sort_list(lst)\nend", "  if lst.size > 0\n    lst_size = lst.size\n\
    \    output = []\n    min = lst.sort.first\n    max = lst.sort.last\n    lst.delete(min)\n\
    \    lst.delete(max)\n    if lst_size % 2 == 0\n      lst_size.times do\n    \
    \    output << min\n        output << max\n        min = lst.sort.first\n    \
    \    max = lst.sort.last\n        lst.delete(min)\n        lst.delete(max)\n \
    \     end\n    else\n      lst_size.times do\n        output << min\n        output\
    \ << max\n        min = lst.sort.first\n        max = lst.sort.last\n        lst.delete(min)\n\
    \        lst.delete(max)\n      end\n      output << min\n    end\n    output\n\
    \  else\n    lst\n  end\nend", "  if lst.count < 1\n    return []\n  end\n  if\
    \ lst.count == 1\n    return lst\n  end\n  if lst.count == 2\n    return lst.reverse\n\
    \  end\n  lst_1 = lst.sort\n  lst_2 = lst_1.select.with_index{|v, i| i.even?}\n\
    \  lst_3 = lst_1.select.with_index{|v, i| i.odd?}\n  lst_4 = lst_2 + lst_3\n \
    \ return lst_4\nend", "  # YOUR CODE HERE\nend", "  return lst if lst.empty?\n\
    \  odd = []\n  even = []\n  i = 1\n  lst.each do |number|\n    odd << number if\
    \ i.odd?\n    even << number if i.even?\n    i += 1\n  end\n  odd.sort + even.sort.reverse\n\
    end", "\tlst.sort!\n\tif lst.length.even?\n\t\tleft = lst[0..lst.length/2-1]\n\
    \t\tright = lst[lst.length/2..-1]\n\t\tnew_lst = []\n\t\tleft.length.times do\
    \ |i|\n\t\t\tnew_lst << left[i]\n\t\t\tnew_lst << right[i]\n\t\tend\n\t\tnew_lst\n\
    \telse\n\t\tleft = lst[0..lst.length/2]\n\t\tright = lst[lst.length/2+1..-1]\n\
    \t\tnew_lst = []\n\t\tleft.length.times do |i|\n\t\t\tnew_lst << left[i]\n\t\t\
    \tnew_lst << right[i]\n\t\tend\n\t\tnew_lst << lst[lst.length/2]\n\tend\nend",
  "  # your code here\nend", "  raise \"input must be a list\" unless lst.is_a?(Array)\n\
    \  lst.sort_by{|i| [i.abs, -i]}\nend", "  return lst if lst.empty?\n  res = []\n\
    \  while !lst.empty?\n    res << lst.delete(lst.min)\n    res << lst.delete(lst.max)\n\
    \  end\n  res.compact\nend", '  return lst if lst.empty?', "\tnew_list = []\n\t\
    sorted_list = lst.sort\n\tmax_value = sorted_list.last\n\tmin_value = sorted_list.first\n\
    \tloop do\n\t\tnew_list << min_value\n\t\tnew_list << max_value\n\t\tlst.delete(min_value)\n\
    \t\tlst.delete(max_value)\n\t\tbreak if lst.empty?\n\t\tmax_value = lst.max\n\t\
    \tmin_value = lst.min\n\tend\n\tnew_list\nend", "  lst.sort_by{|v| [v, -v]}.flatten\n\
    end", "  len = lst.length\n  len.even? ? rng = len : rng = len-1\n  new_list =\
    \ []\n  rng.times do |i|\n    new_list << lst.min\n    lst.delete(lst.min)\n \
    \   new_list << lst.max\n    lst.delete(lst.max)\n  end\n  new_list << lst if\
    \ len.odd?\n  new_list\nend", "  res, sorted_lst = [], lst.sort\n  res << sorted_lst.shift\
    \ << sorted_lst.pop until sorted_lst.empty?\n  res\nend", "  lst.sort!.each_slice(2).to_a.reverse.flatten\n\
    end", "  return lst if lst.empty?\n  list = lst.sort\n  result = []\n  flag =\
    \ true\n  while list.size > 0\n    if flag\n      result << list.delete_at(0)\n\
    \    else\n      result << list.delete_at(-1)\n    end\n    flag = !flag\n  end\n\
    \  result\nend", "  # Your code here\nend", "  lst.sort_by.with_index { |_, i|\
    \ i.even? ? 0 : 1 }\nend", "  lst.size < 2 ? lst : lst.sort.partition.with_index\
    \ { |_, i| i.even? }.flatten\nend", "  lst.sort!\n  res = []\n  (0..lst.size /\
    \ 2).each do |i|\n    if i == lst.size / 2\n      res << lst[i]\n    else\n  \
    \    res << lst[i]\n      res << lst[lst.size - i - 1]\n    end\n  end\n  res\n\
    end", "  left = lst.min\n  right = lst.max\n  result = []\n  while lst.size >\
    \ 0\n    result << left\n    lst.delete(left)\n    result << right\n    lst.delete(right)\n\
    \    left = lst.min\n    right = lst.max\n  end\n  result\nend", "  min_max_list\
    \ = []\n  lst.each_with_index do |num, index|\n    if index.even?\n      min_max_list\
    \ << lst.min\n      lst.delete(lst.min)\n    else\n      min_max_list << lst.max\n\
    \      lst.delete(lst.max)\n    end\n  end\n  min_max_list\nend", "  sorted =\
    \ []\n  lst.each_with_index do |num, i|\n    if i.even?\n      sorted << num if\
    \ num == lst.min\n    else\n      sorted << num if num == lst.max\n    end\n \
    \ end\n  sorted\nend", "  lst.sort!\n  lst.partition.with_index { |_, idx| idx.even?\
    \ }.flatten\nend", "  # your code here\nend", "  # TODO: implement strange sort\n\
    \  return lst if lst.empty?\n  ordered_lst = []\n  ordered_lst << lst.min\n  lst.delete(lst.min)\n\
    \  # this loop retrieves max and min from remaining integers (lst) and append\
    \ them to a new list (ordered_lst)\n  loop do\n    break if lst.empty?\n    ordered_lst\
    \ << lst.max\n    lst.delete(lst.max)\n    break if lst.empty?\n    ordered_lst\
    \ << lst.min\n    lst.delete(lst.min)\n  end\n  ordered_lst\nend", "  lst.sort_by.with_index\
    \ { |_, i| i.even? ? :min : :max }\nend", "\treturn lst if lst.length < 2\n\t\n\
    \tsorted = []\n\tascending = true\n\t\n\twhile sorted.length < lst.length\n\t\t\
    if ascending\n\t\t\tsorted << lst.min\n\t\t\tlst.delete(lst.min)\n\t\telse\n\t\
    \t\tsorted << lst.max\n\t\t\tlst.delete(lst.max)\n\t\tend\n\t\tascending = !ascending\n\
    \tend\n\t\n\tsorted\nend", "  lst.sort_by.with_index { |num, i| [i.even? ? -num\
    \ : num, i] }\nend", '  return lst if lst.empty?', "  sorted = lst.sort\n  sorted.unshift(sorted.pop)\
    \ until sorted.size < 2\n  sorted.unshift(sorted.pop) until sorted.size.zero?\n\
    \  sorted\nend", "  arr = []\n  lst.sort!\n  (0..lst.length-1).step(2) do |i|\n\
    \    arr << lst[i]\n  end\n  (1..lst.length-1).step(2) do |i|\n    arr << lst[i]\n\
    \  end\n  arr\nend", "  return lst if lst.empty?\n  lst.sort!.each_slice(2).to_a.transpose.flatten.compact\n\
    end", "  if lst.empty?\n    lst\n  else\n    new_lst = lst.sort\n    result =\
    \ []\n    idx = 0\n    loop do\n      if new_lst.size == 0\n        break\n  \
    \    else\n        result << new_lst.slice!(idx)\n        result << new_lst.slice!(-1)\n\
    \      end\n    end\n    result\n  end\nend", '  return lst if lst.empty?', " \
    \ # your code here\nend", "  if lst.empty?\n    return []\n  elsif lst.length\
    \ == 1\n    return lst\n  else\n    lst_len = lst.length\n    sorted_lst = []\n\
    \    sorted_lst.push(lst.min)\n    lst.delete(lst.min)\n    while sorted_lst.length\
    \ < lst_len\n      sorted_lst.push(lst.max)\n      lst.delete(lst.max)\n     \
    \ sorted_lst.push(lst.min)\n      lst.delete(lst.min)\n    end\n    return sorted_lst\n\
    \  end\nend", "  return lst if lst.empty?\n  sorted = []\n  sorted << lst.min\n\
    \  new_lst = lst.delete_if { |x| x == lst.min }\n  sorted << new_lst.max\n  new_lst.delete_if\
    \ { |x| x == new_lst.max }\n  if new_lst.empty?\n    return sorted\n  else\n \
    \   return sorted + strange_sort_list(new_lst)\n  end\nend", "    if lst.count\
    \ < 2\n        return lst\n    end\n    sorted = []\n    res = []\n    sorted\
    \ << lst.min\n    sorted << lst.max\n    lst.each do |n|\n        if n != sorted[0]\
    \ && n != sorted[1]\n            res << n\n        end\n    end\n    sorted +=\
    \ res\n    res = []\n    while sorted.count != 1\n        res << sorted.delete_at(0)\n\
    \        res << sorted.delete_at(-1)\n    end\n    res << sorted.delete_at(0)\n\
    \    return res\nend", "  return lst if lst.empty?\n  sorted = lst.sort\n  result\
    \ = []\n  max = true\n  sorted.each do |x|\n    if max\n      result << sorted.pop\n\
    \      max = false\n    else\n      result << sorted.shift\n      max = true\n\
    \    end\n  end\n  result\nend", "  if lst.length.even?\n    lst_sorted = []\n\
    \    lst_remain = lst.sort\n    (0..lst.length/2-1).each do |i|\n      lst_sorted\
    \ << lst_remain.shift\n      lst_sorted << lst_remain.pop\n    end\n    lst_sorted\n\
    \  else\n    lst_sorted = []\n    lst_remain = lst.sort\n    (0..lst.length/2).each\
    \ do |i|\n      lst_sorted << lst_remain.shift\n      lst_sorted << lst_remain.pop\n\
    \    end\n    lst_sorted\n  end\nend", "  lst.sort_by { |n| lst.index(n) - (lst.count\
    \ - 1 - lst.index(n)) }\nend", "  return lst if lst.empty?\n  min = lst.min\n\
    \  lst.delete(min)\n  max = lst.max\n  lst.delete(max)\n  return [min, max] +\
    \ strange_sort_list(lst)\nend", "  start_index = 0\n  last_index = lst.length\
    \ - 1\n  sort_lst = []\n  return sort_lst if lst.empty?\n  min_index = lst.find_index(lst.min)\n\
    \  max_index = lst.find_index(lst.max)\n  if min_index < max_index\n    sort_lst\
    \ << lst[min_index]\n    sort_lst << lst[max_index]\n    sort_lst << lst[start_index..min_index\
    \ - 1]\n    sort_lst << lst[max_index + 1..last_index]\n  else\n    sort_lst <<\
    \ lst[max_index]\n    sort_lst << lst[min_index]\n    sort_lst << lst[start_index..max_index\
    \ - 1]\n    sort_lst << lst[min_index + 1..last_index]\n  end\n  sort_lst.flatten!\n\
    \  return sort_lst if sort_lst.length == lst.length\n  strange_sort_list(sort_lst)\n\
    end", "  p = lst.sort.uniq\n  p.shift\n  [lst.min] + strange_sort_list(p)\nend",
  "  return lst if lst.empty?\n  n = lst.size / 2\n  [lst.min] + strange_sort_list(lst.max(n))\
    \ + strange_sort_list(lst.min(n))\nend", "\tlst.sort!\n\ti = 0\n\twhile lst.size\
    \ > 0\n\t\tlst.size.even? ? i == 0 ? lst.unshift(lst.pop) : lst.push(lst.shift)\
    \ : lst.size > 1 ? i == 0 ? lst.unshift(lst.pop) : lst.push(lst.shift) : lst\n\
    \t\ti = i == 0 ? 1 : 0\n\tend\n\tlst\nend", "  # your code here\nend", "  lst.sort[0..-2].each_slice(2).to_a.transpose.flatten\
    \ << lst.minmax.min\nend", "  return lst if lst.length <= 1\n  even = lst.select.with_index\
    \ { |e, i| i.even? }\n  odd = lst.select.with_index { |e, i| i.odd? }\n  odd =\
    \ odd.sort.reverse\n  even = even.sort\n  res = []\n  even.each_with_index do\
    \ |e, i|\n    res << e\n    res << odd[i]\n  end\n  res\nend", "  lst.sort.partition.with_index\
    \ { |_, idx| idx.even? }.flatten\nend", "  # your code here\nend", "  # Add code\
    \ here.\nend", "  lst.sort! { |a, b| a <=> b }\n  sorted_list = []\n  lst.each_with_index\
    \ do |e, i|\n    sorted_list << lst.delete_at(i)\n    lst.reverse!\n  end\n  sorted_list\n\
    end", "  return lst if lst.empty?\n  res = []\n  min = lst.min\n  max = lst.max\n\
    \  until lst.empty?\n    res << min\n    lst.delete(min)\n    break if lst.empty?\n\
    \    res << max\n    lst.delete(max)\n  end\n  res\nend", "  lst.sort.each_slice(2).flat_map\
    \ { |a, b| [a, b] }.compact\nend", "  sorted = false\n  while !sorted\n    sorted\
    \ = true\n    (0...lst.length - 1).each do |idx|\n      if (idx.even? && lst[idx]\
    \ > lst[idx + 1]) || (idx.odd? && lst[idx] < lst[idx + 1])\n        lst[idx],\
    \ lst[idx + 1] = lst[idx + 1], lst[idx]\n        sorted = false\n      end\n \
    \   end\n  end\n  lst\nend", "  sorted = lst.sort\n  result = []\n  sorted.size.times\
    \ do\n    result << sorted.shift\n    result << sorted.pop\n  end\n  result.pop\
    \ if sorted.empty?\n  result\nend", "  if lst.empty?\n    return []\n  end\n \
    \ res = []\n  lst = lst.sort\n  while res.length < lst.length\n    res << lst.shift\n\
    \    res << lst.pop\n  end\n  res\nend", "  lst.sort.zip(lst.sort.reverse).flatten.compact\n\
    end", "  return lst if lst.empty?\n  sorted = []\n  lst = lst.sort", "  lst.sort[0..-2].zip(lst.sort[1..-1].reverse).flatten\n\
    end", "  return lst if lst.length <= 1\n  output = [lst.min]\n  list = lst - [lst.min]\n\
    \  even = true\n  while list.length > 0\n    if even\n      output << list.max\n\
    \      list.delete(list.max)\n    else\n      output << list.min\n      list.delete(list.min)\n\
    \    end\n    even = !even\n  end\n  output\nend", "  sorted = []\n  sorted <<\
    \ lst.min\n  sorted << lst.max\n  return sorted if lst.length == 2\n  lst.delete(lst.min)\n\
    \  lst.delete(lst.max)\n  while lst.length > 0\n    sorted << lst.min\n    sorted\
    \ << lst.max\n    lst.delete(lst.min)\n    lst.delete(lst.max)\n  end\n  sorted\n\
    end", '  return lst if lst.empty?', "  if lst.length == 0\n    lst\n  else\n \
    \   res = []\n    while lst.length > 0\n      res.push(lst.min)\n      lst.delete(lst.min)\n\
    \      res.push(lst.max)\n      lst.delete(lst.max)\n    end\n    res\n  end\n\
    end", "\tlst.sort!\n\tres = []\n\ti = 0\n\tj = lst.length - 1\n\tlst.length.times\
    \ do\n\t\tif i == j\n\t\t\tres << lst[i]\n\t\t\tbreak\n\t\tend\n\t\tres << lst[i]\n\
    \t\tres << lst[j]\n\t\ti += 1\n\t\tj -= 1\n\tend\n\tres\nend", '  return lst if
    lst.empty?', "  lst.sort!\n  left = 0\n  right = lst.length - 1\n  sorted = []\n\
    \  while left <= right\n    sorted << lst[left]\n    left += 1\n    if left <=\
    \ right\n      sorted << lst[right]\n      right -= 1\n    end\n  end\n  sorted\n\
    end", "  lst.sort.each_slice(2).to_a.transpose.flatten.compact\nend", "  return\
    \ lst if lst.empty?\n  lst.sort!\n  mid_i = lst.size / 2\n  result = []\n  lst.size.times\
    \ do |i|\n    if i % 2 == 0\n      result << lst[mid_i + i / 2]\n    else\n  \
    \    result << lst[mid_i - (i + 1) / 2]\n    end\n  end\n  result\nend", "  raise\
    \ if lst.empty?\n  if lst.size.even?\n    (0..lst.size - 1).step(2).map { |i|\
    \ [lst[i], lst[i + 1]] }.flatten\n  else\n    (0..lst.size - 1).step(2).map {\
    \ |i| [lst[i], lst[i + 1]] }.flatten << lst[-1]\n  end\nend", "  lst.sort! { |a,\
    \ b| [a, -b] <=> [b, -a] }\nend", "\nend", "  # nice, with sort_by method, but\
    \ to long ;)\n  # sorted = lst.sort_by { |value| [value, -value] }\n  # result\
    \ = []\n  # index = 0\n  # loop do\n  #   result << sorted[index]\n  #   result\
    \ << sorted[sorted.size - 1 - index]\n  #   index += 1\n  #   break if index >=\
    \ sorted.size / 2\n  # end\n  # result", "\tlst.size % 2 == 0 ? even_list(lst)\
    \ : odd_list(lst)\nend", "  lst.sort!\n  if lst.length > 1\n    lst[0], lst[-1]\
    \ = lst[-1], lst[0]\n    strange_sort_list(lst[1...-1])\n  end\n  lst\nend", " \
    \ lst.sort!\n  result = []\n  first = true\n  until lst.empty?\n    if first\n\
    \      result << lst.delete_at(0)\n      first = false\n    else\n      result\
    \ << lst.delete_at(-1)\n      first = true\n    end\n  end\n  result\nend", " \
    \ return lst if lst.empty?\n  result = []\n  lst.sort!.each_slice(2) do |low,\
    \ high|\n    result << low\n    result << high if high\n  end\n  result\nend",
  "  return lst if lst.empty?\n  lst.sort[0..1].reverse + strange_sort_list(lst.sort[2..-1])\n\
    end", "  min = lst.min\n  max = lst.max\n  n = lst.length\n  result = []\n  i\
    \ = 0\n  while i < n\n    result << min\n    min = lst.reject { |x| x == min }.min\n\
    \    result << max\n    max = lst.reject { |x| x == max }.max\n    i += 2\n  end\n\
    \  result\nend", "  lst.size.times.map do |i|\n    if i.even?\n      lst.min\n\
    \    else\n      lst.max\n    end\n  end\nend", "  a, b = lst.partition.with_index\
    \ { |_, i| i.even? }\n  b + a\nend", "  output = []\n  lst.sort!", "  return lst\
    \ if lst.empty?\n  index = 0\n  result = []\n  loop do\n    if index.even?\n \
    \     result << lst.min\n      lst.delete(lst.min)\n    else\n      result <<\
    \ lst.max\n      lst.delete(lst.max)\n    end\n    break if lst.empty?\n    index\
    \ += 1\n  end\n  result\nend", "  sorted = []\n  while lst.any?\n    sorted <<\
    \ lst.min\n    lst.delete(lst.min)\n    sorted << lst.max\n    lst.delete(lst.max)\n\
    \  end\n  sorted\nend", "  res = []\n  x = lst.sort[0]\n  res << x\n  lst.delete(x)\n\
    \  x = lst.sort[-1]\n  res << x\n  lst.delete(x)\n  lst = lst.sort\n  while !lst.empty?\n\
    \    x = lst[0]\n    res << x\n    lst.delete(x)\n    x = lst[-1]\n    res <<\
    \ x\n    lst.delete(x)\n  end\n  res\nend", "  lst.sort!\n  min = lst.shift\n\
    \  max = lst.pop\n  [min, max].compact\nend", "  lst.sort.reverse.each_slice(2).to_a.transpose.flatten\n\
    end", "  return lst if lst.empty?\n  max = lst.max\n  (1..lst.length).each do\
    \ |num|\n    if num.odd?\n      lst.delete(max)\n      lst.unshift(max)\n    else\n\
    \      min = lst.min\n      lst.delete(min)\n      lst.unshift(min)\n    end\n\
    \  end\n  lst\nend", "  lst.sort.zip(lst.sort.reverse).flatten.compact\nend",
  "  return lst if lst.length <= 1\n  result = []\n  result << lst.min\n  lst.delete(lst.min)\n\
    \  result << lst.max\n  lst.delete(lst.max)\n  result << strange_sort_list(lst)\n\
    \  result.flatten\nend", "  return lst if lst.empty?\n  even_list = lst.select\
    \ { |i| lst.index(i).even? }\n  odd_list = lst.select { |i| lst.index(i).odd?\
    \ }\n  new_list = []\n  even_list.sort.each_with_index do |element, index|\n \
    \   new_list << element\n    new_list << odd_list.sort.reverse[index]\n  end\n\
    \  new_list\nend", "\tif lst == []\n\t\treturn []\n\telse\n\t\tnew_list = []\n\
    \t\tsorted_list = lst.sort\n\t\twhile sorted_list.length > 0\n\t\t\tnew_list <<\
    \ sorted_list.shift\n\t\t\tnew_list << sorted_list.pop\n\t\tend\n\t\tnew_list.compact\n\
    \tend\nend", "  return lst if lst.empty?\n  strange_sorted = []\n  lst.minmax.reverse.each\
    \ do |bool|\n    bool ? strange_sorted << lst.max : strange_sorted << lst.min\n\
    \    lst.delete(strange_sorted.last)\n  end\n  strange_sorted\nend", "  sorted\
    \ = lst.sort\n  result = []\n  until sorted.empty?\n    result << sorted.delete_at(0)\n\
    \    result << sorted.delete_at(-1)\n  end\n  result\nend", "  puts \"dummy for\
    \ strange_sort_list\"\nend", "  lst.size.even? ? sorted_list(lst).flatten : sorted_list(lst).reverse.flatten\n\
    end", "\nend", "  n = lst.size\n  n == 0 ? [] : n == 1 ? lst :\n  lst.minmax.map\
    \ do |e|\n    index = lst.index(e)\n    lst.delete_at(index)\n    e\n  end + strange_sort_list(lst)\n\
    end", "  x = []\n  return x if lst.empty?\n  until lst.empty?\n    x << lst.min\n\
    \    lst.delete(lst.min)\n    x << lst.max\n    lst.delete(lst.max)\n  end\n \
    \ x\nend", "  return lst if lst.empty?\n  [lst.min] + strange_sort_list(lst.reject{|x|\
    \ x == lst.min}) + strange_sort_list(lst.reject{|x| x == lst.max})\nend", "  lst.sort[0...-1].sort.reverse\
    \ + lst.sort[-1..-1]\nend", "  empty_array = []\n  lst.sort.each_slice(2) { |a,\
    \ b| empty_array << a << b }\n  empty_array.reverse.each_slice(2) { |a, b| empty_array\
    \ << a << b }\n  empty_array.compact\nend", "  # TODO: Implement strange sorting\n\
    \  lst.sort!\n  new_lst = []\n  until lst.empty?\n    new_lst << lst.delete_at(0)\n\
    \    new_lst << lst.delete_at(-1)\n  end\n  new_lst\nend", "  sorted = lst.sort\n\
    \  strange_sort(sorted)\nend", "  new_lst = []\n  lst.sort!\n  min_max_lst = []\n\
    \  lst.each_with_index do |v, i|\n    if i.even?\n      min_max_lst << v\n   \
    \ else\n      min_max_lst.unshift(v)\n    end\n  end\n  min_max_lst\nend", " \
    \ sorted = lst.sort\n  arr = []\n  while sorted.length > 0\n    arr << sorted.shift\n\
    \    arr << sorted.pop\n  end\n  return arr.compact\nend", "  lst.sort.partition.with_index\
    \ { |_, idx| idx.even? }.flatten\nend", "  lst.sort.reverse.each_slice(2).flat_map\
    \ { |a, b| b ? [a, b] : [a] }\nend", "  return lst if lst.empty?\n  (lst.min..lst.max).to_a.map\
    \ { |el| lst.delete_at(lst.index(el)) }\nend", "  lst.map { |l| l == lst.min ?\
    \ l : l == lst.max ? l : nil }.compact\nend", "  sorted = []\n  list = lst.sort\n\
    \  until list.empty?\n    sorted << list.shift\n    sorted << list.pop\n  end\n\
    \  sorted\nend", "  lst.sort_by { |i| [lst.index(i), i % 2] }\nend", "  return\
    \ lst if lst.empty?\n  res = []\n  mn = lst.min\n  res << mn\n  mx = lst.max\n\
    \  res << mx\n  lst.delete(mn)\n  lst.delete(mx)\n  while lst.length >= 2\n  \
    \  mn = lst.min\n    res << mn\n    mx = lst.max\n    res << mx\n    lst.delete(mn)\n\
    \    lst.delete(mx)\n  end\n  if lst.length == 1\n    res << lst[0]\n  end\n \
    \ res\nend", "  new = lst.sort\n  result = []\n  while new.length > 0\n    result\
    \ << new.shift\n    result << new.pop\n  end\n  result.compact\nend", "  lst.sort[0..-2].partition.with_index\
    \ { |_, i| i.even? }.transpose.flatten + [lst.max]\nend", "    lst.sort!\n   \
    \ final = []\n    if lst.length == 0 || lst.length == 1\n        return lst\n\
    \    end\n    final.push(lst[0])\n    final.push(lst[-1])\n    (1...lst.length-1).each\
    \ do |idx|\n        if idx.even?\n            final.push(lst[idx])\n        else\n\
    \            final.unshift(lst[idx])\n        end\n    end\n    final\nend", " \
    \ lst.sort!\n  result = []\n  lst.each_with_index do |i, j|\n    if j == 0\n \
    \     result << i\n    elsif j % 2 == 0\n      result << lst[-j]\n    else\n \
    \     result << lst[j]\n    end\n  end\n  result\nend", "  new_lst = []\n  until\
    \ lst.empty?\n    new_lst << lst.min\n    lst.delete(lst.min)\n    new_lst <<\
    \ lst.max\n    lst.delete(lst.max)\n  end\n  new_lst\nend", "  return lst if lst.empty?\n\
    \  # [(1,2,3,4), (0,1,0,1)]\n  sort_lst = [lst, []]\n  (lst.size / 2).times do\n\
    \    sort_lst = sort_lst.transpose.map { |group| group.sort }\n  end\n  sort_lst.flatten\n\
    end", "  lst.sort { |a, b| a <=> b }.each_slice(2).flat_map(&:reverse)\nend",
  "  if lst.length == 0\n    return []\n  end\n  min = lst.min\n  max = lst.max\n\
    \  while lst.length != 0\n    lst.delete(min)\n    lst.delete(max)\n    lst =\
    \ [min, max] + lst\n    min = lst.min\n    max = lst.max\n  end\n  return lst\n\
    end", "  lst.sort.partition.with_index { |_, idx| idx.even? }.reverse.flatten\n\
    end", "  return lst if lst.empty?\n  new_lst = []\n  new_lst << lst.min\n  lst.delete(lst.min)\n\
    \  until lst.empty?\n    new_lst << lst.max\n    lst.delete(lst.max)\n    new_lst\
    \ << lst.min\n    lst.delete(lst.min)\n  end\n  new_lst\nend", "  return lst if\
    \ lst.empty?\n  a, b = lst.partition { |x| x == lst.min || x == lst.max }\n  strange_sort_list(lst\
    \ - a) + a\nend", "  return lst if lst.length < 2\n  lst = lst.sort\n  r = []\n\
    \  for i in (0..lst.length-1)\n    r[i] = i.even? ? lst.shift : lst.pop\n  end\n\
    \  r\nend", "  return lst if lst.empty?\n  min_max_array = []\n  half_len = lst.length\
    \ / 2\n  half_len.times do\n    min_max_array << lst.min\n    lst.delete(lst.min)\n\
    \    min_max_array << lst.max\n    lst.delete(lst.max)\n  end\n  min_max_array.compact\
    \ + lst\nend", "  return lst if lst.empty?\n  lst.delete(lst.min) + strange_sort_list(lst.insert(0,\
    \ lst.min))\nend", "  return lst if lst.empty?\n  res = [lst.min]\n  lst.reject!\
    \ { |x| x == lst.min }\n  until lst.empty?\n    res << lst.max\n    lst.reject!\
    \ { |x| x == lst.max }\n    res << lst.min\n    lst.reject! { |x| x == lst.min\
    \ }\n  end\n  res\nend", "  lst.sort[0..-2].each_slice(2).to_a.flatten.reverse\
    \ + [lst.min]\nend", "  if lst.empty?\n    []\n  else\n    result = []\n    length\
    \ = lst.length\n    lst = lst.sort\n    length.times do\n      if result.length.even?\n\
    \        result << lst.shift\n      else\n        result << lst.pop\n      end\n\
    \    end\n    result\n  end\nend", "  lst.sort.reverse.each_slice(2).map(&:reverse).flatten\n\
    end", "  lst.sort.reverse.each_slice(2).flat_map(&:reverse)\nend", "  res = []\n\
    \  return lst if lst.empty?\n  res << lst.min\n  loop do\n    break if lst.size\
    \ == 1\n    lst.delete(lst.min)\n    res << lst.max\n    lst.delete(lst.max)\n\
    \  end\n  res << lst[0]\n  res\nend", "  lst.sort.shuffle\nend", "  min, max =\
    \ lst.minmax\n  lst.each_with_object([]) do |num, result|\n    result << (lst.first\
    \ == num ? min : max)\n    lst.delete_at(lst.index(result.last))\n  end\nend",
  "  return lst if lst.empty?\n  @lst = lst.sort\n  @result = []\n  @even = true\n\
    \  @result << @lst.shift\n  while @lst.any?\n    if @even\n      @result << @lst.pop\n\
    \    else\n      @result << @lst.shift\n    end\n    @even = !@even\n  end\n \
    \ @result\nend", "  return lst if lst.empty?\n  a, b = lst.partition.with_index\
    \ { |_, i| i.even? }\n  a.map! { |x| -x }\n  a.sort!\n  a.map! { |x| -x }\n  a\
    \ + b\nend", "  sorted = []\n  lst.sort!\n  until lst.length == 0\n    sorted\
    \ << lst.delete_at(0)\n    sorted << lst.delete_at(-1)\n  end\n  sorted\nend",
  "  return lst if lst.length == 0\n  new_lst = []\n  while lst.length > 0\n    new_lst\
    \ << lst.min\n    lst.delete(lst.min)\n    if lst.length > 0\n      new_lst <<\
    \ lst.max\n      lst.delete(lst.max)\n    end\n  end\n  new_lst\nend", "  sorted\
    \ = []\n  return lst if lst.length <= 1\n  sorted << lst.min\n  lst.delete(lst.min)\n\
    \  sorted << lst.max\n  lst.delete(lst.max)\n  sorted << strange_sort_list(lst)\n\
    \  sorted.flatten\nend", "  # your code here\nend", "  lst.sort.each_slice(2).to_a.reverse.flatten\n\
    end", "  sorted = []\n  lst.sort!\n  while lst.size > 0\n    sorted << lst.delete_at(0)\n\
    \    sorted << lst.delete_at(-1)\n  end\n  sorted\nend", "  case lst.size\n  when\
    \ 0\n    lst\n  when 1\n    lst\n  else\n    lst = lst.sort\n    lst_first = []\n\
    \    lst_second = []\n    lst_size = lst.size\n    temp = lst_size / 2\n    temp\
    \ += 1 if lst_size.odd?\n    counter = 0\n    lst.each do |x|\n      if counter\
    \ < temp\n        lst_first << x\n      else\n        lst_second << x\n      end\n\
    \      counter += 1\n    end\n    if lst_size.odd?\n      lst_first.delete_at(lst_first.size\
    \ - 1)\n    end\n    lst_second.reverse!\n    lst_first.zip(lst_second).flatten\n\
    \  end\nend", "  if lst.length.even?\n    [lst.min, lst.max] + strange_sort_list(lst.select\
    \ { |i| i != lst.min && i != lst.max })\n  elsif lst.length.odd?\n    [lst.max]\
    \ + strange_sort_list(lst.select { |i| i != lst.max })\n  else\n    []\n  end\n\
    end", "  return lst if lst.empty?\n  lst.partition.with_index { |_, i| i.even?\
    \ }.map do |even, odd|\n    even.sort + odd.sort.reverse\n  end.flatten\nend",
  "  lst.sort.group_by.with_index { |_, i| i.even? }.values.flatten\nend", "  lst.sort_by{|x|\
    \ [x, -x]}.flatten\nend", "  if lst.size.even?\n    lst.partition.with_index {\
    \ |_, i| i.even? }.flatten\n  else\n    lst.partition.with_index { |_, i| i.odd?\
    \ }.flatten\n  end\nend", "  #your code here\nend", "  sorted = []\n  order =\
    \ (lst.size / 2).times.map { |x| x % 2 }\n  order.each do |value|\n    sorted\
    \ << lst.send(value.zero? ? :shift : :pop)\n  end\n  sorted\nend", "  lst.sort!\n\
    \  res = []\n  loop do\n    break if lst.empty?\n    res << lst.shift\n    res\
    \ << lst.pop\n  end\n  res\nend", "  (lst + lst.sort.uniq.slice!(0, 1)).flatten.sort.reject\
    \ { |x| x == lst.sort.uniq.slice!(0, 1) }\nend", "  new_list = []\n  lst = lst.sort\n\
    \  while lst.length > 0\n    new_list << lst.shift\n    new_list << lst.pop\n\
    \  end\n  return new_list\nend", "  lst.sort!\n  sorted = []\n  lst.length.times\
    \ do\n    sorted << lst.shift\n    sorted << lst.pop\n  end\n  sorted.compact\n\
    end", "  return lst if lst.empty?\n  new_list = []\n  new_list << lst.min\n  lst.delete(lst.min)\n\
    \  new_list << lst.max\n  lst.delete(lst.max)\n  until lst.empty?\n    new_list\
    \ << lst.min\n    lst.delete(lst.min)\n    new_list << lst.max\n    lst.delete(lst.max)\n\
    \  end\n  new_list\nend", "    return lst if lst.length <= 1\n    first = lst.min\n\
    \    second = lst.reject { |x| x == first }.max\n    return [first, second] +\
    \ strange_sort_list(lst.reject { |x| x == first || x == second })\nend", "  return\
    \ lst if lst.length <= 1\n  front = lst.sort!\n  rear = lst.sort!.reverse!\n \
    \ strange_sort_list(front.zip(rear).flatten)\nend", "  sorted = []\n  if lst.empty?\n\
    \    return sorted\n  elsif lst.count.even?\n    sorted << lst.min\n    sorted\
    \ << lst.max\n    sorted << lst.min(2)[1]\n    sorted << lst.max(2)[1]\n  else\n\
    \    sorted << lst.min\n    sorted << lst.max\n    sorted << lst.min(2)[1]\n \
    \   sorted << lst.max(2)[1]\n    sorted << lst.min(3)[2]\n  end\n  sorted\nend",
  "  return lst if lst.length <= 1\n  new_list = [lst.min]\n  lst.delete(lst.min)\n\
    \  until lst.empty?\n    new_list << lst.max\n    lst.delete(lst.max)\n    new_list\
    \ << lst.min\n    lst.delete(lst.min)\n  end\n  new_list\nend", "  lst = lst.sort\n\
    \  lst2 = []\n  while lst.length > 0\n    lst2 << lst.shift\n    lst2 << lst.pop\n\
    \  end\n  lst2\nend", "  # check if list is empty, if it is return empty list\n\
    \  if lst.length == 0\n    return []\n  end\n  # create new empty array to store\
    \ result in\n  result = []\n  # create two counters to keep track of the minimum\
    \ and maximum values\n  min = 0\n  max = lst.length - 1\n  # loop until result\
    \ is the same length as the list\n  until result.length == lst.length\n    # append\
    \ the minimum value to the result\n    result << lst[min]\n    # add the maximum\
    \ value of the remaining values in the list\n    result << lst[max]\n    # increment\
    \ the minimum and decrement the maximum\n    min += 1\n    max -= 1\n  end\n \
    \ # return the result\n  result\nend", "  # TODO: Your code here\nend", "  lst.sort_by.with_index\
    \ { |e,i| [i.even? ? e : -e, -i] }\nend", "  # your code here\nend", '  return
    lst if lst.empty?', "  return lst if lst.length <= 1\n  mn = lst.min\n  mx = lst.max\n\
    \  n = 0\n  d = 1\n  r = []\n  while lst.length > 0\n    if n == 0\n      r <<\
    \ mn\n      lst.delete(mn)\n    else\n      r << mx\n      lst.delete(mx)\n  \
    \  end\n    n += d\n    if n == lst.length - 1\n      d = -1\n    elsif n == 0\n\
    \      d = 1\n    end\n  end\n  r\nend", "  odd = []\n  even = []\n  list = []\n\
    \  if lst.length.even?\n    lst.each_with_index do |i, index|\n      if index.even?\n\
    \        odd << i\n      else\n        even << i\n      end\n    end\n    even.reverse!\n\
    \    lst.length.times do |index|\n      if index.even?\n        list << odd[index]\n\
    \      else\n        list << even[index]\n      end\n    end\n  else\n    lst.each_with_index\
    \ do |i, index|\n      if index.even?\n        odd << i\n      else\n        even\
    \ << i\n      end\n    end\n    even.reverse!\n    lst.length.times do |index|\n\
    \      if index.even?\n        list << odd[index]\n      else\n        list <<\
    \ even[index]\n      end\n    end\n    list << odd[-1]\n  end\n  list\nend", " \
    \ lst.sort.partition.with_index { |x, i| i.even? }.flatten\nend", "  counter =\
    \ 0\n  result = []\n  while lst.size > 0\n    result << lst.sort[counter]\n  \
    \  lst.delete_at(counter)\n    counter = (counter + 1) % 2\n  end\n  result\n\
    end", "  return lst if lst.empty?\n  result = []\n  min = lst.min\n  lst.delete(min)\n\
    \  result << min\n  max = lst.max\n  lst.delete(max)\n  result << max\n  strange_sort_list(lst).each\
    \ { |e| result << e }\n  result\nend", "  return lst if lst.empty?\n  result =\
    \ []\n  sorted = lst.sort\n  while sorted.any?\n    result << sorted.shift\n \
    \   result << sorted.pop\n  end\n  result\nend", "  lst.sort!\n  new_list = []\n\
    \  while !lst.empty?\n    new_list << lst.shift\n    new_list << lst.pop\n  end\n\
    \  new_list\nend", "\nend", "  lst.sort.reverse.map.with_index do |_, i|\n   \
    \ if i.even?\n      lst.min\n    else\n      lst.max\n    end\n  end\nend", " \
    \ lst.sort.each_slice(2).flat_map{|a,b| [a,b]}.rotate(1)\nend", "  return lst\
    \ if lst.length <= 1\n  new_arr = []\n  if lst.length.odd?\n    new_arr.push(lst.min)\n\
    \    lst.delete(lst.min)\n  end\n  until lst.empty?\n    new_arr.push(lst.max)\n\
    \    lst.delete(lst.max)\n    new_arr.push(lst.min)\n    lst.delete(lst.min)\n\
    \  end\n  new_arr\nend", "  lst.empty? ? [] : lst.select(&:odd?).sort + lst.select(&:even?).sort\n\
    end", '  return lst if lst.empty?', "  # Write your code here\nend", "  res =\
    \ []\n  lst.sort!\n  while lst.length > 0\n    res << lst.shift\n    res << lst.pop\n\
    \  end\n  return res\nend", "  min_value = lst.min\n  lst.delete(min_value)\n\
    \  list = []\n  list << min_value\n  until lst.empty?\n    max_value = lst.max\n\
    \    lst.delete(max_value)\n    list << max_value\n    min_value = lst.min\n \
    \   lst.delete(min_value)\n    list << min_value\n  end\n  list\nend", "  # first\
    \ find the minimum and maximum value\n  max = lst.max\n  min = lst.min\n  # make\
    \ a new array with the min and max\n  result = [min, max]\n  # eliminate the min\
    \ and max from the array\n  remaining = lst - [min, max]\n  # and iterate through\
    \ the remaining array adding either the minimum\n  # or maximum to the result\
    \ array alternatingly\n  remaining.each_with_index do |num, index|\n    index.even?\
    \ ? result << min : result << max\n  end\n  result\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
