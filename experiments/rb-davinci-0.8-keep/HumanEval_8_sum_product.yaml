name: HumanEval_8_sum_product
language: rb
prompt: "# For a given list of integers, return a tuple consisting of a sum and a\
  \ product of all the integers in a list.\n# Empty sum should be equal to 0 and empty\
  \ product should be equal to 1.\n# >>> sum_product([])\n# (0, 1)\n# >>> sum_product([1,\
  \ 2, 3, 4])\n# (10, 24)\ndef sum_product(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sum_product\n\
  \    candidate = method(:sum_product)\n    assert_equal([0, 1], candidate.call([]))\n\
  \    assert_equal([3, 1], candidate.call([1, 1, 1]))\n    assert_equal([100, 0],\
  \ candidate.call([100, 0]))\n    assert_equal([15, 105], candidate.call([3, 5, 7]))\n\
  \    assert_equal([10, 10], candidate.call([10]))\n  end\nend\n"
completions: ["\treturn 0, 1 if numbers.empty?\n\tnumbers.inject(:+), numbers.inject(:*)\n\
    end", "  return [numbers.sum, numbers.reduce(:*)]\nend", "    if numbers.length\
    \ == 0\n        return 0, 1\n    else\n        return numbers.sum, numbers.inject(:*)\n\
    \    end\nend", "  return 0, 1 if numbers.empty?\n  numbers.reduce(:+), numbers.reduce(:*)\n\
    end", "\tsum = 0\n\tproduct = 1\n\tnumbers.each do |n|\n\t\tsum += n\n\t\tproduct\
    \ *= n\n\tend\n\treturn sum, product\nend", "  numbers.empty? ? [0, 1] : [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend",
  "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  sum = 0\n  product = 1\n \
    \ numbers.each do |number|\n    sum += number\n    product *= number\n  end\n\
    \  return sum, product\nend", "  return [numbers.sum, numbers.reduce(:*)]\nend",
  "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  numbers.inject([0, 1]) do |sum_product, number|\n    [sum_product[0]\
    \ + number, sum_product[1] * number]\n  end\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  return 0, 1 if numbers.empty?\n  sum = numbers.reduce(:+)\n  product\
    \ = numbers.reduce(:*)\n  return sum, product\nend", "  sum = 0\n  product = 1\n\
    \  if numbers.length < 1\n    return [sum, product]\n  else\n    numbers.each\
    \ do |i|\n      sum += i\n      product *= i\n    end\n    return [sum, product]\n\
    \  end\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum +=\
    \ number\n    product *= number\n  end\n  return sum, product\nend", "  sum =\
    \ 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n\
    \  end\n  [sum, product]\nend", "  return [numbers.sum, numbers.reduce(:*)]\n\
    end", "  # sum = 0\n  # product = 1\n  # numbers.each do |number|\n  #   sum +=\
    \ number\n  #   product *= number\n  # end\n  # [sum, product]\n  [numbers.sum,\
    \ numbers.inject(:*)]\nend", "\treturn [numbers.sum, numbers.reduce(:*)]\nend",
  "  if numbers.empty?\n    sum = 0\n    product = 1\n  else\n    sum = numbers.reduce(:+)\n\
    \    product = numbers.reduce(:*)\n  end\n  [sum, product]\nend", "  # numbers.empty?\
    \ ? return (0, 1) : return (numbers.sum, numbers.inject(:*))\n  (numbers.sum,\
    \ numbers.inject(:*))\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend",
  "  [numbers.sum, numbers.inject(:*)]\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return sum, product\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n  end\n  return\
    \ sum, product\nend", "\nend", "  product = 1\n  sum = 0\n  numbers.each do |x|\n\
    \    product *= x\n    sum += x\n  end\n  return sum, product\nend", "  sum =\
    \ 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  return sum, product\nend", "  numbers.inject([0, 1]) { |arr,\
    \ num| [arr[0] + num, arr[1] * num] }\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |number|\n    sum += number\n    product *= number\n  end\n  return sum,\
    \ product\nend", "\t[numbers.reduce(:+), numbers.reduce(:*)]\nend", "  if numbers.empty?\n\
    \    return 0, 1\n  else\n    return numbers.sum, numbers.inject(:*)\n  end\n\
    end", "  if numbers.length == 0\n    return 0, 1\n  else\n    sum = 0\n    product\
    \ = 1\n    numbers.each do |x|\n      sum += x\n      product *= x\n    end\n\
    \    return sum, product\n  end\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", end, "  [numbers.sum, numbers.reduce(:*)]\nend", "  return [numbers.sum,\
    \ numbers.reduce(:*)]\nend", "  product = 1\n  sum = 0\n  numbers.each do |element|\n\
    \    product *= element\n    sum += element\n  end\n  return sum, product\nend",
  "  numbers.inject { |sum, x| sum + x }\n  numbers.inject { |product, x| product\
    \ * x }\nend", "\t\n\tsum = 0\n\tproduct = 1\n\t\n\tnumbers.each do |i|\n\t\t\
    sum += i\n\t\tproduct *= i\n\tend\n\t\n\treturn sum, product\n\t\nend", "  return\
    \ [numbers.sum, numbers.inject(:*)]\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |number|\n    sum += number\n    product *= number\n  end\n  return sum,\
    \ product\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  numbers.empty?\
    \ ? [0, 1] : [numbers.sum, numbers.inject(:*)]\nend", "\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |n|\n    sum += n\n    product *= n\n  end\n  puts sum,\
    \ product\nend\nsum_product([1, 2, 3, 4])", "    return numbers.sum, numbers.inject(:*)\n\
    end", "  num_sum = 0\n  num_prod = 1\n  for num in numbers\n    num_sum += num\n\
    \    num_prod *= num\n  end\n  return num_sum, num_prod\nend", "  return [numbers.sum,\
    \ numbers.inject(:*)]\nend", "  return (0, 1) if numbers.empty?\n  { sum: numbers.reduce(:+),\
    \ product: numbers.reduce(:*) }\nend", "  # add your code here\n  return [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend\nputs \"Enter array of numbers\"\narr = gets.chomp.split(\"\
    \ \").map { |x| x.to_i }\nsum_product(arr)", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  numbers.inject([0, 1]) do |sum_product, number|\n    [sum_product[0]\
    \ + number, sum_product[1] * number]\n  end\nend", "  sum = 0\n  product = 1\n\
    \  numbers.each do |n|\n    sum += n\n    product *= n\n  end\n  return sum, product\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n   \
    \ product *= num\n  end\n  return sum, product\nend", "  if numbers.empty?\n \
    \   sum = 0\n    product = 1\n  else\n    sum = numbers.inject(:+)\n    product\
    \ = numbers.inject(:*)\n  end\n  return sum, product\nend\nputs sum_product([1,\
    \ 2, 3, 4])", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum +=\
    \ number\n    product *= number\n  end\n  return sum, product\nend", end, "  \
    \  if numbers.length == 0\n        return 0, 1\n    else\n        total_sum =\
    \ 0\n        total_product = 1\n        numbers.each do |num|\n            total_sum\
    \ += num\n            total_product *= num\n        end\n        return total_sum,\
    \ total_product\n    end\nend", "  sum = 0\n  product = 1\n  numbers.each do |num|\n\
    \    sum += num\n    product *= num\n  end\n  return sum, product\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |x|\n    sum += x\n    product *= x\n\
    \  end\n  return sum, product\nend", "  return 0, 1 if numbers.empty?\n  num_sum\
    \ = numbers.reduce(:+)\n  num_product = numbers.reduce(:*)\n  return num_sum,\
    \ num_product\nend", "  return (0, 1) if numbers.empty?\n  sum = numbers.inject(:+)\n\
    \  product = numbers.inject(:*)\n  [sum, product]\nend", "\nend", "  sum = 0\n\
    \  product = 1\n  for i in numbers\n    sum += i\n    product *= i\n  end\n  return\
    \ sum, product\nend", "  sum, product = 0, 1\n  numbers.each do |n|\n    sum +=\
    \ n\n    product *= n\n  end\n  [sum, product]\nend", "\tnumbers.empty? ? (0,\
    \ 1) : (numbers.reduce(:+), numbers.reduce(:*))\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  if numbers.length == 0\n    return 0, 1\n  else\n\
    \    prod = 1\n    numbers.each do |num|\n      prod *= num\n    end\n    return\
    \ numbers.reduce(:+), prod\n  end\nend", "  nums = numbers.inject { |sum, num|\
    \ sum + num }\n  prods = numbers.inject { |prod, num| prod * num }\n  numbers.empty?\
    \ ? (0, 1) : (nums, prods)\nend", "  numbers.inject { |sum, number| sum + number\
    \ } * numbers.inject { |product, number| product * number }\nend", "  [numbers.sum,\
    \ numbers.reduce(:*)]\nend", "  return [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return sum, product\nend", "    sum = 0\n   \
    \ product = 1\n    for item in numbers\n        sum += item\n        product *=\
    \ item\n    end\n    return [sum, product]\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return sum, product\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |n|\n    sum += n\n    product *= n\n  end\n  return\
    \ sum, product\nend\nputs sum_product([])\nputs sum_product([1, 2, 3, 4])", " \
    \ return [numbers.sum, numbers.inject(:*)]\nend", "  sum, product = numbers.reduce([0,\
    \ 1]) do |(sum, product), element|\n    [sum + element, product * element]\n \
    \ end\n  [sum, product]\nend", "  sum = 0\n  product = 1\n  for n in numbers\n\
    \    sum += n\n    product *= n\n  end\n  return sum, product\nend", "  sum =\
    \ 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n\
    \  end\n  return sum, product\nend", "  numbers.empty? ? [0, 1] : [numbers.sum,\
    \ numbers.inject(:*)]\nend", "  numbers.sum * numbers.inject(:*)\nend", "  if\
    \ numbers.empty?\n    sum = 0\n    product = 1\n  else\n    sum = numbers.inject(:+)\n\
    \    product = numbers.inject(:*)\n  end\n  return sum, product\nend", "  return\
    \ 0, 1 if numbers.empty?\n  numbers.reduce(:+), numbers.reduce(:*)\nend", "  numbers.empty?\
    \ ? [0, 1] : [numbers.reduce(:+), numbers.reduce(:*)]\nend", "    return 0, 1\
    \ if numbers.empty?\n    numbers.inject(:+), numbers.inject(:*)\nend", "  if numbers.empty?\n\
    \    return [0, 1]\n  else\n    return [numbers.reduce(:+), numbers.reduce(:*)]\n\
    \  end\nend", "  numbers.sum.even? ? [numbers.sum, numbers.product] : [numbers.sum,\
    \ numbers.inject(:*)]\nend", "  if numbers.empty?\n    return 0, 1\n  else\n \
    \   sum = 0\n    product = 1\n    numbers.each do |number|\n      sum += number\n\
    \      product *= number\n    end\n    return sum, product\n  end\nend", "  return\
    \ [numbers.sum, numbers.inject(:*)]\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |x|\n    sum += x\n    product *= x\n  end\n  return sum, product\nend",
  "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n    product\
    \ *= number\n  end\n  [sum, product]\nend", "  return [numbers.sum, numbers.reduce(:*)]\n\
    end\np sum_product([])\np sum_product([1, 2, 3, 4])", "  # write your code here\n\
    end", "  return [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  return numbers.sum,\
    \ numbers.reduce(:*)\nend", "  # Your code here\nend", "    if numbers.length\
    \ == 0\n        return [0, 1]\n    end\n    sum = 0\n    product = 1\n    numbers.each\
    \ do |number|\n        sum += number\n        product *= number\n    end\n   \
    \ return [sum, product]\nend", "  if numbers.empty?\n    return [0, 1]\n  else\n\
    \    sum = 0\n    product = 1\n    numbers.each do |number|\n      sum += number\n\
    \      product *= number\n    end\n    return [sum, product]\n  end\nend", " \
    \ # unless numbers.empty?\n  #   numbers.inject(:*)\n  #   numbers.inject(:+)\n\
    \  # end\n  # numbers.reduce { |sum, product| [sum + product, product * product]\
    \ }\n  [numbers.inject(:+), numbers.inject(:*)]\nend", '', "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  return [numbers.sum, numbers.inject(:*)]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |x|\n    sum += x\n    product *= x\n  end\n  return\
    \ sum, product\nend", "    sum = 0\n    product = 1\n    numbers.each do |number|\n\
    \        sum += number\n        product *= number\n    end\n    [sum, product]\n\
    end", "\tsum = 0\n\tproduct = 1\n\tnumbers.each do |number|\n\t\tsum += number\n\
    \t\tproduct *= number\n\tend\n\t(sum, product)\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  product = 1\n  if numbers.empty?\n    return sum, product\n\
    \  else\n    numbers.each do |number|\n      sum += number\n      product *= number\n\
    \    end\n    return sum, product\n  end\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  return [numbers.sum, numbers.inject(:*)]\nend", "  return [numbers.sum,\
    \ numbers.reduce(:*)]\nend", "    return 0, 1 if numbers.empty?\n    numbers.reduce(:+),\
    \ numbers.reduce(:*)\nend", "  # your code here\nend", "  numbers.empty? ? [0,\
    \ 1] : [numbers.sum, numbers.reduce(:*)]\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return sum, product\nend", "  [numbers.sum, numbers.inject(:*)]\n\
    end", "  sum = 0\n  prod = 1\n  numbers.each do |num|\n    sum += num\n    prod\
    \ *= num\n  end\n  return sum, prod\nend", "\treturn numbers.inject(:+), numbers.inject(:*)\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum += number\n\
    \    product *= number\n  end\n  return sum, product\nend", "    sum = 0\n   \
    \ product = 1\n    numbers.each do |number|\n        sum += number\n        product\
    \ *= number\n    end\n    return sum, product\nend", "  if numbers.length == 0\n\
    \    return [0, 1]\n  else\n    sum = 0\n    product = 1\n    numbers.each do\
    \ |num|\n      sum += num\n      product *= num\n    end\n    return [sum, product]\n\
    \  end\nend", "  sum = 0\n  product = 1\n  numbers.each do |number|\n    sum +=\
    \ number\n    product *= number\n  end\n  return sum, product\nend", "  numbers.sum\
    \ && numbers.inject(:*)\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\nend",
  "  return [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  sum = 0\n  product\
    \ = 1\n  numbers.each do |number|\n    sum += number\n    product *= number\n\
    \  end\n  return sum, product\nend", "  [numbers.sum, numbers.reduce(:*)]\nend",
  "  numbers.reduce([0, 1]) { |(s, p), n| [s + n, p * n] }\nend", end, "  return 0,\
    \ 1 if numbers.empty?\n  numbers.reduce(:+), numbers.reduce(:*)\nend", "  return\
    \ [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  if numbers.empty?\n    return\
    \ 0, 1\n  else\n    sum = 0\n    product = 1\n    numbers.each do |number|\n \
    \     sum += number\n      product *= number\n    end\n    return sum, product\n\
    \  end\nend", "  return [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  # sum\
    \ = numbers.reduce(:+)\n  # product = numbers.reduce(:*)\n  sum = numbers.inject(0,\
    \ :+)\n  product = numbers.inject(1, :*)\n  return [sum, product]\nend", "  sum\
    \ = 0\n  product = 1\n  numbers.each do |n|\n    sum += n\n    product *= n\n\
    \  end\n  return sum, product\nend", "    sum = 0\n    product = 1\n    numbers.each\
    \ do |num|\n        sum += num\n        product *= num\n    end\n    return sum,\
    \ product\nend", "  return [numbers.sum, numbers.inject(:*)]\nend", "  return\
    \ [numbers.sum, numbers.inject(:*)]\nend", "  return 0, 1 if numbers.empty?\n\
    \  [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  if numbers.empty?\n    return 0, 1\n  else\n    return numbers.reduce(:+),\
    \ numbers.reduce(:*)\n  end\nend", "\tarr = []\n\tarr << numbers.inject(0) { |sum,\
    \ num| sum + num }\n\tarr << numbers.inject(1) { |product, num| product * num\
    \ }\n\tarr\nend", "  numbers.inject([0, 1]) { |(sum, product), number| [sum +\
    \ number, product * number] }\nend", "  [numbers.sum, numbers.inject(:*)]\nend",
  "  sum = 0\n  product = 1\n  if numbers.empty?\n    (sum, product)\n  else\n   \
    \ numbers.each do |number|\n      sum += number\n      product *= number\n   \
    \ end\n    (sum, product)\n  end\nend", "  return [numbers.sum, numbers.inject(:*)]\n\
    end", "  return [numbers.reduce(:+), numbers.reduce(:*)]\nend", "  return [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  [numbers.sum, numbers.reduce(:*)]\nend", "\tresult\
    \ = numbers.inject([0, 1]) do |current, new|\n\t\tcurrent[0] += new\n\t\tcurrent[1]\
    \ *= new\n\t\tcurrent\n\tend\n\treturn result\nend", "    return [numbers.sum,\
    \ numbers.inject(:*)]\nend", "  sum = 0\n  product = 1\n  numbers.each do |n|\n\
    \    sum += n\n    product *= n\n  end\n  return sum, product\nend", "  if numbers.empty?\n\
    \    [0, 1]\n  else\n    [numbers.sum, numbers.reduce(:*)]\n  end\nend", "  return\
    \ [numbers.sum, numbers.inject(:*)]\nend", "  if numbers.length == 0\n    sum\
    \ = 0\n    product = 1\n  else\n    sum = numbers.inject(:+)\n    product = numbers.inject(:*)\n\
    \  end\n  return sum, product\nend", "  sum = 0\n  product = 1\n  numbers.each\
    \ do |n|\n    sum += n\n    product *= n\n  end\n  return sum, product\nend",
  "\nend", "  return [numbers.sum, numbers.product]\nend", "  return [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  return [numbers.sum, numbers.inject(:*)]\nend",
  "  numbers.sum, numbers.inject(:*)\nend", "  return [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  numbers.inject([0, 1]) { |(sum, product), n| [sum + n, product * n] }\n\
    end", "  \"Write your method here\"\nend", "  sum = 0\n  product = 1\n  if numbers.empty?\n\
    \    return sum, product\n  else\n    numbers.each do |n|\n      sum += n\n  \
    \    product *= n\n    end\n    return sum, product\n  end\nend", "  [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  numbers.empty? ? [0, 1] : [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  return 0, 1 if numbers.empty?\n  numbers.reduce(:+),\
    \ numbers.reduce(:*)\nend", "\tnumbers.empty? ? [0, 1] : [numbers.reduce(:+),\
    \ numbers.reduce(:*)]\nend", "  sum = 0\n  product = 1\n  numbers.each do |num|\n\
    \    sum += num\n    product *= num\n  end\n  [sum, product]\nend", "  sum = 0\n\
    \  product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n\
    \  end\n  return sum, product\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  sum = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n   \
    \ product *= num\n  end\n  return sum, product\nend", "  return [numbers.sum,\
    \ numbers.inject(:*)]\nend\nputs sum_product([1, 2, 3, 4])", "  # *args\n  sum\
    \ = 0\n  product = 1\n  numbers.each do |num|\n    sum += num\n    product *=\
    \ num\n  end\n  [sum, product]\nend", "  [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "\nend", "  return [numbers.sum, numbers.inject(:*)]\nend\np sum_product([])\n\
    p sum_product([1, 2, 3, 4])", "  return 0, 1 if numbers.empty?\n  numbers.inject(:+),\
    \ numbers.inject(:*)\nend", "  if numbers.length == 0\n    sum = 0\n    product\
    \ = 1\n  else\n    sum = numbers.inject { |sum, n| sum + n }\n    product = numbers.inject\
    \ { |product, n| product * n }\n  end\n  return sum, product\nend", "  sum = 0\n\
    \  product = 1\n  numbers.each do |num|\n    sum += num\n    product *= num\n\
    \  end\n  return sum, product\nend", "\nend", "  return [numbers.sum, numbers.reduce(:*)]\n\
    end", "  return 0, 1 if numbers.empty?\n  sum, product = 0, 1\n  numbers.each\
    \ do |number|\n    sum += number\n    product *= number\n  end\n  return sum,\
    \ product\nend", "\tif numbers.empty?\n\t\treturn [0, 1]\n\telse\n\t\tsum = 0\n\
    \t\tproduct = 1\n\t\tnumbers.each do |number|\n\t\t\tsum += number\n\t\t\tproduct\
    \ *= number\n\t\tend\n\t\treturn [sum, product]\n\tend\nend", "  return [numbers.sum,\
    \ numbers.inject(:*)]\nend\np sum_product([])\np sum_product([1, 2, 3, 4])", "\n\
    end", "  if numbers.empty?\n    return 0, 1\n  else\n    [numbers.sum, numbers.reduce(:*)]\n\
    \  end\nend", "  numbers.empty? ? (0, 1) : [numbers.reduce(:+), numbers.reduce(:*)]\n\
    end", "  # implementation here\nend", "  [numbers.sum, numbers.inject(:*)]\nend",
  "  return [numbers.sum, numbers.inject(:*)]\nend", "  numbers.inject { |result,\
    \ number| result ? [result[0] + number, result[1] * number] : [number, number]\
    \ }\nend", "  # numbers.inject(:+), numbers.inject(:*)\n  [numbers.inject(:+),\
    \ numbers.inject(:*)]\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
