name: HumanEval_120_maximum
language: rb
prompt: "# Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n# of length k with the maximum k numbers in arr.\n# Example 1:\n# Input:\
  \ arr = [-3, -4, 5], k = 3\n# Output: [-4, -3, 5]\n# Example 2:\n# Input: arr =\
  \ [4, -4, 4], k = 2\n# Output: [4, 4]\n# Example 3:\n# Input: arr = [-3, 2, 1, 2,\
  \ -1, -2, 1], k = 1\n# Output: [2]\n# Note:\n# 1. The length of the array will be\
  \ in the range of [1, 1000].\n# 2. The elements in the array will be in the range\
  \ of [-1000, 1000].\n# 3. 0 <= k <= len(arr)\ndef maximum(arr, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_maximum\n\
  \    candidate = method(:maximum)\n    assert_equal([-4, -3, 5], candidate.call([-3,\
  \ -4, 5], 3))\n    assert_equal([4, 4], candidate.call([4, -4, 4], 2))\n    assert_equal([2],\
  \ candidate.call([-3, 2, 1, 2, -1, -2, 1], 1))\n    assert_equal([2, 20, 123], candidate.call([123,\
  \ -123, 20, 0, 1, 2, -3], 3))\n    assert_equal([0, 1, 2, 20], candidate.call([-123,\
  \ 20, 0, 1, 2, -3], 4))\n    assert_equal([-13, -8, 0, 0, 3, 5, 15], candidate.call([5,\
  \ 15, 0, 3, -13, -8, 0], 7))\n    assert_equal([3, 5], candidate.call([-1, 0, 2,\
  \ 5, 3, -10], 2))\n    assert_equal([5], candidate.call([1, 0, 5, -7], 1))\n   \
  \ assert_equal([-4, 4], candidate.call([4, -4], 2))\n    assert_equal([-10, 10],\
  \ candidate.call([-10, 10], 2))\n    assert_equal([], candidate.call([1, 2, 3, -23,\
  \ 243, -400, 0], 0))\n  end\nend\n"
completions: ["  n = arr.size\n  quick_select(arr, 0, n - 1, n - k)\n  arr[n - k,\
    \ k]\nend", "  arr.sort.last(k)\nend", "  return if arr.nil? || arr.length ==\
    \ 0 || k <= 0 || k > arr.length\n  # Find the kth largest element in arr, which\
    \ is the (len - k)th smallest element\n  # in arr. Since the expected time complexity\
    \ is O(N) and space complexity is \n  # O(1), quick select is used to solve this\
    \ problem.\n  findKth(arr, 0, arr.length - 1, arr.length - k)\n  arr[0, k]\nend",
  "  # create a priority queue and take k largest elements\n  pq = PriorityQueue.new(arr)\n\
    \  arr = []\n  k.times do\n    arr << pq.pop\n  end\n  arr\nend", "\treturn arr\
    \ if arr.size <= k\n\tqueue = arr[0..k-1]\n\tqueue.sort!\n\t(k..arr.size-1).each\
    \ do |i|\n\t\tj = 0\n\t\twhile j < k\n\t\t\tif arr[i] > queue[j]\n\t\t\t\tqueue.insert(j,\
    \ arr[i])\n\t\t\t\tqueue.pop\n\t\t\t\tbreak\n\t\t\tend\n\t\t\tj += 1\n\t\tend\n\
    \tend\n\tqueue\nend", "  return [] if arr.nil? || arr.empty? || k < 1 || k > arr.size\n\
    \  hash = Hash.new(0)\n  arr.each { |e| hash[e] += 1 }\n  ans = []\n  hash.keys.sort.reverse.each\
    \ do |num|\n    num_count = hash[num]\n    if num_count > k\n      k.times { ans\
    \ << num }\n      return ans\n    else\n      num_count.times { ans << num }\n\
    \      k -= num_count\n    end\n  end\n  ans\nend\narr1 = [-3, -4, 5]\nk1 = 3\n\
    arr2 = [4, -4, 4]\nk2 = 2\narr3 = [-3, 2, 1, 2, -1, -2, 1]\nk3 = 1\nputs \"max\
    \ arr = #{arr1}, k = #{k1} is #{maximum(arr1, k1)}\"\nputs \"max arr = #{arr2},\
    \ k = #{k2} is #{maximum(arr2, k2)}\"\nputs \"max arr = #{arr3}, k = #{k3} is\
    \ #{maximum(arr3, k3)}\"", "  arr.sort.slice(-k, k)\nend", "  maxes = []\n  k.times\
    \ do\n    max_value = arr.max\n    maxes << max_value\n    arr.delete(max_value)\n\
    \  end\n  maxes\nend\narr = [-3, -4, 5]\nk = 3", "  arr.sort! { |a, b| b <=> a\
    \ }\n  arr[0...k]\nend", "\t# ToDo:\nend", end, "  heap = BinaryMinHeap.new {\
    \ |x, y| y <=> x }\n  arr.each do |ele|\n    heap.push(ele)\n    heap.extract\
    \ if heap.count > k\n  end\n  heap.store\nend", "  arr.min(k).sort.reverse\nend",
  "  arr.sort![-k..-1]\nend", "  start = 0\n  arr[0...k].each_with_index do |item,\
    \ index|\n    if item > arr[start]\n      start = index\n    end\n  end\n  arr[start..-1].each\
    \ do |item|\n    if item > arr[start]\n      arr[start] = item\n      start =\
    \ 0\n      arr[0...k].each_with_index do |item, index|\n        if item > arr[start]\n\
    \          start = index\n        end\n      end\n    end\n  end\n  arr[0...k]\n\
    end", "  return arr if arr.size <= k\n  i = 0\n  while i < k\n    j = i + 1\n\
    \    while j < arr.size\n      if arr[i] < arr[j]\n        arr[i], arr[j] = arr[j],\
    \ arr[i]\n      end\n      j += 1\n    end\n    i += 1\n  end\n  arr[0..k-1]\n\
    end", "  arr.max(k)\nend", end, "  # arr.sort[-k..-1]\n  arr.sort[-k..-1].reverse\n\
    end", "  if arr.length == k\n    return arr.sort\n  end\n  if arr.length == 1\n\
    \    return arr\n  end\n  if arr.length == 2\n    if arr[0] > arr[1]\n      arr[0],\
    \ arr[1] = arr[1], arr[0]\n    end\n    return arr[0..k - 1]\n  end\n  pivot =\
    \ arr[arr.length / 2]\n  left = []\n  right = []\n  for i in 0...arr.length\n\
    \    if arr[i] < pivot\n      left.push(arr[i])\n    else\n      right.push(arr[i])\n\
    \    end\n  end\n  if left.length >= k\n    return maximum(left, k)\n  elsif left.length\
    \ == k - 1\n    return left.push(pivot).sort\n  else\n    right = maximum(right,\
    \ k - left.length - 1)\n    return left.push(pivot).push(right).flatten.sort\n\
    \  end\nend", "  heap = Heap.new\n  length = arr.length\n  i = 0\n  while i <\
    \ length\n    heap.push(arr[i])\n    if heap.size > k\n      heap.pop\n    end\n\
    \    i += 1\n  end\n  res = []\n  while heap.size > 0\n    res.push(heap.pop)\n\
    \  end\n  res.reverse\nend", "  # Loop invariant: Maximum k elements with highest\
    \ absolute value are in heap.\n  max_heap = Heap.new(arr.length) { |a, b| a.abs\
    \ < b.abs }\n  arr.each do |num|\n    if max_heap.size < k\n      max_heap.add(num)\n\
    \    else\n      if num.abs > max_heap.peek.abs\n        max_heap.poll\n     \
    \   max_heap.add(num)\n      end\n    end\n  end\n  max_heap.to_a.reverse\nend",
  "  arr.sort.reverse.take(k)\nend", "  arr.sort[-k..-1]\nend", end, "  # write your\
    \ code here\n  # my function\n  return [] if arr.length == 0\n  arr = arr.sort_by(&:abs).reverse\n\
    \  arr.first(k)\nend", "  arr.sort[-k..-1]\nend", "  return arr if arr.length\
    \ <= k\n  partition(arr, 0, arr.length - 1, k)\n  arr[0...k]\nend", "\tres = []\n\
    \treturn res if arr.empty? || k == 0\n\tarr.each do |num|\n\t\tres.push(num) if\
    \ res.size < k\n\t\tres.push(num)\n\t\tres.shift while res.size > k\n\tend\n\t\
    res\nend", "  i = arr.size - 1\n  j = i - 1\n  while k > 0\n    while j >= 0 &&\
    \ arr[j] < arr[i]\n      j -= 1\n    end\n    if j < 0 || arr[j] >= arr[i]\n \
    \     arr[j + 1], arr[i] = arr[i], arr[j + 1]\n      i -= 1\n      j = i - 1\n\
    \      k -= 1\n    end\n  end\n  arr[0...k]\nend\narr1 = [-3, -4, 5]\nk1 = 3\n\
    arr2 = [4, -4, 4]\nk2 = 2\narr3 = [-3, 2, 1, 2, -1, -2, 1]\nk3 = 1\nputs maximum(arr1,\
    \ k1)\nputs maximum(arr2, k2)\nputs maximum(arr3, k3)", "    arr.sort!.reverse[0..k-1]\n\
    end", "    # \u5FEB\u901F\u9009\u62E9\u7B97\u6CD5\n    # \u5047\u8BBE\u4ECE\u4E0B\
    \u68070\u5230\u4E0B\u6807i-1\u662F\u5C0F\u4E8E\u7B49\u4E8Ex\u7684\u5143\u7D20\uFF0C\
    \u4E0B\u6807i\u5230\u4E0B\u6807N-1\u662F\u5927\u4E8Ex\u7684\u5143\u7D20\uFF0C\u5219\
    \ i\u5C31\u662Fx\u5728\u6570\u7EC4\u4E2D\u7684rank\n    def quick_select(arr,\
    \ l, r, x)\n        l, r = l - 1, r + 1\n        while true\n            l +=\
    \ 1\n            while arr[l] > x\n                l += 1\n            end\n \
    \           r -= 1\n            while arr[r] < x\n                r -= 1\n   \
    \         end\n            if l >= r\n                return l\n            end\n\
    \            arr[l], arr[r] = arr[r], arr[l]\n        end\n    end\n    rank =\
    \ quick_select(arr, 0, arr.size - 1, arr[0])\n    while rank != k - 1\n      \
    \  if rank > k - 1\n            rank = quick_select(arr, 0, rank - 1, arr[rank\
    \ - 1])\n        else\n            rank = quick_select(arr, rank + 1, arr.size\
    \ - 1, arr[rank + 1])\n        end\n    end\n    arr[0...k]\nend", "  arr.sort!\n\
    \  arr[-k..-1]\nend", "    arr.sort[-k..-1]\nend", "    n = arr.size\n    if k\
    \ > n\n        return nil\n    end\n    num = arr[0..k-1]\n    num.sort!\n   \
    \ i = k\n    while i < n\n        j = 0\n        while j < k\n            if arr[i]\
    \ > num[j]\n                num.insert(j, arr[i])\n                num.pop\n \
    \               break\n            end\n            j += 1\n        end\n    \
    \    i += 1\n    end\n    return num\nend", "  return [] if arr.empty? || k ==\
    \ 0\n  arr.sort! { |a, b| b <=> a }\n  arr[0...k]\nend", "  left, right = 0, arr.size\
    \ - 1\n  while left <= right\n    j = partition(arr, left, right)\n    return\
    \ arr[0...k] if j == k - 1\n    if j < k - 1\n      left = j + 1\n    else\n \
    \     right = j - 1\n    end\n  end\n  arr[0...k]\nend", "    arr.sort!.reverse[0...k]\n\
    end", "  top = arr.sort.last(k)\n  return top\nend", "    arr.sort[-k..-1]\nend",
  "  arr.sort[-k..-1]\nend", "    heap = Heap.new\n    arr.each do |n|\n        heap.push(n)\n\
    \        heap.pop if heap.size > k\n    end\n    heap.to_a.reverse\nend", "  max\
    \ = nil\n  max_i = 0\n  (0...arr.length).each do |i|\n    if max.nil? || max <\
    \ arr[i]\n      max = arr[i]\n      max_i = i\n    end\n  end\n  [max, max_i]\n\
    end", "  arr.sort[arr.length - k..-1]\nend\nputs maximum([-3, -4, 5], 3)\nputs\
    \ maximum([4, -4, 4], 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "  puts\
    \ \"arr: #{arr}, k: #{k}\"\n  ans = []\n  for i in 0...arr.length do\n    while\
    \ !ans.empty? && ans.length + arr.length - i > k && arr[i] > ans.last do\n   \
    \   ans.pop\n    end\n    ans.push(arr[i]) if ans.length < k\n  end\n  ans\nend",
  "    return [] if arr.nil? || arr.empty? || k <= 0 || k > arr.size\n    res = arr[0...k]\n\
    \    res.sort!\n    res = res[k-1]\n    (k...arr.size).each do |i|\n        if\
    \ arr[i] > res\n            res = arr[i]\n            ind = i\n            (ind\
    \ - 1).downto(0) do |j|\n                break if res >= arr[j]\n            \
    \    arr[j+1] = arr[j]\n                arr[j] = res\n            end\n      \
    \  end\n    end\n    arr[0...k]\nend", "    heap = BinaryHeap.new\n    res = []\n\
    \    arr.each do |num|\n        heap.push(num)\n        if heap.size > k\n   \
    \         heap.extract\n        end\n    end\n    while heap.size > 0\n      \
    \  res.unshift(heap.extract)\n    end\n    res\nend", "  heap = MinHeap.new\n\
    \  arr.each do |e|\n    heap.push(e)\n    heap.pop if heap.size > k\n  end\n \
    \ heap.values.reverse\nend", "  max = arr.max\n  max_arr = [max]\n  arr.delete(max)\n\
    \  k -= 1\n  while k > 0\n    curr_max = arr.max\n    if curr_max > max\n    \
    \  max = curr_max\n      max_arr.unshift(max)\n    else\n      max_arr.push(curr_max)\n\
    \    end\n    arr.delete(curr_max)\n    k -= 1\n  end\n  max_arr\nend", "  arr.sort.reverse.first(k)\n\
    end", "  s = arr.slice(0, k)\n  s.sort!\n  arr.each do |n|\n    next if n < s[0]\n\
    \    s.unshift(n)\n    s.pop\n  end\n  s\nend", "  return arr if arr.length <=\
    \ k\n  arr.sort[-k..-1]\nend\nputs maximum([-3, -4, 5], 3)\nputs maximum([4, -4,\
    \ 4], 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "    res = []\n    i = 0\n\
    \    j = 0\n    while res.size < k do\n        cur_max = arr[i]\n        temp\
    \ = i\n        while i < arr.size do\n            cur_max = arr[i] if arr[i] >\
    \ cur_max\n            i += 1\n        end\n        arr[temp] = -10000\n     \
    \   res << cur_max\n    end\n    res\nend", "    arr.sort.reverse[0..k-1]\nend",
  "  return arr if arr.length <= k\n  queue = []\n  arr.each do |num|\n    if queue.length\
    \ < k\n      queue << num\n    else\n      min = queue.min\n      queue.delete(min)\n\
    \      queue << num if num > min\n    end\n  end\n  queue.sort\nend", "  arr.max(k)\n\
    end", "  res = []\n  for i in 0...arr.length\n    if res.length < k\n      res\
    \ << arr[i]\n    else\n      res.sort!\n      if res[0] < arr[i]\n        res.shift\n\
    \        res << arr[i]\n      end\n    end\n  end\n  res.sort!\n  res\nend", "\t\
    arr.sort!\n\treturn arr[0...k]\nend", "    return [] if arr.nil? || arr.empty?\
    \ || k <= 0 || k > arr.size\n    arr.sort!\n    return arr[-k, k]\nend", "  arr.sort!.reverse!\n\
    \  return arr[0..k-1]\nend", "  arr.sort[-k..-1]\nend", "  arr.sort[arr.length\
    \ - k, k]\nend", "    return [] if arr.empty?\n    return arr if k >= arr.size\n\
    \    arr.sort!.reverse[0..k-1]\nend", "    l = arr.length\n    idx = 0\n    result\
    \ = Array.new(k)\n    k.times do\n        i = idx\n        while i < l\n     \
    \       x = result[idx]\n            if x.nil? || arr[i] > x\n               \
    \ result[idx] = arr[i]\n            end\n            i += 1\n        end\n   \
    \     idx += 1\n    end\n    result\nend", "  arr.sort[-k..-1]\nend", "  sort(arr)[0...k]\n\
    end", "    minheap = []\n    arr.each do |ele|\n        heap_insert(minheap, ele)\n\
    \        if minheap.size > k\n            heap_extract_min(minheap)\n        end\n\
    \    end\n    minheap\nend", "    return [] if arr.length == 0 || k == 0\n   \
    \ arr = arr.sort.reverse\n    arr[0...k]\nend", "  arr.max(k)\nend", "    res\
    \ = []\n    for i in 0...arr.length\n        while res.length > 0 && res[-1] <\
    \ arr[i] && res.length - i + 1 > k\n            res.pop\n        end\n       \
    \ res.push(arr[i]) if res.length < k\n    end\n    res\nend", "  q = []\n  arr.each\
    \ do |num|\n    q.push(num)\n    bubble_up(q, q.size - 1)\n    if q.size > k\n\
    \      q[0] = q[-1]\n      q.pop\n      bubble_down(q, 0)\n    end\n  end\n  q\n\
    end", "  res = []\n  len = arr.length\n  (0...len).each do |i|\n    while(!res.empty?\
    \ && res.length + len - i > k && res.last < arr[i])\n      res.pop\n    end\n\
    \    res.push(arr[i]) if res.length < k\n  end\n  res\nend", end, "  # create\
    \ new array with k elements from arr\n  # sort this array with selection sort\n\
    \  # return array\n  new_arr = arr[0..k - 1]\n  for i in 0..new_arr.length - 1\n\
    \    min_index = i\n    for j in i + 1..new_arr.length - 1\n      min_index =\
    \ j if new_arr[j] > new_arr[min_index]\n    end\n    new_arr[i], new_arr[min_index]\
    \ = new_arr[min_index], new_arr[i]\n  end\n  return new_arr\nend", "    out =\
    \ []\n    max = -1001\n    until out.length == k\n        arr.each do |i|\n  \
    \          max = i if i > max\n        end\n        out << max\n        arr.delete(max)\n\
    \        max = -1001\n    end\n    out\nend\nputs maximum([-3, -4, 5], 3)\nputs\
    \ maximum([4, -4, 4], 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "  i = 0\n\
    \  j = arr.size - 1\n  while j - i >= k\n    if arr[i] < arr[j]\n      arr[i],\
    \ arr[j] = arr[j], arr[i]\n      i += 1\n    else\n      j -= 1\n    end\n  end\n\
    \  arr[0...k]\nend", "    h = {}\n    arr.each do |num|\n        h[num] = h[num].to_i\
    \ + 1\n    end\n    out = []\n    while out.size < k\n        max = h.keys.max\n\
    \        k.times { out << max }\n        h.delete(max)\n    end\n    out\nend",
  "  arr.sort[-k..-1]\nend", "  arr.sort[-k..-1]\nend", "  arr.combination(k).to_a.map\
    \ { |comb| comb.reduce(:+) }.max\nend", "  i = 0\n  j = arr.size - 1\n  while\
    \ i < j\n    l = i\n    r = j\n    pivot = arr[(l + r) / 2]\n    while l <= r\n\
    \      while l <= r && arr[l] > pivot\n        l += 1\n      end\n      while\
    \ l <= r && arr[r] < pivot\n        r -= 1\n      end\n      if l <= r\n     \
    \   arr[l], arr[r] = arr[r], arr[l]\n        l += 1\n        r -= 1\n      end\n\
    \    end\n    if j - l + 1 >= k\n      i = l\n    else\n      j = l - 1\n    \
    \  k -= j - l + 1\n    end\n  end\n  arr[0...k]\nend\nputs maximum([-3, -4, 5],\
    \ 3)\nputs maximum([4, -4, 4], 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)",
  "  heap = Array.new()\n  arr.each { |x| \n    heap.push(x)\n    heap_up(heap, heap.size-1)\n\
    \  }\n  return heap if heap.size <= k\n  (heap.size-k).times { |i|\n    swap(heap,\
    \ 0, heap.size-1-i)\n    heapify(heap, 0, heap.size-1-i)\n  }\n  heap\nend", " \
    \ return arr if arr.size <= k\n  size = arr.size\n  arr.sort!\n  arr[size - k..size\
    \ - 1]\nend\nputs maximum([-3, -4, 5], 3)", "  arr.sort[-k..-1]\nend", "  arr.sort[-k..-1]\n\
    end", "  arr.sort[-k..-1]\nend", "  heap = Heap.new\n  arr.each do |num|\n   \
    \ heap.add(num)\n    heap.remove if heap.size > k\n  end\n  heap.elements\nend",
  "  l = 0\n  r = arr.size - 1\n  while l < r\n    j = partition(arr, l, r)\n    if\
    \ j == k - 1\n      break\n    elsif j < k - 1\n      l = j + 1\n    else\n  \
    \    r = j - 1\n    end\n  end\n  arr[0...k]\nend", end, "  arr.sort[-k..-1]\n\
    end", "    # 2-way, 2-pointers, sliding window\n    ans = []\n    j = 0\n    for\
    \ i in 0...arr.size\n        while j > 0 && j + (arr.size - i) > k && ans[j -\
    \ 1] < arr[i]\n            j -= 1\n        end\n        if j < k\n           \
    \ ans[j] = arr[i]\n            j += 1\n        end\n    end\n    ans\nend", " \
    \ arr.sort!.reverse[0...k]\nend", "  arr.sort.last(k)\nend", "  heap = MaxHeap.new(arr,\
    \ k)\n  heap.heap\nend", "  arr.sort.last(k)\nend", "  # min_heap\n  # we want\
    \ the heap to be of length k\n  # so we can pop off the smallest value\n  # and\
    \ push the next value into the heap\n  heap = [0] * k\n  (0...k).each do |i|\n\
    \    heap[i] = arr[i]\n  end\n  # heapify\n  (0...k).each do |i|\n    child =\
    \ i\n    parent = child / 2\n    while parent >= 0 && heap[parent] > heap[child]\n\
    \      # swap\n      heap[parent], heap[child] = heap[child], heap[parent]\n \
    \     child = parent\n      parent = child / 2\n    end\n  end\n  (k...arr.length).each\
    \ do |i|\n    if arr[i] > heap[0]\n      heap[0] = arr[i]\n      parent = 0\n\
    \      left = parent * 2 + 1\n      right = parent * 2 + 2\n      while left <\
    \ k && (heap[parent] > heap[left] || heap[parent] > heap[right])\n        if heap[left]\
    \ < heap[right]\n          heap[parent], heap[left] = heap[left], heap[parent]\n\
    \          parent = left\n        else\n          heap[parent], heap[right] =\
    \ heap[right], heap[parent]\n          parent = right\n        end\n        left\
    \ = parent * 2 + 1\n        right = parent * 2 + 2\n      end\n    end\n  end\n\
    \  heap\nend", "  # res = [], arr.each do |num|\n  #   idx = res.size-1\n  # \
    \  if idx < 0\n  #     res << num\n  #   elsif num < res[idx]\n  #     next\n\
    \  #   elsif num >= res[idx]\n  #     idx -= 1 while idx >= 0 && num >= res[idx]\n\
    \  #     res.insert(idx+1, num)\n  #   end\n  #   res.shift if res.size > k\n\
    \  # end\n  # res", "    return arr.sort[-k, k]\nend", "    heap = BinaryHeap.new()\n\
    \    for i in arr do\n        heap.insert(i)\n        if heap.size() > k\n   \
    \         heap.pop()\n        end\n    end\n    heap.sorted()\nend", "    #O(nlogn),\
    \ not good for large array\n    # arr.sort![arr.length-k..-1]\n    #O(n)\n   \
    \ # return arr if arr.length == k\n    # answer = []\n    # until answer.length\
    \ == k\n    #     answer.push(arr.max)\n    #     arr.delete(arr.max)\n    # end\n\
    \    # answer\n    #create two arrays, one the first k elements\n    #and one\
    \ the last k elements\n    return arr if arr.length == k\n    arr = arr.sort\n\
    \    first = arr[0...k]\n    last = arr[-k..-1]\n    max_arr = []\n    until max_arr.length\
    \ == k\n        #compare the first element of each array\n        if first[0]\
    \ > last[0]\n            max_arr.push(first.shift)\n        else\n           \
    \ max_arr.push(last.shift)\n        end\n    end\n    max_arr\nend", "  return\
    \ [] if arr.length == 0\n  arr.sort[-k..-1]\nend", "  return arr.max(k)\nend",
  "\tarr.sort!.reverse[0...k]\nend", "\tarr.sort.last(k)\nend", "  # Given an array\
    \ arr of integers and a positive integer k, return a sorted list \n  # of length\
    \ k with the maximum k numbers in arr.\n  arr.sort.last(k)\nend", "  return arr\
    \ if arr.size == k\n  arr.sort.reverse.take(k)\nend", "  results = []\n  i = 0\n\
    \  while i < arr.length\n    curr = arr[i]\n    j = 0\n    while j < results.length\n\
    \      if curr > results[j]\n        results.insert(j, curr)\n        break\n\
    \      end\n      j += 1\n    end\n    results << curr if j == results.length\n\
    \    results.shift if results.length > k\n    i += 1\n  end\n  results\nend",
  "    arr.select{|x| x > 0}.sort.last(k)\nend", "    arr.sort.reverse[0...k]\nend",
  "  # quick_select(arr, 0, arr.size - 1, k)\n  heap_select(arr, k)\nend", "  arr.sort[-k..-1]\n\
    end", "\tn = arr.length\n\tres = []\n\ti = 0\n\twhile i < n\n\t\tif res.length\
    \ < k\n\t\t\tres << arr[i]\n\t\telse\n\t\t\tif arr[i] > res[0]\n\t\t\t\tres.shift\n\
    \t\t\t\tres << arr[i]\n\t\t\tend\n\t\tend\n\t\ti += 1\n\tend\n\tres.sort\nend",
  "  arr.max(k)\nend", "    arr.sort[0...k]\nend", "    return arr.sort.reverse.first(k)\n\
    end", "  # TODO\nend", "  arr.sort!\n  arr[-k..-1]\nend", "  arr = arr.sort.last(k)\n\
    end", "  arr = arr.sort()\n  return arr[-k..-1]\nend", "    return [] if k ==\
    \ 0\n    ans = []\n    (0...arr.length).each do |i|\n        while ans.length\
    \ != 0 && ans[-1] < arr[i] && ans.length + arr.length - i > k\n            ans.pop\n\
    \        end\n        ans.push(arr[i]) if ans.length < k\n    end\n    ans\nend",
  "    arr.sort.reverse[0..k-1]\nend", "  arr.sort!\n  (arr.length - k...arr.length).map\
    \ { |i| arr[i] }\nend", "  heap = MaxHeap.new(arr)\n  res = []\n  k.times do \n\
    \    res << heap.max\n    heap.extract_max\n  end\n  res\nend", "  return arr\
    \ if arr.length == k\n  arr = arr.sort\n  arr[arr.length - k...arr.length]\nend",
  "    # k <= arr.size\n    return arr.sort[-k..-1]\nend", "  arr.sort[-k..-1]\nend",
  "    [-arr.sort.take(k), arr.sort.last(k)].min\nend", "  return arr.max(k)\nend\n\
    arr = [-3, -4, 5]\nk = 3\nprint maximum(arr, k)\nputs\narr = [4, -4, 4]\nk = 2\n\
    print maximum(arr, k)\nputs\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\nprint maximum(arr,\
    \ k)\nputs", "  ret = []\n  arr.each do |i|\n    while !ret.empty? && ret.size\
    \ == k && ret.last < i\n      ret.pop\n    end\n    ret.push(i) if ret.size <\
    \ k\n  end\n  ret\nend\nputs maximum([-3, -4, 5], 3)\nputs maximum([4, -4, 4],\
    \ 2)\nputs maximum([-3, 2, 1, 2, -1, -2, 1], 1)", "\tarr.sort!\n\tarr[arr.length\
    \ - k..arr.length - 1]\nend", "  a = arr.sort\n  a[-k, k]\nend", "\treturn arr\
    \ if arr.size == k\n\theap = Heap.new\n\tfor i in 0...arr.size\n\t\theap.insert(arr[i])\n\
    \t\theap.delete if heap.size > k\n\tend\n\theap.delete until heap.empty?\n\theap.max_heap.map{|n|\
    \ n.value}\nend", "    arr.sort.last(k)\nend", "    heap = Heap.new(arr.size)\
    \ { |x, y| y <=> x }\n    arr.each { |n| heap.push(n) }\n    result = []\n   \
    \ while !heap.empty? && k > 0\n        result << heap.pop\n        k -= 1\n  \
    \  end\n    result\nend", "  heap = []\n  i = 0\n  while i < k\n    heap << arr[i]\n\
    \    i += 1\n  end\n  i = k\n  j = 0\n  while i < arr.length\n    if arr[i] >\
    \ heap[0]\n      heap[0] = arr[i]\n      heapify(heap, 0)\n    end\n    i += 1\n\
    \  end\n  heap\nend", "    return [] if k == 0\n    # return arr.max(k)  # =>\
    \ [-4, -3, 5]\n    # return arr.sort.last(k)  # => [-4, -3, 5]\n    # puts(arr.sort.last(k))",
  "    # Sort\n    k = arr.length if k > arr.length\n    if k == 1\n        return\
    \ [arr.max]\n    end\n    arr = arr.sort\n    if k == arr.length\n        return\
    \ arr\n    end\n    return arr[arr.length - k..-1]\nend", "  return [] if arr.empty?\n\
    \  return arr if k >= arr.size\n  index_to_value_hash = Hash.new\n  arr.each do\
    \ |el|\n    index_to_value_hash[el] = el\n  end\n  sorted_hash = index_to_value_hash.sort_by\
    \ { |k, v| v }\n  sorted_hash.reverse.take(k).to_h.values\nend", "    return []\
    \ if k <= 0 || arr.size < k\n    arr.sort![arr.size - k, k]\nend", "  return []\
    \ if arr.empty?\n  heap = Heap.new\n  arr.each do |n|\n    heap.insert(n)\n  \
    \  heap.poll if heap.size > k\n  end\n  heap.to_a\nend", "  arr.sort.last(k)\n\
    end", "  arr = arr.sort\n  return arr[0...k]\nend", "    arr.sort[-k..-1]\nend",
  "  return [] if arr.nil? || arr.length == 0 || k <= 0\n  return arr if k >= arr.length\n\
    \  pos, neg = [], []\n  arr.each do |num|\n    if num >= 0\n      pos << num\n\
    \    else\n      neg << num\n    end\n  end\n  pos = pos.sort_by { |num| -num\
    \ }\n  neg = neg.sort\n  if pos.length == 0\n    neg[0, k]\n  elsif neg.length\
    \ == 0\n    pos[0, k]\n  else\n    pos.concat(neg)\n    pos[0, k]\n  end\nend\n\
    arr = [-3, -4, 5]\nk = 3\np maximum(arr, k)", "    arr.sort[-k..-1]\nend", " \
    \ return arr.max(k) if arr.length == k\n  left = 0\n  right = k - 1\n  while right\
    \ < arr.length - 1\n    left = arr[left..right].each_with_index.min[1] + 1\n \
    \   right = left + k - 1\n  end\n  arr[left..right]\nend", "    # Sort by abs\
    \ value, keeping track of each number's sign\n    arr.sort! { |a, b| a.abs <=>\
    \ b.abs }.map { |n| n < 0 ? n : -n }\n    # Get and reverse the k numbers from\
    \ the end of the array\n    arr[-k..-1].reverse.map { |n| n < 0 ? n : -n }\nend",
  "  # brute force method, O(n^2), O(1) space\n  output = []\n  k.times do |i|\n \
    \   max = arr.max\n    output << max\n    arr.delete(max)\n  end\n  output\nend",
  "  return [] if arr.empty? || k <= 0\n  res = Array.new(k, -Float::INFINITY)\n \
    \ arr.each do |num|\n    (0...k).each do |i|\n      if num > res[i]\n        res[i]\
    \ = num\n        break\n      end\n    end\n  end\n  res\nend", "    len = arr.length\n\
    \    return arr if len <= k\n    # in-place quicksort, time complexity of O(n^2)\n\
    \    i = 0\n    while i < len do\n        swap = i\n        j = i + 1\n      \
    \  while j < len do\n            if arr[j] > arr[swap]\n                swap =\
    \ j\n            end\n            j += 1\n        end\n        arr[i], arr[swap]\
    \ = arr[swap], arr[i]\n        i += 1\n    end\n    arr[0...k]\nend", "  arr.max(k)\n\
    end", "  minheap = []\n  arr.each do |ele|\n    next if ele < 0\n    if minheap.size\
    \ < k\n      minheap << ele\n    else\n      if ele > minheap[0]\n        minheap[0]\
    \ = ele\n        minheapify(minheap, 0)\n      end\n    end\n  end\n  minheap\n\
    end", "  [arr.sort.reverse[0...k], arr.sort[0...k]].max\nend", "    arr.sort.reverse[0..k-1]\n\
    end", "    # Find the k largest numbers of array by using selection sort\n   \
    \ # Time Complexity: O(k * n)\n    # Space Complexity: O(1)\n    i = 0\n    while\
    \ i < k\n        min_index = i\n        j = i + 1\n        while j < arr.length\n\
    \            min_index = j if arr[j] > arr[min_index]\n            j += 1\n  \
    \      end\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n        i\
    \ += 1\n    end\n    return arr[0, k]\nend", "  sorted = false\n  while !sorted\n\
    \    sorted = true\n    (arr.length - 1).times do |i|\n      if arr[i] < arr[i\
    \ + 1]\n        arr[i], arr[i + 1] = arr[i + 1], arr[i]\n        sorted = false\n\
    \      end\n    end\n  end\n  return arr[0...k]\nend", "    results = []\n   \
    \ (arr.length - k).times do\n        results << arr.delete(arr.min)\n    end\n\
    \    results + arr\nend", "  ans = []\n  arr.each { |num| heap_push(ans, num,\
    \ k) }\n  ans\nend", "    @arr = arr\n    @k = k\n    size = @arr.size\n    if\
    \ (size == 0 || @k <= 0)\n        return []\n    end\n    if (size <= @k)\n  \
    \      return @arr.sort.reverse\n    end\n    max = @arr[0]\n    min = @arr[0]\n\
    \    @arr.each do |num|\n        if num > max\n            max = num\n       \
    \ end\n        if num < min\n            min = num\n        end\n    end\n   \
    \ if @k == 1\n        return [max]\n    end\n    if (@k == 2)\n        if (max\
    \ == min)\n            return [max, min]\n        end\n        return [max, min]\n\
    \    end\n    bucket_size = (max - min) / (@k - 1)\n    buckets = Array.new(@k,\
    \ 0)\n    @arr.each do |num|\n        bucket_index = bucket(num, bucket_size,\
    \ min)\n        buckets[bucket_index] += 1\n    end\n    result = Array.new(@k,\
    \ 0)\n    index = @k - 1\n    buckets.each_with_index do |value, i|\n        if\
    \ value > 0\n            value.times do\n                result[index] = min +\
    \ i * bucket_size\n                index -= 1\n            end\n        end\n\
    \    end\n    return result\nend", "  arr.sort.reverse.take(k)\nend", "    # Partition\
    \ the array around the pivot in place.\n    # @param {Integer[]} arr\n    # @param\
    \ {Integer} l\n    # @param {Integer} r\n    # @return {Integer}\n    def partition(arr,\
    \ l, r)\n        pi = l\n        pivot = arr[r]\n        i = l\n        while\
    \ i < r\n            if arr[i] >= pivot\n                arr[i], arr[pi] = arr[pi],\
    \ arr[i]\n                pi += 1\n            end\n            i += 1\n     \
    \   end\n        arr[pi], arr[r] = arr[r], arr[pi]\n        pi\n    end\n    len\
    \ = arr.length\n    l = 0\n    r = len - 1\n    while true\n        pi = partition(arr,\
    \ l, r)\n        if pi == k - 1\n            return arr[0...k]\n        elsif\
    \ pi > k - 1\n            r = pi - 1\n        else\n            l = pi + 1\n \
    \       end\n    end\nend", "  arr.sort[-k..-1]\nend", "    min_heap = MinHeap.new\n\
    \    arr.each do |num|\n        min_heap.add(num)\n        min_heap.remove_min\
    \ if min_heap.size > k\n    end\n    min_heap.to_a.reverse\nend", "  return arr\
    \ if arr.size == k\n  arr.sort.reverse[0..k-1]\nend", "  arr.sort[-k..-1]\nend",
  "  sorted = arr.sort\n  sorted[-k, k]\nend", "    return arr.sort.slice(-k, k)\n\
    end", "  # sorted list\n  arr.sort.drop(arr.length - k)\nend", "    heap = MinHeap.new\n\
    \    res = []\n    arr.each do |num|\n        heap.insert(num)\n        res.push(heap.extract)\
    \ if res.size < k\n    end\n    res\nend", "  n = arr.size\n  i = 0\n  while i\
    \ < k\n    j = i + 1\n    while j < n\n      if arr[i] < arr[j]\n        arr[i],\
    \ arr[j] = arr[j], arr[i]\n      end\n      j += 1\n    end\n    i += 1\n  end\n\
    \  arr[0..k-1]\nend", "  arr.sort.reverse.take(k)\nend", "  n = arr.size\n  ans\
    \ = []\n  arr.each do |x|\n    while ans.size > 0 && n - ans.size >= k && ans.last\
    \ < x\n      ans.pop\n    end\n    ans << x if ans.size < k\n  end\n  ans\nend",
  "\t# loop arr, push arr[i] to heap, if heap.size > k, pop.last\n\t# return heap\n\
    \treturn arr if arr.size <= k\n\theap = [0] * k\n\theap_size = 0\n\tfor i in 0...arr.size\n\
    \t\tif heap_size < k\n\t\t\theap[heap_size] = arr[i]\n\t\t\tbubble_up(heap, heap_size)\n\
    \t\t\theap_size += 1\n\t\telsif arr[i] > heap[0]\n\t\t\theap[0] = arr[i]\n\t\t\
    \tbubble_down(heap, heap_size)\n\t\tend\n\tend\n\theap\nend", "  arr.sort[-k..-1]\n\
    end", "  arr.sort[-k..-1]\nend", "  # Decending order:\n  arr.sort.reverse.take(k)\n\
    end\np maximum([-3, -4, 5], 3)", "    return arr if arr.size == k\n    # arr =\
    \ arr.sort!\n    # return arr[arr.size - k..arr.size]\n    return arr.sort![arr.size\
    \ - k..arr.size]\nend", "    return [] if arr.length == 0\n    return arr if arr.length\
    \ <= k\n    heap = []\n    result = []\n    i = 0\n    while i < k\n        heap\
    \ << arr[i]\n        heapify_up(heap, i)\n        i += 1\n    end\n    while i\
    \ < arr.length\n        if arr[i] > heap[0]\n            heap[0] = arr[i]\n  \
    \          heapify_down(heap, 0)\n        end\n        i += 1\n    end\n    heap\n\
    end", "    # Time Complexity = O(N + KLogN)\n    # Space Complexity = O(K)\n \
    \   # Frequent use of the delete_at method is not a good idea.\n    # Can use\
    \ binary search to find the index to delete.\n    # Thought that was the problem\
    \ but it was a constraint.\n    # Test cases were too small to care.\n    return\
    \ arr.sort.reverse[0..k-1]\nend", "  counter = {}\n  hash = {}\n  arr.each do\
    \ |i|\n    if counter[i]\n      counter[i] += 1\n    else\n      counter[i] =\
    \ 1\n    end\n  end\n  p counter\n  counter.sort_by { |k, v| -v }.each do |n|\n\
    \    if hash.size < k\n      hash[n[0]] = n[1]\n    end\n  end\n  p hash\n  hash.keys.sort\n\
    end\np maximum([-3, -4, 5], 3)\np maximum([4, -4, 4], 2)\np maximum([-3, 2, 1,\
    \ 2, -1, -2, 1], 1)", "  arr.sort[-k..-1]\nend", "  return arr if arr.size <=\
    \ k\n  heap = []\n  heap_size = 0\n  arr.each do |num|\n    if heap_size == k\n\
    \      heap.shift if num > heap[0]\n      heap << num\n    else\n      heap <<\
    \ num\n      heap_size += 1\n      i = heap_size - 1\n      while i > 0\n    \
    \    parent = (i - 1) / 2\n        if heap[parent] < heap[i]\n          heap[parent],\
    \ heap[i] = heap[i], heap[parent]\n          i = parent\n        else\n      \
    \    break\n        end\n      end\n    end\n  end\n  heap\nend", "    return\
    \ arr if arr.size <= k\n    return arr.sort if k == 1\n    ans = []\n    n = arr.size\n\
    \    f, l = 0, n - 1\n    i = 0\n    while f <= l\n        if (f == l)\n     \
    \       ans[i] = arr[f]\n            break\n        end\n        if (f == l -\
    \ 1)\n            if arr[f] > arr[l]\n                ans[i] = arr[f]\n      \
    \          f += 1\n            else\n                ans[i] = arr[l]\n       \
    \         l -= 1\n            end\n        else\n            mid = (f + l) / 2\n\
    \            if (arr[mid] >= arr[f] && arr[mid] >= arr[l])\n                ans[i]\
    \ = arr[mid]\n                f = mid + 1\n            elsif (arr[mid] <= arr[f]\
    \ && arr[mid] <= arr[l])\n                ans[i] = arr[mid]\n                l\
    \ = mid - 1\n            else\n                ans[i] = arr[f]\n             \
    \   f += 1\n            end\n        end\n        i += 1\n        if i == k\n\
    \            break\n        end\n    end\n    ans\nend", "    # Your code here\n\
    end", "  return arr if arr.length == k\n  heap = Heap.new(arr)\n  res = []\n \
    \ k.times do \n    res << heap.delete_max\n  end\n  res\nend", end, end, "  h\
    \ = {}\n  for i in 0...arr.length\n    h[arr[i]] = i\n  end\n  arr = arr.sort.reverse\n\
    \  arr[0...k]\nend\na = [-3, -4, 5]\nb = [4, -4, 4]\nc = [-3, 2, 1, 2, -1, -2,\
    \ 1]\nputs maximum(a, 3)\nputs maximum(b, 2)\nputs maximum(c, 1)", "  return arr\
    \ if arr.size <= k\n  output = arr[0...k]\n  output.sort!\n  arr[k..-1].each do\
    \ |num|\n    i = 0\n    while i < k and output[i] < num\n      i += 1\n    end\n\
    \    if i < k\n      output.insert(i, num)\n      output.pop\n    end\n  end\n\
    \  output\nend\narr = [-3, -4, 5]\nk = 3\np maximum(arr, k)\narr = [4, -4, 4]\n\
    k = 2\np maximum(arr, k)\narr = [-3, 2, 1, 2, -1, -2, 1]\nk = 1\np maximum(arr,\
    \ k)", "  return [] if arr.empty? or k.zero?\n  max, count = [], 0\n  max << arr.shift\
    \ until arr.empty? or count == k\n  max.each_with_index do |num, idx|\n    idx.upto(max.size\
    \ - 1) do |i|\n      if num < max[i]\n        max[idx], max[i] = max[i], num\n\
    \        count += 1\n        break\n      end\n    end\n  end\n  arr.each do |num|\n\
    \    max.each_with_index do |val, idx|\n      if num > val\n        max[idx] =\
    \ num\n        count += 1\n        break\n      end\n    end\n  end\n  max.sort[0...k]\n\
    end", "    arr.sort!\n    return arr[arr.length - k..-1]\nend\nputs maximum([-3,\
    \ -4, 5], 3)", "    arr.sort.last(k)\nend", "  a = arr.sort.last(k)\n  a\nend",
  "  return nil if k < 1 || k > arr.size\n  arr.sort.reverse[0, k]\nend", "  arr.sort.reverse.first(k)\n\
    end", "  [-arr.first(k).sort, arr.last(k).sort].max\nend", "  return [] if arr.empty?\n\
    \  return arr if k >= arr.size\n  return [arr.max] if k == 1\n  first_mid = arr.size\
    \ / 2\n  second_mid = arr.size - first_mid\n  left_arr = maximum(arr[0...first_mid],\
    \ k)\n  right_arr = maximum(arr[first_mid..-1], k)\n  sort_merge(left_arr, right_arr,\
    \ k)\nend", "    return arr.sort if k == arr.length\n    soln = []\n    k.times\
    \ do\n        soln << arr.max\n        arr.delete(arr.max)\n    end\n    soln\n\
    end", "  n = arr.size\n  raise 'Input cannot be nil' if n == 0\n  raise 'K must\
    \ be valid' if k < 1 || k > n\n  arr.sort!\n  return arr[-k..-1]\nend", "  min,\
    \ max = -1_000, 1_000\n  arr.each do |n|\n    min = n if n < min\n    max = n\
    \ if n > max\n  end\n  hash = [max] * (max - min + 1)\n  arr.each do |n|\n   \
    \ hash[n - min] = n\n  end\n  hash.select { |n| n if n != max }.first(k)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
