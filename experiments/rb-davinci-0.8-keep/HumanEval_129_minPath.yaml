name: HumanEval_129_minPath
language: rb
prompt: "# Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n# each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n# inclusive appears exactly once on the cells of the grid.\n# You have\
  \ to find the minimum path of length k in the grid. You can start\n# from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n# in other words,\
  \ you can go to cells which share an edge with you current\n# cell.\n# Please note\
  \ that a path of length k means visiting exactly k cells (not\n# necessarily distinct).\n\
  # You CANNOT go off the grid.\n# A path A (of length k) is considered less than\
  \ a path B (of length k) if\n# after making the ordered lists of the values on the\
  \ cells that A and B go\n# through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n# than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n# such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n# lst_A[j]\
  \ = lst_B[j].\n# It is guaranteed that the answer is unique.\n# Return an ordered\
  \ list of the values on the cells that the minimum path go through.\n# Examples:\n\
  # Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n# Output: [1, 2, 1]\n# Input:\
  \ grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n# Output: [1]\ndef minPath(grid, k)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_minPath\n\
  \    candidate = method(:minPath)\n    assert_equal([1, 2, 1], candidate.call([[1,\
  \ 2, 3], [4, 5, 6], [7, 8, 9]], 3))\n    assert_equal([1], candidate.call([[5, 9,\
  \ 3], [4, 1, 6], [7, 8, 2]], 1))\n    assert_equal([1, 2, 1, 2], candidate.call([[1,\
  \ 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4))\n    assert_equal([1,\
  \ 10, 1, 10, 1, 10, 1], candidate.call([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11,\
  \ 15], [8, 14, 9, 2]], 7))\n    assert_equal([1, 7, 1, 7, 1], candidate.call([[8,\
  \ 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3, 10, 11, 16]], 5))\n    assert_equal([1,\
  \ 6, 1, 6, 1, 6, 1, 6, 1], candidate.call([[11, 8, 7, 2], [5, 16, 14, 4], [9, 3,\
  \ 15, 6], [12, 13, 10, 1]], 9))\n    assert_equal([1, 6, 1, 6, 1, 6, 1, 6, 1, 6,\
  \ 1, 6], candidate.call([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11, 8,\
  \ 7, 2]], 12))\n    assert_equal([1, 3, 1, 3, 1, 3, 1, 3], candidate.call([[2, 7,\
  \ 4], [3, 1, 5], [6, 8, 9]], 8))\n    assert_equal([1, 5, 1, 5, 1, 5, 1, 5], candidate.call([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8))\n    assert_equal([1, 2, 1, 2, 1, 2, 1, 2, 1,\
  \ 2], candidate.call([[1, 2], [3, 4]], 10))\n    assert_equal([1, 3, 1, 3, 1, 3,\
  \ 1, 3, 1, 3], candidate.call([[1, 3], [3, 2]], 10))\n  end\nend\n"
completions: ["\nend", "    if not grid or grid.empty? or grid[0].empty?\n       \
    \ return []\n    end\n    if k == 0\n        return []\n    end\n    n = grid.length\n\
    \    m = grid[0].length\n    queue = []\n    queue << [0, 0, k, 0, [grid[0][0]]]\n\
    \    min = []\n    visited = {}\n    while not queue.empty?\n        i, j, k,\
    \ sum, arr = queue.shift\n        if visited[i.to_s + ',' + j.to_s + ',' + k.to_s]\n\
    \            next\n        end\n        visited[i.to_s + ',' + j.to_s + ',' +\
    \ k.to_s] = true\n        if i == n - 1 and j == m - 1\n            if min.empty?\
    \ or sum < min[0]\n                min = arr\n            elsif sum == min[0]\n\
    \                for i in 0...min.length\n                    if arr[i] < min[i]\n\
    \                        min = arr\n                        break\n          \
    \          elsif arr[i] > min[i]\n                        break\n            \
    \        end\n                end\n            end\n            next\n       \
    \ end\n        if i + 1 < n and j < m and k - 1 >= 0\n            queue << [i\
    \ + 1, j, k - 1, sum + grid[i + 1][j], arr + [grid[i + 1][j]]]\n        end\n\
    \        if i < n and j + 1 < m and k - 1 >= 0\n            queue << [i, j + 1,\
    \ k - 1, sum + grid[i][j + 1], arr + [grid[i][j + 1]]]\n        end\n    end\n\
    \    return min\nend", "  min_path = [grid[0][0]]\n  queue = [[0, 0, 1]]\n  visited\
    \ = Array.new(grid.size) { Array.new(grid[0].size, false) }\n  visited[0][0] =\
    \ true\n  while !queue.empty?\n    current = queue.shift\n    if current[2] ==\
    \ k\n      if current[0] < min_path[0]\n        min_path = current[0]\n      elsif\
    \ current[0] == min_path[0]\n        min_path = current[0] if current[1] < min_path[1]\n\
    \      end\n    else\n      k = current[2] + 1\n      queue.push([grid[current[0]][current[1]\
    \ + 1], current[1] + 1, k]) if current[1] + 1 < grid[0].size && !visited[current[0]][current[1]\
    \ + 1]\n      queue.push([grid[current[0] + 1][current[1]], current[1], k]) if\
    \ current[0] + 1 < grid.size && !visited[current[0] + 1][current[1]]\n      queue.push([grid[current[0]][current[1]\
    \ - 1], current[1] - 1, k]) if current[1] - 1 >= 0 && !visited[current[0]][current[1]\
    \ - 1]\n      queue.push([grid[current[0] - 1][current[1]], current[1], k]) if\
    \ current[0] - 1 >= 0 && !visited[current[0] - 1][current[1]]\n    end\n  end\n\
    \  min_path\nend", "  return nil if grid.nil?\n  return nil if grid.length ==\
    \ 0\n  return nil if grid[0].length == 0\n  return nil if k <= 0\n  return nil\
    \ if k > grid.length * grid[0].length\n  matrix = build(grid)\n  puts \"matrix\
    \ = #{matrix}\"\n  puts \"matrix = #{matrix}\"\n  matrix.each { |r| puts r.inspect\
    \ }\n  puts \"matrix = #{matrix}\"\n  n = grid.length\n  i = 0\n  j = 0\n  res\
    \ = [grid[i][j]]\n  k.times do\n    puts \"i = #{i}, j = #{j}\"\n    r = i + 1\n\
    \    c = j + 1\n    if c < n && matrix[r][c] > matrix[i][j]\n      res << grid[i][j\
    \ + 1]\n      j += 1\n    elsif r < n && matrix[r][c] > matrix[i][j]\n      res\
    \ << grid[i + 1][j]\n      i += 1\n    elsif c < n && matrix[r][c] < matrix[i][j]\n\
    \      res << grid[i][j + 1]\n      j += 1\n    elsif r < n && matrix[r][c] <\
    \ matrix[i][j]\n      res << grid[i + 1][j]\n      i += 1\n    else\n      puts\
    \ \"ERROR: no direction to go\"\n      break\n    end\n  end\n  res\nend", " \
    \ # Write your code here\nend", "    n = grid.length\n    m = grid[0].length\n\
    \    result = nil\n    (0...n).each do |i|\n        (0...m).each do |j|\n    \
    \        result = [grid[i][j]] + dfs(grid, i, j, k - 1) if result.nil? || compare(result,\
    \ [grid[i][j]] + dfs(grid, i, j, k - 1)) < 0\n        end\n    end\n    result\n\
    end", "\tdp = grid.map { |row| row.map { |num| [[num]] } }\n\t(0...grid.size).each\
    \ do |i|\n\t\t(0...grid.size).each do |j|\n\t\t\tnext if i == 0 && j == 0\n\t\t\
    \ttop = dp[i - 1][j] unless i == 0\n\t\t\tleft = dp[i][j - 1] unless j == 0\n\t\
    \t\tnext if top.nil? && left.nil?\n\t\t\tif top.nil?\n\t\t\t\tdp[i][j] = left.map\
    \ { |l| l.dup }\n\t\t\telsif left.nil?\n\t\t\t\tdp[i][j] = top.map { |t| t.dup\
    \ }\n\t\t\telse\n\t\t\t\tdp[i][j] = top.map { |t| t.dup } + left.map { |l| l.dup\
    \ }\n\t\t\tend\n\t\t\tdp[i][j].select! { |path| path.size <= k }\n\t\t\tdp[i][j].sort!\
    \ { |p1, p2| pathComparator(p1, p2) }\n\t\t\tdp[i][j].reject! { |path| path.size\
    \ > k }\n\t\t\tdp[i][j].uniq!\n\t\t\tdp[i][j].each do |path|\n\t\t\t\tpath <<\
    \ grid[i][j]\n\t\t\tend\n\t\tend\n\tend\n\tdp[-1][-1][0]\nend", "\nend", "\nend",
  "    @min_path, @min_sum = nil, k + 1\n    @n = grid.size\n    @m = grid[0].size\n\
    \    seen = Array.new(@n) { Array.new(@m, false) }\n    def dfs(grid, seen, i,\
    \ j, sum, path)\n        return if i < 0 || i >= @n || j < 0 || j >= @m || seen[i][j]\
    \ || sum + grid[i][j] > @min_sum\n        seen[i][j] = true\n        sum += grid[i][j]\n\
    \        path.push(grid[i][j])\n        if sum < @min_sum\n            @min_path\
    \ = path.dup\n            @min_sum = sum\n        elsif sum == @min_sum\n    \
    \        @min_path = @min_path <=> path < 0 ? @min_path : path\n        end\n\
    \        dfs(grid, seen, i - 1, j, sum, path)\n        dfs(grid, seen, i + 1,\
    \ j, sum, path)\n        dfs(grid, seen, i, j - 1, sum, path)\n        dfs(grid,\
    \ seen, i, j + 1, sum, path)\n        seen[i][j] = false\n        path.pop\n \
    \   end\n    for i in 0...@n\n        for j in 0...@m\n            dfs(grid, seen,\
    \ i, j, 0, [])\n        end\n    end\n    @min_path\nend", "  n = grid.size\n\
    \  m = grid[0].size\n  if k > n * m\n    return []\n  end\n  if k == n * m\n \
    \   return grid.flatten.sort\n  end\n  # initialize a (n * m) * (n * m) graph\n\
    \  graph = Array.new(n * m) { Array.new(n * m, 0) }\n  for i in 0...n\n    for\
    \ j in 0...m\n      id = i * m + j\n      # find the neighbors\n      for x in\
    \ [i - 1, i, i + 1]\n        for y in [j - 1, j, j + 1]\n          if x >= 0 &&\
    \ x < n && y >= 0 && y < m && (x != i || y != j)\n            neighbor = x * m\
    \ + y\n            graph[id][neighbor] = grid[x][y]\n          end\n        end\n\
    \      end\n    end\n  end\n  # build a new graph that is a product of the previous\
    \ graph k times\n  power_graph = Array.new(n * m) { Array.new(n * m, 0) }\n  for\
    \ i in 0...n * m\n    for j in 0...n * m\n      power_graph[i][j] = graph[i][j]\n\
    \    end\n  end\n  for i in 2...k\n    for j in 0...n * m\n      for h in 0...n\
    \ * m\n        power_graph[j][h] = Integer::MAX\n        for t in 0...n * m\n\
    \          power_graph[j][h] = [power_graph[j][h], power_graph[j][t] + graph[t][h]].min\n\
    \        end\n      end\n    end\n  end\n  # for each starting node s, find the\
    \ min path and the min path's end node\n  min_path = nil\n  min_end = nil\n  for\
    \ s in 0...n * m\n    min_end = s\n    min_path = power_graph[s][s]\n    for e\
    \ in 0...n * m\n      if s != e && power_graph[s][e] < min_path\n        min_path\
    \ = power", "  return [] if k == 0\n  min = []\n  min_total = nil\n  [0, 1, -1].repeated_permutation(k).each\
    \ do |moves|\n    cur = [0, 0]\n    val = 0\n    moves.each do |m|\n      cur[0]\
    \ += m\n      cur[1] += 1\n      return [] if cur[0] < 0 || cur[0] >= grid.size\
    \ || cur[1] < 0 || cur[1] >= grid.size\n      val += grid[cur[0]][cur[1]]\n  \
    \  end\n    if min_total.nil? || val < min_total\n      min_total = val\n    \
    \  min = [grid[0][0]] + moves.map { |m| grid[m][1] }\n    end\n  end\n  min\n\
    end", "    if !grid || grid.length == 0 || k <= 0\n        return []\n    end\n\
    \    $n = grid.length\n    $res = grid[0][0]\n    $visited = Hash.new\n    $visited[0]\
    \ = {}\n    $visited[0][0] = true\n    dfs(grid, 0, 0, [grid[0][0]], k)\n    return\
    \ $res\nend", "    q = [[0, 0, 0, []]] # [i, j, path_length, visited]\n    visited\
    \ = [[0] * grid.size] * grid.size\n    res = [[0] * grid.size] * grid.size\n \
    \   while not q.empty?\n        i, j, len, v = q.shift\n        next if visited[i][j]\n\
    \        visited[i][j] = true\n        if len == k\n            res[i][j] = v\
    \ + [grid[i][j]]\n            return res[i][j]\n        end\n        res[i][j]\
    \ = v + [grid[i][j]]\n        q << [i - 1, j, len + 1, res[i][j]] if i > 0\n \
    \       q << [i + 1, j, len + 1, res[i][j]] if i < grid.size - 1\n        q <<\
    \ [i, j - 1, len + 1, res[i][j]] if j > 0\n        q << [i, j + 1, len + 1, res[i][j]]\
    \ if j < grid.size - 1\n    end\n    nil\nend", "\nend", "    if grid.length ==\
    \ 1 && k == 1\n        return grid\n    end\n    # Note: Initialize a matrix of\
    \ size (k+1) * (n) * (n)\n    m = Array.new(k+1) { Array.new(grid.length) { Array.new(grid.length)\
    \ }}\n    # Note: Initialize all entries to large negative number, which signifies\
    \ that the path has not yet been found\n    m.each do |x|\n        x.each do |y|\n\
    \            y.each_index do |i|\n                y[i] = -10000000\n         \
    \   end\n        end\n    end\n    # Note: Initialize the first layer of the matrix\
    \ with the values of the first row and column\n    m[0][0][0] = grid[0][0]\n \
    \   (1...grid.length).each do |i|\n        m[0][0][i] = m[0][0][i-1] + grid[0][i]\n\
    \        m[0][i][0] = m[0][i-1][0] + grid[i][0]\n    end\n    # Note: We now iterate\
    \ through layers 1 to k and fill the matrix\n    (1..k).each do |l|\n        (0...grid.length).each\
    \ do |i|\n            (0...grid.length).each do |j|\n                # Note: The\
    \ base case is that we can directly get from the diagonal element\n          \
    \      m[l][i][j] = [m[l][i][j], m[l-1][i-1][j-1] + grid[i][j]].max\n        \
    \        # Note: We now check all possible paths to get to the current element\n\
    \                (0..i-1).each do |ii|\n                    m[l][i][j] = [m[l][i][j],\
    \ m[l-1][ii][j] + grid[i][j]].max\n                end\n                (0..j-1).each\
    \ do |jj|\n                    m[l][i][j] = [m[l][i][j], m[l-1][i][jj] + grid[i][j]].max\n\
    \                end\n            end\n        end", "    if grid.nil? || grid.empty?\
    \ || grid[0].nil? || grid[0].empty? || k <= 0\n        return []\n    end\n  \
    \  # f[i][j] means the minimum path from (0, 0) to (i, j) with lenght k\n    f\
    \ = Array.new(grid.size) { Array.new(grid[0].size, []) }\n    visited = Array.new(grid.size)\
    \ { Array.new(grid[0].size, false) }\n    visited[0][0] = true\n    f[0][0] =\
    \ [grid[0][0]]\n    min = grid[0][0]\n    res = [grid[0][0]]\n    queue = Queue.new\n\
    \    queue.push([0, 0])\n    while !queue.empty?\n        row, col = queue.pop\n\
    \        [[row + 1, col], [row - 1, col], [row, col + 1], [row, col - 1]].each\
    \ do |i, j|\n            if i >= 0 && i < grid.size && j >= 0 && j < grid[0].size\
    \ && !visited[i][j]\n                path = f[row][col] + [grid[i][j]]\n     \
    \           if path.size == k && path.sum < min\n                    min = path.sum\n\
    \                    res = path\n                end\n                visited[i][j]\
    \ = true\n                f[i][j] = path\n                queue.push([i, j])\n\
    \            end\n        end\n    end\n    res\nend", "  n = grid.size\n  $path\
    \ = []\n  $minLen = n * n\n  def visit(grid, row, col, direction, path, count)\n\
    \    return if path.size == $minLen\n    if count == 0\n      $path = path.dup\
    \ if path.size < $minLen\n      return\n    end\n    visit(grid, row - 1, col,\
    \ 1, path + [grid[row - 1][col]], count - 1) if row > 0\n    visit(grid, row +\
    \ 1, col, 2, path + [grid[row + 1][col]], count - 1) if row < grid.size - 1\n\
    \    visit(grid, row, col - 1, 3, path + [grid[row][col - 1]], count - 1) if col\
    \ > 0\n    visit(grid, row, col + 1, 4, path + [grid[row][col + 1]], count - 1)\
    \ if col < grid.size - 1\n  end\n  n.times do |i|\n    n.times do |j|\n      visit(grid,\
    \ i, j, 0, [grid[i][j]], k - 1)\n    end\n  end\n  $path\nend\ngrid = [ [1,2,3],\
    \ [4,5,6], [7,8,9] ]\nk = 3\np minPath(grid, k)", "\nend", "  n = grid.size\n\
    \  size = n*n\n  min_path = []\n  def dfs(grid, i, j, k, curr_path, min_path)\n\
    \    n = grid.size\n    if k == 0\n      if curr_path.size == k\n        min_path\
    \ = curr_path.dup\n      end\n      return\n    end\n    size = n*n\n    if min_path.size\
    \ != 0 && curr_path.size + size/k >= min_path.size\n      return\n    end\n  \
    \  dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    dirs.each do |dir|\n      new_i\
    \ = i + dir[0]\n      new_j = j + dir[1]\n      if new_i >= 0 && new_i < n &&\
    \ new_j >= 0 && new_j < n\n        curr_path << grid[new_i][new_j]\n        dfs(grid,\
    \ new_i, new_j, k-1, curr_path, min_path)\n        curr_path.pop\n      end\n\
    \    end\n  end\n  n.times do |i|\n    n.times do |j|\n      dfs(grid, i, j, k,\
    \ [grid[i][j]], min_path)\n    end\n  end\n  min_path\nend", "  rows = grid.length\n\
    \  cols = grid[0].length\n  queue = [grid[0][0]]\n  path = [grid[0][0]]\n  cell\
    \ = {path: 0, row: 0, col: 0}\n  for i in 1..k-1\n    for j in 0..path.length-1\n\
    \      for m in cell[:row]-1..cell[:row]+1\n        for n in cell[:col]-1..cell[:col]+1\n\
    \          if m >= 0 && m < rows && n >= 0 && n < cols && m != cell[:row] && n\
    \ != cell[:col]\n            new_path = path.clone\n            new_path.push(grid[m][n])\n\
    \            queue.push({path: new_path, row: m, col: n})\n          end\n   \
    \     end\n      end\n    end\n    cell = queue.shift\n    path = cell[:path]\n\
    \  end\n  path\nend\nputs minPath([ [1,2,3], [4,5,6], [7,8,9]], 3)\nputs minPath([\
    \ [5,9,3], [4,1,6], [7,8,2]], 1)", "  n = grid.size\n  return [] if n == 0 ||\
    \ k < 1\n  map = {}\n  for i in 0...n\n    for j in 0...n\n      if map.has_key?(grid[i][j])\n\
    \        map[grid[i][j]] << [i, j]\n      else\n        map[grid[i][j]] = [[i,\
    \ j]]\n      end\n    end\n  end\n  res = nil\n  cur = []\n  visited = {}\n  (1..n*n).each\
    \ do |num|\n    if map.has_key?(num)\n      for pos in map[num]\n        # p [num,\
    \ pos]\n        visited[pos] = true\n        cur << num\n        dfs(grid, map,\
    \ n, k, num, visited, pos, cur, res)\n        cur.pop\n        visited.delete(pos)\n\
    \      end\n    end\n  end\n  res\nend", "  # Iterate through each square in the\
    \ grid starting from each square in the\n  # grid and make a binary tree. If a\
    \ square is a neighbor to a square, create\n  # a pointer to the neighbor. The\
    \ value of each square is the sum of all\n  # values in the path. The node with\
    \ the minimum value of sum is the final\n  # node of the path.\n  # We calculate\
    \ the value of each square by adding the value of the current\n  # square to the\
    \ value of the previous square.\n  # Use BFS to iterate through all the nodes\
    \ and find the node with the minimum value.\n  # Time complexity is O(n^2 * n^2)\
    \ and space complexity is O(n^2)\n  # Create a node class to hold the square in\
    \ the grid, the value of the path, and the\n  # pointer to the next node.\n  class\
    \ Node\n    attr_accessor :square, :next_node, :path_value", "  n = grid.size\n\
    \  # direction: down, right, up, left\n  diffs = [[1, 0], [0, 1], [-1, 0], [0,\
    \ -1]]\n  # add a border as visited cells\n  visited = Array.new(n + 2) { Array.new(n\
    \ + 2, false) }\n  min_path = Array.new(k)\n  min_sum = n * n + 1\n  queue = Queue.new\n\
    \  cur_sum = grid[0][0]\n  # path: [[row, col], value, path length]\n  queue.push([[0,\
    \ 0], grid[0][0], 1])\n  visited[0][0] = true\n  # BFS\n  while !queue.empty?\n\
    \    cell, sum, length = queue.pop\n    if length == k && sum < min_sum\n    \
    \  min_sum = sum\n      min_path = Array.new(k)\n      min_path[0] = grid[cell[0]][cell[1]]\n\
    \    end\n    if length == k && sum == min_sum\n      min_path[0] = grid[cell[0]][cell[1]]\
    \ if grid[cell[0]][cell[1]] < min_path[0]\n    end\n    diffs.each do |diff|\n\
    \      new_cell = [cell[0] + diff[0], cell[1] + diff[1]]\n      if (0..n - 1).include?(new_cell[0])\
    \ && (0..n - 1).include?(new_cell[1]) && !visited[new_cell[0]][new_cell[1]]\n\
    \        visited[new_cell[0]][new_cell[1]] = true\n        queue.push([new_cell,\
    \ sum + grid[new_cell[0]][new_cell[1]], length + 1])\n      end\n    end\n  end\n\
    \  min_path\nend", "  res = []\n  n = grid.size\n  return res if n == 0\n  m =\
    \ grid[0].size\n  return res if m == 0\n  best = [[0, grid[0][0]]]\n  best <<\
    \ [1, grid[0][1]] if m > 1\n  best << [1, grid[1][0]] if n > 1\n  best << [2,\
    \ grid[1][1]] if n > 1 && m > 1\n  best.sort!\n  (2...[n, m].min).each do |l|\n\
    \    cur = []\n    (l...n).each do |i|\n      (l...m).each do |j|\n        cur\
    \ << [[i, j], [i - 1, j], [i, j - 1]].map do |r, c|\n          [best[r * m + c][0]\
    \ + 1, grid[i][j]]\n        end.min\n      end\n    end\n    cur.sort!\n    best\
    \ = cur\n  end\n  n.times do |i|\n    m.times do |j|\n      res = [i, j] if best[i\
    \ * m + j][0] == k\n    end\n  end\n  res = [0, 0] if best[0][0] == k\n  i, j\
    \ = res\n  res = []\n  res << grid[i][j]\n  (k - 1).times do\n    best_row = i\
    \ - 1 < 0 ? nil : [best[(i - 1) * m + j][0], i - 1]\n    best_col = j - 1 < 0\
    \ ? nil : [best[i * m + j - 1][0], j - 1]\n    best_row = best_col if best_row.nil?\
    \ || best_col && best_col[0] < best_row[0]\n    best_row = best_col if best_row\
    \ && best_col && best_col[0] == best_row[0] && best_col[1] < best_row[1]\n   \
    \ best_row = best_col if best_row && best_col && best_col[0] == best_row[0] &&\
    \ best_col[1]", "  n = grid.size\n  min_path = []\n  min_sum = n * n + 1\n  min_paths\
    \ = {}\n  helper(grid, 0, 0, [], 0, min_paths)\n  min_paths.each do |path|\n \
    \   path = path[0]\n    sum = path.reduce(:+)\n    if sum == k\n      puts \"\
    path = #{path}\"\n      if path < min_path\n        min_path = path\n      end\n\
    \    end\n  end\n  min_path\nend", "  # something\nend", "  paths = []\n  (0...grid.size).each\
    \ do |i|\n    (0...grid.size).each do |j|\n      paths << [grid[i][j]]\n     \
    \ queue = Queue.new\n      queue << [i, j]\n      while !queue.empty?\n      \
    \  coords = queue.pop\n        x, y = coords\n        (x-1..x+1).each do |a|\n\
    \          (y-1..y+1).each do |b|\n            if is_in_grid(grid, a, b) && !paths.last.include?(grid[a][b])\n\
    \              if paths.last.size < k\n                paths.last << grid[a][b]\n\
    \                queue << [a, b]\n              else\n                paths <<\
    \ [grid[a][b]]\n              end\n            end\n          end\n        end\n\
    \      end\n    end\n  end\n  min = nil\n  min_path = nil\n  paths.each do |path|\n\
    \    if path.size == k\n      if min.nil? || min > path\n        min = path\n\
    \        min_path = path\n      end\n    end\n  end\n  min_path\nend", "  return\
    \ grid[0][0] if k == 1\n  size = grid.size\n  minPath = grid[0][0]\n  visited\
    \ = {}\n  path_cache = {}\n  [(0...size).to_a, (0...size).to_a]\n  minPathHelper(grid,\
    \ visited, path_cache, k, minPath, [0, 0], [])\n  return minPath\nend", "  # use\
    \ DFS to find a path of length k and return the cell values in the path\n  curr_path\
    \ = []\n  rows = grid.length\n  cols = grid[0].length\n  dfs(grid, rows, cols,\
    \ k, curr_path, -1, -1)\n  return curr_path\nend", "    n = grid.length\n    @grid\
    \ = grid\n    @memo = Hash.new\n    minPathHelper(0, 0, k, n)\nend", "  m, n =\
    \ grid.size, grid[0].size\n  cache = {}\n  g = Hash.new { |h, key| h[key] = []\
    \ }\n  (0...m).each do |i|\n    (0...n).each do |j|\n      g[grid[i][j]] << [i,\
    \ j]\n    end\n  end\n  g[grid[0][0]] = [[0, 0]]\n  queue = [[0, 0, grid[0][0],\
    \ 1]]\n  cache[[0, 0, grid[0][0], 1]] = true\n  while !queue.empty?\n    i, j,\
    \ v, kk = queue.shift\n    if kk == k\n      return g[v][0...kk]\n    end\n  \
    \  [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]].each do |x, y|\n      if 0\
    \ <= x && x < m && 0 <= y && y < n && !cache[[x, y, v, kk + 1]]\n        cache[[x,\
    \ y, v, kk + 1]] = true\n        queue << [x, y, v, kk + 1]\n      end\n    end\n\
    \    if kk < k\n      g[v].each do |p|\n        if !cache[[p[0], p[1], v, kk +\
    \ 1]]\n          cache[[p[0], p[1], v, kk + 1]] = true\n          queue << [p[0],\
    \ p[1], v, kk + 1]\n        end\n      end\n    end\n  end\n  []\nend\ngrid =\
    \ [ [1,2,3], [4,5,6], [7,8,9] ]\nk = 3\np minPath(grid, k)\ngrid = [ [5,9,3],\
    \ [4,1,6], [7,8,2] ]\nk = 1\np minPath(grid, k)", "\treturn grid.first if k ==\
    \ 1\n\tsize = grid.size\n\tin_grid = lambda { |i, j| (0...size).include?(i) &&\
    \ (0...size).include?(j) }\n\t# use bfs to find the shortest path of length k\
    \ - 1\n\tdist = Array.new(size) { Array.new(size, nil) }\n\tdist[0][0] = 0\n\t\
    q = Queue.new\n\tq.push([0, 0])\n\twhile !q.empty?\n\t\ti, j = q.pop\n\t\tnext\
    \ if dist[i][j] == k - 1\n\t\t[[i, j - 1], [i, j + 1], [i - 1, j], [i + 1, j]].each\
    \ do |ni, nj|\n\t\t\tnext unless in_grid.call(ni, nj)\n\t\t\tif dist[ni][nj].nil?\n\
    \t\t\t\tdist[ni][nj] = dist[i][j] + 1\n\t\t\t\tq.push([ni, nj])\n\t\t\tend\n\t\
    \tend\n\tend\n\t# find the minimum path using the shortest path found above\n\t\
    @k = k\n\t@n = size\n\t@grid = grid\n\t@dist = dist\n\t@path = []\n\tdfs(0, 0)\n\
    \t@path\nend", "    n = grid.length\n    total = n * n\n    min_path = Array.new(total,\
    \ Array.new(total, 0))\n    min_path[0][0] = 0\n    k.times do |i|\n        (0...n).each\
    \ do |r|\n            (0...n).each do |c|\n                if i == 0\n       \
    \             neighbors = [[r, c-1], [r, c+1], [r-1, c], [r+1, c]]\n         \
    \           paths = neighbors.map do |r, c|\n                        if r >= 0\
    \ && r < n && c >= 0 && c < n\n                            min_path[r][c]\n  \
    \                      else\n                            2 ** 31\n           \
    \             end\n                    end\n                    min_path[r][c]\
    \ = [grid[r][c], *paths].min\n                else\n                    min_path[r][c]\
    \ = [min_path[r][c], min_path[r-1][c], min_path[r+1][c], min_path[r][c-1], min_path[r][c+1]].min\n\
    \                end\n            end\n        end\n    end\n    # find the path\n\
    \    curr = [0, 0]\n    path = [grid[0][0]]\n    k.times do |i|\n        min =\
    \ min_path[curr[0]][curr[1]]\n        neighbors = [[curr[0], curr[1]-1], [curr[0],\
    \ curr[1]+1], [curr[0]-1, curr[1]], [curr[0]+1, curr[1]]]\n        neighbors.each\
    \ do |r, c|\n            if r >= 0 && r < n && c >= 0 && c < n && min_path[r][c]\
    \ == min\n                curr = [r, c]\n                path << grid[r][c]\n\
    \                break\n            end\n        end\n    end\n    path\nend\n\
    grid = [ [1,2,3], [4,5,6], [7,8,9] ]\nputs minPath(grid, 3) == [1, 2, 1]\nputs\
    \ min", "    n = grid.length\n    startNode = Node.new(grid, k, 0, 0, 0)\n   \
    \ q = [startNode]\n    visited = { }\n    while !q.empty?\n        current = q.shift\n\
    \        if current.k == 0\n            return current.path\n        end\n   \
    \     id = current.x.to_s + '_' + current.y.to_s\n        if visited[id]\n   \
    \         next\n        end\n        visited[id] = true\n        # up\n      \
    \  if current.x > 0\n            q.push(Node.new(grid, current.k - 1, current.x\
    \ - 1, current.y, current.value))\n        end\n        # down\n        if current.x\
    \ < n - 1\n            q.push(Node.new(grid, current.k - 1, current.x + 1, current.y,\
    \ current.value))\n        end\n        # left\n        if current.y > 0\n   \
    \         q.push(Node.new(grid, current.k - 1, current.x, current.y - 1, current.value))\n\
    \        end\n        # right\n        if current.y < n - 1\n            q.push(Node.new(grid,\
    \ current.k - 1, current.x, current.y + 1, current.value))\n        end\n    end\n\
    \    return []\nend", "    return [] if grid.empty?\n    r = grid.size\n    c\
    \ = grid[0].size\n    # Define distance from starting point (0, 0) to all other\
    \ cells.\n    # This distance is a function of the number of moves we need to\n\
    \    # make to reach each cell.\n    min_distance = Array.new(r) { Array.new(c,\
    \ -1) }\n    # Define a priority queue (sorted array) which holds the cells\n\
    \    # that are still to be processed.\n    q = []\n    # Add the starting point\
    \ (0, 0) with distance 0 to the priority queue.\n    q << [0, 0, 0]\n    min_distance[0][0]\
    \ = 0\n    while !q.empty?\n        # Extract the element with the lowest distance\
    \ from the priority queue.\n        p = q.shift\n        # Get the cell.\n   \
    \     i = p[0]\n        j = p[1]\n        d = p[2]\n        # Check if we need\
    \ to update the distance of any of the neighbors.\n        [[i - 1, j], [i + 1,\
    \ j], [i, j - 1], [i, j + 1]].each do |t|\n            ii = t[0]\n           \
    \ jj = t[1]\n            # If (ii, jj) is out of the grid, skip.\n           \
    \ next if ii < 0 || ii >= r || jj < 0 || jj >= c\n            # If we need more\
    \ moves to reach (ii, jj) than what we already have,\n            # skip.\n  \
    \          next if d + 1 > k\n            # If we've not been to (ii, jj) before\
    \ or if we can reach it with\n            # less moves than we could before, update\
    \ the distance.\n            if min_distance[ii][jj] == -1 || min_distance[ii][jj]\
    \ > d + 1\n                min_distance[ii][jj] = d + 1\n                # We\
    \ also need to update the priority queue.\n                # First, check if (ii,\
    \ jj) is already in the priority queue.\n                idx = q.find_index {\
    \ |x| x[0] == ii && x[1] == jj }", "  res = []\n  n = grid.size\n  (0...n).each\
    \ do |i|\n    (0...n).each do |j|\n      dfs(grid, i, j, k, res, [])\n    end\n\
    \  end\n  res\nend", "  n = grid.size\n  m = Array.new(n) { Array.new(n, 0) }\n\
    \  1.upto(n - 1) do |i|\n    1.upto(n - 1) do |j|\n      if i == 1 && j == 1\n\
    \        m[i][j] = grid[i][j]\n      elsif i == 1\n        m[i][j] = m[i][j -\
    \ 1] + grid[i][j]\n      elsif j == 1\n        m[i][j] = m[i - 1][j] + grid[i][j]\n\
    \      else\n        m[i][j] = [m[i - 1][j], m[i][j - 1]].min + grid[i][j]\n \
    \     end\n    end\n  end\n  p m\n  dp = Array.new(n) { Array.new(n, Array.new(k\
    \ + 1, 0)) }\n  dp[1][1][1] = grid[1][1]\n  2.upto(n - 1) do |i|\n    1.upto(k)\
    \ do |l|\n      dp[i][1][l] = dp[i - 1][1][l - 1] + grid[i][1]\n    end\n  end\n\
    \  2.upto(n - 1) do |j|\n    1.upto(k) do |l|\n      dp[1][j][l] = dp[1][j - 1][l\
    \ - 1] + grid[1][j]\n    end\n  end\n  2.upto(n - 1) do |i|\n    2.upto(n - 1)\
    \ do |j|\n      1.upto(k) do |l|\n        dp[i][j][l] = [dp[i - 1][j][l - 1],\
    \ dp[i][j - 1][l - 1]].min + grid[i][j]\n      end\n    end\n  end\n  p dp\n \
    \ grid[1][1] = m[1][1]\n  1.upto(k - 1) do |l|\n   ", "  n = grid.size\n  # All\
    \ 4 possible moves a knight can make:\n  moves = [[1,2],[2,1],[-1,2],[-2,1],[1,-2],[2,-1],[-1,-2],[-2,-1]]\n\
    \  # We use a priority queue to keep track of the minimum path we saw so far.\n\
    \  # We use a pair of integers as the priority. (sum of the values on the cells\n\
    \  # visited in the path, sum of the squares of the values on the cells visited\n\
    \  # in the path). \n  queue = PQueue.new([]) { |a,b| a[0] < b[0] || (a[0] ==\
    \ b[0] && a[1] < b[1]) }\n  # Since we can start from any cell, we loop on all\
    \ cells.\n  for i in 0...n\n    for j in 0...n\n      # We initiate the queue\
    \ with (0,0) as the value and ([i,j], grid[i][j])\n      # as the priority. The\
    \ priority pair is the pair of integer that holds\n      # the sum of the values\
    \ on the cells visited so far and the sum of the\n      # squares of the values\
    \ on the cells visited so far.\n      queue.push([[i,j],grid[i][j]], [0,0])\n\
    \    end\n  end\n  # As long as the queue is not empty.\n  while !queue.empty?\n\
    \    # We get the element with the minimum priority.\n    value, curr_sum, curr_sum_sq\
    \ = queue.pop\n    # We update the current path's length.\n    path_len = value.size\n\
    \    # If the current path's length is greater than k, we skip it.\n    next if\
    \ path_len > k\n    # We get the current position of the knight on the grid.\n\
    \    curr_pos = value[-1]\n    # If the current path's length is k, we just check\
    \ if the priority of the\n    # path is the minimum priority we saw so far, if\
    \ yes, we update the\n    # answer.\n    if path_len == k\n      if @min_sum.nil?\
    \ || (curr_sum < @min_", "\nend", "    if grid.length < 2 || grid[0].length <\
    \ 2\n        return []\n    end\n    n = grid.length\n    m = grid[0].length\n\
    \    dp = Array.new(n + 1){Array.new(m + 1){Array.new(k + 1){[]}}}\n    dp[0][0][0]\
    \ = []\n    for l in 0..k\n        for i in 0..n\n            for j in 0..m\n\
    \                if l == 0\n                    dp[i][j][l] = []\n           \
    \     else\n                    dp[i][j][l] = dp[i][j][l - 1]\n              \
    \      if i > 0\n                        a = dp[i - 1][j][l - 1] + [grid[i - 1][j]]\n\
    \                        if a < dp[i][j][l]\n                            dp[i][j][l]\
    \ = a\n                        end\n                    end\n                \
    \    if j > 0\n                        a = dp[i][j - 1][l - 1] + [grid[i][j -\
    \ 1]]\n                        if a < dp[i][j][l]\n                          \
    \  dp[i][j][l] = a\n                        end\n                    end\n   \
    \             end\n            end\n        end\n    end\n    res = []\n    for\
    \ i in 0..n\n        for j in 0..m\n            if dp[i][j][k] < res\n       \
    \         res = dp[i][j][k]\n            end\n        end\n    end\n    return\
    \ res\nend", "  # write your code here\nend", "  # TODO\nend", "\nend", "\tqueue\
    \ = []\n\tqueue << [0, 0, [grid[0][0]]]\n\tvisited = []\n\tvisited << [0, 0]\n\
    \twhile !queue.empty?\n\t\trow, col, path = queue.shift\n\t\treturn path if path.length\
    \ == k\n\t\t[-1, 0, 1].each do |dx|\n\t\t\t[-1, 0, 1].each do |dy|\n\t\t\t\tnext\
    \ if dx == 0 && dy == 0\n\t\t\t\tr = row + dx\n\t\t\t\tc = col + dy\n\t\t\t\t\
    next if r < 0 || r >= grid.length || c < 0 || c >= grid[0].length\n\t\t\t\tif\
    \ !visited.include?([r, c])\n\t\t\t\t\tqueue << [r, c, path + [grid[r][c]]]\n\t\
    \t\t\t\tvisited << [r, c]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend", "\nend",
  "\nend", "\tn = grid.length\n\tans = []\n\tfor i in (0...n)\n\t\tfor j in (0...n)\n\
    \t\t\tans = minPathRecur(grid, k, i, j, i, j, [grid[i][j]], ans)\n\t\tend\n\t\
    end\n\treturn ans\nend", "\nend", "    n = grid.length\n    m = grid[0].length\n\
    \    min_path_length = (n * m).times.each_with_object({}) do |i, memo|\n     \
    \   memo[i] = {}\n    end\n    (0...n).each do |i|\n        (0...m).each do |j|\n\
    \            cur_val = grid[i][j]\n            (cur_val...(n * m)).each do |new_val|\n\
    \                path_length = get_path_length(n, m, i, j, cur_val, new_val)\n\
    \                min_path_length[cur_val][new_val] = path_length if path_length\n\
    \            end\n        end\n    end\n    dp = (0...(n * m)).each_with_object({})\
    \ do |i, memo|\n        memo[i] = []\n    end\n    k.times do |i|\n        new_dp\
    \ = (0...(n * m)).each_with_object({}) do |j, memo|\n            memo[j] = []\n\
    \        end\n        (0...(n * m)).each do |cur_val|\n            (0...(n * m)).each\
    \ do |new_val|\n                next if cur_val == new_val\n                cur_path_len\
    \ = min_path_length[cur_val][new_val]\n                cur_path = [cur_val] +\
    \ dp[cur_val]\n                if i == 0\n                    new_dp[new_val]\
    \ = cur_path if cur_path_len\n                else\n                    next if\
    \ cur_path_len.nil?\n                    pre_path = new_dp[cur_val]\n        \
    \            if pre_path.empty?\n                        new_dp[new_val] = cur_path\n\
    \                    else\n                        cur_path_with_pre = pre_path\
    \ + cur_path\n                        if cur_path_with_pre.length < new_dp[new_val].length\n\
    \                            new_dp[new_val] = cur_path_with_pre\n           \
    \             elsif cur_path_with_pre.length == new_dp[new_val].length\n     \
    \                       new_dp[new", "\nend", "  assert { k > 0 }\n  n = grid.size\n\
    \  # all possible paths of length k\n  paths = []\n  # initially, path is empty\n\
    \  (1..n).each do |i|\n    (1..n).each do |j|\n      paths << [grid[i - 1][j -\
    \ 1]]\n    end\n  end\n  # fill more cells into the path\n  (2..k).each do\n \
    \   new_paths = []\n    paths.each do |path|\n      x, y = (1..n).find { |i| (1..n).find\
    \ { |j| grid[i - 1][j - 1] == path.last } }\n      [ [x - 1, y], [x + 1, y], [x,\
    \ y - 1], [x, y + 1] ].each do |x1, y1|\n        next if x1 < 1 || x1 > n || y1\
    \ < 1 || y1 > n\n        new_paths << path + [grid[x1 - 1][y1 - 1]]\n      end\n\
    \    end\n    paths = new_paths\n  end\n  paths.min\nend", "  @visited = []\n\
    \  @grid = grid\n  @k = k\n  @min_path = nil\n  @min_path_value = nil\n  @n =\
    \ grid.length\n  @visited = Array.new(@n) { Array.new(@n, false) }\n  traverse(0,\
    \ 0, 0, [grid[0][0]])\n  @min_path\nend", "  h = grid.size\n  w = grid[0].size\n\
    \  # Base cases\n  return [] if h == 0 || w == 0\n  return [grid[0][0]] if k ==\
    \ 1\n  return [] if k < 1\n  # Build map of nexts\n  nexts = {}\n  h.times do\
    \ |i|\n    w.times do |j|\n      nexts[[i, j]] = []\n      nexts[[i, j]] << [i\
    \ - 1, j] if i > 0\n      nexts[[i, j]] << [i + 1, j] if i < h - 1\n      nexts[[i,\
    \ j]] << [i, j - 1] if j > 0\n      nexts[[i, j]] << [i, j + 1] if j < w - 1\n\
    \    end\n  end\n  # Use DFS to find minimum path\n  cache = {}\n  min_path =\
    \ dfs(grid, k, nexts, [0, 0], cache)\n  min_path.nil? ? [] : min_path\nend", "\n\
    end", "    return nil if grid.length == 0 || grid[0].length == 0\n    return nil\
    \ if k < 1\n    res = []\n    queue = [[0, 0, grid[0][0]]]\n    visited = { \"\
    0-0\" => 1 }\n    while !queue.empty?\n        len = queue.length\n        for\
    \ i in 0...len\n            loc = queue.shift\n            i, j, val = loc[0],\
    \ loc[1], loc[2]\n            if i == grid.length - 1 && j == grid[0].length -\
    \ 1\n                return res + [val] if visited[\"#{i}-#{j}\"] == k\n     \
    \       end\n            if i > 0 && visited[\"#{i - 1}-#{j}\"] != visited[\"\
    #{i}-#{j}\"] + 1\n                visited[\"#{i - 1}-#{j}\"] = visited[\"#{i}-#{j}\"\
    ] + 1\n                queue.push([i - 1, j, grid[i - 1][j]])\n            end\n\
    \            if i < grid.length - 1 && visited[\"#{i + 1}-#{j}\"] != visited[\"\
    #{i}-#{j}\"] + 1\n                visited[\"#{i + 1}-#{j}\"] = visited[\"#{i}-#{j}\"\
    ] + 1\n                queue.push([i + 1, j, grid[i + 1][j]])\n            end\n\
    \            if j > 0 && visited[\"#{i}-#{j - 1}\"] != visited[\"#{i}-#{j}\"]\
    \ + 1\n                visited[\"#{i}-#{j - 1}\"] = visited[\"#{i}-#{j}\"] + 1\n\
    \                queue.push([i, j - 1, grid[i][j - 1]])\n            end\n   \
    \         if j < grid[0].length - 1 && visited[\"#{i}-#{j + 1}\"] != visited[\"\
    #{i}-#{j}\"] + 1\n                visited[\"#{i}-#{j + 1}\"] = visited[\"#{i}-#{j}\"\
    ] + 1\n                queue.push([", "  # TODO: Implement solution\nend", "\t\
    n = grid.length\n\tdist = Array.new(n){Array.new(n)}\n\tdp = Array.new(n){Array.new(n)}\n\
    \t# BFS to find min distance to each cell.\n\tqueue = [[0, 0]]\n\tdist[0][0] =\
    \ 0\n\tvisited = {}\n\tuntil queue.empty?\n\t\tx, y = queue.shift\n\t\tnext if\
    \ visited[[x, y]]\n\t\tvisited[[x, y]] = true\n\t\t[[1, 0], [-1, 0], [0, 1], [0,\
    \ -1]].each do |dx, dy|\n\t\t\tx1, y1 = x + dx, y + dy\n\t\t\tnext if (x1 < 0\
    \ || x1 >= n || y1 < 0 || y1 >= n)\n\t\t\tnext if visited[[x1, y1]]\n\t\t\tdist[x1][y1]\
    \ = dist[x][y] + 1\n\t\t\tqueue << [x1, y1]\n\t\tend\n\tend\n\t# Now we will treat\
    \ this as a knapsack problem. Fill dp[i][j] with the\n\t# minimum path that goes\
    \ through the first i cells and uses j positions\n\t# in the matrix.\n\t(0...n).each\
    \ do |i|\n\t\t(0...n).each do |j|\n\t\t\tdp[i][j] = (1..i).reduce(0) {|acc, ii|\
    \ acc + grid[ii][j]}\n\t\tend\n\tend\n\t(1...n).each do |i|\n\t\t(0...n).each\
    \ do |j|\n\t\t\t(0...n).each do |jj|\n\t\t\t\t# Using a position again.\n\t\t\t\
    \tif j == jj\n\t\t\t\t\tdp[i][j] = [dp[i][j], dp[i - 1][j] + grid[i][j]].min\n\
    \t\t\t\telse\n\t\t\t\t\t# Moving to the next position.\n\t\t\t\t\tdp[i][j] = [dp[i][j],\
    \ dp[i - 1][jj] + grid[", "  n = grid.size\n  min_path = [[[(1 << 32) - 1, []]]\
    \ * n] * n\n  min_path[0][0][0] = [grid[0][0], [grid[0][0]]]\n  puts \"grid =\
    \ #{grid.inspect}, k = #{k}, min_path = #{min_path.inspect}\"\n  max_sum = n *\
    \ n * (n * n + 1) / 2\n  (0..n - 1).each do |i|\n    (0..n - 1).each do |j|\n\
    \      (0..n * n - 1).each do |steps|\n        next if steps >= max_sum\n    \
    \    next if steps - grid[i][j] < 0\n        next if min_path[i][j][steps] ==\
    \ [(1 << 32) - 1, []]\n        prev_sum = steps - grid[i][j]\n        # consider\
    \ all possible previous sums\n        prev_sum.downto(0).each do |p|\n       \
    \   # consider all possible neighbors\n          [[i - 1, j], [i + 1, j], [i,\
    \ j - 1], [i, j + 1]].each do |m, n|\n            next if m < 0 || m >= grid.size\
    \ || n < 0 || n >= grid.size\n            sum = grid[m][n] + p\n            next\
    \ if sum > steps\n            next if min_path[m][n][sum] == [(1 << 32) - 1, []]\n\
    \            new_path = min_path[m][n][sum][1] + [grid[i][j]]\n            if\
    \ new_path.size == k\n              return new_path\n            end\n       \
    \     new_sum = min_path[m][n][sum][0] + grid[i][j]\n            min_path[i][j][steps]\
    \ = [new_sum, new_path] if new_sum < min_path[i][j][steps][0]\n          end\n\
    \        end\n      end\n    end\n  end\n  if min_path[n - 1][n - 1][k - 1] ==\
    \ [(1 << 32) - 1, []]\n    return []\n", "    # return the minimum path in the\
    \ grid, in the form of a list of integers\nend", "  n = grid.size\n  m = grid[0].size\n\
    \  used = Array.new(n) { Array.new(m, false) }\n  minPathHelper(grid, k, 0, 0,\
    \ used, [grid[0][0]])\nend", "  size = grid.size\n  min_path = []\n  # each cell\
    \ of the grid contains a value. Every integer in the range\n  # [1, N * N] inclusive\
    \ appears exactly once on the cells of the grid.\n  # => (1..N*N).to_a\n  return\
    \ min_path if k < 1\n  # A path A (of length k) is considered less than a path\
    \ B (of length k) if\n  # after making the ordered lists of the values on the\
    \ cells that A and B go\n  # through (let's call them lst_A and lst_B), lst_A\
    \ is lexicographically less\n  # than lst_B, in other words, there exist an integer\
    \ index i (1 <= i <= k)\n  # such that lst_A[i] < lst_B[i] and for any j (1 <=\
    \ j < i) we have\n  # lst_A[j] = lst_B[j].\n  cache = {}\n  (0...size).each do\
    \ |i|\n    (0...size).each do |j|\n      # Note that each path starts with a cell.\n\
    \      # Note that a path of length k means visiting exactly k cells (not\n  \
    \    # necessarily distinct).\n      # A path A (of length k) is considered less\
    \ than a path B (of length k)\n      # if after making the ordered lists of the\
    \ values on the cells that A\n      # and B go through (let's call them lst_A\
    \ and lst_B), lst_A is\n      # lexicographically less than lst_B, in other words,\
    \ there exist an\n      # integer index i (1 <= i <= k) such that lst_A[i] < lst_B[i]\
    \ and for\n      # any j (1 <= j < i) we have lst_A[j] = lst_B[j].\n      path\
    \ = walk(grid, k - 1, i, j, cache)\n      min_path = path if min_path.empty? ||\
    \ path < min_path\n    end\n  end\n  return min_path\nend", "\nend", "    return\
    \ [] if grid.empty? or grid[0].empty? or k <= 0\n    n = grid.size\n    m = grid[0].size\n\
    \    dp = Array.new(n) { Array.new(m) { Array.new } }\n    1.upto(k) do |i|\n\
    \        (0...n).each do |x|\n            (0...m).each do |y|\n              \
    \  path = []\n                cur_val = grid[x][y]\n                path << cur_val\n\
    \                if x - 1 >= 0\n                    up_path = dp[x - 1][y]\n \
    \                   path = get_smaller_path(path, up_path)\n                end\n\
    \                if x + 1 < n\n                    down_path = dp[x + 1][y]\n\
    \                    path = get_smaller_path(path, down_path)\n              \
    \  end\n                if y - 1 >= 0\n                    left_path = dp[x][y\
    \ - 1]\n                    path = get_smaller_path(path, left_path)\n       \
    \         end\n                if y + 1 < m\n                    right_path =\
    \ dp[x][y + 1]\n                    path = get_smaller_path(path, right_path)\n\
    \                end\n                dp[x][y] = path\n            end\n     \
    \   end\n    end\n    return dp[0][0]\nend", "  return [] if k == 0\n  return\
    \ [grid[0][0]] if k == 1\n  n = grid.length\n  # if k > n * n / 2, then the answer\
    \ has to be non-decreasing, in other words,\n  # we have to go from smallest to\
    \ biggest cell.\n  if k > n * n / 2\n    ans = (1..n * n).to_a\n    getPath(grid,\
    \ ans, 0, 0, 0, k)\n    return ans\n  end\n  # if k <= n * n / 2, then we can\
    \ greedily go from biggest to smallest,\n  # but as soon as we see a number that\
    \ is too big for current step, we change\n  # direction, go to the smallest number.\n\
    \  ans = (1..n * n).to_a.reverse\n  visited = [].tap {|x| n.times {x << Array.new(n,\
    \ false)}}\n  (n - 1).downto(0) do |i|\n    (n - 1).downto(0) do |j|\n      val\
    \ = grid[i][j]\n      if !visited[i][j] && val == ans[k - 1]\n        getPath(grid,\
    \ ans, i, j, 0, k)\n        return ans\n      end\n    end\n  end\n  return ans\n\
    end", "    res = []\n    min = 2 ** 32\n    (0...grid.length).each do |i|\n  \
    \      (0...grid[0].length).each do |j|\n            helper(grid, i, j, k, [],\
    \ min, res)\n        end\n    end\n    res\nend", "  # @param {Integer[][]} grid\n\
    \  # @param {Integer} k\n  # @return {Integer[]}\nend", "  n = grid.size\n  dp\
    \ = Array.new(n) { Array.new(n) { Array.new(k + 1, nil) } }\n  dp[0][0][0] = []\n\
    \  stack = [[0, 0, 0]]\n  while !stack.empty?\n    i, j, step = stack.pop\n  \
    \  next if step > k\n    if dp[i][j][step].nil?\n      dp[i][j][step] = []\n \
    \   else\n      next\n    end\n    dp[i][j][step] << grid[i][j]\n    if i > 0\n\
    \      stack << [i - 1, j, step + 1]\n    end\n    if i < n - 1\n      stack <<\
    \ [i + 1, j, step + 1]\n    end\n    if j > 0\n      stack << [i, j - 1, step\
    \ + 1]\n    end\n    if j < n - 1\n      stack << [i, j + 1, step + 1]\n    end\n\
    \  end\n  result = nil\n  for i in 0...n\n    for j in 0...n\n      next if dp[i][j][k].nil?\n\
    \      cur = dp[i][j][k]\n      if result.nil? || result > cur\n        result\
    \ = cur\n      end\n    end\n  end\n  result\nend", "\t# row, col = grid.size,\
    \ grid[0].size\n\t# dp = Array.new(row) { Array.new(col) { Array.new(k) { nil\
    \ } } }\n\t# 1.upto(row - 1) do |i|\n\t# \t1.upto(col - 1) do |j|\n\t# \t\t0.upto(k\
    \ - 1) do |n|\n\t# \t\t\tdp[i][j][n] = [dp[i - 1][j][n], dp[i][j - 1][n]].compact.min_by\
    \ do |m|\n\t# \t\t\t\t(m + [grid[i][j]]).sort\n\t# \t\t\tend\n\t# \t\tend\n\t\
    # \tend\n\t# end\n\t# dp[row - 1][col - 1][k - 1]\n\trow, col = grid.size, grid[0].size\n\
    \tdp = Array.new(row) { Array.new(col) { Array.new(k) { [] } } }\n\t0.upto(row\
    \ - 1) do |i|\n\t\t0.upto(col - 1) do |j|\n\t\t\t0.upto(k - 1) do |n|\n\t\t\t\t\
    if i == 0 && j == 0\n\t\t\t\t\tdp[i][j][n] = [grid[i][j]]\n\t\t\t\telsif i ==\
    \ 0\n\t\t\t\t\tdp[i][j][n] = [dp[i][j - 1][n], dp[i][j - 1][n - 1] + [grid[i][j]]].min_by\
    \ { |n| n.sort }\n\t\t\t\telsif j == 0\n\t\t\t\t\tdp[i][j][n] = [dp[i - 1][j][n],\
    \ dp[i - 1][j][n - 1] + [grid[i][j]]].min_by { |n| n.sort }\n\t\t\t\telse\n\t\t\
    \t\t\tdp[i][j][n] = [dp[i - 1][j][n], dp[", "    min = []\n    (0...grid.length).each\
    \ do |i|\n        (0...grid[0].length).each do |j|\n            res = []\n   \
    \         dfs(grid, i, j, k, res)\n            if min.empty? || res < min\n  \
    \              min = res\n            end\n        end\n    end\n    min\nend",
  "    n = grid.length\n    # The fact that grid is a square matrix of size n x n\n\
    \    # means that the range of values of index i and j is [0, n - 1]\n    # We\
    \ can use a 3D array of size n x n x n * n to store the minimum paths\n    # We\
    \ will do dynamic programming\n    # Let dp[i][j][l] be the minimum path of length\
    \ l that ends at cell (i, j)\n    # in other words, dp[i][j][l] = the minimum\
    \ path of length l that starts\n    # from any cell and end at cell (i, j)\n \
    \   # dp[i][j][l] = min(dp[x][y][l - 1]) for all neighbor (x, y) of (i, j)\n \
    \   # We can use this recursive formula to compute dp[i][j][l] for\n    # l =\
    \ n * n to 1\n    # The answer is then dp[0][0][k] as the path of length k that\
    \ starts from\n    # (0, 0) and ends at (0, 0) is the path of length k that starts\
    \ from any\n    # cell and ends at (0, 0)\n    dp = Array.new(n) { Array.new(n)\
    \ { Array.new(n * n, nil) } }\n    # We will use a variable up to store the path\
    \ of minimum length that\n    # starts from cell (0, 0) and ends at cell (0, 0)\n\
    \    up = nil\n    (n * n).downto(1) do |l|\n        (0...n).each do |i|\n   \
    \         (0...n).each do |j|\n                dp[i][j][l] = [ dp[i - 1][j][l\
    \ - 1], dp[i + 1][j][l - 1], dp[i][j - 1][l - 1], dp[i][j + 1][l - 1] ].compact.min\
    \ do |a, b|\n                    a <=> b\n                end\n              \
    \  dp[i][j][l] = dp[i][j][l] << grid[i][j] if l == 1\n               ", "  grid.min_by\
    \ { |x| x[k] }\nend", "  # Find the entry point with minimum value\n  m = grid.size\n\
    \  n = grid[0].size\n  min = nil\n  (0..m-1).each do |i|\n    (0..n-1).each do\
    \ |j|\n      if min.nil? || grid[i][j] < min\n        min = grid[i][j]\n     \
    \   min_i = i\n        min_j = j\n      end\n    end\n  end\n  # bfs\n  visited\
    \ = {}\n  queue = [[min_i, min_j, []]]\n  while !queue.empty?\n    curr = queue.shift\n\
    \    i = curr[0]\n    j = curr[1]\n    path = curr[2]\n    path << grid[i][j]\n\
    \    if path.size == k\n      return path\n    end\n    next if visited[[i, j]]\n\
    \    visited[[i, j]] = true\n    # up\n    if i > 0\n      queue << [i-1, j, path.clone]\n\
    \    end\n    # down\n    if i < m-1\n      queue << [i+1, j, path.clone]\n  \
    \  end\n    # left\n    if j > 0\n      queue << [i, j-1, path.clone]\n    end\n\
    \    # right\n    if j < n-1\n      queue << [i, j+1, path.clone]\n    end\n \
    \ end\nend", "  grid\nend", "  n = grid.size\n  m = grid[0].size\n  path = []\n\
    \  ((0...n) * (0...m)).to_a.sort do |(x1, y1), (x2, y2)|\n    [grid[x1][y1], (x1\
    \ + y1).to_i] <=> [grid[x2][y2], (x2 + y2).to_i]\n  end.each do |x, y|\n    path\
    \ << []\n    curr = [x, y]\n    k.times do\n      path.last << grid[curr[0]][curr[1]]\n\
    \      curr =\n        [[curr[0] - 1, curr[1]], [curr[0] + 1, curr[1]],\n    \
    \     [curr[0], curr[1] - 1], [curr[0], curr[1] + 1]].min_by do |(x, y)|\n   \
    \       [grid[x][y], (x + y).to_i]\n        end\n    end\n  end\n  path.min_by(&:first)\n\
    end\ngrid = [ [1,2,3], [4,5,6], [7,8,9] ]\nk = 3\np minPath(grid, k)\ngrid = [\
    \ [5,9,3], [4,1,6], [7,8,2] ]\nk = 1\np minPath(grid, k)", "    row = grid.length\n\
    \    col = grid[0].length\n    dp = Array.new(row) { Array.new(col) { Array.new(k\
    \ + 1, []) } }\n    tmp = []\n    dp[0][0][1] = [grid[0][0]]\n    (1...col).each\
    \ do |i|\n        dp[0][i][1] = [grid[0][i]] if dp[0][i][1].empty?\n        (1..k).each\
    \ do |j|\n            next if dp[0][i][j].empty?\n            if tmp.empty? ||\
    \ tmp < dp[0][i][j]\n                tmp = dp[0][i][j]\n            end\n    \
    \    end\n    end\n    (1...row).each do |i|\n        dp[i][0][1] = [grid[i][0]]\
    \ if dp[i][0][1].empty?\n        (1..k).each do |j|\n            next if dp[i][0][j].empty?\n\
    \            if tmp.empty? || tmp < dp[i][0][j]\n                tmp = dp[i][0][j]\n\
    \            end\n        end\n    end\n    (1...row).each do |i|\n        (1...col).each\
    \ do |j|\n            (1..k).each do |z|\n                arr = []\n         \
    \       if z == 1\n                    arr = [grid[i][j]]\n                else\n\
    \                    if !dp[i - 1][j][z - 1].empty? && !dp[i][j - 1][z - 1].empty?\n\
    \                        if dp[i - 1][j][z - 1] < dp[i][j - 1][z - 1]\n      \
    \                      arr = dp[i - 1][j][z - 1] + [grid[i][j]]\n            \
    \            else\n                            arr = dp[i][j - 1][z - 1] + [grid[i][j]]\n\
    \                        end\n                    elsif !dp[i - 1][j][z - 1].empty?\n\
    \                        arr = dp[i - 1][j][z - 1", '    n = grid.length', '  p
    grid, k', "  return [] if k == 0\n  # since grid is NxN matrix\n  len = grid.length\n\
    \  # construct a hash table as a look up table\n  # keys: path of lenght k\n \
    \ # values: list of values on the cells that the path go through\n  look_up =\
    \ {}\n  # build the table\n  # find the path of length k for each cell in the\
    \ grid\n  for i in 0...len\n    for j in 0...len\n      # find the path of length\
    \ k from this cell\n      path = find_path(grid, look_up, k, i, j)\n      # save\
    \ the path if it is the minimum path\n      if look_up.empty?\n        look_up[path]\
    \ = [grid[i][j]]\n      else\n        look_up[path] = [grid[i][j]] if path < look_up.keys.first\n\
    \      end\n    end\n  end\n  look_up.values.first\nend", "  # Write your code\
    \ here\nend", "  n = grid.size\n  if n == 1\n    return [grid[0][0]]\n  end\n\
    \  dist = Array.new(n) { Array.new(n, -1) }\n  min_val, min_path = nil, nil\n\
    \  (0...n).each do |r|\n    (0...n).each do |c|\n      path = [grid[r][c]]\n \
    \     max_dist = 0\n      dist[r][c] = max_dist\n      q = Queue.new\n      q.push([r,\
    \ c])\n      while !q.empty?\n        i, j = q.pop\n        (i-1..i+1).each do\
    \ |x|\n          (j-1..j+1).each do |y|\n            if x >= 0 && x < n && y >=\
    \ 0 && y < n && grid[x][y] > grid[i][j] && dist[x][y] == -1\n              path.push(grid[x][y])\n\
    \              max_dist += 1\n              dist[x][y] = max_dist\n          \
    \    q.push([x, y])\n            end\n          end\n        end\n      end\n\
    \      if max_dist + 1 >= k\n        if min_val.nil? || path < min_val\n     \
    \     min_val = path\n          min_path = [r, c]\n        end\n      end\n  \
    \  end\n  end\n  path = []\n  r, c = min_path\n  while !path.size.eql?(k)\n  \
    \  path.push(grid[r][c])\n    (r-1..r+1).each do |x|\n      (c-1..c+1).each do\
    \ |y|\n        if x >= 0 && x < n && y >= 0 && y < n && grid[x][y] > grid[r][c]\
    \ && dist[x][y] < dist[r][c]\n          r, c = x, y\n          break\n       \
    \ end\n      end\n    end\n  end\n  path\nend", "  n = grid.size\n  # construct\
    \ a graph\n  graph = buildGraph(grid, n)\n  # dp[i][j] is the smallest path with\
    \ length k, ending at i,j\n  dp = []\n  n.times { |i| dp << [] }\n  n.times do\
    \ |i|\n    n.times do |j|\n      dp[i][j] = minPathEndingAt(i, j, graph, dp, k,\
    \ grid)\n    end\n  end\n  dp[0][0]\nend", "\t\nend", "  return [] if grid.nil?\
    \ || grid.empty? || grid[0].empty? || k <= 0\n  row, col = grid.size, grid[0].size\n\
    \  return [] if k > row * col\n  path = []\n  min_dfs(grid, path, k, 0, 0, Float::INFINITY)\n\
    \  path\nend", "  n = grid.size\n  q = Queue.new\n  path = []\n  puts \"Grid:\
    \ #{grid}\"\n  puts \"K: #{k}\"\n  puts \"Path: #{path}\"\n  if k == 1\n    min\
    \ = 99999\n    grid.each_with_index do |r, ri|\n      r.each_with_index do |e,\
    \ ei|\n        if e < min\n          min = e\n          path = [min]\n       \
    \ end\n      end\n    end\n    return path\n  end\n  grid.each_with_index do |r,\
    \ ri|\n    r.each_with_index do |e, ei|\n      q.push([e, [[ri, ei]]])\n    end\n\
    \  end\n  seen = {}\n  min = 99999\n  while !q.empty?\n    s, p = q.pop\n    puts\
    \ \"s: #{s}, p: #{p}\"\n    if s > min\n      next\n    end\n    if s == k\n \
    \     if s < min\n        min = s\n        path = p\n      end\n      next\n \
    \   end\n    p.each do |c|\n      c.each do |cc|\n        seen[cc] = true\n  \
    \    end\n    end\n    [0, -1].each do |i|\n      [0, -1].each do |j|\n      \
    \  [1, -1].each do |k|\n          [1, -1].each do |l|\n            next if i ==\
    \ 0 && j == 0\n            next if k == 0 && l == 0\n            ri = p[-1][0]\
    \ + i\n            ei = p[-1][1] + j\n            if ri < 0 || ri >= n || ei <\
    \ 0 || ei >= n\n              next\n            end\n            next if seen[[ri,\
    \ ei]]\n            q.push([s + grid[ri][ei], p + [[ri, ei]]])\n          end\n\
    \        end\n      end\n    end\n  end\n  puts \"path: #{path}\"\n  path.map\
    \ { |e| grid[e[0]][e[1]] }\nend", "  n = grid.size\n  m = grid[0].size\n  r =\
    \ k / m\n  c = k % m\n  r += 1 if c != 0\n  # r = k / n + (k % n == 0 ? 0 : 1)\n\
    \  res = [Array.new(m, grid[0][0])] * r\n  for i in 1...n\n    for j in 1...m\n\
    \      res[i][j] = grid[i][j] if i + j == k\n    end\n  end\n  res\nend", "\t\
    n = grid.length\n\tif (k == 1)\n\t\treturn [grid[0][0]]\n\tend\n\tif (k > n)\n\
    \t\treturn -1\n\tend\n\tif (k == n)\n\t\treturn grid[0]\n\tend\n\tk-=2\n\tfor\
    \ i in 1..k\n\t\tgrid[0][i] = grid[0][i-1] + grid[0][i]\n\t\tgrid[i][0] = grid[i-1][0]\
    \ + grid[i][0]\n\tend\n\tfor i in 1..k\n\t\tfor j in 1..k\n\t\t\tgrid[i][j] =\
    \ [grid[i-1][j], grid[i][j-1]].min + grid[i][j]\n\t\tend\n\tend\n\tgrid[k][k]\
    \ = [grid[k-1][k], grid[k][k-1]].min + grid[k][k]\n\tif (grid[k][k] > grid[0][0])\n\
    \t\treturn -1\n\tend\n\tmin = grid[k][k]\n\tpath = Array.new(2*k+1, 0)\n\ti =\
    \ k\n\tj = k\n\tidx = 2*k\n\tfor num in grid[0][0]..min\n\t\twhile i >= 0 && j\
    \ >= 0\n\t\t\tif (i == 0)\n\t\t\t\tpath[idx] = grid[i][j-1]\n\t\t\t\tj-=1\n\t\t\
    \telsif (j == 0)\n\t\t\t\tpath[idx] = grid[i-1][j]\n\t\t\t\ti-=1\n\t\t\telse\n\
    \t\t\t\tpath[idx] = [grid[i-1][j], grid[i][j-1]].min\n\t\t\t\tif (path[idx] ==\
    \ grid[i-1][j])\n\t\t\t\t\ti-=1\n\t\t\t\telse\n\t\t\t\t\tj-=1\n\t\t\t\tend\n\t\
    \t\tend\n\t\t\tidx-=1\n\t\tend\n\t\tpath[idx", "  n = grid.size\n  return [grid[0][0]]\
    \ if k == 1\n  if k == n*n\n    lst = []\n    (0...n).each do |i|\n      (0...n).each\
    \ do |j|\n        lst << grid[i][j]\n      end\n    end\n    return lst\n  end\n\
    \  q = []\n  seen = {}\n  seen[0] = {}\n  seen[0][0] = true\n  q << [0, 0, [grid[0][0]]]\n\
    \  while !q.empty?\n    r, c, lst = q.shift\n    if r == n-1 && c == n-1\n   \
    \   if lst.size == k\n        if lst.size == 1\n          return lst\n       \
    \ else\n          # print \"lst is #{lst}\"\n          return lst if lst.size\
    \ != k\n          return lst if lst < res\n        end\n      end\n    end\n \
    \   #up\n    if r > 0 && !seen[r-1].has_key?(c)\n      tmp = lst.dup\n      tmp\
    \ << grid[r-1][c]\n      q << [r-1, c, tmp]\n      seen[r-1] = {} if !seen.has_key?(r-1)\n\
    \      seen[r-1][c] = true\n    end\n    #down\n    if r < n-1 && !seen[r+1].has_key?(c)\n\
    \      tmp = lst.dup\n      tmp << grid[r+1][c]\n      q << [r+1, c, tmp]\n  \
    \    seen[r+1] = {} if !seen.has_key?(r+1)\n      seen[r+1][c] = true\n    end\n\
    \    #left\n    if c > 0 && !seen[r].has_key?(c-1)\n      tmp = lst.dup\n    \
    \  tmp << grid[r][c-1]\n      q << [r, c-1, tmp]\n      seen[r][c-1] = true\n\
    \    end\n    #right\n    if c <", "\tm = grid.length\n\tvisited = Array.new(m){Array.new(m)}\n\
    \tminPathUtil(grid, k, 0, 0, visited, [])\nend", "  rows = grid.length\n  return\
    \ nil if rows == 0", "  result = []\n  # Write your code here\n  return result\n\
    end", "\nend", end, "  n = grid.size\n  if k > n\n    return nil\n  end\n  if\
    \ k == 1\n    min_val = grid[0][0]\n    grid.each do |row|\n      row.each do\
    \ |val|\n        min_val = val if val < min_val\n      end\n    end\n    return\
    \ [min_val]\n  end\n  paths = [[[grid[0][0]], [0, 0]]]\n  visited = [[false] *\
    \ n] * n\n  visited[0][0] = true\n  while !paths.empty?\n    path, pos = paths.shift\n\
    \    if path.size == k\n      return path\n    end\n    neighbors = get_neighbors(pos,\
    \ n)\n    neighbors.each do |neighbor|\n      if !visited[neighbor[0]][neighbor[1]]\n\
    \        visited[neighbor[0]][neighbor[1]] = true\n        new_path = path.dup\
    \ << grid[neighbor[0]][neighbor[1]]\n        paths << [new_path, neighbor]\n \
    \     end\n    end\n  end\n  return nil\nend", "    n = grid.length\n    m = grid[0].length\n\
    \    res = []\n    min = []\n    minTotal = 0\n    (0...n).each do |i|\n     \
    \   (0...m).each do |j|\n            total = 0\n            path = dfs(grid, i,\
    \ j, k, total, [], res)\n            if path.nil?\n                next\n    \
    \        elsif min.nil?\n                min = path\n                minTotal\
    \ = total\n            elsif total < minTotal\n                min = path\n  \
    \              minTotal = total\n            elsif total == minTotal\n       \
    \         p1 = path.map(&:to_s).join\n                p2 = min.map(&:to_s).join\n\
    \                if p1 < p2\n                    min = path\n                \
    \    minTotal = total\n                end\n            end\n        end\n   \
    \ end\n    min\nend", "  n = grid.size\n  min_path = []\n  min_path_value = k\
    \ * grid.max_by { |col| col.max }.max\n  min_sum = k * n * (n + 1) / 2\n  min_sum_path\
    \ = []\n  min_sum_path_value = k * grid.max_by { |col| col.max }.max\n  queue\
    \ = []\n  queue << [0, 0, [grid[0][0]], grid[0][0]]\n  while queue.any?\n    i,\
    \ j, path, sum = queue.shift\n    if path.size == k\n      if path.first < min_path_value\n\
    \        min_path = path\n        min_path_value = path.first\n      end\n   \
    \   if sum < min_sum\n        min_sum_path = path\n        min_sum_path_value\
    \ = path.first\n        min_sum = sum\n      end\n    else\n      next if sum\
    \ + min_sum_path_value > min_sum\n      if i - 1 >= 0\n        queue << [i - 1,\
    \ j, path + [grid[i - 1][j]], sum + grid[i - 1][j]]\n      end\n      if i + 1\
    \ < n\n        queue << [i + 1, j, path + [grid[i + 1][j]], sum + grid[i + 1][j]]\n\
    \      end\n      if j - 1 >= 0\n        queue << [i, j - 1, path + [grid[i][j\
    \ - 1]], sum + grid[i][j - 1]]\n      end\n      if j + 1 < n\n        queue <<\
    \ [i, j + 1, path + [grid[i][j + 1]], sum + grid[i][j + 1]]\n      end\n    end\n\
    \  end\n  min_path\nend", "    min = nil\n    (0...grid.size).each do |i|\n  \
    \      (0...grid.size).each do |j|\n            res = [grid[i][j]]\n         \
    \   (minPathHelper(grid, i, j, grid[i][j], k - 1, res) if k > 1)\n           \
    \ min = res if min.nil? || min > res\n        end\n    end\n    min\nend", " \
    \ return nil if grid.nil? || grid.empty? || grid[0].empty? || k < 1\n  return\
    \ [grid[0][0]] if k == 1\n  min_lst = nil\n  (0...grid.size).each do |i|\n   \
    \ (0...grid[0].size).each do |j|\n      lst = [grid[i][j]]\n      lst = dfs(grid,\
    \ lst, i, j, k)\n      if lst\n        lst = [grid[i][j]] + lst\n        if min_lst.nil?\
    \ || lst < min_lst\n          min_lst = lst\n        end\n      end\n    end\n\
    \  end\n  min_lst\nend", "  n = grid.size\n  res = []\n  s = []\n  visited = Array.new(n)\
    \ { Array.new(n, false) }\n  s.push([0, 0, grid[0][0]])\n  visited[0][0] = true\n\
    \  min_path = nil\n  while s.any?\n    i, j, path = s.pop\n    if i == n - 1 &&\
    \ j == n - 1\n      if !min_path || path < min_path\n        min_path = path\n\
    \        res = path.split(',').map(&:to_i)\n      end\n    else\n      # Go up.\n\
    \      if i > 0 && !visited[i - 1][j]\n        visited[i - 1][j] = true\n    \
    \    s.push([i - 1, j, path + ',' + grid[i - 1][j].to_s])\n      end\n      #\
    \ Go down.\n      if i < n - 1 && !visited[i + 1][j]\n        visited[i + 1][j]\
    \ = true\n        s.push([i + 1, j, path + ',' + grid[i + 1][j].to_s])\n     \
    \ end\n      # Go left.\n      if j > 0 && !visited[i][j - 1]\n        visited[i][j\
    \ - 1] = true\n        s.push([i, j - 1, path + ',' + grid[i][j - 1].to_s])\n\
    \      end\n      # Go right.\n      if j < n - 1 && !visited[i][j + 1]\n    \
    \    visited[i][j + 1] = true\n        s.push([i, j + 1, path + ',' + grid[i][j\
    \ + 1].to_s])\n      end\n    end\n  end\n  res[0..k - 1]\nend\ngrid = [ [1,2,3],\
    \ [4,5,6], [7,8,9] ]\nputs minPath(grid, 3)\ngrid = [ [5,9,3], [4,1,6], [7,8,2]\
    \ ]\nputs minPath(grid, 1)", "  rows = grid.length\n  cols = grid[0].length\n\
    \  # Compute prefix sum.\n  prefix_sum = grid\n  0.upto(rows - 1) do |i|\n   \
    \ 0.upto(cols - 1) do |j|\n      if i > 0\n        prefix_sum[i][j] += prefix_sum[i\
    \ - 1][j]\n      end\n      if j > 0\n        prefix_sum[i][j] += prefix_sum[i][j\
    \ - 1]\n      end\n      if i > 0 && j > 0\n        prefix_sum[i][j] -= prefix_sum[i\
    \ - 1][j - 1]\n      end\n    end\n  end\n  # Compute the sum of a rectangle.\n\
    \  def rectangle_sum(prefix_sum, sr, sc, er, ec)\n    result = prefix_sum[er][ec]\n\
    \    if sr > 0\n      result -= prefix_sum[sr - 1][ec]\n    end\n    if sc > 0\n\
    \      result -= prefix_sum[er][sc - 1]\n    end\n    if sr > 0 && sc > 0\n  \
    \    result += prefix_sum[sr - 1][sc - 1]\n    end\n    result\n  end\n  # Compute\
    \ all path sum and store it in a hash table.\n  path_sum = {}\n  # The key of\
    \ the hash table is a string consisting of the following parts:\n  # 1. The length\
    \ of the path.\n  # 2. \":\"\n  # 3. The start location of the path.\n  # 4. \"\
    ->\"\n  # 5. The end location of the path.\n  0.upto(rows - 1) do |sr|\n    0.upto(cols\
    \ - 1) do |sc|\n      0.upto(rows - 1) do |er|\n        0.upto(cols - 1) do |ec|\n\
    \          if sr == er && sc == ec\n            path_sum[\"1:#{sr},#{sc}->#{er},#{ec}\"\
    ] = grid[sr][sc]\n          elsif er >= sr && ec >= sc\n            length = (er\
    \ - sr + 1) * (ec - sc +", "  rows = grid.length\n  columns = grid[0].length\n\
    \  return [] if rows * columns < k\n  path = []\n  queue = [{row: 0, column: 0,\
    \ path: [grid[0][0]]}]\n  while !queue.empty?\n    element = queue.shift\n   \
    \ if element[:path].length == k\n      path = element[:path]\n      break\n  \
    \  end\n    row = element[:row]\n    column = element[:column]\n    if column\
    \ + 1 < columns\n      temp = element[:path].dup\n      temp << grid[row][column\
    \ + 1]\n      queue << {row: row, column: column + 1, path: temp}\n    end\n \
    \   if row + 1 < rows\n      temp = element[:path].dup\n      temp << grid[row\
    \ + 1][column]\n      queue << {row: row + 1, column: column, path: temp}\n  \
    \  end\n  end\n  path\nend", "  n = grid.size\n  visited = Array.new(n) { Array.new(n,\
    \ 0) }\n  hm = {}\n  q = []\n  q << [0, 0, 1, grid[0][0]]\n  visited[0][0] = 1\n\
    \  hm[grid[0][0]] = 1\n  while !q.empty?\n    r, c, cost, val = q.shift\n    return\
    \ [val] if cost == k\n    if r + 1 < n && visited[r + 1][c] == 0\n      q << [r\
    \ + 1, c, cost + 1, val + grid[r + 1][c]]\n      visited[r + 1][c] = 1\n     \
    \ hm[val + grid[r + 1][c]] = cost + 1\n    end\n    if c + 1 < n && visited[r][c\
    \ + 1] == 0\n      q << [r, c + 1, cost + 1, val + grid[r][c + 1]]\n      visited[r][c\
    \ + 1] = 1\n      hm[val + grid[r][c + 1]] = cost + 1\n    end\n    if r - 1 >=\
    \ 0 && visited[r - 1][c] == 0\n      q << [r - 1, c, cost + 1, val + grid[r -\
    \ 1][c]]\n      visited[r - 1][c] = 1\n      hm[val + grid[r - 1][c]] = cost +\
    \ 1\n    end\n    if c - 1 >= 0 && visited[r][c - 1] == 0\n      q << [r, c -\
    \ 1, cost + 1, val + grid[r][c - 1]]\n      visited[r][c - 1] = 1\n      hm[val\
    \ + grid[r][c - 1]] = cost + 1\n    end\n  end\n  val = hm.keys.min\n  res = []\n\
    \  cost = hm[val]\n  while cost > 0\n    res << val - grid[r][c]\n    if r + 1\
    \ < n && hm[val - grid[r][c]] == cost - 1\n      r += 1\n    elsif c + 1 < n &&\
    \ hm[val - grid", "  row = grid.length\n  col = grid[0].length\n  hash = {}\n\
    \  (0...row).each do |i|\n    (0...col).each do |j|\n      list = []\n      list\
    \ << i\n      list << j\n      hash[grid[i][j]] = list\n    end\n  end\n  puts\
    \ hash\n  ans = [hash[1][0], hash[1][1]]\n  hash.each do |k, v|\n    if v[0] ==\
    \ 0 && v[1] == 0\n      v[0] += 1\n      v[1] += 1\n    end\n    if v[0] > 0 &&\
    \ v[1] > 0\n      up = hash[grid[v[0] - 1][v[1]]]\n      left = hash[grid[v[0]][v[1]\
    \ - 1]]\n      case\n      when up.nil?\n        v[0] = left[0]\n        v[1]\
    \ = left[1]\n      when left.nil?\n        v[0] = up[0]\n        v[1] = up[1]\n\
    \      when up[0] < left[0]\n        v[0] = up[0]\n        v[1] = up[1]\n    \
    \  when up[0] > left[0]\n        v[0] = left[0]\n        v[1] = left[1]\n    \
    \  when up[0] == left[0]\n        if up[1] < left[1]\n          v[0] = up[0]\n\
    \          v[1] = up[1]\n        else\n          v[0] = left[0]\n          v[1]\
    \ = left[1]\n        end\n      end\n    end\n  end\n  puts hash\n  ans = [ans[0],\
    \ ans[1]]\n  while k > 0\n    up = [ans[0] - 1, ans[1]]\n    left = [ans[0], ans[1]\
    \ - 1]\n    down = [ans[0] + 1, ans[1]]\n    right = [ans[0], ans[1] + 1]\n  \
    \  list = []\n    list << up\n   ", "    n = grid.length\n    return [] if k >\
    \ n * n\n    min_path = []\n    min_value = 10 ** 6\n    dirs = [[0, 1], [0, -1],\
    \ [1, 0], [-1, 0]]\n    q = Queue.new\n    q.enq([0, 0, 0, []])\n    seen = Set.new\n\
    \    until q.empty?\n        x, y, v, path = q.deq\n        if v < min_value\n\
    \            min_value = v\n            min_path = path\n        end\n       \
    \ if v == min_value\n            if path < min_path\n                min_path\
    \ = path\n            end\n        end\n        dirs.each do |dx, dy|\n      \
    \      nx, ny = x + dx, y + dy\n            if nx >= 0 && nx < n && ny >= 0 &&\
    \ ny < n && !seen.include?([nx, ny])\n                seen.add([nx, ny])\n   \
    \             if grid[nx][ny] < v\n                    q.enq([nx, ny, grid[nx][ny],\
    \ path + [grid[nx][ny]]])\n                else\n                    q.enq([nx,\
    \ ny, v, path])\n                end\n            end\n        end\n    end\n\
    \    min_path\nend", "  return [] if grid.nil? or grid.length == 0 or grid[0].length\
    \ == 0\n  return [] if k <= 0\n  len = grid.length\n  res = []\n  curMin = grid[0][0]\n\
    \  queue = [[0, 0, grid[0][0]]]\n  visited = Array.new(len) { Array.new(len, false)\
    \ }\n  visited[0][0] = true\n  while !queue.empty?\n    x, y, cur = queue.shift\n\
    \    if res.length > 0\n      return res if cur > curMin\n    end\n    if k ==\
    \ 0\n      if res.length == 0\n        res = [cur]\n        curMin = cur\n   \
    \   else\n        if cur < curMin\n          res = [cur]\n          curMin = cur\n\
    \        elsif cur == curMin\n          res.push(cur)\n        end\n      end\n\
    \    end\n    [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |step|\n      xx = x\
    \ + step[0]\n      yy = y + step[1]\n      if xx >= 0 and xx < len and yy >= 0\
    \ and yy < len and !visited[xx][yy]\n        visited[xx][yy] = true\n        queue.push([xx,\
    \ yy, cur + grid[xx][yy]])\n      end\n    end\n  end\n  return res\nend", "\n\
    end", "    len = grid.length\n    pq = []\n    pq.push([0, 0, 0, [grid[0][0]]])\n\
    \    while !pq.empty?\n        score, i, j, list = pq.shift\n        if list.length\
    \ == k\n            return list\n        end\n        if i > 0 && grid[i - 1][j]\
    \ != -1\n            pq.push([list.length, i - 1, j, list + [grid[i - 1][j]]])\n\
    \            grid[i - 1][j] = -1\n        end\n        if i < len - 1 && grid[i\
    \ + 1][j] != -1\n            pq.push([list.length, i + 1, j, list + [grid[i +\
    \ 1][j]]])\n            grid[i + 1][j] = -1\n        end\n        if j > 0 &&\
    \ grid[i][j - 1] != -1\n            pq.push([list.length, i, j - 1, list + [grid[i][j\
    \ - 1]]])\n            grid[i][j - 1] = -1\n        end\n        if j < len -\
    \ 1 && grid[i][j + 1] != -1\n            pq.push([list.length, i, j + 1, list\
    \ + [grid[i][j + 1]]])\n            grid[i][j + 1] = -1\n        end\n       \
    \ pq.sort!{|a, b| a[0] <=> b[0]}\n    end\nend", "  # Ordering of visiting grid\
    \ cells is arbitrary, so we can assume we\n  # always start at grid[0][0]. This\
    \ implies we can compute the minimum\n  # path recursively:\n  #   1. Let's say\
    \ the minimum path goes through cells (0, 0), (1, 1), (2, 2), etc.\n  #   2. Then\
    \ grid[0][0] must be the minimum entry in the first row.\n  #   3. Then the minimum\
    \ path from (0, 0) to (1, 1) is the minimum path\n  #      from (1, 0) to (1,\
    \ 1) + the minimum path from (1, 1) to (2, 2).\n  #\n  #   4. The minimum path\
    \ from (1, 0) to (1, 1) is the minimum entry in the\n  #      second row.\n  #\
    \   5. Then the minimum path from (1, 1) to (2, 2) is the minimum path\n  #  \
    \    from (2, 1) to (2, 2) + the minimum path from (2, 2) to (3, 3).\n  #\n  #\
    \   6. The minimum path from (2, 1) to (2, 2) is the minimum entry in the\n  #\
    \      third row.\n  #   7. And so on...\n  #\n  # Because of this recursive nature,\
    \ we can store the minimum path from\n  # (i, j) to (i + 1, j + 1) in grid[i][j].\n\
    \  #\n  # Let's say the minimum path goes through cells (i, j), (i + 1, j + 1),\n\
    \  # (i + 2, j + 2), etc. Then the total length of the path is i + 1. If the\n\
    \  # total length of the path equals k, then we're done. Otherwise, we can\n \
    \ # recursively compute the minimum path from (i + 1, j + 1) to (i + 2, j + 2).\n\
    \  #\n  # Since (i + 1, j + 1) is always the minimum entry in its row, the\n \
    \ # minimum path from (i + 1, j + 1) to (i + 2, j + 2) is the minimum path\n \
    \ # from (i +", "  rows = grid.length\n  cols = grid[0].length\n  min = (1..rows*cols).to_a.join(\"\
    \").to_i\n  path = []\n  visited = Array.new(rows) { Array.new(cols, false) }\n\
    \  curr_path = []\n  dfs(grid, 0, 0, curr_path, visited, k, min, path)\n  path\n\
    end", "  min = []\n  (0...grid.size).each do |i|\n    (0...grid.size).each do\
    \ |j|\n      if grid[i][j] == 1\n        path = visit(grid, i, j, k)\n       \
    \ min = path if min.empty? || path < min\n      end\n    end\n  end\n  min\nend",
  "  seen = {}\n  m = grid.length\n  n = grid[0].length\n  q = [[0, 0, k, [grid[0][0]]]]\n\
    \  seen[[0, 0, k]] = true\n  while !q.empty?\n    x, y, steps, path = q.shift\n\
    \    return path if steps == 0\n    [[x + 1, y], [x - 1, y], [x, y + 1], [x, y\
    \ - 1]].each do |a, b|\n      if !seen[[a, b, steps - 1]] &&\n          a >= 0\
    \ && a < m && b >= 0 && b < n\n        q << [a, b, steps - 1, path + [grid[a][b]]]\n\
    \        seen[[a, b, steps - 1]] = true\n      end\n    end\n  end\n  []\nend\n\
    grid = [ [1,2,3], [4,5,6], [7,8,9] ]\nputs minPath(grid, 3)", "  bestPath, bestPathValue\
    \ = [], Integer::MAX\n  len = grid.length\n  len.times do |i|\n    len.times do\
    \ |j|\n      tryMinPath(grid, i, j, k, bestPath, bestPathValue)\n    end\n  end\n\
    \  bestPath\nend", "\t@grid = grid\n\t@n = grid.length\n\t@k = k\n\t@cache = Hash.new(nil)\n\
    \t@cycle = Hash.new(false)\n\t@ans = nil\n\t@ans_found = false\n\t\n\tdef dfs(x,\
    \ y, k, path)\n\t\tif k == 0\n\t\t\tif !@ans_found || @ans > path\n\t\t\t\t@ans\
    \ = path\n\t\t\t\t@ans_found = true\n\t\t\tend\n\t\t\treturn\n\t\tend\n\t\tif\
    \ @cycle[path]\n\t\t\treturn\n\t\tend\n\t\tif @cache[path]\n\t\t\tif @cache[path]\
    \ <= k\n\t\t\t\treturn\n\t\t\tend\n\t\t\t@cycle[path] = true\n\t\t\treturn\n\t\
    \tend\n\t\t@cache[path] = k\n\t\t[[x - 1, y], [x + 1, y], [x, y - 1], [x, y +\
    \ 1]].each do |x2, y2|\n\t\t\tif (0...@n).include?(x2) && (0...@n).include?(y2)\n\
    \t\t\t\tdfs(x2, y2, k - 1, path + [@grid[x2][y2]])\n\t\t\tend\n\t\tend\n\tend\n\
    \tdfs(0, 0, k, [@grid[0][0]])\n\t@ans\nend\nputs \"minPath is:\"\nprint minPath([\
    \ [1,2,3], [4,5,6], [7,8,9]], 3)\nputs\nprint minPath([ [5,9,3], [4,1,6], [7,8,2]],\
    \ 1)\nputs", "  rows = grid.length\n  return if rows < 2\n  cols = grid[0].length\n\
    \  if rows != cols || k <= 0\n    return\n  end\n  dp = Array.new(rows) { Array.new(cols)\
    \ { Array.new } }\n  (0...rows).each do |r|\n    (0...cols).each do |c|\n    \
    \  dp[r][c] = []\n      (r+1...rows).each do |r2|\n        if grid[r2][c] < grid[r][c]\n\
    \          dp[r][c] << [r2, c]\n        end\n      end\n      (c+1...cols).each\
    \ do |c2|\n        if grid[r][c2] < grid[r][c]\n          dp[r][c] << [r, c2]\n\
    \        end\n      end\n    end\n  end\n  k -= 1\n  res = []\n  min = nil\n \
    \ (0...rows).each do |r|\n    (0...cols).each do |c|\n      cur = [grid[r][c]]\n\
    \      next if k == 0\n      dp[r][c].each do |rc|\n        after = minPath([[grid[r][c]]\
    \ + dp[rc[0]][rc[1]]], k)\n        if min == nil || after < min\n          min\
    \ = after\n          res = cur + after\n        end\n      end\n    end\n  end\n\
    \  res\nend", "    if grid.empty? || grid[0].empty? || k < 1\n        return []\n\
    \    end\n    min_path = []\n    pos = [0, 0]\n    dfs(grid, k, pos, [], min_path)\n\
    \    return min_path\nend", "  @grid = grid\n  @r = grid.size\n  @c = grid[0].size\n\
    \  @k = k\n  @res = []\n  @ans = []\n  move([0, 0], 1, [])\n  @ans\nend", "  \
    \  valToCoord = {}\n    grid.each_with_index do |row, r|\n        row.each_with_index\
    \ do |val, c|\n            valToCoord[val] = [r, c]\n        end\n    end\n  \
    \  path = []\n    best_path = []\n    k.times do |i|\n        best_path = path.dup\n\
    \        if path.empty?\n            path = grid.flatten\n        else\n     \
    \       path = next_path(path, grid, valToCoord)\n        end\n    end\n    best_path\n\
    end", "    # We can solve the problem using DFS and a memo.\n    # First, we need\
    \ to know all the neighbors of a cell. Let's define the function\n    # get_neighbors(i,\
    \ j, N) that returns the neighbors of the cell (i, j).\n    # Second, we will\
    \ traverse the grid using DFS, and keep a cache of visited cells\n    # to avoid\
    \ going to the same cell twice.\n    # Third, we will record the minimum path\
    \ found so far in min_path,\n    # and compare the current path with it to see\
    \ if we need to update min_path.\n    N = grid.length\n    # The function is_valid(i,\
    \ j) checks if the cell (i, j) is in the grid.\n    is_valid = ->(i, j) {i >=\
    \ 0 && i < N && j >= 0 && j < N}\n    # We traverse the grid using DFS.\n    #\
    \ In dfs(i, j, path, path_len) we pass the following arguments:\n    #   i, j:\
    \ The current cell (row, column).\n    #   path: An array representing the current\
    \ path.\n    #   path_len: The length of the current path.\n    # Then, for each\
    \ neighbor of the current cell (i, j), we will make a copy of\n    # the current\
    \ path, update it by appending the neighbor cell's value to it,\n    # and call\
    \ dfs(neighbor_row, neighbor_column, new_path, path_len + 1).\n    # If path_len\
    \ == k we will compare the current path with min_path, and update\n    # min_path\
    \ if it is lexicographically less than min_path.\n    # In order to avoid going\
    \ to the same cell twice, we will use a cache of visited\n    # cells, visited,\
    \ where the element visited[i][j] is True if we already went to\n    # the cell\
    \ (i, j), and False otherwise.\n    # Finally, the function get_neighbors(i, j,\
    \ N) returns the neighbors of the cell\n    # (i, j).\n    def dfs(i, j, path,\
    \ path_len)\n        @visited[i][j] = true\n        path.push", "\nend", "\tn\
    \ = grid.length\n\tl = 0\n\tr = n * n - 1\n\tmax = n * n\n\twhile l <= r\n\t\t\
    mid = (l + r) / 2\n\t\tif getPathCount(grid, k, mid) >= max\n\t\t\tr = mid - 1\n\
    \t\telse\n\t\t\tl = mid + 1\n\t\tend\n\tend\n\tgetPath(grid, k, r + 1)\nend",
  "\tn = grid.length\n\ta = [[]]\n\t(0...n).each do |i|\n\t\ta[0][i] = [[], grid[0][i]]\n\
    \tend\n\t(1...n).each do |i|\n\t\ta[i] = []\n\t\t(0...n).each do |j|\n\t\t\tx\
    \ = a[i-1][j][1] < a[i][j-1][1] ? a[i-1][j] : a[i][j-1]\n\t\t\tx[0] << x[1]\n\t\
    \t\tx[1] = grid[i][j]\n\t\t\ta[i][j] = x\n\t\tend\n\tend\n\ta[n-1][n-1][0]\nend",
  "\nend", "  row, col = grid.size, grid[0].size\n  queue = Queue.new\n  queue <<\
    \ { path: [grid[0][0]], i: 0, j: 0, l: 1 }\n  visited = Array.new(row) { Array.new(col,\
    \ false) }\n  visited[0][0] = true\n  min_path = []\n  min_sum = grid[0][0]\n\
    \  while !queue.empty?\n    cur = queue.pop\n    if cur[:l] == k\n      if cur[:path].reduce(:+)\
    \ < min_sum\n        min_path = cur[:path]\n        min_sum = cur[:path].reduce(:+)\n\
    \      end\n      next\n    end\n    [[-1, 0], [1, 0], [0, -1], [0, 1]].each do\
    \ |dir|\n      i, j = cur[:i] + dir[0], cur[:j] + dir[1]\n      next if i < 0\
    \ || i >= row || j < 0 || j >= col || visited[i][j]\n      queue << { path: cur[:path]\
    \ + [grid[i][j]], i: i, j: j, l: cur[:l] + 1 }\n      visited[i][j] = true\n \
    \   end\n  end\n  min_path\nend\ngrid = [ [1,2,3], [4,5,6], [7,8,9] ]\nputs \"\
    minPath(#{grid}, 3) = #{minPath(grid, 3)}\"\ngrid = [ [5,9,3], [4,1,6], [7,8,2]\
    \ ]\nputs \"minPath(#{grid}, 1) = #{minPath(grid, 1)}\"", "  @grid = grid\n  @k\
    \ = k\n  min = []\n  min_cost = Float::INFINITY\n  (0...@grid.size).each do |i|\n\
    \    (0...@grid.size).each do |j|\n      tmp = [@grid[i][j]]\n      dfs(i, j,\
    \ tmp, min_cost)\n    end\n  end\n  min\nend", "\tmax_elem = grid.size * grid.size\n\
    \tqueue = [[grid[0][0], 0, 0]]\n\tvisited = {}\n\tk -= 1\n\twhile !queue.empty?\n\
    \t\telem, x, y = queue.shift\n\t\tnext if visited[x.to_s + \",\" + y.to_s] ==\
    \ 1 || k == 0\n\t\tvisited[x.to_s + \",\" + y.to_s] = 1\n\t\treturn elem.to_s\
    \ if k == 0\n\t\t# Find all possible moves\n\t\tmoves = []\n\t\tx_arr = [x - 1,\
    \ x, x + 1]\n\t\ty_arr = [y - 1, y, y + 1]\n\t\tx_arr.each do |i|\n\t\t\ty_arr.each\
    \ do |j|\n\t\t\t\tif i != x || j != y\n\t\t\t\t\tmoves << [grid[i][j], i, j] if\
    \ i >= 0 && i < grid.size && j >= 0 && j < grid.size\n\t\t\t\tend\n\t\t\tend\n\
    \t\tend\n\t\tmoves.sort! { |x, y| x[0] <=> y[0] }\n\t\tmoves.each do |move|\n\t\
    \t\tqueue << move\n\t\tend\n\t\tk -= 1\n\tend\n\treturn max_elem.to_s\nend", " \
    \ n = grid.size\n  a = Array.new(n) { Array.new(n, -1) }\n  a[0][0] = 0\n  i,\
    \ j = 0, 0\n  q = [ [0, 0] ]\n  while !q.empty?\n    x, y = q.shift\n    if a[x][y]\
    \ + 1 == k\n      break\n    end\n    for i in x - 1...x + 2\n      for j in y\
    \ - 1...y + 2\n        if i >= 0 && i < n && j >= 0 && j < n && a[i][j] == -1\n\
    \          a[i][j] = a[x][y] + 1\n          q.push [i, j]\n        end\n     \
    \ end\n    end\n  end\n  p, q = i, j\n  ans = []\n  while k > 0\n    ans.push\
    \ grid[p][q]\n    for i in p - 1...p + 2\n      for j in q - 1...q + 2\n     \
    \   if i >= 0 && i < n && j >= 0 && j < n && a[i][j] == a[p][q] - 1\n        \
    \  p, q = i, j\n          break\n        end\n      end\n    end\n    k -= 1\n\
    \  end\n  ans\nend", "  return [] if grid.nil? || grid.empty? || grid[0].empty?\n\
    \  return [] if k == 0", "  #each cell can be visited 1 time only, so we start\
    \ at (0,0)\n  i = 0\n  j = 0\n  @path = []\n  @minPath = []\n  @minLen = Float::INFINITY\n\
    \  minPathHelper(grid, i, j, k)\n  return @minPath\nend", "  n = grid.size\n \
    \ dirs = [[0,1],[0,-1],[1,0],[-1,0]]\n  q = Queue.new()\n  q.push(0)\n  q.push(0)\n\
    \  q.push(0)\n  visited = {}\n  while !q.empty?\n    row = q.pop()\n    col =\
    \ q.pop()\n    level = q.pop()\n    if level == k\n      return [grid[row][col]]\n\
    \    end\n    visited[row * n + col] = true\n    for i in 0..3\n      r = row\
    \ + dirs[i][0]\n      c = col + dirs[i][1]\n      if 0 <= r && r < n && 0 <= c\
    \ && c < n && !visited[r * n + c]\n        visited[r * n + c] = true\n       \
    \ q.push(r)\n        q.push(c)\n        q.push(level + 1)\n      end\n    end\n\
    \  end\n  return []\nend", "  n = grid.size()\n  res = Array.new(k)\n  dfs(grid,\
    \ [0, 0], 0, n, k, res, [0, 1, 0, -1, 0])\n  return res\nend", "    m = grid.length\n\
    \    n = grid[0].length\n    if k >= (m * n)\n        return Array.new(k) {|i|\
    \ (i / m + 1) * (i % m + 1)}\n    end\n    if k == 0\n        return []\n    end\n\
    \    res = []\n    dist = {}\n    visit = []\n    q = Queue.new\n    (0...m).each\
    \ do |i|\n        (0...n).each do |j|\n            dist[i * n + j] = [m * n, []]\n\
    \            if i - 1 >= 0\n                dist[i * n + j][1] << ((i - 1) * n\
    \ + j)\n            end\n            if i + 1 < m\n                dist[i * n\
    \ + j][1] << ((i + 1) * n + j)\n            end\n            if j - 1 >= 0\n \
    \               dist[i * n + j][1] << (i * n + j - 1)\n            end\n     \
    \       if j + 1 < n\n                dist[i * n + j][1] << (i * n + j + 1)\n\
    \            end\n        end\n    end\n    (0...m).each do |i|\n        (0...n).each\
    \ do |j|\n            visit = []\n            dist[i * n + j][0] = 0\n       \
    \     q.clear\n            q << i * n + j\n            while !q.empty?\n     \
    \           u = q.pop\n                visit << u\n                dist[u][1].each\
    \ do |v|\n                    if !visit.include?(v)\n                        dist[v][0]\
    \ = dist[u][0] + 1\n                        q << v\n                    end\n\
    \                end\n            end\n        end\n    end\n    minD = m * n\n\
    \    minCell = -1\n    (0...m).each do |i|\n        (0...n).each do |j|\n    \
    \        if dist[i * n + j][0] == minD\n                minCell = i * n + j if\
    \ grid[i][j] < grid[minCell / n][minCell % n]\n            end\n            if\
    \ dist[i * n + j", "  n = grid.size\n  m = grid[0].size\n  dp = Array.new(n) {\
    \ Array.new(m) { Array.new(k+1, []) } }\n  (0...n).each do |i|\n    (0...m).each\
    \ do |j|\n      (0..k).each do |l|\n        dp[i][j][l] = [grid[i][j]]\n     \
    \   if i-1 >= 0\n          new_seq = dp[i-1][j][l-1] + [grid[i][j]]\n        \
    \  dp[i][j][l] = new_seq if new_seq < dp[i][j][l]\n        end\n        if j-1\
    \ >= 0\n          new_seq = dp[i][j-1][l-1] + [grid[i][j]]\n          dp[i][j][l]\
    \ = new_seq if new_seq < dp[i][j][l]\n        end\n      end\n    end\n  end\n\
    \  dp[n-1][m-1][k]\nend", "    #Iterate through grid, if the grid is 3x3, there\
    \ are 9 possible\n    #starting points. \n    #We want to create an array of size\
    \ k which represents our path. \n    #For each starting point, and every possible\
    \ path, we want to find the\n    #lexicographically lowest. \n    #For example,\
    \ for a 3x3 grid, starting at grid[0][0], the paths can look like\n    #[0,0]\
    \ -> [0,1] -> [0,2] -> [1,2] -> [2,2] -> [2,1] \n    #[0,0] -> [1,0] -> [2,0]\
    \ -> [2,1] -> [2,2] -> [1,2]\n    #[0,0] -> [1,0] -> [1,1] -> [1,2] -> [2,2] ->\
    \ [2,1]\n    #[0,0] -> [1,0] -> [1,1] -> [2,1] -> [2,2] -> [2,0]\n    #[0,0] ->\
    \ [1,0] -> [2,0] -> [2,1] -> [1,1] -> [1,2]\n    #[0,0] -> [1,0] -> [2,0] -> [2,1]\
    \ -> [2,2] -> [1,2]\n    #[0,0] -> [1,0] -> [2,0] -> [2,1] -> [1,1] -> [0,1]\n\
    \    #[0,0] -> [1,0] -> [2,0] -> [2,1] -> [2,2] -> [1,2]\n    #[0,0] -> [1,0]\
    \ -> [2,0] -> [2,1] -> [1,1] -> [0,1]\n    #[0,0] -> [1,0] -> [2,0] -> [2,1] ->\
    \ [2,2] -> [1,2]\n    #If we use the same logic for every starting point, we should\
    \ get the same result. \n    #Create a hash to store our paths.", "\nend", " \
    \   n = grid.length\n    res = []\n    (0...n).each do |i|\n        (0...n).each\
    \ do |j|\n            next if grid[i][j] > k\n            tmp = [grid[i][j]]\n\
    \            dfs(grid, k, [i, j], tmp, res)\n        end\n    end\n    res\nend",
  "  return [] if grid.nil? or grid.empty?\n  return [] if k < 1\n  m, n = grid.size,\
    \ grid[0].size\n  return [grid[0][0]] if k == 1\n  return [grid[0][0], grid[0][1]]\
    \ if k == 2 and n > 1\n  return [grid[0][0], grid[1][0]] if k == 2 and m > 1\n\
    \  # For each cell, we need to find the minimum path (k - 1) in the grid which\n\
    \  # ends at that cell. \n  # We can then choose the minimum of all these minimum\
    \ paths to find the\n  # minimum path of length k in the grid.\n  # Let dp[i][j][l]\
    \ be the minimum path of length l in the grid which ends at\n  # cell (i, j).\
    \ For example, dp[0][0][3] will be the minimum path of length\n  # 3 which ends\
    \ at cell (0, 0).\n  # We can use dynamic programming to find this values, since\
    \ the result for\n  # dp[i][j][l] depends on the results of dp[i-1][j][l-1], dp[i+1][j][l-1],\n\
    \  # dp[i][j-1][l-1] and dp[i][j+1][l-1].\n  # Then, to find the result for dp[i][j][l],\
    \ we can just try every possible\n  # path of length l which ends at cell (i,\
    \ j), and choose the minimum one.\n  # Therefore, dp[i][j][l] = min(dp[i-1][j][l-1],\
    \ dp[i+1][j][l-1], dp[i][j-1][l-1], dp[i][j+1][l-1])\n  # The base cases are dp[i][j][1]\
    \ = grid[i][j] for all the cells (i, j).\n  # We should also take care of the\
    \ cells on the edges of the grid, because\n  # they may not have all the 4 neighbors.\n\
    \  # Time complexity is O(m * n * k) and space complexity", "\thelper(grid, k,\
    \ 0, 0, [])\nend", "  n = grid.size\n  res = []\n  (0...n).each do |i|\n    (0...n).each\
    \ do |j|\n      if grid[i][j] == 1\n        res = [1] + dfs(grid, i, j, 1, k)\n\
    \        if res.size == k\n          return res\n        end\n      end\n    end\n\
    \  end\n  res\nend", "    # Assuming: grid is not nil, or empty, or empty grid\n\
    \    #           k is a positive integer and <= n * n\n    #           grid only\
    \ contains number between 1 and n * n, and each number\n    #           appears\
    \ only once\n    n = grid.length\n    return nil if n == 0\n    # given (i, j),\
    \ i, j is the position of the number\n    # find the minimum path\n    # @param\
    \ i: Integer, the i of the number\n    # @param j: Integer, the j of the number\n\
    \    # @param min_lst: Array of Integer, the minimum list of numbers from starting\
    \ from (i, j)\n    # @param k: Integer, the length of the path\n    def bfs(i,\
    \ j, min_lst, k)\n        # DONE: Write your code here\n        lst = [min_lst]\n\
    \        dq = [[i, j]]\n        visited = {}\n        count = 1\n        while\
    \ !dq.empty?\n            size = dq.length\n            (0...size).each do |l|\n\
    \                pos = dq.shift\n                if visited[pos]\n           \
    \         next\n                end\n                visited[pos] = true\n   \
    \             next if count == k\n                next_lst = lst.shift\n     \
    \           [[-1, 0], [1, 0], [0, -1], [0, 1]].each do |dir|\n               \
    \     next_i = pos[0] + dir[0]\n                    next_j = pos[1] + dir[1]\n\
    \                    next if next_i < 0 || next_i >= @n || next_j < 0 || next_j\
    \ >= @n\n                    next_lst_tmp = next_lst.clone\n                 \
    \   next_lst_tmp << @grid[next_i][next_j]\n                    dq << [next_i,\
    \ next_j]\n                    lst << next_lst_tmp\n                end\n    \
    \        end\n            count += 1\n        end\n        lst.min\n    end\n\
    \    @grid = grid\n    @n = n\n    min_lst = []\n    min_lst << grid[0][0]\n \
    \   (0...n).each do |", "  r, c = grid.size, grid[0].size\n  return Array.new(k,\
    \ -1) if r * c < k\n  # min_path[i][j] = [cost, path] where cost is min path of\
    \ length k from (i, j)\n  # and path is ordered list of values of cells on the\
    \ path\n  min_path = Array.new(r) { Array.new(c) {[k + 1, []]} }\n  (0...r).each\
    \ do |i|\n    (0...c).each do |j|\n      if i == 0 && j == 0\n        min_path[i][j]\
    \ = [1, [grid[i][j]]]\n      else\n        min_path[i][j] = [k + 1, []]\n    \
    \    prev_paths = []\n        prev_paths << min_path[i - 1][j] if i > 0\n    \
    \    prev_paths << min_path[i][j - 1] if j > 0\n        prev_paths.each do |cost,\
    \ path|\n          tmp_path = path + [grid[i][j]]\n          next if tmp_path.size\
    \ > k\n          min_path[i][j] = [cost + 1, tmp_path] if tmp_path < min_path[i][j][1]\n\
    \        end\n      end\n    end\n  end\n  min_path[r - 1][c - 1][1]\nend\ngrid\
    \ = [ [1,2,3], [4,5,6], [7,8,9] ]\nk = 3\np minPath(grid, k)\ngrid = [ [5,9,3],\
    \ [4,1,6], [7,8,2] ]\nk = 1\np minPath(grid, k)", "    @grid = grid\n    @n =\
    \ grid.length\n    @k = k\n    @res = [1.0/0] * (k + 1)\n    @res[0] = 0\n   \
    \ visited = []\n    @n.times do |i|\n        @n.times do |j|\n            visited[i]\
    \ ||= []\n            visited[i][j] = false\n        end\n    end\n    minPathRecurse(0,\
    \ 0, 0, 0, visited)\n    @res\nend", "  if !grid || grid.length == 0 || grid[0].length\
    \ == 0 || k < 1\n    return nil\n  end\n  min = nil\n  m = grid.length\n  n =\
    \ grid[0].length\n  visited = Array.new(m){Array.new(n,false)}\n  helper(grid,\
    \ visited, 0, 0, [], k, min)\n  return min\nend", "    n = grid.length\n    dp\
    \ = Array.new(n) { Array.new(n) { Array.new(k + 1, []) } }\n    (0...n).each do\
    \ |i|\n        (0...n).each do |j|\n            dp[i][j][1] = [grid[i][j]]\n \
    \       end\n    end\n    (0...n).each do |i|\n        (0...n).each do |j|\n \
    \           (2..k).each do |t|\n                mn = []\n                if i\
    \ > 0 && dp[i - 1][j][t - 1].length > 0\n                    mn = mn.length ==\
    \ 0 ? dp[i - 1][j][t - 1] :\n                        (mn < dp[i - 1][j][t - 1]\
    \ ? mn : dp[i - 1][j][t - 1])\n                end\n                if i < n -\
    \ 1 && dp[i + 1][j][t - 1].length > 0\n                    mn = mn.length == 0\
    \ ? dp[i + 1][j][t - 1] :\n                        (mn < dp[i + 1][j][t - 1] ?\
    \ mn : dp[i + 1][j][t - 1])\n                end\n                if j > 0 &&\
    \ dp[i][j - 1][t - 1].length > 0\n                    mn = mn.length == 0 ? dp[i][j\
    \ - 1][t - 1] :\n                        (mn < dp[i][j - 1][t - 1] ? mn : dp[i][j\
    \ - 1][t - 1])\n                end\n                if j < n - 1 && dp[i][j +\
    \ 1][t - 1].length > 0\n                    mn = mn.length == 0 ? dp[i][j + 1][t\
    \ - 1] :\n                        (mn < dp[i][j + 1][t - 1] ? mn : dp[i][j + 1][t\
    \ - 1])\n                end\n                dp[i][j][t] = mn.clone\n       \
    \         dp[i][j][t] << grid[i", "\tif grid.nil? or grid.empty? or grid[0].nil?\
    \ or grid[0].empty? or k < 1\n\t\treturn\n\tend\n\tdistances = [[], [], []]\n\t\
    for i in 0...grid.length\n\t\tfor j in 0...grid[0].length\n\t\t\tdistances[i]\
    \ << grid[i][j]\n\t\tend\n\tend\n\tfor i in 0...distances.length\n\t\tfor j in\
    \ 0...distances[0].length\n\t\t\tif i > 0\n\t\t\t\tdistances[i][j] += distances[i\
    \ - 1][j]\n\t\t\tend\n\t\t\tif j > 0\n\t\t\t\tdistances[i][j] += distances[i][j\
    \ - 1]\n\t\t\tend\n\t\t\tif i > 0 and j > 0\n\t\t\t\tdistances[i][j] -= distances[i\
    \ - 1][j - 1]\n\t\t\tend\n\t\tend\n\tend\n\tlen = grid.length\n\tmax = distances[len\
    \ - 1][len - 1]\n\tcosts = Array.new(len) { Array.new(len, 0) }\n\tpaths = Array.new(len)\
    \ { Array.new(len, []) }\n\tcosts[0][0] = max - grid[0][0]\n\tpaths[0][0] = [grid[0][0]]\n\
    \tfor i in 0...len\n\t\tfor j in 0...len\n\t\t\tnext if i == 0 and j == 0\n\t\t\
    \tcost = max\n\t\t\tpath = []\n\t\t\tif i > 0\n\t\t\t\tcost = costs[i - 1][j]\n\
    \t\t\t\tpath = paths[i - 1][j].clone\n\t\t\tend\n\t\t\tif j > 0 and costs[i][j\
    \ - 1] < cost\n\t\t\t\tcost = costs[i][j - 1]\n\t\t\t\tpath = paths[i][j - 1].clone\n\
    \t\t\tend\n\t\t\tif j > 0 and i > 0 and costs[i - 1][j - 1] + grid[i][j] < cost\n\
    \t\t\t\t", "\tqueue = []\n\tqueue << [0, 0, 0, grid[0][0], [[0, 0]]]\n\tvisited\
    \ = {}\n\twhile(!queue.empty?)\n\t\trow, col, length, sum, path = queue.shift\n\
    \t\tif length == k\n\t\t\tif (sum < min_sum)\n\t\t\t\tmin_sum = sum\n\t\t\t\t\
    min_path = path\n\t\t\tend\n\t\t\tnext\n\t\tend\n\t\t[[row - 1, col], [row + 1,\
    \ col], [row, col - 1], [row, col + 1]].each do |new_row, new_col|\n\t\t\tnext\
    \ if row < 0 || row >= grid.length || col < 0 || col >= grid[0].length\n\t\t\t\
    next if visited.key?([new_row, new_col]) && visited[[new_row, new_col]] <= sum\
    \ + grid[new_row][new_col]\n\t\t\tnew_path = path.clone\n\t\t\tnew_path << [new_row,\
    \ new_col]\n\t\t\tqueue << [new_row, new_col, length + 1, sum + grid[new_row][new_col],\
    \ new_path]\n\t\t\tvisited[[new_row, new_col]] = sum + grid[new_row][new_col]\n\
    \t\tend\n\tend\n\tmin_path.map { |row, col| grid[row][col] }\nend", "    n = grid.length()\n\
    \    if k == 1\n        return [grid[0][0]]\n    end\n    edges = []\n    for\
    \ i in 0..n-1\n        for j in 0..n-1\n            x, y = grid[i][j], grid[(i+1)%n][j]\n\
    \            edges.push([x, y])\n            edges.push([y, x])\n            x,\
    \ y = grid[i][j], grid[i][(j+1)%n]\n            edges.push([x, y])\n         \
    \   edges.push([y, x])\n        end\n    end\n    # First, find a shortest path\
    \ of length k from each cell to a cell with\n    # smaller value.\n    @dist =\
    \ {}\n    for i in 0..n-1\n        for j in 0..n-1\n            u = grid[i][j]\n\
    \            next if @dist.include?(u)\n            # Dijkstra's Algorithm\n \
    \           @dist[u] = [u]\n            priority = {}\n            for e in edges\n\
    \                x, y = e[0], e[1]\n                if x == u\n              \
    \      if !priority.include?(y) || priority[y] > 1\n                        priority[y]\
    \ = 1\n                    end\n                end\n            end\n       \
    \     while !priority.empty?\n                q = priority.min_by{|k, v| v}\n\
    \                priority.delete(q[0])\n                if q[0] < u\n        \
    \            @dist[u] = @dist[u] + [q[0]]\n                    break\n       \
    \         end\n                for e in edges\n                    x, y = e[0],\
    \ e[1]\n                    if x == q[0]\n                        if !priority.include?(y)\
    \ || priority[y] > q[1] + 1\n                            priority[y] = q[1] +\
    \ 1\n                        end\n                    end\n                end\n\
    \            end\n        end\n    end\n    # Now, use dp to find a shortest path\
    \ of length k.\n    dp = {}\n    for i in 0..n-1\n        for j in 0..n-1\n  \
    \          u = grid[i][j]\n", "  num_rows = grid.length\n  raise Exception, 'invalid\
    \ grid' if !num_rows || num_rows == 0\n  num_cols = grid[0].length\n  raise Exception,\
    \ 'invalid grid' if !num_cols || num_cols == 0\n  raise Exception, 'invalid grid'\
    \ if num_rows != num_cols\n  raise Exception, 'invalid k' if !k || k <= 0\n  return\
    \ [grid[0][0]] if k == 1\n  memo = {}\n  (0...num_rows).each do |i|\n    (0...num_cols).each\
    \ do |j|\n      key = \"#{i},#{j}\"\n      memo[key] = [grid[i][j]]\n      next\
    \ if i == 0 && j == 0\n      prev_cells = []\n      prev_cells << \"#{i - 1},#{j}\"\
    \ if i > 0\n      prev_cells << \"#{i},#{j - 1}\" if j > 0\n      prev_cells <<\
    \ \"#{i - 1},#{j - 1}\" if i > 0 && j > 0\n      best_cell = nil\n      best_cell_lst\
    \ = nil\n      prev_cells.each do |cell|\n        lst = memo[cell]\n        if\
    \ !best_cell || lst < best_cell_lst\n          best_cell = cell\n          best_cell_lst\
    \ = lst\n        end\n      end\n      memo[key] += best_cell_lst\n    end\n \
    \ end\n  last_cell = \"#{num_rows - 1},#{num_cols - 1}\"\n  memo[last_cell][0...k]\n\
    end", "  max = grid.size\n  hash = {}\n  for i in (0..max - 1)\n    for j in (0..max\
    \ - 1)\n      key = encodeKey(i, j)\n      hash[key] = grid[i][j]\n    end\n \
    \ end\n  queue = [[0, 0, hash[encodeKey(0, 0)]]]\n  seen = {}\n  while !queue.empty?\n\
    \    cur = queue.shift\n    x = cur[0]\n    y = cur[1]\n    value = cur[2]\n \
    \   key = encodeKey(x, y)\n    if seen[key]\n      next\n    end\n    seen[key]\
    \ = true\n    if x == max - 1 && y == max - 1\n      if value.size == k\n    \
    \    return value\n      end\n      next\n    end\n    if x > 0\n      queue.push([x\
    \ - 1, y, value + [hash[encodeKey(x - 1, y)]]])\n    end\n    if x < max - 1\n\
    \      queue.push([x + 1, y, value + [hash[encodeKey(x + 1, y)]]])\n    end\n\
    \    if y > 0\n      queue.push([x, y - 1, value + [hash[encodeKey(x, y - 1)]]])\n\
    \    end\n    if y < max - 1\n      queue.push([x, y + 1, value + [hash[encodeKey(x,\
    \ y + 1)]]])\n    end\n  end\n  return -1\nend", "\nend", "    n = grid.length\n\
    \    q = [[0, 0, grid[0][0]]]\n    vis = [[false] * n] * n\n    vis[0][0] = true\n\
    \    ans = []\n    min_val = 10**9\n    while !q.empty?\n        cur = q.shift\n\
    \        i, j, sum = cur[0], cur[1], cur[2]\n        if (i == n - 1 && j == n\
    \ - 1)\n            if (sum < min_val)\n                min_val = sum\n      \
    \          ans = []\n            end\n            if (sum == min_val)\n      \
    \          ans.push(grid[i][j])\n            end\n        end\n        [[0, 1],\
    \ [0, -1], [1, 0], [-1, 0]].each do |d|\n            ni, nj = i + d[0], j + d[1]\n\
    \            if (ni >= 0 && ni < n && nj >= 0 && nj < n && !vis[ni][nj])\n   \
    \             q.push([ni, nj, sum + grid[ni][nj]])\n                vis[ni][nj]\
    \ = true\n            end\n        end\n    end\n    return ans\nend", "\nend",
  "  queue = Queue.new\n  queue << State.new(grid, 0, [], [], [], [], k)\n  while\
    \ !queue.empty?\n    state = queue.pop\n    if state.curr_i == k\n      return\
    \ state.curr_path\n    end\n    [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dx,\
    \ dy|\n      new_i = state.curr_i + 1\n      new_row = state.curr_row + dx\n \
    \     new_col = state.curr_col + dy\n      next if new_row < 0 || new_row >= grid.size\
    \ || new_col < 0 || new_col >= grid.size\n      next if state.visited[new_row][new_col]\n\
    \      next if state.curr_i == 0 && state.rows[new_row][new_col] != new_i\n  \
    \    next if state.curr_i > 0 && state.prev_rows[new_row][new_col] != new_i -\
    \ 1\n      new_visited = Marshal.load(Marshal.dump(state.visited))\n      new_visited[new_row][new_col]\
    \ = true\n      new_prev_rows = Marshal.load(Marshal.dump(state.prev_rows))\n\
    \      new_prev_rows[new_row][new_col] = new_i\n      new_rows = Marshal.load(Marshal.dump(state.rows))\n\
    \      new_rows[new_row][new_col] = new_i + 1\n      new_path = Marshal.load(Marshal.dump(state.curr_path))\n\
    \      new_path << grid[new_row][new_col]\n      queue << State.new(grid, new_i,\
    \ new_row, new_col, new_visited, new_prev_rows, new_rows, new_path, k)\n    end\n\
    \  end\nend", "    minList = grid[0][0].to_s\n    row = 0\n    col = 0\n    counter\
    \ = 0\n    grid[row][col] = \"\"\n    while (counter < k)\n        currVal = grid[row][col]\n\
    \        #puts currVal\n        #search for minimum value in neighbor cells\n\
    \        leftVal = (col == 0) ? 99999 : grid[row][col - 1]\n        rightVal =\
    \ (col == grid.length - 1) ? 99999 : grid[row][col + 1]\n        topVal = (row\
    \ == 0) ? 99999 : grid[row - 1][col]\n        bottomVal = (row == grid.length\
    \ - 1) ? 99999 : grid[row + 1][col]\n        minVal = [leftVal, rightVal, topVal,\
    \ bottomVal].min\n        #puts \"LeftVal: #{leftVal}, RightVal: #{rightVal},\
    \ TopVal: #{topVal}, BottomVal: #{bottomVal}, MinVal: #{minVal}\"\n        #fill\
    \ up minList\n        minList << minVal.to_s\n        #Mark the cell as visited\n\
    \        if leftVal == minVal\n            col -= 1\n        elsif rightVal ==\
    \ minVal\n            col += 1\n        elsif topVal == minVal\n            row\
    \ -= 1\n        elsif bottomVal == minVal\n            row += 1\n        end\n\
    \        grid[row][col] = \"\"\n        counter += 1\n    end\n    minList.split(\"\
    \").map(&:to_i)\nend", "  path = []\n  rLen = grid.length\n  cLen = grid[0].length\n\
    \  i = j = 0\n  (1..k).each do |m|\n    path << grid[i][j]\n    nxtI = i + 1\n\
    \    nxtJ = j + 1\n    if nxtI < rLen && nxtJ < cLen\n      if grid[nxtI][j] <\
    \ grid[i][nxtJ]\n        i = nxtI\n      else\n        j = nxtJ\n      end\n \
    \   elsif nxtI < rLen\n      i = nxtI\n    elsif nxtJ < cLen\n      j = nxtJ\n\
    \    end\n  end\n  path\nend", "    @grid = grid\n    @rows = grid.length\n  \
    \  @cols = grid[0].length\n    @k = k\n    @min = 2**31\n    @min_path = []\n\
    \    @visited = Array.new(@rows) { Array.new(@cols, false) }\n    @grid.each_with_index\
    \ do |row, row_index|\n        row.each_with_index do |num, col_index|\n     \
    \       @row = row_index\n            @col = col_index\n            dfs(num, [num],\
    \ 1)\n        end\n    end\n    return @min_path\nend", "  N = grid.size\n  d\
    \ = [[-1] * N] * N\n  q = [[0, 0, 0]]\n  d[0][0] = 0\n  while !q.empty?\n    x,\
    \ y, s = q.shift\n    if [x, y] == [N - 1, N - 1] && s == k\n      return dp(x,\
    \ y, grid, d)\n    end\n    if s < k\n      [[x + 1, y], [x - 1, y], [x, y + 1],\
    \ [x, y - 1]].each do |i, j|\n        if i >= 0 && i < N && j >= 0 && j < N &&\
    \ d[i][j] == -1\n          d[i][j] = s + 1\n          q.push([i, j, s + 1])\n\
    \        end\n      end\n    end\n  end\n  []\nend", "  cost = Array.new(grid.size)\
    \ { Array.new(grid.size, Float::INFINITY) }\n  cost[0][0] = grid[0][0]\n  queue\
    \ = PriorityQueue.new\n  queue.push([0, 0], 0)\n  while !queue.empty?\n    x,\
    \ y = queue.pop\n    next if cost[x][y] >= k\n    next if x < 0 || x >= grid.size\
    \ || y < 0 || y >= grid.size\n    neighbors = [[x + 1, y], [x - 1, y], [x, y +\
    \ 1], [x, y - 1]]\n    neighbors.each do |x1, y1|\n      c = cost[x][y] + grid[x1][y1]\n\
    \      if c < cost[x1][y1]\n        cost[x1][y1] = c\n        queue.push([x1,\
    \ y1], -c)\n      end\n    end\n  end\n  # puts cost.inspect\n  return -1 if cost[grid.size\
    \ - 1][grid.size - 1] >= k\n  path = []\n  x, y = grid.size - 1, grid.size - 1\n\
    \  while x != 0 || y != 0\n    path << grid[x][y]\n    neighbors = [[x + 1, y],\
    \ [x - 1, y], [x, y + 1], [x, y - 1]]\n    x, y = nil, nil\n    neighbors.each\
    \ do |x1, y1|\n      if cost[x1][y1] < cost[x][y]\n        x, y = x1, y1\n   \
    \   end\n    end\n  end\n  path << grid[0][0]\n  path.reverse\nend\ngrid = [ [1,2,3],\
    \ [4,5,6], [7,8,9] ]\np minPath(grid, 3)\ngrid = [ [5,9,3], [4,1,6], [7,8,2] ]\n\
    p minPath(grid, 1)\ngrid = [ [1,4,6,7], [9,4,5,8], [2,6,7,2], [1", "  # 1. Get\
    \ the path\n  # 2. Compare it with others\n  # 3. Sort\n  minPath = grid.first.first\n\
    \  minPath\nend", "  m, n = grid.size, grid[0].size\n  return [] if k <= 0 ||\
    \ k > m * n\n  return grid.flatten if k == m * n\n  grid.each { |row| row.sort!\
    \ }\n  grid.sort!\n  minPath = []\n  minSum = (1 << 31) - 1\n  for i in 0...m\n\
    \    for j in 0...n\n      path = [grid[i][j]]\n      sum = grid[i][j]\n     \
    \ next if sum > minSum\n      for l in 1...k\n        y, x = i, j\n        if\
    \ i - 1 >= 0 && grid[i - 1][j] < grid[i][j]\n          y = i - 1\n        elsif\
    \ i + 1 < m && grid[i + 1][j] < grid[i][j]\n          y = i + 1\n        elsif\
    \ j - 1 >= 0 && grid[i][j - 1] < grid[i][j]\n          x = j - 1\n        elsif\
    \ j + 1 < n && grid[i][j + 1] < grid[i][j]\n          x = j + 1\n        else\n\
    \          break\n        end\n        path << grid[y][x]\n        sum += grid[y][x]\n\
    \        break if sum > minSum\n        i, j = y, x\n      end\n      if path.size\
    \ == k && sum < minSum\n        minPath = path\n        minSum = sum\n      end\n\
    \    end\n  end\n  minPath\nend\ngrid = [ [1,2,3], [4,5,6], [7,8,9] ]\nk = 3\n\
    puts minPath(grid, k)\ngrid = [ [5,9,3], [4,1,6], [7,8,2] ]\nk = 1\nputs minPath(grid,\
    \ k)", "    dirs = [[0,1],[0,-1],[1,0],[-1,0]]\n    n = grid.length\n    min_path\
    \ = []\n    min_sum = n * n * n * n * n * n * n * n * n * n * n * n * n * n *\
    \ n * n\n    queue = [[0,0,0,[grid[0][0]]]]\n    while queue.any?\n        v,x,y,path\
    \ = queue.shift\n        if v == k\n            if path.sum < min_sum\n      \
    \          min_sum = path.sum\n                min_path = path\n            end\n\
    \        else\n            dirs.each do |di,dj|\n                i,j = x + di,\
    \ y + dj\n                if i.between?(0,n-1) && j.between?(0,n-1)\n        \
    \            queue << [v+1,i,j,path + [grid[i][j]]]\n                end\n   \
    \         end\n        end\n    end\n    min_path\nend", "  def minPathHelper(grid,\
    \ k, i, j, memo)\n    return [] if k <= 0\n    return memo[[i, j]] if memo.has_key?([i,\
    \ j])\n    ans = []\n    if i > 0\n      ans << minPathHelper(grid, k - 1, i -\
    \ 1, j, memo)\n    end\n    if i < grid.length - 1\n      ans << minPathHelper(grid,\
    \ k - 1, i + 1, j, memo)\n    end\n    if j > 0\n      ans << minPathHelper(grid,\
    \ k - 1, i, j - 1, memo)\n    end\n    if j < grid[0].length - 1\n      ans <<\
    \ minPathHelper(grid, k - 1, i, j + 1, memo)\n    end\n    if ans.empty?\n   \
    \   ans = [[grid[i][j]]]\n    end\n    ans.min! { |a, b|\n      # puts a.inspect\n\
    \      # puts b.inspect\n      a.first <=> b.first\n    }\n    ans[0].unshift(grid[i][j])\n\
    \    memo[[i, j]] = ans[0]\n    ans[0]\n  end\n  minPathHelper(grid, k, 0, 0,\
    \ {})\nend", "    @m = grid.length\n    @n = grid[0].length\n    @path = Array.new(@m){Array.new(@n)}\n\
    \    @path_len = @m * @n + 1\n    @result = []\n    @k = k\n    @grid = grid\n\
    \    dfs(0, 0, 0, [])\n    @result\nend", "  rows = grid.length\n  cols = grid[0].length\n\
    \  (0...rows).each do |row|\n    (0...cols).each do |col|\n      dfs(grid, row,\
    \ col, k)\n    end\n  end\n  res\nend", "\t# Time Complexity: O(N^2*k)\n\t# Space\
    \ Complexity: O(N^2*k)\n\tn = grid.length\n\tdp = Array.new(n) { Array.new(n)\
    \ { Array.new(k+1, []) } }\n\t(0...n).each do |i|\n\t\t(0...n).each do |j|\n\t\
    \t\tdp[i][j][1] = [grid[i][j]]\n\t\tend\n\tend\n\t(2..k).each do |path_len|\n\t\
    \t(0...n).each do |i|\n\t\t\t(0...n).each do |j|\n\t\t\t\tneighbors = []\n\t\t\
    \t\tneighbors << dp[i-1][j][path_len-1] if i > 0\n\t\t\t\tneighbors << dp[i+1][j][path_len-1]\
    \ if i < n-1\n\t\t\t\tneighbors << dp[i][j-1][path_len-1] if j > 0\n\t\t\t\tneighbors\
    \ << dp[i][j+1][path_len-1] if j < n-1\n\t\t\t\tdp[i][j][path_len] = [grid[i][j]]\
    \ + neighbors.min_by { |neighbor| neighbor + [grid[i][j]] }\n\t\t\tend\n\t\tend\n\
    \tend\n\tdp[0][0][k]\nend", "  @grid = grid\n  @n = grid.size\n  @k = k\n  @best\
    \ = nil\n  @visited = Array.new(@n) { Array.new(@n, false) }\n  @cells = []\n\
    \  @n.times do |i|\n    @n.times do |j|\n      @cells << [i, j]\n    end\n  end\n\
    \  dfs(0, 0, [], 0)\n  @best\nend", "\nend", "    n = grid.length\n    dirs =\
    \ [[0, 1], [0, -1], [1, 0], [-1, 0]]\n    visited = Array.new(n) { Array.new(n,\
    \ false) }\n    queue = [[[], grid[0][0], 0, 0]]\n    while(!queue.empty?)\n \
    \       temp = queue.shift\n        if temp[2] == k - 1\n            return temp[0]\
    \ + [temp[1]]\n        end\n        x, y = temp[3], temp[4]\n        visited[x][y]\
    \ = true\n        dirs.each do |dir|\n            nx, ny = x + dir[0], y + dir[1]\n\
    \            if nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny]\n \
    \               queue.push([temp[0] + [temp[1]], grid[nx][ny], temp[2] + 1, nx,\
    \ ny])\n            end\n        end\n    end\nend", "    if k < grid.length\n\
    \        return []\n    end\n    if k == grid.length\n        return grid.flatten.sort\n\
    \    end\n    n = grid.length\n    map = Array.new(n) { Array.new(n, 0) }\n  \
    \  queue = Queue.new\n    visited = Array.new(n) { Array.new(n, false) }\n   \
    \ queue.push([0, 0, 1, [grid[0][0]]])\n    visited[0][0] = true\n    until queue.empty?\n\
    \        x, y, m, path = queue.pop\n        if m == k\n            return path\n\
    \        end\n        [[x, y + 1], [x, y - 1], [x + 1, y], [x - 1, y]].each do\
    \ |px, py|\n            if px >= 0 && px < n && py >= 0 && py < n && !visited[px][py]\n\
    \                visited[px][py] = true\n                temp = path.dup\n   \
    \             temp.push(grid[px][py])\n                queue.push([px, py, m +\
    \ 1, temp])\n            end\n        end\n    end\n    []\nend", "  rows = grid.length\n\
    \  cols = grid[0].length\n  total = rows * cols\n  return [1] if k == 1\n  visited\
    \ = {\n    [0, 0] => true\n  }\n  queue = Queue.new\n  queue.push([0, 0, [1]])\n\
    \  while !queue.empty?\n    row, col, path = queue.pop\n    return path if path.length\
    \ == k\n    [[1, 0], [-1, 0], [0, 1], [0, -1]].each do |dr, dc|\n      nr = row\
    \ + dr\n      nc = col + dc\n      next if nr < 0 || nr >= rows || nc < 0 || nc\
    \ >= cols\n      next if visited[[nr, nc]]\n      visited[[nr, nc]] = true\n \
    \     next_path = path.dup << grid[nr][nc]\n      queue.push([nr, nc, next_path])\n\
    \    end\n  end\nend\nputs minPath([ [1,2,3], [4,5,6], [7,8,9]], 3)", "  # use\
    \ dynamic programming to solve this problem\n  # let dp[i][j][n] be the lexicographically\
    \ minimum path of length n from grid[i][j]\n  # also use dp[i][j][n] = -1 as a\
    \ flag for state invalid\n  dp = []\n  for i in 0..grid.length-1\n    dp[i] =\
    \ []\n    for j in 0..grid[0].length-1\n      dp[i][j] = []\n      for n in 0..k-1\n\
    \        dp[i][j][n] = -1\n      end\n    end\n  end\n  # since grid[i][j] (1\
    \ <= i, j <= N) is guaranteed to be in the range [1, N * N]\n  # and all values\
    \ in the range [1, N * N] appear exactly once on the cells of the grid\n  # we\
    \ could use a hashtable to keep track of values seen\n  seen = {}\n  for i in\
    \ 0..grid.length-1\n    for j in 0..grid[0].length-1\n      if seen[grid[i][j]]\n\
    \        return [-1]\n      end\n      seen[grid[i][j]] = true\n    end\n  end\n\
    \  # now we get down to business\n  # firstly, let's fill out the first row\n\
    \  # for any cell at the first row, dp[i][0][n] (0 <= i <= N-1) is the value at\
    \ that cell if n == 0\n  # if n > 0, we can only go right, thus dp[i][0][n] is\
    \ the minimum of dp[i][0][n-1] and dp[i+1][0][n-1] (0 <= i <= N-2)\n  # then we\
    \ compare the min of dp[i][0][n-1] and dp[i+1][0][n-1] with the value at grid[i+1][0]\n\
    \  # we can use a helper function here\n  for i in 0..grid.length-1\n    dp[i][0][0]\
    \ = grid[i][0]\n  end\n  for n in 1..k-1", "\nend", "  n = grid.size\n  m = grid[0].size\n\
    \  dist = Array.new(n) { Array.new(m, -1) }\n  min_path = Array.new(k, -1)\n \
    \ min_val = Float::INFINITY\n  queue = Array.new(n) { Array.new(m, -1) }\n  q_sz\
    \ = 0\n  0.upto(n - 1) do |i|\n    0.upto(m - 1) do |j|\n      dist[i][j] = 0\n\
    \      queue[q_sz][0] = i\n      queue[q_sz][1] = j\n      q_sz += 1\n    end\n\
    \  end\n  0.upto(q_sz - 1) do |qi|\n    i = queue[qi][0]\n    j = queue[qi][1]\n\
    \    if dist[i][j] < k\n      di = -1\n      while di <= 1\n        dj = -1\n\
    \        while dj <= 1\n          if di != 0 || dj != 0\n            if i + di\
    \ >= 0 && i + di < n && j + dj >= 0 && j + dj < m\n              if dist[i + di][j\
    \ + dj] == -1\n                dist[i + di][j + dj] = dist[i][j] + 1\n       \
    \         queue[q_sz][0] = i + di\n                queue[q_sz][1] = j + dj\n \
    \               q_sz += 1\n              end\n            end\n          end\n\
    \          dj += 1\n        end\n        di += 1\n      end\n    end\n  end\n\
    \  0.upto(n - 1) do |i|\n    0.upto(m - 1) do |j|\n      if dist[i][j] == k\n\
    \        path = Array.new(k, -1)\n        path[0] = grid[i][j]\n        path_sum\
    \ = grid[i][j]\n        p = 1\n        q = 0\n        queue[q][0] = i\n      \
    \  queue[q][1] = j\n        q += 1\n        while p < k\n          i = queue",
  "    m = grid.length\n    res = []\n    for i in 0..(m - 1)\n        for j in 0..(m\
    \ - 1)\n            res << dfs(grid, k, i, j, Set.new([[i, j]]))\n        end\n\
    \    end\n    min = res.min\n    res.each_with_index do |el, i|\n        if el\
    \ == min\n            return res[i][1]\n        end\n    end\nend", "\tn = grid.length\n\
    \t#assume grid is a n*n array\n\tmin = Array.new(n, Array.new(n, Array.new(k,\
    \ 0)))\n\tmin.each do |a|\n\t\ta.each do |b|\n\t\t\tb.each do |c|\n\t\t\t\tc =\
    \ 0\n\t\t\tend\n\t\tend\n\tend\n\tmin[0][0][0] = grid[0][0]\n\tmin.each do |i|\n\
    \t\ti.each do |j|\n\t\t\tj.each do |k|\n\t\t\t\tmin[]\n\t\t\tend\n\t\tend\n\t\
    end\n\t#assume k <= n*n\nend", "  n = grid.size\n  all_vals = (1..n*n).to_a\n\
    \  index_map = all_vals.map.with_index.to_h\n  val_map = index_map.invert\n  @grid\
    \ = []\n  n.times do |i|\n    row = []\n    n.times do |j|\n      row << val_map[grid[i][j]]\n\
    \    end\n    @grid << row\n  end\n  @visited = Array.new(n) { Array.new(n, false)\
    \ }\n  @k = k\n  @n = n\n  @res = nil\n  @min_sum = nil\n  @max_sum = nil\n  traverse(0,\
    \ 0, [], 0)\n  @res.map { |x| index_map[x] }\nend", "    grid.flatten!\n    return\
    \ [grid[k - 1]] if k == 1\n    return grid if k == grid.length\n    n = grid.length\n\
    \    return [1] if n == 2\n    dp = Array.new(n, 0)\n    i = 0\n    while i <\
    \ n\n        dp[i] = i + 1\n        i += 1\n    end\n    dp2 = Array.new(n, 0)\n\
    \    dp2[0] = 1\n    for i in 1...n\n        dp2[i] = dp2[i - 1] + dp[i]\n   \
    \ end\n    nums = []\n    for i in 0...n\n        if dp2[i] <= k && k <= dp2[i]\
    \ + n - i - 1\n            nums.push(grid[i])\n            k -= dp2[i]\n     \
    \       if k == 1\n                return nums\n            end\n        end\n\
    \    end\n    return nums\nend", "  return grid[0][0] if k == 1\n  n = grid.length\n\
    \  maxRow = n - 1\n  maxCol = n - 1\n  maxSum = n + n - 1\n  minSum = n - 1\n\
    \  minPath = []\n  (0..maxRow).each do |i|\n    (0..maxCol).each do |j|\n    \
    \  if i + j == minSum\n        cur = [grid[i][j]]\n        (1..maxSum).each do\
    \ |d|\n          if d % 2 == 0\n            if i + d < maxSum\n              cur\
    \ << grid[i + d][j]\n            end\n          else\n            if j + d < maxSum\n\
    \              cur << grid[i][j + d]\n            end\n          end\n       \
    \ end\n        if cur.length == k\n          if minPath.empty? || cur < minPath\n\
    \            minPath = cur\n          end\n        end\n      end\n    end\n \
    \ end\n  return minPath\nend", "  min, minPath = minPathRecur(grid, k, 0, 0, [])\n\
    \  minPath\nend", "\nend", "\t# Write your code here\nend", "  dim = grid.size\n\
    \  min_path = Array.new(dim) { Array.new(dim) }\n  min_path[0][0] = [grid[0][0]]\n\
    \  path_length = 0\n  next_path_length = 1\n  (1...dim).each do |i|\n    if grid[0][i]\
    \ < min_path[0][i - 1][0]\n      min_path[0][i] = [grid[0][i]]\n    else\n   \
    \   min_path[0][i] = min_path[0][i - 1]\n    end\n  end\n  (1...dim).each do |i|\n\
    \    if grid[i][0] < min_path[i - 1][0][0]\n      min_path[i][0] = [grid[i][0]]\n\
    \    else\n      min_path[i][0] = min_path[i - 1][0]\n    end\n  end\n  while\
    \ path_length < k\n    path_length = next_path_length\n    next_path_length +=\
    \ 1\n    (1...dim).each do |i|\n      (1...dim).each do |j|\n        min_path[i][j]\
    \ = min_path[i - 1][j]\n        if min_path[i][j - 1][0] < min_path[i][j][0]\n\
    \          min_path[i][j] = min_path[i][j - 1]\n        end\n        if grid[i][j]\
    \ < min_path[i][j][0]\n          min_path[i][j] = [grid[i][j]]\n        end\n\
    \      end\n    end\n  end\n  min_path[dim - 1][dim - 1][0...k]\nend", "\tr =\
    \ grid.length\n\tc = grid[0].length\n\tmat = Array.new(r) { Array.new(c) }\n\t\
    mat[0][0] = k\n\tfor i in 1...r\n\t\tmat[i][0] = mat[i-1][0] - 1\n\tend\n\tfor\
    \ j in 1...c\n\t\tmat[0][j] = mat[0][j-1] - 1\n\tend\n\tfor i in 1...r\n\t\tfor\
    \ j in 1...c\n\t\t\tmat[i][j] = [mat[i-1][j], mat[i][j-1]].min - 1\n\t\tend\n\t\
    end\n\tputs \"mat is: \"\n\tfor i in 0...r\n\t\tputs mat[i].join(\" \")\n\tend\n\
    \tarr = []\n\ti = r - 1\n\tj = c - 1\n\twhile mat[i][j] > 0\n\t\tarr << grid[i][j]\n\
    \t\tif i > 0 && mat[i-1][j] >= mat[i][j]\n\t\t\ti -= 1\n\t\telse\n\t\t\tj -= 1\n\
    \t\tend\n\tend\n\tarr << grid[i][j]\n\tputs \"returning: #{arr}\"\n\treturn arr\n\
    end", "    n = grid.length\n    m = grid[0].length\n    # D[i][j][l] is the minimum\
    \ values for a path of length l,\n    # where i is the row number and j is the\
    \ column number of the last cell\n    # in the path, and the path has to end in\
    \ (i, j).\n    D = Array.new(n) { Array.new(m) { Array.new(k + 1, 0) } }\n   \
    \ # I have no idea what should be the initial value of D[i][j][l],\n    # but\
    \ if I am using the value of n^2, then the comparision between\n    # the answer\
    \ and the initial value will not fail.\n    # Therefore, I am using n^2 as the\
    \ initial value.\n    n2 = n * n\n    (0..(n - 1)).each do |i|\n        (0..(m\
    \ - 1)).each do |j|\n            D[i][j][1] = grid[i][j]\n        end\n    end\n\
    \    # Initialize the answer (an array).\n    res = Array.new(k, n2)\n    (2..k).each\
    \ do |l|\n        (0..(n - 1)).each do |i|\n            (0..(m - 1)).each do |j|\n\
    \                D[i][j][l] = n2\n                # Check the up cell.\n     \
    \           if i > 0\n                    tmp = D[i - 1][j][l - 1]\n         \
    \           if tmp < D[i][j][l]\n                        D[i][j][l] = tmp\n  \
    \                      res[l - 1] = grid[i - 1][j]\n                    elsif\
    \ tmp == D[i][j][l]\n                        res[l - 1] = [res[l - 1], grid[i\
    \ - 1][j]].min\n                    end\n                end\n               \
    \ # Check the left cell.\n                if j > 0\n                    tmp =\
    \ D[i][j - 1][l - 1]\n                    if tmp < D[i][j][l]\n              \
    \          D[i][j][l] = tmp\n                        res[l - 1] = grid[i][j -\
    \ 1]\n                    els", "    n = grid.length\n    t = []\n    for i in\
    \ 0...n\n        t[i] = []\n        for j in 0...n\n            t[i][j] = [grid[i][j],\
    \ [[i, j]]]\n        end\n    end\n    for i in 0...n\n        for j in 0...n\n\
    \            if i > 0\n                t[i][j] = [t[i - 1][j][0] + grid[i][j],\
    \ t[i - 1][j][1] + [[i, j]]] if t[i][j][0] > t[i - 1][j][0] + grid[i][j]\n   \
    \         end\n            if j > 0\n                t[i][j] = [t[i][j - 1][0]\
    \ + grid[i][j], t[i][j - 1][1] + [[i, j]]] if t[i][j][0] > t[i][j - 1][0] + grid[i][j]\n\
    \            end\n        end\n    end\n    for i in 1...n\n        for j in 1...n\n\
    \            if i < n - 1\n                t[i][j] = [t[i + 1][j][0] + grid[i][j],\
    \ t[i + 1][j][1] + [[i, j]]] if t[i][j][0] > t[i + 1][j][0] + grid[i][j]\n   \
    \         end\n            if j < n - 1\n                t[i][j] = [t[i][j + 1][0]\
    \ + grid[i][j], t[i][j + 1][1] + [[i, j]]] if t[i][j][0] > t[i][j + 1][0] + grid[i][j]\n\
    \            end\n        end\n    end\n    for i in n - 2...0\n        for j\
    \ in n - 2...0\n            if i > 0\n                t[i][j] = [t[i - 1][j][0]\
    \ + grid[i][j], t[i - 1][j][1] + [[i, j]]] if t[i][j][0] >", "  (0..grid.size\
    \ - 1).each do |i|\n    (0..grid[0].size - 1).each do |j|\n      grid[i][j] =\
    \ toIndex(i, j, grid.size)\n    end\n  end\n  puts grid.inspect\n  m = grid.size\n\
    \  n = grid[0].size\n  candidates = []\n  helper(candidates, [], grid, m, n, 0,\
    \ 0, k)\n  candidates.sort!\n  # puts candidates.inspect\n  (0..candidates.size\
    \ - 1).each do |i|\n    (0..candidates[i].size - 1).each do |j|\n      candidates[i][j]\
    \ = grid[toRow(candidates[i][j], m)][toCol(candidates[i][j], m)]\n    end\n  end\n\
    \  puts candidates.inspect\n  candidates[0]\nend", "\nend", "    rows = grid.length\n\
    \    cols = grid[0].length\n    curr, next = [], []\n    curr << [grid[0][0],\
    \ 0, 0]\n    min_path = []\n    (1..k).each do |i|\n        while !curr.empty?\n\
    \            value, row, col = curr.shift\n            if row == rows - 1 && col\
    \ == cols - 1\n                min_path = [value] if min_path.empty?\n       \
    \         if value < min_path[-1]\n                    min_path = [value]\n  \
    \              elsif value == min_path[-1]\n                    min_path << value\n\
    \                end\n            end\n            if row + 1 < rows\n       \
    \         next << [value + grid[row + 1][col], row + 1, col]\n            end\n\
    \            if col + 1 < cols\n                next << [value + grid[row][col\
    \ + 1], row, col + 1]\n            end\n        end\n        curr, next = next,\
    \ curr\n    end\n    min_path\nend", "\trows = grid.length\n\tcolumns = grid[0].length\n\
    \t\n\tmin_path = Array.new(k, 0)\n\tpath = Array.new(k, 0)\n\tcurr_min = Float::INFINITY\n\
    \t\n\t# We need to loop through every cell.\n\tfor row in 0...rows\n\t\tfor column\
    \ in 0...columns\n\t\t\tdfs(grid, row, column, k, 0, 0, curr_min, path, min_path)\n\
    \t\tend\n\tend\n\t\n\treturn min_path\nend", "  n = grid.size\n  # dp[u][i] =\
    \ [val, cost]\n  # - val: minimum value of path from grid[u / n][u % n] of cost\
    \ i\n  # - cost: cost of minimum path from grid[u / n][u % n] of cost i\n  dp\
    \ = Array.new(n * n) { Array.new(k + 1, [-1, -1]) }\n  n.times do |r|\n    n.times\
    \ do |c|\n      u = r * n + c\n      dp[u][0] = [grid[r][c], 0]\n      if r >\
    \ 0\n        v = (r - 1) * n + c\n        if dp[v][0][0] < dp[u][0][0] || (dp[v][0][0]\
    \ == dp[u][0][0] && dp[v][0][1] > dp[u][0][1])\n          dp[u][0] = dp[v][0]\n\
    \        end\n      end\n      if c > 0\n        v = r * n + c - 1\n        if\
    \ dp[v][0][0] < dp[u][0][0] || (dp[v][0][0] == dp[u][0][0] && dp[v][0][1] > dp[u][0][1])\n\
    \          dp[u][0] = dp[v][0]\n        end\n      end\n    end\n  end\n  (1..k).each\
    \ do |i|\n    n.times do |r|\n      n.times do |c|\n        u = r * n + c\n  \
    \      if r > 0\n          v = (r - 1) * n + c\n          if dp[v][i - 1][0] <\
    \ dp[u][i][0] || (dp[v][i - 1][0] == dp[u][i][0] && dp[v][i - 1][1] > dp[u][i][1])\n\
    \            dp[u][i] = dp[v][i - 1]\n          end\n        end\n        if",
  "  m, n = grid.size, grid[0].size\n  q = [[0, 0, grid[0][0]]]\n  @dp = {}\n  @dp[[0,\
    \ 0, grid[0][0]]] = [grid[0][0]]\n  while !q.empty?\n    x, y, val = q.shift\n\
    \    return @dp[[x, y, val]] if x == m - 1 && y == n - 1 && val == k\n    [val\
    \ - 1, val, val + 1].each do |d|\n      next if d < 1 || d > m * n\n      i, j\
    \ = (d - 1) / n, (d - 1) % n\n      if (0..m - 1).include?(i) && (0..n - 1).include?(j)\
    \ && @dp[[i, j, d]].nil?\n        @dp[[i, j, d]] = @dp[[x, y, val]] + [grid[i][j]]\n\
    \        q << [i, j, d]\n      end\n    end\n  end\n  return []\nend", "  grid\
    \ = grid.map { |row| row.map(&:to_i) }\n  n = grid.size\n  return [grid[0][0]]\
    \ if k == 1\n  counts = Hash.new(0)\n  for i in 0...n\n    for j in 0...n\n  \
    \    counts[grid[i][j]] += 1\n    end\n  end\n  queue = [[0, 0, [grid[0][0]]]]\n\
    \  steps = Hash.new(0)\n  steps[[0, 0]] = 1\n  until queue.empty?\n    i, j, path\
    \ = queue.shift\n    return path if path.size == k\n    steps[i, j] = path.size\n\
    \    [[i + 1, j], [i - 1, j], [i, j + 1], [i, j - 1]].each do |x, y|\n      next\
    \ if x < 0 || x >= n || y < 0 || y >= n\n      next if counts[grid[x][y]] == 1\
    \ && steps[x, y] == path.size - 1\n      queue << [x, y, path + [grid[x][y]]]\n\
    \    end\n  end\nend\nputs \"#{minPath([[1,2,3], [4,5,6], [7,8,9]], 3)}\"\nputs\
    \ \"#{minPath([[5,9,3], [4,1,6], [7,8,2]], 1)}\"", "  max_sum = grid.size * grid.size\n\
    \  return [0] if k > max_sum\n  return [1] if k == 1\n  min_path = []\n  visited\
    \ = Array.new(grid.size) { Array.new(grid.size, false) }\n  # visited[0][0] =\
    \ true\n  get_min_path(grid, k, 0, 0, 0, visited, min_path, [])\n  p min_path\n\
    end", "  @k = k\n  @min = []\n  @n = grid.size\n  @visited = Array.new(@n) { Array.new(@n,\
    \ false) }\n  dfs(grid, 0, 0, [])\n  @min\nend", "\tif k == 1\n\t\tmin = grid[0][0]\n\
    \t\tgrid.each { |row| row.each { |e| min = e if e < min } }\n\t\treturn [min]\n\
    \tend\n\theight = grid.length\n\twidth = grid[0].length\n\tminimums = Array.new(height)\
    \ { Array.new(width) }\n\tfor r in 0...height\n\t\tfor c in 0...width\n\t\t\t\
    min = grid[r][c]\n\t\t\tif c > 0\n\t\t\t\tmin = minimums[r][c - 1] if minimums[r][c\
    \ - 1] < min\n\t\t\tend\n\t\t\tif r > 0\n\t\t\t\tmin = minimums[r - 1][c] if minimums[r\
    \ - 1][c] < min\n\t\t\tend\n\t\t\tminimums[r][c] = min\n\t\tend\n\tend\n\tpath\
    \ = []\n\tr = 0\n\tc = 0\n\twhile k > 0\n\t\tpath << grid[r][c]\n\t\tif r > 0\
    \ && c > 0\n\t\t\tif minimums[r - 1][c] < minimums[r][c - 1]\n\t\t\t\tr -= 1\n\
    \t\t\telse\n\t\t\t\tc -= 1\n\t\t\tend\n\t\telsif r > 0\n\t\t\tr -= 1\n\t\telsif\
    \ c > 0\n\t\t\tc -= 1\n\t\tend\n\t\tk -= 1\n\tend\n\tpath\nend", "  # we create\
    \ a matrix that stores the depth of each spot on the grid\n  # and we also create\
    \ a matrix that indicates the previous node we took\n  # to get to that spot\n\
    \  depth = Array.new(grid.length) { Array.new(grid.length, -1) }\n  prev = Array.new(grid.length)\
    \ { Array.new(grid.length, [-1, -1]) }\n  # we begin our BFS at [0, 0] since this\
    \ is a valid starting spot, we mark\n  # that spot as having a depth of 0, and\
    \ a previous node of [-1, -1]\n  que = [[0, 0]]\n  depth[0][0] = 0\n  # while\
    \ the queue is not empty\n  while !que.empty?\n    # grab the first element in\
    \ the queue\n    r, c = que.shift\n    # if the current depth at this spot is\
    \ equal to k, we are done\n    return backtrack(prev, [r, c]) if depth[r][c] ==\
    \ k\n    # we loop through the possible moves for this node\n    moves = [[-1,\
    \ 0], [1, 0], [0, -1], [0, 1]]\n    moves.each do |dr, dc|\n      # if the new\
    \ spot we are looking at is a valid spot and the depth at\n      # that spot is\
    \ -1, we mark the depth at that spot and we add the spot\n      # to the queue\n\
    \      new_r = r + dr\n      new_c = c + dc\n      if (0...grid.length).include?(new_r)\
    \ && (0...grid.length).include?(new_c) && depth[new_r][new_c] == -1\n        depth[new_r][new_c]\
    \ = depth[r][c] + 1\n        prev[new_r][new_c] = [r, c]\n        que << [new_r,\
    \ new_c]\n      end\n    end\n  end\n  # if we get to this point, the grid is\
    \ invalid and we return an empty array\n  []\nend", "  return grid[0][0] if k\
    \ == 1\n  paths = Array.new(k) { Array.new(k) }\n  paths[0][0] = grid[0][0]\n\
    \  # Note: it is the minimum value before the first row and first column\n  #\
    \ that can be obtained from adjacent cells.\n  (1...k).each do |index|\n    paths[0][index]\
    \ = [paths[0][index - 1], grid[0][index]].min\n    paths[index][0] = [paths[index\
    \ - 1][0], grid[index][0]].min\n  end\n  # Now, we can find the minimum value\
    \ to reach cell (i, j) from the\n  # adjacent cells.\n  # Note: it is the minimum\
    \ value before the cell (i, j) that can be obtained\n  # from adjacent cells.\n\
    \  (1...k).each do |row|\n    (1...k).each do |col|\n      paths[row][col] = [paths[row\
    \ - 1][col], paths[row][col - 1], grid[row][col]].min\n    end\n  end\n  paths[k\
    \ - 1][k - 1]\nend", "  n = grid.size\n  pos = [0, 0]\n  dp = [0] * (n * n)\n\
    \  res = 1.0 / 0\n  dfs(grid, dp, k, pos, 0, res)\n  res\nend", "  # Time O(n\
    \ ^ k), Space O(n ^ k)\n  n = grid.size\n  memo = Hash.new { |h, key| h[key] =\
    \ {}}\n  minPathHelper(grid, 0, 0, k, memo)\nend", "    if grid.nil? or grid.length\
    \ < 2 or grid[0].length < 2\n        return nil\n    end\n    if k < 1\n     \
    \   return nil\n    end\n    if k > grid.length * grid[0].length\n        return\
    \ nil\n    end\n    # set dp[i][j][k] as the minimum path length of current grid\n\
    \    # from cell (i, j) to any other cell with length of k\n    dp = Array.new(grid.length)\
    \ {Array.new(grid[0].length) {Array.new(k + 1, -1)}}\n    # dp[i][j][k] is the\
    \ minimum path length of current grid from\n    # cell (i, j) to any other cell\
    \ with length of k\n    # if k < grid.length * grid[0].length - 1\n    # dp[i][j][k]\
    \ = min(dp[i - 1][j][k - 1], dp[i + 1][j][k - 1],\n    #                   dp[i][j\
    \ - 1][k - 1], dp[i][j + 1][k - 1])\n    # and add grid[i][j] to the right place\
    \ in the minimum path\n    # if k = grid.length * grid[0].length - 1\n    # dp[i][j][k]\
    \ = min(dp[i - 1][j][k - 1], dp[i + 1][j][k - 1],\n    #                   dp[i][j\
    \ - 1][k - 1], dp[i][j + 1][k - 1])\n    # and add grid[i][j] to the left most\
    \ place in the minimum path\n    # if k = grid.length * grid[0].length\n    #\
    \ dp[i][j][k] = min(dp[i - 1][j][k - 1], dp[i + 1][j][k - 1],\n    #         \
    \          dp[i][j - 1][k - 1], dp[i][j + 1][k - 1])\n    # and add grid[i][j]\
    \ to the right most place in the minimum path\n    # and the minimum path length\
    \ dp[0][0][k] is", "  # Use DFS to find all paths of length k.\n  # Use helper\
    \ function to compare the values on two paths.\n  min_path = []\n  (0...grid.size).each\
    \ do |i|\n    (0...grid.size).each do |j|\n      min_path = [grid[i][j]] if min_path.empty?\n\
    \      path = []\n      helper(grid, k, i, j, path, min_path)\n    end\n  end\n\
    \  min_path\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
