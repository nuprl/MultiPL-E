name: HumanEval_47_median
language: rb
prompt: "# Return median of elements in the list l.\n# >>> median([3, 1, 2, 4, 5])\n\
  # 3\n# >>> median([-10, 4, 6, 1000, 10, 20])\n# 15.0\ndef median(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_median\n\
  \    candidate = method(:median)\n    assert_equal(3, candidate.call([3, 1, 2, 4,\
  \ 5]))\n    assert_equal(8.0, candidate.call([-10, 4, 6, 1000, 10, 20]))\n    assert_equal(5,\
  \ candidate.call([5]))\n    assert_equal(5.5, candidate.call([6, 5]))\n    assert_equal(7,\
  \ candidate.call([8, 1, 3, 9, 9, 2, 7]))\n  end\nend\n"
completions: ["  n = l.length\n  if n == 0\n    return nil\n  elsif n % 2 == 0\n \
    \   return (l[n/2 - 1] + l[n/2]) / 2.0\n  else\n    return l[n/2]\n  end\nend",
  "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  # FIXME\nend", "  l.sort!\n  n = l.length\n  m = n / 2\n\
    \  if n % 2 == 0\n    return (l[m] + l[m-1]) / 2.0\n  else\n    return l[m]\n\
    \  end\nend", "  sorted = l.sort\n  length = sorted.length\n  (sorted[(length\
    \ - 1) / 2] + sorted[length / 2]) / 2.0\nend", "  # Fill out your code here\n\
    \  \n    if (l.length % 2) == 0\n      i = l.length / 2\n      value = (l[i-1]\
    \ + l[i]) / 2.0\n      return value\n    else\n      i = l.length / 2\n      value\
    \ = l[i]\n      return value\n    end\n  \nend", "\tm=l.sort\n\tif m.length %\
    \ 2 == 1\n\t\treturn m[m.length/2]\n\telse\n\t\ta=m[m.length/2]\n\t\tb=m[m.length/2-1]\n\
    \t\treturn (a+b)/2.0\n\tend\nend", end, "  l.sort!\n  len = l.length\n  len %\
    \ 2 == 0 ? (l[len/2] + l[len/2 - 1]) / 2.0 : l[len/2]\nend", "  l.sort\n  n =\
    \ l.length\n  mid = n/2\n  if n % 2 == 0\n    return (l[mid-1] + l[mid])/2.0\n\
    \  else\n    return l[mid]\n  end\nend", "  sorted = l.sort\n  mid = (sorted.length\
    \ - 1) / 2.0\n  if sorted.length.odd?\n    return sorted[mid]\n  else\n    return\
    \ (sorted[mid] + sorted[mid + 1]) / 2.0\n  end\nend", "  l.sort!\n  if l.length\
    \ % 2 == 0\n    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n  else\n   \
    \ return l[l.length/2]\n  end\nend", "  l.sort!\n  if l.length % 2 == 0\n    return\
    \ (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n    return l[l.length/2]\n\
    \  end\nend", "\tm=l.sort\n\tif m.length%2==0\n\t\treturn (m[m.length/2]+m[m.length/2-1])/2.0\n\
    \telse\n\t\treturn m[m.length/2]\n\tend\nend", "  half = l.size / 2\n  sorted\
    \ = l.sort\n  l.size.odd? ? sorted[half] : (sorted[half - 1] + sorted[half]).to_f\
    \ / 2\nend", "\tif l.length % 2 == 0\n\t\treturn (l[l.length/2 - 1] + l[l.length/2])\
    \ / 2.0\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", "  # ...\nend", "    l\
    \ = l.sort\n    if l.length.odd?\n        return l[l.length/2]\n    else\n   \
    \     return (l[l.length/2] + l[l.length/2 - 1])/2.0\n    end\nend\nputs \"The\
    \ median is #{median([-10, 4, 6, 1000, 10, 20])}\"", "  l.sort!\n  if l.length\
    \ % 2 == 0\n    index = l.length / 2\n    ((l[index] + l[index - 1]) / 2.0)\n\
    \  else\n    (l[l.length / 2])\n  end\nend", "  #write your code here\nend", end,
  "  l.sort!\n  return l[l.length/2] if l.length % 2 == 1\n  return (l[l.length/2\
    \ - 1] + l[l.length/2]) / 2.0\nend", "  l.sort!\n  if l.length % 2 == 0\n    l[l.length/2]\
    \ + l[l.length/2 - 1]\n  else\n    l[l.length/2]\n  end\nend", "  # Put your code\
    \ here\nend", "  l.sort!\n  if l.length % 2 == 0\n    a = l.length / 2\n    b\
    \ = a - 1\n    return (l[a] + l[b]) / 2.0\n  else\n    return l[l.length / 2]\n\
    \  end\nend", "\tn = l.length\n\tif n == 0\n\t\treturn nil\n\telsif n.odd?\n\t\
    \ti = (n / 2).to_i\n\t\treturn l[i]\n\telse\n\t\ti = (n / 2).to_i\n\t\treturn\
    \ (l[i] + l[i - 1]) / 2.0\n\tend\nend", "  # Your code here\n  if l.length.odd?\n\
    \    return sorted_list(l)[(l.length/2)]\n  else\n    return (sorted_list(l)[l.length/2\
    \ - 1] + sorted_list(l)[l.length/2]).to_f/2\n  end\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend",
  "  l.sort[l.length/2]\nend", "  # YOUR CODE HERE\n  require 'set'\n  set=l.to_set\n\
    \  i=0\n  mid=l.length/2\n  set.sort.each do |x|\n    if i==mid\n      return\
    \ x\n    end\n    i+=1\n  end\nend", "  # your code here\n  l.sort!\n  len = l.length\n\
    \  if len % 2 == 0\n    return (l[len/2 - 1] + l[len/2]) / 2.0\n  else\n    return\
    \ l[len/2]\n  end\nend", "  sorted = l.sort\n  return (sorted[l.length/2] + sorted[(l.length-1)/2])/2.0\n\
    end", "  l.sort!\n  length = l.length\n  if length.odd?\n    m_index = length\
    \ / 2\n    return l[m_index]\n  else\n    m_index = length / 2\n    return (l[m_index]\
    \ + l[m_index - 1]) / 2.0\n  end\nend", "  l.sort!\n  if l.length.odd?\n    return\
    \ l[l.length/2]\n  else\n    return (l[l.length/2-1]+l[l.length/2])/2.0\n  end\n\
    end", "  l = l.sort\n  l.length%2 == 0 ? (l[l.length/2-1] + l[l.length/2])/2.0\
    \ : l[l.length/2]\nend", "  m = (l.length-1)/2\n  return (l[m] + l[m+1]).to_f/2\
    \ if l.length.even?\n  l[m]\nend", "  len = l.length\n  if len.odd?\n    return\
    \ l.sort[len/2]\n  else\n    return (l.sort[len/2 - 1] + l.sort[len/2]) / 2.0\n\
    \  end\nend", "  return nil if l.length == 0\n  return l[0] if l.length == 1\n\
    \  l.sort!\n  mid = l.length / 2\n  return l[mid] if l.length % 2 == 1\n  (l[mid\
    \ - 1] + l[mid]) / 2.0\nend", "  l.sort!\n  if l.length % 2 == 0\n    return (l[l.length/2]\
    \ + l[l.length/2 - 1]) / 2.0\n  else\n    return l[l.length/2]\n  end\nend", " \
    \ l.sort!\n  l.length.even? ? median_even(l) : median_odd(l)\nend", "\ta = l.sort.length/2\n\
    \tif l.length % 2 == 0\n\t\t((l.sort[a - 1]) + (l.sort[a]))/2.0\n\telse\n\t\t\
    (l.sort[a])\n\tend\nend", end, "  l = l.sort\n  if l.length % 2 == 0\n    return\
    \ (l[l.length/2-1]+l[l.length/2])/2.0\n  else\n    return l[l.length/2]\n  end\n\
    end", "  # your code here\nend", "  if l.length.odd?\n    return l.sort[l.length/2]\n\
    \  else\n    return (l.sort[l.length/2-1] + l.sort[l.length/2])/2.0\n  end\nend",
  "\tl.sort!\n\tif l.length.odd?\n\t\treturn l[l.length/2]\n\telse\n\t\tsum = 0\n\t\
    \tl.each {|x| sum+=x}\n\t\tsum = sum.to_f\n\t\treturn sum/l.length\n\tend\nend",
  "    l.sort!\n    n = l.length\n    return (l[n/2] + l[(n-1)/2]) / 2.0\nend", " \
    \ if l.size % 2 == 0\n    ((l[l.size/2 - 1].to_f + l[l.size/2].to_f) / 2).to_f\n\
    \  else\n    l[l.size/2].to_f\n  end\nend", "  return nil if l.empty?\n  sorted\
    \ = l.sort\n  m = l.length / 2\n  if l.length.odd?\n    return sorted[m]\n  else\n\
    \    return (sorted[m-1] + sorted[m]) / 2.0\n  end\nend", "  l.sort!\n  length\
    \ = l.length\n  return (l[length/2] + l[(length/2) - 1]) / 2.0 if length % 2 ==\
    \ 0\n  l[length/2]\nend", "  m = l.sort\n  if m.length % 2 == 0\n    return (m[m.length/2]\
    \ + m[m.length/2 - 1])/2.0\n  else\n    return m[m.length/2]\n  end\nend", " \
    \ l.sort!\n  m = l.length/2\n  m.is_a?(Integer) ? l[m] : (l[m] + l[m-1])/2.0\n\
    end", "\tif (l.length % 2) == 0\n\t\treturn ((l[l.length/2-1] + l[l.length/2])\
    \ / 2.0)\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", "  l = l.sort\n  if l.length\
    \ % 2 == 0\n    l[l.length/2] = (l[l.length/2] + l[l.length/2 - 1])/2.0\n  else\n\
    \    l[l.length/2]\n  end\nend", "  # TODO: Your code here\nend", "  len = l.length\n\
    \  sorted = l.sort\n  # mid = len/2\n  if len % 2 == 0\n    (sorted[(len/2)-1]\
    \ + sorted[len/2])/2.0\n  else\n    sorted[len/2]\n  end\nend", "  sorted = l.sort\n\
    \  median = 0\n  if l.size%2 == 0\n    median = sorted[(l.size/2)-1..(l.size/2)]\n\
    \    median = (median[0] + median[1])/2.0\n  else\n    median = sorted[(l.size/2)]\n\
    \  end\n  return median\nend", "\tl.sort!\n\tl.length % 2 == 0 ? (l[l.length/2-1]\
    \ + l[l.length/2])/2.0 : l[l.length/2]\nend", "  s = l.sort\n  len = s.length\n\
    \  (s[(len - 1) / 2] + s[len / 2]) / 2.0\nend", "    return nil if l.empty?\n\
    \    half = l.length / 2\n    l.sort!\n    l.length.odd? ? l[half] : (l[half -\
    \ 1] + l[half]).to_f / 2\nend", "  # first we sort the array to be ascending\n\
    \  sorted = l.sort", "  sorted = l.sort\n  len = sorted.length\n  return (sorted[(len\
    \ - 1) / 2] + sorted[len / 2]) / 2.0\nend", "\treturn 0 if l.length == 0\n\treturn\
    \ l[0] if l.length == 1\n\tl.sort!\n\treturn (l[l.length/2] + l[l.length/2-1])/2.0\
    \ if l.length % 2 == 0\n\treturn l[l.length/2]\nend", "  l.sort!\n  if l.length\
    \ % 2 == 0\n    return (l[l.length/2-1]+l[l.length/2])/2.0\n  else\n    return\
    \ l[l.length/2]\n  end\nend", "\tif l.length % 2 == 0\n\t\tmedian = (l[l.length/2]\
    \ + l[l.length/2 - 1])/2.0\n\telse\n\t\tmedian = l[l.length/2]\n\tend\n\treturn\
    \ median\nend", "  sorted = l.sort\n  if sorted.length % 2 == 0\n    (sorted[sorted.length/2\
    \ - 1] + sorted[sorted.length/2]) / 2.0\n  else\n    sorted[sorted.length/2]\n\
    \  end\nend", "  l.sort!\n  len = l.length\n  if len.odd?\n    # if len is odd\
    \ then median is the middle element\n    l[len/2]\n  else\n    # if len is even\
    \ then median is average of 2 middle elements\n    (l[len/2 - 1] + l[len/2]) /\
    \ 2.0\n  end\nend", "  l.sort!\n  if l.length % 2 == 0\n    (l[l.length/2 - 1]\
    \ + l[l.length/2]) / 2.0\n  else\n    l[l.length/2]\n  end\nend", "  len = l.length\n\
    \  mid = len / 2\n  if len % 2 == 0\n    return (l[mid] + l[mid-1]) / 2.0\n  else\n\
    \    return l[mid]\n  end\nend", "  sorted = l.sort\n  len = sorted.length\n \
    \ (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  l.sort!\n  if l.length\
    \ % 2 == 0\n    return (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n   \
    \ return l[l.length/2]\n  end\nend", "  n = l.size\n  sorted = l.sort\n  (sorted[(n\
    \ - 1) / 2] + sorted[n / 2]) / 2.0\nend", "  if l.size % 2 == 0\n    (l[l.size/2]\
    \ + l[l.size/2 - 1]) / 2.0\n  else\n    l[l.size/2]\n  end\nend", "  if l.length.odd?\n\
    \    l.sort[l.length/2]\n  else\n    (l.sort[l.length/2] + l.sort[l.length/2 -\
    \ 1])/2.0\n  end\nend", "  # Return median of elements in the list l.\n  # >>>\
    \ median([3, 1, 2, 4, 5])\n  # 3\n  # >>> median([-10, 4, 6, 1000, 10, 20])\n\
    \  # 15.0\n  \n  #Sort list first\n  #Select middle if list has odd number of\
    \ elements\n  #Select middle two if list has even number of elements\n  #Return\
    \ median\n  \n  #sort\n  sorted_l = l.sort\n  \n  length = sorted_l.length\n \
    \ \n  #select middle or two middle elements\n  if length % 2 == 0\n    middle\
    \ = length / 2 - 1\n    median = (sorted_l[middle] + sorted_l[middle + 1]) / 2.0\n\
    \  else\n    middle = length / 2\n    median = sorted_l[middle]\n  end\n  \n \
    \ return median\nend", "  l.sort!\n  if l.length % 2 == 0\n    first = l[l.length\
    \ / 2 - 1]\n    second = l[l.length / 2]\n    (first + second) / 2.0\n  else\n\
    \    l[l.length / 2]\n  end\nend", "  sorted = l.sort\n  length = sorted.length\n\
    \  return sorted[length/2] if length % 2 == 1\n  (sorted[length/2 - 1] + sorted[length/2]).to_f\
    \ / 2\nend", "  m = l.length / 2.0\n  sorted = l.sort\n  if m % 1 == 0\n    sorted[m.floor\
    \ - 1]\n  else\n    (sorted[m.floor - 1] + sorted[m.floor]) / 2.0\n  end\nend",
  "  l.sort!\n  size = l.size\n  if size % 2 == 0\n    (l[size/2 - 1] + l[size/2])\
    \ / 2.0\n  else\n    l[size/2]\n  end\nend", "  l = l.sort\n  len = l.length\n\
    \  if len % 2 == 0\n    (l[len/2-1] + l[len/2]) / 2.0\n  else\n    l[len/2]\n\
    \  end\nend", "    if l.length % 2 == 0 \n        (l[l.length/2] + l[l.length/2\
    \ - 1]) / 2.0\n    else\n        l[l.length/2]\n    end\nend", "  if l.length\
    \ % 2 == 0\n    (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n  else\n    l[l.length/2]\n\
    \  end\nend", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) /\
    \ 2] + sorted[len / 2]) / 2.0\nend", "  l.sort!\n  size = l.size\n  if size %\
    \ 2 == 0\n    return (l[size/2 - 1] + l[size/2]) / 2.0\n  else\n    return l[size/2]\n\
    \  end\nend", "\traise \"Empty List\" if l.length == 0\n\tl.sort!\n\t(l[l.length/2\
    \ - 1] + l[l.length/2])/2.0\nend", "\tl.sort!\n\tl.length % 2 == 0 ? (l[l.length/2-1]+l[l.length/2])/2.0\
    \ : l[l.length/2]\nend", "  l.sort!\n  if l.length % 2 == 0\n    return (l[l.length/2].to_f\
    \ + l[l.length/2 - 1].to_f)/2\n  else\n    return l[l.length/2]\n  end\nend",
  "  length = l.length\n  if length % 2 == 0\n    return (l[length/2 - 1] + l[length/2])\
    \ / 2.0\n  else\n    return l[length/2]\n  end\nend", "  i=l.size-1\n  j=0\n \
    \ t=0\n  while i>j\n    if l[i]<l[j]\n      t=l[i]\n      l[i]=l[j]\n      l[j]=t\n\
    \    end\n    i-=1\n    j+=1\n  end\n  if l.size%2==0\n    ((l[l.size/2]+l[l.size/2-1])/2.0)\n\
    \  else\n    l[l.size/2]\n  end\nend", "  l.sort!\n  if l.length.odd?\n    return\
    \ l[l.length/2]\n  else\n    return (l[l.length/2] + l[l.length/2-1])/2.0\n  end\n\
    end", "  # YOUR CODE HERE\nend", "  len = l.length\n  if len % 2 == 0\n    return\
    \ (l[len/2-1] + l[len/2]) / 2.0\n  else\n    return l[len/2]\n  end\nend", " \
    \ sorted = l.sort\n  if sorted.length % 2 == 0\n    (sorted[sorted.length/2] +\
    \ sorted[sorted.length/2 - 1]) / 2.0\n  else\n    sorted[sorted.length/2]\n  end\n\
    end", "  # \"Median is the middle number for a sorted list of numbers\"\n  length\
    \ = l.length\n  return nil if length < 1\n  # Sort the array\n  l.sort!\n  # If\
    \ the length is odd, return the middle element\n  return l[length/2] if length.odd?\n\
    \  # Otherwise, return the average of the two middle numbers\n  (l[length/2] +\
    \ l[length/2 - 1]) / 2.0\nend", "  if l.length % 2 == 0\n    return ((l[l.length/2]\
    \ + l[l.length/2 - 1]).to_f / 2)\n  else\n    return l[l.length/2]\n  end\nend",
  "    # Calculate the median here.\n    sorted_list = l.sort\n    return (sorted_list[(sorted_list.length/2)-1]\
    \ + sorted_list[sorted_list.length/2])/2.0 if sorted_list.length % 2 == 0\n  \
    \  return sorted_list[sorted_list.length/2]\nend", "  l.sort!\n  if l.length %\
    \ 2 == 0\n    return (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n    return\
    \ l[l.length/2]\n  end\nend", "  l.sort!\n  puts (l[l.length/2] + l[(l.length/2)\
    \ - 1]) / 2.0\nend", "  m = l.length / 2\n  return l[m] if l.length.odd?\n  return\
    \ (l[m-1] + l[m]) / 2.0\nend", "  return nil if l.empty?\n  l.sort!\n  length\
    \ = l.length\n  middle = length/2\n  if (length % 2) == 0\n    (l[middle-1] +\
    \ l[middle])/2.0\n  else\n    l[middle]\n  end\nend", "  sorted = l.sort\n  len\
    \ = sorted.length\n  if len % 2 == 1\n    sorted[len/2]\n  else\n    (sorted[len/2\
    \ - 1] + sorted[len/2]).to_f / 2\n  end\nend", "\tsorted = l.sort\n\tif sorted.length\
    \ % 2 == 0\n\t\treturn (sorted[sorted.length/2] + sorted[sorted.length/2-1])/2.0\n\
    \telse\n\t\treturn sorted[sorted.length/2]\n\tend\nend", "\t# sort l\n\t# if even,\
    \ get middle 2 and average\n\t# if odd, get middle\n\t# return median\n\tsorted_l\
    \ = l.sort\n\tif sorted_l.length.even?\n\t\tmedian = (sorted_l[sorted_l.length/2-1]\
    \ + sorted_l[sorted_l.length/2])/2.0\n\telse\n\t\tmedian = sorted_l[sorted_l.length/2]\n\
    \tend\n\treturn median\nend", end, "  if l.size.odd?\n    sorted = l.sort\n  \
    \  median = sorted[l.size/2]\n  else\n    sorted = l.sort\n    low = sorted[l.size/2\
    \ - 1]\n    high = sorted[l.size/2]\n    median = (low + high)/2.0\n  end\nend",
  "  l.sort!\n  if l.length.odd?\n    return l[l.length/2]\n  else\n    return (l[l.length/2]\
    \ + l[l.length/2 - 1])/2.0\n  end\nend", "  n = l.length\n  # Find the median\
    \ of an array\n  if n % 2 == 0\n    sorted = l.sort\n    return (sorted[n/2] +\
    \ sorted[n/2 - 1]) / 2.0\n  else\n    sorted = l.sort\n    return sorted[n/2]\n\
    \  end\nend", "  # REFACTOR THIS\n  sorted = l.sort\n  len = sorted.length\n \
    \ (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  sorted = l.sort\n\
    \  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend",
  "\tl.sort!\n\tif l.length % 2 == 0\n\t\t(l[l.length/2] + l[l.length/2 - 1]) / 2.0\n\
    \telse\n\t\tl[l.length/2]\n\tend\nend", "    l = l.sort\n    l_middle = l.length\
    \ / 2\n    if l.length % 2 == 0\n        middle_elements = [l[l_middle - 1], l[l_middle]]\n\
    \        (middle_elements[0] + middle_elements[1]) / 2.0\n    else\n        l[l_middle]\n\
    \    end\nend", "  if l.length.odd?\n    l.sort[l.length/2]\n  else\n    (l.sort[l.length/2]\
    \ + l.sort[l.length/2-1])/2.0\n  end\nend", "  sorted = l.sort\n  len = sorted.length\n\
    \  return (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", "  sorted = l.sort\n\
    \  return sorted[sorted.length/2] if sorted.length.odd?\n  (sorted[sorted.length/2-1]\
    \ + sorted[sorted.length/2])/2.0\nend", end, "  if l.size.odd?\n    l[l.size/2]\n\
    \  else\n    (l[l.size/2-1]+l[l.size/2])/2.0\n  end\nend", "  l.sort!\n  if l.length\
    \ % 2 == 0\n    return (l[l.length/2-1] + l[l.length/2])/2.0\n  else\n    return\
    \ l[l.length/2]\n  end\nend", "  # Your code here\nend", end, "  sorted = l.sort\n\
    \  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend",
  "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len\
    \ / 2]) / 2.0\nend", "  # FIXME - wrong!!\n  # q = l.sort { |a,b| a<=>b }\n  #\
    \ q.size % 2 == 0 ? (q[q.size/2] + q[q.size/2-1])/2.0 : q[q.size/2]\n  l.sort[l.size/2]\n\
    end", "  l.sort!\n  if l.length % 2 == 0\n    m = l.length / 2\n    (l[m-1] +\
    \ l[m]) / 2.0\n  else\n    m = l.length / 2\n    l[m]\n  end\nend", "  l = l.sort\n\
    \  if l.length % 2 == 0\n    return (l[l.length/2] + l[l.length/2 - 1])/2.0\n\
    \  else\n    return l[l.length/2]\n  end\nend", "\t\n\treturn nil if l.length\
    \ == 0\n\t\n\tl.sort!\n\t\n\tif l.length % 2 == 0\n\t\treturn (l[l.length/2] +\
    \ l[l.length/2 - 1]) / 2.0\n\telse\n\t\treturn l[l.length/2]\n\tend\nend", " \
    \ l.sort!\n  if l.length % 2 == 0\n    return (l[l.length/2-1]+l[l.length/2])/2.0\n\
    \  else\n    return l[l.length/2]\n  end\nend", "  s = l.sort\n  if s.length %\
    \ 2 == 0\n    (s[s.length/2] + s[s.length/2 - 1]) / 2.0\n  else\n    s[s.length/2]\n\
    \  end\nend", "  n = l.size\n  return nil if n == 0\n  m = n / 2\n  return l[m]\
    \ if n % 2 == 1\n  (l[m-1] + l[m]).to_f / 2\nend", "  # Your code here\n  len\
    \ = l.length\n  sorted = l.sort\n  mid = len/2\n  return sorted[mid] if len.odd?\n\
    \  (sorted[mid] + sorted[mid-1]).to_f/2\nend", "    # YOUR CODE HERE\n    if l.length\
    \ % 2 == 0\n        (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n    else\n    \
    \    l[l.length/2]\n    end\nend", "  l.sort[l.length/2]\nend", "\tl = l.sort\n\
    \tif l.length % 2 == 0\n\t\treturn (l[l.length/2] + l[l.length/2 - 1])/2.0\n\t\
    else\n\t\treturn l[l.length/2]\n\tend\nend", "  sort = l.sort\n  length = sort.length\n\
    \  #Check to see if even or odd\n  if length % 2 == 0\n    #Mean of the two middle\
    \ values\n    index = length / 2\n    (sort[index - 1] + sort[index]) / 2.0\n\
    \  else\n    #Just return the middle value\n    index = length / 2\n    sort[index]\n\
    \  end\nend", "    # sort l\n    # l is now sorted\n    # len = l.length\n   \
    \ # len = 4\n    # if even len / 2\n    # if odd len / 2 + 1 \n    len = l.length\n\
    \    # len = 4\n    mid_index = (len / 2).floor", "  if l.length.odd?\n    l.sort[l.length/2]\n\
    \  else\n    (l.sort[l.length/2] + l.sort[l.length/2 - 1])/2.0\n  end\nend", " \
    \ #return nil if l.empty?\n  len = l.length\n  l.sort!\n  mid = len/2\n  if len.odd?\n\
    \    l[mid]\n  else\n    (l[mid] + l[mid-1])/2.0\n  end\nend", "\tl.sort!\n\t\
    if l.length.odd?\n\t\tl[l.length/2]\n\telse\n\t\t(l[l.length/2] + l[l.length/2\
    \ - 1])/2.0\n\tend\nend", "\tarray = l.sort\n\tif array.length % 2 == 0\n\t\t\
    return (array[array.length/2-1] + array[array.length/2])/2.0\n\telse\n\t\treturn\
    \ array[array.length/2]\n\tend\nend", "  l.sort!\n  if l.length % 2 == 0\n   \
    \ return (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n    return l[l.length/2]\n\
    \  end\nend", "  # TODO\nend", "  even, odd = l.sort, l.sort.select.with_index\
    \ { |_, i| i.odd? }\n  even.size.even? ? even.zip(odd).map { |a, b| (a + b) /\
    \ 2.0 }.sum / 2 : odd.first\nend", "  return \"List cannot be empty\" if l.empty?\n\
    \  sorted = l.sort\n  length = sorted.length\n  if length.odd?\n    return sorted[length/2]\n\
    \  else\n    return (sorted[length/2-1] + sorted[length/2])/2.0\n  end\nend",
  "  l.sort!\n  if l.length % 2 == 0\n    (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n\
    \  else\n    l[l.length/2]\n  end\nend", "  l = l.sort\n  length = l.length\n\
    \  middle = length / 2\n  if length.odd?\n    l[middle]\n  else\n    (l[middle\
    \ - 1] + l[middle]) / 2.0\n  end\nend", "  # TODO\nend", "  l.sort!\n  i = l.length/2\n\
    \  if l.length % 2 == 0 \n    return (l[i]+l[i-1])/2.0\n  else\n    return l[i]\n\
    \  end\nend", "  l.sort!\n  if l.length % 2 == 0\n    return (l[l.length/2] +\
    \ l[l.length/2 - 1]) / 2.0\n  else\n    return l[l.length/2]\n  end\nend", "\t\
    l.sort!\n\tif l.length % 2 == 0\n\t\tmid = l.length / 2 - 1\n\t\treturn (l[mid]\
    \ + l[mid + 1]) / 2.0\n\telse\n\t\tmid = l.length / 2\n\t\treturn l[mid]\n\tend\n\
    end", "  return nil if l.empty?\n  sorted = l.sort\n  if sorted.length.odd?\n\
    \    return sorted[sorted.length / 2]\n  else\n    return (sorted[sorted.length\
    \ / 2 - 1] + sorted[sorted.length / 2]) / 2.0\n  end\nend", end, "  l.sort!\n\
    \  half = l.length / 2\n  if l.length % 2 == 0\n    avg = (l[half] + l[half -\
    \ 1]) / 2.0\n  else\n    avg = l[half]\n  end\n  avg\nend", "    l.sort!\n   \
    \ if l.length % 2 == 0\n        return (l[l.length/2] + l[l.length/2 - 1])/2.0\n\
    \    else\n        return l[l.length/2]\n    end\nend", "\tl.sort!\n\treturn (l[l.length/2]+l[l.length/2-1])/2.0\
    \ if l.length%2==0\n\treturn l[l.length/2]\nend", "  s = l.sort\n  if s.length.even?\n\
    \    (s[s.length/2 - 1] + s[s.length/2]) / 2.0\n  else\n    s[s.length/2]\n  end\n\
    end", '  l.sort!', "  # TODO\nend", "\tl.sort!\n\tif l.length % 2 == 0\n\t\tmedian\
    \ = (l[l.length/2].to_f + l[l.length/2 - 1].to_f)/2\n\telse\n\t\tmedian = l[l.length/2]\n\
    \tend\n\treturn median\nend", "  return nil if l.empty?\n  l.sort!\n  m = l.length\
    \ / 2\n  l.length.odd? ? l[m] : (l[m - 1] + l[m]).to_f / 2\nend", "  if l.length\
    \ % 2 == 0\n    even = []\n    even.push(l[l.length/2] + l[l.length/2 - 1])\n\
    \    even[0] / 2.0\n  else\n    odd = []\n    odd.push(l[l.length/2])\n    odd[0]\n\
    \  end\nend", "  length = l.length\n  # sort from least to greatest\n  sort =\
    \ l.sort\n  # check if length is even or odd\n  if length.even?\n    # sum of\
    \ the middle two numbers then divide by 2\n    sum = sort[length/2] + sort[length/2\
    \ - 1]\n    sum / 2.0\n  else\n    # return middle number\n    sort[length/2]\n\
    \  end\nend", "  l.sort!\n  if l.length % 2 == 0\n    (l[l.length/2] + l[l.length/2\
    \ - 1]) / 2.0\n  else\n    l[l.length/2]\n  end\nend", "  sorted = l.sort\n  len\
    \ = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2]) / 2.0\nend", " \
    \ sorted = l.sort\n  if sorted.length % 2 == 0\n    i = sorted.length / 2\n  \
    \  return (sorted[i] + sorted[i-1]) / 2.0\n  else\n    return sorted[sorted.length\
    \ / 2]\n  end\nend", "  n = l.size\n  s = l.sort\n  if n.even?\n    return (s[n/2-1]\
    \ + s[n/2])/2.0\n  else\n    return s[n/2]\n  end\nend", "  return nil if l.empty?\n\
    \  l.sort!\n  len = l.length\n  if len % 2 == 0\n    return (l[len/2 - 1] + l[len/2])\
    \ / 2.0\n  else\n    return l[len/2]\n  end\nend", "  return ((l.sort[l.length/2\
    \ - 1].to_f + l.sort[l.length/2].to_f)/2) if l.length.even?\n  return l.sort[l.length/2]\n\
    end", "  if l.length % 2 == 0\n    return (l[l.length/2] + l[l.length/2 - 1])\
    \ / 2.0\n  else\n    return l[l.length/2]\n  end\nend", "  # return nil if l.empty?\n\
    \  sorted = l.sort\n  median = nil\n  if l.count.odd?\n    median = sorted[(l.count\
    \ / 2)]\n  else\n    median = (sorted[(l.count / 2) - 1] + sorted[(l.count / 2)])\
    \ / 2.0\n  end\n  return median\nend", "  m = l.sort!\n  if m.length % 2 == 0\n\
    \    return (m[m.length/2].to_f + m[m.length/2 - 1].to_f)/2\n  else\n    return\
    \ m[m.length/2]\n  end\nend", "\t#variant 1\n\t#x = l.sort\n\t#if x.size % 2 ==\
    \ 0\n\t#\tav = (x[x.size/2] + x[x.size/2 - 1]) / 2.0\n\t#else\n\t#\tav = x[x.size/2]\n\
    \t#end\n\t#return av\n\t\n\t#variant 2\n\tx = l.sort.size % 2 == 0 ? (l.sort[l.sort.size/2]\
    \ + l.sort[l.sort.size/2 - 1]) / 2.0 : l.sort[l.sort.size/2]\n\treturn x\nend",
  "  l.sort!\n  if l.length % 2 == 0\n    median = (l[l.length/2] + l[l.length/2 -\
    \ 1]) / 2.0\n  else\n    median = l[l.length/2]\n  end\n  return median\nend",
  "    l.sort!\n    if l.length % 2 == 0\n        return ((l[l.length/2-1] + l[l.length/2])\
    \ / 2.0)\n    else\n        return l[l.length/2]\n    end\nend", "  len = l.length\n\
    \  m = 0.0\n  if len%2 == 0\n    m = (l[len/2]+l[len/2-1])/2.0\n  else\n    m\
    \ = l[len/2]\n  end\n  return m\nend", "  # Sort list and find median using odd\
    \ or even length\n  sorted = l.sort\n  if sorted.length % 2 == 0\n    (sorted[sorted.length/2\
    \ - 1] + sorted[sorted.length/2]) / 2.0\n  else\n    sorted[sorted.length/2]\n\
    \  end\nend", "\tif l.length % 2 == 0\n\t\tn = l.length / 2\n\t\t(l[n] + l[n-1])\
    \ / 2.0\n\telse\n\t\tl[l.length / 2]\n\tend\nend", "\tl.sort!\n\tmiddle = l.length\
    \ / 2\n\tif l.length % 2 == 0\n\t\tmedian = (l[middle] + l[middle - 1]) / 2.0\n\
    \telse\n\t\tmedian = l[middle]\n\tend\n\tmedian\nend", "\tif l.empty?\n\t\treturn\
    \ nil\n\tend\n\tl.sort!\n\tmedian_position = l.length / 2\n\tif l.length % 2 ==\
    \ 0\n\t\treturn (l[median_position] + l[median_position - 1]) / 2.0\n\telse\n\t\
    \treturn l[median_position]\n\tend\nend", "  sortl = l.sort\n  return (sortl[sortl.length/2]+sortl[sortl.length/2-1])/2\
    \ if sortl.length%2 == 0\n  sortl[sortl.length/2]\nend", "  s = l.sort\n  m =\
    \ (s.length) / 2\n  if s.length % 2 == 0\n    (s[m - 1] + s[m]) / 2.0\n  else\n\
    \    s[m]\n  end\nend", "  # TODO: Your code here\nend", "  if l.length % 2 ==\
    \ 0\n    return (l[l.length/2 - 1] + l[l.length/2]) / 2.0\n  else\n    return\
    \ l[l.length/2]\n  end\nend", "  list = l.sort\n  if list.length % 2 == 0\n  \
    \  return (list[list.length/2] + list[list.length/2 - 1])/2.0\n  else\n    return\
    \ list[list.length/2]\n  end\nend", "  if l.length % 2 == 0\n    index = l.length\
    \ / 2 - 1\n    (l[index] + l[index + 1]) / 2.0\n  else\n    index = l.length /\
    \ 2\n    l[index]\n  end\nend", "  sort_list = l.sort\n  if sort_list.length %\
    \ 2 == 0\n    i = sort_list.length / 2\n    return (sort_list[i] + sort_list[i\
    \ - 1]) / 2.0\n  else\n    sort_list[sort_list.length / 2]\n  end\nend", "  sorted\
    \ = l.sort\n  len = sorted.length\n  (sorted[(len - 1) / 2] + sorted[len / 2])\
    \ / 2.0\nend", "  sorted = l.sort\n  len = sorted.length\n  (sorted[(len - 1)\
    \ / 2] + sorted[len / 2]) / 2.0\nend", "    list = l.sort\n    if list.length.odd?\n\
    \        return list[(list.length/2)]\n    else\n        return (list[(list.length/2)]\
    \ + list[(list.length/2)-1])/2.0\n    end\nend", "  l.sort!\n  if l.length % 2\
    \ == 0\n    (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n  else\n    l[l.length/2]\n\
    \  end\nend", "    return nil if l.empty?\n    mid = l.length / 2\n    l.length.odd?\
    \ ? l[mid] : (l[mid - 1] + l[mid]).to_f / 2\nend", "  # YOUR CODE HERE\nend",
  "  sorted = l.sort\n  if sorted.length % 2 == 0\n    (sorted[sorted.length/2 - 1]\
    \ + sorted[sorted.length/2]) / 2.0\n  else\n    sorted[sorted.length/2]\n  end\n\
    end", "\nend", "  length = l.length\n  if length % 2 == 0\n    (l[length/2 - 1]\
    \ + l[length/2]) / 2.0\n  else\n    l[length/2]\n  end\nend", "  if l.size % 2\
    \ == 0\n    (l[l.size/2] + l[l.size/2 - 1]) / 2.0\n  else\n    l[l.size/2]\n \
    \ end\nend", "  l.sort!\n  med = l.length/2\n  if l.length.odd?\n    l[med]\n\
    \  else\n    (l[med] + l[med-1])/2.0\n  end\nend", "  n = l.length\n  return \"\
    Error!\" if n < 1\n  sorted = l.sort\n  n.odd? ? sorted[n/2] : (sorted[n/2-1]\
    \ + sorted[n/2]).to_f / 2\nend", "\tn = l.length\n\treturn nil if n == 0\n\tl.sort!\n\
    \tmid = n/2\n\tif n % 2 == 0\n\t\treturn (l[mid-1] + l[mid])/2.0\n\telse\n\t\t\
    return l[mid]\n\tend\nend", "\tl.sort!\n\tif l.length % 2 == 0\n\t\t# even\n\t\
    \treturn (l[l.length/2] + l[l.length/2 - 1]) / 2.0\n\telse\n\t\t# odd\n\t\treturn\
    \ l[l.length/2]\n\tend\nend", "  if l.length % 2 == 0\n    return (l[l.length/2-1]+l[l.length/2])/2.0\n\
    \  else\n    return l[l.length/2]\n  end\nend", "\ts = l.sort\n\tmed = s.length\
    \ / 2\n\tif s.length % 2 == 0\n\t\t(s[med-1] + s[med]) / 2.0\n\telse\n\t\ts[med]\n\
    \tend\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
