name: HumanEval_6_parse_nested_parens
language: rb
prompt: "# Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n# For each of the group, output the deepest\
  \ level of nesting of parentheses.\n# E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n# >>> parse_nested_parens('(()()) ((())) () ((())()())')\n\
  # [2, 3, 1, 3]\ndef parse_nested_parens(paren_string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_parse_nested_parens\n\
  \    candidate = method(:parse_nested_parens)\n    assert_equal([2, 3, 1, 3], candidate.call(\"\
  (()()) ((())) () ((())()())\"))\n    assert_equal([1, 2, 3, 4], candidate.call(\"\
  () (()) ((())) (((())))\"))\n    assert_equal([4], candidate.call(\"(()(())((())))\"\
  ))\n  end\nend\n"
completions: ["  paren_string.split(' ').map do |paren_group|\n    # We could use\
    \ a stack to store levels of parentheses\n    level = 0\n    max_level = 0\n \
    \   paren_group.each_char do |c|\n      level += 1 if c == '('\n      level -=\
    \ 1 if c == ')'\n      max_level = level if level > max_level\n    end\n    max_level\n\
    \  end\nend", "  paren_string.split(\" \").map { |string| parse_parens(string)\
    \ }\nend", "\tgroups = paren_string.split(\" \")\n\tmax_nest = []\n\tfor group\
    \ in groups\n\t\tnest = 0\n\t\tfor char in group.chars\n\t\t\tif char == \"(\"\
    \n\t\t\t\tnest += 1\n\t\t\telsif char == \")\"\n\t\t\t\tnest -= 1\n\t\t\tend\n\
    \t\tend\n\t\tmax_nest.push(nest)\n\tend\n\treturn max_nest\nend", "  arr = paren_string.split\n\
    \  result = []\n  arr.each do |paren|\n    current_max = 0\n    new_max = 0\n\
    \    paren.each_char do |char|\n      if char == '('\n        new_max += 1\n \
    \     elsif char == ')'\n        new_max -= 1\n      end\n      current_max =\
    \ new_max if new_max > current_max\n    end\n    result << current_max\n  end\n\
    \  result\nend", "  # Write your code here.\n  # First, separate the input string\
    \ into groups by whitespace\n  groups = paren_string.split(' ')\n  # puts groups\n\
    \  # Then parse each group, one at a time.\n  # For each group, create an array\
    \ containing the\n  # depths of each of the parentheses\n  max_depth = 0\n  count\
    \ = 0\n  levels = []\n  groups.each do |group|\n    group.each_char do |char|\n\
    \      if char == '('\n        count += 1\n        max_depth = count if count\
    \ > max_depth\n      elsif char == ')'\n        count -= 1\n      end\n    end\n\
    \    levels << max_depth\n    max_depth = 0\n    count = 0\n  end\n  # puts levels\n\
    \  levels\nend", "  paren_string.split(' ').map do |paren|\n    stack = []\n \
    \   max_depth = 0\n    current_depth = 0\n    paren.each_char do |char|\n    \
    \  case char\n      when '('\n        stack.push(char)\n        current_depth\
    \ += 1\n        max_depth = current_depth if current_depth > max_depth\n     \
    \ when ')'\n        stack.pop\n        current_depth -= 1\n      end\n    end\n\
    \    max_depth\n  end\nend", "  output = []\n  paren_string.split.each do |paren|\n\
    \    count = 0\n    max_count = 0\n    paren.split('').each do |c|\n      if c\
    \ == '('\n        count += 1\n      elsif c == ')'\n        count -= 1\n     \
    \ end\n      max_count = count if count > max_count\n    end\n    output << max_count\n\
    \  end\n  output\nend", "    parentheses = paren_string.split(' ')\n    nested_parens\
    \ = []\n    max_nested = 0\n    count = 0\n    parentheses.each do |paren|\n \
    \       count = 0\n        paren.split('').each do |char|\n            if char\
    \ == '('\n                count += 1\n            elsif char == ')'\n        \
    \        count -= 1\n            end\n        end\n        if count > max_nested\n\
    \            max_nested = count\n        end\n    end\n    nested_parens.push(max_nested)\n\
    \    nested_parens\nend", "  max_nesting = 0\n  current_nesting = 0\n  deepest_levels\
    \ = []\n  paren_string.split(' ').each do |pairs|\n    parens = pairs.split('')\n\
    \    parens.each do |paren|\n      if paren == '('\n        current_nesting +=\
    \ 1\n      elsif paren == ')'\n        current_nesting -= 1\n      end\n     \
    \ max_nesting = current_nesting if current_nesting > max_nesting\n    end\n  \
    \  deepest_levels << max_nesting\n    max_nesting = 0\n    current_nesting = 0\n\
    \  end\n  deepest_levels\nend", "  # TODO\nend", "  list_parens = paren_string.split()\n\
    \  puts list_parens\n  counter = 0\n  max_parens = 0\n  list_parens.each do |parens|\n\
    \    if parens == '('\n      counter += 1\n    elsif parens == ')'\n      counter\
    \ -= 1\n    end\n    if counter > max_parens\n      max_parens = counter\n   \
    \ end\n  end\n  puts max_parens\nend", "    # Write your code here\n    paren_string\
    \ = paren_string.delete(' ')\n    max_level = Array.new\n    i = 0\n    while\
    \ i < paren_string.length\n        if paren_string[i] == '('\n            level\
    \ = 1\n            j = i+1\n            while j < paren_string.length\n      \
    \          if paren_string[j] == '('\n                    level += 1\n       \
    \         elsif paren_string[j] == ')'\n                    level -= 1\n     \
    \           end\n                if level == 0\n                    break\n  \
    \              end\n                j += 1\n            end\n            max_level.push(level)\n\
    \            i = j\n        end\n        i += 1\n    end\n    return max_level\n\
    end", "  # Time complexity: O(n)\n  # Space complexity: O(n)\n  max_depths = []\n\
    \  current_depth = 0\n  max_depth = 0\n  start_paren = '('\n  end_paren = ')'\n\
    \  paren_string.each_char do |char|\n    if char == start_paren\n      current_depth\
    \ += 1\n      max_depth = current_depth if current_depth > max_depth\n    elsif\
    \ char == end_paren\n      max_depths << max_depth if char == end_paren\n    \
    \  current_depth -= 1\n      max_depth = current_depth if current_depth > max_depth\n\
    \    end\n  end\n  max_depths\nend", "  paren_string.split.map do |group|\n  \
    \  paren_parens = group.split('').select { |x| x == '(' || x == ')' }\n    levels\
    \ = 0\n    max_levels = 0\n    paren_parens.each do |paren|\n      if paren ==\
    \ '('\n        levels += 1\n      else\n        levels -= 1\n      end\n     \
    \ max_levels = levels if levels > max_levels\n    end\n    max_levels\n  end\n\
    end", "  paren_string.split(' ').map do |p|\n    result = 0\n    p.chars.each\
    \ do |char|\n      result += 1 if char == '('\n      result -= 1 if char == ')'\n\
    \    end\n    result\n  end\nend", "  #write your code here\n  #expected output:\
    \ [2, 3, 1, 3]\nend\n```", "  max_depth = []\n  stack = []\n  (0...paren_string.length).each\
    \ do |i|\n    current_char = paren_string[i]\n    if current_char == '('\n   \
    \   stack.push(current_char)\n    elsif current_char == ')'\n      stack.pop\n\
    \    elsif current_char == ' '\n      max_depth.push(stack.length)\n    end\n\
    \  end\n  max_depth\nend", "  paren_string.split(\" \").map do |substr|\n    prev_paren_type\
    \ = nil\n    deepest_level = 0\n    curr_level = 0\n    substr.each_char do |paren|\n\
    \      if prev_paren_type.nil?\n        prev_paren_type = paren\n        curr_level\
    \ += 1\n      elsif prev_paren_type == \"(\" && paren == \")\"\n        curr_level\
    \ -= 1\n      elsif prev_paren_type == \")\" && paren == \"(\"\n        curr_level\
    \ += 1\n      end\n      deepest_level = curr_level if curr_level > deepest_level\n\
    \      prev_paren_type = paren\n    end\n    deepest_level\n  end\nend", "  max_depth\
    \ = 0\n  max_depth_list = []\n  paren_string.each_char do |paren|\n    if paren\
    \ == '('\n      max_depth += 1\n    elsif paren == ')'\n      max_depth_list <<\
    \ max_depth\n      max_depth = 0\n    end\n  end\n  max_depth_list\nend", "  results\
    \ = []\n  arr = paren_string.split(' ')\n  arr.each do |string|\n    results <<\
    \ string.scan(/\\(/).length - string.scan(/\\)/).length\n  end\n  results\nend",
  "  paren_string.split.map { |paren| paren.count('(') - paren.count(')') }\nend",
  "  paren_groups = paren_string.split(' ')\n  depth_array = []\n  paren_groups.each\
    \ do |group|\n    depth = 0\n    max_depth = 0\n    group.split('').each do |character|\n\
    \      if character == '('\n        depth += 1\n      elsif character == ')'\n\
    \        depth -= 1\n      end\n      max_depth = depth if depth > max_depth\n\
    \    end\n    depth_array << max_depth\n  end\n  depth_array\nend", "  paren_string.split('\
    \ ').map { |paren_group| get_nesting_depth(paren_group) }\nend", "\tparen_arr\
    \ = paren_string.split(' ')\n\tsolution = []\n\tparen_arr.each do |string|\n\t\
    \tsolution << find_deepest_level(string)\n\tend\n\treturn solution\nend", "  max_nesting\
    \ = []\n  paren_string.split.each do |paren_string|\n    nest_level = 0\n    max_nest\
    \ = 0\n    paren_string.each_char do |ch|\n      if ch == '('\n        nest_level\
    \ += 1\n      elsif ch == ')'\n        nest_level -= 1\n      end\n      max_nest\
    \ = nest_level if nest_level > max_nest\n    end\n    max_nesting << max_nest\n\
    \  end\n  max_nesting\nend", "  paren_string.split(\" \").map { |str|\n    paren_level\
    \ = 0\n    max_level = 0\n    str.each_char { |c|\n      if c == \"(\"\n     \
    \   paren_level += 1\n        max_level = paren_level if paren_level > max_level\n\
    \      elsif c == \")\"\n        paren_level -= 1\n      end\n    }\n    max_level\n\
    \  }\nend", "  max_level = 0\n  current_level = 0\n  max_levels = []\n  paren_string.chars.each\
    \ do |paren|\n    if paren == '('\n      current_level += 1\n      max_level =\
    \ current_level if current_level > max_level\n    elsif paren == ')'\n      max_levels\
    \ << max_level\n      current_level -= 1\n      max_level = current_level\n  \
    \  elsif paren == ' '\n      max_levels << max_level\n      max_level = 0\n  \
    \    current_level = 0\n    end\n  end\n  max_levels\nend", "  arr = paren_string.split(\"\
    \ \")\n  result = []\n  i = 0\n  while i < arr.length\n    first_paren_index =\
    \ arr[i].index(\"(\")\n    last_paren_index = arr[i].rindex(\")\")\n    str =\
    \ arr[i][first_paren_index+1..last_paren_index-1]\n    counter = 0\n    max =\
    \ 0\n    k = 0\n    while k < str.length\n      if str[k] == \"(\"\n        counter\
    \ = counter + 1\n      elsif str[k] == \")\"\n        counter = counter - 1\n\
    \      end\n      if counter > max\n        max = counter\n      end\n      k\
    \ = k + 1\n    end\n    result << max\n    i = i + 1\n  end\n  return result\n\
    end", "\tarr = []\n\tdepth = 0\n\topen = 0\n\tparen_string.each_char do |c|\n\t\
    \tif c == '('\n\t\t\topen += 1\n\t\t\tdepth += 1\n\t\telsif c == ')'\n\t\t\topen\
    \ -= 1\n\t\t\tif open == 0\n\t\t\t\tarr << depth\n\t\t\t\tdepth = 0\n\t\t\tend\n\
    \t\tend\n\tend\n\tarr\nend", "  # return 0 if paren_string.empty?\n  paren_string.split('\
    \ ').map { |parens| count_deepest_nesting(parens) }\nend", "  # TODO: Implement\
    \ this.\n  # NOTE: I think the problem boils down to counting the depth of each\
    \ subgroup.\n  # Parse string into groups.\n  # Split on space, then parse each\
    \ group as an array.\n  # Find the max depth of a group.\n  # return an array\
    \ of depths.\n  depths = paren_string.split(' ').map do |paren_group|\n    max_depth\
    \ = 0\n    stack = []\n    paren_group.each_char do |char|\n      if char == '('\n\
    \        stack.push(char)\n        max_depth = stack.length if stack.length >\
    \ max_depth\n      elsif char == ')'\n        stack.pop\n      end\n    end\n\
    \    max_depth\n  end\n  depths\nend", "  paren_string.split.map do |token|\n\
    \    token.scan(/\\(/).count\n  end\nend", "  paren_string.split(' ').map { |s|\
    \ parse_parens(s).last }\nend", "  list_of_max_levels = []\n  current_max_level\
    \ = 0\n  current_level = 0\n  #parse_parens_list = paren_string.split(' ')\n \
    \ paren_string.each_char do |char|\n    if char == '('\n      current_level +=\
    \ 1\n      if current_level > current_max_level\n        current_max_level = current_level\n\
    \      end\n    elsif char == ')'\n      current_level -= 1\n    elsif char ==\
    \ ' '\n      list_of_max_levels << current_max_level\n      current_max_level\
    \ = 0\n      current_level = 0\n    end\n  end\n  list_of_max_levels << current_max_level\n\
    \  return list_of_max_levels\nend", "  results = []\n  paren_string.split(' ').each\
    \ do |paren_group|\n    current_max = 0\n    current_count = 0\n    paren_group.each_char\
    \ do |ch|\n      if ch == '('\n        current_count += 1\n        current_max\
    \ = current_count if current_count > current_max\n      elsif ch == ')'\n    \
    \    current_count -= 1\n      end\n    end\n    results << current_max\n  end\n\
    \  results\nend", "  raise NotImplementedError\nend", "    max_levels = []\n \
    \   paren_groups = paren_string.split(' ')\n    paren_groups.each do |group|\n\
    \        if group.count('(') == group.count(')')\n            if group[0] == '('\
    \ && group[-1] == ')'\n                max_levels << 0\n            else\n   \
    \             max_levels << -1\n            end\n        else\n            max_levels\
    \ << -1\n        end\n    end\n    return max_levels\nend", end, "  # Levels =\
    \ []\n  # paren_string.split(' ').each do |i|\n  #   level = 0\n  #   max_level\
    \ = 0\n  #   i.each_char do |char|\n  #     if char == '('\n  #       level +=\
    \ 1\n  #     elsif char == ')'\n  #       level -= 1\n  #     end\n  #     max_level\
    \ = level if level > max_level\n  #   end\n  #   Levels << max_level\n  # end\n\
    \  # Levels\n  paren_string.split(' ').map do |paren|\n    paren.chars.reduce(0)\
    \ do |max_level, paren|\n      if paren == '('\n        max_level += 1\n     \
    \ elsif paren == ')'\n        max_level -= 1\n      end\n      max_level\n   \
    \ end\n  end\nend", "  # TODO\nend", "  output = []\n  paren_string.split(\" \"\
    ).each do |paren|\n    count = 0\n    max_count = 0\n    paren.each_char do |c|\n\
    \      if c == \"(\"\n        count += 1\n        max_count = count if count >\
    \ max_count\n      elsif c == \")\"\n        count -= 1\n      end\n    end\n\
    \    output << max_count\n  end\n  output\nend", "  paren_string.split.map do\
    \ |paren_group|\n    max_level = 0\n    level = 0\n    for paren in paren_group.chars\n\
    \      if paren == '('\n        level += 1\n        max_level = level if level\
    \ > max_level\n      elsif paren == ')'\n        level -= 1\n      end\n    end\n\
    \    max_level\n  end\nend", "\tnested_depth = []\n\tnesting_level = 0\n\tparen_string.each_char\
    \ do |char|\n\t\tcase char\n\t\twhen '('\n\t\t\tnesting_level += 1\n\t\twhen ')'\n\
    \t\t\tnesting_level -= 1\n\t\twhen ' '\n\t\t\tnested_depth << nesting_level\n\t\
    \t\tnesting_level = 0\n\t\tend\n\tend\n\tnested_depth\nend", "    # Write your\
    \ code here!\nend", "  paren_string.split(' ').map { |e| e.count('(') }\nend",
  "    paren_string.split(' ').map do |paren|\n        max_depth = 0\n        current_depth\
    \ = 0\n        paren.each_char do |c|\n            if c == '('\n             \
    \   current_depth += 1\n                max_depth = current_depth if current_depth\
    \ > max_depth\n            elsif c == ')'\n                current_depth -= 1\n\
    \            end\n        end\n        max_depth\n    end\nend", "  depth = 0\n\
    \  max_depth = 0\n  output = []\n  i = 0\n  j = 0\n  paren_string.each_char do\
    \ |char|\n    if char == '('\n      depth += 1\n      max_depth = depth if depth\
    \ > max_depth\n    elsif char == ')'\n      depth -= 1\n    end\n    if char ==\
    \ ' '\n      output << max_depth\n      max_depth = 0\n      depth = 0\n    end\n\
    \  end\n  output << max_depth\n  output\nend", "  #\n  paren_string = paren_string.split(\"\
    \ \")\n  retval = []\n  paren_string.each do |paren|\n    retval << max_nesting(paren)\n\
    \  end\n  retval\nend", "  paren_string.split(' ').map do |paren|\n    deepest_level(paren)\n\
    \  end\nend", "  paren_string.gsub!(/[^()]/, '')\n  # print paren_string\n  paren_string.gsub!(/\\\
    (\\)/, '') until paren_string.index('()').nil?\n  paren_string.length\nend", " \
    \ result = []\n  (0...paren_string.length).each do |i|\n    if paren_string[i]\
    \ == '('\n      # keep track of max depth of paren nesting\n      count = 0\n\
    \      # j keeps track of inner-most pair of parens\n      j = i\n      while\
    \ i < paren_string.length\n        if paren_string[i] == '('\n          count\
    \ += 1\n        elsif paren_string[i] == ')'\n          count -= 1\n        end\n\
    \        # if count is zero, that means we've gotten to the end of the current\
    \ group\n        if count == 0\n          break\n        end\n        i += 1\n\
    \      end\n      # add the biggest count for current group to the result\n  \
    \    result << count\n    end\n  end\n  result\nend", "  arr = paren_string.split('\
    \ ')\n  max_count = []\n  arr.each do |string|\n    max_count << 0\n    max_count\
    \ << 0\n    string.each_char do |char|\n      if char == '('\n        max_count\
    \ << max_count.pop + 1\n      elsif char == ')'\n        max_count.pop\n     \
    \ end\n    end\n  end\n  max_count.uniq\nend", "  nested_levels = []\n  paren_string.split(\"\
    \ \").each do |paren|\n    level = 0\n    max_level = 0\n    paren.split(\"\"\
    ).each do |letter|\n      if letter == \"(\"\n        level += 1\n      elsif\
    \ letter == \")\"\n        level -= 1\n      end\n      max_level = level if level\
    \ > max_level\n    end\n    nested_levels << max_level\n  end\n  nested_levels\n\
    end", "  result = []\n  paren_string.split(\" \").each do |paren_string|\n   \
    \ result << (paren_string.chars.select { |char| char == \"(\" }.length - paren_string.chars.select\
    \ { |char| char == \")\" }.length) / 2\n  end\n  result\nend", '  # TODO: Implement
    me', "  result = []\n  # use regex to match parentheses in groups\n  paren_string.scan(/\\\
    ((.*?)\\)/) do |matched_parens|\n    # track nested parentheses using a stack\
    \ data structure\n    stack = []\n    current_nested_parens = 0\n    # iterate\
    \ over each character of the matched parentheses to detect the opening and closing\
    \ of nested parentheses\n    matched_parens[0].each_char do |paren|\n      # for\
    \ an opening parentheses, we increment the nest level and push the nest level\
    \ to the stack\n      if paren == '('\n        current_nested_parens += 1\n  \
    \      stack.push(current_nested_parens)\n      else\n        # for a closing\
    \ parentheses, we pop the stack to decrement the nest level\n        stack.pop\n\
    \      end\n    end\n    # the deepest level of nesting is the last element in\
    \ the stack\n    result.push(stack.last)\n  end\n  result\nend", "  paren_string.split('\
    \ ').map { |s| count_nested_parens(s) }\nend", "  paren_string.split.map do |parens|\n\
    \    count = 0\n    max_count = 0\n    parens.each_char do |c|\n      if c ==\
    \ '('\n        count += 1\n        max_count = count if count > max_count\n  \
    \    elsif c == ')'\n        count -= 1\n      end\n    end\n    max_count\n \
    \ end\nend", " \nend", "  paren_string.split(\" \").map do |paren_group|\n   \
    \ depth = 0\n    max_depth = 0\n    paren_group.each_char do |char|\n      if\
    \ char == \"(\"\n        depth += 1\n        max_depth = depth if depth > max_depth\n\
    \      elsif char == \")\"\n        depth -= 1\n      end\n    end\n    max_depth\n\
    \  end\nend", "  paren_string.split.map do |parens|\n    parens.scan(/\\(/).size\n\
    \  end\nend", "  levels = []\n  result = 0\n  paren_string.each_char do |char|\n\
    \    if char == '('\n      result += 1\n    elsif char == ')'\n      result -=\
    \ 1\n    elsif char == ' '\n      levels << result\n      result = 0\n    end\n\
    \  end\n  levels << result\n  levels\nend", "  result = []\n  i = 0\n  until i\
    \ == paren_string.length\n    nest_count = 0\n    while paren_string[i] != ' '\n\
    \      nest_count += 1 if paren_string[i] == '('\n      nest_count -= 1 if paren_string[i]\
    \ == ')'\n      i += 1\n    end\n    result << nest_count\n    i += 1\n  end\n\
    \  result\nend", "  raise NotImplementedError\nend", "  # Let's start with an\
    \ empty array\n  paren_levels = []\n  # Now we need to split the paren_string\
    \ with spaces, so we get an array of strings representing each group\n  paren_groups\
    \ = paren_string.split(\" \")\n  # Now we need to iterate through this array of\
    \ groups and find the level of nesting for each\n  paren_groups.each do |paren_group|\n\
    \    # We start with a level of zero\n    paren_level = 0\n    # Now we need to\
    \ iterate through each character in the group\n    paren_group.each_char do |paren|\n\
    \      # Every time we encounter an open parenthesis, we increment our level\n\
    \      paren_level += 1 if paren == \"(\"\n      # Every time we encounter a closed\
    \ parenthesis, we decrement our level\n      paren_level -= 1 if paren == \")\"\
    \n    end\n    # Finally, we add our max level to the array\n    paren_levels\
    \ << paren_level\n  end\n  # And then return that array\n  paren_levels\nend",
  "  groups = paren_string.split\n  groups.map { |g| parse_nested_parens_group(g)\
    \ }\nend", "  paren_string.split(' ').map do |group|\n    depth = 0\n    deepest\
    \ = 0\n    group.each_char do |c|\n      if c == '('\n        depth += 1\n   \
    \     deepest = depth if depth > deepest\n      elsif c == ')'\n        depth\
    \ -= 1\n      end\n    end\n    deepest\n  end\nend", "  paren_string.split('\
    \ ').map do |paren|\n    deepest_nesting(paren)\n  end\nend", "  paren_string.split(\"\
    \ \").map { |x| x.scan(/\\(/).count }\nend", "  # e.g. (()()) ((())) () ((())()())\n\
    \  # split on spaces\n  # ['(()())', '((()))', '()', '((())()())']\n  paren_string.split.map\
    \ do |parens|\n    # iterate through each set of parens and count the opening\
    \ parens\n    count = 0\n    max_count = 0\n    parens.each_char do |char|\n \
    \     if char == '('\n        count += 1\n        max_count = count if count >\
    \ max_count\n      elsif char == ')'\n        count -= 1\n      end\n    end\n\
    \    max_count\n  end\nend", "  paren_string.split.map { |x| x.count('(') }\n\
    end", "  paren_string.split.map { |paren_group| paren_group.count('(') }\nend",
  "  deepest_nesting = []\n  paren_string.split(' ').each do |paren_group|\n    max_nesting\
    \ = 0\n    current_nesting = 0\n    paren_group.each_char do |char|\n      current_nesting\
    \ += 1 if char == '('\n      current_nesting -= 1 if char == ')'\n      max_nesting\
    \ = current_nesting if current_nesting > max_nesting\n    end\n    deepest_nesting\
    \ << max_nesting\n  end\n  deepest_nesting\nend", "\tparen_arr = paren_string.split('\
    \ ')\n\tparen_arr.map do |str|\n\t\tstr.count('(') - str.count(')')\n\tend\nend",
  "  paren_string.split(' ').map { |string| string.scan(/\\(/).count }\nend", "  max_levels\
    \ = []\n  current_level = 0\n  max_level = 0\n  paren_string.each_char do |c|\n\
    \    if c == '('\n      current_level += 1\n      max_level = current_level if\
    \ current_level > max_level\n    elsif c == ')'\n      current_level -= 1\n  \
    \  elsif c == ' '\n      max_levels << max_level\n      max_level = 0\n      current_level\
    \ = 0\n    end\n  end\n  max_levels << max_level\n  max_levels\nend", "  result\
    \ = []\n  paren_string.split(' ').each do |paren_group|\n    open_count = 0\n\
    \    max_open_count = 0\n    paren_group.each_char do |c|\n      if c == '('\n\
    \        open_count += 1\n        max_open_count = open_count if open_count >\
    \ max_open_count\n      elsif c == ')'\n        open_count -= 1\n      end\n \
    \   end\n    result << max_open_count\n  end\n  result\nend", "  paren_array =\
    \ paren_string.split(' ')\n  result = []\n  paren_array.each do |paren|\n    count\
    \ = 0\n    if paren[0] == '('\n      count += 1\n      while paren[count] == '('\n\
    \        count += 1\n      end\n    end\n    result << count\n  end\n  result\n\
    end", "  max_depth = []\n  paren_string.split.each do |substring|\n    depth =\
    \ 0\n    max_depth_substring = 0\n    substring.each_char do |char|\n      if\
    \ char == '('\n        depth += 1\n      elsif char == ')'\n        depth -= 1\n\
    \      end\n      max_depth_substring = depth if depth > max_depth_substring\n\
    \    end\n    max_depth << max_depth_substring\n  end\n  max_depth\nend", "\t\
    # Split the string on spaces\n\tparen_string.split(\" \").map{|group|\n\t\t# A\
    \ stack is used to keep track of the current nesting level\n\t\t# Each time an\
    \ opening paren is encountered, push the current nesting level onto the stack.\n\
    \t\t# When a closing paren is encountered, pop the last entry from the stack and\
    \ decrement it.\n\t\t# This will give the deepest level of nesting of the group.\n\
    \t\tstack = []\n\t\tgroup.split(\"\").each{|char|\n\t\t\tif char == \"(\"\n\t\t\
    \t\tstack.push(stack.empty? ? 1 : stack.last + 1)\n\t\t\telsif char == \")\"\n\
    \t\t\t\tstack.pop\n\t\t\tend\n\t\t}\n\t\tstack.last || 0\n\t}\nend", "\t# Your\
    \ code here\n\t#count = 0\n\tparen_string.scan(/\\(\\)/).count\nend", "  paren_string.split.map\
    \ do |group|\n    count = 0\n    max_count = 0\n    group.each_char do |paren|\n\
    \      if paren == '('\n        count += 1\n        max_count = count if count\
    \ > max_count\n      elsif paren == ')'\n        count -= 1\n      end\n    end\n\
    \    max_count\n  end\nend", "  res = []\n  paren_string.split(' ').each do |paren_group|\n\
    \    if paren_group.start_with?('(')\n      paren_group = paren_group[1..-2] #\
    \ remove outer parentheses\n      level = 1\n      max_level = 0\n      pos =\
    \ 0\n      while pos < paren_group.length\n        if paren_group[pos] == '('\n\
    \          level += 1\n        elsif paren_group[pos] == ')'\n          level\
    \ -= 1\n        end\n        max_level = [max_level, level].max\n        pos +=\
    \ 1\n      end\n      res << max_level\n    else\n      res << 0\n    end\n  end\n\
    \  res\nend", "  paren_string.split.map { |paren_group| paren_group.count('(')\
    \ }\nend", "  result = []\n  i = 0\n  while i < paren_string.length\n    if paren_string[i]\
    \ == '('\n      depth = 0\n      depth += 1\n      i += 1\n      while paren_string[i]\
    \ != ')'\n        if paren_string[i] == '('\n          depth += 1\n        end\n\
    \        i += 1\n      end\n      result << depth\n    end\n    i += 1\n  end\n\
    \  result\nend", "  # this will keep track of the number of nested parens for\
    \ each group\n  out = []\n  # this will store every open parens, and every close\
    \ parens will be\n  # popped off until we hit an empty array\n  stack = []\n \
    \ # we don't want to keep track of the last index, so we iterate up to\n  # length\
    \ - 1\n  (0...paren_string.length - 1).each do |i|\n    # we only want to do anything\
    \ for open parens\n    if paren_string[i] == '('\n      # if the next character\
    \ is an open parens, we need to increment the\n      # count\n      if paren_string[i\
    \ + 1] == '('\n        stack.push(paren_string[i])\n      # if the next character\
    \ is a close parens, we still need to push onto\n      # the stack, but we don't\
    \ increment the count\n      elsif paren_string[i + 1] == ')'\n        stack.push(paren_string[i])\n\
    \      end\n    # if we have a close parens, we need to pop off the top of the\
    \ stack and\n    # decrement the count\n    elsif paren_string[i] == ')'\n   \
    \   stack.pop\n    # if we hit a space, we will clear the array and start over\n\
    \    elsif paren_string[i] == ' '\n      out.push(stack.length)\n      stack =\
    \ []\n    end\n  end\n  # we need to make sure we account for the last group of\
    \ parens\n  out.push(stack.length)\n  out\nend", "  paren_string.split(' ').map\
    \ { |string| string.count('(') - string.count(')') }\nend", "  paren_string.split('\
    \ ').map do |word|\n    current_count = 0\n    max_count = 0\n    word.chars.each\
    \ do |c|\n      if c == '('\n        current_count += 1\n        max_count = current_count\
    \ if current_count > max_count\n      elsif c == ')'\n        current_count -=\
    \ 1\n      end\n    end\n    max_count\n  end\nend", "\tparen_string.split(' ').map\
    \ do |group|\n\t\ti = 0\n\t\tmaximum = 0\n\t\tgroup.chars.each do |char|\n\t\t\
    \tif char == '('\n\t\t\t\ti += 1\n\t\t\t\tmaximum = i if i > maximum\n\t\t\telsif\
    \ char == ')'\n\t\t\t\ti -= 1\n\t\t\tend\n\t\tend\n\t\tmaximum\n\tend\nend", " \
    \ # Create an array to hold the number of levels of nesting for each group\n \
    \ groups = paren_string.split(\" \")\n  result = []\n  # Iterate through each\
    \ group, keeping track of the number of levels of nesting and\n  # the index at\
    \ which the current group starts.\n  groups.each do |group|\n    i = 0\n    level\
    \ = 0\n    max_level = 0\n    until i == group.length\n      if group[i] == \"\
    (\"\n        level += 1\n        max_level = level if level > max_level\n    \
    \  elsif group[i] == \")\"\n        level -= 1\n      end\n      i += 1\n    end\n\
    \    result << max_level\n  end\n  result\nend", "  max_levels = []\n  paren_string.split('\
    \ ').each do |paren|\n    max_levels << max_nested_parens(paren)\n  end\n  max_levels\n\
    end", "  paren_string.split(\" \").map { |paren_group| find_max_depth(paren_group)\
    \ }\nend", "  arr = paren_string.split(\" \")\n  arr.map { |e|\n    e.delete(\"\
    ()\").length\n  }\nend", "  paren_string.split.map do |group|\n    paren_stack\
    \ = 0\n    max_level = 0\n    group.chars.each do |char|\n      paren_stack +=\
    \ 1 if char == '('\n      paren_stack -= 1 if char == ')'\n      max_level = paren_stack\
    \ if paren_stack > max_level\n    end\n    max_level\n  end\nend", "  max_count\
    \ = 0\n  result = []\n  paren_string.split(\" \").each do |paren|\n    paren_array\
    \ = paren.split(\"\")\n    stack = []\n    paren_array.each do |letter|\n    \
    \  if letter == \"(\"\n        stack.push(letter)\n      else\n        stack.pop\n\
    \      end\n    end\n    paren_string.split(\" \").each do |paren2|\n      paren_array2\
    \ = paren2.split(\"\")\n      stack2 = []\n      paren_array2.each do |letter2|\n\
    \        if letter2 == \"(\"\n          stack2.push(letter2)\n        else\n \
    \         stack2.pop\n        end\n      end\n      if stack2.length > max_count\n\
    \        max_count = stack2.length\n      end\n    end\n    result.push(max_count)\n\
    \    max_count = 0\n  end\n  result\nend", "  parse_nested_parens_helper(paren_string,\
    \ 0, 1)\nend", "  # TODO: implement this method\nend", "  max_level = []\n  paren_string.split.each\
    \ do |str|\n    stack = []\n    level = 0\n    str.chars.each do |ch|\n      case\
    \ ch\n      when '('\n        stack.push(ch)\n        level += 1\n      when ')'\n\
    \        stack.pop()\n        level -= 1\n      end\n    end\n    max_level.push(level)\n\
    \  end\n  max_level\nend", "  paren_string.split(' ').map { |s| s.scan(/\\(/).size\
    \ }\nend", "  num_nest = []\n  paren_string.each do |nested_parens|\n    arr =\
    \ nested_parens.split('')\n    paren_counter = 0\n    max_nest = 0\n    arr.each\
    \ do |paren|\n      if paren == '('\n        paren_counter += 1\n      elsif paren\
    \ == ')'\n        paren_counter -= 1\n      end\n      max_nest = paren_counter\
    \ if paren_counter > max_nest\n    end\n    num_nest << max_nest\n  end\n  return\
    \ num_nest\nend", "  result = []\n  paren_string.split.each do |paren|\n    count\
    \ = 0\n    paren.chars.each do |c|\n      count += 1 if c == '('\n      count\
    \ -= 1 if c == ')'\n    end\n    result << count\n  end\n  result\nend", "  array_of_max_nesting\
    \ = []\n  test_array = paren_string.split(\" \")\n  test_array.each do |group|\n\
    \    max_nesting = 0\n    nesting = 0\n    group.each_char do |char|\n      nesting\
    \ += 1 if char == \"(\"\n      nesting -= 1 if char == \")\"\n      max_nesting\
    \ = nesting if nesting > max_nesting\n    end\n    array_of_max_nesting << max_nesting\n\
    \  end\n  return array_of_max_nesting\nend", "  deepest_parens = []\n  paren_array\
    \ = paren_string.scan(/\\((\\w+)?\\)/)", "\t# Your code goes here.\n\tparen_string\
    \ = paren_string.split(' ')\n\tparen_string.map { |x| x.length - x.gsub('(','').length\
    \ }\nend", "  paren_string.split.map { |paren| paren.count('(') - paren.count(')')\
    \ }\nend", "  # Your Code Here\n  # paren_string.split.map { |str| str.count('(')\
    \ - str.count(')') }\n  paren_string.split.map do |str|\n    open_count = 0\n\
    \    max_nesting = 0\n    str.each_char do |char|\n      if char == '('\n    \
    \    open_count += 1\n        max_nesting = open_count if open_count > max_nesting\n\
    \      elsif char == ')'\n        open_count -= 1\n      end\n    end\n    max_nesting\n\
    \  end\nend", "  paren_string.split(' ').map { |paren_group| paren_group.scan(/\\\
    (+/).map(&:length).max }\nend", "  paren_string.split(\" \").map { |e| e.chars.map\
    \ { |e| e == \"(\" ? 1 : -1 }.reduce(:+) }\nend", "  parsed_parens = []\n  paren_string.split('\
    \ ').each do |paren|\n    parsed_parens << paren.count('(')\n  end\n  parsed_parens\n\
    end", "  paren_string.scan(/\\((.*?)\\)/).map { |paren| paren[0].scan(/\\(/).size\
    \ + 1 }\nend", "  #Regexp.last_match(0)\n  paren_string.split(\" \").map { |paren|\
    \ paren.scan(/\\((?:[^()]|\\((?1)\\))*\\)/).size }\nend", "  paren_string.split(\"\
    \ \").map { |p| parse_parens(p) }\nend", "  parenthesis_groups = paren_string.split('\
    \ ')\n  parenthesis_groups.map { |group| group.count('(') - group.count(')') }\n\
    end", "\tparen_string.split(\" \").map do |paren_group|\n\t\tdeepest_nesting(paren_group)\n\
    \tend\nend", "  levels = []\n  paren_string.split(' ').each do |paren_group|\n\
    \    levels << get_nesting_level(paren_group)\n  end\n  levels\nend", "  groups\
    \ = paren_string.split(' ')\n  result = []\n  groups.each do |group|\n    result\
    \ << find_max_nesting(group)\n  end\n  result\nend", "  paren_string.split(' ').map\
    \ { |paren_group|\n    paren_group.count('(') - paren_group.count(')')\n  }\n\
    end", "  paren_string.split.map do |group|\n    max_nesting = 0\n    nesting =\
    \ 0\n    group.chars.each do |ch|\n      if ch == '('\n        nesting += 1\n\
    \        max_nesting = nesting if nesting > max_nesting\n      elsif ch == ')'\n\
    \        nesting -= 1\n      end\n    end\n    max_nesting\n  end\nend", "\treturn\
    \ nil if paren_string.nil?\n\tparen_string = paren_string.gsub(/\\s+/, '')\n\t\
    nums = []\n\tcurr_num = 0\n\tparen_string.each_char do |c|\n\t\tif c == '('\n\t\
    \t\tcurr_num += 1\n\t\telsif c == ')'\n\t\t\tnums << curr_num\n\t\t\tcurr_num\
    \ = 0\n\t\tend\n\tend\n\tnums\nend", "  paren_string.split(' ').map { |x| x.count('(')\
    \ - x.count(')') }\nend", "  paren_string.split(' ').map { |paren| paren.length\
    \ / 2 }\nend", "  results = []\n  paren_string.split(' ').each do |paren_group|\n\
    \    depth = 0\n    max_depth = 0\n    paren_group.split('').each do |char|\n\
    \      if char == '('\n        depth += 1\n        max_depth = depth if depth\
    \ > max_depth\n      elsif char == ')'\n        depth -= 1\n      end\n    end\n\
    \    results << max_depth\n  end\n  results\nend", "  paren_string.split(' ').map\
    \ { |paren|\n    opens = 0\n    max_opens = 0\n    paren.each_char do |char|\n\
    \      if char == '('\n        opens += 1\n        max_opens = opens if opens\
    \ > max_opens\n      elsif char == ')'\n        opens -= 1\n      end\n    end\n\
    \    max_opens\n  }\nend", "  paren_string.split(\" \").map { |str| get_max_levels(str)\
    \ }\nend", "  paren_string.split(\" \").map do |str|\n    depth = 0\n    max_depth\
    \ = 0\n    str.each_char do |c|\n      if c == \"(\"\n        depth += 1\n   \
    \     max_depth = depth if depth > max_depth\n      elsif c == \")\"\n       \
    \ depth -= 1\n      end\n    end\n    max_depth\n  end\nend", "  paren_string.split.map\
    \ do |phrase|\n    count = 0\n    max_count = 0\n    phrase.each_char do |char|\n\
    \      case char\n      when '('\n        count += 1\n        max_count = count\
    \ if count > max_count\n      when ')'\n        count -= 1\n      end\n    end\n\
    \    max_count\n  end\nend", "  paren_string.split.map do |parens|\n    parens.chars.reduce(0)\
    \ do |acc, char|\n      if char == '('\n        acc += 1\n      elsif char ==\
    \ ')'\n        acc -= 1\n      end\n      acc\n    end\n  end\nend", "\t#paren_array\
    \ = paren_string.split(\" \")\n\tparen_array = paren_string.scan(/\\(([^)]+)\\\
    )/)\n\t#paren_array = paren_string.split(/\\(([^)]+)\\)/)\n\t# paren_array = paren_string.split(\"\
    \ \")\n\t# paren_array = paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array =\
    \ paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array = paren_string.scan(/\\\
    (([^)]+)\\)/)\n\t# paren_array = paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array\
    \ = paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array = paren_string.scan(/\\\
    (([^)]+)\\)/)\n\t# paren_array = paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array\
    \ = paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array = paren_string.scan(/\\\
    (([^)]+)\\)/)\n\t# paren_array = paren_string.scan(/\\(([^)]+)\\)/)\n\t# paren_array\
    \ = paren_string.scan(/\\(([^)]+)\\)/)\n\tparen_array.each do |paren|\n\t\twhile\
    \ paren != nil\n\t\t\tparen = paren.scan(/\\(([^)]+)\\)/)\n\t\t\tp paren.length\n\
    \t\tend\n\tend\nend", "  paren_string.split.map do |string|\n    string.count\
    \ '('\n  end\nend", "  paren_string.split(\" \").map do |element|\n    deepest_nesting(element)\n\
    \  end\nend", "  paren_arr = paren_string.split(' ')\n  paren_arr.map do |paren|\n\
    \    next if paren.empty?\n    paren_arr = paren.split('')\n    depth = 0\n  \
    \  max_depth = 0\n    paren_arr.each do |char|\n      if char == '('\n       \
    \ depth += 1\n        max_depth = depth if depth > max_depth\n      elsif char\
    \ == ')'\n        depth -= 1\n      end\n    end\n    max_depth\n  end\nend",
  end, "  paren_string.split(' ').map do |group|\n    # TODO: Return the appropriate\
    \ number from this group\n    1\n  end\nend", "\tparen_string.split(' ').map {\
    \ |element| get_deepest_nesting(element) }\nend", end, "  paren_string.split('\
    \ ').map do |paren|\n    split_paren = paren.split('')\n    max_depth = 0\n  \
    \  current_depth = 0\n    split_paren.each do |character|\n      if character\
    \ == '('\n        current_depth += 1\n        max_depth = current_depth if current_depth\
    \ > max_depth\n      elsif character == ')'\n        current_depth -= 1\n    \
    \  end\n    end\n    max_depth\n  end\nend", "  paren_string.scan(/\\(+\\)/).map{|k|\
    \ k.length}.to_a\nend", "  # TODO: your code here\nend", "\tparen_string.split.map\
    \ { |s| s.gsub(/[^\\(\\)]/, '').chars.count('(') }\nend", "  paren_string.split.map\
    \ { |paren_group| level_of_nesting(paren_group) }\nend", "  paren_string.split('\
    \ ').map { |paren_group| \n    max_nesting = 0\n    current_nesting = 0\n    paren_group.each_char\
    \ do |char|\n      if char == '('\n        current_nesting += 1\n        max_nesting\
    \ = current_nesting if current_nesting > max_nesting\n      elsif char == ')'\n\
    \        current_nesting -= 1\n      end\n    end\n    max_nesting\n  }\nend",
  "  pairs = paren_string.split(' ')\n  levels = []\n  pairs.each do |pair|\n    count\
    \ = 0\n    pair.split('').each do |char|\n      count += 1 if char == '('\n  \
    \    count -= 1 if char == ')'\n    end\n    levels << count\n  end\n  levels\n\
    end", "  paren_string.split.map do |parens|\n    deepest_paren_level(parens)\n\
    \  end\nend", "  paren_string.split(' ').map { |word| word.chars.select { |char|\
    \ char == '(' }.count }\nend", "    array = paren_string.split(' ')\n    array.map\
    \ { |group| \n        stack = []\n        max_depth = 0\n        group.each_char\
    \ do |char|\n            if char == '('\n                stack.push(char)\n  \
    \              if stack.length > max_depth\n                    max_depth = stack.length\n\
    \                end\n            elsif char == ')'\n                stack.pop\n\
    \            end\n        end\n        max_depth\n    }\nend", "  paren_string.split('\
    \ ').map { |s| s.count('(') }\nend", "    parsed_array = []\n    paren_string.split(\"\
    \ \").each do |paren|\n        if (paren.include? \"(\")\n            parsed_array\
    \ << paren.count('(')\n        else\n            parsed_array << 0\n        end\n\
    \    end\n    return parsed_array\nend", "\tparen_array = paren_string.split('\
    \ ')\n\toutput = []\n\tparen_array.each do |string|\n\t\toutput << max_depth(string)\n\
    \tend\n\toutput\nend", "  paren_string.split.map do |group|\n    max_depth = 0\n\
    \    current_depth = 0\n    group.each_char do |c|\n      current_depth += 1 if\
    \ c == '('\n      current_depth -= 1 if c == ')'\n      max_depth = current_depth\
    \ if current_depth > max_depth\n    end\n    max_depth\n  end\nend", "  paren_string.split('\
    \ ').map do |par|\n    max_depth = 0\n    current_depth = 0\n    par.chars.each\
    \ do |ch|\n      if ch == '('\n        current_depth += 1\n        max_depth =\
    \ current_depth if current_depth > max_depth\n      elsif ch == ')'\n        current_depth\
    \ -= 1\n      end\n    end\n    max_depth\n  end\nend", "  paren_string.split('\
    \ ').map { |group| group.count('(') - group.count(')') }\nend", "  paren_string.scan(/\\\
    ((\\(|\\))+\\)/).map do |paren_group|\n    paren_group.first.count('(')\n  end\n\
    end", "  paren_groups = paren_string.split(' ')\n  deepest_levels = []\n  paren_groups.each\
    \ do |group|\n    depth = 0\n    max_depth = 0\n    group.each_char do |char|\n\
    \      if char == '('\n        depth += 1\n      elsif char == ')'\n        max_depth\
    \ = depth if depth > max_depth\n        depth -= 1\n      end\n    end\n    deepest_levels\
    \ << max_depth\n  end\n  deepest_levels\nend", "  result = []\n  paren_string.split('\
    \ ').each do |item|\n    count = 0\n    item.each_char do |char|\n      count\
    \ += 1 if char == '('\n      count -= 1 if char == ')'\n    end\n    result <<\
    \ count\n  end\n  result\nend", "  answer = []\n  groups = paren_string.split('\
    \ ')\n  groups.each do |group|\n    level = 0\n    max_level = 0\n    group.each_char\
    \ do |paren|\n      if paren == '('\n        level += 1\n      elsif paren ==\
    \ ')'\n        level -= 1\n      end\n      max_level = level if level > max_level\n\
    \    end\n    answer << max_level\n  end\n  answer\nend", "  paren_string.split('\
    \ ').map do |item|\n    parsed_item = []\n    depth = 0\n    item.each_char do\
    \ |char|\n      if char == '('\n        depth += 1\n      elsif char == ')'\n\
    \        depth -= 1\n      end\n      parsed_item << depth\n    end\n    parsed_item.max\n\
    \  end\nend", "  list_of_parens = paren_string.split(\" \")\n  paren_count = 0\n\
    \  max_count = 0\n  max_count_list = []\n  list_of_parens.each do |parens|\n \
    \   parens.each_char do |char|\n      if char == \"(\"\n        paren_count +=\
    \ 1\n      else\n        paren_count -= 1\n      end\n      if paren_count > max_count\n\
    \        max_count = paren_count\n      end\n    end\n    max_count_list << max_count\n\
    \    max_count = 0\n    paren_count = 0\n  end\n  return max_count_list\nend",
  "  depth = 0\n  max_depth = 0\n  nested_parens = []\n  paren_string.each_char do\
    \ |char|\n    depth += 1 if char == '('\n    depth -= 1 if char == ')'\n    max_depth\
    \ = depth if depth > max_depth\n    if depth == 0\n      nested_parens << max_depth\n\
    \      max_depth = 0\n    end\n  end\n  nested_parens\nend", "  #TODO: parse and\
    \ return a list of integers representing depth of each group\nend", "  result\
    \ = []\n  paren_string.split(\" \").each do |string|\n    result << get_nesting_level(string)\n\
    \  end\n  result\nend", "  deepest_level = []\n  paren_string.split.each do |e|\n\
    \    paren_start = e.count('(')\n    paren_end = e.count(')')\n    if paren_start\
    \ == paren_end\n      deepest_level << paren_start\n    else\n      deepest_level\
    \ << [paren_start, paren_end].min\n    end\n  end\n  deepest_level\nend", "  paren_string.split('\
    \ ').map { |paren_group| paren_group.count('(') }\nend", "    paren_string.split('\
    \ ').map do |item|\n        i = 0\n        count = 0\n        # iterate each character\
    \ of the string\n        while i < item.length\n            # if we find the left\
    \ parenthesis, add 1 to count\n            if item[i] == '('\n               \
    \ count += 1\n            end\n            # if we find the right parenthesis,\
    \ minus 1 to count\n            if item[i] == ')'\n                count -= 1\n\
    \            end\n            i += 1\n        end\n        count.abs # get the\
    \ absolute value of count\n    end\nend", "  paren_string.split(' ').map { |paren_group|\
    \ parse_parens(paren_group) }\nend", "  raise 'Not implemented'\nend", "  # TODO\n\
    end", "  paren_string.split(' ').map { |paren_group| count_parens(paren_group)\
    \ }\nend", "  paren_string.split(' ').map do |paren|\n    # your code here\n \
    \ end\nend", "  paren_string.split(' ').map do |paren|\n    '(' * (paren.length/2)\n\
    \  end\nend", "    res = []\n    subs = paren_string.split(' ')\n    subs.each\
    \ do |sub|\n        count = 0\n        res << parse_one_nested_parens(sub, count)\n\
    \    end\n    res\nend", "  # TODO: implement this\nend", "  paren_string.split('\
    \ ').map { |s| s.count('(') - s.count(')') }\nend", "  paren_string.split(\" \"\
    ).map do |paren_string|\n    nested_parens(paren_string)\n  end\nend", "  groups\
    \ = paren_string.split(' ')\n  max_levels = []\n  groups.each do |group|\n   \
    \ max_levels << count_nested_parens(group)\n  end\n  return max_levels\nend",
  end, "  paren_string.split.map do |group|\n    max_nest = 0\n    nest_count = 0\n\
    \    group.each_char do |char|\n      if char == '('\n        nest_count += 1\n\
    \        max_nest = nest_count if nest_count > max_nest\n      elsif char == ')'\n\
    \        nest_count -= 1\n      end\n    end\n    max_nest\n  end\nend", "  paren_string.split(\"\
    \ \").map { |paren_expr| paren_expr.scan(/\\(/).size }\nend", "  #########################################\n\
    \  ## WRITE YOUR CODE BELOW THIS COMMENT ##\n  #########################################\n\
    end", "  paren_string.split(\" \").map do |e|\n    depth = 0\n    max = 0\n  \
    \  e.chars.each do |c|\n      if c == \"(\"\n        depth += 1\n        max =\
    \ depth if depth > max\n      elsif c == \")\"\n        depth -= 1\n      end\n\
    \    end\n    max\n  end\nend", "  paren_string.split.map do |str|\n    max_count\
    \ = 0\n    level = 0\n    str.chars.each do |ch|\n      if ch == '('\n       \
    \ level += 1\n        max_count = level if level > max_count\n      elsif ch ==\
    \ ')'\n        level -= 1\n      end\n    end\n    max_count\n  end\nend", " \
    \ # TODO: Implement\nend", "  paren_string.split(\" \").map { |group|\n    nest_level\
    \ = 0\n    max_nest_level = 0\n    for i in 0..group.length-1\n      if group[i]\
    \ == \"(\"\n        nest_level += 1\n      elsif group[i] == \")\"\n        nest_level\
    \ -= 1\n      end\n      max_nest_level = nest_level if nest_level > max_nest_level\n\
    \    end\n    max_nest_level\n  }\nend", "  # TODO: Write your code here.\n  paren_string.split(\"\
    \ \").map do |paren|\n    # paren = '(()())'\n    # paren = '(())'\n    max_levels\
    \ = 0\n    current_level = 0\n    paren.each_char do |char|\n      current_level\
    \ += 1 if char == '('\n      current_level -= 1 if char == ')'\n      max_levels\
    \ = current_level if current_level > max_levels\n    end\n    max_levels\n  end\n\
    end", "\tparsed_parens = []\n\tparen_string.split.each do |paren|\n\t\tnested_parens\
    \ = paren.chars.map{|x| x == '(' ? 1 : -1}\n\t\tif nested_parens.inject(:+) !=\
    \ 0\n\t\t\tparsed_parens << \"Invalid\"\n\t\telse\n\t\t\tparsed_parens << nested_parens.inject([])\
    \ {|total,x| total << total.last.to_i + x}.max\n\t\tend\n\tend\n\tparsed_parens\n\
    end", "  parse_nested_parens_helper(paren_string.gsub(' ', ''))\nend", "  count_arr\
    \ = []\n  paren_string.split(' ').each do |parentheses|\n    count = 0\n    current_max\
    \ = 0\n    parentheses.split('').each do |p|\n      count += 1 if p == '('\n \
    \     count -= 1 if p == ')'\n      current_max = count if count > current_max\n\
    \    end\n    count_arr << current_max\n  end\n  count_arr\nend", "  paren_string.split('\
    \ ').map do |str|\n    stack = []\n    max_len = 0\n    str.each_char do |c|\n\
    \      if c == '('\n        stack.push(c)\n        max_len = [max_len, stack.length].max\n\
    \      elsif c == ')'\n        stack.pop\n      end\n    end\n    max_len\n  end\n\
    end", "  # TODO Write function body\n  output = []\n  temp = \"\"\n  paren_string.each_char\
    \ do |x|\n    if x != \" \"\n      temp << x\n    else\n      output << parse_parens(temp)\n\
    \      temp = \"\"\n    end\n  end\n  output << parse_parens(temp)\n  output\n\
    end", "  paren_string.split(' ').map { |paren|\n    paren.chars.reduce(0) { |max,\
    \ p|\n      if p == '('\n        max + 1\n      elsif p == ')'\n        max -\
    \ 1\n      else\n        max\n      end\n    }\n  }\nend", "  paren_string.split('\
    \ ').map do |paren|\n    paren.chars.reduce(0) do |acc, char|\n      acc += 1\
    \ if char == '('\n      acc -= 1 if char == ')'\n      acc = 0 if acc < 0\n  \
    \    acc\n    end\n  end\nend", "  result = []\n  paren_string.split(\" \").each\
    \ do |paren|\n    result << count_levels(paren)\n  end\n  result\nend", "  # Write\
    \ your code here\nend", "  paren_string.split.map do |parens|\n    depth = 0\n\
    \    deepest = 0\n    parens.chars.each do |paren|\n      if paren == '('\n  \
    \      depth += 1\n        deepest = depth if depth > deepest\n      elsif paren\
    \ == ')'\n        depth -= 1\n      end\n    end\n    deepest\n  end\nend", " \
    \   paren_string.split(\" \").map do |string|\n        string.chars.reduce(0)\
    \ do |level, char|\n            if char == \"(\"\n                level += 1\n\
    \            elsif char == \")\"\n                level -= 1\n            end\n\
    \            level\n        end\n    end\nend", "    paren_string.split.map {\
    \ |paren_string| paren_string.scan(/\\(/).count }\nend", "  paren_string.split.map\
    \ { |paren_group| parse_nested_parens_helper(paren_group) }\nend", "  paren_string.split('\
    \ ').map do |s|\n    counter = 0\n    max_counter = 0\n    s.chars.each do |ch|\n\
    \      counter += 1 if ch == '('\n      counter -= 1 if ch == ')'\n      max_counter\
    \ = counter if counter > max_counter\n    end\n    max_counter\n  end\nend", " \
    \ paren_string.split(' ').map do |group|\n    max_depth = 0\n    current_depth\
    \ = 0\n    group.each_char do |char|\n      if char == '('\n        current_depth\
    \ += 1\n        max_depth = current_depth if current_depth > max_depth\n     \
    \ elsif char == ')'\n        current_depth -= 1\n      end\n    end\n    max_depth\n\
    \  end\nend", "  paren_string.split(' ').map { |el| el.split('').select { |char|\
    \ char == '(' }.length }\nend", "  res = []\n  paren_string.split(' ').each do\
    \ |paren_group|\n    level = 0\n    max_level = 0\n    paren_group.split('').each\
    \ do |char|\n      if char == '('\n        level += 1\n        max_level = level\
    \ if level > max_level\n      elsif char == ')'\n        level -= 1\n      end\n\
    \    end\n    res << max_level\n  end\n  res\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
