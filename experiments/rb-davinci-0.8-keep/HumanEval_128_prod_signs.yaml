name: HumanEval_128_prod_signs
language: rb
prompt: "# You are given an array arr of integers and you need to return\n# sum of\
  \ magnitudes of integers multiplied by product of all signs\n# of each number in\
  \ the array, represented by 1, -1 or 0.\n# Note: return None for empty arr.\n# Example:\n\
  # >>> prod_signs([1, 2, 2, -4]) == -9\n# >>> prod_signs([0, 1]) == 0\n# >>> prod_signs([])\
  \ == None\ndef prod_signs(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_prod_signs\n\
  \    candidate = method(:prod_signs)\n    assert_equal(-9, candidate.call([1, 2,\
  \ 2, -4]))\n    assert_equal(0, candidate.call([0, 1]))\n    assert_equal(-10, candidate.call([1,\
  \ 1, 1, 2, 3, -1, 1]))\n    assert_equal(nil, candidate.call([]))\n    assert_equal(20,\
  \ candidate.call([2, 4, 1, 2, -1, -1, 9]))\n    assert_equal(4, candidate.call([-1,\
  \ 1, -1, 1]))\n    assert_equal(-4, candidate.call([-1, 1, 1, 1]))\n    assert_equal(0,\
  \ candidate.call([-1, 1, 1, 0]))\n  end\nend\n"
completions: ["  return nil if arr.empty?\n  product = 1\n  sum = 0\n  arr.each do\
    \ |i|\n    product *= i <=> 0\n    sum += i.abs\n  end\n  product * sum\nend",
  "  return nil if arr.empty?\n  arr.reduce(1) { |acc, x| acc *= x.zero? ? 1 : x <=>\
    \ 0 } * arr.map(&:abs).reduce(:+)\nend", "  if arr.empty?\n    return nil\n  else\n\
    \    multiplier = 1\n    sum = 0\n    arr.each do |n|\n      if n == 0\n     \
    \   multiplier *= 0\n      elsif n < 0\n        multiplier *= -1\n      end\n\
    \      sum += n.abs\n    end\n    sum * multiplier\n  end\nend", "  return nil\
    \ if arr.empty?\n  signs = arr.map { |a| a <=> 0 }\n  magnitudes = arr.map { |a|\
    \ a.abs }\n  signs.inject(:*) * magnitudes.inject(:+)\nend", "  return if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) *\n    arr.map { |num| num.zero? ? 0 :\
    \ num.positive? ? 1 : -1 }.reduce(:*)\nend", "  return nil if arr.empty?\n  #\
    \ write your code here\nend", end, "  return nil if arr.empty?\n  arr.reduce(1)\
    \ { |acc, e| acc * e.abs * (e <=> 0) }\nend", "  arr.empty? ? nil : arr.map {\
    \ |num| Math.sqrt(num.abs) * num.sign }.reduce(:*)\nend", "  # your code here\n\
    end", "  if arr.empty?\n    return nil\n  end\n  new_arr = arr.map { |x| x.abs\
    \ }\n  final_sum = new_arr.inject(:+)\n  new_arr = arr.map { |x| x <=> 0 }\n \
    \ final_product = new_arr.inject(:*)\n  final_sum * final_product\nend", "  if\
    \ arr.empty?\n    nil\n  else\n    product = 1\n    arr.each do |number|\n   \
    \   product *= number <=> 0\n    end\n    arr.map { |number| number.abs }.reduce(:+)\
    \ * product\n  end\nend", "  return nil if arr.empty?\n  sum = 0\n  p = 1\n  arr.each\
    \ do |n|\n    sum += n.abs\n    p *= n.negative? ? -1 : n.zero? ? 0 : 1\n  end\n\
    \  sum * p\nend", "  # Your code here\nend", "  if arr.nil? || arr.empty?\n  \
    \  return nil\n  end\n  prod = arr.reduce(1) { |p, n| p * (n == 0 ? 1 : n <=>\
    \ 0) }\n  prod * arr.map(&:abs).reduce(:+)\nend", "  return nil if arr.empty?\n\
    \  (arr.map(&:abs).sum * arr.select{|x| x != 0}.map(&:sign).inject(:*)).abs\n\
    end", "  return nil if arr.empty?\n  a = arr.select { |x| x > 0 }.inject(:+) ||\
    \ 0\n  b = arr.select { |x| x < 0 }.inject(:+) || 0\n  c = arr.select { |x| x\
    \ == 0 }.inject(:+) || 0\n  a + b + c\nend", "  # your code goes here\nend", " \
    \ return nil if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map { |x| x == 0\
    \ ? 0 : x / x.abs }.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.map {\
    \ |x| x.abs }.sum * arr.map { |x| x <=> 0 }.inject(:*)\nend", "    return if arr.empty?\n\
    \    total = 0\n    arr.each do |x|\n        if x > 0\n            total += x\n\
    \        elsif x < 0\n            total -= x\n        end\n    end\n    total\n\
    end", end, "  return nil if arr.empty?\n  arr.map { |e| e.abs }.sum * arr.map\
    \ { |e| e <=> 0 }.reduce(:*)\nend", "  if arr.empty?\n    nil\n  else\n    prod\
    \ = 1\n    sum = 0\n    arr.each do |n|\n      if n > 0\n        prod *= 1\n \
    \       sum += n\n      elsif n < 0\n        prod *= -1\n        sum += n.abs\n\
    \      else\n        sum += 0\n      end\n    end\n    prod * sum\n  end\nend",
  "  return nil if arr.empty?\n  arr.map { |a| a.abs }.sum * arr.map { |a| a <=> 0\
    \ }.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.reduce(1) { |sum, x|\
    \ sum * (x.positive? ? 1 : (x.zero? ? 0 : -1)) } * arr.reduce(0) { |sum, x| sum\
    \ + x.abs }\nend", "\tif arr.empty?\n\t\treturn nil\n\tend\n\tsigns = arr.map\
    \ { |x| x.sign }\n\tmagnitudes = arr.map { |x| x.abs }\n\tmagnitudes.inject(:+)\
    \ * signs.inject(:*)\nend", end, "  if arr.empty?\n    nil\n  else\n    arr.map!\
    \ do |e|\n      if e > 0\n        1\n      elsif e < 0\n        -1\n      else\n\
    \        0\n      end\n    end\n    prod = arr.inject(:*)\n    arr.map! { |e|\
    \ e.abs }\n    arr.inject(:+) * prod\n  end\nend", end, "  product = 1\n  magnitude\
    \ = 0\n  if arr.empty?\n    return nil\n  else\n    arr.each do |el|\n      if\
    \ el > 0\n        product *= 1\n        magnitude += el\n      elsif el < 0\n\
    \        product *= -1\n        magnitude += el.abs\n      else\n        product\
    \ *= 0\n      end\n    end\n  end\n  product * magnitude\nend", "\tif arr.length\
    \ == 0\n\t\treturn nil\n\telse\n\t\t#stores signs in new array\n\t\tsigns = []\n\
    \t\t#1 for positive, -1 for negative, 0 for zero\n\t\tarr.each do |value|\n\t\t\
    \tif value == 0\n\t\t\t\tsigns << 0\n\t\t\telsif value > 0\n\t\t\t\tsigns << 1\n\
    \t\t\telse\n\t\t\t\tsigns << -1\n\t\t\tend\n\t\tend\n\t\t#calculates product of\
    \ signs\n\t\tsigns_prod = signs.inject(:*)\n\t\t#stores magnitudes in new array\n\
    \t\tmagnitudes = []\n\t\tarr.each do |value|\n\t\t\tif value < 0\n\t\t\t\tmagnitudes\
    \ << value * -1\n\t\t\telse\n\t\t\t\tmagnitudes << value\n\t\t\tend\n\t\tend\n\
    \t\t#calculates sum of magnitudes\n\t\tmagnitudes_sum = magnitudes.inject(:+)\n\
    \t\t#returns product of signs * sum of magnitudes\n\t\treturn signs_prod * magnitudes_sum\n\
    \tend\nend", "  raise NotImplementedError\nend", "  return nil if arr.length ==\
    \ 0\n  product = 1\n  sum = 0\n  arr.each do |num|\n    product *= num <=> 0\n\
    \    sum += num.abs\n  end\n  product * sum\nend", "  # your code here\nend",
  "  return nil if arr.empty?\n  negatives = 0\n  sum = 0\n  arr.each do |i|\n   \
    \ negatives += 1 if i < 0\n    sum += i.abs\n  end\n  sum * (negatives.even? ?\
    \ 1 : -1)\nend", "\tarr.map { |num| num.abs }.inject(:+) * arr.map { |num| num\
    \ <=> 0 }.inject(:*) || nil\nend", "    if arr.empty?\n        return nil\n  \
    \  end\n    sum = 0\n    prod = 1\n    arr.each do |x|\n        sum += x.abs\n\
    \        if x < 0\n            prod *= -1\n        elsif x > 0\n            prod\
    \ *= 1\n        end\n    end\n    return sum * prod\nend", "  return nil if arr.empty?\n\
    \  arr.map { |num| num.abs }.reduce(:+) * arr.map { |num| num <=> 0 }.reduce(:*)\n\
    end", "  return nil if arr.empty?\n  arr.map{|e| e <=> 0}.product(*arr.map{|e|\
    \ e.abs}).flatten.reduce(:*)\nend", "  return nil if arr.empty?\n  signs = arr.map\
    \ { |i| i > 0 ? 1 : i < 0 ? -1 : 0 }\n  signs.inject(:*) * arr.map(&:abs).inject(:+)\n\
    end", "  if arr.length == 0\n    return nil\n  else\n    b = arr.map { |e| e.abs\
    \ }\n    c = arr.reduce(:*)\n    return (b.reduce(:+)) * c\n  end\nend", "  if\
    \ arr.empty?\n    return nil\n  end\n  v = 1\n  arr.each do |s|\n    if s > 0\n\
    \      v *= 1\n    elsif s < 0\n      v *= -1\n    else\n      v *= 0\n    end\n\
    \  end\n  puts v\n  ans = 0\n  arr.each do |s|\n    ans += s.abs\n  end\n  return\
    \ ans * v\nend", "  if arr.length == 0\n    return nil\n  end\n  arr.map! do |x|\n\
    \    x <=> 0\n  end\n  first = arr.delete_at(0)\n  s = first * arr.reduce(:*)\n\
    \  s * arr.map { |x| x.abs }.reduce(:+)\nend", "  return nil if arr.empty?\n \
    \ magn = arr.map(&:abs)\n  sign = arr.map { |num| num > 0 ? 1 : num < 0 ? -1 :\
    \ 0 }\n  magn.inject(:+) * sign.inject(:*)\nend", "\tif arr.empty?\n\t\treturn\
    \ nil\n\tend\n\tsum = 0\n\tsigns = 1\n\tarr.each do |n|\n\t\tsum += n.abs\n\t\t\
    if n == 0\n\t\t\tnext\n\t\tend\n\t\tsigns *= n/n.abs\n\tend\n\treturn sum * signs\n\
    end", "  return nil if arr.empty?\n  arr.map(&:abs).sum * arr.map { |x| x == 0\
    \ ? 0 : x <=> 0 }.reduce(:*)\nend", "  return nil if arr.empty?\n  prod = 1\n\
    \  arr.each do |int|\n    prod *= (int > 0 ? 1 : int < 0 ? -1 : 0)\n  end\n  arr.map(&:abs).reduce(:+)\
    \ * prod\nend", "  ans = 1\n  arr.each do |x|\n    if x > 0\n      ans *= 1\n\
    \    elsif x < 0\n      ans *= -1\n    else\n      ans *= 0\n    end\n  end\n\
    \  if arr.empty?\n    return nil\n  else\n    return ans * arr.map(&:abs).reduce(:+)\n\
    \  end\nend", "  return nil if arr.empty?\n  signs = arr.reduce(1) { |acc, val|\
    \ acc * (val <=> 0) }\n  arr.reduce(0) { |acc, val| acc + val.abs } * signs\n\
    end", "  return nil if arr.length == 0\n  result = 1\n  arr.each do |x|\n    result\
    \ *= x.sign\n  end\n  arr.map { |x| x.abs }.sum * result\nend", end, "  raise\
    \ NotImplementedError, \"TODO: prod_signs\"\nend", '  # fill in your code here',
  "\tif arr.length == 0\n\t\treturn nil\n\tend\n\tmagnitude = 0\n\tsign = 1\n\tarr.each\
    \ do |i|\n\t\tif i == 0\n\t\t\tnext\n\t\tend\n\t\tmagnitude += i.abs\n\t\tsign\
    \ *= i <=> 0\n\tend\n\treturn magnitude * sign\nend", "  return nil if arr.empty?\n\
    \  arr.inject(1) { |m, x| m * sign(x) } * arr.map(&:abs).reduce(:+)\nend", " \
    \ prod = 1\n  arr.each do |el|\n    prod *= (el > 0 ? 1 : el < 0 ? -1 : 0)\n \
    \ end\n  prod * arr.map { |n| n.abs }.reduce(:+)\nend", "  # your code here\n\
    end", "  return if arr.empty?\n  arr.map! { |num| num <=> 0 }.reduce(:*) * arr.map\
    \ { |num| num.abs }.reduce(:+)\nend", "  # YOUR CODE HERE\nend", "  return nil\
    \ if arr.empty?\n  arr.map { |num| num * num.sign }.reduce(:*)\nend", "  sum =\
    \ 0\n  prod = 1\n  arr.each do |int|\n    prod *= sign(int)\n    sum += int.abs\n\
    \  end\n  return prod * sum\nend", "\treturn nil if arr.empty?\n\tarr.map{|i|\
    \ i.abs}.reduce(:+) * arr.map{|i| i <=> 0}.reduce(:*)\nend", "  return nil if\
    \ arr.empty?\n  product = 1\n  arr.each do |number|\n    product *= number <=>\
    \ 0\n  end\n  arr.map { |number| number.abs }.reduce(:+) * product\nend", "  return\
    \ nil if arr.empty?\n  sum = 0\n  product = 1\n  arr.each do |num|\n    sum +=\
    \ num.abs\n    product *= num.sign\n  end\n  sum * product\nend", "  return if\
    \ arr.empty?\n  product = 1\n  arr.each do |num|\n    product *= sign(num)\n \
    \ end\n  arr.reduce(0) { |sum, num| sum + num.abs } * product\nend", "\tif arr.length\
    \ == 0\n\t\treturn nil\n\telse\n\t\tsum = 0\n\t\tp_sum = 1\n\t\tfor i in arr\n\
    \t\t\tif i < 0\n\t\t\t\ti = i * -1\n\t\t\t\tp_sum = p_sum * -1\n\t\t\telsif i\
    \ == 0\n\t\t\t\tp_sum = 0\n\t\t\tend\n\t\t\tsum = sum + i\n\t\tend\n\t\tsum =\
    \ sum * p_sum\n\t\treturn sum\n\tend\nend", "  result = arr.inject(1) { |sum,\
    \ i| sum *= i <=> 0 }\n  result ? arr.map { |i| i.abs }.inject(:+) * result :\
    \ nil\nend", "    arr.empty? ? nil : arr.map{|i| i <=> 0 }.reduce(:*) * arr.map{|i|\
    \ i.abs }.reduce(:+)\nend", "  return nil if arr.empty?\n  sum = 0\n  prod = 1\n\
    \  arr.each do |num|\n    sum += num.abs\n    prod *= num.zero? ? 1 : num.positive?\
    \ ? 1 : -1\n  end\n  sum * prod\nend", "  return if arr.empty?\n  arr.map(&:abs).reduce(:+)\
    \ * arr.map { |x| x <=> 0 }.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.map\
    \ { |x| x <=> 0 }.inject(:*) * arr.map(&:abs).inject(:+)\nend", "  # your code\
    \ here\nend", "  if arr.empty?\n    return nil\n  else\n    return (arr.map {\
    \ |e| e.abs }.inject(:*) * arr.map { |e| e.positive? ? 1 : e.zero? ? 0 : -1 }.inject(:*))\n\
    \  end\nend", "  return if arr.empty?\n  arr.map { |x| x.abs }.sum * arr.map {\
    \ |x| x.sign }.reduce(:*)\nend", "  prod = 1\n  sum = 0\n  return nil if arr.empty?\n\
    \  arr.each do |i|\n    prod *= i > 0 ? 1 : i < 0 ? -1 : 0\n    sum += i.abs\n\
    \  end\n  sum * prod\nend", end, "  return nil if arr.empty?\n  signs = arr.map\
    \ { |num| num <=> 0 }\n  signs.inject(:*) * arr.map(&:abs).inject(:+)\nend", " \
    \ return nil if arr.empty?\n  product = 1\n  sum = 0\n  arr.each do |i|\n    sum\
    \ += i.abs\n    product *= i <=> 0\n  end\n  sum * product\nend", "  return nil\
    \ if arr.empty?\n  signs = arr.map{|num| num <=> 0}\n  magnitude = arr.map{|num|\
    \ num.abs}\n  magnitude.reduce(:+) * signs.reduce(:*)\nend", "  return nil if\
    \ arr.empty?\n  signs = arr.map { |num| num.positive? ? 1 : num.zero? ? 0 : -1\
    \ }\n  signs.reduce(:*) * arr.map(&:abs).reduce(:+)\nend", "  # TODO: implement\
    \ this method\nend", "  # Write your code here.\nend", "  return nil if arr.empty?\n\
    \  arr.map!{|a| a == 0 ? 1 : a}\n  arr.map!{|a| a < 0 ? -1 : 1}\n  arr.inject(:*)\
    \ * arr.map!{|a| a.abs}.inject(:+)\nend", end, "  arr.empty? ? return : sum =\
    \ 0\n  arr.each do |num|\n    product_of_signs = num.abs\n    sum += product_of_signs\n\
    \  end\n  arr.select! { |num| num != 0 }\n  arr.empty? ? return : product = 1\n\
    \  arr.each do |num|\n    sign = if num > 0\n             1\n           elsif\
    \ num < 0\n             -1\n           end\n    product *= sign\n  end\n  sum\
    \ * product\nend", "  # your code goes here\nend", "  if arr.empty?\n    nil\n\
    \  else\n    arr.map { |n| n.abs }.reduce(:+) * arr.map { |n| n.positive? ? 1\
    \ : -1 }.reduce(:*)\n  end\nend", "  if arr.empty?\n    return nil\n  else\n \
    \   sign_prod = 1\n    mag_sum = 0\n    arr.each do |int|\n      sign_prod *=\
    \ int.sign\n      mag_sum += int.abs\n    end\n    return sign_prod * mag_sum\n\
    \  end\nend", "  arr.reduce(1) { |a, e| a * (e <=> 0) } * arr.reduce(0) { |a,\
    \ e| a + e.abs }\nend", end, "  # TODO: implement me\nend", "  return nil if arr.empty?\n\
    \  arr_signs = arr.map { |n| n > 0 ? 1 : n < 0 ? -1 : 0 }\n  (arr.reduce(:+) *\
    \ arr_signs.reduce(:*)).abs\nend", "  # TODO: Write your code here\nend", "  arr.reduce(1)\
    \ { |s, v| s * v.sign } * arr.reduce(0) { |s, v| s + v.abs }\nend", "  if arr.empty?\n\
    \    nil\n  else\n    product = arr.reduce(1) { |product, number| product * number.sign\
    \ }\n    sum = arr.map { |number| number.abs }.reduce(:+)\n    product * sum\n\
    \  end\nend", "  return nil if arr.empty?\n  # TODO: understand\n  # mags = arr.map\
    \ { |num| num.abs }\n  # prod = arr.map { |num| num <=> 0 }.reduce(&:*)\n  # mags.reduce(&:+)\
    \ * prod\n  # prod = 1\n  # (arr.map { |num| num <=> 0 }).each { |num| prod *=\
    \ num }\n  # (arr.map { |num| num.abs }).reduce(&:+) * prod\n  arr.map { |num|\
    \ num.abs }.reduce(&:+) * arr.map { |num| num <=> 0 }.reduce(&:*)\nend", "\t#\
    \ your code here\nend", "  return nil if arr.empty?\n  product = arr.map { |x|\
    \ x.nonzero? ? x.sign : 0 }.reduce(:*)\n  arr.map { |x| x.abs }.reduce(:+) * product\n\
    end", "  return nil if arr.empty?\n  arr.map { |num| num.abs }.sum * arr.map {\
    \ |num| num <=> 0 }.inject(:*)\nend", end, "  return nil if arr.empty?\n  signs\
    \ = arr.map { |n| n <=> 0 }\n  signs.reduce(:*) * arr.map(&:abs).reduce(:+)\n\
    end", "  return nil if arr.empty?\n  arr.map { |i| i.abs }.sum * arr.map { |i|\
    \ i <=> 0 }.reduce(:*)\nend", "    return nil if arr.empty?\n    return 0 if arr.all?\
    \ { |n| n == 0 }\n    arr.map! { |i| i > 0 ? 1 : i < 0 ? -1 : 0 }\n    arr.inject(:*)\
    \ * arr.map { |i| i.abs }.inject(:+)\nend", "  # Your code goes here\nend", " \
    \ if arr.empty?\n    nil\n  else\n    mags = arr.map { |num| num.abs }\n    signs\
    \ = arr.map { |num| num <=> 0 }\n    signs.inject(:*) * mags.inject(:+)\n  end\n\
    end", "  return nil if arr.empty?\n  s = 1\n  a = 0\n  arr.each do |i|\n    if\
    \ i.zero?\n      s = 0\n      break\n    end\n    s *= i > 0 ? 1 : -1\n    a +=\
    \ i.abs\n  end\n  s * a\nend", "  arr.reduce(0) { |result, elem| result + (elem\
    \ * sign(elem)) }\nend", "  return if arr.empty?\n  arr.map! { |n| n.abs }\n \
    \ arr.reduce(:+) * arr.map { |n| n <=> 0 }.reduce(:*)\nend", "  return nil if\
    \ arr.empty?\n  arr.map { |item| item.abs }.reduce(:+) * arr.map { |item| item.sign\
    \ }.reduce(:*)\nend", "  return nil if arr.length == 0\n  arr.inject(0) { |sum,\
    \ n| sum + n.abs * arr.map { |i| i <=> 0 }.inject(:*) }\nend", "  return if arr.empty?\n\
    \  sum = 0\n  sign = 1\n  arr.each do |x|\n    sum += x.abs\n    sign *= x <=>\
    \ 0\n  end\n  sum * sign\nend", "  return nil if arr.empty?\n  prod = 1\n  sum\
    \ = 0\n  arr.each do |num|\n    sum += num.abs\n    prod *= num <=> 0\n  end\n\
    \  prod * sum\nend", "  return nil if arr.empty?\n  # result = 1\n  # arr.each\
    \ do |x|\n  #   if x < 0\n  #     result *= -1\n  #   elsif x > 0\n  #     result\
    \ *= 1\n  #   else\n  #     result *= 0\n  #   end\n  # end\n  # sum = 0\n  #\
    \ arr.each do |y|\n  #   sum += y.abs\n  # end\n  # sum * result\n  sum = 0\n\
    \  signs = 1\n  arr.each do |x|\n    if x.zero?\n      signs = 0\n    elsif x\
    \ < 0\n      signs *= -1\n    end\n    sum += x.abs\n  end\n  sum * signs\nend",
  "  if arr.empty?\n    return nil\n  end\n  prod = 1\n  sum = 0\n  arr.each do |elem|\n\
    \    prod *= sign_magnitude(elem)\n    sum += magnitude(elem)\n  end\n  sum *\
    \ prod\nend", "  return nil if arr.empty?\n  # rubocop:disable Style/NumericPredicate\n\
    \  res = 1.0\n  arr.each do |x|\n    res *= (x <=> 0) if x != 0\n  end\n  res\
    \ * arr.map(&:abs).reduce(:+)\n  # rubocop:enable Style/NumericPredicate\nend",
  end, "  product = 1\n  arr.each do |num|\n    if num < 0\n      product *= -1\n\
    \    elsif num > 0\n      product *= 1\n    else\n      product *= 0\n    end\n\
    \  end\n  return nil if arr.empty?\n  sum = 0\n  arr.each do |num|\n    sum +=\
    \ num.abs\n  end\n  sum * product\nend", "  arr.empty? ? nil : (arr.inject(:+)\
    \ * arr.map{|i| i.abs}.inject(:*))\nend", "  if arr.length == 0\n    nil\n  else\n\
    \    arr.map { |number| number = number <=> 0}.reduce(:*) * arr.reduce(:+)\n \
    \ end\nend", "  # TODO\nend", "  return nil if arr.empty?\n  sgns = arr.map {\
    \ |x| x > 0 ? 1 : (x < 0 ? -1 : 0) }\n  arr.map(&:abs).sum * sgns.inject(:*)\n\
    end", "  return nil if arr.empty?\n  prod = 1\n  sum = 0\n  arr.each do |num|\n\
    \    if num == 0\n      prod *= 1\n      sum += 0\n    elsif num > 0\n      prod\
    \ *= 1\n      sum += num\n    else\n      prod *= -1\n      sum += num.abs\n \
    \   end\n  end\n  prod * sum\nend", "  return nil if arr.empty?\n  sum = 0\n \
    \ arr.each do |num|\n    sum += num if num > 0\n    sum -= num if num < 0\n  end\n\
    \  sign = 1\n  arr.each do |num|\n    if num < 0\n      sign *= -1\n    elsif\
    \ num > 0\n      sign *= 1\n    else\n      sign *= 0\n    end\n  end\n  sum *\
    \ sign\nend", end, "  # Your code goes here.\nend", "  return nil if arr.empty?\n\
    \  all_signs = arr.map { |n| n <=> 0 }.reduce(:*)\n  sum_of_magnitudes = arr.reduce(0)\
    \ { |sum, n| sum + n.abs }\n  all_signs * sum_of_magnitudes\nend", "  if arr.empty?\n\
    \    nil\n  else\n    arr.map! { |x| x.abs }\n    arr.inject(:+) * arr.count{\
    \ |x| x >= 0}\n  end\nend", "  return nil if arr.empty?\n  arr.map { |a| a ==\
    \ 0 ? 1 : a / a.abs }.reduce(:*) * arr.map(&:abs).reduce(:+)\nend", "  if arr.empty?\n\
    \    nil\n  else\n    sum = 0\n    product = 1\n    arr.each do |i|\n      sum\
    \ += i.abs\n      if i > 0\n        product *= 1\n      elsif i < 0\n        product\
    \ *= -1\n      else\n        product *= 0\n      end\n    end\n    sum * product\n\
    \  end\nend", "  return nil if arr.empty?\n  arr.map! { |x| x.abs }\n  arr.reduce(:+)\
    \ * arr.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.map { |num| num.abs\
    \ }.sum * arr.map { |num| num == 0 ? 0 : (num / num.abs) }.reduce(:*)\nend", " \
    \ # your code here\nend", "  return nil if arr.empty?\n  arr.map{|item| item.abs\
    \ }.reduce(:+) * arr.map{|item| item > 0 ? 1 : item < 0 ? -1 : 0 }.reduce(:*)\n\
    end", "  return nil if arr.empty?\n  arr.map { |n| n.abs }.reduce(:+) * arr.map\
    \ { |n| n > 0 ? 1 : n < 0 ? -1 : 0 }.reduce(:*)\nend", "    return nil if arr.empty?\n\
    \    prod_signs = 1\n    sum_magnitudes = 0\n    arr.each do |num|\n        sum_magnitudes\
    \ += num.abs\n        if num == 0\n            prod_signs *= 1\n        elsif\
    \ num < 0\n            prod_signs *= -1\n        end\n    end\n    sum_magnitudes\
    \ * prod_signs\nend", "  if arr.size.zero?\n    return nil\n  end\n  # product\
    \ of signs\n  signs = arr.map { |i| i.zero? ? 0 : i.positive? ? 1 : -1 }.reduce(:*)\n\
    \  # sum of magnitudes\n  mag = arr.map { |i| i.abs }.reduce(:+)\n  # return product\
    \ of signs * sum of magnitudes\n  mag * signs\nend", end, "  if arr.empty?\n \
    \   return nil\n  else\n    sum = 0\n    arr.each do |n|\n      sum += n.abs\n\
    \    end\n    product = 1\n    arr.each do |n|\n      product *= n.abs\n    end\n\
    \    return sum * product\n  end\nend", "    return nil if arr.empty?\n    arr.map{|i|\
    \ i.abs}.reduce(:+) * arr.map{|i| i <=> 0}.reduce(:*)\nend", "    return 0 if\
    \ arr.length == 0\n    puts arr.select { |x| x >= 0 }.inject(:+)\n    # return\
    \ arr.select { |x| x >= 0 }.inject(:+)\n    # return arr.select { |x| x <= 0 }.inject(:+)\n\
    end", "  if arr.length == 0\n    return nil\n  else\n    return arr.map{|x| x.abs}.reduce(:*)\
    \ * arr.map{|x| x <=> 0}.reduce(:*)\n  end\nend", "  arr.empty? ? nil : arr.map\
    \ { |el| el.abs }.sum * arr.map { |el| el.sign }.inject(:*)\nend", "  return nil\
    \ if arr.empty?\n  signs = []\n  magnitudes = []\n  arr.each do |n|\n    if n\
    \ == 0\n      signs << 0\n      magnitudes << 0\n    elsif n > 0\n      signs\
    \ << 1\n      magnitudes << n\n    else\n      signs << -1\n      magnitudes <<\
    \ n.abs\n    end\n  end\n  (magnitudes.reduce(:+) * signs.reduce(:*)).to_i\nend",
  "  signs = arr.map{|i| i > 0 ? 1 : i < 0 ? -1 : 0}\n  magnitudes = arr.map(&:abs)\n\
    \  magnitudes.sum * signs.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.map\
    \ { |x| x.abs }.reduce(:+) * arr.map { |x| x.zero? ? 0 : x/x.abs }.reduce(:*)\n\
    end", "  return nil if arr.empty?\n  arr.map(&:abs).sum * arr.map { |i| i <=>\
    \ 0 }.reduce(:*)\nend", "  return nil if arr.empty?\n  arr.map{|x| x.abs}.reduce(:+)\
    \ * arr.map{|x| x == 0 ? 0 : x/x.abs}.reduce(:*)\nend", "  if arr.length == 0\n\
    \    return nil\n  end\n  sign = 0\n  total = 0\n  for x in arr\n    if x < 0\n\
    \      sign -= 1\n    elsif x > 0\n      sign += 1\n    end\n    total += x.abs\n\
    \  end\n  return sign * total\nend", "    if arr.empty?\n        return nil\n\
    \    end\n    signs = arr.map { |n| n <=> 0 }.inject(:*)\n    magnitudes = arr.map\
    \ { |n| n.abs }.inject(:+)\n    signs * magnitudes\nend", "    # Your code here\n\
    end", "\t# Write your code here\nend", end, "  return nil if arr.empty?\n  arr.map{|x|\
    \ x.abs}.reduce(:+) * arr.map{|x| x <=> 0}.reduce(:*)\nend", "  return nil if\
    \ arr.length == 0\n  arr.map! { |n| n >= 0 ? 1 : -1 }\n  arr.sum * arr.product\n\
    end", "  # Write your code here\nend", "  arr.map { |x| x.sign * x.abs }.inject(:*)\n\
    end", "  nums = arr.map { |n| n.abs }\n  signs = arr.map { |n| n <=> 0 }.inject(:*)\n\
    \  nums.inject(:+) * signs\nend", "  arr.sum{|x| x.abs} * arr.select{|x| x !=\
    \ 0}.inject(1){|a,b| a * b.sign}\nend", "  # your code here\nend", "  return nil\
    \ if arr.empty?\n  signs = arr.map { |i| [1, -1, 0][i <=> 0] }\n  signs.reduce(:*)\
    \ * arr.map(&:abs).reduce(:+)\nend", "  # your code here\nend", "  return nil\
    \ if arr.empty?\n  arr_p = arr.map { |a| a.positive? ? 1 : a == 0 ? 0 : -1 }\n\
    \  arr_m = arr.map { |a| a.abs }\n  arr_p.inject(:*) * arr_m.inject(:+)\nend",
  "  arr.empty? ? nil : arr.map(&:abs).reduce(:+) * arr.map { |x| x <=> 0 }.reduce(:*)\n\
    end", "  return nil if arr.empty?\n  sum = 0\n  prod = 1\n  arr.each do |n|\n\
    \    if n > 0\n      sum += n\n      prod *= 1\n    elsif n < 0\n      sum +=\
    \ n.abs\n      prod *= -1\n    end\n  end\n  sum * prod\nend", "  if arr.length\
    \ == 0\n    return nil\n  end\n  sign = 0\n  prod = 1\n  arr.each do |item|\n\
    \    if item < 0\n      sign += -1 * item\n      prod *= -1\n    elsif item >\
    \ 0\n      sign += item\n    end\n  end\n  return sign * prod\nend", "  # your\
    \ code here\nend", "    return nil if arr.length == 0\n    prod = 1\n    sum =\
    \ 0\n    arr.each do |e|\n        prod *= e <=> 0\n        sum += e.abs\n    end\n\
    \    sum * prod\nend", "  return nil if arr.empty?\n  arr_signs = arr.map { |num|\
    \ num.positive? ? 1 : num.zero? ? 0 : -1 }\n  arr_signs.reduce(:*) * arr.reduce(:+)\n\
    end", "  arr.inject(:*)\nend", "  arr.reduce(0) { |a, e| e.abs } * arr.select\
    \ { |e| e != 0 }.map { |e| e / e.abs }.reduce(:*)\nend", "  @mag = arr.map { |i|\
    \ i.abs }.reduce(:+)\n  @sign = arr.select { |i| i < 0 }.count.even? ? 1 : -1\n\
    \  @mag * @sign\nend", "  if arr.empty?\n    nil\n  else\n    product = 1\n  \
    \  sum = 0\n    arr.each do |n|\n      if n > 0\n        product *= 1\n      \
    \  sum += n\n      elsif n < 0\n        product *= -1\n        sum += n.abs\n\
    \      end\n    end\n    sum * product\n  end\nend", "  unless arr.empty?\n  \
    \  prod = 1\n    sum = 0\n    arr.each do |a|\n      prod *= sign(a)\n      sum\
    \ += a.abs\n    end\n    prod * sum\n  end\nend", end, "  return nil if arr.empty?\n\
    \  sum = 0\n  prod = 1\n  arr.each do |num|\n    sign = num.zero? ? 0 : num.positive?\
    \ ? 1 : -1\n    prod *= sign\n    sum += num.abs\n  end\n  sum * prod\nend", " \
    \ # Your code here\nend", "  return nil if arr.empty?\n  signs = arr.map { |i|\
    \ i <=> 0 }\n  signs.reduce(:*) * arr.map(&:abs).reduce(:+)\nend", "  return nil\
    \ if arr.empty?\n  total = 0\n  arr.each do |num|\n    if num == 0\n      total\
    \ += 0\n    elsif num < 0\n      total += num.abs\n    else\n      total += num\n\
    \    end\n  end\n  total\nend", "    return nil if arr.length == 0\n    s = arr.inject(1)\
    \ { |prod, num| prod *= num == 0 ? 1 : num / num.abs }\n    arr.inject(0) { |sum,\
    \ num| sum += num.abs } * s\nend", "  return nil if arr.empty?\n  signs = arr.map{|num|\
    \ num <=> 0}\n  signs.inject(:*) * arr.map(&:abs).inject(:+)\nend", "  if arr.empty?\n\
    \    nil\n  else\n    abs_sum = arr.map(&:abs).reduce(:+)\n    sign_prod = arr.map\
    \ { |n| n <=> 0 }.reduce(:*)\n    abs_sum * sign_prod\n  end\nend", "  # code\
    \ here\nend", "  if arr.length > 0\n    return arr.map{|x| x.abs}.inject(:+) *\
    \ arr.map{|x| x > 0 ? 1 : x < 0 ? -1 : 0}.inject(:*)\n  else\n    return nil\n\
    \  end\nend", "  return if arr.empty?\n  arr.map { |a| a <=> 0 }.reduce(:*) *\
    \ arr.reduce(:+)\nend", "  return nil if arr.empty?\n  res = []\n  arr.each do\
    \ |x|\n    if x > 0\n      res << 1\n    elsif x < 0\n      res << -1\n    else\n\
    \      res << 0\n    end\n  end\n  prod = res.inject(:*)\n  num = arr.map { |n|\
    \ n.abs }.inject(:+)\n  prod * num\nend", "  prod = arr.reduce(1, :*)\n  if prod\
    \ == 0\n    return 0\n  elsif prod > 0\n    return 1\n  else\n    return -1\n\
    \  end\nend", end, "  return nil if arr.empty?\n  positive = 0\n  negative = 0\n\
    \  zeros = 0\n  arr.each do |num|\n    if num > 0\n      positive += 1\n    elsif\
    \ num < 0\n      negative += 1\n    else\n      zeros += 1\n    end\n  end\n \
    \ prod = [positive, negative].product([1, -1]).map do |arr|\n    arr.inject(:*)\n\
    \  end\n  result = 0\n  arr.each do |num|\n    result += num.abs\n  end\n  prod.each\
    \ do |prod|\n    result *= prod\n  end\n  result\nend", "  return nil if arr.empty?\n\
    \  arr.map { |n| n <=> 0 }.reduce(:*) * arr.map(&:abs).reduce(:+)\nend", "  #\
    \ add code here\nend", "  # your code here\nend", "  if arr.empty?\n    nil\n\
    \  else\n    arr.map!{|x| x <=> 0}.reduce(:*) * arr.map{|x| x.abs}.reduce(:+)\n\
    \  end\nend", "    arr.empty? ? nil : arr.map { |e| e.abs }.sum * arr.map { |e|\
    \ e <=> 0 }.inject(:*)\nend", "  return nil if arr.empty?\n  sign_arr = arr.map\
    \ { |num| num <=> 0 }\n  sign_prod = sign_arr.inject(:*)\n  arr.map(&:abs).inject(:+)\
    \ * sign_prod\nend", "  return if arr.empty?\n  arr.map { |num| num.abs }.sum\
    \ * arr.map { |num| num.sign }.inject(:*)\nend", "  product = arr.reduce(1) {\
    \ |prod, elem| prod *= elem >= 0 ? 1 : -1 }\n  arr.empty? ? nil : arr.map(&:abs).reduce(:+)\
    \ * product\nend", "  return nil if arr.empty?\n  arr.map(&:abs).reduce(:+) *\
    \ arr.map { |item| item.zero? ? 0 : item > 0 ? 1 : -1 }.reduce(:*)\nend", "  if\
    \ arr.empty?\n    nil\n  else\n    arr.map { |n| n.abs }.reduce(:+) * arr.reduce(1)\
    \ { |acc, n| acc * n.positive? ? 1 : -1 }\n  end\nend", "  if arr.empty?\n   \
    \ nil\n  else\n    arr.map(&:abs).sum * arr.map { |x| x <=> 0 }.reduce(:*)\n \
    \ end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
