name: HumanEval_83_starts_one_ends
language: rb
prompt: "# Given a positive integer n, return the count of the numbers of n-digit\n\
  # positive integers that start or end with 1.\ndef starts_one_ends(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_starts_one_ends\n\
  \    candidate = method(:starts_one_ends)\n    assert_equal(1, candidate.call(1))\n\
  \    assert_equal(18, candidate.call(2))\n    assert_equal(180, candidate.call(3))\n\
  \    assert_equal(1800, candidate.call(4))\n    assert_equal(18000, candidate.call(5))\n\
  \  end\nend\n"
completions: ["  return 0 if n < 1\n  return 10 if n == 1\n  ten = 10 ** (n - 1)\n\
    \  starts_one_ends(n - 1) + ten * 9 + ten\nend", "\nend", "  # write your code\
    \ here\nend", "  return 1 if n == 1\n  (2 * (n - 1) + 2 * (n - 2)) * 2\nend",
  "  # Your code here\nend", "  val = n - 1\n  (9 * 10 ** val) + (10 ** val)\nend",
  end, "  # write your code here\nend", "  return 1 if n == 1\n  s = ends_one_ends(n\
    \ - 1)\n  (1..(n - 2)).each do |i|\n    s += starts_one_ends(i) * ends_one_ends(n\
    \ - i - 1)\n  end\n  s + ends_one_ends(n - 1)\nend", "  count = 0\n  (10**(n-1))..(10**n-1)\
    \ do |i|\n    count += 1 if (i.to_s.scan(/1/) == [\"1\"])\n  end\n  count\nend",
  "  return 0 if n == 0\n  return 1 if n == 1\n  count = 1\n  for i in (1..n-1)\n\
    \    count += 9 * 10 ** (i-1)\n  end\n  count\nend", "  ends_one(n) + starts_one(n)\n\
    end", "\nend", "  return 0 if n == 0\n  num_chars = n\n  start_one = end_one =\
    \ (n == 1) ? 2 : 10 ** (n - 1)", "  # Count the numbers that start with 1\n  answer\
    \ = 1\n  (n - 1).times do\n    answer *= 10\n    answer += 9\n  end", "  # your\
    \ code here\nend", "  1\nend", "  return n if n <= 2\n  sum = 0\n  (1..n).each\
    \ do |i|\n    sum += (10**(i-1) - 10**(i-2))\n  end\n  sum\nend", "  raise \"\
    n must be an integer greater than 1\" unless n.is_a?(Integer) && n > 1\n  return\
    \ 10 if n == 2\n  a = [10, 9, 8] # count of numbers when n = 3\n  (3..n-1).each\
    \ do |i|\n    a << (a[i-1] * (9 - i + 2)) + a[i-2]\n  end\n  a[n-1]\nend", " \
    \ return 0 if n == 0\n  return 10 if n == 1\n  (n-1)*10**(n-2) + 10*10**(n-2)\
    \ + 9*(10**(n-2) - 10**(n-3))\nend", "  return 0 if n < 2\n  return 1 if n ==\
    \ 2\n  return 1 + (n / 2) + ((n / 2) - 1)\nend", "  # Your code here.\nend", " \
    \ return n if n < 2\n  (10**(n-1)) + (9 * (10**(n-2)))\nend", "  # let's just\
    \ take one of the two cases.\n  # There are (n-1)*9^(n-1) ending with 1.\n  (n-1)*9**(n-1)\n\
    end", "  return n if n < 1\n  count = 0\n  num = 1\n  (n - 1).times do\n    num\
    \ *= 10\n    count += 9 * num\n  end\n  count += 10 ** (n - 1)\n  count\nend",
  "  if n < 0 || n > 9\n    puts 'Error: n must be between 0 and 9'\n    return\n\
    \  end", "  return 1 if n == 1\n  return 11 if n == 2\n  # n == 3 \u3067\u306F\
    \u30011~9 \u304C\u5341\u306E\u4F4D\u300110,11 \u304C\u4E00\u306E\u4F4D\u3001\n\
    \  # 10~99 \u306E 90 \u304C\u4E00\u306E\u4F4D\u306E\u30D1\u30BF\u30FC\u30F3\u3092\
    \ 10,11 \u3068\u7F6E\u304D\u63DB\u3048\u3066\u6570\u3048\u308B\n  return 91 if\
    \ n == 3\n  # n == 4 \u3067\u306F\u30011~99 \u304C\u767E\u306E\u4F4D\u300110,11,100,101\
    \ \u304C\u4E00\u306E\u4F4D\n  # 10~999 \u306E 990 \u304C\u4E00\u306E\u4F4D\u306E\
    \u30D1\u30BF\u30FC\u30F3\u3092 10,11,100,101 \u3068\u7F6E\u304D\u63DB\u3048\u3066\
    \u6570\u3048\u308B\n  return 991 if n == 4\n  9 * 10**(n - 1) + starts_one_ends(n\
    \ - 1)\nend", "  n > 1 ? 9 * 10 ** (n - 2) : 1\nend", "  return 10 if n == 1\n\
    \  (1..n).map { |i| (i-1)*9*9**(i-2) }.sum\nend", "  count = 0\n  (1..9).each\
    \ do |number|\n    count += number_combinations(n-1)\n  end\n  count\nend", " \
    \ res = 0\n  num = n.to_s.split('')\n  (1..9).each do |i|\n    temp = num.clone\n\
    \    temp[0] = i.to_s\n    res += 1 if is_num?(temp.join)\n  end\n  (1..9).each\
    \ do |i|\n    temp = num.clone\n    temp[-1] = i.to_s\n    res += 1 if is_num?(temp.join)\n\
    \  end\n  res\nend", "  return 1 if n == 1\n  starts_one_ends(n - 1) + count_numbers(n\
    \ - 1)\nend", "  sum = 0\n  a = [1] * (n + 1)\n  a[1] = 1\n  a[2] = 10\n  a[3]\
    \ = 100\n  (4..n).each do |i|\n    a[i] = a[i - 1] * 9 + a[i - 2] * 9\n  end\n\
    \  # puts a.inspect\n  sum = a[n] + a[n - 1] - 10 + 2\n  sum\nend", "  return\
    \ 10 if n == 1\n  return 9 * 10 ** (n - 2) if n == 2\n  return (n - 1) * 10 **\
    \ (n - 2) + 9 * 10 ** (n - 2)\nend", "  return 1 if n == 1\n  return 10 if n ==\
    \ 2\n  count = 0\n  9.downto(1) do |i|\n    count += 9 * 10**(i-1)\n  end\n  count\
    \ + 9 * starts_one_ends(n-1)\nend", "  if n == 1\n    return 2\n  end\n  nums\
    \ = [2]\n  1.upto(n-2) do |i|\n    nums[i] = nums[i-1] * 4\n  end\n  nums.inject(:+)\
    \ + 2\nend", "  # permutations, 2^(n-1)\n  2**(n-1)\nend", "  if n == 1\n    1\n\
    \  else\n    10 ** (n - 1) + starts_one_ends(n - 1)\n  end\nend", "  if n == 1\n\
    \    return 2\n  else\n    return 10 ** (n - 1) + starts_one_ends(n - 1)\n  end\n\
    end", "  if n == 1\n    return 2\n  end\n  count = 11\n  upper = 10 ** (n - 1)\n\
    \  while count < upper\n    count *= 10\n    count += 1\n  end\n  return count\n\
    end", "  return 1 if n == 1\n  return 10 if n == 2\n  10 + 9*(10**(n-2))\nend",
  "\nend", "  (1..n).map { |k| 10 ** (k - 1) }.sum\nend", "  count = 0\n  (1..9).each\
    \ do |num|\n    count += (1..n).map { |i| 10**(i-1) }.reduce(:+)\n  end\n  count\n\
    end", "  # Your Code Here\nend", "  if n <= 1\n    return 0\n  end\n  [n-1, 9]\n\
    end", "  raise ArgumentError if n < 1\n  return 1 if n == 1\n  return 9 if n ==\
    \ 2\n  return 9 if n == 3\n  start = 2\n  endd = 10\n  (n - 2).times do\n    start\
    \ = start * 10\n    endd = endd * 10\n  end\n  return start + endd - 1\nend",
  "  return 0 if n == 0\n  return 9 if n == 1\n  return 9 + n * 9 * (10 ** (n - 2))\n\
    end", "  # [1, 10, 100, 1000]\n  # 9, 99, 999\n  if n == 1\n    return 2\n  end\n\
    \  digits = 1\n  (1..n).each do |i|\n    digits *= 9\n  end\n  2 * digits\nend",
  "  if n == 1\n    return 2\n  end\n  # 10**(n-1) starts with 1, so must be excluded\n\
    \  # 9 is for 1-9, and the rest is for 10-99, 100-999, etc\n  return 9 * 10**(n-2)\
    \ + starts_one_ends(n-1)\nend", "  #return 0 if n == 1\n  return 0 if n < 1\n\
    \  return 10 if n == 1\n  last = dp_starts_one_ends(n)\n  first = dp_starts_one_ends(n-1)\n\
    \  last + first\nend", "  return -1 if n == 0\n  n * (10 ** (n - 1)) + (n - 1)\
    \ * 9\nend", "  (1..n-1).map { |k| 10**k }.sum\nend", "  return 0 if n == 0\n\
    \  return 9 if n == 1\n  return 9 + 9*10**(n-2)\nend", "  (10**(n-1)..10**n-1).count\
    \ { |x| x.to_s =~ /^1|1$/ }\nend", "  return 0 if n <= 0\n  return 1 if n == 1\n\
    \  dp = Array.new(n) { Array.new(2, 0) }\n  dp[0][0] = 0\n  dp[0][1] = 1\n  (1...n).each\
    \ do |i|\n    dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n    dp[i][1] = dp[i - 1][0]\n\
    \  end\n  dp[n - 1][0] + dp[n - 1][1]\nend", "    nums = {}\n    (1..n).each do\
    \ |digit|\n        (1..10).each do |one|\n            nums[one] = 1\n        end\n\
    \        (1..9).each do |i|\n            (1..10).each do |j|\n               \
    \ nums[nums.keys[i - 1] * 10 + j] = nums[nums.keys[i - 1]]\n            end\n\
    \        end\n    end\n    nums.values.reduce(:+)\nend", "  n <= 1 ? n :\n   \
    \ n - 1 +\n    (1..9).to_a.map { |i|\n      (10**(n - 1) - 1) / 9\n    }.reduce(:+)\n\
    end", "  # Your code here\nend", "    # n = 1 is the base case\n    return 1 if\
    \ n == 1\n    # n = 2 is the base case\n    return 10 if n == 2\n    return 1\
    \ + 10 * (2**(n-2)) + 10 * (n-2)\nend", "  return 10 if n == 1\n  (81 * (10 **\
    \ (n - 2))).to_i\nend", "  if n == 1\n    return 2\n  end\n  inner_numbers = (10\
    \ ** (n - 2)) * 9\n  2 * inner_numbers + starts_one_ends(n - 1)\nend", "  if n\
    \ == 1\n    return 1\n  end\n  start_with_one(n) + ends_with_one(n)\nend", " \
    \ digits = n.to_s.split('')\n  return 0 if digits.length == 1\n  zeros = '0' *\
    \ (digits.length - 1)\n  digits.inject(0) do |c, d|\n    c += digits_to_i(\"#{d}#{zeros}\"\
    ) + digits_to_i(\"#{zeros}#{d}\")\n  end\nend", "  if n == 1\n    2\n  else\n\
    \    n * 2 * (10 ** (n - 1))\n  end\nend", "  (1..n).map { |i| Math.log10(i).floor\
    \ + 1 }.select { |x| x == n }.count\nend", "  return 10 if n == 1\n  return 9\
    \ * 9**(n - 2) + 10 if n == 2\n  return 9 * 9**(n - 1) + 9 * 9**(n - 2)\nend",
  "  # TODO\nend", "  # what's the base case?\n  return 0 if n == 0", "  return 1\
    \ if n == 1\n  9 * 10**(n-2) + starts_one_ends(n-1)\nend", "  return 1 if n ==\
    \ 1\n  count = 10 ** (n - 1)\n  count += (10 ** (n - 2)) * 9\nend", "  raise unless\
    \ n.is_a?(Integer) && n > 0\n  # The number of n-digit integers that start with\
    \ 1 is 10^(n-1).\n  # The number of n-digit integers that end with 1 is 10^(n-1)\
    \ - 1\n  # (because none of them start with 0).\n  # The number of n-digit integers\
    \ that start or end with 1 is then\n  # 2 * 10^(n-1) - 1.\n  2 * 10**(n-1) - 1\n\
    end", "  return 1 if n == 1\n  return 9 if n == 2\n  return 9 + 9 * 10**(n - 2)\
    \ if n > 2\nend", "  return n if n < 2\n  (10**(n-1) - 10**(n-2)).to_s.chars.map(&:to_i).inject(:+)\n\
    end", "  num_digit_start_one(n) + num_digit_end_one(n)\nend", "  count = 0\n \
    \ for i in 1..9\n    count += (9 * (10 ** (n - 1))) + 1 if i == 1\n    count +=\
    \ 9 * (10 ** (n - 1)) if i != 1\n  end\n  count\nend", "  return -1 if n < 0\n\
    \  return 9 if n == 1\n  return 90 * (10 ** (n - 2))\nend", "    # Base case 1:\n\
    \    if n == 1\n        return 2\n    end\n    # Recursive case 1:\n    if n >\
    \ 1\n        return (starts_one_ends(n-1) * 9) + 10**(n-1)\n    end\nend", " \
    \ arr = []\n  (10**(n-1)).upto(10**n-1) do |i|\n    arr << i if i.to_s.split('').first\
    \ == '1'\n    arr << i if i.to_s.split('').last == '1'\n  end\n  return arr.length\n\
    end", "  return n if n < 1\n  digits = Array.new(n+1, 0)\n  digits[0] = 1\n  for\
    \ i in 1..n\n    digits[i] = digits[i-1] + (9 * 9.upto(10**(i-1)).inject(:*))\n\
    \  end\n  return digits[n]\nend", "  # ...\nend", "\nend", "  # Solution here.\n\
    end", "  if n < 2\n    return 0\n  end\n  starting_with_one = (10 ** (n - 1))\
    \ - 1\n  ending_with_one = 10 ** (n - 1)\n  starting_with_one + ending_with_one\n\
    end", "  return 0 if n == 0\n  return 1 if n == 1\n  (10**(n-1)..10**n-1).count{|i|\
    \ i.to_s =~ /^1/ || i.to_s =~ /1$/}\nend", "  # We can easily construct this by\
    \ hand. n-digit numbers\n  # start with 1: there are 9 possibilities for the rest\
    \ of the digits (0-9).\n  # End with 1: there are 9 possibilities for the rest\
    \ of the digits.\n  # For n == 1: we also count 10\n  (n == 1) ? 10 : 10**(n-1)\
    \ + 10**(n-1)\nend", "  start = n == 1 ? 1 : Math.log10(10 ** (n - 1)).to_i +\
    \ 1\n  end_ = n == 1 ? 1 : Math.log10(10 ** n - 1).to_i + 1\n  start + end_\n\
    end", "  (\"1\" + \"0\" * (n - 1)).to_i + 1..(10 ** n - 1).to_s.rindex(\"1\").to_i\
    \ + 1\nend", "  dp = [[1], [1]]\n  (2..n).each do |k|\n    arr = [1]\n    arr\
    \ << (dp[k - 1][0] + dp[k - 1][1])\n    dp[k] = arr\n  end\n  dp[n][0] + dp[n][1]\n\
    end", "  return 1 if n == 1\n  count_start_with_one(n) + count_end_with_one(n)\n\
    end", "  sum = 0\n  for i in 1..n\n    sum += (\"1\" + \"0\" * (i - 1)).to_i -\
    \ 10 ** (i - 1) + 1\n  end\n  sum\nend", "  (n-1) * 10**(n-2)\nend", "  one_counts\
    \ = 0\n  one_factor = 10 ** (n - 1)\n  (1..9).each do |num|\n    one_counts +=\
    \ 1 if (one_factor * num) % 11 == 0\n  end\n  one_counts\nend", "  if n == 1\n\
    \    return 2\n  else\n    return 1 + 9 * 10 ** (n - 2)\n  end\nend", "  arr =\
    \ []\n  for i in 0..(n)\n    arr.push(10**i)\n  end\n  return arr.reduce(:+)\n\
    end", "  sum = 0\n  return 10 if n == 1\n  (1..n).each do |i|\n    sum += 9 *\
    \ 10 ** (i - 1)\n  end\n  return sum\nend", "  return 1 if n == 1\n  starts_one_ends(n\
    \ - 1) + 9 * starts_one_ends(n - 2)\nend", "  count = 0\n  (1..n).each do |i|\n\
    \    count += 9 * 10 ** (i - 1)\n  end\n  count\nend", "  return 1 if n == 1\n\
    \  (10**(n-1)).to_s[0].to_i + 9 * (10**(n-2)).to_s[0].to_i\nend", "    count =\
    \ 0\n    if n > 0\n        count += 9\n        count += starts_one_ends(n - 1)\n\
    \    end\n    count\nend", "  if n == 1\n    return 2\n  end\n  f = Array.new(n)\n\
    \  f[0] = 2\n  f[1] = 3\n  # f[i] = f[i-1] + f[i-2] (start with 1) + f[i-2] (end\
    \ with 1)\n  for i in 2..n-1\n    f[i] = f[i-1] + f[i-2] + f[i-2]\n  end\n  return\
    \ f[n-1]\nend", "  10**(n-1) + 9*9**(n-1)\nend", "  start_one = 10 ** (n - 1)\n\
    \  end_one = 1 * (n - 1)\n  start_one + end_one\nend", "  failsafe = 10000\n \
    \ results = []\n  start_with_one(n).each do |s|\n    end_with_one(n).each do |e|\n\
    \      results << s + e\n      break if results.length > failsafe\n    end\n \
    \ end\n  results.length\nend", "  if n == 1\n    return 1\n  else\n    arr = [1,1]\n\
    \    for i in 2..n\n      arr[i] = arr[i-1] + (arr[i-2] * 9)\n    end\n    return\
    \ arr[n]\n  end\nend", "  return 0 if n < 1\n  count = 0\n  (10**(n-1)..10**n-1).each\
    \ do |i|\n    if i.to_s[0] == '1' || i.to_s[-1] == '1'\n      count += 1\n   \
    \ end\n  end\n  count\nend", "  if n == 1\n    return 2\n  else\n    return 10\
    \ * starts_one_ends(n - 1) - starts_one_ends(n - 2)\n  end\nend", "  max = 10\
    \ ** n - 1\n  min = 10 ** (n - 1)\n  fives = [5, 25, 125, 625, 3125, 15625, 78125,\
    \ 390625, 1953125, 9765625]\n  if n == 1\n    return 2\n  elsif n == 2\n    return\
    \ 10\n  elsif n % 2 == 0\n    pairs = 10 ** (n / 2) - 1\n    return pairs * pairs\
    \ + 2 * pairs + 2 * fives[n / 2 - 1] + 2\n  else\n    pairs = 10 ** ((n - 1) /\
    \ 2) - 1\n    odd_digits = 10 ** ((n - 1) / 2)\n    return 2 * pairs * pairs +\
    \ 2 * pairs + 2 * odd_digits + 2\n  end\nend", "    start_one(n) + end_one(n)\n\
    end", "  (1..9).reduce(0) { |a, e| a + (e.to_s * n).to_i + 1 }\nend", "  return\
    \ 2 if n == 1\n  return 9 if n == 2\n  (1..n).inject(0) { |total, i| total +=\
    \ num_starting_one(i) }\nend", "  # your code here\nend", "  10 ** (n - 1)\nend",
  "  return n if n <= 10\n  10 ** (n - 1) + 9 * (10 ** (n - 2))\nend", "  # TODO\n\
    end", "  return 0 if n < 1\n  return 10 if n == 1\n  return 11 if n == 2\n  a\
    \ = [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]\n  (n - 3).times do\n    a.each_with_index\
    \ do |v, i|\n      a[i] = 0\n      (1..9).each do |j|\n        next if j == 4\n\
    \        a[i] += 1 if (j + i) % 10 == 1\n      end\n    end\n  end\n  sum = 0\n\
    \  (1..9).each do |i|\n    next if i == 4\n    sum += 1 if (i + 1) % 10 == 1\n\
    \  end\n  sum + a.inject(:+)\nend", "  return 1 if n == 1\n  # one way to get\
    \ a 1 at the end is to start with a 1\n  # if we already have a 1 at the start,\
    \ then it takes 10^(n-2) to get a 1 at the end\n  1 + 10 ** (n - 2)\nend", " \
    \ count = 0\n  return 0 if n == 1\n  (1..n-1).each do |x|\n    count += 10**x\n\
    \  end\n  count * 2\nend", "  n.times.inject(0) { |sum, i| sum + 9*(10**i) }\n\
    end", "  (1..n).each.map { |e| (10**(e-1)) + 1 }.select { |e| e.to_s[0] == '1'\
    \ || e.to_s[-1] == '1' }.count\nend", "  n.to_s.include?('1') ? n.to_s.size *\
    \ 9 ** (n - 1) : 9 ** n\nend", "  (1..9).to_a.map { |x| x.to_s + (10**(n-1) -\
    \ 1).to_s }.map(&:to_i).count\nend", "  (1..9).to_a.map { |x| x.to_s.ljust(n,\
    \ '0').to_i + 1 }.inject(:+)\nend", "  x = 9 * 10 ** (n - 1)\n  y = 10 ** (n -\
    \ 1)\n  x + y\nend", "  return 0 if n == 0\n  return 1 if n == 1\n  return 0 if\
    \ n % 2 == 0\n  10**(n/2-1) + ends_one_starts(n-1)\nend", "  return 0 if n <=\
    \ 1\n  return 9 if n == 2\n  dp = [1, 0, 9] # dp[i] = number of i-digit start_one_end\n\
    \  (3..n).each do |i|\n    dp[i] = 10 * dp[i - 1] + 9 * 10 ** (i - 2)\n  end\n\
    \  dp[n]\nend", "  # TODO\nend", "  1\nend", "    if n == 1\n        return 2\n\
    \    end\n    return 10**(n-1) + starts_one_ends(n-1)\nend", "  return 10 if n\
    \ == 1\n  return 20 if n == 2\n  a = 10; b = 20\n  for i in 3..n\n    c = a +\
    \ b\n    a = b\n    b = c\n  end\n  c\nend", "  n < 2 ? n : (((n-1)*10 + 9) +\
    \ (n-1))\nend", "  if n == 1\n    return 2\n  end\n  return 10 * (10 ** (n - 2))\
    \ + 2\nend", "  if n == 1\n    return 2\n  end\n  (3 * (10 ** (n - 1)) - 2 * (9\
    \ ** n))\nend", "  raise \"n must be at least 1\" if n < 1\n  return 1 if n ==\
    \ 1\n  return 10 if n == 2\n  return 10 + 9 * 9 + (n - 3) * 9 * 8 + starts_one_ends(n\
    \ - 1)\nend", "  # write your code here\nend", end, "  # First, count all numbers\
    \ of length n. There are ten options to choose\n  # the first digit, and then\
    \ 9 for the rest, since we can't choose 0.\n  nums = 10 * 9**(n - 1)", "  # Your\
    \ code here\nend", "  10**(n-1) + 10**(n-2) - 2\nend", "  if n < 1\n    return\
    \ 0\n  elsif n == 1\n    return 1\n  else\n    return (starts_one_ends(n-1)*9)\
    \ + 9\n  end\nend", "  (n - 1) * 2 ** (n - 1)\nend", "  return 0 if n <= 0\n \
    \ return 1 if n == 1\n  starts_one_ends(n - 1) + starts_one_ends(n - 2)\nend",
  "  if n > 1\n    res = (10**(n-1)) + starts_one_ends(n-1)\n  else\n    res = 1\n\
    \  end\n  res\nend", "  (\"1\" * n + \"0\" * (n - 1)).to_i - (\"1\" * (n - 1)\
    \ + \"0\" * n).to_i\nend", "  # If a number ends in 1, then there are 10 choices\
    \ for the first digit,\n  # and 9 choices for each of the following digits. If\
    \ a number starts in 1,\n  # then there are 9 choices for the first digit, and\
    \ 9 choices for each of\n  # the following digits.\n  # Since a number can start\
    \ in 1 and end in 1, we need to subtract that case.\n  # The sum of this is:\n\
    \  (1..n).map { |k| 9**k }.reduce(:+) + (1..n-1).map { |k| 9**k }.reduce(:+) -\
    \ 1\nend", "  count = 0\n  n.times do |i|\n    count += count_n_digit_sequence(i\
    \ + 1) - count_n_digit_sequence(i)\n  end\n  count\nend", "  x = 1\n  (1..n).each\
    \ do |_|\n    x = x * 10 + 1\n  end\n  # The calculation begins...\n  (1..(x /\
    \ 10)).map do |j|\n    # ... with the number (1^1)*10^(n-1)\n    ((x / 10)..x).map\
    \ do |i|\n      # ... and ends with the number (1^1)*10^n-1\n      i.to_s.each_char.to_a.map(&:to_i).inject(:+)\n\
    \    end.inject(:+)\n  end.inject(:+)\nend", "  # Handle the base case\n  return\
    \ 0 if n <= 0", "  ##############\n  #\n  #\n  #\n  ##############\nend", "  return\
    \ 1 if n == 1\n  d = 10**(n-1)\n  d + starts_one_ends(n-1)\nend", "  if n == 1\n\
    \    2\n  else\n    res = 2 * starts_one_ends(n - 1) + 10 ** (n - 1)\n    res\
    \ - 2\n  end\nend", "  # TODO: your code here\nend", "  n < 2 ? 0 : (2**(n-1)\
    \ + starts_one_ends(n-1))\nend", "  return 0 if n <= 0\n  (n-1) * 9 + 1\nend",
  "  return 1 if n == 1\n  return 10 if n == 2\n  a = 9\n  b = 9\n  c = 8\n  i = 2\n\
    \  while i < n\n    d = a + b\n    a = b\n    b = c\n    c = d\n    i += 1\n \
    \ end\n  d\nend", "  # 10 ** (n - 1)\n  10 ** (n - 1) +\n    # (10 ** (n - 1)\
    \ - 1) * 9\n    ((10 ** (n - 1) - 1) * 9)\nend", "  return 0 if n == 0\n  # Compute\
    \ 10^(n-1)\n  a = 1\n  (n-1).times do\n    a *= 10\n  end\n  # The answer is 10(n-1)\
    \ + 1\n  a * 10 + 1\nend", "  # n = 1: we have 1 number that starts with one (1)\n\
    \  # n = 2: we have (10...19), which is 10 numbers\n  # n = 3: we have (10...19)\
    \ and (100...199), which is 20 numbers\n  # n = 4: we have (10...19), (100...199),\
    \ and (1000...1999), which is 30 numbers\n  # this pattern is the same as (10**(n-1))*2\n\
    \  # to account for the ones that end with one, we do the same pattern\n  # and\
    \ subtract 1 since we're counting 1 as ending with one\n  (10**(n-1))*2 - 1\n\
    end", "  n <= 1 ? 0 : n * 9 ** (n - 1) + starts_one_ends(n - 1)\nend", "  return\
    \ 0 if n == 0\n  return 10 if n == 1\n  return 11 * (1..(n - 2)).inject(:*) +\
    \ 10 * (n - 1) * (1..(n - 2)).inject(:*)\nend", "  return 0 if n < 1\n  return\
    \ 1 if n == 1\n  return 10 if n == 2\n  end_at_one(n-1) + start_at_one(n-1)\n\
    end", "  if n == 1\n    return 2\n  else\n    return starts_one_ends(n-1) + 9\
    \ * (10 ** (n-2))\n  end\nend", "  # convert to string and count 1s\n  (n**2).to_s.count('1')\n\
    end", "  f = ->(n) { return 1 if n == 1; f[n - 1] + (n - 1) * 9 }\n  return f[n]\n\
    end", "    if n < 1\n        return 0\n    elsif n == 1\n        return 1\n  \
    \  end\n    return starts_one_ends(n-1) + 10 * starts_one_ends(n-2)\nend", " \
    \ return 2 if n == 1\n  start_one = 9.downto(1).to_a.reduce(:*)\n  end_one = 9.downto(1).to_a.reduce(:*)\n\
    \  start_one + end_one\nend", "  (1..9).select{|i| i.to_s.length == n}.count *\
    \ 2\nend", end, "\nend", "  one_count(n) + one_count(n-1)\nend", "  return 1 if\
    \ n <= 1\n  return 10 if n == 2\n  (10 ** (n - 1) - 1) + (10 ** (n - 2))\nend",
  "  count = 0\n  (10**(n-1)..10**n-1).each do |number|\n    number_string = number.to_s\n\
    \    if number_string[0] == '1' || number_string[-1] == '1'\n      count += 1\n\
    \    end\n  end\n  count\nend", "  return n * 9 * (10 ** (n - 1)) if n > 1\n \
    \ 10\nend", "  return 10 if n == 1\n  rest = (n - 2) * 9\n  10 + rest\nend", " \
    \ dp = [1, 1]\n  (2..n).each do |i|\n    dp[i] = dp[i - 1] + dp[i - 2] * 10**(i\
    \ - 2)\n  end\n  dp[n]\nend", "    # 0 - 1 digit -> 1\n    # 1 - 1 digit -> 1\n\
    \    # 2 - 2 digits -> 11, 21\n    # 3 - 3 digits -> 111, 211, 121, 221\n    #\
    \ 4 - 4 digits -> 1111, 2111, 1211, 2211, 1121, 2121, 1221, 2221\n    # 5 - 5\
    \ digits -> 11111, 21111, 12111, 22111, 11211, 21211, 12211, 22211, 11121, 21121,\
    \ 12121, 22121, 11221, 21221, 12221, 22221\n    # 6 - 6 digits -> 111111, 211111,\
    \ 121111, 221111, 112111, 212111, 122111, 222111, 111211, 211211, 121211, 221211,\
    \ 112211, 212211, 122211, 222211, 111121, 211121, 121121, 221121, 112121, 212121,\
    \ 122121, 222121, 111221, 211221, 121221, 221221, 112221, 212221, 122221, 222221\n\
    \    # 7 - 7 digits -> 1111111, 2111111, 1211111, 2211111, 1121111, 2121111, 1221111,\
    \ 2221111, 1112111, 2112111, 1212111, 2212111, 1122111, 2122111, 1222111, 222211",
  "  (10**(n-1)) + (n-1)*9*(10**(n-2))\nend", "  return 1 if n == 1\n  start_end_one_count(n)\
    \ + starts_one_ends(n - 1)\nend", "  count_one_ends(n) + count_one_starts(n)\n\
    end", "  # all the n-digit numbers with 1 as a start\n  start_ones = 9 * 10 **\
    \ (n - 1)\n  # all the n-digit numbers with 1 as an end\n  end_ones = 10 ** (n\
    \ - 1)\n  start_ones + end_ones\nend", "  return 0 if n == 0\n  s = Array.new(n+1)\
    \ { Array.new(2, 0) }\n  (0..9).each do |i|\n    s[1][i == 1 ? 1 : 0] += 1\n \
    \ end\n  (2..n).each do |i|\n    (0..9).each do |j|\n      (0..9).each do |k|\n\
    \        s[i][j == 1 ? 1 : 0] += s[i-1][k == 1 ? 1 : 0]\n      end\n    end\n\
    \  end\n  s[n][1]\nend", "  n_str = n.to_s\n  return n_str.count('1') + (n_str.length-1)\
    \ * (n_str.length - n_str.count('1'))\nend", "  # 10**(n-1) for first digit, 9\
    \ * 10**(n-2) for last digit, 1 for the\n  # case where the first and last digits\
    \ are both 1.\n  10**(n-1) + 9 * 10**(n-2) + 1\nend", "  return n\nend", "  (10**(n-1))\
    \ + (9*(10**(n-2)))\nend", "  base = 10 ** (n - 1)\n  ((base * 10) - base) * 2\
    \ + (base - 1) * n\nend", "  str = \"1\" * n\n  (1..9).map { |d| str.gsub(/1/,\
    \ d.to_s) }.select { |s| s.to_i.to_s == s }.count\nend", "  return 1 if n == 1\n\
    \  base = 10**(n-1)\n  ones = base + 9\n  # build the numbers not starting with\
    \ 1\n  n1 = ones\n  n2 = 0\n  11.upto(base-1) do |i|\n    if i % 10 == 0\n   \
    \   n1 -= 1\n    else\n      n2 += 1\n    end\n  end\n  n1 + n2 * 2\nend", " \
    \ str_num = '1' * n\n  arr = str_num.split('')\n  arr.permutation.map(&:join).uniq.size\n\
    end", "  valid_numbers(n).count { |x| x.to_s.match(/\\A1|1\\z/) }\nend", "  1\
    \ * 10**(n-1) + (n-1) * 9 * 10**(n-2)\nend", "  if n == 1\n    2\n  else\n   \
    \ (10 ** (n - 1)) + (n - 1) * 9\n  end\nend", "  count = 0\n  (10**(n-1)..10**n-1).each\
    \ do |i|\n    i_s = i.to_s\n    count += 1 if i_s[0] == '1' || i_s[-1] == '1'\n\
    \  end\n  count\nend", "  return 0 if n == 0\n  count = 0\n  10.times do |i|\n\
    \    count += count_numbers(i, n - 1)\n  end\n  count\nend", '  n_len = n.to_s.length',
  "  if n == 1\n    return 2\n  else\n    return 10 ** (n - 1) + starts_one_ends(n\
    \ - 1)\n  end\nend", "  (1..9).map{|d| (d.to_s*n).to_i}.map{|n| n.to_s}.map{|s|\
    \ s.count('1')}.inject(:+)\nend", "  count = 1\n  # for each number of digits,\
    \ we have 10 choices for the ones place, 9 choices\n  # for the tens place, etc.\n\
    \  (n - 1).times do\n    count *= 10\n    count -= 1\n  end\n  count * 2\nend",
  "  starts_one(n) + ends_one(n)\nend", "  return 0 if n == 0\n  return 10 if n ==\
    \ 1\n  return (10**(n-1)) + (10**(n-2))\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
