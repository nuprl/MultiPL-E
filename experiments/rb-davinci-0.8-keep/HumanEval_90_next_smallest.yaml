name: HumanEval_90_next_smallest
language: rb
prompt: "# You are given a list of integers.\n# Write a function next_smallest() that\
  \ returns the 2nd smallest element of the list.\n# Return None if there is no such\
  \ element.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3,\
  \ 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\ndef next_smallest(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_next_smallest\n\
  \    candidate = method(:next_smallest)\n    assert_equal(2, candidate.call([1,\
  \ 2, 3, 4, 5]))\n    assert_equal(2, candidate.call([5, 1, 4, 3, 2]))\n    assert_equal(nil,\
  \ candidate.call([]))\n    assert_equal(nil, candidate.call([1, 1]))\n    assert_equal(1,\
  \ candidate.call([1, 1, 1, 1, 0]))\n    assert_equal(nil, candidate.call([1, 1]))\n\
  \    assert_equal(-35, candidate.call([-35, 34, 12, -45]))\n  end\nend\n"
completions: ["  lst.sort[1] if lst.uniq.length >= 2\nend", "  smallest = nil\n  second_smallest\
    \ = nil\n  lst.each do |num|\n    if smallest.nil? || num < smallest\n      second_smallest\
    \ = smallest\n      smallest = num\n    elsif second_smallest.nil? || num < second_smallest\n\
    \      second_smallest = num\n    end\n  end\n  second_smallest\nend", "\tsorted_lst\
    \ = lst.sort\n\tn = sorted_lst.length\n\tif n == 0 || n == 1\n\t\treturn nil\n\
    \telse\n\t\treturn sorted_lst[1]\n\tend\nend", "\tmax = lst.max\n\tmin = lst.min\n\
    \tresult = 0\n\tlst.each do |x|\n\t\tif x != max && x != min\n\t\t\tresult = x\n\
    \t\tend\n\tend\n\tif result == 0\n\t\treturn nil\n\telse\n\t\treturn result\n\t\
    end\nend", "  return nil if lst.size < 2\n  return nil if lst.uniq.size == 1\n\
    \  lst.sort!\n  lst[1]\nend", "  return nil if lst.empty? || lst.uniq.size < 2\n\
    \  lst.uniq.sort[1]\nend", "  lst.sort[1]\nend", "  lst.size < 2 ? nil : lst.uniq.sort[1]\n\
    end", "  lst.uniq.sort[1]\nend", "  lst.size < 2 ? nil : lst.min(2).max\nend",
  "  return nil if lst.length < 2\n  lst.sort.reject{|el| el == lst.min}.min\nend",
  "  lst.sort!\n  if lst[1] == lst[0]\n    return nil\n  else\n    return lst[1]\n\
    \  end\nend", "  if lst.empty?\n    return nil\n  end\n  if lst.length == 1\n\
    \    return nil\n  end\n  lst.sort!\n  c1 = lst[0]\n  if c1 != lst[1]\n    return\
    \ lst[1]\n  end\n  return nil\nend", "\nend", "\tif lst.length <= 1\n\t\treturn\
    \ nil\n\tend\n\tmin = lst[0]\n\tnext_min = nil\n\tlst.each do |num|\n\t\tif num\
    \ < min\n\t\t\tnext_min = min\n\t\t\tmin = num\n\t\telsif (num < next_min || next_min\
    \ == nil) && num != min\n\t\t\tnext_min = num\n\t\tend\n\tend\n\treturn next_min\n\
    end", "  lst.min(2)[1]\nend", "  if lst.empty?\n    return nil\n  end\n  min =\
    \ lst.min\n  min2 = min\n  for i in lst\n    if i < min\n      min2 = min\n  \
    \    min = i\n    elsif i > min && i < min2\n      min2 = i\n    end\n  end\n\
    \  if min2 == min\n    return nil\n  end\n  return min2\nend", "  second_smallest\
    \ = nil\n  smallest = nil\n  lst.each do |element|\n    if smallest == nil\n \
    \     smallest = element\n    elsif second_smallest == nil\n      if element ==\
    \ smallest\n        second_smallest = element\n      elsif element < smallest\n\
    \        second_smallest = smallest\n        smallest = element\n      else\n\
    \        second_smallest = element\n      end\n    else\n      if element < smallest\n\
    \        second_smallest = smallest\n        smallest = element\n      elsif element\
    \ == smallest\n        second_smallest = element\n      elsif element < second_smallest\n\
    \        second_smallest = element\n      end\n    end\n  end\n  second_smallest\n\
    end", "\t# if lst.size == 0\n\t# \treturn nil\n\t# end\n\t# if lst.size == 1\n\
    \t# \treturn nil\n\t# end\n\t# lst = lst.sort\n\t# return lst[1]\n\tlst.sort[1]\n\
    end", "  if lst.size < 2\n    return nil\n  end\n  new = lst.uniq.sort\n  return\
    \ new[1]\nend", "  return nil if lst.length < 2\n  return nil if lst.uniq.length\
    \ == 1\n  sorted = lst.sort\n  sorted[1]\nend", "  if lst.size <= 1\n    return\
    \ nil\n  end\n  if lst.size == 2\n    if lst[0] != lst[1]\n      return lst[1]\n\
    \    else\n      return nil\n    end\n  end\n  min = lst[0]\n  min_index = 0\n\
    \  second_min = nil\n  second_min_index = nil\n  (1..lst.size-1).each do |i|\n\
    \    if lst[i] < min\n      min = lst[i]\n      min_index = i\n    elsif lst[i]\
    \ > min && (second_min == nil || lst[i] < second_min)\n      second_min = lst[i]\n\
    \      second_min_index = i\n    end\n  end\n  if second_min == nil\n    return\
    \ nil\n  else\n    return second_min\n  end\nend", "  smallest = nil\n  second_smallest\
    \ = nil\n  lst.each do |item|\n    if second_smallest\n      if smallest && item\
    \ < smallest\n        second_smallest = smallest\n        smallest = item\n  \
    \    elsif item < second_smallest\n        second_smallest = item\n      end\n\
    \    else\n      smallest = item\n    end\n  end\n  second_smallest\nend", " \
    \ lst.uniq.sort[1]\nend", "  fst = lst.first\n  snd = nil\n  lst.each do |e|\n\
    \    if fst && e < fst\n      snd = fst\n      fst = e\n    elsif fst && e < snd\n\
    \      snd = e\n    end\n  end\n  snd\nend", "\nend", "  lst.uniq.sort[1] || nil\n\
    end", "  return nil if lst.size < 2\n  lst.sort[1]\nend", end, "  lst = lst.uniq.sort\n\
    \  lst[1]\nend", "  return nil if lst.size < 2\n  lst.delete_if { |i| lst.count(i)\
    \ > 1 }\n  lst.minmax[1]\nend", "  lst.uniq.sort[1]\nend", end, "  # ...\nend",
  "    # lst.uniq!\n    lst.min(2)[1]\nend", "    a = lst.uniq.sort\n    if a.length\
    \ < 2\n        return nil\n    else\n        return a[1]\n    end\nend", "  puts\
    \ \"Got #{lst}\"\n  lst.sort!.uniq!", "  lst = lst.uniq.sort\n  lst[1]\nend",
  "\t# solution 1\n\t# n = lst.uniq.sort[1] \n\t# n ? n : nil", "    if lst.length\
    \ < 2\n        return nil\n    end\n    smallest = lst[0]\n    second = nil\n\
    \    lst.each do |element|\n        if element <= smallest\n            second\
    \ = smallest\n            smallest = element\n        elsif element <= second\
    \ || second == nil\n            second = element\n        end\n    end\n    return\
    \ second\nend", "  if lst.uniq.length == 1\n    nil\n  else\n    lst.uniq.sort[1]\n\
    \  end\nend", "  sorted = lst.sort\n  return nil if sorted.length < 2 || sorted[0]\
    \ == sorted[1]\n  sorted[1]\nend", "  lst.sort[1] || nil\nend", "    # raise NotImplementedError\n\
    \    # return nil if lst.empty? || lst.uniq.size == 1\n    # sorted = lst.sort\n\
    \    # sorted[1]", "  lst.sort[1]\nend", "  return nil if lst.empty?\n  lst.sort[1]\n\
    end", "    # your code here\nend", "  second_smallest = nil\n  if lst.length ==\
    \ 0\n    return second_smallest\n  end\n  smallest = lst[0]\n  lst.each do |n|\n\
    \    if n < smallest\n      second_smallest = smallest\n      smallest = n\n \
    \   elsif (n < second_smallest) && (n != smallest)\n      second_smallest = n\n\
    \    end\n  end\n  second_smallest\nend", "  min1 = min2 = nil\n  lst.each do\
    \ |val|\n    if !min1 || val < min1\n      min2 = min1\n      min1 = val\n   \
    \ elsif !min2 || val < min2\n      min2 = val\n    end\n  end\n  min2\nend", " \
    \ return nil if lst.length < 2\n  min, min2 = nil, nil\n  lst.each do |item|\n\
    \    min = item if min.nil? || item < min\n  end\n  lst.each do |item|\n    min2\
    \ = item if item > min && (min2.nil? || item < min2)\n  end\n  min2\nend", " \
    \ lst.uniq.sort[1] || nil\nend", "  lst = lst.uniq.sort\n  lst[1]\nend", "  lst.sort[1]\n\
    end", "\tlst = lst.sort\n\tif lst.size > 1\n\t\tif lst[0] == lst[1]\n\t\t\treturn\
    \ nil\n\t\telse\n\t\t\treturn lst[1]\n\t\tend\n\tend\n\treturn nil\nend", "  new_lst\
    \ = lst.uniq.sort\n  return new_lst[1] if new_lst.length > 1\n  nil\nend", " \
    \   lst.sort.uniq[1]\nend", "  new_lst = lst.uniq.sort!\n  new_lst[1] == nil ?\
    \ nil : new_lst[1]\nend", "  min, min2 = [nil, nil]\n  lst.each do |i|\n    if\
    \ min == nil || i < min\n      min2 = min\n      min = i\n    elsif min2 == nil\
    \ || i < min2\n      min2 = i\n    end\n  end\n  min2\nend", end, "  lst.sort!\n\
    \  lst.length <= 1 ? nil : lst[1]\nend", "  #TODO \nend", "  # your code here\n\
    end", "  return nil if lst.length < 2\n  x = lst.sort.uniq.shift(2)\n  x.length\
    \ == 2 ? x.last : nil\nend", "    return lst.sort[1]\nend", "  lst.sort!\n  uniq\
    \ = lst.uniq\n  uniq.length > 1 ? uniq[1] : nil\nend", "  if lst.size < 2\n  \
    \  return nil\n  end\n  lst.sort.uniq[1]\nend", "  return nil if lst.nil? || lst.empty?\n\
    \  lst.sort!\n  lst.uniq.size > 1 ? lst[1] : nil\nend", "  return nil if lst.empty?\
    \ || lst.uniq.size == 1\n  lst.sort.uniq[1]\nend", "  if lst.length == 0\n   \
    \ nil\n  elsif lst.length == 1\n    nil\n  elsif lst.length == 2\n    lst[0] if\
    \ lst[0] == lst[1]\n  else\n    lst.sort!\n    if lst[0] == lst[1]\n      next_smallest(lst[1..-1])\n\
    \    else\n      lst[1]\n    end\n  end\nend", end, "  return nil if lst.length\
    \ < 2\n  lst.uniq!\n  lst.sort!\n  lst[1]\nend", "  # your code here\nend", " \
    \ lst.uniq.sort[1]\nend", "  return nil if lst.empty? || lst.uniq.size == 1\n\
    \  lst.minmax.reverse[1]\nend", "  return nil if lst.length < 2\n  sorted = lst.sort\n\
    \  i = 0\n  while i < sorted.length\n    if sorted[i] != sorted[i + 1]\n     \
    \ return sorted[i + 1]\n    end\n    i += 1\n  end\n  nil\nend", "  if lst.length\
    \ == 0 || lst.length == 1 || lst.length == 2\n    return nil\n  end\n  lst.sort!\n\
    \  return lst[1]\nend", "  if lst.empty? || lst.uniq.length == 1\n    return nil\n\
    \  else\n    return lst.sort[1]\n  end\nend", "  sorted = lst.sort\n  sorted.each_with_index\
    \ do |el, i|\n    return el if sorted[i + 1] != el\n  end\n  nil\nend", "  lst.size\
    \ > 1 ? lst.sort[1] : nil\nend", "  return nil if lst.empty?\n  lst.uniq!\n  lst.sort!\n\
    \  lst[1] || nil\nend", "  return nil if lst.length <= 1\n  lst.sort[1]\nend",
  "  lst.sort!\n  lst.uniq.length > 1 ? lst[1] : nil\nend", "  if lst.length < 2\n\
    \    return nil\n  end\n  if lst.uniq.length < 2\n    return nil\n  end\n  lst.sort!\n\
    \  lst[1]\nend", "  # Base case: 1 element or less\n  return nil if lst.length\
    \ <= 1", "  lst.sort[1]\nend", "    if lst.size == 1\n        return nil\n   \
    \ end\n    sm1 = lst[0]\n    sm2 = nil\n    lst.each do |i|\n        if i <= sm1\n\
    \            sm2 = sm1\n            sm1 = i\n        elsif i <= sm2 || sm2 ==\
    \ nil\n            sm2 = i\n        end\n    end\n    return sm2\nend", "  # return\
    \ lst.uniq.sort[1]\n  lst.uniq.sort[1]\nend", "    if lst.length > 1\n       \
    \ if lst[0] < lst[1]\n            min1 = lst[0]\n            min2 = lst[1]\n \
    \       else\n            min1 = lst[1]\n            min2 = lst[0]\n        end\n\
    \        (2...lst.length).each do |i|\n            if lst[i] < min1\n        \
    \        min2 = min1\n                min1 = lst[i]\n            elsif lst[i]\
    \ < min2\n                min2 = lst[i]\n            end\n        end\n      \
    \  min2\n    end\nend", "  lst.uniq.sort[1]\nend", "    return nil if lst.length\
    \ < 2\n    return nil if lst.length == 2 && lst[0] == lst[1]\n    second_smallest\
    \ = lst[0]\n    smallest = lst[0]\n    lst.each do |el|\n        if el < smallest\n\
    \            second_smallest = smallest\n            smallest = el\n        elsif\
    \ el < second_smallest\n            second_smallest = el\n        end\n    end\n\
    \    second_smallest\nend", "  smallest = lst.min\n  next_smallest = (lst.max\
    \ - 1)\n  i = 0\n  while i < lst.length\n    if lst[i] > smallest && lst[i] <\
    \ next_smallest\n      next_smallest = lst[i]\n    end\n    i += 1\n  end\n  next_smallest\
    \ == (lst.max - 1) ? nil : next_smallest\nend", "  # your code here\nend", " \
    \ lst.sort!\n  lst.select { |e| e != lst.first }.first\nend", "    return lst.sort()[1]\
    \ if lst.length > 1 && lst.uniq.length > 1\n    return nil\nend", "  if lst.length\
    \ < 2\n    return nil\n  end\n  if lst.uniq.length < 2\n    return nil\n  end\n\
    \  lst.sort[1]\nend", "  m, n = 1/0.0, 1/0.0\n  lst.each do |n|\n    if n < m\n\
    \      m, n = n, m\n    elsif n < n\n      n = n\n    end\n  end\n  n\nend", " \
    \ return nil if lst.empty?\n  sorted = lst.sort\n  sorted.uniq == sorted ? sorted[1]\
    \ : sorted[0]\nend", "  lst = lst.uniq\n  return nil if lst.empty? || lst.size\
    \ == 1\n  lst.sort!\n  lst[1]\nend", "  # Your code here\nend", "    return nil\
    \ if lst.length < 2\n    lst.sort!\n    (1...lst.length).each do |i|\n       \
    \ return lst[i] if lst[i] != lst[i-1]\n    end\n    nil\nend", "  lst.sort!\n\
    \  if lst.length > 1\n    lst.uniq!\n    return lst[1]\n  else\n    return nil\n\
    \  end\nend", "  return if lst.empty?\n  lst.sort.uniq[1]\nend", "  # code here\n\
    end", "  return nil if lst.empty? || lst.length == 1\n  min, min2 = nil\n  lst.each\
    \ do |el|\n    if min2.nil? || el < min2\n      min2 = el\n    end\n    if min.nil?\
    \ || el < min\n      min2 = min\n      min = el\n    end\n  end\n  min2\nend",
  "  if lst.length <= 1 || lst.uniq.length <= 1\n    return nil\n  end\n  lst.uniq.sort[1]\n\
    end", "  if lst.length <= 1\n    return nil\n  end\n  if lst.uniq.length == 1\n\
    \    return nil\n  end\n  sorted = lst.sort\n  return sorted[1]\nend\nputs(\"\\\
    nTests for #next_smallest\")\nputs(\"===============================================\"\
    )\n    puts \"next_smallest([1, 2, 3, 4, 5]) == 2: \"  + (next_smallest([1, 2,\
    \ 3, 4, 5]) == 2).to_s\n    puts \"next_smallest([5, 1, 4, 3, 2]) == 2: \"  +\
    \ (next_smallest([5, 1, 4, 3, 2]) == 2).to_s\n    puts \"next_smallest([]) ==\
    \ nil: \"  + (next_smallest([]) == nil).to_s\n    puts \"next_smallest([1, 1])\
    \ == nil: \"  + (next_smallest([1, 1]) == nil).to_s\nputs(\"===============================================\"\
    )", "  lst.uniq.sort.reverse[1]\nend", "\tif lst.size == 0\n\t\treturn nil\n\t\
    elsif lst.size == 1\n\t\treturn nil\n\telse\n\t\tarr = lst.sort\n\t\tif arr[0]\
    \ == arr[1]\n\t\t\treturn nil\n\t\telse\n\t\t\treturn arr[1]\n\t\tend\n\tend\n\
    end", "  lst.sort[1] || nil\nend", "  return nil if lst.empty? || lst.uniq.length\
    \ == 1\n  uniq = lst.uniq.sort\n  uniq[1]\nend", "\treturn nil if lst.length <\
    \ 2\n\treturn nil if lst.uniq.length == 1\n\tlst.sort.uniq[1]\nend", "\tlst.uniq.sort[1]\n\
    end", "  return nil if lst.empty? || lst.uniq.length == 1\n  lst.sort[1]\nend",
  "\t\nend", "  # write your code here\nend", "  sorted = lst.sort\n  sorted.each_with_index\
    \ do |e, i|\n    if i > 0 && e != sorted[i-1]\n      return e\n    end\n  end\n\
    \  return nil\nend", "  return if lst.empty?\n  lst.uniq!\n  lst.length > 1 ?\
    \ lst.sort[1] : nil\nend", "  lst.sort!\n  return lst[1] if lst.uniq.size > 1\n\
    \  nil\nend\np next_smallest([5, 1, 4, 3, 2])", "  lst.uniq.sort[1] || nil\nend",
  "  lst.uniq.sort[1]\nend", "\tsorted = lst.sort\n\ti = 0\n\twhile sorted[i] == sorted[i+1]\n\
    \t\ti += 1\n\tend\n\treturn sorted[i+1]\nend", "  return nil if lst.empty?\n \
    \ min = lst.min\n  return nil if lst.count(min) == lst.size\n  lst.reject{|n|\
    \ n == min}.min\nend", "  lst.sort!.uniq!\n  lst[1]\nend", "  # TODO: implement\n\
    end", "  # lst.uniq.size < 2 ? nil : lst.uniq.sort[1]\n  lst.uniq.size < 2 ? nil\
    \ : lst.uniq.minmax[1]\nend", "    return nil if lst.length < 2\n    return nil\
    \ if lst.uniq.length == 1\n    lst.sort[1]\nend", end, "  lst.uniq.sort[1]\nend",
  "  lst[1] if lst.size > 1\nend", "  return nil if lst.empty?\n  return nil if lst.uniq.size\
    \ == 1\n  lst.uniq.sort[1]\nend", "  lst.uniq!\n  return nil if lst.length <=\
    \ 1\n  lst.sort[1]\nend", "  return nil if lst.size < 2\n  arr = lst.uniq.sort\n\
    \  arr[1]\nend", "  if lst.size < 2\n    return nil\n  end\n  if lst.size == 2\n\
    \    if lst[0] != lst[1]\n      return lst[1]\n    else\n      return nil\n  \
    \  end\n  end\n  lst.sort[1]\nend", "  return nil if lst.empty? || lst.uniq.size\
    \ < 2\n  min = lst.min\n  lst.reject! { |num| num == min }\n  lst.min\nend", " \
    \ return nil if lst.length < 2\n  lst.sort.uniq[1]\nend", "\tlst.sort!\n\tif lst.length\
    \ < 2\n\t\tnil\n\telse\n\t\tcurrent_smallest = lst[0]\n\t\tlst.each do |x|\n\t\
    \t\tif x > current_smallest\n\t\t\t\treturn x\n\t\t\tend\n\t\tend\n\t\tnil\n\t\
    end\nend", "  return nil if lst.length <= 1\n  lst.sort!\n  return nil if lst[0]\
    \ == lst[1]\n  lst[1]\nend", "  return nil if lst.empty?\n  min = lst.min\n  return\
    \ nil if lst.count(min) == lst.size\n  lst.delete(min)\n  return lst.min\nend\n\
    p next_smallest([1, 2, 3, 4, 5]) == 2\np next_smallest([5, 1, 4, 3, 2]) == 2\n\
    p next_smallest([]) == nil\np next_smallest([1, 1]) == nil", "  lst.uniq.sort[1]\n\
    end", "  if lst.length == 0 || lst.uniq.length < 2\n    return nil\n  else\n \
    \   lst.uniq.sort[1]\n  end\nend", "  return if lst.empty?\n  lst.sort!\n  lst.each_with_index\
    \ do |el, i|\n    return lst[i + 1] if lst[i + 1] != el\n  end\n  nil\nend", " \
    \ # please complete this function\nend", "  lst.uniq.sort[1]\nend", "  lst.sort.uniq[1]\n\
    end", "  lst = lst.sort\n  if lst.length > 2\n    return lst[1]\n  else\n    return\
    \ nil\n  end\nend", "  sorted = lst.sort\n  sorted[1] ? sorted[1] : nil\nend",
  "  lst.sort.uniq[1]\nend", "  return nil if lst.empty?\n  return nil if lst.uniq.length\
    \ < 2\n  lst.uniq.sort[1]\nend", "  sorted = lst.sort\n  return sorted[1]\nend",
  "  lst.sort!\n  return nil if lst.size <= 1\n  lst[1]\nend", "  lst.sort[1]\nend",
  "  return nil if lst.empty?\n  lst.sort!.each_with_index do |e, i|\n    return e\
    \ if e != lst[i+1]\n  end\n  nil\nend", "  # your code here\nend", "  return nil\
    \ if lst.empty?\n  lst.sort[1]\nend", "  lst.delete(lst.min) if lst.length > 1\n\
    \  lst.min\nend", "\ta = lst.sort\n\ta.length == 0 || a.length == 1 ? nil : a[1]\n\
    end", "  lst.sort.uniq[1]\nend", "  if lst.length == 0 || lst.length == 1\n  \
    \  return nil\n  end\n  lst.sort!\n  i = 0\n  while i < lst.length - 1\n    if\
    \ lst[i] == lst[i + 1]\n      i += 1\n    else\n      return lst[i + 1]\n    end\n\
    \  end\n  return nil\nend", "  lst.sort!\n  if lst.length == 0\n    return nil\n\
    \  end\n  if lst.length < 2\n    return nil\n  end\n  if lst[0] == lst[1]\n  \
    \  return nil\n  end\n  return lst[1]\nend", "  return nil if lst.empty?\n  return\
    \ nil if lst.length == 1\n  lst.uniq.sort[1]\nend", "    # Sort the list to find\
    \ the smallest element\n    sorted_lst = lst.sort\n    # Return the next smallest\
    \ element\n    return sorted_lst[1]\nend", "  lst.count == 0 ? nil : lst.min(2).max\n\
    end", "  lst.delete(lst.min)\n  lst.min\nend", "  new_lst = lst.uniq.sort\n  new_lst[1]\n\
    end", "  sorted = lst.sort\n  min = sorted[0]\n  count = 0\n  i = 0\n  while i\
    \ < sorted.length\n    if sorted[i] == min\n      count += 1\n    end\n    i +=\
    \ 1\n  end\n  if count == 1\n    return sorted[1]\n  else\n    return nil\n  end\n\
    end", "  return nil if lst.size < 2\n  min = min2 = nil\n  lst.each do |i|\n \
    \   if min.nil?\n      min = i\n    elsif min > i\n      min2 = min\n      min\
    \ = i\n    elsif min2.nil?\n      min2 = i\n    elsif min2 > i\n      min2 = i\n\
    \    end\n  end\n  min2\nend", "  sorted = lst.sort\n  hash = Hash.new\n  for\
    \ num in sorted\n    hash[num] = sorted.find_index(num) + 1\n  end\n  p hash\n\
    \  hash.each_value { |v| return v if v == 2 }\n  return nil\nend", "  return nil\
    \ if lst.empty?\n  lst.sort.uniq[1]\nend", "  lst = lst.sort\n  if lst.uniq.length\
    \ < 2\n    nil\n  else\n    lst[1]\n  end\nend", "  lst.sort[1] || nil\nend",
  "  return nil if lst.empty?\n  min = lst.first\n  second_min = nil\n  lst.each do\
    \ |el|\n    if el < min\n      second_min = min\n      min = el\n    elsif (el\
    \ < second_min) || (second_min.nil?)\n      second_min = el\n    end\n  end\n\
    \  second_min.nil? ? nil : second_min\nend", "\nend", end, '  lst.sort!', "  \
    \  return nil if lst.length < 2\n    min = lst[0]\n    second_min = nil\n    lst.each\
    \ do |elem|\n        if elem < min\n            second_min = min\n           \
    \ min = elem\n        elsif elem < second_min\n            second_min = elem\n\
    \        end\n    end\n    second_min\nend", "  lst.length > 1 ? lst.sort.uniq[1]\
    \ : nil\nend", "\nend", end, "  smallest = lst.min\n  second_smallest = nil\n\
    \  lst.each do |num|\n    if num < smallest && num > second_smallest\n      second_smallest\
    \ = num\n    end\n  end\n  second_smallest\nend", end, "  sortlst = lst.sort\n\
    \  return nil if sortlst == [] || sortlst.length == 1\n  if sortlst[0] == sortlst[1]\n\
    \    sortlst[2]\n  else\n    sortlst[1]\n  end\nend", "  lst = lst.sort.uniq\n\
    \  lst[1]\nend", "  return nil if lst.empty?\n  distinct_list = lst.uniq\n  distinct_list.sort[1]\n\
    end", "  lst.sort[1]\nend", "  return nil if lst.empty?\n  lst = lst.uniq.sort\n\
    \  lst[1]\nend", "  lst.sort.uniq[1]\nend", "  return if lst.length < 2\n  smallest\
    \ = lst.min\n  return if lst.count(smallest) == lst.length\n  lst.select { |num|\
    \ num > smallest }.min\nend", "    if lst.empty?\n        return nil\n    end\n\
    \    if lst.length == 1\n        return nil\n    end\n    if lst.length == 2\n\
    \        if lst[0] == lst[1]\n            return nil\n        end\n    end\n \
    \   smallest = lst[0]\n    second_smallest = nil\n    lst.each do |elem|\n   \
    \     if elem < smallest\n            second_smallest = smallest\n           \
    \ smallest = elem\n        end\n    end\n    return second_smallest\nend", " \
    \ return nil if lst.empty? || lst.size < 2 || lst.uniq.size == 1\n  sorted = lst.sort\n\
    \  sorted[1]\nend", "    # Turn input into a hash\n    # Get keys of hash\n  \
    \  # Sort keys of hash\n    # Get 2nd smallest key\n    # Return value of that\
    \ key\n    lst_hash = {}\n    lst.each do |num|\n        lst_hash[num] = 0\n \
    \   end\n    sorted_keys = lst_hash.keys.sort\n    if sorted_keys.length < 2\n\
    \        return nil\n    else\n        return sorted_keys[1]\n    end\nend", " \
    \ next_smallest = lst.sort\n  if next_smallest[1] == next_smallest[0]\n    return\
    \ nil\n  else\n    return next_smallest[1]\n  end\nend", "  if lst.empty?\n  \
    \  return nil\n  elsif lst.uniq.size == 1\n    return nil\n  else\n    lst.uniq.sort[1]\n\
    \  end\nend", "  lst.uniq.sort[1] if lst.uniq.count > 1\nend", '  return nil if
    lst.empty? || lst.length == 1', "  sorted = lst.sort\n  first = sorted[0]\n  second\
    \ = sorted[1]\n  while first == second\n    sorted.shift\n    first = sorted[0]\n\
    \    second = sorted[1]\n  end\n  return nil if sorted.length == 0\n  second\n\
    end", "  lst.sort!\n  return nil if lst.size < 2\n  lst.each_with_index do |element,\
    \ index|\n    if lst[index + 1] > element\n      return lst[index + 1]\n    end\n\
    \  end\n  nil\nend", "\nend", "  lst.length > 1 ? lst.sort.uniq[1] : nil\nend",
  "  return nil if lst.length < 2\n  lst = lst.sort()\n  i = 0\n  second_smallest\
    \ = nil\n  smallest = lst[0]\n  until i == lst.length\n    if lst[i] != smallest\n\
    \      second_smallest = lst[i]\n      break\n    end\n    i += 1\n  end\n  second_smallest\n\
    end", "  return nil if lst.length < 2\n  first = nil\n  second = nil\n  lst.each\
    \ do |e|\n    if !first || e < first\n      second = first\n      first = e\n\
    \    elsif !second || e < second\n      second = e\n    end\n  end\n  second\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
