name: HumanEval_87_get_row
language: rb
prompt: "# You are given a 2 dimensional data, as a nested lists,\n# which is similar\
  \ to matrix, however, unlike matrices,\n# each row may contain a different number\
  \ of columns.\n# Given lst, and integer x, find integers x in the list,\n# and return\
  \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n# each tuple is a coordinate\
  \ - (row, columns), starting with 0.\n# Sort coordinates initially by rows in ascending\
  \ order.\n# Also, sort coordinates of the row by columns in descending order.\n\
  # Examples:\n# get_row([\n# [1,2,3,4,5,6],\n# [1,2,3,4,1,6],\n# [1,2,3,4,5,1]\n\
  # ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n# get_row([], 1) == []\n# get_row([[],\
  \ [1], [1, 2, 3]], 3) == [(2, 2)]\ndef get_row(lst, x)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_row\n\
  \    candidate = method(:get_row)\n    assert_equal([[0, 0], [1, 4], [1, 0], [2,\
  \ 5], [2, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
  \ 4, 5, 1]], 1))\n    assert_equal([[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5,\
  \ 1]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6],\
  \ [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6]], 2))\n    assert_equal([[0,\
  \ 0], [1, 0], [2, 1], [2, 0], [3, 2], [3, 0], [4, 3], [4, 0], [5, 4], [5, 0], [6,\
  \ 5], [6, 0]], candidate.call([[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6], [1, 1, 3,\
  \ 4, 5, 6], [1, 2, 1, 4, 5, 6], [1, 2, 3, 1, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3,\
  \ 4, 5, 1]], 1))\n    assert_equal([], candidate.call([], 1))\n    assert_equal([],\
  \ candidate.call([[1]], 2))\n    assert_equal([[2, 2]], candidate.call([[], [1],\
  \ [1, 2, 3]], 3))\n  end\nend\n"
completions: ["  result = []\n  count = 0\n  lst.each do |sub_arr|\n    sub_arr.each_with_index\
    \ do |num, index|\n      if num == x\n        result << [count, index]\n     \
    \ end\n    end\n    count += 1\n  end\n  result.sort_by { |sub_arr| [sub_arr[0],\
    \ -sub_arr[1]] }\nend", "  indices = []\n  lst.each_with_index do |row, row_index|\n\
    \    col_index = row.index(x)\n    if col_index\n      indices << [row_index,\
    \ col_index]\n    end\n  end\n  indices.sort_by { |sub_lst| [sub_lst[0], -sub_lst[1]]\
    \ }\nend", "  result = []\n  for i in 0...lst.length\n    for j in 0...lst[i].length\n\
    \      if lst[i][j] == x\n        result << [i, j]\n      end\n    end\n  end\n\
    \  result.sort_by!{|x| [x[0], -x[1]]}\nend", "  res = []\n  lst.each_with_index\
    \ do |rows, i|\n    rows.each_with_index do |el, j|\n      res << [i, j] if el\
    \ == x\n    end\n  end\n  res.sort_by { |x, y| [x, -y] }\nend", "  return [] if\
    \ lst.empty?\n  idx = 0\n  res = []\n  while idx < lst.size\n    count = 0\n \
    \   while count < lst[idx].size\n      res << [idx, count] if lst[idx][count]\
    \ == x\n      count += 1\n    end\n    idx += 1\n  end\n  res.sort.reverse\nend",
  "  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |elem,\
    \ j|\n      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by {\
    \ |tuple| tuple[0] }.sort_by { |tuple| tuple[1] }.reverse\nend", "  result = []\n\
    \  lst.each_with_index do |row, i|\n    row.each_with_index do |item, j|\n   \
    \   result << [i, j] if item == x\n    end\n  end\n  result.sort_by { |a, b| [a,\
    \ -b] }\nend", "  result = []\n  lst.each_with_index do |e, i|\n    e.each_with_index\
    \ do |e1, i1|\n      result << [i, i1] if e1 == x\n    end\n  end\n  result.sort\
    \ { |x, y| [x[0], -x[1]] <=> [y[0], -y[1]] }\nend", "  result = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      result << [i, j] if\
    \ col == x\n    end\n  end\n  result.sort_by { |row, col| [row, -col] }\nend",
  "  lst.map.with_index do |row, i|\n    row.map.with_index.select { |el, _| el ==\
    \ x }.map { |_, j| [i, j] }\n  end.flatten(1).sort_by { |_, j| [j, -i] }\nend",
  "  list_of_tuples = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |n, j|\n      list_of_tuples << [i, j] if n == x\n    end\n  end\n  list_of_tuples.sort_by\
    \ { |i, j| [i, -j] }\nend", "    # your code here\n    coordinates = []\n    lst.each_with_index\
    \ do |row, row_index|\n        row.each_with_index do |num, column_index|\n  \
    \          if num == x\n                coordinates << [row_index, column_index]\n\
    \            end\n        end\n    end\n    return coordinates.sort_by { |(row,\
    \ column)| [row, -column] }\nend", "  result = []\n  i = 0\n  lst.each do |sublist|\n\
    \    sublist.each_with_index do |num, j|\n      result << [i, j] if num == x\n\
    \    end\n    i += 1\n  end\n  result.sort_by { |sublist| sublist[0] }.map { |sublist|\
    \ [sublist[0], -sublist[1]] }\nend\np get_row([\n[1,2,3,4,5,6],\n[1,2,3,4,1,6],\n\
    [1,2,3,4,5,1]\n], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]", "  lst.each_with_index.with_object([])\
    \ do |(row, row_index), coordinates|\n    row.each_with_index { |column, column_index|\
    \ coordinates << [row_index, column_index] if column == x }\n  end.sort_by { |row_index,\
    \ column_index| [row_index, -column_index] }\nend", "  # your code here\nend",
  "  lst.each_with_index.map { |row, i|\n    row.each_with_index.map { |el, j| [i,\
    \ j] if el == x }\n  }.flatten(1).compact.sort_by { |el| [-el[1], el[0]] }\nend",
  "  lst.each_with_index.flat_map do |row, i|\n    row.each_with_index.map do |el,\
    \ j|\n      el == x ? [i, j] : nil\n    end.compact\n  end.sort_by { |x, y| [x,\
    \ -y] }\nend", "  arr = []\n  lst.each_with_index do |n, i|\n    n.each_with_index\
    \ do |m, j|\n      arr << [i, j] if m == x\n    end\n  end\n  arr.sort_by{|k|\
    \ [k[0], -k[1]]}\nend", "    result = []\n    lst.each_with_index { |row, i|\n\
    \        row.each_with_index { |num, j|\n            result << [i, j] if num ==\
    \ x\n        }\n    }\n    result.sort_by { |pair| [pair[0], -pair[1]] }\nend",
  "  result = []\n  for i in 0...lst.length\n    for j in 0...lst[i].length\n    \
    \  if lst[i][j] == x\n        result << [i, j]\n      end\n    end\n  end\n  result.sort\n\
    end", "  res = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      res << [i, j] if col == x\n    end\n  end\n  res.sort_by\
    \ { |x| [x[0], -x[1]] }\nend", "  res = []\n  lst.each_with_index do |line, y|\n\
    \    line.each_with_index do |cell, x|\n      res << [y, x] if cell == x\n   \
    \ end\n  end\n  res.sort_by { |i| [i[0], -i[1]] }\nend", "  lst.each_with_index.flat_map\
    \ { |row, row_index|\n    row.each_with_index.map { |val, col_index|\n      val\
    \ == x ? [row_index, col_index] : nil\n    }.compact\n  }.sort { |c1, c2|\n  \
    \  c1[0] == c2[0] ? -(c1[1] <=> c2[1]) : c1[0] <=> c2[0]\n  }\nend", "  rows =\
    \ []\n  lst.each_with_index do |item, row|\n    item.each_with_index do |item,\
    \ column|\n      rows << [row, column] if item == x\n    end\n  end\n  rows.sort_by\
    \ { |item| [item[0], -item[1]] }\nend", "  arr = []\n  lst.each_with_index { |e,\
    \ i| e.each_with_index { |f, j| arr << [i, j] if f == x } }\n  arr.sort_by { |a,\
    \ b| [a, -b] }\nend", "  # your code here\nend", "  lst.each_with_index.inject([])\
    \ do |result, (row, index)|\n    row.reverse.each_with_index.inject(result) do\
    \ |arr, (item, inner_index)|\n      arr << [index, row.size - inner_index - 1]\
    \ if item == x\n      arr\n    end\n  end\nend", "  res = []\n  lst.each_with_index\
    \ do |row, index|\n    row.each_with_index do |el, el_index|\n      res << [index,\
    \ el_index] if el == x\n    end\n  end\n  res.sort_by { |(row, col)| [row, -col]\
    \ }\nend", "  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |num, j|\n      result << [i, j] if num == x\n    end\n  end\n  result.sort_by\
    \ { |row, col| [row, -col] }\nend", "  # result = []\n  # lst.each_with_index\
    \ do |lst_el, row_index|\n  #   lst_el.each_with_index do |el, col_index|\n  #\
    \     result << [row_index, col_index] if el == x\n  #   end\n  # end\n  # result.sort\n\
    \  # result.sort_by { |row, col| [row, -col] }\n  # result.sort_by(&:reverse)\n\
    \  # lst.map.with_index { |el, row| el.map.with_index { |el, col| [row, col] if\
    \ el == x } }.flatten(1).compact.sort\n  # lst.map.with_index { |el, row| el.map.with_index\
    \ { |el, col| [row, col] if el == x } }.flatten(1).compact.sort_by(&:reverse)\n\
    \  lst.map.with_index { |el, row| el.map.with_index { |el, col| [row, col] if\
    \ el == x } }.flatten(1).compact.sort_by { |row, col| [row, -col] }\nend", " \
    \ # Find row and column for all x\n  row = []\n  lst.each_with_index do |e, r|\n\
    \    e.each_with_index do |a, c|\n      row << [r, c] if a == x\n    end\n  end\n\
    \  # Sort by row, and then by column\n  sorted = row.sort_by do |a|\n    [a[0],\
    \ -a[1]]\n  end\n  sorted\nend", "  lst.each_with_index.reduce([]) do |result,\
    \ (row, i)|\n    row.each_with_index do |_, j|\n      result << [i, j] if row[j]\
    \ == x\n    end\n    result\n  end.sort_by { |l| [l[0], -l[1]] }\nend", "  #your\
    \ code here\nend", "  result = []\n  lst.each_with_index do |row, i|\n    result\
    \ << row.map { |e| [i, row.size - row.index(e) - 1] if e == x }\n  end\n  result.flatten(1).compact.sort_by\
    \ { |a| [a[0], a[1]] }\nend", "  lst.map.with_index do |row, i|\n    row.map.with_index\
    \ do |cell, j|\n      [i, j] if cell == x\n    end\n  end.flatten(1).compact.sort\
    \ do |a, b|\n    if a[0] == b[0]\n      -1 * (a[1] <=> b[1])\n    else\n     \
    \ a[0] <=> b[0]\n    end\n  end\nend", "  result = []\n  lst.each_with_index do\
    \ |sub, i|\n    result += sub.map.with_index { |v, j| [i, j] if v == x }.compact\n\
    \  end\n  result.sort.sort_by { |x, y| y }.reverse\nend", "  lst.map.with_index\
    \ do |r,i|\n    r.map.with_index do |c,j|\n      [i,j] if c == x\n    end\n  end.flatten(1).compact.sort_by\
    \ { |a,b| [a, -b] }\nend", "  result = []\n  lst.each_with_index do |row, i|\n\
    \    row.each_with_index do |element, j|\n      result << [i, j] if element ==\
    \ x\n    end\n  end\n  result.sort_by { |element| [element[0], -element[1]] }\n\
    end", "  # res = []\n  # lst.each_with_index do |arr, i|\n  #   l = arr.size\n\
    \  #   arr.each_with_index do |x, j|\n  #     res << [i, l - j - 1] if x == 1\n\
    \  #   end\n  # end\n  # res.sort_by { |i, j| [i, -j] }\n  lst.each_with_index.flat_map\
    \ do |arr, i|\n    arr.each_with_index.select { |x, _| x == 1 }.map { |_, j| [i,\
    \ arr.size - j - 1] }\n  end.sort_by { |i, j| [i, -j] }\nend", "  positions =\
    \ []\n  lst.each_with_index do |list, y|\n    list.each_with_index do |num, x|\n\
    \      positions << [y, x] if num == x\n    end\n  end\n  positions.sort_by do\
    \ |y, x|\n    [-x, y]\n  end\nend", "  lst.each_with_index.flat_map { |x,i|\n\
    \    x.map.with_index { |y,j|\n      [i,j] if y == x\n    }\n  }.compact.sort_by\
    \ { |x, y|\n    [x, -y]\n  }\nend", "  coordinates = []\n  lst.each_with_index\
    \ do | row, i |\n    row.each_with_index do | el, j |\n      coordinates << [i,\
    \ j] if el == x\n    end\n  end\n  coordinates.sort_by { | arr | arr[0] }.map\
    \ do | coord |\n    [coord[0], -coord[1]]\n  end\nend", "  c = []\n  lst.each_with_index\
    \ do |line, i|\n    line.each_with_index do |num, j|\n      c << [i, j] if num\
    \ == x\n    end\n  end\n  c.sort_by { |a,b| [a, -b] }\nend", "  result = []\n\
    \  i = 0\n  lst.each do |row|\n    j = 0\n    row.each do |elem|\n      result\
    \ << [i, j] if elem == x\n      j += 1\n    end\n    i += 1\n  end\n  result.sort_by\
    \ { |elem| [elem[0], -elem[1]] }\nend", "  tuples = []\n  lst.each_with_index\
    \ do |row, r|\n    row.each_with_index do |val, c|\n      tuples << [r, c] if\
    \ val == x\n    end\n  end\n  tuples.sort_by{|t| [t[0], -t[1]]}\nend", "  result\
    \ = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index do\
    \ |column, column_index|\n      result << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  result.sort.reverse\nend", "\t# your code here\nend",
  "  # get index of subarrays which contain x\n  # get indexes of x in those subarrays\n\
    \  # return the coordinates of x inside those subarrays\n  # one coordinate pair\
    \ is like this: [subarray_index, x_index]\n  # ==> [[x, y], [x, y]]\n  result\
    \ = []\n  lst.each_with_index do |subarray, subarray_index|\n    subarray.each_with_index\
    \ do |element, element_index|\n      if element == x\n        result << [subarray_index,\
    \ element_index]\n      end\n    end\n  end\n  # sort subarrays by the first element\
    \ in ascending order\n  result.sort! do |subarray1, subarray2|\n    subarray1[0]\
    \ <=> subarray2[0]\n  end\n  # from each subarray, only keep the second element\
    \ (the x index)\n  result.map! do |subarray|\n    subarray[1]\n  end\n  # for\
    \ each element in result, make a pair with its index,\n  # so that each element\
    \ becomes a coordinate [x, y]\n  result.map!.with_index do |y, x|\n    [x, y]\n\
    \  end\n  # for each subarray in result, reverse the two elements in it,\n  #\
    \ so that each element becomes a coordinate [y, x]\n  result.map! do |subarray|\n\
    \    subarray.reverse\n  end\n  # sort each subarray in result by descending order\n\
    \  result.map! do |subarray|\n    subarray.sort { |y1, y2| y2 <=> y1 }\n  end\n\
    \  result\nend", "  lst.map.with_index { |row, i| row.each_with_index.select {\
    \ |e, j| e == x }.map { |a, b| [i, b] } }.flatten(1).sort { |a, b| a[0] == b[0]\
    \ ? b[1] <=> a[1] : a[0] <=> b[0] }\nend", "  lst.map.with_index { |r, i| r.map.with_index\
    \ { |c, j| [i, j] if c == x } }.flatten(1).compact.sort_by { |x| [x[0], -x[1]]\
    \ }\nend", "  lst.each_with_index.with_object([]) do |(e, i), memo|\n    e.each_with_index\
    \ do |el, j|\n      memo << [i, j] if el == x\n    end\n  end.sort { |x, y| x[0]\
    \ <=> y[0] }.each_with_object([]) do |e, memo|\n    memo << e if memo.empty? ||\
    \ memo.last[0] != e[0]\n    memo.unshift(e) if memo.last[0] == e[0]\n  end\nend",
  "  ans = []\n  lst.each_with_index do |r,i|\n    r.each_with_index do |e,j|\n  \
    \    ans << [i,j] if e == x\n    end\n  end\n  ans.sort_by{|k| k[0]}.sort_by{|k|\
    \ -k[1]}\nend", "\tx_indices = Hash.new { |hash, key| hash[key] = [] }\n\tlst.each_with_index\
    \ do |x, i|\n\t\tx.each_with_index do |y, j|\n\t\t\tx_indices[x] << i if x ==\
    \ y\n\t\tend\n\tend\n\tsorted_indices = []\n\tx_indices[x].each do |i|\n\t\tsorted_indices\
    \ << lst[i].each_with_index.select { |y, j| y == x }.to_a.sort { |(a, b), (c,\
    \ d)| d <=> b }\n\tend\n\tsorted_indices.flatten(1).sort { |(a, b), (c, d)| a\
    \ <=> c }\nend", "  lst.each_with_index.flat_map do |l, i|\n    l.each_with_index.select\
    \ { |_x, _| _x == x }.map { |_, j| [i, j] }\n  end.sort_by { |i, j| [i, -j] }\n\
    end", "  # change me!\n  row = lst.map.with_index { |r, i|\n    lst[i].map.with_index\
    \ { |e, j|\n      [i, j] if e == x\n    }.compact\n  }.flatten(1).sort_by { |r,\
    \ e| [r, -e] }\nend", "  lst.each_with_index.map { |i, index| i.each_with_index.map\
    \ { |j, index2| [index, index2] if j == x } }.flatten(1).compact.sort_by { |i|\
    \ [i[0], -i[1]] }\nend", "  lst.map.with_index { |row, i| row.map.with_index {\
    \ |n, j| [i, j] if n == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\n\
    end", "  res = []\n  lst.each_with_index do |el, i|\n    el.each_with_index do\
    \ |e, j|\n      res << [i, j] if e == x\n    end\n  end\n  res.sort_by { |a, b|\
    \ [a, -b] }\nend", "  lst.each_with_index.map do |row, i|\n    row.each_with_index.select\
    \ do |elem, j|\n      elem == x\n    end.map do |elem, j|\n      [i, j]\n    end\n\
    \  end.flatten(1).sort do |x, y|\n    x[0] == y[0] ? y[1] <=> x[1] : x[0] <=>\
    \ y[0]\n  end\nend", "\tlst.map.with_index do |row, y|\n\t\trow.map.with_index\
    \ { |e, xi| [y, xi] if e == x }\n\tend.flatten(1).reject { |y, x| y.nil? }.sort_by\
    \ { |y, x| [y, -x] }\nend", "\tresult = []\n\tlst.each_with_index do |row, y|\n\
    \t\trow.each_with_index do |col, z|\n\t\t\tresult << [y, z] if col == x\n\t\t\
    end\n\tend\n\tresult.sort_by { |e| [e[0], -e[1]] }\nend", "\tlst.map.with_index\
    \ { |v, i| v.map.with_index { |e, j| [i, j] if e == x } }.\n\t  flatten(1).compact.sort_by\
    \ { |e| [e[0], -e[1]] }\nend", "    b = []\n    lst.each_with_index { |v, idx|\n\
    \        v.each_with_index { |v2, idx2|\n            if v2 == x\n            \
    \    b << [idx, idx2]\n            end\n        }\n    }\n    #puts b.to_s\n \
    \   #puts b.sort_by { |x, y| [x, -y] }.to_s\n    b.sort_by { |x, y| [x, -y] }\n\
    end", "  lst.each_with_index.inject([]) do |res, (row, y)|\n    row.each_with_index\
    \ do |el, x|\n      if el == x\n        res << [y, x]\n      end\n    end\n  \
    \  res\n  end.sort_by do |e|\n    e[0]\n  end.sort_by do |e|\n    -e[1]\n  end\n\
    end", "  lst.each_with_index.map { |e, i| e.each_with_index.map { |e, j| [i, j]\
    \ if e == x } }.flatten(1).compact.sort_by { |x, y| [x, -y] }\nend", "  result\
    \ = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |elem, j|\n\
    \      result << [i, j] if elem == x\n    end\n  end\n  result.sort_by { |elem|\
    \ elem[0] }.reverse.sort_by { |elem| elem[1] }\nend", "  ret = []\n  lst.each_with_index\
    \ { |row, i|\n    row.each_with_index { |v, j|\n      ret << [i, j] if v == x\n\
    \    }\n  }\n  ret.sort! do |a, b|\n    a[0] <=> b[0]\n  end\n  ret.sort! do |a,\
    \ b|\n    if a[0] == b[0]\n      b[1] <=> a[1]\n    else\n      0\n    end\n \
    \ end\n  ret\nend", "  lst.each_with_index.with_object([]) do |(row, i), result|\n\
    \    row.each_with_index do |col, j|\n      result << [i, j] if col == x\n   \
    \ end\n  end.sort_by { |i, j| [i, -j] }\nend", "  array = []\n  lst.each_with_index\
    \ { |e, i| array += e.map.with_index { |e, j| [i, j] if e == x }.compact }\n \
    \ array.sort { |x, y| y[1] <=> x[1] }.sort\nend", "  result = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |num, j|\n      result << [i, j] if\
    \ num == x\n    end\n  end\n  result.sort_by { |i, j| [i, -j] }\nend", "  if lst.flatten.index(x)\
    \ == nil\n    return []\n  else\n    result = []\n    lst.each_with_index do |sub_lst,\
    \ sub_lst_index|\n      sub_lst.each_with_index do |elem, elem_index|\n      \
    \  if elem == x\n          result << [sub_lst_index, elem_index]\n        end\n\
    \      end\n    end\n    result.sort_by { |sub_arr| sub_arr[0] }.reverse\n  end\n\
    end", "  # your code here\nend", "  arr = []\n  lst.each_with_index do |v, k|\n\
    \    v.each_with_index do |v1, k1|\n      arr << [k, k1] if v1 == x\n    end\n\
    \  end\n  arr.sort_by { |x| [x[0], -x[1]] }\nend\np get_row([[1, 2, 3, 4, 5, 6],\
    \ [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]], 1)\np get_row([], 1)\np get_row([[],\
    \ [1], [1, 2, 3]], 3)", "  lst.each_with_index.map { |v, i| v.each_with_index.map\
    \ { |w, j| (i, j) if w == x } }.flatten(1).compact.sort_by { |(i, j)| [i, -j]\
    \ }\nend", "  result = []\n  (0...lst.size).each do |i|\n    (0...lst[i].size).each\
    \ do |j|\n      result << [i, j] if lst[i][j] == x\n    end\n  end\n  return result.sort_by{|i|\
    \ i[0]}.sort_by{|i| i[1]}.reverse\nend", "  xy = []\n  lst.each_with_index do\
    \ |sub_lst, i|\n    sub_lst.each_with_index do |sub_sub_lst, j|\n      xy << [i,\
    \ j] if sub_sub_lst == x\n    end\n  end\n  xy.sort_by{|sub_arr| sub_arr[0]}.reverse\n\
    end", "  res = []\n  lst.each_with_index do |item, index|\n    item.each_with_index\
    \ do |i, ind|\n      res << [index, ind] if i == x\n    end\n  end\n  res.sort_by\
    \ { |i| i[0] }.sort_by { |i| -i[1] }\nend", "  answer = []\n  lst.each_with_index\
    \ do |sub_arr, outer_index|\n    sub_arr.each_with_index do |value, inner_index|\n\
    \      answer << [outer_index, inner_index] if value == x\n    end\n  end\n  answer.sort_by\
    \ { |val| [val[0], -val[1]] }\nend", "  mapper = []\n  lst.each_with_index do\
    \ |row, ridx|\n    row.each_with_index do |el, cidx|\n      mapper << [ridx, cidx]\
    \ if el == x\n    end\n  end\n  mapper.sort_by { |item| [item[0], -item[1]] }\n\
    end", "  lst.map.with_index { |y, i| [y.grep(x).length, i] }.select { |y| y[0]\
    \ > 0 }.sort.reverse.map { |y| [y[1], y[0]] }.map { |y| [y[0], y[1] - 1] }\nend",
  "  res = []\n  lst.each_with_index do |e, row|\n    if e.include?(x)\n      e.each_with_index\
    \ do |e, col|\n        res << [row, col] if e == x\n      end\n    end\n  end\n\
    \  res.sort.reverse\nend", "  def search(lst, x, idx, result=[])\n    lst.each_with_index\
    \ do |row, i|\n      row.each_with_index do |col, j|\n        result << [i, j]\
    \ if col == x\n      end\n    end\n    result.sort_by { |arr| [arr[0], -arr[1]]\
    \ }\n  end\n  search(lst, x, [])\nend", "  lst.map.with_index{|sub,i| sub.map.with_index{|v,j|\
    \ [i,j] if v == x}}.flatten(1).compact.sort_by{|i, j| [i, -j]}\nend", "  result\
    \ = []\n  lst.each_with_index do |row, index|\n    row.each_with_index do |item,\
    \ i|\n      result << [index, i] if item == x\n    end\n  end\n  result.sort_by\
    \ { |i| [i[0], -i[1]] }\nend", "  # get the index of x\n  coord = []\n  lst.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      if col == x\n      \
    \  coord << [i, j]\n      end\n    end\n  end\n  # sort the array\n  coord.sort_by!\
    \ { |el| el[0] }\n  coord.map! do |el|\n    el.reverse\n  end\n  coord.each do\
    \ |el|\n    el.reverse!\n  end\n  coord\nend", "  arr_coordinates = []\n  lst.each_with_index\
    \ do |el, i|\n    arr_coordinates << el.each_index.select { |j| el[j] == x }.map\
    \ { |j| [i, j] }\n  end\n  arr_coordinates.flatten(1).sort_by { |i, j| [i, -j]\
    \ }\nend", "  coord = lst.map.with_index { |e, i| e.map.with_index { |e, j| [i,\
    \ j] if e == x } }.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\nend", " \
    \ lst.map.with_index do |row, y|\n    row.map.with_index { |e, x2| [y, x2] if\
    \ e == x }\n  end.flatten(1).compact.sort_by do |(y, x2)|\n    [y, -x2]\n  end\n\
    end", "  tuples = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |el, j|\n      tuples << [i, j] if el == x\n    end\n  end\n  tuples.sort\
    \ { |x, y| x[0] == y[0] ? y[1] <=> x[1] : x[0] <=> y[0] }\nend", "  res = []\n\
    \  lst.each_with_index do |row, i|\n    row.each_with_index do |elem, j|\n   \
    \   res << [i, j] if elem == x\n    end\n  end\n  res.sort.reverse\nend", "  result\
    \ = []\n  lst.each_with_index do |val, i|\n    val.each_with_index do |value,\
    \ j|\n      result << [i, j] if value == x\n    end\n  end\n  result.sort\nend",
  "  lst.map.with_index { |r, i| r.map.with_index { |c, j| [i, j] if c == x } }.\n\
    \      flatten(1).compact.sort_by { |e| e[0] }.sort_by { |e| -e[1] }\nend", "\t\
    list = []\n\ti = 0\n\twhile i < lst.length\n\t\tz = 0\n\t\twhile z < lst[i].length\n\
    \t\t\tif lst[i][z] == x\n\t\t\t\tlist << [i, z]\n\t\t\tend\n\t\t\tz += 1\n\t\t\
    end\n\t\ti += 1\n\tend\n\tlist.sort_by { |i| [i[0], -i[1]] }\nend", "  res = []\n\
    \  return res if lst.empty?\n  lst.each_with_index do |row, i|\n    next if row.empty?\n\
    \    row.each_with_index do |column, j|\n      next if column != x\n      res\
    \ << [i, j]\n    end\n  end\n  res.sort_by { |arr| [arr[0], -arr[1]] }\nend",
  "  coords = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |val,\
    \ j|\n      coords << [i, j] if val == x\n    end\n  end\n  coords.sort_by { |c|\
    \ [c[0], -c[1]] }\nend", "    if lst.empty?\n        return []\n    end\n    result\
    \ = []\n    (0...lst.length).each do |i|\n        (0...lst[i].length).each do\
    \ |j|\n            if lst[i][j] == x\n                result << [i, j]\n     \
    \       end\n        end\n    end\n    result.sort{|x, y| x[0] <=> y[0]}.sort{|x,\
    \ y| x[1] <=> y[1]}.reverse\nend", "  arr = []\n  lst.each_with_index do |row,\
    \ row_index|\n    row.each_with_index do |item, column_index|\n      arr << [row_index,\
    \ column_index] if item == x\n    end\n  end\n  arr.sort_by do |row, column|\n\
    \    [row, -column]\n  end\nend", "\ttable = []\n\tlst.each_with_index do |item,\
    \ index|\n\t\t(0...item.length).each do |i|\n\t\t\ttable << [index, i] if item[i]\
    \ == x\n\t\tend\n\tend\n\ttable.sort_by! { |x| x[0] }\n\ttable.map! { |x| x.reverse\
    \ }\n\tindex = 0\n\twhile index < table.length\n\t\tl = table[index].length\n\t\
    \ti = 0\n\t\twhile i < l\n\t\t\ttable[index].sort! { |x, y| y <=> x }\n\t\t\t\
    i += 1\n\t\tend\n\t\tindex += 1\n\tend\n\ttable.map! { |x| x.reverse }\nend",
  "  if lst.empty?\n    return []\n  end\n  a = []\n  b = []\n  (0...lst.size).each\
    \ do |row|\n    (0...lst[row].size).each do |col|\n      if lst[row][col] == x\n\
    \        a << row\n        b << col\n      end\n    end\n  end\n  c = []\n  (0...a.size).each\
    \ do |i|\n    c << [a[i], b[i]]\n  end\n  c.sort_by { |a, b| a }.reverse.sort_by\
    \ { |a, b| b }\nend", '  len = lst.length', "  result = []\n  lst.each_with_index\
    \ do |e, i|\n    e.each_with_index do |y, j|\n      result << [i, j] if y == x\n\
    \    end\n  end\n  result.sort_by!{|x| x[0]}\n  result.sort_by!{|x| x[1]}.reverse!\n\
    \  result\nend", "    rows = []\n    lst.each_with_index { |row, index| rows <<\
    \ [index, row.rindex(x)] if row.include?(x) }\n    rows.sort_by { |row| [row[0],\
    \ -row[1]] }\nend", "  h = {}\n  lst.each_with_index do |subarr, i|\n    subarr.each_with_index\
    \ do |el, j|\n      h[el] ||= []\n      h[el] << [i, j]\n    end\n  end\n  h[x].sort_by{|subarr|\
    \ [subarr[0], -subarr[1]] }\nend", "  lst.each_with_index.with_object([]) do |(row,\
    \ row_index), output|\n    row.each_with_index do |value, col_index|\n      output\
    \ << [row_index, col_index] if value == x\n    end\n  end.sort_by { |row, col|\
    \ [row, -col] }\nend", "  row_col = []\n  return row_col if lst.empty?\n  lst.each_with_index\
    \ do |row, row_index|\n    next if row.empty?\n    row.each_with_index do |col,\
    \ col_index|\n      row_col << [row_index, col_index] if col == x\n    end\n \
    \ end\n  row_col.sort.reverse\nend", "  lst.each_with_index.flat_map do |row,\
    \ i|\n    row.each_with_index.map do |e, j|\n      [i, j] if e == x\n    end\n\
    \  end.compact.sort.reverse\nend", "  result = []\n  lst.each_with_index do |row,\
    \ row_index|\n    row.each_with_index do |elem, elem_index|\n      result << [row_index,\
    \ elem_index] if elem == x\n    end\n  end\n  result.sort { |x, y| [x[0], -x[1]]\
    \ <=> [y[0], -y[1]] }\nend", "  lst.map.with_index do |list, i|\n    list.map.with_index\
    \ { |element, j| [i, j] if element == x }\n  end.flatten(1).compact.sort_by {\
    \ |a, b| [a, -b] }\nend", "  lst.map.with_index { |row, y| [y, row.rindex(x)]\
    \ if row.include?(x) }.compact.sort.reverse\nend", end, "\nend", "  lst.each_with_index.inject([])\
    \ { |acc, (val, idx)|\n    val.each_with_index { |elem, jdx|\n      acc << [idx,\
    \ jdx] if elem == x\n    }\n    acc\n  }.sort_by { |elem| [elem[0], -elem[1]]\
    \ }\nend", "  lst.map.with_index { |inner, outer| inner.map.with_index { |num,\
    \ inner| [outer, inner] if num == x } }.flatten(1).compact.sort_by { |arr| [arr[0],\
    \ -arr[1]] }\nend", "  new_array = []\n  lst.each_with_index do |x,y|\n    x.each_with_index\
    \ do |i,z|\n      if i == 1\n        new_array << [y,z]\n      end\n    end\n\
    \  end\n  sorted_array = new_array.sort_by{|x,y|x}.reverse\n  sorted_array.each_with_index\
    \ do |x,y|\n    if y != 0\n      if sorted_array[y][0] == sorted_array[y-1][0]\n\
    \        sorted_array[y], sorted_array[y-1] = sorted_array[y-1], sorted_array[y]\n\
    \      end\n    end\n  end\n  return sorted_array\nend", "  # your code here\n\
    end", "  num = []\n  for i in 0...lst.length\n    for j in 0...lst[i].length\n\
    \      if lst[i][j] == x\n        num << [i, j]\n      end\n    end\n  end\n \
    \ num.sort!\n  num.sort_by!{|e| e[1]}.reverse!\n  num\nend", "\tresult = []\n\t\
    lst.each_with_index { |arr, i|\n\t\tarr.each_with_index { |elem, j|\n\t\t\tresult\
    \ << [i, j] if elem == x\n\t\t}\n\t}\n\tresult.sort_by { |elem| elem[0] }.sort_by\
    \ { |elem| -elem[1] }\nend", "  lst.map.with_index{|row, i| row.map.with_index{|e,\
    \ j| [i, j] if e == x}}.flatten(1).compact.sort_by{|i, j| [i, -j]}\nend", "  result\
    \ = []\n  row = 0\n  lst.each do |item|\n    column = 0\n    item.each do |i|\n\
    \      result << [row, column] if i == x\n      column += 1\n    end\n    row\
    \ += 1\n  end\n  result.sort.reverse\nend", "  result = []\n  lst.each_with_index\
    \ do |row, row_idx|\n    row.each_with_index do |col, col_idx|\n      result <<\
    \ [row_idx, col_idx] if col == x\n    end\n  end\n  result.sort_by { |x| [x[0],\
    \ -x[1]] }\nend", "  # your code here\nend", "  result = []\n  lst.each_with_index\
    \ do |value, index|\n    result += value.each_with_index.map { |v, i| [index,\
    \ i] if v == x }.compact\n  end\n  result.sort\nend", "  #0 1 2 3 4 5\n  #1 2\
    \ 3 4 1 6\n  #1 2 3 4 5 1\n  #0 1 2 3 4 5\n  #1 2 3 4 1 6\n  #1 2 3 4 5 1\n  #get\
    \ the number of columns in the matrix (number of elements in a row)\n  #find the\
    \ number of the element x in the matrix\n  #return coordinates of x (row, column)",
  "  map = []\n  lst.each_with_index do |el, i|\n    el.each_with_index do |e, j|\n\
    \      map << [i, j] if e == x\n    end\n  end\n  map.sort.reverse\nend", "  lst.map.with_index{|row,i|\
    \ row.map.with_index{|n,j| [i,j] if n == x}}.flatten(1).compact.sort_by{|coord|\
    \ [coord[0],-coord[1]]}\nend", "  result = []\n  lst.each_with_index do |row,\
    \ row_i|\n    row.each_with_index do |elem, elem_i|\n      result << [row_i, elem_i]\
    \ if elem == x\n    end\n  end\n  result.sort.sort_by { |i| -i[1] }\nend", " \
    \ res = []\n  for i in 0...lst.size do\n    for j in 0...lst[i].size do\n    \
    \  if lst[i][j] == x\n        res << [i, j]\n      end\n    end\n  end\n  return\
    \ res.sort_by { |x| x[0] }.reverse\nend", "  indexes = []\n  lst.each_with_index\
    \ do |row, index|\n    row.each_with_index do |el, index2|\n      indexes << [index,\
    \ index2] if el == x\n    end\n  end\n  indexes.sort_by! { |el| [el[0], -el[1]]\
    \ }\nend", "  # index_lst = []\n  # result = []\n  # lst.each_with_index do |x,\
    \ index|\n  #   x.each_with_index do |num, idx|\n  #     if num == x\n  #    \
    \   index_lst << [index, idx]\n  #     end\n  #   end\n  # end\n  # index_lst.sort_by!\
    \ { |sub_arr| sub_arr[0] }\n  # index_lst.each do |x|\n  #   result << x.reverse\n\
    \  # end\n  # result\n  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |num, idx|\n      result << [i, idx] if num == x\n    end\n  end\n  result.sort.reverse\n\
    end", "  result = []\n  lst.each_with_index do |row, row_num|\n    row.each_with_index\
    \ do |num, num_index|\n      result << [row_num, num_index] if num == x\n    end\n\
    \  end\n  result.sort_by{|arr| arr[0]}.sort_by{|arr| arr[1] * -1}\nend", "  coordinates\
    \ = []\n  if lst.empty?\n    coordinates\n  else\n    lst.each_with_index do |row,\
    \ row_idx|\n      row.each_with_index do |value, col_idx|\n        if value ==\
    \ x\n          coordinates << [row_idx, col_idx]\n        end\n      end\n   \
    \ end\n    coordinates.sort.reverse\n  end\nend", "\nend", "  r = []\n  lst.each_with_index\
    \ do |x_n, row|\n    x_n.each_with_index do |n, col|\n      r << [row, col] if\
    \ n == x\n    end\n  end\n  r.sort_by { |pair| [pair[0], -pair[1]] }\nend", " \
    \ count = 0\n  result = []\n  lst.each do |elem|\n    elem.each do |el|\n    \
    \  if el == x\n        result << [count, elem.index(el)]\n      end\n    end\n\
    \    count += 1\n  end\n  result.sort_by { |element| [element[0], -element[1]]\
    \ }\nend", "  return [] if lst.empty?\n  lst.map.with_index do |sublist, sublist_i|\n\
    \    sublist.map.with_index do |sublist_element, sublist_element_i|\n      [sublist_i,\
    \ sublist_element_i] if sublist_element == x\n    end\n  end.flatten(1).reject(&:nil?).sort_by\
    \ { |subarr| [subarr[0], -subarr[1]] }\nend", "  row = 0\n  if lst.size == 0\n\
    \    return []\n  end\n  lst.map do |l|\n    col = 0\n    if l.size == 0\n   \
    \   row += 1\n      next\n    end\n    l.map do |c|\n      if c == x\n       \
    \ res = [row, col]\n        col += 1\n        res\n      else\n        col +=\
    \ 1\n        next\n      end\n    end\n    row += 1\n  end.flatten(1).sort_by\
    \ { |x| [x[0], -x[1]] }\nend", "  ans = []\n  lst.each_with_index do |row, i|\n\
    \    row.each_with_index do |num, j|\n      ans << [i, j] if num == x\n    end\n\
    \  end\n  ans.sort { |a, b| a[0] == b[0] ? b[1] <=> a[1] : a[0] <=> b[0] }\nend",
  "  lst.map.with_index { |row, y|\n    row.map.with_index { |el, x| [y, x] if el\
    \ == x }\n  }.flatten(1).compact.sort_by { |y, x| [y, -x] }\nend", "  lst.map.with_index\
    \ { |y, i| y.map.with_index { |z, j| [i, j] if z == x } }.flatten(1).compact.sort_by\
    \ { |a, b| [a, -b] }\nend", "  result = []\n  return result if lst.empty?\n  lst.each_with_index\
    \ do |line, line_index|\n    line.each_with_index do |number, number_index|\n\
    \      result << [line_index, number_index] if number == x\n    end\n  end\n \
    \ result.sort!\n  result.sort_by { |line, number| line }\nend", "  coordinates\
    \ = []\n  lst.each_with_index do |row, x_index|\n    row.each_with_index do |element,\
    \ y_index|\n      coordinates << [x_index, y_index] if element == x\n    end\n\
    \  end\n  coordinates.sort_by{|el| [el[0], -el[1]]}\nend", "    lst.each_with_index.map\
    \ do |e, i|\n        e.each_with_index.map do |v, j|\n            [i, j] if v\
    \ == x\n        end\n    end.flatten(1).compact.sort_by { |e| [e[0], -e[1]] }\n\
    end", "\nend", "  x_coordinates = lst.map.with_index { |sub, i| sub.map.with_index\
    \ { |a, j| [i, j] if a == x } }.flatten(1).compact\n  x_coordinates.sort_by {\
    \ |sub| sub[0] }.map { |sub| sub.reverse }\nend", "  # your code here\nend", " \
    \ coordinates = []\n  lst.each_with_index do |row, i|\n    next if row.nil? ||\
    \ row.empty?\n    row.each_with_index do |elem, j|\n      coordinates << [i, j]\
    \ if elem == x\n    end\n  end\n  coordinates.sort_by { |row, col| [row, -col]\
    \ }\nend", "  res = []\n  lst.each_with_index do |row, row_index|\n    row.each_with_index\
    \ do |column, column_index|\n      res << [row_index, column_index] if column\
    \ == x\n    end\n  end\n  res.sort_by { |i| [i[0], -i[1]] }\nend", "  # your code\
    \ here\nend", "  res = []\n  lst.each_with_index do |row, row_idx|\n    col_idx\
    \ = row.find_index(x)\n    while col_idx != nil\n      res << [row_idx, col_idx]\n\
    \      col_idx = row.find_index(x, col_idx + 1)\n    end\n  end\n  res.sort_by\
    \ { |coord| coord[0] }.map { |coord| [coord[0], -coord[1]] }\nend", "  lst.map.with_index\
    \ do |item, index|\n    item.map.with_index { |item2, index2| [index, index2]\
    \ if item2 == x }\n  end.flatten(1).compact.sort_by { |item| [item[0], -item[1]]\
    \ }\nend", "  lst.flatten.map.with_index { |e, i| e == x ? i : nil }.compact.map\
    \ do |i|\n    [(i/lst[0].size), (i%lst[0].size)]\n  end.sort_by { |i| [i[0], -i[1]]\
    \ }\nend", "  indices = []\n  lst.each_with_index do |sub_lst, i|\n    sub_lst.each_with_index\
    \ do |num, j|\n      indices << [i, j] if num == x\n    end\n  end\n  indices.sort_by\
    \ { |coord| [coord[0], -coord[1]] }\nend", "  # your code here\nend", "  x_indices\
    \ = []\n  lst.each_with_index do |row, index|\n    row.each_with_index do |number,\
    \ column|\n      x_indices << [index, column] if number == x\n    end\n  end\n\
    \  x_indices.sort_by { |a, b| [a, -b] }\nend", "\nend", "  if lst.empty?\n   \
    \ []\n  else\n    coordinates = []\n    lst.each_with_index do |row, row_index|\n\
    \      row.each_with_index do |item, col_index|\n        if item == x\n      \
    \    coordinates << [row_index, col_index]\n        end\n      end\n    end\n\
    \    coordinates.sort.reverse\n  end\nend", "  lst.each_with_index.map { |e, i|\
    \ [i, e.index(x)] }.select { |e| e[1] != nil }.sort_by { |e| [e[0], -e[1]] }\n\
    end", "  y = 0\n  res = []\n  while y < lst.size\n    x1 = 0\n    while x1 < lst[y].size\n\
    \      if lst[y][x1] == x\n        res << [y, x1]\n      end\n      x1 += 1\n\
    \    end\n    y += 1\n  end\n  res.sort.sort_by { |y, x| -x }\nend", "  row_col_hash\
    \ = Hash.new { |h, k| h[k] = [] }\n  lst.each_with_index do |sub_lst, row|\n \
    \   sub_lst.each_with_index do |value, col|\n      row_col_hash[row] << col if\
    \ value == x\n    end\n  end\n  row_col_hash.keys.sort.map { |k| row_col_hash[k].sort.reverse.map\
    \ { |v| [k, v] } }.flatten(1)\nend", "  lst.each_with_index.inject([]) { |acc,\
    \ (arr, idx)| acc += arr.each_with_index.select { |e, i| e == x }.map { |_, i|\
    \ [idx, i] } }.sort_by { |(r, c)| [r, -c] }\nend", "  row = 0\n  lst.each_with_object([])\
    \ do |i, a|\n    if i.include?(x)\n      i.each_with_index do |j, col|\n     \
    \   a << [row, col] if j == x\n      end\n    end\n    row += 1\n  end.sort_by\
    \ { |i| i[0] }.reverse\nend", "  lst.each_with_index.map do |sub_lst, row|\n \
    \   sub_lst.each_with_index.select do |element, col|\n      element == x\n   \
    \ end.map do |element, col|\n      [row, col]\n    end\n  end.flatten(1).sort_by\
    \ { |row, col| [row, -col] }\nend", "  matches = []\n  lst.each_with_index do\
    \ |row, row_index|\n    row.each_with_index do |el, column_index|\n      matches\
    \ << [row_index, column_index] if el == x\n    end\n  end\n  matches.sort_by {\
    \ |_row, column| [column, -_row] }\nend", "  res = []\n  lst.each_with_index do\
    \ |row, i|\n    if (row.include?(x))\n      row.each_with_index do |col, j|\n\
    \        if (col == x)\n          res << [i, j]\n        end\n      end\n    end\n\
    \  end\n  res.sort_by { |a, b| [a, -b] }\nend", "\nend", "  lst.map { |l| l.each_with_index.select\
    \ { |e, i| e == x }.map { |e, i| [l.index(l), i] } }.flatten(1).sort_by { |l|\
    \ [l[0], -l[1]] }\nend", "  result = []\n  lst.each_with_index do |row, r_idx|\n\
    \    row.each_with_index do |elem, c_idx|\n      result << [r_idx, c_idx] if elem\
    \ == x\n    end\n  end\n  result.sort_by { |r, c| [r, -c] }\nend", "  if lst.empty?\n\
    \    return []\n  end\n  result = []\n  lst.each_with_index do |row, index|\n\
    \    row.each_with_index do |number, index_number|\n      if number == x\n   \
    \     result << [index, index_number]\n      end\n    end\n  end\n  result.sort_by\
    \ { |coordinate| [coordinate[0], -coordinate[1]] }\nend", "  result = []\n  lst.each_with_index\
    \ do |item, index|\n    item.each_with_index do |num, index_j|\n      result <<\
    \ [index, index_j] if num == x\n    end\n  end\n  result.sort_by { |x| [x[0],\
    \ -x[1]] }\nend", "\tlst.each_with_index.reduce([]) do |acc, (row, i)|\n\t\trow.each_with_index.select\
    \ { |n, j| n == x }.reduce(acc) do |acc, (n, j)|\n\t\t\tacc << [i, j]\n\t\tend\n\
    \tend.sort { |a, b| a.first <=> b.first }.map { |row, col| [row, -col] }.sort\
    \ { |a, b| a.last <=> b.last }.map { |row, col| [row, -col] }\nend", "  y = []\n\
    \  x += 1\n  lst.each_with_index do |item, index|\n    item.each_with_index do\
    \ |n, i|\n      if n == x\n        y << [index, i]\n      end\n    end\n  end\n\
    \  y.sort_by { |a, b| [a, -b] }\nend\np get_row([\n[1,2,3,4,5,6],\n[1,2,3,4,1,6],\n\
    [1,2,3,4,5,1]\n], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\np get_row([],\
    \ 1) == []\np get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]", "  result = []\n\
    \  lst.each_with_index do |row, i|\n    row.each_with_index do |col, j|\n    \
    \  result << [i, j] if col == x\n    end\n  end\n  result.sort.reverse\nend",
  "  row_col_list = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |val, j|\n      row_col_list << [i, j] if val == x\n    end\n  end\n  row_col_list.sort_by!\
    \ { |arr| arr[0] }\n  last_index = row_col_list.map { |arr| arr[0] }.uniq.last\n\
    \  (0..last_index).each do |i|\n    row_col_list.select! { |arr| arr[0] == i }\n\
    \    row_col_list.sort_by! { |arr| arr[1] }.reverse!\n  end\n  row_col_list\n\
    end", "  result = []\n  lst.each_with_index do |row, row_index|\n    if row.count(x)\
    \ > 0\n      row.each_with_index do |item, item_index|\n        result << [row_index,\
    \ item_index] if item == x\n      end\n    end\n  end\n  result.sort_by { |x|\
    \ [x[0], -x[1]] }\nend", "  lst.each_with_index.map do |e, i|\n    e.map.with_index\
    \ { |_, j| [i, j] if x == lst[i][j] }\n  end.flatten(1).compact.sort_by do |x|\n\
    \    [x[0], -x[1]]\n  end\nend", "  lst.each_with_index.map do |row, r|\n    row.each_with_index.map\
    \ do |e, c|\n      e == x ? [r, c] : nil\n    end\n  end.flatten(1).compact.sort_by\
    \ { |e| [e[0], -e[1]] }\nend", "  lst.map.with_index { |row, i| row.map.with_index\
    \ { |el, j| [i, j] if el == x } }.flatten(1).compact.sort_by { |a, b| [a, -b]\
    \ }\nend", "  lst.each_with_index.map { |arr, i| arr.each_with_index.map { |e,\
    \ j| [i, j] if e == x } }.flatten(1).compact.sort_by { |item| [item[0], -item[1]]\
    \ }\nend", "  result = []\n  lst.each_with_index do |row, ri|\n    row.each_with_index\
    \ do |el, ci|\n      result << [ri, ci] if el == x\n    end\n  end\n  result.sort_by\
    \ { |row, col| [row, -col] }\nend", "  result = []\n  lst.each_with_index do |item,\
    \ index|\n    item.each_with_index do |it, idx|\n      result << [index, idx]\
    \ if it == x\n    end\n  end\n  result.sort_by! { |a, b| [a, -b] }\nend", "  lst.each_with_index.each_with_object([])\
    \ do |(row, idx), result|\n    row.each_with_index { |val, col| result << [idx,\
    \ col] if val == x }\n  end.sort_by { |x, y| [x, -y] }\nend", "\tlst.each_with_index.reduce([])\
    \ do |res, (l, i)|\n\t\tpos = l.reverse.each_with_index.reduce([]) { |arr, (el,\
    \ j)| el == x ? arr << j : arr }\n\t\tres += pos.reverse.map { |p| [i, p] }\n\t\
    end\nend", "  lst.each_with_index.with_object([]) do |(row, row_num), tuples|\n\
    \    row.each_with_index do |item, col_num|\n      tuples << [row_num, col_num]\
    \ if item == x\n    end\n  end.sort_by { |row, col| [-col, row] }\nend", "  result\
    \ = []\n  lst.each_with_index do |row, i|\n    row.each_with_index do |elem, j|\n\
    \      result << [i, j] if elem == x\n    end\n  end\n  result.sort.reverse\n\
    end", "  coords = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |elem, j|\n      coords << [i, j] if elem == x\n    end\n  end\n  coords.sort_by\
    \ do |(i, j)|\n    [i, -j]\n  end\nend", "  # res = []\n  # lst.each_with_index\
    \ do |row, row_index|\n  #   row.each_with_index do |val, column_index|\n  # \
    \    res << [row_index, column_index] if val == x\n  #   end\n  # end\n  # res.sort_by{|arr|\
    \ arr[0]}.map{|arr| arr.reverse}\n  lst.map.with_index{|row, row_index| row.map.with_index{|val,\
    \ column_index| [row_index, column_index] if val == x}}.flatten(1).compact.sort_by{|arr|\
    \ arr[0]}.map{|arr| arr.reverse}\nend", "  lst.each_with_index.map do |y, i|\n\
    \    y.each_with_index.map do |z, j|\n      [i, j] if z == x\n    end\n  end.flatten(1).compact.sort\
    \ do |a, b|\n    if a[0] < b[0]\n      -1\n    elsif a[0] > b[0]\n      1\n  \
    \  else\n      if a[1] < b[1]\n        1\n      elsif a[1] > b[1]\n        -1\n\
    \      else\n        0\n      end\n    end\n  end\nend", "  result = []\n  lst.each_with_index\
    \ do |sub_lst, row|\n    sub_lst.each_with_index do |sub_sub_lst, col|\n     \
    \ result << [row, col] if sub_sub_lst == x\n    end\n  end\n  result.sort_by {\
    \ |sub_sub_sub_lst| [sub_sub_sub_lst[0], -sub_sub_sub_lst[1]] }\nend", "  lst.each_with_index.flat_map\
    \ do |row, index|\n    row.each_with_index.flat_map do |elem, i|\n      if elem\
    \ == x\n        [[index, i]]\n      else\n        []\n      end\n    end\n  end.sort_by\
    \ { |arr| [arr[0], -arr[1]] }\nend", "  # x_indices = []\n  # lst.each_with_index\
    \ do |el, i|\n  #   el.each_with_index do |el2, j|\n  #     x_indices << [i, j]\
    \ if el2 == x\n  #   end\n  # end\n  # x_indices.sort_by { |pair| [pair[0], -pair[1]]\
    \ }\n  x_indices = []\n  lst.each_with_index do |el, i|\n    el.each_with_index\
    \ do |el2, j|\n      x_indices << [i, j] if el2 == x\n    end\n  end\n  x_indices.sort\n\
    end", "  result = []\n  lst.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, k|\n      result << [i, k] if col == x\n    end\n  end\n  result.sort_by\
    \ { |x| x[0] }.map { |x| [x[0], -x[1]] }.sort_by { |x| x[1] }.map { |x| [x[0],\
    \ -x[1]] }\nend", "  res = []\n  (0...lst.size).each do |i|\n    lst[i].each_with_index\
    \ do |y, j|\n      res << [i, j] if y == x\n    end\n  end\n  res.sort! { |a,\
    \ b| [a[0], -a[1]] <=> [b[0], -b[1]] }\nend", "  a = []\n  (0...lst.size).each\
    \ { |i|\n    if lst[i].include?(x)\n      (0...lst[i].size).each { |j|\n     \
    \   a << [i, j] if lst[i][j] == x\n      }\n    end\n  }\n  a.sort_by { |i, j|\
    \ [i, -j] }\nend", "  lst.each_with_index.with_object([]) do |(row, row_idx),\
    \ coords|\n    row.each_with_index do |el, col_idx|\n      coords << [row_idx,\
    \ col_idx] if el == x\n    end\n  end.sort_by { |coord| [coord[0], -coord[1]]\
    \ }\nend", "  # write your code here\nend", "  row_count = 0\n  col_count = 0\n\
    \  # intializing an empty array to store the values\n  result = []\n  # iterating\
    \ through each row\n  lst.each do |row|\n    # iterating through each element\n\
    \    row.each do |element|\n      #checking if element == given number\n     \
    \ if element == x\n        # appending the values in the array\n        result\
    \ << [row_count, col_count]\n      end\n      col_count += 1\n    end\n    row_count\
    \ += 1\n    col_count = 0\n  end\n  # sorting the result in ascending order of\
    \ rows and descending order of columns\n  result.sort.reverse\nend", "\tlen=lst.length\n\
    \ti=0\n\tj=0\n\tarr=[]\n\twhile(i<len)\n\t\tj=0\n\t\twhile(j<lst[i].length)\n\t\
    \t\tif(lst[i][j]==x)\n\t\t\t\tarr.push([i,j])\n\t\t\tend\n\t\t\tj+=1\n\t\tend\n\
    \t\ti+=1\n\tend\n\tarr=arr.sort_by{|item| item[0]}\n\tarr.sort_by!{|item| item[1]}.reverse!\n\
    \treturn arr\nend", "  res = []\n  lst.each_with_index do |e, i|\n    e.each_with_index\
    \ do |f, j|\n      res << [i, j] if f == x\n    end\n  end\n  res.sort_by { |e|\
    \ [e[0], -e[1]] }\nend", "  result = []\n  lst.each_with_index do |arr, index|\n\
    \    arr.each_with_index do |element, el_index|\n      result << [index, el_index]\
    \ if element == x\n    end\n  end\n  result.sort_by{|el| [el[0], -el[1]]}\nend",
  "  lst.map { |sub_list| [sub_list.each_index.select { |i| sub_list[i] == x }, sub_list.count(x)]\
    \ }\n        .select { |sub_list| sub_list[1] > 0 }\n        .sort { |sub_list1,\
    \ sub_list2| sub_list1[1] <=> sub_list2[1] }\n        .map { |sub_list| sub_list[0].map\
    \ { |i| [lst.index(sub_list[0][i]), i] } }\n        .flatten(1)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
