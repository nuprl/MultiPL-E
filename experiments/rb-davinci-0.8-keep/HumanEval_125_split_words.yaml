name: HumanEval_125_split_words
language: rb
prompt: "# Given a string of words, return a list of words split on whitespace, if\
  \ no whitespaces exists in the text you\n# should split on commas ',' if no commas\
  \ exists you should return the number of lower-case letters with odd order in the\n\
  # alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n# Examples\n# split_words(\"\
  Hello world!\") \u279E [\"Hello\", \"world!\"]\n# split_words(\"Hello,world!\")\
  \ \u279E [\"Hello\", \"world!\"]\n# split_words(\"abcdef\") == 3\ndef split_words(txt)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_split_words\n\
  \    candidate = method(:split_words)\n    assert_equal([\"Hello\", \"world!\"],\
  \ candidate.call(\"Hello world!\"))\n    assert_equal([\"Hello\", \"world!\"], candidate.call(\"\
  Hello,world!\"))\n    assert_equal([\"Hello\", \"world,!\"], candidate.call(\"Hello\
  \ world,!\"))\n    assert_equal([\"Hello,Hello,world\", \"!\"], candidate.call(\"\
  Hello,Hello,world !\"))\n    assert_equal(3, candidate.call(\"abcdef\"))\n    assert_equal(2,\
  \ candidate.call(\"aaabb\"))\n    assert_equal(1, candidate.call(\"aaaBb\"))\n \
  \   assert_equal(0, candidate.call(\"\"))\n  end\nend\n"
completions: ["  txt.split(\",\").size>1 ? txt.split(\",\") : txt.split(\" \").size>1\
    \ ? txt.split(\" \") : txt.size.odd? ? 0 : 1\nend", "  return txt.split(\" \"\
    ) if txt.include?(\" \")\n  return txt.split(\",\") if txt.include?(\",\")\n \
    \ index = 0\n  count = 0\n  while index < txt.length\n    if index.odd?\n    \
    \  count += 1 if txt[index] == txt[index].downcase\n    end\n    index += 1\n\
    \  end\n  count\nend", "  txt.include?(' ') ? txt.split(' ') : txt.include?(',')\
    \ ? txt.split(',') : txt.count('a-z').odd? ? txt.count('a-z') : 1\nend", "   \
    \ if txt.include?(\" \")\n        txt.split(\" \")\n    elsif txt.include?(\"\
    ,\")\n        txt.split(\",\")\n    else\n        return txt.count(\"a-z\") %\
    \ 2\n    end\nend", "  return txt.split(/\\s|,/) if txt.match(/\\s|,/)\n  return\
    \ txt.chars.select.with_index { |_, i| i.odd? }.size if txt.match(/[a-z]/)\nend",
  "  if txt.count(' ') > 0\n    txt.split(' ')\n  elsif txt.count(',') > 0\n    txt.split(',')\n\
    \  else\n    txt.scan(/[a-z]/).count { |e| e.ord.odd? }\n  end\nend", "  if txt.include?('\
    \ ')\n    txt.split(' ')\n  elsif txt.include?(',')\n    txt.split(',')\n  else\n\
    \    odd_num = []\n    txt.each_char do |x|\n      if ('a'..'z').include?(x)\n\
    \        odd_num << x if x.ord.odd?\n      end\n    end\n    odd_num.size\n  end\n\
    end", "  if txt.match(/\\s/)\n    txt.split(/\\s/)\n  elsif txt.match(/\\,/)\n\
    \    txt.split(/\\,/)\n  else\n    count = 0\n    txt.each_char { |c| count +=\
    \ 1 if c.ord.odd? }\n    count\n  end\nend", "    if txt.include?(\" \")\n   \
    \     return txt.split(\" \")\n    elsif txt.include?(\",\")\n        return txt.split(\"\
    ,\")\n    else\n        return txt.count(\"abcdefghijklmnopqrstuvwxyz\".split(\"\
    \").select {|x| \"abcdefghijklmnopqrstuvwxyz\".index(x) % 2 == 1})\n    end\n\
    end", "  if txt.include?(\" \")\n    return txt.split(\" \")\n  elsif txt.include?(\"\
    ,\")\n    return txt.split(\",\")\n  else\n    sum = 0\n    result = txt.chars.select\
    \ { |letter| sum += letter.ord - 96 if letter.ord.odd? }\n    return sum\n  end\n\
    end", "  txt.split(/[, ]/).size\nend", "  return txt.split(/[\\s,]/) if txt.include?('\
    \ ') || txt.include?(',')\n  i = 0\n  (0..txt.length-1).each do |x|\n    i +=\
    \ 1 if txt[x].ord % 2 == 1\n  end\n  i\nend", "  if txt.count(\" \") == 0\n  \
    \  txt.count(\",\") == 0 ? txt.chars.count { |l| txt.chars.index(l).odd? } : txt.split(\"\
    ,\")\n  else\n    txt.split(\" \")\n  end\nend", "    if txt =~ /\\s/\n      \
    \  return txt.split(/\\s/)\n    elsif txt =~ /,/\n        return txt.split(/,/)\n\
    \    else\n        txt_count = txt.count('a-z')\n        return txt_count%2 !=\
    \ 0 ? txt_count : 0\n    end\nend\np split_words(\"abcdef\")\np split_words(\"\
    hello world!\")\np split_words(\"Hello,world!\")", "  (txt.include? \" \") ? txt.split(\"\
    \ \") : (txt.include? \",\") ? txt.split(\",\") : txt.count(\"a-z\")\nend", " \
    \ if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n    txt.split(',')\n\
    \  else\n    txt.downcase.split('').count { |l| (l.ord - 96).odd? }\n  end\nend",
  "  my_array = txt.split(/[\\s,]/)\n  (my_array.empty?) ? txt.size : my_array\nend",
  "  if txt.split.size > 1\n    txt.split\n  elsif txt.split(\",\").size > 1\n   \
    \ txt.split(\",\")\n  else\n    count = 0\n    txt.chars.each do |x|\n      if\
    \ txt.chars.index(x).odd? && x == x.downcase\n        count += 1\n      end\n\
    \    end\n    count\n  end\nend", "  if txt.include?(' ')\n    txt.split(' ')\n\
    \  elsif txt.include?(',')\n    txt.split(',')\n  else\n    vowels = ['a', 'e',\
    \ 'i', 'o', 'u']\n    count = 0\n    txt.each_char do |ch|\n      count += 1 if\
    \ vowels.include?(ch)\n    end\n    count\n  end\nend", "  return [] if txt.empty?\n\
    \  if txt.count(' ') > 0\n    return txt.split(' ')\n  elsif txt.count(',') >\
    \ 0\n    return txt.split(',')\n  else\n    count = 0\n    txt.chars.each do |e|\n\
    \      count += 1 if e.ord.odd?\n    end\n    return count\n  end\nend", "  txt.include?('\
    \ ') ? txt.split(' ') : txt.include?(',') ? txt.split(',') : txt.count{|i| ('a'..'z').to_a.index(i).odd?}\n\
    end", "  (txt.include?(' ') || txt.include?(',')) ? txt.tr(',', ' ').split : txt.split.count\
    \ { |x| txt.downcase.index(x) % 2 == 0 }\nend", "  if txt.include?(' ')\n    txt.split('\
    \ ')\n  elsif txt.include?(',')\n    txt.split(',')\n  else\n    txt.count('abdfhlnoprsyz')\n\
    \  end\nend", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n\
    \    txt.split(',')\n  else\n    txt.chars.select.with_index { |_, i| i.odd? }.count\n\
    \  end\nend", "\tif txt.index(\" \") != nil\n\t\ttxt.split(\" \")\n\telsif txt.index(\"\
    ,\") != nil\n\t\ttxt.split(\",\")\n\telse\n\t\todds = []\n\t\tind = 0\n\t\twhile\
    \ ind < txt.length\n\t\t\tif txt[ind].ord % 2 != 0\n\t\t\t\todds.push(txt[ind])\n\
    \t\t\tend\n\t\t\tind += 1\n\t\tend\n\t\todds.length\n\tend\nend", "  txt.split(/[\\\
    s,]/)\n  txt.split(/[\\s,]/).length\nend\nputs split_words(\"abcdef\")", "  #\
    \ \u043F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u0435\u0441\u0442\u044C\
    \ \u043B\u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u044B \u0432 \u0441\u0442\u0440\
    \u043E\u043A\u0435.\n  if txt.include?(' ')\n    # \u0432\u043E\u0437\u0432\u0440\
    \u0430\u0449\u0430\u0435\u043C \u043C\u0430\u0441\u0441\u0438\u0432 \u0441\u043B\
    \u043E\u0432\n    return txt.split(' ')\n  # \u0435\u0441\u043B\u0438 \u043D\u0435\
    \u0442 \u043F\u0440\u043E\u0431\u0435\u043B\u043E\u0432, \u043F\u0440\u043E\u0432\
    \u0435\u0440\u044F\u0435\u043C \u0435\u0441\u0442\u044C \u043B\u0438 \u0437\u0430\
    \u043F\u044F\u0442\u044B\u0435 \u0432 \u0441\u0442\u0440\u043E\u043A\u0435\n \
    \ elsif txt.include?(',')\n    # \u0432\u043E\u0437\u0432\u0440\u0430\u0449\u0430\
    \u0435\u043C \u043C\u0430\u0441\u0441\u0438\u0432 \u0441\u043B\u043E\u0432\n \
    \   return txt.split(',')\n  # \u0435\u0441\u043B\u0438 \u043D\u0435\u0442 \u043F\
    \u0440\u043E\u0431\u0435\u043B\u043E\u0432 \u0438 \u0437\u0430\u043F\u044F\u0442\
    \u044B\u0445, \u0437\u043D\u0430\u0447\u0438\u0442 \u0432\u043E\u0437\u0432\u0440\
    \u0430\u0449\u0430\u0435\u043C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\
    \u0432\u043E \u0431\u0443\u043A\u0432 \u0441 \u043D\u0435\u0447\u0435\u0442\u043D\
    \u044B\u043C \u043F\u043E\u0440\u044F\u0434\u043A\u043E\u0432\u044B\u043C \u043D\
    \u043E\u043C\u0435\u0440\u043E\u043C \u0432 \u0430\u043B\u0444\u0430\u0432\u0438\
    \u0442\u0435\n  else\n    arr = (0..25).to_a\n    res = 0\n    # \u043F\u0435\u0440\
    \u0435\u0431\u0438\u0440\u0430\u0435\u043C \u0432\u0441\u0435 \u0431\u0443\u043A\
    \u0432\u044B \u0438\u0437 \u0441\u0442\u0440\u043E\u043A\u0438\n    txt.each_char\
    \ do |x|\n      # \u0435\u0441\u043B\u0438 \u043E\u043D\u0430 \u0435\u0441\u0442\
    \u044C \u0432 \u043C\u0430\u0441\u0441\u0438\u0432\u0435 \u043D\u0435\u0447\u0435\
    \u0442\u043D\u044B\u0445 \u0431\u0443\u043A\u0432, \u0443\u0432\u0435\u043B\u0438\
    \u0447\u0438\u0432\u0430\u0435\u043C \u0441\u0447\u0435\u0442\u0447\u0438\u043A\
    \n      if arr.include?(x.ord - 97)\n        res += 1\n      end\n    end\n  \
    \  # \u0432\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C \u0441\u0447\
    \u0435\u0442\u0447\u0438\u043A\n    return res\n  end\nend", "  if txt.include?('\
    \ ')\n    txt.split(' ')\n  elsif txt.include?(',')\n    txt.split(',')\n  else\n\
    \    odd = []\n    txt.chars.map(&:ord).each_with_index do |a, idx|\n      odd\
    \ << txt[idx] if a.odd?\n    end\n    odd.length\n  end\nend", "  if txt.index('\
    \ ')\n    txt.split(' ')\n  elsif txt.index(',')\n    txt.split(',')\n  else\n\
    \    txt.count { |char| char.ord < 97 }\n  end\nend", "  return txt.split(\" \"\
    ) if txt.include?(\" \")\n  return txt.split(\",\") if txt.include?(\",\")\n \
    \ txt.count(\"abcdefghijklmnopqrstuvwxyz\".chars.select { |ch| ch.ord.odd? })\n\
    end", "  res = []\n  i = 0\n  if !txt.match(/\\s/).nil?\n    res = txt.split('\
    \ ')\n  elsif !txt.match(/,/).nil?\n    res = txt.split(',')\n  else\n    res\
    \ = txt.scan(/[a-z]/).each_with_index do |x, index|\n      i += 1 if index.odd?\n\
    \    end\n    res = i\n  end\n  res\nend", "  txt.split(/[,\\s]/).reject(&:empty?)\n\
    end", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n\
    \    txt.split(',')\n  else\n    count = 0\n    txt.each_char do |char|\n    \
    \  count += 1 if txt.index(char).odd?\n    end\n    count\n  end\nend", "  return\
    \ txt.split(/[\\s,]/) if txt =~ /[\\s,]/\n  return txt.count(/[acegikmoqsuwy]/)\n\
    end", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n\
    \    txt.split(',')\n  else\n    count = 0\n    txt.chars.each do |x|\n      if\
    \ x.ord.to_i.odd?\n        count += 1\n      end\n    end\n    count\n  end\n\
    end", "    if txt.include?(\" \")\n        return txt.split(\" \")\n    elsif\
    \ txt.include?(\",\")\n        return txt.split(\",\")\n    else\n        count\
    \ = 0\n        txt.each_char do |i|\n            count += 1 if (i.ord - 97) %\
    \ 2 == 1\n        end\n        return count\n    end\nend", "\tif !txt.include?\
    \ \" \"\n\t\tif !txt.include? \",\"\n\t\t\treturn txt.downcase.each_char.select\
    \ {|char| txt.downcase.index(char).odd?}.count\n\t\telse\n\t\t\treturn txt.split(\"\
    ,\")\n\t\tend\n\telse\n\t\treturn txt.split(\" \")\n\tend\nend", "  if txt.index('\
    \ ')\n    txt.split(' ')\n  elsif txt.index(',')\n    txt.split(',')\n  else\n\
    \    count = 0\n    0.upto(txt.length - 1) do |i|\n      count += 1 if i.odd?\
    \ && txt[i] == txt[i].downcase\n    end\n    count\n  end\nend\np split_words(\"\
    Hello world!\") == [\"Hello\", \"world!\"]\np split_words(\"Hello,world!\") ==\
    \ [\"Hello\", \"world!\"]\np split_words(\"abcdef\") == 3", "    if txt.include?('\
    \ ')\n        return txt.split(' ')\n    elsif txt.include?(',')\n        return\
    \ txt.split(',')\n    else\n        return odd_chars(txt)\n    end\nend", "  \
    \  return txt.split(\" \") if txt.include?(\" \")\n    return txt.split(\",\"\
    ) if txt.include?(\",\")\n    return txt.chars.select.with_index { |letter, i|\
    \ i.odd? && letter == letter.downcase }.length\nend\nputs split_words(\"abcdef\"\
    )", "  txt.split(/[\\s,]/).reject { |c| c.empty? }.empty? ? txt.chars.map(&:ord).select\
    \ { |n| n.odd? }.size : txt.split(/[\\s,]/)\nend", "  if txt.count(' ') != 0\n\
    \    return txt.split(' ')\n  elsif txt.count(',') != 0\n    return txt.split(',')\n\
    \  else\n    arr = []\n    i = 0\n    while i < txt.length\n      if (txt[i].ord\
    \ - 97) % 2 != 0\n        arr.push(txt[i])\n      end\n      i += 1\n    end\n\
    \    return arr.length\n  end\nend", "  if txt.include?(' ')\n    txt.split('\
    \ ')\n  elsif txt.include?(',')\n    txt.split(',')\n  else\n    odd = 0\n   \
    \ txt.each_char { |x| odd += 1 if x.ord.odd? }\n    odd\n  end\nend", "\t# if\
    \ txt.match(\" \")\n\t# \tarr_str = txt.split(\" \")\n\t# \treturn arr_str\n\t\
    # elsif txt.match(\",\")\n\t# \tarr_str = txt.split(\",\")\n\t# \treturn arr_str\n\
    \t# else\n\t# \treturn txt.count(\"a\",\"c\",\"e\",\"g\",\"i\",\"k\",\"m\",\"\
    o\",\"q\",\"s\",\"u\",\"w\",\"y\")\n\t# end\n\tif txt.match(\" \") \n\t\treturn\
    \ txt.split(\" \")\n\telsif txt.match(\",\")\n\t\treturn txt.split(\",\")\n\t\
    else\n\t\t# number of odd of letters\n\t\tnumber_odd = 0\n\t\t# letters from a\
    \ to z\n\t\talphabet = 'abcdefghijklmnopqrstuvwxyz'\n\t\talphabet.each_char do\
    \ |letter|\n\t\t\tif (alphabet.index(letter) % 2) != 0\n\t\t\t\tif txt.include?(letter)\n\
    \t\t\t\t\tnumber_odd += 1\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn number_odd\n\
    \tend\nend", "  if txt.count(' ') != 0\n    txt.split(' ')\n  elsif txt.count(',')\
    \ != 0\n    txt.split(',')\n  else\n    txt.count('a-z').odd?\n  end\nend", " \
    \   if txt.include?(' ')\n        txt.split(' ')\n    elsif txt.include?(',')\n\
    \        txt.split(',')\n    else\n        txt.split('').select {|c| ('a'..'z').include?(c)\
    \ && c.ord.odd? }.size\n    end\nend", "  if txt.include?(\" \")\n    return txt.split('\
    \ ')\n  elsif txt.include?(\",\")\n    return txt.split(',')\n  else\n    txt_length\
    \ = txt.length\n    return txt_length\n  end\nend", "  txt.split(\" \").length\
    \ > 1 ? txt.split(\" \") : txt.split(\",\").length > 1 ? txt.split(\",\") : txt.split(\"\
    \").select.with_index { |letter, idx| letter.ord.even? }.length\nend", "\tif txt.include?\
    \ \" \"\n\t\ttxt.split(\" \")\n\telsif txt.include? \",\"\n\t\ttxt.split(\",\"\
    )\n\telse\n\t\todd = txt.count {|i| i =~ /[bdfhjlnprtvxz]/}\n\t\teven = txt.count\
    \ {|i| i =~ /[aeiouy]/}\n\t\todd - even\n\tend\nend\np split_words(\"Hello world!\"\
    ) #\u279E [\"Hello\", \"world!\"]\np split_words(\"Hello,world!\") #\u279E [\"\
    Hello\", \"world!\"]\np split_words(\"abcdef\") #== 3", "  if txt.count(' ') >\
    \ 0\n    puts txt.split(' ')\n  elsif txt.count(',') > 0\n    puts txt.split(',')\n\
    \  else\n    puts txt.count('a'..'z').odd?\n  end\nend", "  return txt.split('\
    \ ') if txt.include? ' '\n  return txt.split(',') if txt.include? ','\n  return\
    \ txt.split('').select.with_index { |_, i| i.odd? }.count\nend", "    if txt =~\
    \ /\\s/\n        return txt.split(' ')\n    elsif txt =~ /,/\n        return txt.split(',')\n\
    \    else\n        c = 0\n        for i in 0..txt.length-1\n            if txt[i].ord\
    \ % 2 == 1\n                c += 1\n            end\n        end\n        return\
    \ c\n    end\nend", "    if txt.include?(' ')\n        txt.split(' ')\n    elsif\
    \ txt.include?(',')\n        txt.split(',')\n    else\n        count = 0\n   \
    \     txt.each_char do |char|\n            count += 1 if char.ord % 2 == 1\n \
    \       end\n        count\n    end\nend", "  return txt.split(/[ ,]/) if txt.index('\
    \ ') || txt.index(',')\n  ary = (\"a\"..\"z\").to_a\n  odds = []\n  txt.downcase.chars.each\
    \ do |ch|\n    odds << ch if ary.index(ch).odd?\n  end\n  odds.length\nend", " \
    \ if txt.index(' ')\n    return txt.split(' ')\n  elsif txt.index(',')\n    return\
    \ txt.split(',')\n  end\n  counter = 0\n  txt.split('').each do |char|\n    if\
    \ (char.ord - 97).odd?\n      counter += 1\n    end\n  end\n  counter\nend", " \
    \   if txt.include? \" \"\n        return txt.split(\" \")\n    elsif txt.include?\
    \ \",\"\n        return txt.split(\",\")\n    else\n        p txt.length\n   \
    \ end\n    \"abcde\".split(\" \")\nend\nsplit_words(\"Hello world!\")\nsplit_words(\"\
    Hello,world!\")\nsplit_words(\"abcdef\")", "  if txt.include?(\" \")\n    txt.split(\"\
    \ \")\n  elsif txt.include?(\",\")\n    txt.split(\",\")\n  else\n    txt.count\
    \ \"abcdefghijklmnopqrstuvwxyz\".chars.reject { |i| i.ord.even? }\n  end\nend",
  "    txt.match(/\\s/) ? txt.split : (txt.match(/\\w+/) ? txt.scan(/\\w+/) : txt.scan(/[a-z]/).count)\n\
    end", "  if txt.split.size == 1 && txt.split(\",\").size == 1\n    return txt.count{|x|x.match?(/[a-z]/)}\n\
    \  elsif txt.split(\",\").size == 1\n    return txt.split\n  else\n    return\
    \ txt.split(\",\")\n  end\nend", "  if txt.include?(\" \")\n    txt.split(\" \"\
    )\n  elsif txt.include?(\",\")\n    txt.split(\",\")\n  else\n    odd_alphabet\
    \ = []\n    i = 0\n    while i < txt.length\n      if txt[i].ord % 2 != 0\n  \
    \      odd_alphabet << txt[i]\n      end\n      i += 1\n    end\n    odd_alphabet.length\n\
    \  end\nend", "  return txt.split(' ') if txt.include?(' ')\n  return txt.split(',')\
    \ if txt.include?(',')\n  txt.chars.select.with_index{|ch, i| ('a'..'z').include?(ch)\
    \ && i % 2 == 0}.count\nend", "  txt.split(/\\s|,/).length > 1 ? txt.split(/\\\
    s|,/) : txt.count('a-z').odd? ? txt.count('a-z') : 0\nend", "  if txt.match(/\\\
    s/)\n    return txt.split(' ')\n  elsif txt.match(/,/)\n    return txt.split(',')\n\
    \  else\n    txt.count(Regexp.new(\"[#{txt.gsub(/[^a-z]/, '')}]\"))\n  end\nend",
  "\treturn txt.split(/[\\s,]/) if txt.include?(' ')\n\treturn txt.split(',') if txt.include?(',')\n\
    \treturn txt.length if txt.length\nend", "  if txt.include? \" \"\n    txt.split(\"\
    \ \")\n  elsif txt.include? \",\"\n    txt.split(\",\")\n  else\n    txt.chars.select\
    \ {|char| char == char.downcase && char.ord % 2 == 1 }.count\n  end\nend", " \
    \ if txt.include?(\" \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n\
    \    txt.split(\",\")\n  else\n    txt.count(\"a-z\")\n  end\nend", "  if txt.index(\"\
    \ \")\n    return txt.split(\" \")\n  elsif txt.index(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    i = 0\n    for char in txt.chars\n      i += 1 if char.downcase\
    \ == \"a\" || char.downcase == \"c\" || char.downcase == \"e\" || char.downcase\
    \ == \"g\" || char.downcase == \"i\" || char.downcase == \"k\" || char.downcase\
    \ == \"m\" || char.downcase == \"o\" || char.downcase == \"q\" || char.downcase\
    \ == \"s\" || char.downcase == \"u\" || char.downcase == \"w\" || char.downcase\
    \ == \"y\"\n    end\n    return i\n  end\nend", "\t#p txt.split(/[ ,]/)\n\tif\
    \ txt.split(/[ ,]/).length == 1\n\t\treturn txt.length.times.count{|x| txt[x].ord.odd?}\n\
    \telse\n\t\treturn txt.split(/[ ,]/)\n\tend\nend", "  if txt =~ /\\s/\n    txt.split\n\
    \  elsif txt =~ /,/\n    txt.split(',')\n  else\n    txt.chars.map { |c| c.ord\
    \ - 97 }.select(&:odd?).count\n  end\nend", "  if txt.include?(' ')\n    return\
    \ txt.split\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n  \
    \  return txt.count('a-z')\n  end\nend", "  # your code here\nend\nputs split_words(\"\
    Hello world!\") #\u279E [\"Hello\", \"world!\"]\nputs split_words(\"Hello,world!\"\
    ) #\u279E [\"Hello\", \"world!\"]\nputs split_words(\"abcdef\") #== 3\nputs \"\
    -\"*40", "  return txt.downcase.split(/[,\\s]/) if txt.match(/[,\\s]/)\n  alpha\
    \ = ('a'..'z').to_a\n  txt.downcase.chars.map { |x| x = alpha.index(x) }.select\
    \ { |x| x.odd? }.size\nend", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif\
    \ txt.include?(',')\n    txt.split(',')\n  else\n    # txt.each_char.with_index\
    \ { |x,i| i if x.downcase != i }\n    # txt.length - txt.chars.join.downcase.delete('abdegikmoqsuwy').length\n\
    \    txt.length - txt.chars.map { |x| txt.chars.index(x) if x.downcase.ord !=\
    \ txt.chars.index(x) }.count(nil)\n  end\nend", "  txt.include?(' ') ? txt.split('\
    \ ') : txt.include?(',') ? txt.split(',') : txt.downcase.each_char.select { |char|\
    \ txt.downcase.index(char).odd? }.size\nend", "  return txt.split(/[\\s,]/) if\
    \ txt.match(/[\\s,]/)\n  return txt.size if txt.size % 2 == 1 && txt.match(/^[a-z]*$/)\n\
    \  return txt.size - 1 if txt.size % 2 == 0 && txt.match(/^[a-z]*$/)\nend", "\t\
    if txt.include?(\" \")\n\t\treturn txt.split(\" \")\n\telsif txt.include?(\",\"\
    )\n\t\treturn txt.split(\",\")\n\telse\n\t\treturn txt.length\n\tend\nend\nputs\
    \ split_words(\"Hello world!\")\nputs split_words(\"Hello,world!\")\nputs split_words(\"\
    abcdef\")", "  return txt.split(',') if txt.include?(',')\n  return txt.split('\
    \ ') if txt.include?(' ')\n  c = 0\n  txt.each_char { |x| c += 1 if x.ord.odd?\
    \ }\n  c\nend", "  txt.split(/\\W/).reject(&:empty?)\nend", "  if txt.include?(\"\
    \ \")\n    return txt.split(\" \")\n  elsif txt.include?(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    sum = 0\n    txt.chars.each_with_index do |value, index|\n \
    \     if (value.ord - \"a\".ord).odd?\n        sum += 1\n      end\n    end\n\
    \    return sum\n  end\nend", "\tif txt.include?(\" \")\n\t\ttxt.split(\" \")\n\
    \telsif txt.include?(\",\")\n\t\ttxt.split(\",\")\n\telse\n\t\tcount = 0\n\t\t\
    txt.chars.each do |x|\n\t\t\tcount += 1 if (x.ord - 'a'.ord).odd?\n\t\tend\n\t\
    \tcount\n\tend\nend", "  if txt.include? \" \"\n    return txt.split(\" \")\n\
    \  elsif txt.include? \",\"\n    return txt.split(\",\")\n  end\n  a = 0\n  arr\
    \ = []\n  txt.split(\"\").each do |x|\n    if (x.ord - \"a\".ord) % 2 == 1\n \
    \     a += 1\n    end\n  end\n  return a\nend", "  # TODO\nend", "  if txt.include?(\"\
    \ \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n    txt.split(\",\"\
    )\n  else\n    (0..txt.length-1).select {|x| x.odd? && txt[x] =~ /[a-z]/}.length\n\
    \  end\nend\np split_words(\"Hello world!\") # \u279E [\"Hello\", \"world!\"]\n\
    p split_words(\"Hello,world!\") # \u279E [\"Hello\", \"world!\"]\np split_words(\"\
    abcdef\") # \u279E 3\np split_words(\"asd a asd, fgh gh fgh\") # \u279E [\"asd\"\
    , \"a\", \"asd\", \"fgh\", \"gh\", \"fgh\"]\np split_words(\"asd asd,fgh fgh\"\
    ) # \u279E [\"asd\", \"asd\", \"fgh\", \"fgh\"]\np split_words(\"asd,fgh\") #\
    \ \u279E [\"asd\", \"fgh\"]\np split_words(\"asd asd\") # \u279E [\"asd\", \"\
    asd\"]\np split_words(\"asd fgh\") # \u279E [\"asd\", \"fgh\"]\np split_words(\"\
    asd\") # \u279E 1\np split_words(\"asd,\") # \u279E [\"asd\"]\np split_words(\"\
    asd,,\") # \u279E [\"asd\"]\np split_words(\"\") # \u279E []\np split_words(\"\
    asd,fgh,zxc\") # \u279E [\"asd\", \"fgh\", \"zxc\"]\np split_words(\"asd asd asd\"\
    ) # \u279E [\"asd\", \"asd\", \"asd\"]\np split_words(\"asd,fgh,zxc,fgh,zxc\"\
    ) # \u279E [\"asd\", \"fgh\", \"zxc\", \"fgh\", \"zxc\"]\np split_words(\"asd,fgh,asd,fgh\"\
    ) # \u279E [\"asd\", \"fgh\", \"asd\", \"fgh\"]\np split_words(\"asd,asd,", " \
    \  words = txt.split(' ')\n   if words.size == 1\n     words = txt.split(',')\n\
    \     if words.size == 1\n       letters = txt.split('')\n       total = 0\n \
    \      letters.each do |letter|\n         if letters.index(letter).odd?\n    \
    \       total += 1\n         end\n       end\n       return total\n     end\n\
    \   end\n   return words\nend", "  if txt.include?(\" \")\n    return txt.split(\"\
    \ \")\n  elsif txt.include?(\",\")\n    return txt.split(\",\")\n  else\n    counter\
    \ = 0\n    txt.split(\"\").each do |val|\n      if txt.index(val) % 2 == 0\n \
    \       counter += 1\n      end\n    end\n    return counter\n  end\nend", " \
    \ if txt.match?(/\\s/)\n    txt.split(/\\s/)\n  elsif txt.match?(/\\,/)\n    txt.split(/\\\
    ,/)\n  else\n    txt.downcase.chars.count { |i| 'a'.ord <= i.ord && i.ord <= 'z'.ord\
    \ && i.ord.odd? }\n  end\nend", "  # 1\n  if txt.include?(' ')\n    txt.split('\
    \ ')\n  elsif txt.include?(',')\n    txt.split(',')\n  else\n    0.upto(25).select\
    \ { |i| i.odd? }.length\n  end\n  # 2\n  # txt.gsub(/[^\\s,]/, '').size.odd? ?\
    \ txt.size - txt.gsub(/[^\\s,]/, '').size : txt.gsub(/[^\\s,]/, '').size - 1\n\
    end", "  if !txt.split(/\\s+/).empty?\n    txt.split(/\\s+/)\n  elsif !txt.split(/,/).empty?\n\
    \    txt.split(/,/)\n  else\n    txt.chars.count { |c| c.downcase.ord.odd? }\n\
    \  end\nend", "\tif txt.split.size > 1\n\t\ttxt.split\n\telsif txt.split(\",\"\
    ).size > 1\n\t\ttxt.split(\",\")\n\telse\n\t\tindex = 0\n\t\tindex_n = 0\n\t\t\
    (0..txt.size-1).each do |index|\n\t\t\tif index%2 == 0\n\t\t\t\tindex_n += 1\n\
    \t\t\tend\n\t\tend\n\t\tindex_n\n\tend\nend", "  txt.split.size == 1 ? txt.count('a-z').odd?\
    \ ? txt.count('a-z') : txt.split(',') : txt.split\nend", "\tif txt.include? \"\
    \ \"\n\t\treturn txt.split\n\telsif txt.include? \",\"\n\t\treturn txt.split(\"\
    ,\")\n\telse\n\t\treturn txt.chars.map{|a| a.ord-97}.select{|a| a%2==1}.length\n\
    \tend\nend", "  p txt.split(/\\W+/)\nend", "  if txt.include?(' ')\n    return\
    \ txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n  else\n\
    \    txt.downcase!\n    num_odd = 0\n    txt.each_char { |ch| num_odd += 1 if\
    \ txt.index(ch).odd? }\n    return num_odd\n  end\nend", "  if txt.include? \"\
    \ \"\n    return txt.split\n  elsif txt.include? \",\"\n    return txt.split(\"\
    ,\")\n  else\n    x = 0\n    txt.chars.each_with_index do |i, v|\n      if v.odd?\n\
    \        x += 1\n      end\n    end\n    return x\n  end\nend", "  if txt =~ /\\\
    s/\n    txt.split(/\\s/)\n  elsif txt =~ /,/\n    txt.split(',')\n  else\n   \
    \ count = 0\n    txt.each_char do |x|\n      count += 1 if ('a'..'z').to_a.index(x).odd?\n\
    \    end\n    count\n  end\nend", "  letters = ('a'..'z').to_a\n  txt.split.size\
    \ > 1 ? txt.split : txt.split(',').size > 1 ? txt.split(',') : letters.find_index(txt[0])\n\
    end", "  return txt.split if txt.include?(\" \")\n  return txt.split(\",\") if\
    \ txt.include?(\",\")\n  tmp = txt.chars.to_a.map { |c| c.ord - 97 }\n  tmp.select!\
    \ { |i| i.odd? }\n  tmp.size\nend", "\tif txt.include?(\" \")\n\t\treturn txt.split(\"\
    \ \")\n\telsif txt.include?(\",\")\n\t\treturn txt.split(\",\")\n\telse\n\t\t\
    count = 0\n\t\tletters = ('a'..'z').to_a\n\t\ttxt.chars.each do |letter|\n\t\t\
    \tif letters.index(letter).odd?\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\t\t\
    return count\n\tend\nend\nputs split_words(\"hello\")", "  if txt.split.length\
    \ > 1\n    txt.split\n  elsif txt.count(',') > 0\n    txt.split(',')\n  else\n\
    \    return txt.gsub(/[^a-z]/, '').length\n  end\nend", "  txt.split.count > 1\
    \ ? txt.split : txt.count(\"a-z\").odd? ? txt.count(\"a-z\") : txt.split(\",\"\
    )\nend", "  txt = txt.split(/\\s|,/)\n  txt.length == 1 ? txt[0].count('a-z').odd?\
    \ ? txt[0].count('a-z').odd : txt : txt\nend\np split_words(\"Hello world!\")\n\
    p split_words(\"Hello,world!\")\np split_words(\"abcdef\")", "  if txt.split.length\
    \ > 1\n    p txt.split(' ')\n  elsif txt.split(',').length > 1\n    p txt.split(',')\n\
    \  else\n    count = 0\n    txt.each_char do |letter|\n      count += 1 if letter.ord.odd?\n\
    \    end\n    p count\n  end\nend", "  if txt.include? \" \"\n    return txt.split(\"\
    \ \")\n  elsif txt.include? \",\"\n    return txt.split(\",\")\n  else\n    odd=0\n\
    \    for i in 0..txt.length-1\n      if txt[i].ord%2==1\n        odd+=1\n    \
    \  end\n    end\n    return odd\n  end\nend", "  if txt.index(' ')\n    return\
    \ txt.split(' ')\n  elsif txt.index(',')\n    return txt.split(',')\n  else\n\
    \    letters = txt.split('')\n    counter = 0\n    for i in 0..letters.length\n\
    \      if i % 2 == 1\n        counter += 1\n      end\n    end\n    return counter\n\
    \  end\nend", "  if txt.include? \" \"\n    return txt.split(\" \")\n  elsif txt.include?\
    \ \",\"\n    return txt.split(\",\")\n  else\n    return txt.scan(/[a-z]/).size\n\
    \  end\nend", "  if txt.split(\" \").size > 1\n    return txt.split(\" \")\n \
    \ elsif txt.split(\",\").size > 1\n    return txt.split(\",\")\n  else\n    return\
    \ txt.count(\"abcdefghijklmnopqrstuvwxyz\".chars.select { |s| s.ord.odd? })\n\
    \  end\nend", "    if txt.include? \" \"\n        txt.split(\" \")\n    elsif\
    \ txt.include? \",\"\n        txt.split(\",\")\n    else\n        # ord(\"a\"\
    ) = 0, ord(\"b\") = 1, ... ord(\"z\") = 25\n        count = 0\n        for i in\
    \ 0..txt.length-1\n            if txt[i].ord.odd?\n                count += 1\n\
    \            end\n        end\n        count\n    end\nend", "  words = txt.split(/[\\\
    s,]/)\n  if words.length > 1\n    return words\n  else\n    return txt.chars.select.with_index{|char,\
    \ index| ('a'..'z').include?(char) && index.odd?}.length\n  end\nend", "  if txt.include?(\"\
    \ \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n    txt.split(\",\"\
    )\n  else\n    txt.downcase.split(\"\").select {|a| a.ord % 2 == 1}.length\n \
    \ end\nend", "  if !txt.match(/\\s+/)\n    return txt.count \"^a-z\"\n  end\n\
    \  txt.split(/\\s+/)\nend", "  return txt.split if txt.include? \" \"\n  return\
    \ txt.split(\",\") if txt.include? \",\"\n  txt.count { |c| (c.ord - 97).odd?\
    \ }\nend", "  if txt.scan(/\\s/).empty? && txt.scan(/,/).empty?\n    alphabet\
    \ = ('a'..'z').to_a\n    counter = 0\n    txt.chars.each { |x| counter += 1 if\
    \ alphabet.index(x) % 2 == 1 }\n    counter\n  elsif txt.scan(/\\s/).empty?\n\
    \    txt.split(',')\n  else\n    txt.split(' ')\n  end\nend", "  if txt.include?(\"\
    \ \")\n    return txt.split(\" \")\n  elsif txt.include?(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    count = 0\n    txt.split(\"\").each do |x|\n      if x.ord %\
    \ 2 == 1\n        count += 1\n      end\n    end\n    return count\n  end\nend",
  "  arr = txt.split(\" \")\n  if arr.length > 1\n    return arr\n  else\n    arr\
    \ = txt.split(\",\")\n    if arr.length > 1\n      return arr\n    else\n    \
    \  odds = 0\n      txt.each_char do |char|\n        if ord(char) % 2 != 0\n  \
    \        odds += 1\n        end\n      end\n      return odds\n    end\n  end\n\
    end", "  txt.include?(' ') ? txt.split(' ') : (txt.include?(',') ? txt.split(',')\
    \ : txt.downcase.chars.map(&:ord).select(&:odd?).count)\nend", "  words = []\n\
    \  text = txt.strip\n  text.split(\",\").each do |i|\n    words.push(i)\n  end\n\
    \  if words.length == 1\n    text.split(\" \").each do |i|\n      words.push(i)\n\
    \    end\n  end\n  if words.length == 1\n    count = 0\n    text.each_char do\
    \ |i|\n      count += 1 if i.ord % 2 == 1\n    end\n    words.push(count)\n  end\n\
    \  words\nend", "\twords = []\n\tif txt.include? \" \"\n\t\twords = txt.split(\"\
    \ \")\n\telsif txt.include? \",\"\n\t\twords = txt.split(\",\")\n\telse\n\t\t\
    words << txt.length\n\tend\n\tp words\nend", "  if txt.include?(\" \")\n    txt.split(\"\
    \ \")\n  elsif txt.include?(\",\")\n    txt.split(\",\")\n  else\n    arr = []\n\
    \    for i in (0..txt.length - 1)\n      if i % 2 == 0\n        arr.push(txt[i])\n\
    \      end\n    end\n    arr.length\n  end\nend", "  if txt.include? \" \"\n \
    \   puts txt.split(\" \")\n  elsif txt.include? \",\"\n    puts txt.split(\",\"\
    )\n  else\n    odd_letters = []\n    odd_numbers = []\n    txt.each_char do |x|\n\
    \      odd_letters << x if (x.ord % 2) != 0\n    end\n    odd_letters.each do\
    \ |y|\n      odd_numbers << y.ord\n    end\n    p odd_numbers.count\n  end\nend",
  "  if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n    txt.split(',')\n\
    \  else\n    count = 0\n    txt.split('').each { |i| count += 1 if i.ord % 2 !=\
    \ 0 }\n    count\n  end\nend", "  txt.split.size > 1 ? txt.split : txt.split(',').size\
    \ > 1 ? txt.split(',') : split_in_odd_nums(txt)\nend", "  if txt.scan(/\\s/).empty?\n\
    \    txt.scan(/[a-z]/).each_with_index.select { |l, i| i.odd? }.map(&:first).size\n\
    \  else\n    txt.split(/\\s/)\n  end\nend", "  if txt.include? \" \"\n    return\
    \ txt.split(\" \")\n  elsif txt.include? \",\"\n    return txt.split(\",\")\n\
    \  else\n    array_ord = []\n    txt.each_char { |c| array_ord << c.ord - 97 }\n\
    \    counter = 0\n    array_ord.each do |e|\n      if e.odd?\n        counter\
    \ += 1\n      end\n    end\n    return counter\n  end\nend", "  if txt.include?('\
    \ ')\n    return txt.split(' ')\n  elsif txt.include?(',')\n    return txt.split(',')\n\
    \  else\n    return txt.scan(/[a-z]/).select.with_index { |_, idx| idx.odd? }.count\n\
    \  end\nend", "\tif txt.include? \" \"\n\t\treturn txt.split(\" \")\n\telsif txt.include?\
    \ \",\"\n\t\treturn txt.split(\",\")\n\telse\n\t\tcount = 0\n\t\tfor i in 0..txt.length\n\
    \t\t\tif txt[i].ord.odd?\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\t\treturn count\n\
    \tend\nend", "\tif txt.include?(\" \")\n\t\ttxt.split(\" \")\n\telsif txt.include?(\"\
    ,\")\n\t\ttxt.split(\",\")\n\telse\n\t\tcount = 0\n\t\ta = txt.split(\"\")\n\t\
    \ta.each do |letter|\n\t\t\tcount += 1 if letter.ord % 2 == 1\n\t\tend\n\t\tcount\n\
    \tend\nend\np split_words(\"Hello world!\")\np split_words(\"Hello,world!\")\n\
    p split_words(\"abcdef\")\np split_words(\"abcdefghijklmnopqrstuvwxyz\")", " \
    \ txt.include?(\" \") ? txt.split(\" \") : (txt.include?(\",\") ? txt.split(\"\
    ,\") : txt.downcase.chars.select.with_index { |_, i| i.odd? }.size)\nend", " \
    \ if txt.include?(\" \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n\
    \    txt.split(\",\")\n  else\n    arr = txt.split(\"\")\n    odd = arr.select\
    \ { |num| num.ord.odd? }\n    odd.count\n  end\nend\np split_words(\"Hello world!\"\
    )\np split_words(\"Hello,world!\")\np split_words(\"abcdef\")", "  splited = []\n\
    \  unless txt.split.empty?\n    splited = txt.split\n  else\n    unless txt.split(',').empty?\n\
    \      splited = txt.split(',')\n    else\n      splited = txt.count { |letter|\
    \  ('a'..'z').to_a.index(letter) % 2 == 1 }\n    end\n  end\n  return splited\n\
    end", "  if txt =~ /\\s/\n    txt.split\n  elsif txt =~ /,/\n    txt.split(',')\n\
    \  else\n    txt.chars.select.with_index { |char, index| (char.ord - 97).odd?\
    \ }.size\n  end\nend", "  if txt.include?(\" \")\n    return txt.split(\" \")\n\
    \  elsif txt.include?(\",\")\n    return txt.split(\",\")\n  else\n    counter\
    \ = 0\n    str = \"\"\n    txt.each_char do |c|\n      if c.ord.even?\n      \
    \  counter += 1\n      end\n    end\n    return counter\n  end\nend", "  if txt.count(\"\
    \ \") == 0 && txt.count(\",\") == 0\n    txt.count(\"abcdefghijklmnopqrstuvwxyz\"\
    .chars.select { |letter| txt.count(letter).odd? })\n  elsif txt.count(\" \") ==\
    \ 0\n    txt.split(\",\")\n  else\n    txt.split(\" \")\n  end\nend", "  if txt.match(\"\
    \ \")\n    txt.split(\" \")\n  elsif txt.match(\",\")\n    txt.split(\",\")\n\
    \  else\n    count = 0\n    for i in 0..txt.length\n      if i % 2 == 0\n    \
    \    if txt[i] == txt[i].downcase\n          count += 1\n        end\n      end\n\
    \    end\n    count\n  end\nend", "  if txt.match?(/\\s/)\n    txt.split(\" \"\
    )\n  elsif txt.match?(/\\,/)\n    txt.split(\",\")\n  else\n    txt.count(\"a-z\"\
    )\n  end\nend", "  return txt.split(/[, ]/) if txt.include?(\" \") || txt.include?(\"\
    ,\")\n  return txt.split(\"\").count { |char| char.ord.odd? }\nend", "  if txt.include?(\"\
    \ \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n    txt.split(\",\"\
    )\n  else\n    txt.scan(/[a-z]/).select.with_index { |_, i| i.odd? }.size\n  end\n\
    end\np split_words(\"Hello world!\") #\u279E [\"Hello\", \"world!\"]\np split_words(\"\
    Hello,world!\") #\u279E [\"Hello\", \"world!\"]\np split_words(\"abcdef\") #\u279E\
    \ 3", "  # with split\n  # txt.split.size\n  # txt.split(/[ ,]/).size", "    if\
    \ txt.match(/\\s/) != nil\n        txt.split\n    elsif txt.match(/,/) != nil\n\
    \        txt.split(\",\")\n    else\n        count = 0\n        for i in 0..txt.length\
    \ - 1\n            if (txt[i].ord % 2 == 1)\n                count += 1\n    \
    \        end\n        end\n        count\n    end\nend\nputs split_words(\"Hello\
    \ world!\")\nputs split_words(\"Hello,world!\")\nputs split_words(\"abcdef\")",
  "  words = []\n  if txt.include?(' ')\n    words = txt.split(' ')\n  elsif txt.include?(',')\n\
    \    words = txt.split(',')\n  else\n    x = 0\n    i = 0\n    while i < txt.length\n\
    \      if txt[i].ord % 2 == 1\n        x += 1\n      end\n      i += 1\n    end\n\
    \    words.push(x)\n  end\n  words\nend", "\twords = txt.split\n\treturn words\
    \ unless words.empty?\n\tletters = txt.split('')\n\treturn letters.count { |letter|\
    \ ('a'..'z').include?(letter) && letters.index(letter).odd? }\nend", "\tif txt.include?\
    \ \" \"\n\t\treturn txt.split(\" \")\n\telsif txt.include? \",\"\n\t\treturn txt.split(\"\
    ,\")\n\telse\n\t\tcount = 0\n\t\tfor i in 0..txt.length\n\t\t\tif txt[i].ord %\
    \ 2 == 1\n\t\t\t\tcount += 1\n\t\t\tend\n\t\tend\n\t\treturn count\n\tend\nend",
  "  return txt.split(',') if txt.include?(',')\n  return txt.split(' ') if txt.include?('\
    \ ')\n  count = 0\n  txt.chars.each_with_index do |c, i|\n    count += 1 if i.odd?\
    \ && c == c.downcase\n  end\n  count\nend", "  # split on space if present\n \
    \ if txt.include?(' ')\n    txt.split(' ')\n  # split on comma if present\n  elsif\
    \ txt.include?(',')\n    txt.split(',')\n  # otherwise return the number of lower-case\
    \ letters with odd order in the alphabet\n  else\n    txt.chars.map(&:ord).select\
    \ { |c| c.between?(97, 122) && c.odd? }.size\n  end\nend\nputs \"Problem 8:\"\n\
    puts split_words(\"Hello world!\")\nputs split_words(\"Hello,world!\")\nputs split_words(\"\
    abcdef\")", "\tif txt.split.length > 1\n\t\treturn txt.split\n\telsif txt.include?\
    \ \",\"\n\t\treturn txt.split(\",\")\n\telse\n\t\todd_arr = []\n\t\t(97..122).each\
    \ do |letter|\n\t\t\tif txt.count(letter.chr) % 2 != 0\n\t\t\t\todd_arr << letter.chr\n\
    \t\t\tend\n\t\tend\n\t\treturn odd_arr.length\n\tend\nend", "    # split on whitespace\
    \ if possible\n    # split on comma if possible\n    # return number of lower-case\
    \ letters with odd order in the alphabet", "  return txt.split(' ') if txt.split('\
    \ ').size > 1\n  return txt.split(',') if txt.split(',').size > 1\n  odd_lowers\
    \ = ('a'..'z').select.with_index { |e, i| i.odd? }\n  txt.count { |letter| odd_lowers.include?(letter)\
    \ }\nend", "  if txt.include?(\" \")\n    txt.split(\" \")\n  elsif txt.include?(\"\
    ,\")\n    txt.split(\",\")\n  else\n    arr = (\"a\"..\"z\").to_a\n    letters\
    \ = txt.split(\"\")\n    count = 0\n    letters.each do |letter|\n      count\
    \ += 1 if arr.index(letter).odd?\n    end\n    count\n  end\nend", "  arr = txt.split\n\
    \  return arr if arr.size > 1\n  arr = txt.split(',')\n  return arr if arr.size\
    \ > 1\n  count = 0\n  txt.downcase.each_char { |c| count += 1 if c.ord.odd? }\n\
    \  count\nend", "  if txt =~ /\\s/\n    txt.split(\" \")\n  elsif txt =~ /,/\n\
    \    txt.split(\",\")\n  else\n    (0..txt.length-1).to_a.select{|i| i.odd? &&\
    \ txt[i] == txt[i].downcase}.count\n  end\nend\nputs split_words(\"abcdef\")\n\
    puts split_words(\"Hello,world!\")\nputs split_words(\"Hello world!\")", "\treturn\
    \ txt.split(\" \") if txt.index(\" \")\n\treturn txt.split(\",\") if txt.index(\"\
    ,\")\n\treturn 'Odd letters: ' + (txt.count(\"a-z\") % 2).to_s\nend", "    letters\
    \ = txt.downcase.split('')\n    letters.map!.with_index { |e, i| if i.odd? &&\
    \ e.ord.between?(0, 25) then e end }\n    letters.compact!\n    letters.count\
    \ > 0 ? letters.count : txt.split(/[\\s,]/).reject(&:empty?)\nend", "  if txt.include?(\"\
    \ \")\n    txt.split(\" \")\n  elsif txt.include?(\",\")\n    txt.split(\",\"\
    )\n  else\n    txt.count { |i| ('a'..'z').to_a.index(i).odd? }\n  end\nend", " \
    \ if txt.include? \" \"\n    return txt.split(' ')\n  elsif txt.include? \",\"\
    \n    return txt.split(',')\n  else\n    if txt.length % 2 == 0\n      return\
    \ 0\n    else\n      return 1\n    end\n  end\nend", "    x = 0\n    split_txt\
    \ = txt.split(/[,\\s]/)\n    if split_txt.length > 1\n        split_txt\n    else\n\
    \        for i in 0..txt.length-1\n            if txt[i].ord % 2 == 1\n      \
    \          x = x + 1\n            end\n        end\n        x\n    end\nend",
  "  txt.split(/[\\s,]/).reject { |e| e.empty? } unless txt.empty?\nend", "  return\
    \ txt.split(\" \") if txt.include?(\" \")\n  return txt.split(\",\") if txt.include?(\"\
    ,\")\n  count = 0\n  txt.each_char { |c| count += 1 if (c.ord-97).odd? }\n  count\n\
    end", "\ttxt.split.length == 1 ? txt.count('a-z') : txt.split(/[,\\s]/)\nend\n\
    puts \"No.2\"\np split_words(\"Hello world!\") #\u279E [\"Hello\", \"world!\"\
    ]\np split_words(\"Hello,world!\") #\u279E [\"Hello\", \"world!\"]\np split_words(\"\
    abcdef\") == 3\nputs \"____________________\"", "\treturn txt.split() if txt.include?('\
    \ ')\n\treturn txt.split(',') if txt.include?(',')\n\ttxt.chars.map{|c| c.ord\
    \ - 96 if c =~ /[a-z]/}.select{|x| x % 2 == 1}.size\nend", "  txt.split(/\\s+/).empty?\
    \ ? txt.split(',').empty? ? txt.chars.select.with_index { |_, i| i.odd? }.size\
    \ : txt.split(',') : txt.split(/\\s+/)\nend", "  #...\nend", "  if txt.include?\
    \ \" \"\n    txt.split(' ')\n  elsif txt.include? \",\"\n    txt.split(',')\n\
    \  else\n    i = 0\n    odd = 0\n    while i < txt.length\n      if txt[i].ord.odd?\n\
    \        odd += 1\n      end\n      i += 1\n    end\n    odd\n  end\nend", " \
    \  if txt.include?(\" \")\n    txt.split(\" \")\n   elsif txt.include?(\",\")\n\
    \    txt.split(\",\")\n   else\n   end\n end\n p split_words(\"Hello world!\")",
  "  if txt.include?(\" \")\n    arr_txt = txt.split(\" \")\n    return arr_txt\n\
    \  elsif txt.include?(\",\")\n    arr_txt = txt.split(\",\")\n    return arr_txt\n\
    \  else\n    alphabet = (\"a\"..\"z\").to_a\n    arr_new = alphabet.select.with_index{|_,i|\
    \ i.odd?}\n    arr_txt = txt.chars\n    arr_txt.select{|item| arr_new.include?(item)}\n\
    \  end\nend", "  if txt.include?(\" \")\n    txt.split(\" \")\n  elsif txt.include?(\"\
    ,\")\n    txt.split(\",\")\n  else\n    txt.chars.select.with_index{|char, index|\
    \ (index.odd? && char == char.downcase)}.length\n  end\nend", "\tif txt.match?(\"\
    \ \")\n\t\ttxt.split(\" \")\n\telsif txt.match?(\",\")\n\t\ttxt.split(\",\")\n\
    \telse\n\t\tlen = txt.length\n\t\tcount = 0\n\t\tfor i in (0..len-1)\n\t\t\tif\
    \ i%2 != 0 && txt[i].match?(/[a-z]/)\n\t\t\t\tcount = count + 1\n\t\t\tend\n\t\
    \tend\n\t\tcount\n\tend\nend", "  arr = []\n  if txt.include?(' ')\n    arr =\
    \ txt.split(' ')\n  elsif txt.include?(',')\n    arr = txt.split(',')\n  else\n\
    \    arr = txt.count('abcdefghijklmnopqrstuvwxyz'.chars.select{|i| txt.count(i).odd?})\n\
    \  end\n  arr\nend", "    if txt.include? \" \"\n        return txt.split\n  \
    \  elsif txt.include? \",\"\n        return txt.split(\",\")\n    else\n     \
    \   return txt.count \"a\"..\"z\"\n    end\nend", "  if txt.include?(\" \")\n\
    \    txt.split(\" \")\n  elsif txt.include?(\",\")\n    txt.split(\",\")\n  else\n\
    \    count = 0\n    alphabet = ('a'..'z').to_a\n    chars = txt.chars\n    chars.each\
    \ do |char|\n      if alphabet.index(char).odd?\n        count += 1\n      end\n\
    \    end\n    count\n  end\nend", "  txt.gsub(/[,!]/, \" \").split\nend", "  #\
    \ your code here\nend", "    if txt.include? \" \"\n        return txt.split(\"\
    \ \")\n    elsif txt.include? \",\"\n        return txt.split(\",\")\n    else\n\
    \        count = 0\n        for i in 0..25\n            if i % 2 == 1\n      \
    \          if txt.include? i.chr\n                    count += 1\n           \
    \     end\n            end\n        end\n        return count\n    end\nend",
  "  return txt.split(\" \") if txt.include?(\" \")\n  return txt.split(\",\") if\
    \ txt.include?(\",\")\n  counter = 0\n  txt.split(\"\").each_with_index do |letter,\
    \ i|\n    counter += 1 if txt.split(\"\").index(letter).odd? && i.odd?\n  end\n\
    \  counter\nend\np split_words(\"abcdef\")", "  if txt.include? \" \"\n    return\
    \ txt.split(\" \")\n  elsif txt.include? \",\"\n    return txt.split(\",\")\n\
    \  else\n    txt = txt.downcase\n    count = 0\n    txt.each_char do |c|\n   \
    \   if txt.index(c).odd?\n        count += 1\n      end\n    end\n    return count\n\
    \  end\nend", "    txt.split(/[, ]+/).reject(&:empty?)\nend", "  return txt.split('\
    \ ') if txt.include?(' ')\n  return txt.split(',') if txt.include?(',')\n  return\
    \ txt.chars.count { |c| c.downcase.ord.odd? }\nend", "  if txt.include?(\" \"\
    )\n    return txt.split\n  elsif txt.include?(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    count = 0\n    txt.each_char do |char|\n      if (char.ord -\
    \ 97).odd?\n        count += 1\n      end\n    end\n    return count\n  end\n\
    end", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n\
    \    txt.split(',')\n  else\n    a = ('a'..'z').to_a\n    odd = []\n    i = 0\n\
    \    txt.each_char do |c|\n      if i.odd?\n        odd << c\n      end\n    \
    \  i += 1\n    end\n    odd.length\n  end\nend", "  return txt.split(/[\\s,]/)\
    \ if txt.match(/[\\s,]/)\n  return txt.downcase.count('a-z').odd? if txt.match(/[a-z]/)\n\
    end", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif txt.include?(',')\n\
    \    txt.split(',')\n  else\n    txt.chars.select { |char| char.ord.between?(ord('a'),\
    \ ord('z')) && char.ord.odd? }.count\n  end\nend", "  if txt.include?(\" \")\n\
    \    return txt.split(\" \")\n  elsif txt.include?(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    return txt.downcase.count(\"acegikmoqsuwy\")\n  end\nend", " \
    \ txt.count(' ') > 0 ? txt.split(' ') : (txt.count(',') > 0 ? txt.split(',') :\
    \ txt.count('abcdefghijklmnopqrstuvwxyz'.chars.select { |e| txt.count(e).odd?\
    \ }))\nend", "  if txt.include? \" \"\n    txt.split(\" \")\n  elsif txt.include?\
    \ \",\"\n    txt.split(\",\")\n  else\n    txt.split(\"\").count {|i| i.ord%2\
    \ == 1}\n  end\nend\nputs split_words(\"abcdef\")", "  if txt.include?(\" \")\n\
    \    return txt.split(\" \")\n  elsif txt.include?(\",\")\n    return txt.split(\"\
    ,\")\n  else\n    a = 0\n    (\"a\"..\"z\").each_with_index do |i, index|\n  \
    \    if index.odd?\n        a += txt.count(i)\n      end\n    end\n    return\
    \ a\n  end\nend\nputs split_words(\"Hello world!\")\nputs split_words(\"Hello,world!\"\
    )\nputs split_words(\"abcdef\")\nputs split_words(\"def\")\nputs split_words(\"\
    Hello world!Hello,world!\")", "  if txt.include?(' ')\n    txt.split(' ')\n  elsif\
    \ txt.include?(',')\n    txt.split(',')\n  else\n    txt.chars.select { |ch| ch.ord.odd?\
    \ }.count\n  end\nend", "  txt = txt.split(\" \") if txt.include?(\" \")\n  txt\
    \ = txt.split(\",\") if txt.include?(\",\")\n  txt = txt.split(\"\") if txt.size\
    \ == 1\n  txt.size\nend", "  txt.split(/[\\s,]/) == 1 ? txt.chars.find_all { |c|\
    \ txt.chars.index(c).odd? && c.downcase == c }.size : txt.split(/[\\s,]/)\nend\n\
    p split_words(\"Hello world!\") # \u279E [\"Hello\", \"world!\"]\np split_words(\"\
    Hello,world!\") # \u279E [\"Hello\", \"world!\"]\np split_words(\"abcdef\") #\
    \ == 3\np split_words(\"\") # == 0\np split_words(\"Fe, fi, fo, fum, I smell a,\
    \ rat.\") # == 6\np split_words(\"If Peter Piper picked a peck of pickled peppers,\\\
    nwhere's the peck of pickled peppers Peter Piper picked?\") # == 6\np split_words(\"\
    How much wood could a woodchuck chuck, if a woodchuck could chuck wood?\") # ==\
    \ 7\np split_words(\"On a dark desert highway, cool wind in my hair\\nWarm smell\
    \ of colitas, rising up through the air\\nUp ahead in the distance, I saw a shimmering\
    \ light\\nMy head grew heavy and my sight grew dim\\nI had to stop for the night\"\
    ) # == 4\np split_words(\"It's not easy being green, having to spend each day\
    \ the color of the leaves\\nWhen I think it could be nicer being red, or yellow\
    \ or gold\\nOr something much more colorful like that\") # == 5\np split_words(\"\
    When she was just a girl, she expected the world\\nBut it flew away from her reach,\
    \ so she ran away in her sleep\\nAnd dreamed of para-para-paradise, para-para-paradise,\
    \ para-para-paradise\\nEvery time she closed her eyes\") # == 6\np split_words(\"\
    Papa-Papa-Paparazzi\") # == 3\np split_words(\"Bada-ba-ba-ba, I'm lovin' it, bada-ba-ba-ba,\
    \ I'm lovin' it\") # == 5\np split_words(\"Yesterday, all my troubles seemed so\
    \ far away\\nNow it looks as though they're here to stay\\nOh", "    if txt.include?(\"\
    \ \")\n        return txt.split(\" \")\n    elsif txt.include?(\",\")\n      \
    \  return txt.split(\",\")\n    else\n        i = 0\n        odd_letters = 0\n\
    \        while i < txt.length\n            if txt[i].ord % 2 == 1\n          \
    \      odd_letters += 1\n            end\n            i += 1\n        end\n  \
    \      return odd_letters\n    end\nend", "  # TODO: implement\nend", "  puts\
    \ txt\n  puts \"Number of words \" + txt.split.size.to_s\n  words = txt.split\n\
    \  words.each { |word|\n    print word\n    print \" \"\n  }\n  puts\n  puts \"\
    Number of words after split: \" + words.size.to_s\n  puts \"Number of commas:\
    \ \" + txt.count(',').to_s\n  count = 0\n  txt.each_char { |ch|\n    if (ch.ord\
    \ >= 'a'.ord) && (ch.ord <= 'z'.ord)\n      if (ch.ord - 'a'.ord) % 2 == 1\n \
    \       count += 1\n      end\n    end\n  }\n  puts \"Number of odd characters:\
    \ \" + count.to_s\nend", "  if txt =~ /\\s/\n    txt.split(' ')\n  elsif txt =~\
    \ /,/\n    txt.split(',')\n  else\n    count = 0\n    txt.downcase.each_char {\
    \ |c| count += 1 if c.ord.odd? }\n    count\n  end\nend", "  if txt =~ /\\s/\n\
    \    txt.split(/\\s/)\n  elsif txt =~ /,/\n    txt.split(/,/)\n  else\n    txt.chars.select\
    \ { |ch| ch == ch.downcase && ch.ord.odd? }.size\n  end\nend", "  if txt.match(/\\\
    s/) != nil\n    return txt.split(/\\s/)\n  elsif txt.match(/,/) != nil\n    return\
    \ txt.split(',')\n  else\n    counter = 0\n    txt.each_char { |ch| counter +=\
    \ 1 if ch.ord.odd? }\n    return counter\n  end\nend", "\ttxt.split(/\\s+|,+/).uniq.sort\n\
    end\np split_words(\"Hello world!\") \np split_words(\"Hello,world!\") \np split_words(\"\
    abcdef\") ", "  if txt.include? \" \"\n    return txt.split(\" \")\n  elsif txt.include?\
    \ \",\"\n    return txt.split(\",\")\n  else\n    return txt.length\n  end\nend",
  "    txt.split(/,| /).reject(&:empty?)\nend", "  return txt.split() if txt.include?\
    \ \" \"\n  return txt.split(\",\") if txt.include? \",\"\n  txt.count(txt.gsub(/[^a-z]/,\
    \ '').downcase.chars.select.with_index { |e, i| i.odd? }.join)\nend", "  txt.match?(/\\\
    s/) ? txt.split(/\\s/) : txt.match?(/,/) ? txt.split(',') : txt.match?(/[a-z]/)\
    \ ? txt.count('a-z').odd? ? 1 : 0 : 0\nend", "  if txt.include?(' ')\n    txt.split('\
    \ ')\n  elsif txt.include?(',')\n    txt.split(',')\n  else\n    counter = 0\n\
    \    txt.each_char do |char|\n      counter += 1 if (char.ord - 97).odd?\n   \
    \ end\n    counter\n  end\nend", "  if txt.include? \" \"\n    txt.split\n  elsif\
    \ txt.include? \",\"\n    txt.split(\",\")\n  else\n    txt.count {|letter| letter\
    \ =~ /[a-z]/ && ('a'..'z').to_a.index(letter).odd?}\n  end\nend", "  return txt.split(/[,\\\
    s]/) if txt.count(' ') > 0\n  return txt.split(/[,\\s]/) if txt.count(',') > 0\n\
    \  txt.downcase.each_char.count { |ch| ch.ord.odd? }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
