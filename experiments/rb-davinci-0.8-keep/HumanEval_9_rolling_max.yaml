name: HumanEval_9_rolling_max
language: rb
prompt: "# From a given list of integers, generate a list of rolling maximum element\
  \ found until given moment\n# in the sequence.\n# >>> rolling_max([1, 2, 3, 2, 3,\
  \ 4, 2])\n# [1, 2, 3, 3, 3, 4, 4]\ndef rolling_max(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rolling_max\n\
  \    candidate = method(:rolling_max)\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([1, 2, 3, 4], candidate.call([1, 2, 3, 4]))\n    assert_equal([4,\
  \ 4, 4, 4], candidate.call([4, 3, 2, 1]))\n    assert_equal([3, 3, 3, 100, 100],\
  \ candidate.call([3, 2, 3, 100, 3]))\n  end\nend\n"
completions: ["  result = []\n  rolling_max = 0\n  numbers.each do |n|\n    rolling_max\
    \ = n if n > rolling_max\n    result << rolling_max\n  end\n  result\nend", " \
    \ max = []\n  j = 0\n  i = 0\n  while i < numbers.length\n    if numbers[i] >\
    \ numbers[j]\n      max << numbers[i]\n      j = i\n    else\n      max << numbers[j]\n\
    \    end\n    i += 1\n  end\n  max\nend", "  maximum = nil\n  numbers.map do |number|\n\
    \    maximum = number unless maximum\n    maximum = number if number > maximum\n\
    \    maximum\n  end\nend", "  max_list = []\n  max = nil\n  numbers.each do |n|\n\
    \    max = max.nil? ? n : max\n    max = n if n > max\n    max_list << max\n \
    \ end\n  max_list\nend", "  result = []\n  i = 0\n  while i < numbers.length\n\
    \    result << numbers[0..i].max\n    i += 1\n  end\n  result\nend", "  numbers.map.with_index\
    \ do |number, index|\n    numbers[0..index].max\n  end\nend", "  numbers.each_with_index.map\
    \ do |_, i|\n    numbers[0..i].max\n  end\nend", "  maximum = numbers.first\n\
    \  numbers.map do |n|\n    maximum = n if n > maximum\n    maximum\n  end\nend",
  "    numbers.each_index.with_object([]) do |i, result|\n        numbers[0..i].max\n\
    \    end\nend", "    max_list = []\n    for i in 0..numbers.length - 1\n     \
    \   max_list << numbers[0..i].max\n    end\n    max_list\nend", "  max_queue =\
    \ []\n  max_list = []\n  numbers.each do |number|\n    max_queue.push(number)\n\
    \    max_queue.shift if max_queue.size > 2\n    max_list.push(max_queue.max)\n\
    \  end\n  max_list\nend", "  result = []\n  max = 0\n  numbers.each do |number|\n\
    \    if number > max\n      max = number\n    end\n    result << max\n  end\n\
    \  result\nend", "  # TODO: implement it\nend", "  numbers.each_with_index.map\
    \ do |number, index|\n    numbers[0..index].max\n  end\nend", "  numbers.map.with_index\
    \ do |n, i|\n    numbers[0..i].max\n  end\nend", "  # Find the maximum ending\
    \ at position i.\n  # There are two possibilities:\n  # 1. The previous maximum\
    \ sequence ended at position i-1 plus the current element\n  # 2. The maximum\
    \ ending at position i is the current element.\n  maxes = [numbers[0]]\n  for\
    \ i in 1..numbers.length-1\n    # Find the maximum ending at position i.\n   \
    \ maxes[i] = [maxes[i-1], numbers[i]].max\n  end\n  return maxes\nend", "  ret\
    \ = []\n  last_max = 0\n  numbers.each { |n| last_max = ret << (n > last_max ?\
    \ n : last_max) }\n  ret\nend", "    max_until_now = []\n    numbers.each do |n|\n\
    \        max_until_now << (max_until_now.empty? ? n : [max_until_now.last, n].max)\n\
    \    end\n    max_until_now\nend", "  numbers.map.with_index do |number, index|\n\
    \    numbers[0..index].max\n  end\nend", "  numbers.each_with_index.map { |n,\
    \ i| numbers[0..i].max }\nend", "  max = nil\n  numbers.each_with_object([]) do\
    \ |number, result|\n    max = number if max.nil? || number > max\n    result <<\
    \ max\n  end\nend", "  numbers.each_index.map do |i|\n    numbers[0..i].max\n\
    \  end\nend", "  numbers.map.with_index { |_n, index| numbers[0..index].max }\n\
    end", "  numbers.map.with_index { |n, i| numbers[0..i].max }\nend", "    numbers.each_index.map\
    \ { |i| numbers[0..i].max }\nend", "  (0...numbers.length).map do |i|\n    numbers[0..i].max\n\
    \  end\nend", "  numbers.reduce([]) do |acc, n|\n    acc << acc.last.to_i.succ\n\
    \    acc\n  end\nend", "  result = []\n  numbers.each_with_index do |current_number,\
    \ i|\n    result[i] = numbers[0..i].max\n  end\n  result\nend", "  rolling_max\
    \ = []\n  maximum = numbers[0]\n  numbers.each do |num|\n    if num > maximum\n\
    \      maximum = num\n    end\n    rolling_max << maximum\n  end\n  rolling_max\n\
    end", "\t# create a variable that will hold the maximum value\n\t# and an empty\
    \ array to hold the values\n\tmax = 0\n\tmax_values = []\n\tnumbers.each do |number|\n\
    \t\tif number > max\n\t\t\tmax = number\n\t\tend\n\t\tmax_values << max\n\tend\n\
    \tmax_values\nend", "  # TODO: your code goes here\nend", "  (1..numbers.size).map\
    \ do |i|\n    numbers[0..i-1].max\n  end\nend", "  max = []\n  numbers.each do\
    \ |n|\n    max << [n, max.last].compact.max\n  end\n  max\nend", "  result = []\n\
    \  max = numbers[0]\n  numbers.each do |number|\n    if number > max\n      max\
    \ = number\n    end\n    result << max\n  end\n  result\nend", "  numbers.each_with_index.map\
    \ do |n, i|\n    i == 0 ? n : [n, numbers[0..i-1].max].max\n  end\nend", "  numbers.each_index.map\
    \ do |i|\n    numbers[0..i].max\n  end\nend", "  # >>> rolling_max([1, 2, 3, 2,\
    \ 3, 4, 2])\n  # [1, 2, 3, 3, 3, 4, 4]\n  # Length is 7\n  # Max is 3", "  numbers.each_with_index.map\
    \ { |_, i| numbers[0..i].max }\nend", "  if numbers.empty?\n    raise RuntimeError,\
    \ 'Empty list!'\n  end", "  result = []\n  numbers.each_with_index do |number,\
    \ index|\n    if index == 0\n      result << number\n    else\n      max = result[index\
    \ - 1]\n      if number > max\n        result << number\n      else\n        result\
    \ << max\n      end\n    end\n  end\n  result\nend", "  result = []\n  current_max\
    \ = numbers[0]\n  result.push(current_max)\n  numbers[1..-1].each do |num|\n \
    \   if num > current_max\n      current_max = num\n    end\n    result.push(current_max)\n\
    \  end\n  result\nend", "  numbers.each_with_index.map { |n, i| numbers[0...i].max\
    \ || n }\nend", "  numbers.reduce([]) do |acc, num|\n    acc << [num, acc.last\
    \ || 0].max\n  end\nend", "  (1..numbers.size).map { |i| numbers[0..i-1].max }\n\
    end", "  numbers.each_with_index.map do |number, index|\n    index == 0 ? number\
    \ : [number, *numbers[0..index]].max\n  end\nend", "  numbers.map.with_index do\
    \ |number, index|\n    max = number\n    i = 0\n    while i <= index\n      max\
    \ = number if number > max\n      i += 1\n    end\n    max\n  end\nend", "  #\
    \ https://stackoverflow.com/questions/1100613/fastest-way-to-calculate-rolling-maximum\n\
    \  # https://stackoverflow.com/questions/17762667/ruby-implementing-a-rolling-window-on-an-array\n\
    \  maxes = []\n  current_max = numbers[0]\n  maxes << current_max\n  (1...numbers.length).each\
    \ do |i|\n    current_max = [current_max, numbers[i]].max\n    maxes << current_max\n\
    \  end\n  maxes\nend", "  max_elements = []\n  numbers.each_with_index do |number,\
    \ index|\n    if index == 0\n      max_elements << number\n    else\n      max_elements\
    \ << number if number > max_elements[index - 1]\n      max_elements << max_elements[index\
    \ - 1] if number <= max_elements[index - 1]\n    end\n  end\n  max_elements\n\
    end", "  numbers.each_with_index.map do |_, index|\n    numbers[0..index].max\n\
    \  end\nend", "  # TODO: implement!\nend", "  result = []\n  numbers.each_with_index\
    \ do |current_number, i|\n    until i == 0\n      prev_number = numbers[i - 1]\n\
    \      i -= 1\n      if current_number < prev_number\n        result << prev_number\n\
    \        break\n      end\n    end\n    result << current_number if i == 0\n \
    \ end\n  result\nend", "  numbers.map.with_index do |_, i|\n    numbers[0..i].max\n\
    \  end\nend", "  numbers.map.with_index do |n, i|\n    numbers[0..i].max\n  end\n\
    end", "  results = []\n  max = numbers[0]\n  numbers.each do |number|\n    if\
    \ number > max\n      max = number\n    end\n    results << max\n  end\n  results\n\
    end", "  numbers.map.with_index do |n, i|\n    numbers[0..i].max\n  end\nend",
  "  # TODO\nend", "    # TODO: YOUR CODE HERE\nend", "  result = []\n  max = 0\n\
    \  numbers.each do |num|\n    if num > max\n      max = num\n    end\n    result\
    \ << max\n  end\n  result\nend", "  # use scan to accumulate the result\n  numbers.scan(numbers.first)\
    \ do |max, num|\n    max > num ? max : num\n  end\nend", "  max_arr = []\n  max\
    \ = nil\n  numbers.each_with_index do |num, index|\n    if max.nil? || max < num\n\
    \      max = num\n    end\n    max_arr[index] = max\n  end\n  max_arr\nend", " \
    \ result = []\n  max = nil\n  numbers.each do |n|\n    max = n if max.nil? ||\
    \ n > max\n    result << max\n  end\n  result\nend", "    result = []\n    current_max\
    \ = numbers[0]\n    result << current_max\n    numbers[1..-1].each do |el|\n \
    \       if el > current_max\n            current_max = el\n        end\n     \
    \   result << current_max\n    end\n    result\nend", "  result = []\n  max =\
    \ 0\n  numbers.each do |num|\n    max = num if num > max\n    result << max\n\
    \  end\n  result\nend", "    result = []\n    max = numbers[0]\n    numbers.each\
    \ do |n|\n        if n > max\n            max = n\n        end\n        result\
    \ << max\n    end\n    result\nend", "  numbers.each_with_index.map do |number,\
    \ index|\n    numbers[0..index].max\n  end\nend", "  max_numbers = []\n  max_number\
    \ = 0\n  numbers.each do |number|\n    max_number = [max_number, number].max\n\
    \    max_numbers << max_number\n  end\n  max_numbers\nend", "  i = 0\n  max =\
    \ []\n  until i == numbers.size\n    max << numbers[0..i].max\n    i += 1\n  end\n\
    \  max\nend", "  (1..numbers.length).map { |i| numbers[0..i].max }\nend", "  rmax\
    \ = []\n  (0..numbers.length-1).each do |index|\n    rmax << numbers[0..index].max\n\
    \  end\n  rmax\nend", "  ret = []\n  for i in 0..numbers.length-1\n    ret <<\
    \ numbers[0..i].max\n  end\n  ret\nend", "  max = nil\n  numbers.map { |n| max\
    \ = [max, n].compact.max }\nend", "  result = []\n  if numbers.length >= 1\n \
    \   max = numbers[0]\n    result << max\n    numbers[1..-1].each do |number|\n\
    \      max = [max, number].max\n      result << max\n    end\n  end\n  result\n\
    end", "  results = [numbers.first]\n  numbers[1..-1].each do |number|\n    max\
    \ = [number, results.last].max\n    results << max\n  end\n  results\nend", " \
    \ numbers.map.with_index do |_, index|\n    max = 0\n    (0..index).each do |i|\n\
    \      max = numbers[i] if numbers[i] > max\n    end\n    max\n  end\nend", " \
    \ max_so_far = 0\n  rolling_max = []\n  numbers.each do |num|\n    max_so_far\
    \ = [max_so_far, num].max\n    rolling_max << max_so_far\n  end\n  rolling_max\n\
    end", "  max_numbers = []\n  max_numbers << numbers[0]\n  numbers[1..-1].each\
    \ do |number|\n    max_numbers << [max_numbers.last, number].max\n  end\n  max_numbers\n\
    end", "  prev_max = nil\n  numbers.map do |n|\n    if prev_max.nil? || n > prev_max\n\
    \      prev_max = n\n    else\n      prev_max\n    end\n  end\nend", "    result\
    \ = []\n    for i in 0..numbers.length-1\n        result << numbers[0..i].max\n\
    \    end\n    result\nend", "  max = numbers.first\n  rolling_max = []\n  numbers.each\
    \ do |n|\n    if n > max\n      max = n\n    end\n    rolling_max << max\n  end\n\
    \  rolling_max\nend", "\t# Just a fancy way to create a list of zeros\n\tmaximums\
    \ = Array.new(numbers.size, 0)\n\tmaximums[0] = numbers[0]\n\tfor i in (1..numbers.size-1)\n\
    \t\tmaximums[i] = [maximums[i-1], numbers[i]].max\n\tend\n\treturn maximums\n\
    end", "  max_elements = []\n  current_max = 0\n  numbers.each do |element|\n \
    \   current_max = element if element > current_max\n    max_elements << current_max\n\
    \  end\n  max_elements\nend", "  result = []\n  current_max = 0\n  numbers.each\
    \ do |number|\n    current_max = number if number > current_max\n    result <<\
    \ current_max\n  end\n  result\nend", "  max_so_far = numbers.first\n  max_so_far,\
    \ *numbers = numbers\n  numbers.map do |n|\n    max_so_far = n if n > max_so_far\n\
    \    max_so_far\n  end\nend", "  # We have a list of numbers and we want to generate\
    \ a list of rolling maximum element found until given moment in the sequence.\n\
    \  # We need to generate an output list with the same number of elements as the\
    \ input list (i.e. map)\n  # We can get the maximum by using the max function.\n\
    \  # max function takes a list and returns the maximum element.\n  # max function\
    \ takes a block and returns the maximum element of the list relative to the given\
    \ block.\n  # In this case, we do not care for the current element, we just want\
    \ to compare with the previous maximum.\n  # Therefore, we can use inject function\
    \ to build the current maximum and return it.\n  # inject function takes an initial\
    \ value and a block.\n  # inject function returns a single value by applying the\
    \ given block.\n  # inject function applies the given block to the given initial\
    \ value and the first element of the list.\n  # inject function applies the given\
    \ block to the previous result and the next element of the list.\n  # In this\
    \ case, we will use the first element of the list as the initial value of the\
    \ max_value.\n  # The block will return a new max_value by comparing the current\
    \ value with the previous max_value.\n  # Therefore, the block will return a new\
    \ max_value by using the max function.\n  # The inject function will return the\
    \ final max_value.\n  # Therefore, our map function will return a list of maximum\
    \ values with the same size as the input list.\n  numbers.map do |number|\n  \
    \  # The first max_value is the first element of the list.\n    # We can use the\
    \ first element of the list to assign a default max_value.\n    max_value = number\n\
    \    # The input list will be the list of elements of the input list except the\
    \ first element.\n    # This is to avoid getting the initial max_value in the\
    \ list.\n    # map function will return a list of maximum elements found until\
    \ given moment in the sequence.\n    # This list will have the same size as the\
    \ input list.\n    # The first element of the list will be the first element of\
    \ the input list (i.e. max_value).\n    numbers.drop(1).inject(max_value) do |max_value,\
    \ value|\n      # max function takes two elements", "  result = []\n  numbers.each_with_index\
    \ do |value, i|\n    i > 0 ? result << [value, result[i - 1]].max : result <<\
    \ value\n  end\n  result\nend", "  i = 0\n  rolling_max = []\n  maximum = 0\n\
    \  while i < numbers.length\n    if numbers[i] > maximum\n      maximum = numbers[i]\n\
    \    end\n    rolling_max.push(maximum)\n    i += 1\n  end\n  return rolling_max\n\
    end", "\ti = 0\n\tj = 1\n\tarr1 = []\n\twhile i < numbers.length\n\t\tif numbers[i]\
    \ > numbers[j]\n\t\t\tarr1 << numbers[i]\n\t\t\ti += 1\n\t\t\tj += 1\n\t\telsif\
    \ numbers[i] < numbers[j]\n\t\t\tarr1 << numbers[j]\n\t\t\ti += 1\n\t\t\tj +=\
    \ 1\n\t\telse\n\t\t\tarr1 << numbers[i]\n\t\t\ti += 1\n\t\t\tj += 1\n\t\tend\n\
    \tend\n\tarr1\nend", "\tmax_number_list = []\n\tmax_number = 0\n\tnumbers.each\
    \ do |x|\n\t\tif x > max_number\n\t\t\tmax_number = x\n\t\tend\n\t\tmax_number_list\
    \ << max_number\n\tend\n\treturn max_number_list\nend", "  n = numbers.size\n\
    \  maximums = Array.new(n)\n  stack = []", "  result = []\n  for index in 0..numbers.length-1\n\
    \    temp = []\n    for i in 0..index\n      temp << numbers[i]\n    end\n   \
    \ result << temp.max\n  end\n  result\nend", "  result = [numbers.first]\n  (1...numbers.length).each\
    \ do |i|\n    result << [result.last, numbers[i]].max\n  end\n  result\nend",
  "  # For example, if I have [1, 2, 3, 2, 3, 4, 2],\n  # I will create a list of\
    \ all local maximums in the given array, that would be\n  # [1, 2, 3, 3, 4] (I\
    \ consider only first occurence of the local maximum, e.g.\n  # in this case,\
    \ 4 is local maximum at the end, but I take only first occurence\n  # of 4).\n\
    \  # Then, for each number in the given list, I will find a local maximum that\
    \ is\n  # closest to the left from this number.\n  local_maximums = Array.new\n\
    \  prev_number = numbers[0]\n  numbers.each_with_index do |number, index|\n  \
    \  if number > prev_number\n      local_maximums.push index\n    end\n    prev_number\
    \ = number\n  end", "  numbers.each_with_index.map { |_, i| numbers[0..i].max\
    \ }\nend", "  max = []\n  result = []\n  numbers.each do |x|\n    max << x\n \
    \   if max.max == x\n      result << x\n    else\n      result << max.max\n  \
    \  end\n  end\n  result\nend", "  numbers.each_with_index.with_object([]) do |(number,\
    \ index), acc|\n    acc << numbers[0..index].max\n  end\nend", "\tmaximums = [numbers[0]]\n\
    \tfor i in 1..numbers.length-1\n\t\tmaximums.push(numbers[i] > maximums[i-1] ?\
    \ numbers[i] : maximums[i-1])\n\tend\n\tmaximums\nend", "  maximum = []\n  tmp\
    \ = []\n  numbers.each do |n|\n    tmp << n\n    if tmp.max == n\n      maximum\
    \ << n\n    else\n      maximum << tmp.max\n    end\n  end\n  maximum\nend", " \
    \ rolling_maxes = [numbers.first]\n  (1...numbers.length).each do |i|\n    rolling_maxes\
    \ << [rolling_maxes.last, numbers[i]].max\n  end\n  rolling_maxes\nend", "   \
    \ numbers.map.with_index do |number, index|\n        number if index == 0\n  \
    \      numbers[0..index].max\n    end\nend", "  # Can't generate anything from\
    \ an empty list\n  return [] if numbers.empty?", "  numbers.each_with_index.map\
    \ { |_, i| numbers[0..i].max }\nend", "  numbers.each_with_index.map do |_, i|\n\
    \    numbers[0..i].max\n  end\nend", "  # since we are making use of the O(1)\
    \ time and space insertion\n  # and deletion from the left end of the array, we\
    \ can make\n  # sure that the first element of the max_indices array\n  # is always\
    \ the index of the max element in the numbers\n  # array. To achieve this, we\
    \ will store the index instead\n  # of the number in the max_indices array.\n\
    \  max_indices = []\n  max_index = 0\n  numbers.each_with_index do |num, index|\n\
    \    if num > numbers[max_index]\n      max_index = index\n    end\n    max_indices\
    \ << max_index\n  end\n  max_indices.map{|index| numbers[index]}\nend", "  result\
    \ = []\n  return result if numbers.nil? || numbers.empty?\n  current_max = numbers[0]\n\
    \  result.push(current_max)\n  numbers[1..-1].each do |number|\n    if number\
    \ > current_max\n      current_max = number\n    end\n    result.push(current_max)\n\
    \  end\n  result\nend", "  (1..numbers.length).map do |i|\n    numbers[0..i].max\n\
    \  end\nend", "  rolling_max_array = []\n  max_element = numbers[0]\n  for i in\
    \ numbers\n    if max_element < i\n      max_element = i\n    end\n    rolling_max_array.push(max_element)\n\
    \  end\n  rolling_max_array\nend", "  max_so_far = numbers.shift\n  numbers.map\
    \ do |value|\n    max_so_far = [max_so_far, value].max\n  end.unshift(max_so_far)\n\
    end", "  numbers.map.with_index do |num, i|\n    break if i == numbers.length\
    \ - 1\n    num > numbers[i + 1] ? num : numbers[i + 1]\n  end\nend", "  max =\
    \ numbers.first\n  numbers.map do |number|\n    max = [max, number].max\n  end\n\
    end", "  numbers.each_with_index.map do |number, index|\n    numbers[0..index].max\n\
    \  end\nend", "  accumulator = []\n  index = 0\n  while index < numbers.length\n\
    \    accumulator[index] = numbers[0..index].max\n    index += 1\n  end\n  accumulator\n\
    end", "  max_num = numbers[0]\n  numbers.map do |num|\n    if num > max_num\n\
    \      max_num = num\n    end\n    max_num\n  end\nend", "  max = numbers.first\n\
    \  numbers.map { |x| max = x if x > max; max }\nend", "  result = []\n  max =\
    \ 0\n  numbers.each do |num|\n    max = num if num > max\n    result << max\n\
    \  end\n  result\nend", "  #to store the max value\n  max_value = numbers[0]\n\
    \  # list to store rolling max elements\n  rolling_max_elements = []\n  #looping\
    \ through the list \n  numbers.each do |n|\n    # if max_value is greater than\
    \ n (element in the list)\n    if max_value > n\n      # append max_value to the\
    \ rolling_max_elements list\n      rolling_max_elements << max_value\n    else\n\
    \      # if n is greater than max_value, update max_value to n\n      max_value\
    \ = n\n      # append n to the rolling_max_elements list\n      rolling_max_elements\
    \ << n\n    end\n  end\n  #print the rolling_max_elements list\n  rolling_max_elements\n\
    end", "  result = []\n  max = numbers[0]\n  numbers.each do |number|\n    max\
    \ = [max, number].max\n    result << max\n  end\n  result\nend", "  numbers.map.with_index\
    \ do |num, idx|\n    numbers[0..idx].max\n  end\nend", "  max = []\n  max_so_far\
    \ = -Float::INFINITY\n  numbers.each do |n|\n    max_so_far = [max_so_far, n].max\n\
    \    max << max_so_far\n  end\n  max\nend", "  result = []\n  max = 0\n  numbers.each\
    \ do |x|\n    if x > max\n      max = x\n    end\n    result << max\n  end\n \
    \ result\nend", "  raise NotImplementedError\nend", "    rolling_max = []\n  \
    \  maximum = numbers[0]\n    numbers.each do |num|\n        maximum = [maximum,\
    \ num].max\n        rolling_max << maximum\n    end\n    rolling_max\nend", " \
    \ maximums = []\n  for idx in 0..numbers.length-1\n    maximums << numbers[0..idx].max\n\
    \  end\n  maximums\nend", "  numbers.length.times.map do |i|\n    numbers[0..i].max\n\
    \  end\nend", "  result = [numbers.first]\n  numbers[1..-1].each do |num|\n  \
    \  max = result.last\n    result << max > num ? max : num\n  end\n  result\nend",
  "  numbers.size.times.map do |i|\n    numbers[0..i].max\n  end\nend", "  result\
    \ = []\n  current_max = 0\n  numbers.each do |num|\n    current_max = [current_max,\
    \ num].max\n    result << current_max\n  end\n  result\nend", "    result = []\n\
    \    # Add first item to the results\n    result << numbers[0]\n    # For each\
    \ subsequent item\n    numbers[1..-1].each do |item|\n        # Check if the last\
    \ item in the result is less than the item\n        if result[-1] < item\n   \
    \         # Add the item to the result\n            result << item\n        else\n\
    \            # Otherwise add the last item in the result\n            result <<\
    \ result[-1]\n        end\n    end\n    result\nend", "  max_array = []\n  max\
    \ = 0\n  numbers.each do |n|\n    if n > max\n      max = n\n    end\n    max_array\
    \ << max\n  end\n  max_array\nend", "  numbers.each_with_index.map do |number,\
    \ index|\n    max = number\n    numbers[0..index].each do |number|\n      max\
    \ = number if number > max\n    end\n    max\n  end\nend", "  numbers.each_with_index.map\
    \ { |n, i| numbers[0..i].max }\nend", "  numbers.map.with_index { |number, index|\
    \ numbers[0..index].max }\nend", "  current_max = numbers.first\n  numbers.map\
    \ do |number|\n    current_max = number if number > current_max\n    current_max\n\
    \  end\nend", "  numbers.each_with_index.map do |current_number, index|\n    numbers[0..index].max\n\
    \  end\nend", "  numbers.map.with_index do |_, i|\n    numbers[0..i].max\n  end\n\
    end", "  numbers.reduce([]) do |rolling_max, number|\n    if rolling_max.empty?\n\
    \      rolling_max << number\n    else\n      rolling_max << [rolling_max.last,\
    \ number].max\n    end\n  end\nend", "  # YOUR CODE HERE\nend", "  result = []\n\
    \  max = numbers[0]\n  result << max\n  numbers[1..-1].each do |number|\n    if\
    \ number > max\n      max = number\n    end\n    result << max\n  end\n  result\n\
    end", "  # max = numbers.first\n  max = 0\n  numbers.map do |number|\n    max\
    \ = number if number > max\n    max\n  end\nend", "  maximums = []\n  maximum\
    \ = 0\n  numbers.each do |e|\n    maximum = e if e > maximum\n    maximums <<\
    \ maximum\n  end\n  maximums\nend", "  result = []\n  max = numbers[0]\n  numbers.each_with_index\
    \ do |number, index|\n    max = number if number > max\n    result[index] = max\n\
    \  end\n  result\nend", "  max = numbers.shift\n  result = [max]\n  for i in numbers\n\
    \    if i > max\n      max = i\n    end\n    result.push(max)\n  end\n  result\n\
    end", "  r = []\n  idx = 0\n  max = nil\n  while idx < numbers.size\n    if max.nil?\
    \ || numbers[idx] > max\n      max = numbers[idx]\n    end\n    r << max\n   \
    \ idx += 1\n  end\n  r\nend", "  i = 0\n  max = 0\n  array = []\n  while i < numbers.size\n\
    \    if numbers[i] > max\n      max = numbers[i]\n    end\n    array.push(max)\n\
    \    i += 1\n  end\n  return array\nend", "  numbers.each_with_index.map { |n,\
    \ i| numbers[0..i].max }\nend", "  output = []\n  max = 0\n  numbers.each do |number|\n\
    \    if number > max\n      max = number\n    end\n    output << max\n  end\n\
    \  return output\nend", "  result = []\n  max = numbers[0]\n  numbers.each do\
    \ |number|\n    max = [max, number].max\n    result << max\n  end\n  result\n\
    end", "  result = []\n  max = numbers[0]\n  numbers.each do |n|\n    max = n if\
    \ n > max\n    result << max\n  end\n  result\nend", "  rolling_max = []\n  max\
    \ = numbers[0]\n  numbers.each do |number|\n    max = number if number > max\n\
    \    rolling_max << max\n  end\n  rolling_max\nend", "  # check if numbers is\
    \ empty\n  return [] if numbers.empty?", "\tnumbers.each_index.map { |i| numbers[0..i].max\
    \ }\nend", "  maxes = []\n  max = nil\n  numbers.each do |n|\n    max = n if max.nil?\n\
    \    max = n if n > max\n    maxes << max\n  end\n  maxes\nend", "  max_list =\
    \ []\n  numbers.each_with_index do |number, index|\n    if index == 0\n      max_list\
    \ << number\n    else\n      if number > max_list[index - 1]\n        max_list\
    \ << number\n      else\n        max_list << max_list[index - 1]\n      end\n\
    \    end\n  end\n  max_list\nend", "\tnumbers.each_with_index.map { |v, i| numbers[0..i].max\
    \ }\nend", "  result = []\n  max = 0\n  numbers.each do |n|\n    if n > max\n\
    \      max = n\n    end\n    result << max\n  end\n  result\nend", "    max_array\
    \ = []\n    for i in (0..numbers.length-1)\n        max_array << numbers[0..i].max\n\
    \    end\n    max_array\nend", "  result = []\n  rolling_max = 0\n  numbers.each\
    \ do |number|\n    if number > rolling_max\n      rolling_max = number\n    end\n\
    \    result << rolling_max\n  end\n  result\nend", "  result = []\n  numbers.each\
    \ do |number|\n    result << result.last.to_i.max(number)\n  end\n  result\nend",
  "  max = 0\n  numbers.collect do |number|\n    if number > max\n      max = number\n\
    \    end\n    max\n  end\nend", "  # code here\nend", "  # This helper function\
    \ creates a list of rolling maximums\n  # It accepts 2 parameters\n  # 1. A list\
    \ of elements until given moment in the sequence\n  # 2. A new element to be added\
    \ to the list\n  # => a list of elements which contains a new element plus the\
    \ maximum element\n  #    compared to the new element in the provided list\n \
    \ def rolling_max_helper(seq, new_element)\n    # If the sequence is empty then\
    \ it means that the new element is the first\n    # element in the sequence and\
    \ it would be the maximum element as well.\n    return [new_element] if seq.empty?",
  "  # Your code here\nend", "  result = []\n  max = numbers[0]\n  numbers.each do\
    \ |element|\n    max = element if element > max\n    result << max\n  end\n  result\n\
    end", "  result = []\n  current_max = 0\n  numbers.each do |num|\n    if num >\
    \ current_max\n      current_max = num\n    end\n    result << current_max\n \
    \ end\n  result\nend", "  results = []\n  max = numbers[0]\n  results.push(max)\n\
    \  numbers.each do |n|\n    max = n if n > max\n    results.push(max)\n  end\n\
    \  results\nend", "  result = []\n  numbers.each_with_index do |num, index|\n\
    \    if index == 0\n      result << num\n    else\n      result << [num, result[index\
    \ - 1]].max\n    end\n  end\n  result\nend", "  result = []\n  max = 0\n  numbers.each\
    \ do |number|\n    if number > max\n      max = number\n    end\n    result <<\
    \ max\n  end\n  result\nend", "  # TODO\nend", end, "  result = []\n  max = numbers[0]\n\
    \  numbers.each do |number|\n    if number > max\n      max = number\n    end\n\
    \    result << max\n  end\n  result\nend", "  numbers.map.with_index do |item,\
    \ index|\n    numbers[0..index].max\n  end\nend", "  result = []\n  max = numbers[0]\n\
    \  numbers.each do |num|\n    max = num if num > max\n    result << max\n  end\n\
    \  result\nend", "  max = nil\n  numbers.map do |x|\n    max = x if max.nil? ||\
    \ x > max\n    max\n  end\nend", "  max = []\n  numbers.each do |i|\n    if max.empty?\n\
    \      max << i\n    else\n      max << [max.last, i].max\n    end\n  end\n  max\n\
    end", "  numbers.each_with_index.map do |number, index|\n    numbers[0..index].max\n\
    \  end\nend", "  result = []\n  # TODO: implement the algorithm\n  max = numbers[0]\n\
    \  numbers.each do |number|\n    if number > max\n      max = number\n    end\n\
    \    result << max\n  end\n  result\nend", "  maxes = []\n  current_max = 0\n\
    \  numbers.each do |current_number|\n    if current_number > current_max\n   \
    \   current_max = current_number\n    end\n    maxes << current_max\n  end\n \
    \ maxes\nend", "  max_list = []\n  max = 0\n  numbers.each do |number|\n    if\
    \ number > max\n      max = number\n    end\n    max_list << max\n  end\n  max_list\n\
    end", "  numbers.each_with_index.map do |_, index|\n    numbers[0..index].max\n\
    \  end\nend", "  maxes = []\n  max_current = numbers[0]\n  maxes.push(max_current)\n\
    \  numbers.each do |number|\n    max_current = [max_current, number].max\n   \
    \ maxes.push(max_current)\n  end\n  maxes.shift\n  maxes\nend", "  max_list =\
    \ []\n  max = numbers[0]\n  numbers.each do |number|\n    if number > max\n  \
    \    max = number\n    end\n    max_list << max\n  end\n  return max_list\nend",
  "  # Implement your algorithm here!\nend", "  maximum = numbers.first\n  numbers.map\
    \ { |n| (maximum = n if n > maximum) && maximum }\nend", "end\n```", "    result\
    \ = []\n    max = 0\n    numbers.each do |number|\n        if number > max\n \
    \           max = number\n        end\n        result << max\n    end\n    result\n\
    end", "  nums = numbers\n  numbers.each_with_index.map do |num, idx|\n    nums\
    \ = nums[1..-1]\n    nums.max if nums.max > num\n  end\nend", "  rolling_max_numbers\
    \ = []\n  numbers.each_with_index do |number, index|\n    rolling_max_numbers\
    \ << numbers[0...index].max\n  end\n  rolling_max_numbers\nend", "  raise NotImplementedError\n\
    end", "  max = numbers.first\n  numbers.each_with_object([]) do |number, res|\n\
    \    res << max\n    max = [max, number].max\n  end\nend", "    numbers.map.with_index\
    \ do |n, i|\n        numbers[0..i].max\n    end\nend", "  res = []\n  max = nil\n\
    \  numbers.each do |e|\n    if max == nil || e > max\n      max = e\n    end\n\
    \    res << max\n  end\n  res\nend", "  result = []\n  max = numbers[0]\n  numbers.each_with_index\
    \ do |number, index|\n    max = number if number > max\n    result << max\n  end\n\
    \  result\nend", "  max = numbers.first\n  numbers.each_with_object([]) do |value,\
    \ result|\n    max = max > value ? max : value\n    result << max\n  end\nend",
  "  result = []\n  max = numbers[0]\n  numbers.each_with_index do |e, index|\n  \
    \  if index == 0\n      result << e\n    else\n      max = [max, e].max\n    \
    \  result << max\n    end\n  end\n  result\nend", "  (0...numbers.size).map do\
    \ |i|\n    numbers[0..i].max\n  end\nend", "  max_list = []\n  max = numbers[0]\n\
    \  numbers.each do |number|\n    if number > max\n      max = number\n    end\n\
    \    max_list << max\n  end\n  max_list\nend", "  (1..numbers.size).map do |sub_list_size|\n\
    \    numbers.first(sub_list_size).max\n  end\nend", "  result = []\n  max = nil\n\
    \  numbers.each do |num|\n    max = num if max.nil? || num > max\n    result <<\
    \ max\n  end\n  result\nend", "  # TODO:\nend", "  #TODO\nend", "  numbers.map.with_index\
    \ do |_, i|\n    numbers[0..i].max\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
