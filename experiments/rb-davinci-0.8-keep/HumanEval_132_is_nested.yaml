name: HumanEval_132_is_nested
language: rb
prompt: "# Create a function that takes a string as input which contains only square\
  \ brackets.\n# The function should return True if and only if there is a valid subsequence\
  \ of brackets \n# where at least one bracket in the subsequence is nested.\n# is_nested('[[]]')\
  \ \u279E True\n# is_nested('[]]]]]]][[[[[]') \u279E False\n# is_nested('[][]') \u279E\
  \ False\n# is_nested('[]') \u279E False\n# is_nested('[[][]]') \u279E True\n# is_nested('[[]][[')\
  \ \u279E True\ndef is_nested(string)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_is_nested\n\
  \    candidate = method(:is_nested)\n    assert_equal(true, candidate.call(\"[[]]\"\
  ))\n    assert_equal(false, candidate.call(\"[]]]]]]][[[[[]\"))\n    assert_equal(false,\
  \ candidate.call(\"[][]\"))\n    assert_equal(false, candidate.call(\"[]\"))\n \
  \   assert_equal(true, candidate.call(\"[[[[]]]]\"))\n    assert_equal(false, candidate.call(\"\
  []]]]]]]]]]\"))\n    assert_equal(true, candidate.call(\"[][][[]]\"))\n    assert_equal(false,\
  \ candidate.call(\"[[]\"))\n    assert_equal(false, candidate.call(\"[]]\"))\n \
  \   assert_equal(true, candidate.call(\"[[]][[\"))\n    assert_equal(true, candidate.call(\"\
  [[][]]\"))\n    assert_equal(false, candidate.call(\"\"))\n    assert_equal(false,\
  \ candidate.call(\"[[[[[[[[\"))\n    assert_equal(false, candidate.call(\"]]]]]]]]\"\
  ))\n  end\nend\n"
completions: ["  string.count('[')==string.count(']') ? false : true\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "\tbrackets = 0\n\tnested\
    \ = false\n\tstring.split(\"\").each do |char|\n\t\tif char == \"[\"\n\t\t\tbrackets\
    \ += 1\n\t\t\tnested = true\n\t\telsif char == \"]\"\n\t\t\tbrackets -= 1\n\t\t\
    end\n\tend\n\treturn nested if brackets == 0\n\treturn false\nend", "    stack\
    \ = []\n    string.chars.each do |char|\n        if(stack.empty?)\n          \
    \  stack.push(char)\n        elsif(char == \"]\" && stack[-1] == \"[\")\n    \
    \        stack.pop\n        else\n            stack.push(char)\n        end\n\
    \    end\n    return true if(stack.empty?)\n    return false\nend\nputs(is_nested('[[]]'))\n\
    puts(is_nested('[]]]]]]][[[[[]'))\nputs(is_nested('[][]'))\nputs(is_nested('[]'))\n\
    puts(is_nested('[[][]]'))\nputs(is_nested('[[]][['))", "\tstring.include?(\"[]\"\
    )\nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\n\
    p is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')", "  string =\
    \ string.chars.select { |char| ['[', ']'].include?(char) }\n  until string.first\
    \ == '[' && string.last == ']'\n    string.shift if string.first == ']'\n    string.pop\
    \ if string.last == '['\n  end\n  string.delete_at(0) && string.delete_at(-1)\n\
    \  string.empty?\nend", "    lst = string.split('')\n    return lst.count('[')\
    \ >= lst.count(']') && lst.count('[') >= lst.count('[') && lst.count(']') >= lst.count(']')\n\
    end\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \   return string.match(/\\[\\]/) != nil\nend", "    string.split('').each_with_index\
    \ do |i, index|\n        if string[index] == '['\n            if string[index\
    \ + 1] == ']'\n                return true\n            end\n        end\n   \
    \ end\n    return false\nend\nputs is_nested('[[]]') \nputs is_nested('[]]]]]]][[[[[]')\
    \ \nputs is_nested('[][]') \nputs is_nested('[]') \nputs is_nested('[[][]]') \n\
    puts is_nested('[[]][[') ", "  return true if string.match(/\\[\\[\\]\\]/)\n \
    \ false\nend", "\tstring.include?('[]')\nend", "\tflag = 0\n\tpairs = 0\n\tstring.split(\"\
    \").each do |i|\n\t\tif i == \"[\" \n\t\t\tflag += 1\n\t\t\tpairs += 1\n\t\telsif\
    \ i == \"]\"\n\t\t\tif flag > 0\n\t\t\t\tflag -= 1\n\t\t\telse\n\t\t\t\treturn\
    \ false\n\t\t\tend\n\t\tend\n\tend\n\treturn pairs > 1 && flag == 0\nend\np is_nested('[[]]')\n\
    p is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\n\
    p is_nested('[[]][[')", "\tstring.scan(/\\[\\]/).size > 0 ? true : false\nend",
  "\topen = string.count('[')\n\tclose = string.count(']')\n\tif open == close\n\t\
    \tfalse\n\telse\n\t\ttrue\n\tend\nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\n\
    p is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')",
  "    stack = []\n    string.each_char do |char|\n        if char == '['\n      \
    \      stack.push(char)\n        else\n            stack.pop\n        end\n  \
    \  end\n    return stack.empty?\nend", "    #if (string.include?(\"[\") == false)\
    \ || (string.include?(\"]\") == false)\n    #    return false\n    #end\n    counter\
    \ = 0\n    string.each_char do |char|\n        if char == \"[\"\n            counter\
    \ += 1\n        elsif char == \"]\"\n            counter -= 1\n        end\n \
    \       if counter < 0\n            return false\n        end\n    end\n    return\
    \ true\nend\nputs is_nested(\"[[]]\")\nputs is_nested(\"[]]]]]]][[[[[]\")\nputs\
    \ is_nested(\"[][]\")\nputs is_nested(\"[]\")\nputs is_nested(\"[[][]]\")\nputs\
    \ is_nested(\"[[]][[\")", "    stack = []\n    string.each_char { |char|\n   \
    \     if char == '['\n            stack.push(char)\n        elsif char == ']'\n\
    \            if stack.pop() != '['\n                return false\n           \
    \ end\n        end\n    }\n    return stack.length == 0\nend", "  open = 0\n \
    \ close = 0\n  string.each_char do |i|\n    if i == \"[\"\n      open += 1\n \
    \   elsif i == \"]\"\n      close += 1\n    end\n  end\n  if open == 0 && close\
    \ == 0\n    return false\n  end\n  return true\nend\np is_nested('[[]]') == true\n\
    p is_nested('[]]]]]]][[[[[]') == false\np is_nested('[][]') == false\np is_nested('[]')\
    \ == false\np is_nested('[[][]]') == true\np is_nested('[[]][[') == true", " \
    \   return false if string.size == 1\n    stack = []\n    string.each_char do\
    \ |c|\n        if c == '['\n            stack.push(c)\n        else\n        \
    \    if stack.size == 0\n                return false\n            else\n    \
    \            stack.pop\n            end\n        end\n    end\n    return stack.size\
    \ > 0\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \ if string.match(/[\\[\\]]/)\n    return true\n  else\n    return false\n  end\n\
    end", "\tstring = string.split('')\n\tstack = []\n\tfor i in 0..string.length-1\n\
    \t\tif string[i] == '['\n\t\t\tstack.push(string[i])\n\t\telse\n\t\t\tif stack.length\
    \ == 0\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tstack.pop\n\t\tend\n\tend\n\treturn\
    \ true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs\
    \ is_nested('[')\nputs is_nested(']')", "  return false if string.length == 1\
    \ || string.length.even?\n  test = string.gsub(/\\[\\]/, '')\n  test != string\n\
    end", "\tflag = false\n\tstring.scan(/\\[\\[/) do |match|\n\t\tflag = true\n\t\
    end\n\treturn flag\nend\np is_nested('[[]]') \np is_nested('[]]]]]]][[[[[]') \n\
    p is_nested('[][]') \np is_nested('[]') \np is_nested('[[][]]') \np is_nested('[[]][[')\
    \ \np is_nested('[[][[]]][') ", "  str = string.dup\n  str.delete! '[]'\n  str.empty?\n\
    end", "  # string.count('[]') == string.size / 2\n  string.delete('[]').empty?\n\
    end", "\tstring.count(']') > string.count('[') ? false : string.include?('[]')\n\
    end\nputs is_nested('[[]]') \nputs is_nested('[]]]]]]][[[[[]') \nputs is_nested('[][]')\
    \ \nputs is_nested('[]') \nputs is_nested('[[][]]') \nputs is_nested('[[]][[')",
  "\tstring.chars.select{|x|x==\"[\"}.length > string.chars.select{|x|x==\"]\"}.length\n\
    end\nis_nested('[[]]') #\u279E True\nis_nested('[]]]]]]][[[[[]') #\u279E False\n\
    is_nested('[][]') #\u279E False\nis_nested('[]') #\u279E False\nis_nested('[[][]]')\
    \ #\u279E True\nis_nested('[[]][[') #\u279E True", "    string = string.split('')\n\
    \    while (string.include?('[') || string.include?(']'))\n        if string.include?('[]')\n\
    \            string.delete_at(string.index('['))\n            string.delete_at(string.index(']'))\n\
    \        elsif string.include?('][')\n            string.delete_at(string.index(']'))\n\
    \            string.delete_at(string.index('['))\n        elsif string.include?('[[')\n\
    \            string.delete_at(string.index('['))\n            string.delete_at(string.index('['))\n\
    \        elsif string.include?(']]')\n            string.delete_at(string.index(']'))\n\
    \            string.delete_at(string.index(']'))\n        else\n            return\
    \ false\n        end\n    end\n    return true\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs '-----'", "  arr = string.split('')\n\
    \  return false if arr.count('[') != arr.count(']')\n  start_count = 0\n  end_count\
    \ = 0\n  arr.each do |ele|\n    if ele == '['\n      start_count += 1\n    else\n\
    \      end_count += 1\n    end\n    return true if start_count < end_count\n \
    \ end\n  false\nend", "\tstring.count('[') > string.count(']')\nend", "    count\
    \ = 0\n    string.chars.each do |x|\n        count += 1 if x == '['\n        count\
    \ -= 1 if x == ']'\n        break if count < 0\n    end\n    count == 0\nend",
  "  string.scan(/\\[|\\]/).each_with_object([]).with_index do |(char, arr), idx|\n\
    \    arr << char if arr.empty?\n    if arr.size > 1 && arr[-1] == '[' && char\
    \ == ']'\n      arr.pop\n      arr.pop\n    end\n  end.size != string.size\nend\n\
    p is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\n\
    p is_nested('[[][]]')\np is_nested('[[]][[')", "    count = 0\n    string.each_char\
    \ do |x|\n        count += 1 if x == '['\n        count -= 1 if x == ']'\n   \
    \     return false if count < 0\n    end\n    count.zero?\nend", "\ta = string.scan(/\\\
    [\\]/)\n\tif a.count == 1\n\t\treturn false\n\telse\n\t\treturn true\n\tend\n\
    end\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs\
    \ \"********************************************************************\"", " \
    \   flag = false\n    stack = []\n    if(string.length % 2 != 0)\n        return\
    \ false\n    end\n    string.split(\"\").each do |char|\n        if(char == \"\
    [\")\n            stack.push(char)\n        elsif(char == \"]\")\n           \
    \ flag = true\n            stack.pop()\n        end\n    end\n    if(stack.length\
    \ == 0 && flag)\n        return true\n    else\n        return false\n    end\n\
    end", "    l_count, r_count = 0, 0\n    string.each_char { |char| \n        l_count\
    \ += 1 if char == '['\n        r_count += 1 if char == ']'\n        return false\
    \ if r_count > l_count\n    }\n    return l_count == r_count\nend", "\t\tif string.include?(\"\
    [[\") || string.include?(\"]]\")\n\t\t\treturn true\n\t\telse\n\t\t\treturn false\n\
    \t\tend\nend\nputs \"Is Nested\"\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\n\
    puts is_nested(\"[[]]\")\nputs is_nested(\"[]]]]]]][[[[[]\")\nputs is_nested(\"\
    [][]\")\nputs is_nested(\"[]\")\nputs is_nested(\"[[][]]\")\nputs is_nested(\"\
    [[]][[\")", "\nend", "    return false if string.size.odd?\n    stack = []\n \
    \   string.each_char do |char|\n        if char == '['\n            stack.push(char)\n\
    \        else\n            stack.pop\n        end\n    end\n    return false if\
    \ stack.size > 0\n    return true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "    # Write code here\n    even = \"\"\n    if string.length < 2\n        return\
    \ false\n    end\n    if string.length % 2 == 0\n        even = true\n    else\n\
    \        even = false\n    end\n    if even\n        string.split(\"\").each_with_index\
    \ do |x, i|\n            if x == \"[\"\n                if string[i+1] == \"]\"\
    \n                    return true\n                end\n            end\n    \
    \    end\n    else\n        string.split(\"\").each_with_index do |x, i|\n   \
    \         if x == \"[\"\n                if string[i+1] == \"]\"\n           \
    \         return true\n                end\n            end\n        end\n   \
    \ end\n    return false\nend", "\tstack = []\n\tstring.each_char do |char|\n\t\
    \tif char == '['\n\t\t\tstack.push(char)\n\t\telsif char == ']'\n\t\t\tif stack.size\
    \ > 0\n\t\t\t\tstack.pop\n\t\t\telse\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\
    \tend\n\treturn true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\n\
    puts '====='", "\tn = 0\n\tstring.each_char do |i|\n\t\tif i == \"[\"\n\t\t\t\
    n += 1\n\t\telsif i == \"]\"\n\t\t\tn -= 1\n\t\tend\n\t\tif n < 0\n\t\t\treturn\
    \ false\n\t\tend\n\tend\n\treturn n != 0 ? false : true\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "  return false if string.length\
    \ <= 1\n  left = 0\n  right = 0\n  string.split('').each do |character|\n    left\
    \ += 1 if character == '['\n    right += 1 if character == ']'\n    return false\
    \ if right > left\n  end\n  left == right\nend", "  string.scan(/[[]]/).length\
    \ > 0 ? true : false\nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\n\
    p is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')",
  "  return false if string.nil? || string.empty?\n  stack = []\n  string.each_char\
    \ do |ch|\n    case ch\n    when \"[\"\n      stack.push(ch)\n    when \"]\"\n\
    \      return false if stack.empty?\n      stack.pop\n    end\n  end\n  return\
    \ stack.empty?\nend", "  a = []\n  for char in string\n    a.push(char) if char\
    \ == \"[\"\n    a.pop if char == \"]\"\n  end\n  return a.empty?\nend\np is_nested('[[]]')\n\
    p is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\n\
    p is_nested('[[]][[')", "    stack = 0\n    string.each_char { |c|\n        if\
    \ c == '['\n            stack += 1\n        elsif c == ']'\n            stack\
    \ -= 1\n        end\n        return false if stack < 0\n    }\n    return stack\
    \ == 0\nend", "\treturn false if string.length == 0\n\treturn false if string.length.odd?\n\
    \treturn false if string[0] == ']' || string[-1] == '['\n\treturn true if string.length\
    \ == 2\n\tstack = []\n\ti = 0\n\twhile i < string.length\n\t\tstack << string[i]\
    \ if string[i] == '['\n\t\tif string[i] == ']'\n\t\t\tif stack.length != 0\n\t\
    \t\t\tstack.pop\n\t\t\telse\n\t\t\t\treturn false\n\t\t\tend\n\t\tend\n\t\ti +=\
    \ 1\n\tend\n\treturn true if stack.length == 0\n\treturn false\nend", "\t\nend\n\
    puts \"is_nested\"\nputs is_nested('[[]]') == True\nputs is_nested('[]]]]]]][[[[[]')\
    \ == False\nputs is_nested('[][]') == False\nputs is_nested('[]') == False\nputs\
    \ is_nested('[[][]]') == True\nputs is_nested('[[]][[') == True\nputs \"======================\"",
  "\t#p string\n\tfinal = false\n\tstr_array = string.split('')\n\tstr_array.each\
    \ do |x|\n\t\tif x == '['\n\t\t\tif str_array.include?(']')\n\t\t\t\tfinal = true\n\
    \t\t\telse\n\t\t\t\tfinal = false\n\t\t\tend\n\t\tend\n\tend\n\tp final\nend",
  "\t#is_nested\n\tcount = 0\n\tarr = string.chars.to_a\n\tarr.each do |s|\n\t\tif(s\
    \ == \"[\")\n\t\t\tcount += 1\n\t\telsif(s == \"]\")\n\t\t\tcount -= 1\n\t\tend\n\
    \t\tif(count < 0)\n\t\t\treturn false\n\t\tend\n\tend\n\treturn (count == 0)\n\
    end\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", "\t\
    bracket_count = 0\n\tnested_count = 0\n\tstring.split(\"\").each do |char|\n\t\
    \tif char == \"[\"\n\t\t\tbracket_count += 1\n\t\telsif char == \"]\"\n\t\t\t\
    bracket_count -= 1\n\t\tend\n\t\tif bracket_count < 0\n\t\t\tnested_count += 1\n\
    \t\tend\n\tend\n\tnested_count > 0\nend", "    string.count('[') > string.count(']')\
    \ ? (string.count(']') > 0 ? true : false) : (string.count('[') > 0 ? true : false)\n\
    end", "  string.count('[') > 1\nend", "  nested = false\n  string.each_char.with_index\
    \ do |char, idx|\n    if string[idx + 1] == '[' && char == ']'\n      nested =\
    \ true\n    end\n  end\n  nested\nend", "    return true if string.include?(\"\
    []\")\n    return false if string.length <= 1\n    is_nested(string.gsub(\"[]\"\
    , \"\"))\nend", "    #not sure if this is the best way to solve this problem\n\
    \    string.scan(/\\[+/)[0].length < string.scan(/\\]+/)[0].length ? true : false\n\
    end", "    stack = []\n    string.each_char do |char|\n        if char == '['\n\
    \            stack.push(char)\n        else\n            return true if stack.length\
    \ > 0\n        end\n    end\n    return false\nend\nputs is_nested('[[]]')\nputs\
    \ is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs is_nested('[]]')", " \
    \ stack = []\n  string.each_char do |c|\n    case c\n    when '['\n      stack.push(c)\n\
    \    when ']'\n      if stack.empty?\n        return false\n      else\n     \
    \   stack.pop\n      end\n    end\n  end\n  stack.empty?\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs is_nested('[')", "  count\
    \ = 0\n  string.each_char do |char|\n    count += 1 if char == '['\n    count\
    \ -= 1 if char == ']'\n    break if count < 0\n  end\n  count == 0\nend", "\t\
    if string.count('[') > string.count(']')\n\t\treturn true\n\telse\n\t\treturn\
    \ false\n\tend\nend", "  string.split('').each_with_index do |letter, index|\n\
    \    if string[index] == \"[\" && string[index+1] == \"[\"\n      return true\n\
    \    end\n  end\n  return false\nend", "  string.scan(/[[\\]]/).combination(2).each\
    \ do |a, b|\n    return true if a != b\n  end\n  false\nend", "\tc=0\n\tstring.each_char\
    \ do |char|\n\t\tc+=1 if char=='['\n\t\tc-=1 if char==']'\n\t\treturn false if\
    \ c<0\n\tend\n\tc==0\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "  stack = []\n  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n\
    \    else\n      return true if stack.length > 0\n    end\n  end\n  false\nend\n\
    puts is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \ brackets = { ']' => '[', '}' => '{', ')' => '(' }\n  stack = []\n  string.each_char\
    \ do |c|\n    if brackets.values.include?(c)\n      stack << c\n    elsif brackets.keys.include?(c)\n\
    \      return false if brackets[c] != stack.pop\n    end\n  end\n  stack.empty?\n\
    end", "  def is_nested_recursive(string, stack, first_index, last_index)\n   \
    \ return stack.empty? && first_index == last_index\n    if string[first_index]\
    \ == '['\n      stack.push('[')\n      is_nested_recursive(string, stack, first_index\
    \ + 1, last_index)\n    else\n      return false if stack.empty?\n      stack.pop\n\
    \      is_nested_recursive(string, stack, first_index + 1, last_index)\n    end\n\
    \  end\n  is_nested_recursive(string, [], 0, string.length - 1)\nend", "  p =\
    \ 0\n  string.split('').each do |char|\n    if char == '['\n      p += 1\n   \
    \ elsif char == ']'\n      p -= 1\n    end\n    if p < 0\n      return false\n\
    \    end\n  end\n  p == 0\nend", "    count = 0\n    (0...string.length).each\
    \ do |i|\n        count += 1 if string[i] == '['\n        count -= 1 if string[i]\
    \ == ']'\n        return false if count < 0\n    end\n    return true if count\
    \ == 0\n    return false\nend", "  stack = []\n  string.each_char do |c|\n   \
    \ if c == '['\n      stack.push c\n    else\n      return false if stack.empty?\n\
    \      stack.pop\n    end\n  end\n  return false if stack.size > 0\n  true\nend\n\
    p is_nested('[[]]') == true\np is_nested('[]]]]]]][[[[[]') == false\np is_nested('[][]')\
    \ == false\np is_nested('[]') == false\np is_nested('[[][]]') == true\np is_nested('[[]][[')\
    \ == true", "  string.count('[') == string.count(']') &&\n  string.count('[[')\
    \ > string.count(']]') &&\n  string.count('[') > string.count(']') &&\n  string.count('[[')\
    \ < string.count(']]')\nend", "\tstack = []\n\tstring.each_char do |char|\n\t\t\
    stack << char if char == '['\n\t\tstack.pop if char == ']'\n\tend\n\tstack.empty?\n\
    end", "  puts string.scan(/\\[+\\]/).size > 0 ? true : false\nend\nis_nested('[[]]')\n\
    is_nested('[]]]]]]][[[[[]')\nis_nested('[][]')\nis_nested('[]')\nis_nested('[[][]]')\n\
    is_nested('[[]][[')", "  new_string = string.gsub(/[^\\[\\]]/, '')\n  new_string.delete(\"\
    []\") != new_string ? true : false\nend\nputs \"first test: #{is_nested('[[]]')}\"\
    \nputs \"second test: #{is_nested('[]]]]]]][[[[[]')}\"\nputs \"third test: #{is_nested('[][]')}\"\
    \nputs \"fourth test: #{is_nested('[]')}\"\nputs \"fifth test: #{is_nested('[[][]]')}\"\
    \nputs \"sixth test: #{is_nested('[[]][[')}\"", "    count=0\n    string.each_char\
    \ do |ch|\n        count+=1 if ch=='['\n        count-=1 if ch==']'\n        return\
    \ false if count<0\n    end\n    count==0 ? true : false\nend", "  return false\
    \ if string.length < 2\n  i = 1\n  j = string.length - 1\n  while i <= j do\n\
    \    if string[i] == string[j]\n      i += 1\n      j -= 1\n    else\n      return\
    \ false\n    end\n  end\n  true\nend", "\tstack = []\n\tstring.each_char do |c|\n\
    \t\tif c == '['\n\t\t\tstack.push(c)\n\t\telsif c == ']'\n\t\t\tif stack.pop ==\
    \ '['\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend\nputs\
    \ is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \ string.count('[') == string.count(']') ? false : true\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "  string.count(']') - string.count('[')\
    \ != 0 ? false : true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "  # FILL THIS IN\nend", "    # your code here\nend", "    return false if string.length\
    \ <= 0\n    left_bracket = 0\n    right_bracket = 0\n    left_nested = 0\n   \
    \ right_nested = 0\n    left_nested_bracket = 0\n    right_nested_bracket = 0\n\
    \    string.each_char do |x|\n        if x == \"[\"\n            left_bracket\
    \ += 1\n            left_nested_bracket += 1\n        elsif x == \"]\"\n     \
    \       right_bracket += 1\n            right_nested_bracket += 1\n        end\n\
    \        if left_nested_bracket > 0 && right_nested_bracket > 0\n            if\
    \ left_nested_bracket > right_nested_bracket\n                left_nested += 1\n\
    \                left_nested_bracket = 0\n                right_nested_bracket\
    \ = 0\n            elsif left_nested_bracket < right_nested_bracket\n        \
    \        right_nested += 1\n                left_nested_bracket = 0\n        \
    \        right_nested_bracket = 0\n            end\n        end\n    end\n   \
    \ left_bracket == right_bracket && left_nested > 0 && right_nested > 0\nend\n\
    puts is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs\
    \ is_nested('[]][[]')\nputs is_nested('[[[[[]]]]]')\nputs is_nested('[[[][[]]]')\n\
    puts is_nested('[[[[[[[[[[]]]]]]]]]]]')\nputs is_nested('[[[]][]]')\nputs is_nested('[[[[[[[[]]]]]]]]')\n\
    puts is_nested('[[[[[[[[]]]]]]]][[[[[[[[]]]]]]]]')\nputs is_nested('[[[[[[[[]]]]]]]][[[[[[[[]]]]]]]]][[[[[[[[[]]",
  "  return true if string.include?('[]')\n  return false if string.empty? || string.size.odd?\n\
    \  string.size.times do |i|\n    string.gsub!('[]', '')\n    return true if string.include?('[]')\n\
    \  end\n  false\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "\t(0...string.length).each do |i|\n\t\tif string[i] == '[' && string[i+1] == ']'\n\
    \t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\nputs is_nested('[[][]]')\n\
    puts is_nested('[[]][[')\nputs is_nested('[[]]')\nputs is_nested('[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]]]]]]][[[[[]')", "    if string.scan(/[[\\]]/).length > 1\n\
    \        if string.include?(\"[\") && string.include?(\"]\")\n            if string.scan(/[[\\\
    ]]/).join.include?(\"[]\")\n                return true\n            else\n  \
    \              return false\n            end\n        else\n            return\
    \ false\n        end\n    else\n        return false\n    end\nend\np is_nested('[[]]')\
    \ #\u279E True\np is_nested('[]]]]]]][[[[[]') #\u279E False\np is_nested('[][]')\
    \ #\u279E False\np is_nested('[]') #\u279E False\np is_nested('[[][]]') #\u279E\
    \ True\np is_nested('[[]][[') #\u279E True", "\t# return true if string.scan(/\\\
    ]\\[/).any?\n\ta=string.scan(/\\[\\]/)\n\treturn true if a.size>0\n\treturn false\n\
    end\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", "\t\
    pairs = {'{' => '}', '[' => ']', '(' => ')'}\n\tarr = []\n\tstring.each_char do\
    \ |char|\n\t\tif pairs.key?(char)\n\t\t\tarr << char\n\t\telsif pairs.values.include?(char)\n\
    \t\t\treturn false if pairs[arr.pop] != char\n\t\tend\n\tend\n\tarr.empty?\nend\n\
    p is_nested('[]]]]]]][[[[[]') # False\np is_nested('[[]]') # True\np is_nested('[][]')\
    \ # False\np is_nested('[]') # False\np is_nested('[[][]]') # True\np is_nested('[[]][[')\
    \ # True", "  str = string.delete('^[][]')\n  str.scan(/\\[\\]/).length == 1 ?\
    \ true : false\nend\nputs \"Is nested:\"\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "\tstring.count('[') != string.count(']') ? true : false\nend\nputs is_nested('[[]]')\
    \ == true\nputs is_nested('[]]]]]]][[[[[]') == false\nputs is_nested('[][]') ==\
    \ false\nputs is_nested('[]') == false\nputs is_nested('[[][]]') == true\nputs\
    \ is_nested('[[]][[') == true", "    subs = []\n    string.each_char do |c|\n\
    \        if c == '['\n            subs << ']'\n        elsif subs.empty? || subs.pop\
    \ != c\n            return false\n        end\n    end\n    subs.empty?\nend",
  "\tcounter = 0\n\tstring.each_char do |char|\n\t\tif char == \"[\"\n\t\t\tcounter\
    \ += 1\n\t\telsif char == \"]\"\n\t\t\tcounter -= 1\n\t\tend\n\t\treturn false\
    \ if counter < 0\n\tend\n\tcounter > 0 ? true : false\nend\np is_nested('[[]]')\
    \ \np is_nested('[]]]]]]][[[[[]') \np is_nested('[][]') \np is_nested('[]') \n\
    p is_nested('[[][]]') \np is_nested('[[]][[')", "    stack = []\n    string.each_char\
    \ do |ch|\n        if ch == '['\n            stack.push(ch)\n        else\n  \
    \          return false if stack.empty?\n            stack.pop\n        end\n\
    \    end\n    stack.empty?\nend", "    string.split(\"\").each do |bracket|\n\
    \        if string.include?('[][]')\n            return false\n        else\n\
    \            return true\n        end\n    end\nend\np is_nested('[][]')\np is_nested('[[]]')\n\
    p is_nested('[]]]]]]][[[[[]')\np is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')",
  "    n = string.length\n    return true if n.even? && string[0] == '[' && string[-1]\
    \ == ']'\n    return false if n.odd? || string[0] != '[' || string[-1] != ']'\n\
    \    true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs\
    \ is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "  output = false\n  string.split('').each_with_index do |e,i|\n    if string[i]\
    \ == '['\n      if string[i+1] == '['\n        output = true\n      end\n    end\n\
    \  end\n  output\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\n\
    puts is_nested('[[][[[')\nputs is_nested(']]]]]]]][[[[[[')\nputs is_nested('[[[[[[[[]]]]]]]]')",
  "    string.count('[') == string.count(']') && string.count('[') != 0\nend\nputs\
    \ is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \   return false if string.count('[') != string.count(']')\n    count = 0\n  \
    \  string.each_char do |x|\n        count += 1 if x == '['\n        count -= 1\
    \ if x == ']'\n        return true if count == 0\n    end\n    return false\n\
    end\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", "\t\
    # empty array, open brackets and close brackets\n\tarr = []\n\topen = \"[\"\n\t\
    close = \"]\"\n\tstring.split(\"\").each do |bracket|\n\t\t# open brackets will\
    \ push to array, close brackets will pop from array\n\t\tif bracket == open\n\t\
    \t\tarr.push(\"[\")\n\t\telsif bracket == close\n\t\t\tarr.pop\n\t\tend\n\tend\n\
    \t# if array is empty return true\n\t# else return false\n\tarr.empty?\nend\n\
    p is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\n\
    p is_nested('[[][]]')\np is_nested('[[]][[')", "    string = string.split('')\n\
    \    return false if string.length <= 2\n    left, right = 0, 0\n    return true\
    \ if string[0] == '[' && string[-1] == ']'\n    string.each do |str|\n       \
    \ left += 1 if str == '['\n        right += 1 if str == ']'\n        if right\
    \ > left\n            return false\n        end\n    end\n    return false if\
    \ left == right\n    return true\nend", "\tif string.match(/\\[\\]/) != nil\n\t\
    \treturn true\n\telse\n\t\treturn false\n\tend\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')\nputs is_nested('[[[]]]')\n\
    puts is_nested('[][')\nputs is_nested('[]][[]')\nputs is_nested('[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]')",
  "  if string.count('[') == 0 || string.count(']') == 0\n    return false\n  end\n\
    \  open_stack = []\n  close_stack = []\n  string.each_char do |char|\n    if char\
    \ == '['\n      open_stack.push(char)\n    elsif char == ']'\n      close_stack.push(char)\n\
    \    end\n  end\n  open_stack.length < close_stack.length ? false : true\nend\n\
    p is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\n\
    p is_nested('[[][]]')\np is_nested('[[]][[')", "    count = 0\n    string.each_char\
    \ do |bracket|\n        count += 1 if bracket == '['\n        count -= 1 if bracket\
    \ == ']'\n        return false if count < 0\n    end\n    count == 0\nend\nputs\
    \ is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \ return true if string.scan(/\\[\\]/).count > 0\n  false\nend", "    string.gsub!(/[[]]/,\
    \ ' ')\n    string.gsub!(/[][]/, ' ')\n    string.include?('[')\nend", "    i\
    \ = 0\n    brackets = []\n    while i < string.length\n        if string[i] ==\
    \ \"[\"\n            brackets.push(\"[\")\n        elsif string[i] == \"]\"\n\
    \            if brackets.last == \"[\"\n                brackets.pop\n       \
    \     else\n                brackets.push(\"]\")\n            end\n        end\n\
    \        i += 1\n    end\n    if brackets.empty?\n        return true\n    else\n\
    \        return false\n    end\nend", "\ti=0\n\tj=1\n\tcount=0\n\tif string.length<2\n\
    \t\treturn false\n\telse\n\t\twhile i<string.length\n\t\t\tif string[i]==\"[\"\
    \ and string[j]==\"]\"\n\t\t\t\tcount+=1\n\t\t\tend\n\t\t\ti+=1\n\t\t\tj+=1\n\t\
    \tend\n\t\tif count>0\n\t\t\treturn true\n\t\telse\n\t\t\treturn false\n\t\tend\n\
    \tend\nend", "\tclose_bracket = 0\n\topen_bracket = 0\n\tstring.each_char do |item|\n\
    \t\titem == '[' ? open_bracket += 1 : close_bracket += 1\n\t\treturn false if\
    \ close_bracket > open_bracket\n\tend\n\tclose_bracket < open_bracket ? true :\
    \ false\nend", "\tnumber = 0\n\tstring.chars.each do |char|\n\t\tif char == \"\
    [\"\n\t\t\tnumber += 1\n\t\telsif char == \"]\"\n\t\t\tnumber -= 1\n\t\tend\n\t\
    \treturn false if number < 0\n\tend\n\treturn true if number > 0\n\tfalse\nend",
  "    # loop over all bracket characters\n    # if opening bracket create a new array\n\
    \    # if closing bracket check if first bracket is closing bracket", "  count\
    \ = 0\n  string.each_char do |i|\n    count += 1 if i == '['\n    count -= 1 if\
    \ i == ']'\n    return false if count < 0\n  end\n  count == 0\nend", "\tleft\
    \ = 0\n\tright = 0\n\tstring.each_char do |char|\n\t\tchar == '[' ? left += 1\
    \ : right += 1\n\t\treturn false if right > left\n\tend\n\ttrue\nend\np is_nested('[[]]')\n\
    p is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\n\
    p is_nested('[[]][[')\np is_nested('[]][')\np is_nested('[[]]][')\np is_nested('[[]]')",
  "    opening = string.count(\"[\")\n    closing = string.count(\"]\")\n    if opening\
    \ == 0 || closing == 0\n        return false\n    elsif opening > closing\n  \
    \      return false\n    elsif opening < closing\n        return false\n    else\n\
    \        return true\n    end\nend", "\tif string.include?(\"[[\") || string.include?(\"\
    ]]\")\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend", "  return string.scan(/\\\
    [\\]/).count > 0\nend", "\treturn false if string.count('[') == 0\n\treturn false\
    \ if string.count(']') == 0\n\treturn false if string.count('[') == string.count(']')\n\
    \treturn true if string.count('[') > string.count(']')\n\treturn true if string.count('[')\
    \ < string.count(']')\nend\np is_nested('[[]]') #True\np is_nested('[]]]]]]][[[[[]')\
    \ #False\np is_nested('[][]') #False\np is_nested('[]') #False\np is_nested('[[][]]')\
    \ #True\np is_nested('[[]][[') #True\np is_nested('[]()') #False\np is_nested('[{}[]]')\
    \ #True\np is_nested('[])([]') #False\np is_nested('[])({})[]') #True\np is_nested('[])([]{})')\
    \ #False\np is_nested('((((()))))') #True\np is_nested('([[]()])') #True\np is_nested('([()[]()])')\
    \ #True\np is_nested('([)]') #False\np is_nested('([]()[]{})') #True\np is_nested('[][[]{}[]][]')\
    \ #True\np is_nested('(()][()]') #False\np is_nested('[][[()]]') #True\np is_nested('(()[]()[]{})')\
    \ #True\np is_nested('((([])){})') #True\np is_nested('(([][]{}))') #True\np is_nested('((()[]))')\
    \ #True\np is_nested('(([]()[]))') #True\np is_nested('([][])') #True\np is_nested('(())[]{}')\
    \ #True\np is_nested('(([]){})') #True\np is_nested('((([])))({})') #True\np is_nested('([[][]{}])')\
    \ #True\np is_", "\tstring.delete(\"[\").delete(\"]\") == \"\" ? true : false\n\
    end\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\n\
    p is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')", "\treturn true\
    \ if string.include?(\"[[\") || string.include?(\"][\")\n\treturn false\nend\n\
    p is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\n\
    p is_nested('[[][]]')\np is_nested('[[]][[')", "    # to find out the number of\
    \ opening and closing brackets,\n    # but I can't figure out how to check if\
    \ they are nested\n    open = 0\n    close = 0\n    string.each_char do |c|\n\
    \        if c == \"[\"\n            open += 1\n        else\n            close\
    \ += 1\n        end\n    end\n    open > 0 && close > 0\nend\nputs \"3) #{is_nested('[[]]')}\
    \ should be true.\"\nputs \"3) #{is_nested('[]]]]]]][[[[[]')} should be false.\"\
    \nputs \"3) #{is_nested('[][]')} should be false.\"\nputs \"3) #{is_nested('[]')}\
    \ should be false.\"\nputs \"3) #{is_nested('[[][]]')} should be true.\"\nputs\
    \ \"3) #{is_nested('[[]][[')} should be true.\"", "  # your code goes here\nend\n\
    puts is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \   if string.length < 2\n        return false\n    end\n    open = 0\n    closed\
    \ = 0\n    string.each_char do |char|\n        if char == \"[\"\n            open\
    \ += 1\n        elsif char == \"]\"\n            closed += 1\n        end\n  \
    \  end\n    return open == closed\nend", "  left = string.scan(/\\[/).length\n\
    \  right = string.scan(/\\]/).length\n  left == right ? false : true\nend", " \
    \   string.scan(/\\[|\\]/).each_slice(2).to_a.select{|x|x.size==2}.size>0\nend",
  "  string.scan(/\\[\\]/).size == string.size / 2 ? false : true\nend", "    counts\
    \ = {\"[\": 0, \"]\": 0}\n    string.each_char do |char|\n        counts[char]\
    \ += 1\n    end\n    counts[\"[\"] >= 1 && counts[\"[\"] == counts[\"]\"]\nend",
  "  if string.count('[') == string.count(']')\n    if string.include?('[][]')\n \
    \     return false\n    else\n      return true\n    end\n  else\n    return false\n\
    \  end\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \   string.count(']') == string.count('[')\nend\nputs is_nested('[[]]')\nputs\
    \ is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "    stack = []\n    string.each_char\
    \ do |char|\n        if char == '['\n            stack.push(char)\n        else\n\
    \            if stack.empty?\n                return false\n            else\n\
    \                stack.pop\n            end\n        end\n    end\n    return\
    \ true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \ stack = []\n  string.chars.each do |char|\n    stack << char if char == '['\n\
    \    stack.pop if char == ']'\n  end\n  return false if stack.size == string.size\
    \ || stack.size > 0\n  true\nend", "    count = 0\n    string.each_char do |char|\n\
    \        count += 1 if char == '['\n        count -= 1 if char == ']'\n      \
    \  return false if count < 0\n    end\n    count == 0 ? true : false\nend\np is_nested('[[]]')\n\
    p is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\n\
    p is_nested('[[]][[')", "  left = 0\n  right = 0\n  string.chars.each do |c|\n\
    \    left += 1 if c == '['\n    right += 1 if c == ']'\n    break if right > left\n\
    \  end\n  left == right\nend", "    #flag = 0\n    string.scan(/\\[\\]/) do |match|\n\
    \        #puts match\n        if match.size == 2\n            flag = 1\n     \
    \   end\n    end\n    if flag == 1\n        return true\n    else\n        return\
    \ false\n    end\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "\tstatus = false\n\tbrackets = 0\n\tbrackets_1 = 0\n\tbrackets_2 = 0\n\tstring.each_char\
    \ { |c| \n\t\tif c == \"[\"\n\t\t\tbrackets += 1\n\t\telsif c == \"]\"\n\t\t\t\
    brackets -= 1\n\t\tend\n\t\tif brackets > 0 && brackets_1 == 0\n\t\t\tbrackets_1\
    \ = brackets\n\t\tend\n\t\tif brackets < 0 && brackets_2 == 0\n\t\t\tbrackets_2\
    \ = brackets\n\t\tend\n\t}\n\tif brackets_1 == brackets_2.abs\n\t\tstatus = true\n\
    \tend\n\tstatus\nend", "\tleft = string.split('').select{|x| x == \"[\"}\n\tright\
    \ = string.split('').select{|x| x == \"]\"}\n\treturn left.size == right.size\
    \ ? false : true\nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\n\
    p is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')", "  str1 = string.gsub(/[[]]/,\
    \ \"\")\n  str2 = str1.gsub(/[]][]/, \"\")\n  if str2.include?(\"[\") || str2.include?(\"\
    ]\") \n    puts false\n  else\n    puts true\n  end\nend\nis_nested('[[]]')\n\
    is_nested('[]]]]]]][[[[[]')\nis_nested('[][]')\nis_nested('[]')\nis_nested('[[][]]')\n\
    is_nested('[[]][[')", "\ti = 0\n\twhile i < string.length\n\t\tif string[i] ==\
    \ \"[\" && string[i+1] == \"]\"\n\t\t\treturn true\n\t\tend\n\t\ti += 1\n\tend\n\
    \treturn false\nend\nputs(is_nested('[[]]'))\nputs(is_nested('[]]]]]]][[[[[]'))\n\
    puts(is_nested('[][]'))\nputs(is_nested('[]'))\nputs(is_nested('[[][]]'))\nputs(is_nested('[[]][['))",
  "    c = 0\n    string.each_char do |x|\n        if x == '['\n            c += 1\n\
    \        else\n            c -= 1\n        end\n        if c < 0\n           \
    \ return false\n        end\n    end\n    return c == 0\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "\tleft = 0\n\tright = 0\n\
    \tstring.each_char do |char|\n\t\tif char == \"[\"\n\t\t\tleft += 1\n\t\telsif\
    \ char == \"]\"\n\t\t\tright += 1\n\t\tend\n\tend\n\tleft > 1 && right > 1\nend",
  "    if string.include?('[') && string.include?(']')\n        return true\n    else\n\
    \        return false\n    end\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "    return string.match?(/\\[\\[\\]\\]/)\nend", "\tstring.include?('[') && string.include?(']')\n\
    end\np is_nested('[[]]') \np is_nested('[]]]]]]][[[[[]') \np is_nested('[][]')\
    \ \np is_nested('[]') \np is_nested('[[][]]') \np is_nested('[[]][[') ", "\tstr=string.split('')\n\
    \tl=str.length\n\tif l%2 != 0\n\t\treturn false\n\telse\n\t\tfor i in 0..l-1\n\
    \t\t\tif str[i]=='[' and str[i+1]==']' or str[i]==']' and str[i+1]=='['\n\t\t\t\
    \treturn true\n\t\t\tend\n\t\tend\n\tend\nend", "    open = string.scan('[')\n\
    \    close = string.scan(']')\n    if open.length > close.length\n        return\
    \ false\n    elsif open.length == close.length\n        return true\n    elsif\
    \ open.length < close.length\n        return true\n    end\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "  return false if string.count('[')\
    \ == 0 || string.count(']') == 0\n  stack = []\n  string.each_char do |char|\n\
    \    if char == '['\n      stack.push(char)\n    else\n      stack.pop\n    end\n\
    \  end\n  stack.empty?\nend", "    bracket = 0\n    string.chars.each do |chr|\n\
    \        bracket += 1 if chr == '['\n        bracket -= 1 if chr == ']'\n    \
    \    return false if bracket < 0\n    end\n    bracket == 0\nend", "\tcounter\
    \ = 0\n\tstring.each_char do |char|\n\t\tif char == \"[\"\n\t\t\tcounter += 1\n\
    \t\telsif char == \"]\"\n\t\t\tcounter -= 1\n\t\tend\n\t\treturn false if counter\
    \ < 0\n\tend\n\ttrue\nend\nputs \"4-------------------------\"\np is_nested('[[]]')\
    \ == true\np is_nested('[]]]]]]][[[[[]') == false\np is_nested('[][]') == false\n\
    p is_nested('[]') == false\np is_nested('[[][]]') == true\np is_nested('[[]][[')\
    \ == true", "\t# I need a list of valid \"pairs\" of brackets\n\t# I need a list\
    \ of brackets that don't have a match\n\t# If list of brackets without a match\
    \ is empty, return true\n\t# Else return false\n\tbrackets = {'[' => ']', '{'\
    \ => '}', '(' => ')'}\n\tbrackets_without_match = []\n\tstring.each_char do |char|\n\
    \t\tif brackets.has_key?(char)\n\t\t\tbrackets_without_match << char\n\t\telsif\
    \ brackets.has_value?(char)\n\t\t\tbrackets_without_match.pop\n\t\tend\n\tend\n\
    \treturn true if brackets_without_match.empty?\n\tfalse\nend", "    a = 0\n  \
    \  b = 0\n    string.chars.each do |char|\n        a += 1 if char == \"[\"\n \
    \       b += 1 if char == \"]\"\n        return false if b > a\n    end\n    return\
    \ true if a == b\n    return false\nend", "  string = string.split('')\n  flag\
    \ = false\n  string.each_with_index do |s,index|\n    if (s == '[' && string[index+1]\
    \ == ']') || (s == ']' && string[index-1] == '[')\n      flag = true\n    end\n\
    \  end\n  return flag\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "  string.count(']') > string.count('[') ? false : true\nend", "  string.gsub!('[]',\
    \ '')\n  string.empty? ? true : false\nend", "\tstr = string.downcase.split('')\n\
    \tnested = false\n\tnested = str.include?('[[') || str.include?(']]') ? true :\
    \ false\n\tnested\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "  storage = []\n  string.chars.each do |char|\n    if char == '['\n      storage\
    \ << char\n    elsif char == ']'\n      if storage.last == '['\n        storage.pop\n\
    \      else\n        return false\n      end\n    end\n  end\n  storage.empty?\
    \ ? true : false\nend", "  count_right = 0\n  count_left = 0\n  string.each_char\
    \ do |char|\n    if char == '['\n      count_left += 1\n    elsif char == ']'\n\
    \      count_right += 1\n    end\n  end\n  count_right != count_left\nend", " \
    \   left_brackets_count = 0\n    right_brackets_count = 0\n    string.each_char\
    \ do |ch|\n        if ch == '['\n            left_brackets_count += 1\n      \
    \  elsif ch == ']'\n            right_brackets_count += 1\n        end\n    end\n\
    \    return left_brackets_count > 1 && right_brackets_count > 1\nend", "\t(string.count('[')\
    \ != string.count(']')) ? false : true\nend", "  string.count('[') == string.count(']')\
    \ && string.count('[') > 1\nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\n\
    p is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')",
  "\tp1=string.count('[')\n\tp2=string.count(']')\n\tif p1==p2\n\t\treturn false\n\
    \telse\n\t\treturn true\n\tend\nend\nis_nested('[[]]')\nis_nested('[]]]]]]][[[[[]')\n\
    is_nested('[][]')\nis_nested('[]')\nis_nested('[[][]]')\nis_nested('[[]][[')",
  "\tstack = []\n\tstring.each_char do |char|\n\t\tif char == '['\n\t\t\tstack.push(char)\n\
    \t\telse\n\t\t\tif stack.length == 0\n\t\t\t\treturn false\n\t\t\telse\n\t\t\t\
    \tstack.pop\n\t\t\tend\n\t\tend\n\tend\n\treturn true\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "    a = string.split('')\n\
    \    a.each_with_index do |ch,i|\n        if (ch == ']' && a[i+1] != '[')\n  \
    \          return false\n        elsif (ch == '[' && a[i+1] != ']')\n        \
    \    return false\n        end\n    end\n    return true\nend\nprint is_nested('[[]]'),\"\
    \\n\"\nprint is_nested('[]]]]]]][[[[[]'),\"\\n\"\nprint is_nested('[][]'),\"\\\
    n\"\nprint is_nested('[]'),\"\\n\"\nprint is_nested('[[][]]'),\"\\n\"\nprint is_nested('[[]][['),\"\
    \\n\"\nprint is_nested('[]]]'),\"\\n\"", "  string.count('[') == string.count(']')\n\
    end", "    bool = false\n    stack = Array.new\n    i = 0\n    while i < string.length\n\
    \        if string[i] == '['\n            stack.push('[')\n        else\n    \
    \        if stack.length == 0\n                return false\n            end\n\
    \            stack.pop\n        end\n        i += 1\n    end\n    if stack.length\
    \ > 0\n        return false\n    end\n    return true\nend", "    # string.gsub!(/\\\
    [\\]/, '')\n    # if string.match?(/\\]\\[/)\n    #     return false\n    # else\n\
    \    #     return true\n    # end\n    # return string.match?(/\\]\\[/) ? false\
    \ : true\n    return string.match?(/\\]\\[/) == false\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "  i = 0\n  while i < string.length\n\
    \    puts string[i]\n    if string[i] == \"[\" && string[i+1] == \"]\"\n     \
    \ return true\n    end\n    i += 1\n  end\n  return false\nend", "  stack = []\n\
    \  string.each_char do |char|\n    if char == '['\n      stack.push(char)\n  \
    \  else\n      if stack.length > 0\n        stack.pop\n      else\n        return\
    \ false\n      end\n    end\n  end\n  return true\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "  string.count('[') == string.count(']')\
    \ ? false : true\nend", "    arr = string.chars.map {|char| char.match(/[\\[\\\
    ]]/)}\n    return false if arr.include?(nil)\n    end_index = nil\n    until end_index\
    \ == string.length\n        arr = arr.drop(end_index + 1) if end_index\n     \
    \   start_index = arr.index {|char| char == \"[\"}\n        return false if !start_index\n\
    \        end_index = arr.index {|char| char == \"]\"}\n        return false if\
    \ !end_index\n    end\n    true\nend\nputs \"Exercise 6\"\nputs is_nested('[[]]')\
    \ \nputs is_nested('[]]]]]]][[[[[]') \nputs is_nested('[][]') \nputs is_nested('[]')\
    \ \nputs is_nested('[[][]]') \nputs is_nested('[[]][[') \nputs", "  p string.scan(/\\\
    [{2,}|\\]{2,}/).empty?\nend\nis_nested('[[]]')\nis_nested('[]]]]]]][[[[[]')\n\
    is_nested('[][]')\nis_nested('[]')\nis_nested('[[][]]')\nis_nested('[[]][[')",
  "  string.include?('[]')\nend", "  if string.include?('[]')\n    return true\n \
    \ else\n    return false\n  end\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "    return false if string.length == 0\n    return true if string.scan(/\\[/).length\
    \ > string.scan(/\\]/).length\n    return true if string.scan(/\\[/).length <\
    \ string.scan(/\\]/).length\n    string.each_char.with_index do |c, i|\n     \
    \   if c == \"[\" && string[i+1] == \"]\"\n            return true\n        end\n\
    \    end\n    return false\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\n\
    puts \"==================\"", "    return true if string.include?('[[')\n    return\
    \ true if string.include?('][')\n    return false\nend", "    stack = 0\n    not_nested\
    \ = []\n    string.each_char do |char|\n        if char == \"[\"\n           \
    \ stack += 1\n        elsif char == \"]\"\n            stack -= 1\n        end\n\
    \        not_nested << stack\n    end\n    if not_nested.include?(-1)\n      \
    \  false\n    else\n        true\n    end\nend\np is_nested('[[]]') #\u279E True\n\
    p is_nested('[]]]]]]][[[[[]') #\u279E False\np is_nested('[][]') #\u279E False\n\
    p is_nested('[]') #\u279E False\np is_nested('[[][]]') #\u279E True\np is_nested('[[]][[')\
    \ #\u279E True\np is_nested('[[[]]]') #\u279E True\np is_nested('][') #\u279E\
    \ False\np is_nested('[') #\u279E False\np is_nested(']') #\u279E False\np is_nested('[[[][]]]')\
    \ #\u279E True\np is_nested('[][][]') #\u279E False\np is_nested('[[[[[[[[[]]]]]]]]]')\
    \ #\u279E True\np is_nested('[]]') #\u279E False\np is_nested(']][[') #\u279E\
    \ False\np is_nested('[[]][[]][[[]]][]') #\u279E True\np is_nested('[[]][[[]][]]')\
    \ #\u279E True\np is_nested('[[]]][[[') #\u279E False\np is_nested('[][]]][[[')\
    \ #\u279E False\np is_nested('[]]][[[') #\u279E False", "\tpairs = {\n\t  \"[\"\
    \ => \"]\",\n\t  \"{\" => \"}\",\n\t  \"(\" => \")\"\n\t}\n\topen = []\n\tstring.each_char\
    \ do |char|\n\t  if pairs.keys.include?(char)\n\t\topen << char\n\t  elsif pairs.values.include?(char)\n\
    \t\treturn false if pairs[open.pop] != char\n\t  end\n\tend\n\topen.empty?\n \
    \ end\n  puts is_nested('[[]]')\n  puts is_nested('[]]]]]]][[[[[]')\n  puts is_nested('[][]')\n\
    \  puts is_nested('[]')\n  puts is_nested('[[][]]')\n  puts is_nested('[[]][[')",
  "\ta = string.scan(/\\[+/)\n\tb = string.scan(/\\]+/)\n\ta.each do |str|\n\t\tstr.length.times\
    \ do\n\t\t\tb.shift\n\t\tend\n\tend\n\treturn true if b.empty?\n\treturn false\n\
    end\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\n\
    puts is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')", " \
    \ return true if string.scan(/\\[/).size == string.scan(/\\]/).size\n  return\
    \ false\nend\nputs is_nested('[[]]') # \u279E True\nputs is_nested('[]]]]]]][[[[[]')\
    \ # \u279E False\nputs is_nested('[][]') # \u279E False\nputs is_nested('[]')\
    \ # \u279E False\nputs is_nested('[[][]]') # \u279E True\nputs is_nested('[[]][[')\
    \ # \u279E True", "  string.scan(/\\[\\]/).size >= 1\nend", "    return string.count('[')\
    \ > string.count(']')\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "  p string.count('[') > string.count(']') && string.count('[') < string.count(']')\
    \ ? false : true\nend\nis_nested('[[]]')\nis_nested('[]]]]]]][[[[[]')\nis_nested('[][]')\n\
    is_nested('[]')\nis_nested('[[][]]')\nis_nested('[[]][[')\nis_nested('[[[]]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\n\
    is_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('[[]]')\nis_nested('",
  "    count = 0\n    string.each_char do |char|\n        count += 1 if char == '['\n\
    \        count -= 1 if char == ']'\n        return false if count < 0\n    end\n\
    \    return false if count != 0\n    return true\nend\np is_nested('[[]]') ==\
    \ true\np is_nested('[]]]]]]][[[[[]') == false\np is_nested('[][]') == false\n\
    p is_nested('[]') == false\np is_nested('[[][]]') == true\np is_nested('[[]][[')\
    \ == true", "\tstack = []\n\tmapping = {')' => '(', ']' => '[', '}' => '{'}\n\t\
    string.chars.each do |char|\n\t\tif mapping.values.include?(char)\n\t\t\tstack.push(char)\n\
    \t\telse\n\t\t\treturn false if stack.pop != mapping[char]\n\t\tend\n\tend\n\t\
    stack.empty?\nend", "   \n    \nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\n\
    p is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')\n\
    puts '-----'", "\tstring.scan(/\\[\\]/).length > 0\nend\np is_nested('[[]]') \n\
    p is_nested('[]]]]]]][[[[[]') \np is_nested('[][]') \np is_nested('[]') \np is_nested('[[][]]')\
    \ \np is_nested('[[]][[') ", "\tif string == \"\"\n\t\tfalse\n\telse\n\t\twhile\
    \ string.include?(\"[]\")\n\t\t\tstring.gsub!(\"[]\", \"\")\n\t\tend\n\t\tif string\
    \ == \"\"\n\t\t\ttrue\n\t\telse\n\t\t\tfalse\n\t\tend\n\tend\nend", "\tleft =\
    \ 0\n\tright = 0\n\tstring.each_char do |char|\n\t\tif char == \"[\"\n\t\t\tleft\
    \ += 1\n\t\telsif char == \"]\"\n\t\t\tright += 1\n\t\tend\n\tend\n\tif left >\
    \ right\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend\nputs is_nested('[[][]]')",
  "    # make an array of the strings\n    # iterate through the array\n    # if the\
    \ first string is [\" then find the next bracket that is a ]\n    # then check\
    \ if that bracket is nested\n    # if true then return true\n    # if the first\
    \ bracket is ] then check if its nested\n    # if not then return false\n    #\
    \ add a counter to the array to test the brackets\n    # if counter is even then\
    \ its nested\n    # if counter is odd then its not\n    # iterate through the\
    \ array again to check the brackets\n    # if the counter is odd then return false\n\
    \    # return true\n    # if the two brackets dont match then return false\n \
    \   # if the two brackets match then return true\n    # if the brackets are not\
    \ the same then return false\n    # if the brackets are the same then return true\n\
    \    # the counter is equal to zero \n    # the counter is not equal to zero\n\
    \    # make an empty array\n    # for each bracket in the string\n    # if the\
    \ bracket is equal to ]\n    # then add one to the counter\n    # else add one\
    \ to the counter\n    # if the counter is zero then return true\n    # else return\
    \ false\n    # make an empty array\n    # for each bracket in the string\n   \
    \ # if the bracket is equal to [\n    # then add one to the counter\n    # else\
    \ add one to the counter\n    # if the counter is zero then return true\n    #\
    \ else return false\n    # create an empty array\n    # for each bracket in the\
    \ string\n    # if the bracket is equal to ]\n    # then add one to the counter\n\
    \    # else add one to the counter\n    # if the counter is zero then return true\n\
    \    # else return false\n    # create an empty array\n    # for each bracket\
    \ in the string\n    # if the bracket is equal to [\n    # then add one to the\
    \ counter\n    # else add one to the counter\n    # if the counter is zero then\
    \ return true\n    # else return false\n    # create an empty array\n    # for\
    \ each bracket in the string\n    # if the bracket is equal to ]\n    # then add\
    \ one to the counter\n    # else add one to the counter\n    # if the counter\
    \ is zero then return true\n    # else return false\n   ", "\t# \u0435\u0441\u043B\
    \u0438 \u043F\u0435\u0440\u0432\u044B\u0439 \u0441\u0438\u043C\u0432\u043E\u043B\
    \ \u043E\u0442\u043A\u0440\u044B\u0432\u0430\u044E\u0449\u0430\u044F \u0441\u043A\
    \u043E\u0431\u043A\u0430 \u0438 \u043F\u043E\u0441\u043B\u0435\u0434\u043D\u0438\
    \u0439 \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u044E\u0449\u0430\u044F, \u0442\
    \u043E \u044D\u0442\u043E \u0432\u0441\u0435\u0433\u0434\u0430 \u0431\u0443\u0434\
    \u0435\u0442 true\n\tif string[0] == \"[\" && string[-1] == \"]\"\n\t\ttrue\n\t\
    # \u0438\u043D\u0430\u0447\u0435 \u0432\u044B\u0447\u0438\u0441\u043B\u044F\u0435\
    \u043C \u0441\u0442\u0435\u043F\u0435\u043D\u044C \u0432\u043B\u043E\u0436\u0435\
    \u043D\u043D\u043E\u0441\u0442\u0438\n\telse\n\t\t# \u0443\u0431\u0438\u0440\u0430\
    \u0435\u043C \u043B\u0438\u0448\u043D\u0438\u0435 \u0441\u043A\u043E\u0431\u043A\
    \u0438, \u043E\u0441\u0442\u0430\u0432\u043B\u044F\u044F \u0442\u043E\u043B\u044C\
    \u043A\u043E \u043D\u0435\u0438\u0437\u043C\u0435\u043D\u043D\u044B\u0435 \u0432\
    \u043B\u043E\u0436\u0435\u043D\u043D\u044B\u0435 \u0441\u0442\u0440\u0443\u043A\
    \u0442\u0443\u0440\u044B\n\t\tstring.split(/\\[[^\\[\\]]*\\]/).reject(&:empty?).any?{|i|\
    \ i.length.odd?}\n\tend\nend", "\treturn false if string.length == 0 || string.length.odd?\n\
    \ttemp = string.split('')\n\tcount_opening_brackets = 0\n\tcount_closing_brackets\
    \ = 0\n\ttemp.each do |bracket|\n\t\tcount_opening_brackets += 1 if bracket ==\
    \ '['\n\t\tcount_closing_brackets += 1 if bracket == ']'\n\t\treturn false if\
    \ count_closing_brackets > count_opening_brackets\n\tend\n\treturn true if count_opening_brackets\
    \ == count_closing_brackets\nend\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')",
  "    return false if string.count('[') != string.count(']')\n    return false if\
    \ string.count('[') == 0 || string.count(']') == 0\n    count = 0\n    string.chars.each\
    \ do |char|\n        count -= 1 if char == ']'\n        count += 1 if char ==\
    \ '['\n        return true if count < 0\n    end\n    count == 0\nend\nputs is_nested('[[]]')\
    \ #\u279E True\nputs is_nested('[]]]]]]][[[[[]') #\u279E False\nputs is_nested('[][]')\
    \ #\u279E False\nputs is_nested('[]') #\u279E False\nputs is_nested('[[][]]')\
    \ #\u279E True\nputs is_nested('[[]][[') #\u279E True", "  array = string.chars\n\
    \  if array.count(\"[\") == array.count(\"]\")\n    if array.index(\"[\") < array.index(\"\
    ]\")\n      return true\n    else\n      return false\n    end\n  else\n    return\
    \ false\n  end\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')",
  "\tstring = string.split('')\n\tcount = 0\n\tstring.each do |x|\n\t\tcount += 1\
    \ if x == '['\n\t\tcount -= 1 if x == ']'\n\t\treturn false if count < 0\n\tend\n\
    \tcount.zero?\nend\np is_nested('[[]]') == true\np is_nested('[]]]]]]][[[[[]')\
    \ == false\np is_nested('[][]') == false\np is_nested('[]') == false\np is_nested('[[][]]')\
    \ == true\np is_nested('[[]][[') == true", "\tstring.count('[') == string.count(']')\
    \ && string.count('[') != 0 && string.count(']') != 0\nend\nputs is_nested('[[]]')\n\
    puts is_nested('[]]]]]]][[[[[]')\nputs is_nested('[][]')\nputs is_nested('[]')\n\
    puts is_nested('[[][]]')\nputs is_nested('[[]][[')", "    open = string.gsub(/\\\
    ]/,\"\")\n    closed = string.gsub(/\\[/,\"\")\n    open.length < closed.length\
    \ || open.length == closed.length\nend", "\ti = 0\n\tj = 0\n\twhile i < string.length\n\
    \t\tif string[i] == '['\n\t\t\tj += 1\n\t\telse\n\t\t\tj -= 1\n\t\tend\n\t\ti\
    \ += 1\n\tend\n\treturn true if j > 0\n\treturn false\nend", "  open = [\"[\"\
    ]\n  closed = [\"]\"]\n  input = string.split(\"\")\n  new_string = []\n  if input.count(open)\
    \ > input.count(closed)\n    return false\n  elsif input.count(open) == input.count(closed)\n\
    \    return true\n  else \n    return true\n  end\nend", "  open = string.count('[')\n\
    \  closed = string.count(']')\n  return false if open != closed\n  open_stack\
    \ = []\n  string.chars.each do |c|\n    open_stack << c if c == '['\n    open_stack.pop\
    \ if c == ']'\n  end\n  return true if open_stack.empty?\n  false\nend", "\tstring.scan(/\\\
    [\\]/).length >= 1\nend", "    if string.count('[') == string.count(']')\n   \
    \   return false\n    end\n    return true\nend", "\treturn false if string.count('[')\
    \ == 0\n\tstring.scan(/\\[+\\]/).join.count('[') > 0\nend", "    stack = []\n\
    \    open = [\"[\"]\n    close = [\"]\"]\n    string.each_char do |c|\n      \
    \  if open.include?(c)\n            stack.push(c)\n        elsif close.include?(c)\n\
    \            return false if stack.empty?\n            popped = stack.pop\n  \
    \          return false if popped != open[close.index(c)]\n        end\n    end\n\
    \    return true\nend\nputs is_nested('[[]]')\nputs is_nested('[]]]]]]][[[[[]')\n\
    puts is_nested('[][]')\nputs is_nested('[]')\nputs is_nested('[[][]]')\nputs is_nested('[[]][[')\n\
    puts is_nested('[]]')", "\tstring.scan(/\\[+/).each do |b|\n\t\tstring.scan(/\\\
    ]+/).each do |r|\n\t\t\tif r.length == b.length\n\t\t\t\treturn true\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn false\nend\np is_nested('[[]]')\np is_nested('[]]]]]]][[[[[]')\n\
    p is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\np is_nested('[[]][[')",
  "    open = 0\n    close = 0\n    string.each_char do |char|\n        if char ==\
    \ \"[\"\n            open += 1\n        elsif char == \"]\"\n            close\
    \ += 1\n        end\n    end\n    if open == close\n        return false\n   \
    \ elsif open > close\n        return true\n    end\nend\np is_nested('[[]]')\n\
    p is_nested('[]]]]]]][[[[[]')\np is_nested('[][]')\np is_nested('[]')\np is_nested('[[][]]')\n\
    p is_nested('[[]][[')"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
