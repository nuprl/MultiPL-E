name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# Input: \n# grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n# bucket_capacity :\
  \ 1\n# Output: 6\n# Example 2:\n# Input: \n# grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]]\n# bucket_capacity : 2\n# Output: 5\n# Example 3:\n# Input: \n# grid\
  \ : [[0,0,0], [0,0,0]]\n# bucket_capacity : 5\n# Output: 0\n# Constraints:\n# *\
  \ all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid,\
  \ capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["  raise \"capacity can't be lower than 1\" if capacity < 1\n  n = grid.length\n\
    \  m = grid[0].length\n  ans = 0\n  for i in 0...n\n    for j in 0...m\n     \
    \ if grid[i][j] == 1\n        max = 0\n        for k in 0...m\n          if grid[i][k]\
    \ == 1\n            max += 1\n          else\n            max = 0\n          end\n\
    \        end\n        ans += 1 if max > 0\n        ans += (max - 1) / capacity\n\
    \      end\n    end\n  end\n  ans\nend", "  max_fill_level = 0\n  grid.each do\
    \ |row|\n    row.each do |element|\n      max_fill_level += element\n    end\n\
    \  end\n  max_fill_level\nend", "  num_rows = grid.length\n  num_cols = grid[0].length\n\
    \  grid_copy = Marshal.load(Marshal.dump(grid))\n  filled = 0\n  # fill rows\n\
    \  num_rows.times do |row|\n    num_cols.times do |col|\n      if grid_copy[row][col]\
    \ > 0\n        filled += capacity\n        grid_copy[row][col] = 0\n      end\n\
    \    end\n  end\n  num_rows.times do |row|\n    next if row == 0\n    num_cols.times\
    \ do |col|\n      if grid_copy[row][col] > 0\n        filled += capacity\n   \
    \     grid_copy[row][col] = 0\n      end\n    end\n  end\n  filled\nend", "  \
    \  # for each row, find the longest set of consecutive 1s\n    # then, take the\
    \ max of each row and multiply it by the number of rows\n    grid.max_by(&:length).count(1)\
    \ * grid.size\nend", '  max_row = grid.map { |r| r.max }.max', "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n \
    \ max_fill\nend", "  n = grid.size\n  res = 0\n  loop do\n    fill = [capacity]\
    \ * n\n    grid.each_with_index do |row, i|\n      break if fill[i] == 0\n   \
    \   row.each_with_index do |col, j|\n        break if fill[i] == 0\n        if\
    \ col == 1\n          grid[i][j] = 0\n          fill[i] -= 1\n        end\n  \
    \    end\n    end\n    return res if fill.all? { |f| f == 0 }\n    res += 1\n\
    \  end\nend", "  row_count, col_count = grid.size, grid[0].size\n  result = 0\n\
    \  (0...row_count).each do |i|\n    # find the first column to fill\n    start_index\
    \ = -1\n    (0...col_count).each do |j|\n      if grid[i][j] == 1\n        start_index\
    \ = j\n        break\n      end\n    end\n    # exit if the current row has no\
    \ water to fill\n    next if start_index == -1\n    # fill the buckets in current\
    \ row\n    (start_index...col_count).each do |j|\n      result += 1 if grid[i][j]\
    \ == 1\n    end\n    # fill the buckets in the rows below\n    (i+1...row_count).each\
    \ do |k|\n      # find the first column to fill\n      start_index = -1\n    \
    \  (0...col_count).each do |j|\n        if grid[k][j] == 1\n          start_index\
    \ = j\n          break\n        end\n      end\n      # exit if the current row\
    \ has no water to fill\n      next if start_index == -1\n      # fill the buckets\
    \ in current row\n      (start_index...col_count).each do |j|\n        result\
    \ += 1 if grid[k][j] == 1\n      end\n    end\n  end\n  result\nend", "  ans =\
    \ 0\n  for r in 0...grid.length\n    for c in 0...grid[r].length\n      if grid[r][c]\
    \ == 1\n        ans += capacity - 1\n        break\n      end\n    end\n  end\n\
    \  ans\nend", "  grid.map { |row| row.sum }.max\nend", "  max_fill_util(grid,\
    \ capacity, 0, 0, grid.length, grid[0].length)\nend", "  num_rows = grid.length\n\
    \  num_cols = grid[0].length\n  result = num_rows * num_cols\n  puts \"result\
    \ before: #{result}\"\n  # go over each row\n  grid.each do |row|\n    water_units\
    \ = row.inject(:+)\n    result += (water_units / capacity)\n    # puts \"result\
    \ after: #{result}\"\n  end\n  result\nend", "  return 0 if grid.empty?\n  rows,\
    \ cols = grid.size, grid[0].size\n  return 0 if rows == 0 || cols == 0\n  return\
    \ 0 if capacity == 0\n  # Init buckets\n  buckets = Array.new(cols, 0)\n  # Loop\
    \ through rows\n  count = 0\n  rows.times do |i|\n    # Fill the buckets\n   \
    \ cols.times do |j|\n      buckets[j] += grid[i][j]\n      count += 1 if buckets[j]\
    \ == capacity\n      buckets[j] = 0 if buckets[j] > capacity\n    end\n  end\n\
    \  count\nend", "    m = grid.length\n    n = grid[0].length\n    cost = Array.new(m)\
    \ { Array.new(n, 0) }\n    cost[0][0] = grid[0][0]\n    (1...n).each { |j| cost[0][j]\
    \ = cost[0][j-1] + grid[0][j] }\n    (1...m).each { |i| cost[i][0] = cost[i-1][0]\
    \ + grid[i][0] }\n    (1...m).each do |i|\n        (1...n).each do |j|\n     \
    \       cost[i][j] = [cost[i-1][j], cost[i][j-1]].max + grid[i][j]\n        end\n\
    \    end\n    total = cost[m-1][n-1]\n    if total == 0\n        return 0\n  \
    \  end\n    ceil = (total / capacity.to_f).ceil\n    ceil\nend", "  sum = 0\n\
    \  grid.each do |row|\n    max = 0\n    row.each do |well|\n      if well > max\n\
    \        max = well\n      end\n    end\n    sum += (max / capacity)\n    sum\
    \ += 1 if max % capacity > 0\n  end\n  sum\nend", "  return 0 if capacity >= grid.inject(0){|sum,\
    \ row| sum += row.inject(0){|sum2, cell| sum2 += cell}}\n  m = grid.length\n \
    \ n = grid[0].length\n  fill_count = 0\n  loop do\n    i = 0\n    j = 0\n    max_fill\
    \ = 0\n    max_fill_ij = []\n    min_fill = capacity + 1\n    min_fill_ij = []\n\
    \    (0...m).each do |i|\n      (0...n).each do |j|\n        fill = 0\n      \
    \  fill += grid[i][j]\n        fill += grid[i][j-1] if j > 0\n        fill +=\
    \ grid[i][j+1] if j < n-1\n        fill += grid[i-1][j] if i > 0\n        fill\
    \ += grid[i+1][j] if i < m-1\n        max_fill, max_fill_ij = fill, [i,j] if fill\
    \ > max_fill\n        min_fill, min_fill_ij = fill, [i,j] if fill < min_fill &&\
    \ fill > 0\n      end\n    end\n    break if max_fill == 0\n    i, j = max_fill_ij\n\
    \    grid[i][j] = 0\n    grid[i][j-1] = 0 if j > 0\n    grid[i][j+1] = 0 if j\
    \ < n-1\n    grid[i-1][j] = 0 if i > 0\n    grid[i+1][j] = 0 if i < m-1\n    fill_count\
    \ += max_fill\n    grid[min_fill_ij[0]][min_fill_ij[1]] += capacity\n    fill_count\
    \ += 1\n  end\n  fill_count\nend", "  max_fill_count = 0\n  min_fill_count = 0\n\
    \  water_count = 0\n  # Get total water count\n  grid.each { |row| water_count\
    \ += row.count(1) }\n  # Get no. of max fill actions\n  max_fill_count = water_count\
    \ / capacity\n  # Get no. of min fill actions\n  min_fill_count = grid.transpose.count\
    \ { |col| col.count(1) == water_count }\n  max_fill_count + min_fill_count\nend",
  "  # return 0 if grid is empty\n  return 0 if grid.empty?\n  # put all water sums\
    \ in reverse order of the grid\n  sums = grid.map(&:sum).reverse\n  # init the\
    \ fill counter at 0\n  fills = 0\n  # loop until all the water is filled\n  while\
    \ !sums.all?{|x| x <= 0}\n    sums.length.times do |i|\n      if sums[i] > 0\n\
    \        sums[i] -= capacity\n        fills += 1\n      end\n    end\n  end\n\
    \  fills\nend", "  n = grid.size\n  m = grid[0].size\n  (n-1).downto(0).each do\
    \ |i|\n    grid[i][0,m] = grid[i][0,m].map { |e| (e == 1) ? capacity : 0 }\n \
    \   for j in 1...m\n      if grid[i][j] > 0\n        grid[i][j] = grid[i][j] +\
    \ grid[i][j-1]\n        grid[i][j] = capacity if grid[i][j] > capacity\n     \
    \ end\n    end\n    for j in (m-2).downto(0)\n      if grid[i][j] > 0\n      \
    \  grid[i][j] = grid[i][j] + grid[i][j+1]\n        grid[i][j] = capacity if grid[i][j]\
    \ > capacity\n      end\n    end\n  end\n  grid\nend", "    max = 0\n    grid.each\
    \ do |row|\n        row.each do |e|\n            max = e if e > max\n        end\n\
    \    end\n    max = [max, capacity].min\n    max\nend", "  # get the \"max height\"\
    \ column-wise\n  max_height = Array.new(grid[0].length, 0)\n  grid.each do |row|\n\
    \    row.each_with_index do |col, i|\n      max_height[i] = [max_height[i], col].max\n\
    \    end\n  end\n  # get the prefix sum, so that we can get the number of ones\
    \ needed for each height (1..max_height)\n  prefix_sum = max_height.each_with_index.map\
    \ { |e, i| max_height[0..i].inject(:+) }\n  # for each height, get the number\
    \ of ones needed and divide by the capacity\n  # if the number of ones needed\
    \ is more than the capacity, we have to lower it multiple times,\n  # so we add\
    \ 1 to the result\n  # we can use the prefix sum to get the number of ones needed\n\
    \  (1..max_height.max).inject(0) { |sum, e| sum + ((prefix_sum[e - 1] || 0) +\
    \ capacity - 1) / capacity }\nend", "  grid.map { |row|\n    row.map { |cell|\n\
    \      # cell / capacity = how many buckets for this cell\n      # if cell % capacity\
    \ > 0 -> need an extra bucket\n      (cell / capacity) + (cell % capacity == 0\
    \ ? 0 : 1)\n    }.max\n  }.min\nend", "  grid.map { |row| row.reduce(:+) / capacity\
    \ }.reduce(:+)\nend", "    max_fill = 0\n    grid.each do |well|\n        max_fill\
    \ = [max_fill, well.count(1)].max\n    end\n    max_fill > capacity ? max_fill\
    \ : 0\nend", "  return 0 if grid.empty?\n  max_num = capacity\n  ans = 0\n  grid.each\
    \ do |arr|\n    ans += 1 if arr.include?(1)\n    max_num = [max_num, arr.max].min\n\
    \  end\n  ans * max_num\nend", "  grid.map! { |row| row.map { |e| e * capacity\
    \ } }\n  min_in_rows = grid.map { |row| row.min }\n  min_in_cols = grid.transpose.map\
    \ { |col| col.min }\n  moves = 0\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |cell, j|\n      water = (min_in_rows[i] < min_in_cols[j]) ? min_in_rows[i]\
    \ : min_in_cols[j]\n      moves += water\n      cell -= water\n    end\n  end\n\
    \  moves\nend", "  row_size = grid.size\n  col_size = grid[0].size\n  times =\
    \ 0\n  capacity = capacity\n  row_size.times do |row|\n    capacity_to_fill =\
    \ capacity\n    until capacity_to_fill <= 0\n      capacity_to_fill = fill_capacity(grid,\
    \ row, capacity_to_fill)\n      break if capacity_to_fill <= 0\n      times +=\
    \ 1\n    end\n  end\n  times\nend", "  filled = 0\n  max_grid = 0\n  grid.each\
    \ do |row|\n    row.each do |value|\n      filled += value\n      if filled >\
    \ capacity\n        return max_grid\n      end\n    end\n    max_grid += 1\n \
    \ end\n  max_grid\nend", "  buckets = 0\n  max_height = 0\n  max_height_count\
    \ = 0\n  max_row = 0\n  max_row_count = 0\n  number_of_rows = grid.length\n  number_of_columns\
    \ = grid[0].length\n  number_of_rows.times do |row|\n    number_of_columns.times\
    \ do |column|\n      if grid[row][column] > max_height\n        max_height = grid[row][column]\n\
    \        max_height_count = 1\n      elsif grid[row][column] == max_height\n \
    \       max_height_count += 1\n      end\n      if grid[row].sum > max_row\n \
    \       max_row = grid[row].sum\n        max_row_count = 1\n      elsif grid[row].sum\
    \ == max_row\n        max_row_count += 1\n      end\n    end\n  end\n  until max_height\
    \ == 0\n    buckets += max_height_count\n    max_height -= 1\n  end\n  until max_row\
    \ == 0\n    buckets += max_row_count\n    max_row -= capacity\n  end\n  buckets\n\
    end", "  water_needed = grid.sum\n  return water_needed / capacity if water_needed\
    \ % capacity == 0\n  water_needed / capacity + 1\nend", "  max_fill_value = 0\n\
    \  grid.each do |row|\n    row.each do |cell|\n      if cell > max_fill_value\n\
    \        max_fill_value = cell\n      end\n    end\n  end\n  return max_fill_value\n\
    end", "  # grid = grid.map(&:clone)\n  # row_capacity = grid.map { |a| a.reduce(:+)\
    \ }\n  # prev_rows = Array.new(grid.length) { Array.new(grid[0].length, 0) }\n\
    \  # new_rows = Array.new(grid.length) { Array.new(grid[0].length, 0) }\n  # count\
    \ = 0\n  # row_capacity.reduce(:+).times do\n  #   row_capacity.each_with_index\
    \ do |rc, i|\n  #     next if rc <= 0\n  #     max_bucket = (rc > capacity) ?\
    \ capacity : rc\n  #     grid[i].each_with_index do |v, j|\n  #       next if\
    \ v == 0\n  #       new_rows[i][j] = max_bucket\n  #       grid[i][j] -= max_bucket\n\
    \  #       rc -= max_bucket\n  #       break if rc <= 0\n  #     end\n  #   end\n\
    \  #   new_rows.each_with_index do |row, i|\n  #     row.each_with_index do |v,\
    \ j|\n  #       unless prev_rows[i][j] == 0\n  #         new_rows[i][j] = 0\n\
    \  #         next\n  #       end\n  #       if i != new_rows.length - 1\n  # \
    \        new_rows[i+1][j] += v\n  #         new_rows[i][j] = 0\n  #       end\n\
    \  #     end\n  #   end\n  #   prev_rows = new_rows.map(&:clone)\n  #   count\
    \ += 1\n  # end\n  # count\n  grid = grid.map(&:clone)\n  capacity = capacity\n\
    \  depth = grid.length\n  width = grid[0].length\n  # count = 0\n  # depth.times\
    \ do\n  #   grid = grid.transpose\n  #   grid.each_with_index do |col, i|\n  #\
    \     next if col.reduce(:+) == 0\n  #     max_bucket = (col", "  buckets = grid.map\
    \ { |row| row.reduce(:+) }\n  buckets.reduce(0) { |acc, bucket| acc + (bucket\
    \ + capacity - 1) / capacity }\nend", "  # Return 0 if there are no wells to empty.\n\
    \  return 0 if grid.all?{|well| well.none?{|unit| unit == 1}}\n  # First, determine\
    \ the number of wells.\n  num_wells = grid.length\n  # Next, determine the longest\
    \ well in this grid.\n  well_length = grid.max_by{|well| well.length}.length\n\
    \  # Next, determine the number of units of water we can move in one well.\n \
    \ units_per_well = capacity * num_wells\n  # Determine the number of full rows\
    \ we can empty.\n  full_rows = grid.count{|well| well.all?{|unit| unit == 1}}\n\
    \  # Next, determine the number of units that can be moved in these full rows.\n\
    \  units_per_full_row = units_per_well * full_rows\n  # Finally, determine the\
    \ number of times we need to move buckets.\n  operations = (well_length * units_per_full_row)\
    \ / units_per_well\n  return operations\nend", "  max = 0\n  row_h = 0\n  col_h\
    \ = 0\n  grid.each do |row|\n    row_h = row.count(1) if row.count(1) > row_h\n\
    \  end\n  grid.transpose.each do |col|\n    col_h = col.count(1) if col.count(1)\
    \ > col_h\n  end\n  [row_h, col_h].max\nend", "  height = grid.length\n  fill_size\
    \ = 0\n  for row in grid\n    for cell in row\n      if cell == 1\n        fill_size\
    \ += 1\n      end\n    end\n  end\n  return 0 if fill_size == 0\n  fill_size =\
    \ (fill_size + height - 1) / height\n  return height * fill_size\nend", "  max\
    \ = 0\n  grid.each do |row|\n    water = 0\n    row.each do |cell|\n      water\
    \ += cell\n      if water > capacity\n        water = capacity\n      end\n  \
    \  end\n    max = water if water > max\n  end\n  max\nend", "  return 0 if grid.nil?\
    \ || grid.empty?\n  grid.map!{|row| row.map{|val| val * capacity}}\n  max = 0\n\
    \  grid.each do |row|\n    max = [max, row.reduce(:+)].max\n  end\n  max\nend",
  "  max_depth = 0\n  (0...grid.length).each do |r|\n    (0...grid[r].length).each\
    \ do |c|\n      if grid[r][c] > 0\n        max_depth = grid[r][c]\n        break\n\
    \      end\n    end\n  end\n  max_depth * capacity\nend", "  return 0 if grid.empty?\n\
    \  rows = grid.size\n  cols = grid[0].size\n  fill_count = 0\n  0.upto(rows -\
    \ 1) do |i|\n    0.upto(cols - 1) do |j|\n      num_units = grid[i][j]\n     \
    \ while num_units > 0\n        fill_count += 1\n        num_units -= capacity\n\
    \      end\n    end\n  end\n  fill_count\nend", "  return 0 if grid.size < 1 ||\
    \ grid[0].size < 1\n  return 0 if capacity < 1\n  min_row = grid.min_by(&:size).size\n\
    \  fill_times = 0\n  min_row.times do |col|\n    grid.each_with_index do |row,\
    \ row_idx|\n      if row[col] == 1\n        grid[row_idx][col] = 0\n        fill_times\
    \ += 1\n      end\n    end\n  end\n  fill_times\nend", "  # construct a histogram\
    \ array\n  # find maximum of histogram\n  # subtract capacity from all elements\
    \ in histogram\n  # repeat\n  grid.inject(0) do |max, row|\n    sum = row.inject(0)\
    \ { |sum, x| sum + x }\n    max < sum ? sum : max\n  end\nend", "  return 0 if\
    \ grid.empty?\n  grid.map! { |row| row.reduce(:+) }\n  grid.reduce(&:+)\nend",
  "  m = grid.size\n  n = grid[0].size\n  row_maxes = Array.new(m, 0)\n  for i in\
    \ 0...m\n    for j in 0...n\n      row_maxes[i] = grid[i][j] if grid[i][j] > row_maxes[i]\n\
    \    end\n  end\n  col_maxes = Array.new(n, 0)\n  for j in 0...n\n    for i in\
    \ 0...m\n      col_maxes[j] = grid[i][j] if grid[i][j] > col_maxes[j]\n    end\n\
    \  end\n  i = 0\n  j = 0\n  count = 0\n  while i < m && j < n\n    row_max = row_maxes[i]\n\
    \    col_max = col_maxes[j]\n    if row_max < col_max\n      count += row_max\n\
    \      i += 1\n    else\n      count += col_max\n      j += 1\n    end\n  end\n\
    \  return count\nend", '  return 0 if grid.empty?', "  total = 0\n  (0...grid.length).each\
    \ do |row|\n    remaining = capacity\n    (0...grid[row].length).each do |col|\n\
    \      break if remaining == 0\n      if grid[row][col] == 1\n        remaining\
    \ -= 1\n        grid[row][col] = 0\n      end\n    end\n    total += capacity\
    \ - remaining\n  end\n  total\nend\ngrid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n\
    capacity = 1\nputs max_fill(grid, capacity)\ngrid = [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]]\ncapacity = 2\nputs max_fill(grid, capacity)\ngrid = [[0,0,0], [0,0,0]]\n\
    capacity = 5\nputs max_fill(grid, capacity)", "  rows = grid.length\n  columns\
    \ = grid[0].length\n  buckets = rows\n  well_tokens = Array.new(rows) { Array.new(columns,\
    \ 0) }\n  loop do\n    # Fill buckets.\n    buckets.times do |i|\n      buckets.times\
    \ do |j|\n        if well_tokens[i][j] > 0\n          # Empty tokens.\n      \
    \    well_tokens[i][j] -= 1\n          # Distribute tokens.\n          columns.times\
    \ do |jj|\n            if well_tokens[i][jj] < capacity\n              well_tokens[i][jj]\
    \ += 1\n              break\n            end\n          end\n        end\n   \
    \   end\n    end\n    break if well_tokens.none? { |well| well.any? { |token|\
    \ token > 0 } }\n  end\n  well_tokens.flatten.count(0)\nend", "  grid.flatten.inject(0)\
    \ { |acc, fill| acc += capacity - fill }\nend", "  # we'll need the number of\
    \ columns (number of wells)\n  wells = grid[0].length\n  # the number of rows\
    \ (number of times we are going to lower the buckets)\n  drops = grid.length\n\
    \  # the maximum units of water we can extract in a single drop (the bucket capacity)\n\
    \  cap = capacity\n  # the minimum water we can extract in a single drop (the\
    \ minimum water level in a well)\n  min = grid.map { |row| row.min }.min\n  #\
    \ the maximum water we can extract in a single drop (the maximum water level in\
    \ a well)\n  max = grid.map { |row| row.max }.max\n  # if the maximum water level\
    \ is lower than the bucket capacity, we can't extract any water\n  return 0 if\
    \ max < cap\n  # the number of times we need to lower the buckets is the number\
    \ of rows\n  times = drops\n  # we can at least extract the minimum water level\
    \ in each well\n  fill = min * wells\n  # try to extract more water in a single\
    \ drop\n  while cap <= max\n    # the number of buckets we need to extract the\
    \ maximum water in a single drop\n    more = grid.inject(0) { |a, row| a + row.count(cap)\
    \ }\n    # if there is water in at least one well we can extract, we can do that\
    \ in a single drop\n    if more > 0\n      # increase the amount of water we can\
    \ extract\n      fill += more * cap\n      # decrease the number of drops\n  \
    \    times -= 1\n    end\n    # we are going to extract less water\n    cap -=\
    \ 1\n  end\n  # we can't extract water from the wells, return 0\n  return 0 if\
    \ fill == 0\n  # return the minimum number of drops we need to empty the wells\n\
    \  return times\nend", "  length = grid.length\n  width = grid[0].length\n  row_maxes\
    \ = grid.map { |row| row.max }\n  row_maxes.each_with_index.map do |row_max, row_index|\n\
    \    row_max - capacity\n  end.inject(:+)\nend", "  rows, columns = grid.size,\
    \ grid[0].size\n  # fill grid:\n  #   - a value of (1..capacity) represents the\
    \ amount of water in the well\n  #   - 0 means the well is empty\n  #   - -1 means\
    \ the well is full\n  (0...rows).each do |row|\n    (0...columns).each do |column|\n\
    \      grid[row][column] = grid[row][column] == 1 ? 1 : 0\n    end\n  end\n  #\
    \ 1st pass: fill with water until full\n  total_fill = 0\n  while total_fill <\
    \ rows * columns\n    (0...rows).each do |row|\n      (0...columns).each do |column|\n\
    \        next if grid[row][column] == -1\n        grid[row][column] += 1\n   \
    \     total_fill += 1\n        grid[row][column] = -1 if grid[row][column] ==\
    \ capacity\n      end\n    end\n  end\n  # 2nd pass: drain until full\n  total_fill\
    \ = 0\n  while total_fill < rows * columns\n    (0...rows).each do |row|\n   \
    \   (0...columns).each do |column|\n        next if grid[row][column] == -1\n\
    \        grid[row][column] -= 1\n        total_fill += 1\n        grid[row][column]\
    \ = -1 if grid[row][column] == 0\n      end\n    end\n  end\n  # 3rd pass: count\
    \ the number of times we filled the well\n  total_fill = 0\n  (0...rows).each\
    \ do |row|\n    (0...columns).each do |column|\n      next if grid[row][column]\
    \ == 0\n      total_fill += 1\n    end\n  end\n  total_fill\nend", "  # 0.5 *\
    \ [sum(column) / capacity] * capacity\n  (grid.map { |r| r.sum }.sum.to_f / capacity.to_f).ceil\
    \ * capacity\nend", "  depths = []\n  rows = grid.length\n  cols = grid[0].length\n\
    \  # create one-dimensional array of well depths\n  (0...rows).each do |r|\n \
    \   (0...cols).each do |c|\n      depths << grid[r][c]\n    end\n  end\n  # sort\
    \ depths\n  depths.sort!\n  # start with the deepest well\n  max_depth = depths.pop\n\
    \  total_lowers = 0\n  # decrement max_depth until empty\n  while max_depth >\
    \ 0\n    # \"lower\" bucket into well\n    max_depth -= capacity\n    total_lowers\
    \ += 1\n    # next deepest well\n    max_depth = depths.pop if max_depth < 0\n\
    \  end\n  total_lowers\nend", "  # fill each well until the max capacity\n  num_buckets\
    \ = 0\n  grid.each do |row|\n    next if row.size < capacity\n    num_buckets\
    \ += row.chunk { |x| x }.select { |e, v| e == 1 }.map { |e, v| (v.size / capacity.to_f).ceil\
    \ }.sum\n  end\n  num_buckets\nend", "  # put your code here\nend", "  bucket\
    \ = Array.new(grid.length, 0)\n  count = 0\n  while bucket.min < capacity\n  \
    \  bucket.each_with_index do |b, i|\n      if b < capacity\n        bucket[i]\
    \ += 1\n        grid[i].shift\n      end\n    end\n    count += 1\n  end\n  count\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.inject(:+)].max\n\
    \  end\n  [[max_fill, capacity].min, 0].max\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    row.each do |cell|\n      max_fill += capacity if cell == 1\n\
    \    end\n  end\n  max_fill\nend", "    max_filled = 0\n    (0...grid.length).each\
    \ do |r|\n        max_in_row = 0\n        (0...grid[r].length).each do |c|\n \
    \           if grid[r][c] == 1\n                max_in_row += 1\n            else\n\
    \                max_filled = [max_filled, max_in_row].max\n                max_in_row\
    \ = 0\n            end\n        end\n        max_filled = [max_filled, max_in_row].max\n\
    \    end\n    max_filled\nend", "  max_in_columns = []\n  grid.each do |row|\n\
    \    row.each_with_index do |column, index|\n      max_in_columns[index] = [max_in_columns[index]\
    \ || 0, column].max\n    end\n  end\n  max_in_columns.reduce(0) { |sum, max| sum\
    \ + max / capacity }\nend", "  # grid = grid.map{|row| row.unshift(0)}\n  # max_fill\
    \ = (grid.flatten.max / capacity).ceil\n  # fill = 0\n  # while fill < max_fill\n\
    \  #   grid.each_with_index do |row, i|\n  #     row.each_with_index do |col,\
    \ j|\n  #       grid[i][j] -= 1 if grid[i][j] > 0\n  #     end\n  #   end\n  #\
    \   fill += 1\n  # end\n  max_fill = (grid.flatten.max / capacity).ceil\n  buckets\
    \ = grid.length * capacity\n  if buckets > 0\n    buckets / max_fill\n  else\n\
    \    0\n  end\nend", "  max_fill = 0\n  grid.each do |well|\n    filled = 0\n\
    \    well.each do |water|\n      if water == 1\n        filled += 1\n      end\n\
    \      if filled == capacity\n        max_fill += 1\n        filled = 0\n    \
    \  end\n    end\n    max_fill += 1 if filled > 0\n  end\n  max_fill\nend", " \
    \   # A grid of size n x m, we can fill a column in at most n times\n    # so\
    \ we need to find the max column and fill it in n times\n    column_max = [0]\
    \ * grid[0].length\n    grid.each do |row|\n        row.each_with_index do |num,\
    \ col|\n            column_max[col] += num\n        end\n    end\n    max_col\
    \ = column_max.index(column_max.max)\n    grid.map { |row| row[max_col] * capacity\
    \ }.inject(:+)\nend", "  grid.map! { |row| row.map { |element| element == 1 ?\
    \ 0 : element } }\n  movements = 0\n  buckets = Array.new(grid[0].length, capacity)\n\
    \  loop do\n    buckets_empty = buckets.select { |bucket| bucket == 0 }.length\n\
    \    break if buckets_empty == buckets.length\n    (0...grid.length).each do |i|\n\
    \      (0...grid[i].length).each do |j|\n        grid[i][j] = [grid[i][j], buckets[j]].min\n\
    \        buckets[j] -= grid[i][j]\n      end\n    end\n    movements += 1\n  end\n\
    \  movements\nend", "  max_fill = 0\n  grid.each do |row|\n    curr_fill = row.reduce(0,\
    \ :+)\n    max_fill = curr_fill if curr_fill > max_fill\n  end\n  max_fill\nend",
  "  capacity < 0 and return 0\n  if grid.all? { |row| row.all? { |e| e == 0 } }\n\
    \    return 0\n  end\n  # find the max full well and empty it\n  max_well = 0\n\
    \  max_i = 0\n  max_j = 0\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |e, j|\n      if e > max_well\n        max_well = e\n        max_i = i\n\
    \        max_j = j\n      end\n    end\n  end\n  [grid, capacity].tap do |args|\n\
    \    args[0][max_i][max_j] = 0\n    args[1] -= 1\n  end\n  1 + max_fill(grid,\
    \ capacity)\nend", "  max_fill = 0\n  grid.each do |row|\n    row.each do |col|\n\
    \      max_fill = col if col > max_fill\n    end\n  end\n  max_fill\nend", " \
    \ row_count = grid.length\n  col_count = grid[0].length\n  grid_max = Array.new(row_count)\
    \ { Array.new(col_count, 0) }\n  row_idx = col_idx = 0\n  max_bucket_height =\
    \ 0\n  # max_bucket_height = row_count\n  # top, right, bottom, left\n  directions\
    \ = [\n    [ 0,  1],\n    [ 1,  0],\n    [ 0, -1],\n    [-1,  0]\n  ]\n  while\
    \ true\n    row_idx = col_idx = 0\n    max_bucket_height = 0\n    grid_max.each\
    \ do |row|\n      row.each do |col|\n        if col == 0\n          break\n  \
    \      end\n        max_bucket_height += 1\n      end\n    end\n    # puts \"\
    max_bucket_height: #{max_bucket_height}\"\n    if max_bucket_height == 0\n   \
    \   break\n    end\n    max_bucket_height.times do |level|\n      break if row_idx\
    \ >= row_count || col_idx >= col_count\n      grid[row_idx][col_idx] -= 1\n  \
    \    grid_max[row_idx][col_idx] += 1\n      # print \"grid[#{row_idx}][#{col_idx}]:\
    \ #{grid[row_idx][col_idx]}\\n\"\n      directions.each do |direction|\n     \
    \   direction_row_idx = row_idx + direction[0]\n        direction_col_idx = col_idx\
    \ + direction[1]\n        if direction_row_idx >= 0 && direction_row_idx < row_count\
    \ && direction_col_idx >= 0 && direction_col_idx < col_count\n          if grid[direction_row_idx][direction_col_idx]\
    \ > 0\n            grid[direction_row_idx][direction_col_idx] -= 1\n         \
    \   grid_max[direction_row_idx][direction_col_idx] += 1\n            # print \"\
    grid[#", "  min_height = 0\n  max_height = 0\n  grid.each { |row|\n    max_height\
    \ = row.max if row.max > max_height\n  }\n  return 0 if max_height == 0\n  max_height\
    \ = [capacity, max_height].min\n  min_height = [0, max_height - capacity].max\n\
    \  min_height\nend", "  len, wid = grid.length, grid[0].length\n  total = 0\n\
    \  wid.times do |j|\n    # fill up buckets\n    row = 0\n    len.times do |i|\n\
    \      break if row >= capacity\n      row += grid[i][j]\n    end\n    if row\
    \ >= capacity\n      # upper water will overflow\n      wid.times do |jj|\n  \
    \      grid[len - 1][jj] = [capacity, grid[len - 1][jj]].min\n      end\n    \
    \  total += 1\n    else\n      # water will not overflow\n      wid.times do |j|\n\
    \        grid[row - 1][j] = [capacity, grid[row - 1][j]].min\n      end\n    \
    \  total += 1\n    end\n  end\n  total\nend", "  r = grid.size\n  c = grid[0].size\n\
    \  total = 0\n  r.times do |i|\n    (0...c).each do |j|\n      total += grid[i][j]\n\
    \    end\n  end\n  bucket_count = (total / capacity.to_f).ceil\n  r.times do |i|\n\
    \    (0...c).each do |j|\n      grid[i][j] -= capacity\n    end\n  end\n  bucket_count\n\
    end", "  res = 0\n  grid.each do |row|\n    row_max = row.max\n    row_max.times\
    \ do\n      row.map! { |c| c - capacity }\n      res += 1\n    end\n  end\n  res\n\
    end", "  puts \"max_fill(#{grid}, #{capacity})\"\n  return if grid.empty?\n  current_max\
    \ = 0\n  grid.each do |row|\n    current_max = row.sum if row.sum > current_max\n\
    \  end\n  current_max / capacity\nend", "  # puts \"grid: #{grid}\"\n  # puts\
    \ \"capacity: #{capacity}\"\n  # Let's start by computing the max fill for each\
    \ row\n  row_capacities = []\n  grid.each do |row|\n    # puts \"    row: #{row}\"\
    \n    max_fill = 0\n    (0...row.length).each do |col|\n      # puts \"      col:\
    \ #{col}\"\n      if row[col] == 1\n        if max_fill + 1 <= capacity\n    \
    \      max_fill += 1\n        else\n          row_capacities << max_fill\n   \
    \       max_fill = 0\n        end\n      end\n    end\n    row_capacities << max_fill\n\
    \  end\n  # puts \"row_capacities: #{row_capacities}\"\n  # Then, compute the\
    \ max fill over the row_capacities\n  max_fill = 0\n  row_capacities.each do |capacity|\n\
    \    # puts \"  capacity: #{capacity}\"\n    if max_fill + capacity <= capacity\n\
    \      max_fill += capacity\n    else\n      max_fill = capacity\n    end\n  end\n\
    \  # puts \"max_fill: #{max_fill}\"\n  max_fill\nend", "  # compute the max value\
    \ of each row\n  # we can fill the entire row with that value\n  # and it counts\
    \ as one operation\n  rows = grid.map { |row| row.max }\n  num_rows = rows.length\n\
    \  # sort the rows by their max value\n  # we will greedily fill them in descending\
    \ order\n  # so that we make the least number of passes\n  sorted_rows = rows.zip(Array.new(num_rows).map.with_index\
    \ { |_, i| i }).sort.reverse\n  # the total number of times we lowered the bucket\n\
    \  num_lowerings = 0\n  # the number of wells filled by the last lowering\n  last_lowering_num_fills\
    \ = 0\n  # keep looping until all wells are filled\n  while (sorted_rows.any?\
    \ { |max_fill, i| max_fill > 0 })\n    # check how many wells we can fill with\
    \ this lowering\n    num_fills = 0\n    sorted_rows.each do |max_fill, i|\n  \
    \    # stop if we can't fill any more wells\n      break if max_fill <= 0\n  \
    \    num_fills += 1\n      # lower the bucket\n      sorted_rows[i][0] -= capacity\n\
    \    end\n    # if we filled at least one more well than last time\n    # then\
    \ this counts as a lowering\n    num_lowerings += 1 if num_fills > last_lowering_num_fills\n\
    \    last_lowering_num_fills = num_fills\n  end\n  num_lowerings\nend", "  grid.map\
    \ { |row| row.sum }.max / capacity\nend", "  # if there are no wells, then no\
    \ fills are needed\n  return 0 if grid.empty?", "  water_in_bucket = 0\n  grid.each\
    \ do |row|\n    row.each do |fill|\n      water_in_bucket += fill\n      if water_in_bucket\
    \ >= capacity\n        return capacity\n      end\n    end\n  end\n  water_in_bucket\n\
    end", "  return 0 if grid.empty? || grid[0].empty?\n  m, n = grid.size, grid[0].size\n\
    \  i, j = 0, 0\n  count = 0\n  while i < m && j < n\n    while j < n && grid[i][j]\
    \ == 0\n      j += 1\n    end\n    return count if j == n\n    count += capacity\n\
    \    j += 1\n  end\n  return count\nend\ngrid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n\
    capacity = 1\np max_fill(grid, capacity)\ngrid = [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]]\ncapacity = 2\np max_fill(grid, capacity)\ngrid = [[0,0,0], [0,0,0]]\n\
    capacity = 5\np max_fill(grid, capacity)", "  return 0 if grid.empty? || grid[0].empty?\
    \ || capacity <= 0\n  return grid.reduce(0) { |acc, row| acc + row.reduce(0) {\
    \ |acc, column| acc + column }} if capacity >= grid.length", "  max = 0\n  grid.each\
    \ do |row|\n    count = 0\n    row.each do |water|\n      count += water\n   \
    \   if count == capacity\n        max += 1\n        count = 0\n      end\n   \
    \ end\n    max += 1 if count > 0\n  end\n  max\nend", "    height = grid.length\n\
    \    width = grid[0].length\n    running_sum = 0\n    water_count = 0\n    running_max\
    \ = 0\n    0.upto(height - 1) do |y|\n        0.upto(width - 1) do |x|\n     \
    \       # find the maximum row that can be filled\n            # with the given\
    \ bucket\n            water_count += grid[y][x]\n            if y == height -\
    \ 1 || grid[y][x] == 0\n                if water_count > 0\n                 \
    \   # all the preceding wells can be filled,\n                    # but the current\
    \ well cannot be filled\n                    running_sum += water_count\n    \
    \                running_max = [running_max, running_sum].max\n              \
    \      running_sum = 0\n                else\n                    # the current\
    \ well can be filled\n                    running_sum += water_count\n       \
    \         end\n                water_count = 0\n            end\n        end\n\
    \    end\n    bucket_fill_count = (running_max / capacity).floor\n    bucket_fill_count\
    \ += 1 if running_max % capacity > 0\n    return bucket_fill_count\nend", "  max_fill\
    \ = grid.map do |row|\n    count = 0\n    row.each do |cell|\n      count += cell\n\
    \    end\n    count\n  end.max\n  max_fill + capacity - 1\nend", "  # -----------------------------------------------------------\n\
    \  # max_fill(g,c) = number of times you need to lower the buckets\n  # g = grid\n\
    \  # c = capacity\n  # calculate the number of buckets needed to fill each well\n\
    \  # -----------------------------------------------------------\n  # Pseudo\n\
    \  # -----------------------------------------------------------\n  # 1. transform\
    \ g into an array of fills for each well\n  #    [1,1,2,0,0,0,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1",
  "  # total number of 1s (non-zero) in the grid\n  ones = grid.map { |row| row.reduce(:+)\
    \ }.reduce(:+)\n  [capacity, ones].min\nend", "  row_1 = grid[0]\n  all_wet =\
    \ grid.length\n  row_1.map! do |cell|\n    cell == 1 ? capacity : 0\n  end\n \
    \ filled = row_1.sum\n  buckets = row_1.length\n  (1...grid.length).each do |r|\n\
    \    row = grid[r]\n    (0...row.length).each do |c|\n      if row[c] == 1\n \
    \       if row_1[c] > 0\n          row_1[c] -= 1\n          filled += 1\n    \
    \    else\n          all_wet -= 1\n        end\n      end\n    end\n  end\n  return\
    \ 0 if all_wet == 0\n  buckets * all_wet - filled\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    row.each do |val|\n      max_fill += capacity if val == 1\n  \
    \  end\n  end\n  max_fill\nend", "  grid.flatten.sort.reverse[0, capacity].sum\n\
    end", "    @wells = []\n    rows = grid.length\n    columns = grid[0].length\n\
    \    return 0 if rows == 0 || columns == 0\n    @wells = grid\n    @capacity =\
    \ capacity\n    @rows = rows\n    @columns = columns\n    @empty_levels = {}\n\
    \    @times = 0\n    return @times if @wells.all?{|x| x.all?{|y| y == 0}}\n  \
    \  # fill the lower row\n    for i in 0...@columns\n        if @wells[0][i] ==\
    \ 1\n            @wells[0][i] = 0\n            @times += 1\n        end\n    end\n\
    \    # traverse the array upwards\n    for i in 1...@rows\n        # calculate\
    \ the empty levels\n        @empty_levels[i] = find_empty_level(i)\n        #\
    \ move water to the empty levels\n        move_water(i)\n    end\n    @times\n\
    end", "  max = 0\n  grid.each do |row|\n    row.each_with_index do |col, j|\n\
    \      max = row[j+1] if j < (row.length - 1) && row[j+1] && row[j+1] > max\n\
    \    end\n  end\n  [max, capacity].min\nend", "  rows = grid.length\n  cols =\
    \ grid[0].length\n  # each row has a count of water.\n  # each col also has a\
    \ count of water.\n  (0...rows).each do |row|\n    (0...cols).each do |col|\n\
    \      grid[row][col] = water_in_row(grid, row, col, capacity)\n    end\n  end\n\
    \  return water_in_cols(grid, capacity)\nend", "  max_volume = 0\n  n = grid.length\n\
    \  m = grid[0].length\n  0.upto(n - 1) do |i|\n    0.upto(m - 1) do |j|\n    \
    \  max_volume = (max_volume + grid[i][j]).max\n    end\n  end\n  max_volume /\
    \ capacity\nend", "  max = 0\n  grid.each do |row|\n    row.each_with_index do\
    \ |col, i|\n      max = i if col == 1\n    end\n  end\n  max\nend", "  # For each\
    \ row, count the numbers of 1s, \n  # and subtract the largest amount we can subtract\
    \ to get the final amount we need to lower the bucket\n  count = 0\n  grid.each\
    \ do |row|\n    filled = count_1s(row)\n    while filled > capacity\n      filled\
    \ -= capacity\n      count += 1\n    end\n    count += 1 if filled > 0\n  end\n\
    \  count\nend", "  rows = grid.length\n  cols = grid[0].length\n  filled = 0\n\
    \  empty = 0\n  rows.times do |i|\n    cols.times do |j|\n      if grid[i][j]\
    \ == 1\n        filled += 1\n      else\n        empty += 1\n      end\n    end\n\
    \  end\n  [(filled / capacity.to_f).ceil, empty].max\nend", "  # return 0 if grid.empty?\n\
    \  # return 0 if grid.all? { |row| row.all?(&:zero?) }\n  # return capacity *\
    \ grid.size if grid.all? { |row| row.all?(1) }\n  # max_filled = 0\n  # grid.each\
    \ do |row|\n  #   counter = 0\n  #   row.each do |col|\n  #     counter += 1 if\
    \ col.zero?\n  #     break if counter == capacity\n  #   end\n  #   max_filled\
    \ = [max_filled, counter].max\n  # end\n  # max_filled\n  return 0 if grid.empty?\n\
    \  return 0 if grid.all? { |row| row.all?(&:zero?) }\n  return capacity * grid.size\
    \ if grid.all? { |row| row.all?(1) }\n  empty_cells = grid.map do |row|\n    row.each_with_index.reduce(0)\
    \ do |max_zero_streak, (col, index)|\n      if col.zero?\n        [max_zero_streak,\
    \ row[index+1..-1].index(1)].compact.max\n      else\n        max_zero_streak\n\
    \      end\n    end\n  end\n  empty_cells.each_with_index.reduce(0) do |sum, (empty_cells_in_row,\
    \ row_index)|\n    sum + (empty_cells_in_row < capacity ? empty_cells_in_row :\
    \ capacity)\n  end\nend\nputs \"INCORRECT\" unless max_fill([[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]], 1) == 6\nputs \"INCORRECT\" unless max_fill([[0,0,1,1], [0,0,0,0],\
    \ [1,1,1,1], [0,1,1,1]], 2) == 5\nputs \"INCORRECT\" unless max_fill([[0,0,0],\
    \ [0,0,0]], 5) == 0", "  max_fill_in_wells = []\n  grid.each_with_index do |row,\
    \ index|\n    max_fill_in_wells[index] = []\n    row.each_with_index do |well,\
    \ col_index|\n      if well == 1\n        max_fill_in_wells[index][col_index]\
    \ = capacity\n      else\n        max_fill_in_wells[index][col_index] = 0\n  \
    \    end\n    end\n  end\n  max_fill_in_wells\nend", "  # 1D DP, max fill pattern\
    \ for current line\n  (1...grid.size).each do |r|\n    (0...grid[r].size).each\
    \ do |c|\n      grid[r][c] += grid[r-1][c]\n    end\n  end\n  # extract max from\
    \ all columns\n  grid.map{|row| row.max}.max\nend", "  sorted_rows = grid.sort_by{|row|\
    \ row.count(1)}\n  sorted_rows.each do |row|\n    filled = 0\n    while filled\
    \ < capacity && row.any?{|x| x == 1}\n      row.pop\n      filled += 1\n    end\n\
    \  end\n  sorted_rows.count * capacity - sorted_rows.flatten.count(1)\nend", " \
    \ return 0 if grid.empty?\n  return 0 if grid[0].empty?\n  wells_to_fill = []\n\
    \  0.upto(grid.size - 1) do |i|\n    0.upto(grid[0].size - 1) do |j|\n      wells_to_fill\
    \ << [i, j] if grid[i][j] == 1\n    end\n  end\n  num_operations = 0\n  buckets\
    \ = Array.new(grid[0].size, capacity)\n  until wells_to_fill.empty?\n    0.upto(grid[0].size\
    \ - 1) do |j|\n      row_index = 0\n      until row_index >= grid.size || buckets[j]\
    \ == 0\n        if grid[row_index][j] == 1\n          buckets[j] -= 1\n      \
    \    wells_to_fill.delete([row_index, j])\n        end\n        row_index += 1\n\
    \      end\n    end\n    num_operations += 1\n  end\n  num_operations\nend", " \
    \   capacities = grid.inject([]) { |memo, row| memo << row.each_with_index.map\
    \ { |x, i| x.zero? ? 0 : capacity } }\n    i = 0\n    while i < capacities.length\
    \ do\n        overflow = capacities[i].map { |x| x - capacity }.reduce(:+)\n \
    \       next_overflow = 0\n        overflow -= next_overflow if next_overflow\
    \ <= overflow\n        if next_overflow > overflow\n            i += 1\n     \
    \       capacities[i] = capacities[i].map { |x| x + next_overflow }\n        end\n\
    \        if overflow > 0\n            if i + 1 < capacities.length\n         \
    \       capacities[i + 1] = capacities[i + 1].map { |x| x + overflow }\n     \
    \       end\n            i += 1\n        end\n        i += 1\n    end\n    capacities.inject([])\
    \ { |memo, row| memo << row.reduce(:+) }.reduce(:+)\nend", "  col_size = grid[0].size\n\
    \  row_size = grid.size\n  return 0 if row_size.zero?\n  rows = grid.map(&:max)\n\
    \  cols = Array.new(col_size) { 0 }\n  (0...row_size).each do |row|\n    (0...col_size).each\
    \ do |col|\n      cols[col] = [cols[col], grid[row][col]].max\n    end\n  end\n\
    \  (0...row_size).sum { |row| rows[row] / capacity } + (0...col_size).sum { |col|\
    \ cols[col] / capacity }\nend", "  max_fill = 0\n  grid.each do |well|\n    max_fill\
    \ = [max_fill, well.count(1)].max\n  end\n  max_fill\nend", "  max = 0\n  sum\
    \ = 0\n  grid.each do |row|\n    max = row.max if row.max > max\n    sum += row.sum\n\
    \  end\n  max = sum if sum > max\n  max\nend", "  # run a vertical max\n  max_grid\
    \ = grid.map(&:max)\n  # assume the wells are all the same length\n  grid.size.times.map\
    \ do |i|\n    # each well has a max fill of the row max or capacity\n    [max_grid[i],\
    \ capacity].min\n  end\nend", "  total = 0\n  grid.each do |row|\n    row.each\
    \ do |cell|\n      total += cell\n    end\n  end\n  total / capacity\nend", " \
    \ # find the maximum height of a column\n  # repeat until all columns are 0\n\
    \  #   fill each column up to the height and subtract 1", "  grid.each do |row|\n\
    \    row.map! { |x| x * capacity }\n  end\n  # find the max in each column\n \
    \ max_in_col = grid.map { |row| row.max }\n  # subtract the max from the elements\
    \ in the column\n  grid.each do |row|\n    row.each_with_index do |cell, col|\n\
    \      if cell == max_in_col[col]\n        row[col] = 0\n      else\n        row[col]\
    \ = max_in_col[col] - cell\n      end\n    end\n  end\n  # find the max in each\
    \ row\n  grid.map { |row| row.max }.sum\nend\nputs max_fill([[0,0,1,0], [0,1,0,0],\
    \ [1,1,1,1]], 1)\nputs max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]],\
    \ 2)\nputs max_fill([[0,0,0], [0,0,0]], 5)", "  max_fill = 0\n  rows = grid.length\n\
    \  cols = grid[0].length\n  (0...rows).each do |i|\n    (0...cols).each do |j|\n\
    \      if grid[i][j] > 0\n        max_fill = [max_fill, grid[i][j]].max\n    \
    \  end\n    end\n  end\n  max_fill\nend", "  puts \"#{grid}, #{capacity}\"\n \
    \ return 0 if grid.empty?\n  depth = Array.new(grid[0].length, 0)\n  grid.each\
    \ do |line|\n    line.each_with_index do |e, i|\n      depth[i] += 1 if e == 1\n\
    \    end\n  end\n  puts \"depth = #{depth}\"\n  depth.max / capacity\nend", " \
    \ # Replace me with your implementation.\nend", "  max = 0\n  grid.each { |row|\
    \ max = row.max if row.max > max }\n  max\nend", "  count = 0\n  num_rows = grid.length\n\
    \  num_cols = grid[0].length\n  (0...num_rows).each do |row|\n    (0...num_cols).each\
    \ do |col|\n      if grid[row][col] == 1\n        count += 1\n        if capacity\
    \ - grid[row][col] >= 0\n          grid[row][col] = 0\n          capacity -= 1\n\
    \        end\n      end\n    end\n  end\n  count\nend", "  n_rows = grid.length\n\
    \  n_cols = grid[0].length\n  max_bucket_fill = [0] * n_cols\n  bucket_fill =\
    \ [0] * n_cols\n  n_drops = 0\n  (0...n_rows).each do |i|\n    (0...n_cols).each\
    \ do |j|\n      if grid[i][j] == 1\n        bucket_fill[j] += 1\n        max_bucket_fill[j]\
    \ = [max_bucket_fill[j], bucket_fill[j]].max\n      else\n        bucket_fill[j]\
    \ = 0\n      end\n    end\n    n_drops += max_bucket_fill.max / capacity\n   \
    \ n_drops += max_bucket_fill.max % capacity == 0 ? 0 : 1\n  end\n  n_drops\nend\n\
    grid1 = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\nbucket_capacity1 = 1\np max_fill(grid1,\
    \ bucket_capacity1)\ngrid2 = [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\nbucket_capacity2\
    \ = 2\np max_fill(grid2, bucket_capacity2)\ngrid3 = [[0,0,0], [0,0,0]]\nbucket_capacity3\
    \ = 5\np max_fill(grid3, bucket_capacity3)", "    rows = grid.length\n    cols\
    \ = grid[0].length\n    max_fill = 0\n    count = 0\n    (0...rows).each do |row|\n\
    \        (0...cols).each do |col|\n            max_fill += grid[row][col]\n  \
    \      end\n    end\n    # if the grid is empty\n    return 0 if max_fill == 0\n\
    \    # the max number of fills is the ceiling of the max_fill / capacity\n   \
    \ max_fills = (max_fill / capacity.to_f).ceil\n    (0...max_fills).each do |fill|\n\
    \        (0...rows).each do |row|\n            (0...cols).each do |col|\n    \
    \            grid[row][col] -= capacity\n                grid[row][col] = 0 if\
    \ grid[row][col] < 0\n                if grid[row][col] == 0\n               \
    \     count += 1\n                end\n            end\n        end\n    end\n\
    \    # return the number of times you lowered a bucket\n    max_fills\nend", " \
    \ max_fill = 0\n  grid.each do |row|\n    if row.inject(:+) > max_fill\n     \
    \ max_fill = row.inject(:+)\n    end\n  end\n  max_fill = capacity if max_fill\
    \ > capacity\n  max_fill\nend", "  rows = grid.length\n  cols = grid[0].length\n\
    \  count = 0\n  cols.times do |j|\n    sum = 0\n    rows.times do |i|\n      sum\
    \ += grid[i][j]\n      if sum > capacity\n        count += 1\n        sum = grid[i][j]\n\
    \      end\n    end\n    count += 1 if sum > 0\n  end\n  count\nend", "  return\
    \ 0 if grid.empty?\n  wells = grid.map { |w| w.count(1) }\n  ans = 0\n  wells.each\
    \ do |w|\n    ans += w / capacity + (w % capacity).zero? ? 0 : 1\n  end\n  ans\n\
    end\ngrid1 = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\ngrid2 = [[0,0,1,1], [0,0,0,0],\
    \ [1,1,1,1], [0,1,1,1]]\ngrid3 = [[0,0,0], [0,0,0]]\nputs max_fill(grid1, 1)\n\
    puts max_fill(grid2, 2)\nputs max_fill(grid3, 5)", "    total = 0\n    while grid.any?\
    \ { |row| row.any? }\n        max_fill_height = grid.map { |row| row.max }.max\n\
    \        max_fill_height = capacity if max_fill_height > capacity\n        grid.map!\
    \ { |row| row.map { |col| col - max_fill_height } }\n        total += 1\n    end\n\
    \    total\nend\ngrid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\ncapacity = 1\nputs\
    \ \"Expected: 6 -- Actual: #{max_fill(grid, capacity)}\"\ngrid = [[0,0,1,1], [0,0,0,0],\
    \ [1,1,1,1], [0,1,1,1]]\ncapacity = 2\nputs \"Expected: 5 -- Actual: #{max_fill(grid,\
    \ capacity)}\"\ngrid = [[0,0,0], [0,0,0]]\ncapacity = 5\nputs \"Expected: 0 --\
    \ Actual: #{max_fill(grid, capacity)}\"", "  return 0 if grid.empty? || grid[0].empty?\n\
    \  count = 0\n  wells = grid.map {|row| row.reduce(:+)}\n  wells.each_with_index\
    \ do |fill, i|\n    count += fill / capacity\n    grid[i].each_with_index do |el,\
    \ j|\n      grid[i][j] = el - (fill - capacity) if fill - capacity > 0\n    end\n\
    \  end\n  count\nend", "  # sort rows by max element\n  sorted_rows = grid.sort_by\
    \ { |row| row.max }\n  count = 0\n  # remove the largest value from each row until\
    \ all wells are empty\n  until sorted_rows.all? { |row| row.all? { |value| value\
    \ == 0 } }\n    sorted_rows.each do |row|\n      max_value = row.max\n      if\
    \ max_value > 0\n        max_value -= capacity\n        if max_value < 0\n   \
    \       max_value = 0\n        end\n        index = row.index(row.max)\n     \
    \   row[index] = max_value\n        count += 1\n      end\n    end\n  end\n  count\n\
    end", "  heights = grid.map { |row| row.count(1) }\n  return 0 if heights.max\
    \ == 0\n  positions = Hash.new { |h, k| h[k] = [] }\n  heights.each_with_index\
    \ { |h, i| positions[h] << i }\n  result = 0\n  positions.each do |height, wells|\n\
    \    last_position = wells.first\n    wells.each do |well|\n      result += (well\
    \ - last_position - 1) / capacity\n      last_position = well\n    end\n    result\
    \ += (heights.length - last_position - 1) / capacity\n  end\n  result\nend", " \
    \ max = -1\n  rows = grid.length\n  cols = grid[0].length\n  (0...rows).each do\
    \ |i|\n    row = grid[i]\n    (0...cols).each do |j|\n      if (row[j] == 1)\n\
    \        max = [max, capacity].max\n        capacity = 0\n      else\n       \
    \ capacity += 1\n      end\n    end\n  end\n  max\nend", "  max_fill = 0\n  grid.each\
    \ do |r|\n    max_fill = r.count(1) if r.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  # find max fill of buckets and subtract fill of non-empty wells\n  max_fill\
    \ = 0\n  grid.each do |well|\n    max_fill += well.reduce(:+)\n  end\n  max_fill\
    \ = (max_fill / capacity).ceil\n  grid.each do |well|\n    max_fill -= well.count\
    \ { |e| e == 1 }\n  end\n  max_fill\nend", "  # Find the max bucket fill for one\
    \ bucket, for each bucket in the grid\n  grid.map do |row|\n    # For each row,\
    \ find the largest block of water\n    row.each_with_index.map do |cell, idx|\n\
    \      # Map each cell to the max length block of water if the row below is empty\n\
    \      if cell == 1\n        raise \"Unexpected water\" if row[idx+1] == 1\n \
    \       block_length = 0\n        (idx+1).upto(row.length-1) do |j|\n        \
    \  break if row[j] == 1\n          block_length += 1\n        end\n        # If\
    \ the block of water is too long for one bucket, cap it at capacity\n        if\
    \ block_length > capacity\n          capacity\n        else\n          block_length\n\
    \        end\n      else\n        0\n      end\n    end.max\n  end.inject(:+)\n\
    end", "  row_maxes = []\n  for row in grid\n    row_maxes << row.max\n  end\n\
    \  num_maxes = row_maxes.max\n  (1..num_maxes).inject(0) do |total, i|\n    total\
    \ + row_maxes.inject(0) do |t, r|\n      t + (r / capacity) + (r % capacity ==\
    \ 0 ? 0 : 1)\n    end\n  end\nend", "  max_fill_rows(grid, capacity) + max_fill_cols(grid,\
    \ capacity)\nend", "  # two dimentional array of max fill for each cell\n  m =\
    \ Array.new(grid.length) { Array.new(grid[0].length, 0) }\n  # get max fill for\
    \ each cell, 1st row is all 0s\n  (1...grid.length).each do |row|\n    (0...grid[0].length).each\
    \ do |col|\n      if (grid[row][col] == 1)\n        fill = 0\n        fill +=\
    \ [m[row-1][col], capacity].min if (row-1 >= 0)\n        fill += [m[row][col-1],\
    \ capacity].min if (col-1 >= 0)\n        m[row][col] = fill\n      end\n    end\n\
    \  end\n  # accumulate max fill and return\n  m.flatten.reduce(:+)\nend\nputs\
    \ max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\nputs max_fill([[0,0,1,1], [0,0,0,0],\
    \ [1,1,1,1], [0,1,1,1]], 2)\nputs max_fill([[0,0,0], [0,0,0]], 5)", "  max = 0\n\
    \  grid.each do |r|\n    max = [max, r.sum].max\n  end\n  (max + capacity - 1)\
    \ / capacity\nend", "  i, max = 0, 0\n  while i < grid.length\n    j = 0\n   \
    \ while j < grid[i].length\n      max = [max, grid[i][j]].max\n      j += 1\n\
    \    end\n    i += 1\n  end\n  max\nend", "    return 0 if capacity < 1\n    r\
    \ = grid.length\n    c = grid[0].length\n    raise \"r < 1 or c < 1\" if r < 1\
    \ || c < 1\n    grid.each do |row|\n        raise \"wrong number of columns\"\
    \ if row.length != c\n    end\n    # compute how much water to add in each row\
    \ and column\n    rows = grid.map { |row| row.reduce(:+) }\n    columns = grid.transpose.map\
    \ { |col| col.reduce(:+) }\n    # compute how much water to remove from each row\
    \ and column\n    rows = rows.map { |sum| [(sum + capacity - 1) / capacity, 0].max\
    \ }\n    columns = columns.map { |sum| [(sum + capacity - 1) / capacity, 0].max\
    \ }\n    # compute how much water to add to each row and column\n    rows = rows.map\
    \ { |sum| sum * capacity }\n    columns = columns.map { |sum| sum * capacity }\n\
    \    # total number of drops\n    rows.reduce(:+) + columns.reduce(:+)\nend",
  "  sz = grid.map(&:size).max\n  grid.map!{|row| (row + Array.new(sz - row.size,\
    \ 0)).map(&:to_i)}\n  grid.max_by(&:sum).max_by(&:to_i)\nend", "  max = grid.first.size\
    \ - 1\n  num_rows = grid.size\n  num_cols = grid.first.size\n  num_drops = 0\n\
    \  current_level = 0\n  current_row = 0\n  # we start by filling the first column\n\
    \  # for each row in the column, if the water level is above the water level of\
    \ the row, we have to drop the bucket\n  # we also have to drop it if the well\
    \ has not been filled\n  while current_row < num_rows\n    if current_level <\
    \ max\n      if grid[current_row][current_level] == 1 && current_level < max\n\
    \        current_level += 1\n        num_drops += 1\n      elsif grid[current_row][current_level]\
    \ == 0\n        grid[current_row][current_level] = 1\n        num_drops += 1\n\
    \      end\n    else\n      current_row += 1\n      current_level = 0\n    end\n\
    \  end\n  # we then check if the current_level is above the current_row\n  # if\
    \ it is, then we drop down a row and set current_level to 0\n  # if it is not,\
    \ then we check if the row at current_level is full or not\n  # if it is, we increase\
    \ current_level by 1 and drop the bucket\n  # if it is not, we fill the well and\
    \ drop the bucket\n  # we repeat until the current_row is full\n  # we then repeat\
    \ the process for the next column\n  current_row = 0\n  current_level = 1\n  (1...num_cols).each\
    \ do |col|\n    while current_row < num_rows\n      if current_level < max\n \
    \       if grid[current_row][current_level] == 1 && current_level < max\n    \
    \      current_level += 1\n          num_drops += 1\n        elsif grid[current_row][current_level]\
    \ == 0\n          grid[current_row][current_level] = 1\n          num_drops +=\
    \ 1\n        end\n      else\n        current_row += 1\n        current_level\
    \ = 0\n      end\n    end\n    current_row = 0\n    current_level = col + 1\n\
    \  end\n  num_drops", "  # First empty out all the rows that are full of water\
    \ (1s)\n  rows_to_remove = []\n  grid.each_with_index do |row, idx|\n    rows_to_remove\
    \ << idx if row.all? { |e| e == 1 }\n  end\n  rows_to_remove.each { |idx| grid.delete_at(idx)\
    \ }\n  # Now, our goal is to empty out all the cells in the remaining rows.\n\
    \  # To empty one row, we have to have a bucket pass over it capacity times.\n\
    \  # We can do this by incrementing every cell by capacity.\n  grid.each { |row|\
    \ row.map! { |e| e + capacity } }\n  # Now, we need to track if each cell is the\
    \ max of its column.\n  # If it is, then we can only empty that cell if we have\
    \ a bucket that can fill it.\n  # If it isn't, then we can just fill it capacity\
    \ times and we're good.\n  col_maxes = Array.new(grid[0].length, 0)\n  grid.each\
    \ do |row|\n    row.each_with_index do |e, idx|\n      col_maxes[idx] = e if e\
    \ > col_maxes[idx]\n    end\n  end\n  # Now we need to find the number of columns\
    \ that have a max value less than capacity.\n  # For each of these columns, we\
    \ need to fill the cell capacity times.\n  # For each of the remaining columns,\
    \ we need to fill the cell max_value / capacity times.\n  num_of_pours = 0\n \
    \ col_maxes.each do |max|\n    if max >= capacity\n      num_of_pours += max /\
    \ capacity\n    else\n      num_of_pours += capacity\n    end\n  end\n  num_of_pours\n\
    end", "  max_well = capacity - 1\n  # For each well, get the max amount of water\
    \ we can fill \n  # without going over capacity.\n  grid.map { |well| [well.size,\
    \ max_well].min }\nend", "  total_fill = 0\n  for row in grid\n    units_filled\
    \ = 0\n    for n in row\n      units_filled += n\n      if units_filled == capacity\n\
    \        total_fill += 1\n        units_filled = 0\n      end\n    end\n    total_fill\
    \ += 1 if units_filled > 0\n  end\n  total_fill\nend", "  grid.flatten.map { |x|\
    \ x / capacity }.sum\nend", "  grid.map { |row|\n    row.reduce(0) { |sum, x|\
    \ sum + x }\n  }.max / capacity\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.sum\n    break if max_fill == capacity\n  end\n  max_fill\n\
    end", "  row_max = 0\n  row_ind = 0\n  grid.each_with_index do |row, i|\n    temp\
    \ = row.reduce(:+)\n    if temp > row_max\n      row_max = temp\n      row_ind\
    \ = i\n    end\n  end\n  grid[row_ind] = grid[row_ind].map {|col| col * capacity}\n\
    \  grid[row_ind]\nend", "  # TODO\nend", "  capacity_left = capacity\n  max_fill\
    \ = 0\n  grid.each do |well|\n    if well.max > max_fill\n      max_fill = well.max\n\
    \    end\n  end\n  capacity_left -= max_fill\n  return max_fill if capacity_left\
    \ <= 0\n  max_fill\nend", "  total = 0\n  grid.each do |row|\n    total += (row.count(1)\
    \ + capacity - 1) / capacity\n  end\n  total\nend\ngrid, capacity = [[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]], 1\np max_fill(grid, capacity)\ngrid, capacity = [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2\np max_fill(grid, capacity)\ngrid, capacity\
    \ = [[0,0,0], [0,0,0]], 5\np max_fill(grid, capacity)", "  max_fill = 0\n  for\
    \ i in 0...grid.length\n    for j in 0...grid[i].length\n      max_fill = grid[i][j]\
    \ if grid[i][j] > max_fill\n    end\n  end\n  max_fill = [max_fill, capacity].min\n\
    \  puts \"max_fill is #{max_fill}\"\n  return max_fill\nend", "  rows = grid.length\n\
    \  return 0 if rows == 0", "  # Using the observation that the maximum number\
    \ of buckets\n  # we need for a column is the maximum number of 1s in that column,\n\
    \  # we can find the maximum number of buckets we need for each\n  # row, and\
    \ then return the maximum of those values.\n  grid.map { |row| count_max_buckets(row,\
    \ capacity) }.max\nend", "  rows = grid.length\n  cols = grid[0].length\n  max_fill\
    \ = 0\n  rows.times do |i|\n    cols.times do |j|\n      max_fill = [max_fill,\
    \ grid[i][j]].max\n    end\n  end\n  max_fill\nend", "  num_rows = grid.length\n\
    \  num_cols = grid[0].length\n  # convert grid so that we can simply subtract\
    \ the capacity when emptying\n  grid.each do |row|\n    row.each_with_index do\
    \ |el, col|\n      row[col] = el == 1 ? capacity : 0\n    end\n  end\n  operations\
    \ = 0\n  while true\n    break if grid.flatten.all? { |e| e == 0 }\n    0.upto(num_rows\
    \ - 1) do |row|\n      0.upto(num_cols - 1) do |col|\n        if grid[row][col]\
    \ != 0\n          left_col = col == 0 ? nil : col - 1\n          right_col = col\
    \ == num_cols - 1 ? nil : col + 1\n          prev_row = row == 0 ? nil : row -\
    \ 1\n          next_row = row == num_rows - 1 ? nil : row + 1\n          # find\
    \ the minimum amount of water to remove\n          if !left_col.nil? && grid[row][left_col]\
    \ > 0\n            min_water = [grid[row][left_col], grid[row][col]].min\n   \
    \         grid[row][left_col] -= min_water\n            grid[row][col] -= min_water\n\
    \            operations += min_water\n          elsif !right_col.nil? && grid[row][right_col]\
    \ > 0\n            min_water = [grid[row][right_col], grid[row][col]].min\n  \
    \          grid[row][right_col] -= min_water\n            grid[row][col] -= min_water\n\
    \            operations += min_water\n          elsif !prev_row.nil? && grid[prev_row][col]\
    \ > 0\n            min_water = [grid[prev_row][col], grid[row][col]].min\n   \
    \         grid[prev_row][col] -= min_water\n            grid[row][col] -= min_water\n\
    \            operations += min_water\n          elsif !next_row.nil? && grid[next_row][col]\
    \ > 0\n            min_water = [grid[next_row][col], grid[row][", "  return 0\
    \ if grid.nil? || grid.empty? || grid[0].nil? || grid[0].empty?\n  rows = grid.size\n\
    \  cols = grid[0].size\n  fill_count = 0\n  capacity.times do |row|\n    next\
    \ if grid[row].nil?\n    cols.times do |col|\n      if grid[row][col] == 1\n \
    \       fill_count += 1\n        grid[row][col] = 0\n      end\n    end\n  end\n\
    \  fill_count\nend", "  # your code goes here\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.sum].max\n  end\n  [max_fill, capacity].min\n\
    end", "  hash = {}\n  grid.each_with_index do |row, i|\n    # hash[i] = row.sum\n\
    \    hash[i] = row.each_with_index.map { |c, j| c == 1 ? j : 0 }.sum\n  end\n\
    \  hash\nend", "  ans = 0\n  h = grid.size - 1\n  w = grid[0].size - 1\n  bucket\
    \ = Array.new(w + 1, 0)\n  (0..h).each do |y|\n    (0..w).each do |x|\n      bucket[x]\
    \ += grid[y][x]\n      ans += grid[y][x]\n    end\n    water = 0\n    (0..w).each\
    \ do |x|\n      water += bucket[x]\n      if water > capacity\n        water -=\
    \ capacity\n        ans += water\n      end\n    end\n  end\n  ans\nend", "  return\
    \ 0 if grid.empty? || grid[0].empty?\n  total_water = 0\n  grid.each { |row| total_water\
    \ += row.sum }\n  total_water / capacity\nend", "  count = 0\n  grid.each do |row|\n\
    \    row.each_with_index do |fill, index|\n      diff = capacity - fill\n    \
    \  row[index] = diff > 0 ? capacity : capacity + diff\n      count += 1\n    end\n\
    \  end\n  count\nend", "  max = 0\n  grid.each do |row|\n    max = row.sum if\
    \ row.sum > max\n  end\n  max\nend", "  m = grid.size\n  n = grid[0].size\n  max\
    \ = capacity\n  grid.each_with_index do |row, i|\n    n.times do |j|\n      if\
    \ row[j] > 0\n        row[j] = -1\n        max = [max, fill(grid, m, n, capacity,\
    \ i, j)].max\n      end\n    end\n  end\n  max\nend", "  return 0 if grid.length\
    \ == 0\n  fill_grid = Array.new(grid.length) { Array.new(grid[0].length, capacity)\
    \ }\n  max_fill_hash = {}\n  fill_grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      if grid[i][j] == 1\n        max_fill_hash[[i, j]] = {\n \
    \         row: i,\n          col: j,\n          val: capacity\n        }\n   \
    \   end\n    end\n  end\n  max_fill_hash.each do |loc, info|\n    update_max_fill(fill_grid,\
    \ max_fill_hash, loc, info)\n  end\n  total_drops = 0\n  fill_grid.each do |row|\n\
    \    total_drops += row.reduce(:+)\n  end\n  return total_drops\nend", "  @grid\
    \ = grid\n  @capacity = capacity\n  @max_fill = 0\n  # find all columns containing\
    \ max value\n  # loop over columns, filling them\n  @grid.each_with_index do |col,\
    \ idx|\n    if col.max == @max_fill\n      fill_col_and_remove(idx)\n    end\n\
    \  end\n  return @grid.empty? ? 0 : @max_fill\nend", "  # We can solve this problem\
    \ via a simple dynamic programming solution.\n  # What is the mininum number of\
    \ operations needed to fill the first k wells\n  # in the grid?\n  # At each step,\
    \ we can either fill a well, or pump a well.\n  # If a well is filled, then there\
    \ will be an extra operation to fill this well.\n  # Let's assume that we use\
    \ exactly k operations to fill the first k wells.\n  # Then the number of operations\
    \ required to fill the first k + 1 wells is\n  # either k + 1, if we have to fill\
    \ the (k + 1)th well, or k, if we can pump\n  # the (k + 1)th well.\n  # The goal\
    \ is to minimize the number of operations.\n  # Note that the minimum number of\
    \ operations to fill the first 0 wells is 0.\n  # dp[0] = 0\n  # dp[k] = min(\n\
    \  #   dp[k - 1] + 1,  # We fill the kth well.\n  #   dp[k]          # We pump\
    \ the kth well.\n  # )\n  # dp[k] = min(\n  #   dp[k - 1] + 1,  # We fill the\
    \ kth well.\n  #   dp[k - 2] + 1,  # We pump the kth well.\n  #   dp[k - 3] +\
    \ 1,  # We pump the kth well.\n  #   ...\n  #   dp[k - capacity] + 1,  # We pump\
    \ the kth well.\n  # )\n  # dp[k] = min(\n  #   dp[k - 1] + 1,  # We fill the\
    \ kth well.\n  #   dp[k - 2] + 1,  # We pump the kth well.\n  #   dp[k - 3] +\
    \ 1,  # We pump the kth well.\n  #   ...\n  #   dp[0] + 1,  # We pump the kth\
    \ well.\n  # )\n  # We initialize dp to [0, 1, ..., capacity], because we need\
    \ at least that\n  # many operations to fill the first capacity", "  fill_count\
    \ = 0\n  grid.each do |row|\n    fill_count += (row.count(1) + capacity - 1) /\
    \ capacity\n  end\n  fill_count\nend", "  return 0 if grid.empty?\n  #puts \"\
    grid = #{grid}\"\n  #puts \"capacity = #{capacity}\"\n  rows, cols = grid.size,\
    \ grid[0].size\n  lowers = 0\n  lowers += grid.transpose.each_with_index.map {\
    \ |row, col|\n    #puts \"row = #{row}, col = #{col}\"\n    (row.inject(&:+) /\
    \ capacity).floor\n  }.inject(&:+)\n  #puts \"lowers = #{lowers}\"\n  lowers\n\
    end", "  # input 2D array, bucket capacity -> output integer\n  # fill the well\
    \ with the most water first, until the bucket is empty\n  # the remaining amount\
    \ of water in that bucket goes to the bucket of the next well with the most water\n\
    \  # continue until the buckets are all empty and all the wells are filled\n \
    \ # sum up the total number of drops\n  # pseudocode\n  # initialize a drops variable,\
    \ set to 0\n  # while there are drops left\n  #   call a max_fill_helper function,\
    \ passing in the grid and the capacity\n  #   increment the drops variable\n \
    \ # return the drops variable\n  drops = 0\n  until max_fill_helper(grid, capacity)\
    \ == 0\n    drops += 1\n  end\n  drops\nend", "  max_fill = 0\n  grid.each { |row|\
    \ max_fill = [max_fill, row.reduce(:+)].max }\n  max_fill\nend", "  rows = grid.length\n\
    \  cols = grid[0].length\n  max_fill = 0\n  (0...rows).each do |row|\n    (0...cols).each\
    \ do |col|\n      max_fill = [max_fill, grid[row][col]].max\n    end\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    row.each do |well|\n\
    \      if well > max_fill\n        max_fill = well\n      end\n    end\n  end\n\
    \  max_fill = max_fill - 1\n  return max_fill if max_fill <= capacity\n  if max_fill\
    \ > capacity\n    max_fill = capacity\n  end\n  max_fill\nend", "  max_fill =\
    \ 0\n  (0...grid.length).each do |i|\n    sum = 0\n    (0...grid[i].length).each\
    \ do |j|\n      sum += grid[i][j]\n      if sum > capacity\n        sum = capacity\n\
    \      end\n    end\n    max_fill = sum if sum > max_fill\n  end\n  max_fill\n\
    end", '  return 0 if grid.length == 0', "  min = 0\n  max = 0\n  grid.each do\
    \ |row|\n    row.each do |col|\n      max += col\n    end\n  end\n  while max\
    \ > min\n    mid = min + (max - min) / 2\n    if is_valid(grid, capacity, mid)\n\
    \      max = mid\n    else\n      min = mid + 1\n    end\n  end\n  min\nend",
  "    rows = grid.length\n    cols = grid[0].length\n    [rows, cols].max.times.reduce(0)\
    \ do |max_water, i|\n        full_buckets = 0\n        grid.each do |row|\n  \
    \          full_buckets += row[i]\n        end\n        max_water + (full_buckets\
    \ / capacity).floor\n    end\nend", '  return 0 if grid.empty?', "  row_max =\
    \ []\n  fill_count = 0\n  grid.each do |row|\n    row_max << row.max \n  end\n\
    \  loop do\n    break if row_max.max == 0\n    row_max.each_with_index do |c,\
    \ i|\n      if c > 0\n        fill_count += 1\n        row_max[i] = c - capacity\n\
    \      end\n    end\n  end\n  fill_count\nend", "  # time: O(n * m)\n  # space:\
    \ O(n * m)\n  total = 0\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |cell, j|\n      total += cell\n    end\n  end\n  count = 0\n  while total\
    \ > 0\n    total -= capacity\n    count += 1\n  end\n  count\nend", "  max = 0\n\
    \  grid.each do |row|\n    max = row.count(1) if row.count(1) > max\n  end\n \
    \ max\nend", "  # Hash to save wells and buckets\n  h = {}\n  # all wells have\
    \ the same length\n  grid.each_with_index do |row, idx|\n    row.each_with_index\
    \ do |col, idx2|\n      h[idx2] = 0 if h[idx2].nil?\n      h[idx2] += col\n  \
    \  end\n  end\n  # p h\n  count = 0\n  # Sort wells in ascending order\n  h =\
    \ h.sort.to_h\n  # p h\n  h.each do |k, v|\n    # Bucket can have buckets with\
    \ the same capacity\n    if h[k] > capacity\n      count += h[k] / capacity\n\
    \      h[k] = h[k] % capacity\n    end\n  end\n  # p h\n  count\nend", "  len\
    \ = grid.length\n  return len if len <= 1\n  capacity -= grid[len-1]\n  max_fill(grid[0..-2],\
    \ capacity)\nend", "  rows = grid.length\n  cols = grid[0].length\n  row_maxes\
    \ = Array.new(rows, 0)\n  col_maxes = Array.new(cols, 0)\n  for i in 0...rows\n\
    \    for j in 0...cols\n      row_maxes[i] = [row_maxes[i], grid[i][j]].max\n\
    \      col_maxes[j] = [col_maxes[j], grid[i][j]].max\n    end\n  end\n  result\
    \ = 0\n  for i in 0...rows\n    for j in 0...cols\n      result += [row_maxes[i],\
    \ col_maxes[j]].min - grid[i][j]\n    end\n  end\n  result\nend", "  m = grid.size\n\
    \  n = grid[0].size\n  cells = (0...m).map { |i| (0...n).select { |j| grid[i][j]\
    \ == 1 } }\n  cells = cells.reject { |c| c.empty? }\n  return 0 if cells.empty?\n\
    \  # find all cells within capacity\n  cells_in_range = cells.map { |c| c.select\
    \ { |i| (i - c[0]).abs <= capacity } }\n  # merge cells that are next to each\
    \ other\n  cells_in_range.each_with_index do |c, i|\n    while i < cells_in_range.size\
    \ - 1\n      break if (c[-1] - cells_in_range[i + 1][0]).abs > capacity\n    \
    \  c.concat(cells_in_range[i + 1])\n      cells_in_range.delete_at(i + 1)\n  \
    \  end\n  end\n  # find the largest cell\n  max_cells = cells_in_range.max_by(&:size)\n\
    \  max_cells.size\nend", "  i, j = 0, 0\n  while i < grid.length\n    while j\
    \ < grid[i].length\n      grid[i][j] = capacity if grid[i][j] > capacity\n   \
    \   j += 1\n    end\n    j = 0\n    i += 1\n  end\n  grid\nend", "  rv = 0\n \
    \ grid.each do |well|\n    rv += (well.count(1) + capacity - 1) / capacity\n \
    \ end\n  rv\nend", "  rows = grid.length\n  columns = grid[0].length\n  if rows\
    \ == 0 || columns == 0\n    return 0\n  end\n  row_counts = (0...rows).map do\
    \ |i|\n    grid[i].count(1)\n  end\n  total_buckets = row_counts.max\n  if total_buckets\
    \ <= capacity\n    return total_buckets\n  end\n  ans = 0\n  while total_buckets\
    \ > 0\n    total_buckets -= capacity\n    ans += 1\n  end\n  ans\nend", "  # we\
    \ use as helper a matrix, with max entries of 1 at the bottom\n  # and the rest\
    \ of the entries are (min of the entry above, capacity)\n  # for each column we\
    \ compute the max, and return the sum\n  return 0 if grid.empty?\n  m, n = grid.size,\
    \ grid[0].size\n  helper = Array.new(m){Array.new(n, 0)}\n  helper[-1] = grid[-1]\n\
    \  (m-2).downto(0) do |i|\n    n.times do |j|\n      helper[i][j] = [helper[i+1][j],\
    \ capacity].min if grid[i][j] == 1\n    end\n  end\n  helper.map{|a| a.max}.reduce(:+)\n\
    end", "    max = 0\n    1.upto(grid.size-1) do |i|\n        max = i if grid[i]\
    \ > max\n    end\n    max\nend", "    # sum the fill levels for each column and\
    \ then divide by the\n    # capacity to get the number of cycles\n    grid.transpose.map{|x|\
    \ x.sum}.map{|x| x/capacity}.sum\nend", "  grid.map { |row| row.reduce(:+) / capacity\
    \ }.reduce(:+)\nend", "  cnt = 0\n  for r in 0...grid.length\n    for c in 0...grid[r].length\n\
    \      cnt += (grid[r][c] / capacity)\n      grid[r][c] = grid[r][c] % capacity\n\
    \    end\n  end\n  return cnt\nend", "  max_fill = 0\n  grid.each do |row|\n \
    \   fill = 0\n    row.each do |water|\n      if water == 1\n        fill += 1\n\
    \      elsif fill > 0\n        max_fill = [max_fill, fill].max\n        fill =\
    \ 0\n      end\n    end\n    max_fill = [max_fill, fill].max\n  end\n  max_fill\n\
    end", "  total_wells = grid.flatten.count(1)\n  current_fill = grid.map{|row|\
    \ [0] * row.length}\n  fill_count = 0\n  while current_fill.flatten.count(1) <\
    \ total_wells\n    current_fill.map!{|row| [0] * row.length}\n    fill_count +=\
    \ 1\n    (0...grid.length).each do |row|\n      (0...grid[row].length).each do\
    \ |col|\n        current_fill[row][col] = current_fill[row][col] == 1 ? 1 : grid[row][col]\n\
    \        if current_fill[row][col] == 1\n          if current_fill[row-1] && current_fill[row-1][col]\
    \ == 0\n            current_fill[row-1][col] = 1\n          end\n          if\
    \ current_fill[row+1] && current_fill[row+1][col] == 0\n            current_fill[row+1][col]\
    \ = 1\n          end\n          if current_fill[row][col-1] == 0\n           \
    \ current_fill[row][col-1] = 1\n          end\n          if current_fill[row][col+1]\
    \ == 0\n            current_fill[row][col+1] = 1\n          end\n        end\n\
    \      end\n    end\n  end\n  fill_count\nend", "  @bucket_capacity = capacity\n\
    \  @fill_max = []\n  @cnt = 0\n  grid.each_with_index do |row, idx|\n    row.each_with_index\
    \ do |square, idx2|\n      if square == 1\n        add_to_bucket(idx, idx2)\n\
    \      end\n    end\n  end\n  @cnt\nend", "  n = grid.size\n  m = grid[0].size\n\
    \  grid = grid.map{|row| row.map{|el| [el, capacity]}}\n  fill_rows = []\n  #\
    \ fill the wells from top to bottom\n  (0...n).each do |i|\n    # empty all wells\
    \ which already contain water\n    (0...m).each do |j|\n      next if grid[i][j][0]\
    \ == 0\n      grid[i][j][0] = 0\n      grid[i][j][1] = capacity\n    end\n   \
    \ # fill the wells with water if possible\n    (0...m).each do |j|\n      if grid[i][j][1]\
    \ > 0\n        grid[i][j][0] = 1\n        grid[i][j][1] -= 1\n      end\n    end\n\
    \    fill_rows << i if grid[i].any?{|well| well[0] == 1}\n  end\n  # go backwards\
    \ and fill wells using water from above\n  result = 0\n  fill_rows.reverse.each\
    \ do |i|\n    (0...m).each do |j|\n      next if grid[i][j][0] == 0\n      if\
    \ grid[i][j][1] > 0\n        grid[i][j][0] = 1\n        grid[i][j][1] -= 1\n \
    \     else\n        (i-1).downto(0).each do |k|\n          next if grid[k][j][0]\
    \ == 0\n          if grid[k][j][1] > 0\n            grid[k][j][0] = 1\n      \
    \      grid[k][j][1] -= 1\n            result += 1\n            break\n      \
    \    end\n        end\n      end\n    end\n  end\n  result\nend", "    # [0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]\n    # [0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]\n   \
    \ # [0,0,0], [0,0,0]\n    # return number of times you lower bucket\n    # 1.\
    \ loop over all wells, keep track of the maximum index of a water well\n    #\
    \ 2. loop over all water wells, keep track of the maximum index of a water well\n\
    \    # 3. return minimum of those two\n    max_indices = []\n    grid.each do\
    \ |row|\n        max_index = 0\n        row.each_with_index do |well, index|\n\
    \            max_index = index if well == 1\n        end\n        max_indices\
    \ << max_index\n    end\n    max_indices.max + 1\nend", "    count = 0\n    (0...grid.length).each\
    \ do |i|\n        (0...grid[i].length).each do |j|\n            fill_amt = capacity\n\
    \            # fill up to capacity\n            while grid[i][j] > 0 && fill_amt\
    \ > 0\n                grid[i][j] -= 1\n                fill_amt -= 1\n      \
    \          count += 1\n            end\n        end\n    end\n    count\nend",
  "  m = grid.size\n  n = grid[0].size\n  height = Array.new(n, 0)\n  (0...m).each\
    \ do |r|\n    (0...n).each do |c|\n      height[c] = grid[r][c] == 1 ? height[c]\
    \ + 1 : 0\n    end\n    (0...n).each do |c|\n      while height[c] > 0 && capacity\
    \ > 0\n        height[c] -= 1\n        capacity -= 1\n      end\n    end\n  end\n\
    \  m * n - height.reduce(:+)\nend", "    total_fill = 0\n    while true\n    \
    \    while true\n            # Try to fill any rows that are not full\n      \
    \      fill_to_empty = true\n            (0...grid.length).each do |row|\n   \
    \             sum = grid[row].sum\n                if sum < grid[row].length\n\
    \                    grid[row].map! do |well|\n                        well ==\
    \ 1 ? 0 : 1\n                    end\n                    fill_to_empty = false\n\
    \                end\n            end\n            break if fill_to_empty\n  \
    \          total_fill += 1\n        end\n        empty_grid = true\n        (0...grid.length).each\
    \ do |row|\n            sum = grid[row].sum\n            if sum != 0\n       \
    \         empty_grid = false\n            end\n        end\n        break if empty_grid\n\
    \        grid.map! do |row|\n            row.map do |well|\n                well\
    \ == 1 ? 0 : 1\n            end\n        end\n        total_fill += 1\n    end\n\
    \    total_fill\nend", "  wells = Hash.new\n  grid.each_with_index do |row, i|\n\
    \    (0...row.length).each do |j|\n      if grid[i][j] == 1\n        wells[[i,j]]\
    \ = capacity\n      end\n    end\n  end\n  wells\nend", "  row_num = grid.length\n\
    \  col_num = grid[0].length\n  max_len = [row_num, col_num].max\n  max_len.times\
    \ do |i|\n    (row_num - i).times do |j|\n      (col_num - i).times do |k|\n \
    \       if grid[j + i][k + i] == 1\n          v1 = j + i - 1 >= 0 ? grid[j + i\
    \ - 1][k + i] : capacity\n          v2 = k + i - 1 >= 0 ? grid[j + i][k + i -\
    \ 1] : capacity\n          v = [v1, v2].min\n          grid[j + i][k + i] = [grid[j\
    \ + i][k + i], v + 1].min\n        end\n      end\n    end\n  end\n  ans = 0\n\
    \  row_num.times do |i|\n    col_num.times do |j|\n      ans += capacity - grid[i][j]\n\
    \    end\n  end\n  ans\nend\ngrid = [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\ncapacity\
    \ = 1\nputs max_fill(grid, capacity)\ngrid = [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]]\ncapacity = 2\nputs max_fill(grid, capacity)\ngrid = [[0,0,0], [0,0,0]]\n\
    capacity = 5\nputs max_fill(grid, capacity)", "  max_units_filled = 0\n  num_times_bucket_lowered\
    \ = 0\n  grid.each do |well|\n    units_filled = 0\n    well.each do |water_unit|\n\
    \      units_filled += water_unit\n      if units_filled == capacity\n       \
    \ num_times_bucket_lowered += 1\n        units_filled = 0\n      end\n    end\n\
    \    max_units_filled = units_filled if units_filled > max_units_filled\n  end\n\
    \  num_times_bucket_lowered += (max_units_filled / capacity)\n  return num_times_bucket_lowered\n\
    end", "  max_fill = 0\n  bucket = Bucket.new(capacity)\n  (0...grid.length).each\
    \ do |row|\n    bucket.add_from_well(grid[row])\n    max_fill = bucket.max_fill\
    \ if bucket.max_fill > max_fill\n  end\n  max_fill\nend", "  raise ArgumentError,\
    \ 'grid can\\'t be nil' if grid.nil?\n  raise ArgumentError, 'capacity can\\'t\
    \ be nil' if capacity.nil?\n  return 0 if grid.empty?\n  return 0 if grid[0].empty?\n\
    \  # this is to store the number of times we have to pour water into the buckets\n\
    \  counter = 0\n  # loop over the rows\n  for i in 0...grid.length\n    # this\
    \ is to store the number of wells that we have already filled\n    filled = 0\n\
    \    # this is to store the number of wells that we need to fill\n    need_to_fill\
    \ = 0\n    # loop over the wells in the row\n    for j in 0...grid[i].length\n\
    \      # if the well is filled, skip to the next well\n      next if grid[i][j]\
    \ == 1\n      # if the well is not filled, we need to fill it\n      need_to_fill\
    \ += 1\n      # if we have filled a number of wells, equal to the bucket capacity,\
    \ we can fill the wells\n      if filled == capacity\n        # fill the wells\n\
    \        filled = 0\n        # update the counter to include the number of times\
    \ we had to pour water into the buckets\n        counter += 1\n      else\n  \
    \      # if we didn't yet fill the wells, we need to pour water in the buckets\n\
    \        filled += 1\n      end\n    end\n    # if we have wells that need to\
    \ be filled, we can fill them\n    if need_to_fill > 0\n      # if we have filled\
    \ a number of wells, equal to the bucket capacity, we can fill the wells\n   \
    \   if filled == capacity\n        # fill the wells\n        filled = 0\n    \
    \    # update the counter to include the number of times we had to pour water\
    \ into the buckets\n        counter += 1\n      else\n        # if we didn't yet\
    \ fill the wells, we need to pour water in the buckets\n        filled += 1\n\
    \      end\n    end\n  end\n  # return the number of times we need to pour water\
    \ into the buckets\n  counter\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
