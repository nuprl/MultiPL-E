name: HumanEval_62_derivative
language: rb
prompt: "# xs represent coefficients of a polynomial.\n# xs[0] + xs[1] * x + xs[2]\
  \ * x^2 + ....\n# Return derivative of this polynomial in the same form.\n# >>>\
  \ derivative([3, 1, 2, 4, 5])\n# [1, 4, 12, 20]\n# >>> derivative([1, 2, 3])\n#\
  \ [2, 6]\ndef derivative(xs)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_derivative\n\
  \    candidate = method(:derivative)\n    assert_equal([1, 4, 12, 20], candidate.call([3,\
  \ 1, 2, 4, 5]))\n    assert_equal([2, 6], candidate.call([1, 2, 3]))\n    assert_equal([2,\
  \ 2], candidate.call([3, 2, 1]))\n    assert_equal([2, 2, 0, 16], candidate.call([3,\
  \ 2, 1, 0, 4]))\n    assert_equal([], candidate.call([1]))\n  end\nend\n"
completions: ["  result = []\n  xs.each_with_index do |coefficient, i|\n    next if\
    \ i == 0\n    result << coefficient * i\n  end\n  result\nend", "  # Your code\
    \ here.\nend", "  result = []\n  (1...xs.length).each do |x|\n    result << xs[x]\
    \ * x\n  end\n  result\nend", "  raise ArgumentError, \"xs must be an array\"\
    \ unless xs.is_a?(Array)\n  raise ArgumentError, \"xs must have at least 2 elements\"\
    \ if xs.size < 2\n  result = []\n  xs.each_with_index do |x, i|\n    next if i\
    \ == 0\n    result << x * i\n  end\n  result\nend", "  xs.each_with_index.inject([])\
    \ do |result, (x, i)|\n    next result if i == 0\n    result << x * i\n  end\n\
    end", "  raise \"xs must not be empty\" if xs.length == 0\n  result = xs.map.with_index\
    \ { |x, i| x * i }\n  result.shift\n  result\nend", "  xs.each_with_index.map\
    \ { |x, i| x * i }.slice(1, xs.length - 1)\nend", "  power = xs.size - 1\n  xs.map\
    \ { |x| x * power }.tap { |xs| xs.pop }\nend", "  (1...xs.length).map { |idx|\
    \ xs[idx] * idx }\nend", "  xs.each_with_index.map { |x,i| x * i if i > 0 }.compact\n\
    end", "  # your code here\nend", "  xs.map.with_index { |num, i| num * i }.drop(1)\n\
    end", "  result = []\n  for i in 0..xs.length - 2\n    result << (i + 1) * xs[i\
    \ + 1]\n  end\n  result\nend", "  xs.map.with_index { |x, i| (i * x) }.drop(1)\n\
    end", "  # YOUR CODE HERE\n  n = xs.length\n  (1...n).map{|i| i * xs[i]}\nend",
  "  result = []\n  xs.each_with_index do |x, i|\n    next if i == 0\n    result <<\
    \ x * i\n  end\n  result\nend", "  xs[1..-1].each_with_index.map{|x, i| x * (i\
    \ + 1)}\nend", "  new_xs = []\n  i = 1\n  while i < xs.length\n    new_xs.push(xs[i]\
    \ * i)\n    i += 1\n  end\n  new_xs\nend", "  len = xs.length\n  len = len - 1\n\
    \  xs.select.with_index { |x, i| i < len }.map.with_index { |x, i| x * (i + 1)\
    \ }\nend", "    arr = []\n    i = 1\n    while i < xs.length\n        arr.push(xs[i]\
    \ * i)\n        i += 1\n    end\n    return arr\nend", "  raise ArgumentError\
    \ unless xs.is_a?(Array)\n  raise ArgumentError unless xs.all? { |el| el.is_a?(Numeric)\
    \ }\n  raise ArgumentError if xs.empty?", "    l = xs.length\n    res = Array.new\n\
    \    for i in 0..l-2\n        res.push(xs[i] * (l-i-1))\n    end\n    return res\n\
    end", "  new_xs = []\n  index = 1\n  xs.drop(1).each do |coefficient|\n    new_xs\
    \ << coefficient * index\n    index += 1\n  end\n  new_xs\nend", "  # `xs` is\
    \ an array of the coefficients\n  # of the polynomial in its simplest form.\n\
    \  # If a polynomial is in the form:\n  # `2x^3 + 3x^2 + x` (`[2, 3, 1]`),\n \
    \ # the derivative is:\n  # `6x^2 + 6x + 1` (`[6, 6, 1]`).\n  xs.size == 1 ? [0]\
    \ : xs.each_cons(2).map { |a, b| a * b }.map { |el| el.to_i }\nend", "  (1...xs.length).each.map{|i|\
    \ xs[i] * i}\nend", "  # your code here\nend", "  xs.length-1.times.with_object([])\
    \ { |i, acc| acc << xs[i+1] * (i+1) }\nend", "  new_arr = []\n  if xs.length >\
    \ 1\n    xs.each_with_index do |x,i|\n      new_arr << x * i if i > 0\n    end\n\
    \  end\n  new_arr\nend", "  result = []\n  i = 1\n  while i < xs.length\n    result\
    \ << i * xs[i]\n    i += 1\n  end\n  result\nend", "  new_xs = xs.clone\n  new_xs.shift\n\
    \  new_xs.map.with_index { |x, i| x * (i + 1) }\nend", "  xs.each_with_index.map\
    \ { |x, i| x * i }.drop(1)\nend", "  new_xs = []\n  xs.each_with_index do |x,\
    \ index|\n    new_xs << index * x if index > 0\n  end\n  new_xs\nend", "    #\
    \ YOUR CODE HERE\nend", "  # Your code here\nend", end, "  raise NotImplementedError\n\
    end", "  new_xs = []\n  i = 1\n  while i < xs.length\n    new_xs << xs[i] * i\n\
    \    i += 1\n  end\n  new_xs\nend", "  #raise NotImplementedError\n  if xs.length\
    \ == 1\n    return []\n  end\n  n = 1\n  ys = []\n  while n < xs.length\n    ys\
    \ << xs[n] * n\n    n += 1\n  end\n  return ys\nend", "  if xs.length == 1\n \
    \   xs = [0]\n  else\n    xs.delete_at(0)\n    xs.map!.with_index do |coefficient,\
    \ idx|\n      if idx == 0\n        coefficient\n      else\n        coefficient\
    \ * idx\n      end\n    end\n  end\n  xs\nend", "  (1...xs.length).map { |x| x\
    \ * xs[x] }\nend", "  result = []\n  i = 1\n  while i < xs.length\n    result\
    \ << xs[i] * i\n    i += 1\n  end\n  result\nend", "  i = 1\n  new_xs = []\n \
    \ while i < xs.length\n    new_xs.push(xs[i] * i)\n    i += 1\n  end\n  new_xs\n\
    end", "  derivative = []\n  xs.each_with_index do |x, i|\n    if i != 0\n    \
    \  derivative << x * i\n    end\n  end\n  derivative\nend", "\txs.map.with_index\
    \ { |x, i| x * i if i > 0 }.compact\nend", end, "  new_array = []\n  index = 0\n\
    \  while index < xs.length\n    if index == 0\n      new_array.push(xs[index])\n\
    \    else\n      new_array.push(xs[index] * index)\n    end\n    index += 1\n\
    \  end\n  new_array.shift\n  new_array\nend", "  dx = []\n  xs.each_with_index\
    \ do |x, i|\n    if i > 0\n      dx << i * x\n    end\n  end\n  dx\nend", "  #\
    \ Write your code here\nend", "  xs.drop(1).each_with_index.map { |x, i| (i +\
    \ 1) * x }\nend", "  if xs.empty?\n    return []\n  end\n  if xs.length == 1\n\
    \    return [0]\n  end\n  xs.each_index.map do |i|\n    if i > 0\n      xs[i]\
    \ * i\n    end\n  end.compact\nend", "  xs[1..-1].map.with_index { |x, i| x *\
    \ (i + 1) }\nend", "\txs.each_with_index.collect { |x, index| x*index }.drop(1)\n\
    end", "  xs.select.with_index { |_, i| i > 0 }.map.with_index { |x, i| x * (i\
    \ + 1) }\nend", "  xs.each_index.map { |i| xs[i] * i }.drop(1)\nend", "  result\
    \ = []\n  if xs.empty?\n    return result\n  end\n  xs.each_with_index do |x,\
    \ i|\n    next if i == 0\n    result << i * x\n  end\n  result\nend", "  # YOUR\
    \ CODE HERE\n  new_array = Array.new\n  (1..xs.length - 1).each do |i|\n    new_array\
    \ << xs[i] * i\n  end\n  new_array\nend", "  derivative = []\n  xs.each_with_index\
    \ do |x, idx|\n    derivative << x * idx unless idx == 0\n  end\n  derivative\n\
    end", "  #...\nend", "  new_xs = []\n  if xs.length > 1\n    counter = 1\n   \
    \ xs.each do |x|\n      new_xs << counter * x\n      counter += 1\n    end\n \
    \   new_xs.shift\n  end\n  new_xs\nend", "  xs.drop(1).map.with_index{|x,i| x\
    \ * (i+1)}\nend", "    xs_deriv = []\n    (1...xs.length).each do |i|\n      \
    \  xs_deriv << i * xs[i]\n    end\n    xs_deriv\nend", "    xs.collect.with_index\
    \ { |item, index| item * index }.drop(1)\nend", "  xs[1..-1].map.with_index {\
    \ |x, i| x * (i + 1) }\nend", "  i = 1\n  res = []\n  while i < xs.length\n  \
    \  res << xs[i] * i\n    i += 1\n  end\n  res\nend", "  xs.each_index.map { |i|\
    \ xs[i] * i }.drop(1)\nend", "    xs[1..-1].map.with_index{|x, i| (i+1) * x}\n\
    end", "\treturn [] if xs.empty?\n\tderivative = []\n\tfor i in 0..xs.length-2\n\
    \t\tderivative.push(xs[i+1] * (i+1))\n\tend\n\tderivative\nend", "  new_xs = []\n\
    \  xs.each_with_index do |x, idx|\n    new_xs << x * idx if idx > 0\n  end\n \
    \ new_xs\nend", "  new_xs = []\n  xs.each_with_index do |coefficient, degree|\n\
    \    next if degree == 0\n    new_xs << coefficient * degree\n  end\n  new_xs\n\
    end", "    result = Array.new\n    i = 0\n    xs.each do |x|\n        if (i ==\
    \ 0)\n            i += 1\n            next\n        end\n        result.push(x\
    \ * i)\n        i += 1\n    end\n    return result\nend", "  result = []\n  for\
    \ i in 1...xs.length\n    result.push(xs[i] * i)\n  end\n  return result\nend",
  "  xs.each_with_index.map do |x, i|\n    x * i\n  end.drop(1)\nend", "\tderivative_xs\
    \ = []\n\tlen = xs.length\n\tif len == 1\n\t\treturn derivative_xs\n\tend\n\t\
    len.times do |i|\n\t\tif i == 0\n\t\t\tnext\n\t\tend\n\t\tderivative_xs << xs[i]\
    \ * i\n\tend\n\treturn derivative_xs\nend", "  result = []\n  for i in 1..xs.length\n\
    \    result << xs[i] * i\n  end\n  result\nend", "  derivative = []\n  length\
    \ = xs.length", "  # REPLACE ME\nend", "  result = []\n  # YOUR CODE HERE\n  return\
    \ result\nend", "  new_array = []\n  counter = 1\n  xs.each do |x|\n    new_array\
    \ << x * counter\n    counter += 1\n  end\n  new_array.delete_at(0)\n  new_array\n\
    end", "  derivative = []\n  i = 1\n  xs.length.times do\n    if xs[i] != nil\n\
    \      derivative.push(xs[i] * i)\n    end\n    i += 1\n  end\n  derivative\n\
    end", "  xs.each_index.reduce([]) do |result, i|\n    result << xs[i] * i if i\
    \ != 0\n    result\n  end\nend", "\tout = Array.new\n\tfor i in 0..xs.length-2\n\
    \t\tout << xs[i+1] * (i+1)\n\tend\n\treturn out\nend", "  derivs = []\n  i = 1\n\
    \  xs.length.times do\n    derivs << i * xs[i - 1]\n    i += 1\n  end\n  derivs\n\
    end", "    z = xs[1..-1]\n    z.zip((1..xs.length-1).to_a).map {|x, y| x * y}\n\
    end", "  derivative = []\n  (1...xs.length).each do |i|\n    derivative.push(xs[i]\
    \ * i)\n  end\n  derivative\nend", "  result = []\n  n = xs.length\n  n.times\
    \ do |i|\n    if i > 0\n      result.push(xs[i] * i)\n    end\n  end\n  result\n\
    end", "  d = []\n  xs.each_with_index do |x, i|\n    # d[i] = i * x\n    if i\
    \ > 0\n      d << i * x\n    end\n  end\n  d\nend", "  dxs = []\n  xs.each_with_index\
    \ do |x, index|\n    dxs << (index * x)\n  end\n  dxs.shift\n  dxs\nend", "  xs.each_index.with_object([])\
    \ do |i, derivative|\n    derivative << (xs[i] * i) unless i.zero?\n  end\nend",
  "    new_xs = []\n    xs.each_with_index do |x, i|\n        next if i == 0\n   \
    \     new_xs << x * i\n    end\n    new_xs\nend", "  xs.map.with_index{|n, i|\
    \ n * i}.drop(1)\nend", "\t# return a list of the coefficients of the derivative",
  "  xs[1..-1].map.with_index { |x, i| x * (i + 1) }\nend", "\t(1...xs.length).map\
    \ { |i| xs[i] * i }\nend", "  xs[1..-1].map.with_index{|x, i| x * (i + 1)}\nend",
  "  xs.drop(1).map.with_index(1) { |x, i| x * i }\nend", "  xs.each_with_index.map\
    \ do |x, i|\n    x * i if i > 0\n  end.compact\nend", "  sum = 0\n  result = []\n\
    \  xs.each_with_index do |x, index|\n    if xs[index + 1] != nil\n      if index\
    \ == 0\n        result << xs[index + 1]\n      else\n        result << (xs[index]\
    \ * index)\n      end\n    end\n  end\n  result\nend", "  result = []\n  xs.each_with_index\
    \ do |coef, idx|\n    result << coef * idx if idx > 0\n  end\n  result\nend",
  "  xs.map.with_index { |e, i| e * i }.drop(1)\nend", "  xs[1..-1].map.with_index\
    \ { |x, i| (i + 1) * x }\nend", "    new_arr = []\n    xs.each_with_index do |num,\
    \ index|\n        if index == 0\n            new_arr.push(0)\n        else\n \
    \           new_arr.push(num * index)\n        end\n    end\n    new_arr\nend",
  "  result = []\n  (1...xs.length).each do |i|\n    result << xs[i] * i\n  end\n\
    \  result\nend", "\tres = []\n\txs.each_with_index do |x, i|\n\t\tif i == 0\n\t\
    \t\tres << 0\n\t\telse\n\t\t\tres << i * x\n\t\tend\n\tend\n\tres\nend", "  xs.each_with_index.map\
    \ { |x, i| x * i }.reject { |x| x == 0 }\nend", "  r = []\n  n = xs.length\n \
    \ n.times do |i|\n    if i > 0\n      r << xs[i] * i\n    end\n  end\n  r\nend",
  end, "\tif xs.length <= 1\n\t\t[0]\n\telse\n\t\txs[1..xs.length-1].each_with_index.map\
    \ { |x, i| x * (i+1) }\n\tend\nend", "  derivative = []\n  # x_0' = 0\n  # x_1'\
    \ = 1\n  # x_2' = 2 * x_1\n  # x_3' = 3 * x_2 = 3 * 2 * x_1\n  # x_4' = 4 * x_3\
    \ = 4 * 3 * 2 * x_1\n  for i in 1..xs.length\n    derivative << i * xs[i-1]\n\
    \  end\n  derivative\nend", "  new_xs = xs[1..-1]\n  new_xs.each_with_index do\
    \ |x, i|\n    new_xs[i] = x * (i + 1)\n  end\n  new_xs\nend", "  xs[1..-1].each_with_index.map{|x,\
    \ i| (i+1) * x}\nend", "  result = []\n  xs.each_with_index do |x, idx|\n    next\
    \ if idx == 0\n    result << x * idx\n  end\n  result\nend", "  #your code here\n\
    end", "  xs.each_with_index.map { |x, i| i > 0 ? i * x : 0 }\nend", "  result\
    \ = []\n  xs.each_with_index do |x, index|\n    result.push(index * x)\n  end\n\
    \  result.shift\n  result\nend", "  xs.each_with_index.inject([]) do |acc, (x,\
    \ idx)|\n    acc << x * idx unless idx == 0\n    acc\n  end\nend", "  xs.each_with_index.map\
    \ do |coef, index|\n    next 0 if index == 0\n    coef * index\n  end.compact\n\
    end", "  (1...xs.length).map { |i| xs[i] * i }\nend", "  new_arr = []\n  (1...xs.length).each\
    \ do |i|\n    new_arr << xs[i] * i\n  end\n  new_arr\nend", "    x = xs.length\n\
    \    c = 0\n    xs.each do |x|\n        xs[c] = xs[c] * c\n        c += 1\n  \
    \  end\n    xs.shift\n    return xs\nend", "  polynomial = xs.dup\n  dxs = []\n\
    \  polynomial.shift\n  polynomial.each_with_index do |x, index|\n    # the polynomial\
    \ xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    # is a derivative of the polynomial\
    \ xs[1] + xs[2] * x + xs[3] * x^2 + ....\n    dxs << (index + 1) * x\n  end\n\
    \  dxs\nend", "\tresult = []\n\ti = 1\n\twhile i < xs.length do\n\t\tresult <<\
    \ xs[i] * i\n\t\ti += 1\n\tend\n\tresult\nend", "  return xs[1..-1].map.with_index{|x,i|\
    \ (i+1)*x}\nend", "  xs[1..-1].zip(1..xs.length-1).map { |x, i| x * i }\nend",
  "  xs.inject([]) { |xs, x| xs << x * xs.size }[1..-1]\nend", "  xs.drop(1).zip(0...xs.length).map\
    \ { |a, b| a * b }\nend", "  xs[1..-1].each_with_index.map { |x, i| x * (i + 1)\
    \ }\nend", "    if xs.length == 1\n        return []\n    end\n    out = []\n\
    \    i = 1\n    while i < xs.length\n        out.push(xs[i] * i)\n        i +=\
    \ 1\n    end\n    return out\nend", "  if xs.size == 1\n    [0]\n  else\n    xs.each_with_index.map\
    \ do |x, idx|\n      if idx == 0\n        0\n      else\n        x * idx\n   \
    \   end\n    end\n  end\nend", "  i = 0\n  j = 1\n  result = []\n  xs.each do\
    \ |x|\n    if i > 0\n      result << x * i\n    end\n    i += 1\n  end\n  result\n\
    end", "  derivative = []\n  xs.each_with_index do |coefficient, index|\n    if\
    \ index != 0\n      derivative << coefficient * index\n    end\n  end\n  derivative\n\
    end", "  derivative = []\n  (1...xs.length).each do |i|\n    derivative << i *\
    \ xs[i]\n  end\n  derivative\nend", "  ys = xs[1..-1]\n  ys.map.with_index { |x,\
    \ i| x * (i + 1) }\nend", "    result = Array.new(xs.length - 1)\n    result.each_index\
    \ do |i|\n        result[i] = xs[i + 1] * (i + 1)\n    end\n    result\nend",
  "    res = []\n    xs.each_with_index do |x, i|\n        res << x * i if i > 0\n\
    \    end\n    res\nend", "  raise ArgumentError, \"xs is empty\" if xs.empty?\n\
    \  new_list = []\n  xs.each_with_index do |item, index|\n    new_list.push(index\
    \ * item) if index != 0\n  end\n  new_list\nend", "\tnew_arr = []\n\tif xs.size\
    \ == 1\n\t\treturn []\n\telse\n\t\tfor i in 1..xs.size\n\t\t\tnew_arr << xs[i]\
    \ * i\n\t\tend\n\tend\n\tnew_arr\nend", "  xs.length == 1 ? [] : xs.each_with_index.map\
    \ { |num, idx| num * idx if idx != 0 }.compact\nend", "  result = []\n  xs.each_with_index\
    \ do |x, i|\n    if i > 0\n      result << x * i\n    end\n  end\n  result\nend",
  "  new_arr = []\n  xs.each_with_index do |x, idx|\n    next if idx == 0\n    new_arr\
    \ << x * idx\n  end\n  new_arr\nend", "\tresult = []\n\ti = 1\n\twhile i < xs.length\n\
    \t\tresult << i * xs[i]\n\t\ti += 1\n\tend\n\tresult\nend", "  dxs = []\n  xs.each_with_index\
    \ do |x, i|\n    dxs << x * i\n  end\n  dxs.shift\n  dxs\nend", "  #xs.each_with_index.map\
    \ { |x, i| (i + 1) * x if i > 0 }.compact\n  xs.each_with_index.map { |x, i| \
    \ (i + 1) * x }.drop(1)\nend", "  xs[1..-1].map.with_index { |x, i| x * (i + 1)\
    \ }\nend", "  xs_derivative = []\n  n = xs.length\n  for i in 1..n-1\n    xs_derivative\
    \ << i * xs[i]\n  end\n  return xs_derivative\nend", "  ans = []\n  xs.each_with_index\
    \ do |x, i|\n    if i != 0\n      ans << x * i\n    end\n  end\n  ans\nend", " \
    \ result = []\n  # if xs.size == 0\n  #   return result\n  # else\n  #   for i\
    \ in 0..xs.size-1\n  #     result << xs[i] * i\n  #   end\n  # end\n  # result.shift\n\
    \  # result\n  xs.map.with_index { |x,i| x * i }.shift\nend", "    # Your code\
    \ here.\n    xs.zip(1..xs.length).map { |x,i| x * i }[1..-1]\nend", "  #xs = []\n\
    \  #xs.each.with_index do |x, i|\n  #  xs << x * i\n  #end\n  #xs.shift\n  xs.map.with_index\
    \ { |x, i| x * i }.drop(1)\nend", "  new_array = []\n  n = xs.length\n  n.times\
    \ do |i|\n    # xs[i] * i\n    new_array << xs[i] * i\n  end\n  return new_array[1..-1]\n\
    end", "  result = []\n  xs.each_with_index do |x, i|\n    result << (i * x)\n\
    \  end\n  result.pop\n  result\nend", "  # ... REPLACE THIS ...\nend", "  xs.each_with_index.map\
    \ do |x, index|\n    x * index\n  end.drop(1)\nend", "\tnew_array = []\n\ti =\
    \ 0\n\twhile i < xs.length\n\t\tnew_array << xs[i] * i\n\t\ti += 1\n\tend\n\t\
    new_array.delete_at(0)\n\treturn new_array\nend", "  derive = []\n  i = 1\n  xs.each\
    \ do |x|\n    derive << x * i\n    i += 1\n  end\n  derive.shift\n  derive\nend",
  "  if xs.length == 1\n    return [0]\n  end\n  new_xs = []\n  xs.each_with_index\
    \ do |x, i|\n    new_xs.push(x * i)\n  end\n  new_xs.shift\n  return new_xs\n\
    end", "  # TODO: Implement me\n  dxs = Array.new(xs.length-1)\n  count = 0\n \
    \ xs.each do |x|\n    dxs[count] = x * count if count > 0\n    count += 1\n  end\n\
    \  dxs\nend", "    if xs.length > 1\n        xs.each_with_index.map { |num, index|\
    \ num * index if index > 0 }.compact\n    else\n        [0]\n    end\nend", " \
    \ new_xs = []\n  xs.each_with_index do |x, idx|\n    if idx > 0\n      new_xs\
    \ << x * idx\n    end\n  end\n  new_xs\nend", "  i = 0\n  derivative = []\n  while\
    \ i < xs.length - 1\n    derivative << xs[i + 1] * (i + 1)\n    i += 1\n  end\n\
    \  derivative\nend", "\tresult = []\n\tif xs.length == 1\n\t\tresult << 0\n\t\
    else\n\t\tfor x in 0..xs.length-2\n\t\t\tresult << xs[x+1] * (x+1)\n\t\tend\n\t\
    end\n\tresult\nend", "  # YOUR CODE HERE\n  xs[1..-1].map.with_index{|x, i| x\
    \ * (i + 1)}\nend", "  raise ArgumentError if xs.size == 0\n  powers = (1..xs.size).to_a\n\
    \  xs.zip(powers).map{|a,b| a*b}.drop(1)\nend", "  xs[1..-1].map.with_index {\
    \ |x, i| x * (i + 1) }\nend", "  derivative = []\n  if xs.length == 1\n    derivative.push(0)\n\
    \  else\n    xs.length.times do |num|\n      derivative.push(xs[num] * num)\n\
    \    end\n    derivative.shift\n  end\n  derivative\nend", "\tlen = xs.length\n\
    \tnew_xs = []\n\tlen.times do |i|\n\t\tnew_xs << xs[i] * i if i > 0\n\tend\n\t\
    new_xs\nend", "    # add your code here\n    xs.each_index.with_object([]) do\
    \ |idx, arr|\n        arr << xs[idx] * idx unless idx == 0\n    end\nend", " \
    \ res = []\n  (1...xs.length).each do |i|\n    res << i * xs[i]\n  end\n  res\n\
    end", "\tderivative_array = []\n\t\n\txs.each_with_index do |x, index|\n\t\tif\
    \ index > 0\n\t\t\tderivative_array << x * index\n\t\tend\n\tend\n\t\n\tderivative_array\n\
    end", "  xs.each_with_index.map { |c, i|\n    c * i\n  }.drop(1)\nend", "  xs.each_with_index.map\
    \ do |x, i|\n    if i > 0\n      x * i\n    end\n  end.compact\nend", "  result\
    \ = []\n  xs.each_with_index do |element, index|\n    if index != 0\n      result\
    \ << element * index\n    end\n  end\n  result\nend", "  xs.each_with_index.map\
    \ { |x, i| i > 0 ? i * x : 0 }\nend", "  xs.each_with_index.map do |a, i|\n  \
    \  a * i if i > 0\n  end.compact\nend", "  new = []\n  count = 1\n  xs.each do\
    \ |i|\n    new << i * count\n    count += 1\n  end\n  new.shift\n  new\nend",
  "  xs.drop(1).map.with_index { |x, i| (i + 1) * x }\nend", "  # Your code here\n\
    end", "  result = []\n  i = 1\n  while i < xs.length\n    result << xs[i] * i\n\
    \    i += 1\n  end\n  result\nend", "  xs.each_with_index.map { |x, i| i == 0\
    \ ? nil : i * x }.compact\nend", "  result = []\n  xs.each_with_index do |num,\
    \ idx|\n    if idx != 0\n      result << num * idx\n    end\n  end\n  result\n\
    end", end, "  ret = []\n  for i in 1..xs.length - 1\n    ret.push(xs[i] * i)\n\
    \  end\n  return ret\nend", "\txs.map.with_index { |x, index| x * index }.drop(1)\n\
    end", "  xs.each_with_index.map { |x, i| x * i }.drop(1)\nend", "  if xs.count\
    \ > 1\n    xs.drop(1).map.with_index { |item, index| item * (index + 1) }\n  else\n\
    \    [0]\n  end\nend", "  if xs.size == 1\n    []\n  else\n    (1...xs.size).map\
    \ { |i| xs[i] * i }\n  end\nend", "  i = 0\n  xs.map do |x|\n    i += 1\n    next\
    \ if i == 1\n    x * i\n  end.compact\nend", "  (1...xs.length).map { |i| xs[i]\
    \ * i }\nend", "  xs.each_with_index.map { |x, i| i * x }.drop(1)\nend", "\tderivative\
    \ = []\n\txs.each_with_index do |coef, index|\n\t\tif index != 0\n\t\t\tderivative\
    \ << coef * index\n\t\tend\n\tend\n\tderivative\nend", "  xs.each_index.map {\
    \ |i| xs[i] * i }.drop(1)\nend", "  xs.each_with_index.map do |n, i|\n    n *\
    \ i\n  end.tap { |ys| ys.delete_at(0) }\nend", "  newArr = []\n  i = 1\n  while\
    \ i < xs.length\n    y = xs[i] * i\n    newArr.push(y)\n    i = i + 1\n  end\n\
    \  return newArr\nend", "  result = []\n  xs.each_with_index do |x, index|\n \
    \   if index > 0\n      result << x * index\n    end\n  end\n  result\nend", " \
    \ # YOUR CODE HERE\n  # I think this is the most readable one\n  # but it sucks\
    \ in terms of performance\n  # I need to do some R&D on how to build new array\
    \ from old one\n  # without using .each\n  arr = Array.new()\n  xs.each_with_index\
    \ do |x, index|\n    unless index == 0\n      arr.push(x * index)\n    end\n \
    \ end\n  arr\nend", "  raise \"not enough arguments\" if xs.length == 0\n  results\
    \ = []\n  power = 1\n  xs.each do |x|\n    results << x * power\n    power +=\
    \ 1\n  end\n  results.drop(1)\nend", "  (1...xs.length).map{|i| xs[i] * i}\nend",
  "  xs.each_with_index.map { |x, i| x * i if i > 0 }.compact\nend", "  xs.each_with_index.map\
    \ { |x,i| x * i if i > 0 }.compact\nend", "  raise NotImplementedError\nend",
  "  derivative = []\n  order = xs.length - 1\n  xs.each_with_index do |item, i|\n\
    \    derivative << item * (order - i)\n  end\n  derivative.shift\n  derivative\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
