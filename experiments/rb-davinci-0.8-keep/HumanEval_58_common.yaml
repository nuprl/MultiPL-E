name: HumanEval_58_common
language: rb
prompt: "# Return sorted unique common elements for two lists.\n# >>> common([1, 4,\
  \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\ndef common(l1, l2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_common\n\
  \    candidate = method(:common)\n    assert_equal([1, 5, 653], candidate.call([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\n    assert_equal([2, 3], candidate.call([5,\
  \ 3, 2, 8], [3, 2]))\n    assert_equal([2, 3, 4], candidate.call([4, 3, 2, 8], [3,\
  \ 2, 4]))\n    assert_equal([], candidate.call([4, 3, 2, 8], []))\n  end\nend\n"
completions: ["  (l1 & l2).sort\nend", "  l1 & l2\nend", "  l1.uniq.sort & l2.uniq.sort\n\
    end", "  com = []\n  l1.each do |n|\n    if l2.include?(n)\n      com << n\n \
    \   end\n  end\n  com.uniq.sort\nend", end, "  #your code here\n  a = l1 & l2\n\
    \  a.sort!\nend", "  l1.select { |i| l2.include?(i) }.uniq.sort\nend", "  l1 &\
    \ l2\nend", "\tp (l1 | l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "  #\
    \ Your code here\nend", "  l1 = l1.sort\n  l2 = l2.sort\n  l3 = []\n  l1.each\
    \ do |x|\n    l2.each do |y|\n      if x == y\n        l3 << x\n      end\n  \
    \  end\n  end\n  l3.uniq!\n  return l3\nend", "  (l1 & l2).sort\nend", "  (l1\
    \ & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  # TODO\nend", "  l1 & l2\n\
    end", "  (l1 & l2).sort\nend", "  (l1 & l2).sort_by { |i| i }\nend", "  # you\
    \ can use l1 & l2 to get the sorted, uniq common elements of 2 arrays\n  # (l1\
    \ & l2).sort\n  # we can simply do the following:\n  l1 & l2\nend", "  l1.select\
    \ { |num| l2.include?(num) }.uniq.sort\nend", "  l1 & l2\nend", "  common_elements\
    \ = []\n  l1.each do |elem|\n    if l2.include?(elem)\n      common_elements <<\
    \ elem\n    end\n  end\n  common_elements.uniq.sort\nend", "\t#write your code\
    \ here\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "    return (l1\
    \ & l2).sort\nend", "  l1.sort.uniq & l2.sort.uniq\nend", "\tl3 = []\n\tl1.each\
    \ do |i|\n\t\tif l2.include?(i)\n\t\t\tl3 << i\n\t\tend\n\tend\n\tl3.uniq!\n\t\
    l3.sort!\n\treturn l3\nend", "\nend", "  l1 & l2\nend", "\tl1.select { |x| l2.include?(x)\
    \ }.uniq.sort\nend", "\th = {}\n\tl = []\n\tl1.each { |n| h[n] = \"D\" }\n\tl2.each\
    \ { |n| h[n] = \"D\" if h[n] == \"D\" }\n\th.each_key { |k| l << k }\n\tl.sort\n\
    end", "\nend", "  l1 & l2\nend", "  l1.reject { |x| (l2 & [x]).empty? }.uniq.sort\n\
    end", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\nend", "    uniqs = []\n\
    \    l1.each { |element| uniqs << element if l2.include?(element) }\n    uniqs.uniq.sort\n\
    end", "\t(l1 & l2).sort.uniq\nend", "  l1 & l2\nend", "  (l1 & l2).sort.uniq\n\
    end", "  common_elements = l1 & l2\n  common_elements.sort\nend", "  l1 & l2\n\
    end", "  l1 & l2\nend", "  (l1 & l2).sort\nend", "  ary = []\n  l1.each do |i|\n\
    \    ary << i if l2.include?(i)\n  end\n  ary.uniq.sort\nend", "  l1.sort.uniq\
    \ & l2.sort.uniq\nend", "  arr = []\n  if l1.empty? || l2.empty?\n    return []\n\
    \  else\n    # l1.each do |x|\n    #   if l2.include?(x)\n    #     arr << x\n\
    \    #   end\n    # end\n    arr = l1 & l2\n    return arr.uniq.sort\n  end\n\
    end", "  l1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  return [] if l1.empty?\
    \ || l2.empty?\n  l1.uniq.sort & l2.uniq.sort\nend", "  (l1 & l2).sort\nend",
  "  l1.select { |x| l2.include?(x) }.uniq.sort\nend", "  l1 & l2\nend", "  l1 & l2\n\
    end", "    @com = []\n    l1.each do |element|\n        l2.each do |element2|\n\
    \            if element == element2\n                @com << element\n       \
    \     end\n        end\n    end\n    return @com.uniq.sort\nend", "  # your code\
    \ here\nend", "  (l1 & l2).sort\nend", "\treturn nil if l1.nil? || l2.nil?\n\t\
    [l1, l2].inject(:&).sort\nend", "\tcommon = l1 & l2\n\tcommon.sort\nend", "  (l1\
    \ & l2).sort\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "\nend",
  "\t(l1 & l2).sort\nend", "  # return the sorted array with uniq values\n  (l1 &\
    \ l2).sort\nend", "  common_array = l1.select { |x| l2.include?(x) }\n  common_array.uniq.sort\n\
    end", "  l2 & l1\nend", "  return l1 & l2\nend", "\nend", "  arr = l1 & l2\n \
    \ arr.sort\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "    l1 &\
    \ l2\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\n\
    end", "\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "    # TODO:\
    \ your code here\n    (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1\
    \ & l2).sort\nend", "  list1 = l1.uniq.sort\n  list2 = l2.uniq.sort\n  list1 &\
    \ list2\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ (l1 & l2).sort\nend", "  l1 = l1.sort\n  l2 = l2.sort\n  result = []\n  l1.each\
    \ { |n| result << n if l2.include?(n) }\n  result.uniq\nend", "  # code here\n\
    end", "  (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\n\
    end", "  l1.uniq.sort & l2.uniq.sort\nend", "\tanswer = []\n\tl1.each do |num|\n\
    \t\tl2.each do |number|\n\t\t\tif num == number\n\t\t\t\tanswer << num\n\t\t\t\
    end\n\t\tend\n\tend\n\tanswer.uniq.sort\nend", "  (l1 & l2).sort.uniq\nend", " \
    \ (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\nend",
  "\treturn (l1.uniq & l2.uniq).sort\nend", "  (l1 & l2).sort.uniq\nend", "  l1 &\
    \ l2\nend", "  (l1 & l2).sort.uniq\nend", "\nend", "  l1 & l2\nend", "\tarr =\
    \ []\n\tl1.each { |i| arr << i if l2.include?(i) }\n\tarr.uniq\nend", "  (l1 &\
    \ l2).sort\nend", "  # 1. add all elements from l1 and l2 to one array called\
    \ result\n  # 2. delete all duplicates\n  # 3. sort array\n  # 4. return result",
  "\tcommon_elements = []\n\tl1.each do |element|\n\t\tif l2.include?(element)\n\t\
    \t\tcommon_elements << element\n\t\tend\n\tend\n\treturn common_elements.uniq.sort\n\
    end", "\t(l1 & l2).sort\nend", "  # s1 = Set.new(l1)\n  # s2 = Set.new(l2)\n \
    \ # s1.intersection(s2).to_a\n  l1 & l2\nend", "\nend", "  (l1 & l2).sort\nend",
  "  l1.uniq.select{|element| l2.include?(element)}.sort\nend", "  l1.uniq.sort &\
    \ l2.uniq.sort\nend", "  #l1 & l2\n  (l1 & l2).sort!\nend", "\tarray1 = l1.uniq.sort\n\
    \tarray2 = l2.uniq.sort\n\t# find the shorter of the two arrays\n\tshortest =\
    \ array1.length < array2.length ? array1 : array2\n\t# initialize an empty array\
    \ to house the elements in common\n\tcommon = []\n\t# compare each element in\
    \ the shortest array to each element in the other\n\tshortest.each do |x|\n\t\t\
    if array1.include?(x) && array2.include?(x)\n\t\t\tcommon << x\n\t\tend\n\tend\n\
    \t# return a new array with the elements in common\n\tcommon\nend", "    n = []\n\
    \    l1.each { |i| l2.each { |j| n << i if i == j } }\n    n.uniq.sort\nend",
  "    l3 = l1 & l2\n    l3.sort\nend", "    l1.uniq.sort.keep_if { |x| l2.uniq.sort.include?(x)\
    \ }\nend", "  l1 & l2\nend", "  (l1 & l2).sort\nend", "    (l1 & l2).sort\nend",
  "  l1.uniq.sort & l2.uniq.sort\nend", "    # l1 & l2\n    (l1 & l2).sort\nend",
  "  (l1 & l2).sort\nend", "  s1 = Set.new(l1)\n  s2 = Set.new(l2)\n  (s1 & s2).to_a.sort\n\
    end", "  l1 & l2\nend", "    com = l1 & l2\n    com.sort.uniq\nend", "  l1 & l2\n\
    end", "    a = l1.sort\n    b = l2.sort\n    arr = []\n    a.each do |x|\n   \
    \     b.each do |y|\n            if x == y\n                arr << x\n       \
    \     end\n        end\n    end\n    arr.uniq\nend", "    l1 & l2\nend", "  #\
    \ (l1 & l2).sort\n  l1.each_with_object([]) do |value, arr|\n    arr << value\
    \ if l2.include?(value)\n  end.sort\nend", "  (l1 & l2).sort\nend", "\t(l1 & l2).sort\n\
    end", "  l1 & l2\nend", "    (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend",
  "    new_array = []\n    l1.each do |item|\n        if l2.include?(item) && !new_array.include?(item)\n\
    \            new_array << item\n        end\n    end\n    new_array.sort\nend",
  "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort\nend", "    (l1 & l2).sort\nend",
  "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "  l1.each_with_object(Array.new)\
    \ do |e, arr|\n    arr << e if l2.include?(e)\n  end.uniq.sort\nend", "  h1 =\
    \ {}\n  l1.each do |v|\n    h1[v] = true\n  end\n  h2 = {}\n  l2.each do |v|\n\
    \    h2[v] = true\n  end\n  h3 = {}\n  h1.each do |k, v|\n    if h2[k]\n     \
    \ h3[k] = true\n    end\n  end\n  h3.keys.sort\nend", "  return l1 & l2\nend",
  "  return l1.sort.uniq & l2.sort.uniq\nend", "\nend", "  return l1 & l2\nend", "\t\
    (l1 & l2).sort.uniq\nend", "\t(l1 & l2).sort\nend", "  # TODO: Return sorted unique\
    \ common elements for two lists.\n  l1 & l2\nend", "    l1.select{|n| l2.include?(n)}.uniq.sort\n\
    end", "  # your code here\nend", "  result = []\n  l1.each do |element|\n    if\
    \ l2.include?(element)\n      result << element\n    end\n  end\n  result.uniq.sort\n\
    end", "  (l1 & l2).sort\nend", "  # FILL ME IN\nend", "  (l1 & l2).sort\nend",
  "\nend", "  (l1 & l2).sort\nend", "  (l1 & l2).sort\nend", "    l1.uniq.sort & l2.uniq.sort\n\
    end", "  unique_elements = []\n  # store elements in hash with values set to true\n\
    \  hash = {}\n  l1.each { |item| hash[item] = true }\n  l2.each { |item| hash[item]\
    \ = true }\n  hash.each { |k, v| unique_elements << k if v }\n  unique_elements.sort\n\
    end", "\t(l1 & l2).sort\nend", "\tl1.uniq.sort & l2.uniq.sort\nend", "  #get all\
    \ unique values from l1 and l2\n  l1.uniq!\n  l2.uniq!\n  #get all common values\
    \ by getting the intersection of l1 and l2\n  common = l1 & l2\n  #sort the list\
    \ of common values\n  common.sort\nend", "  #l1 & l2\n  l1.select { |a| l2.include?(a)\
    \ }.uniq.sort\nend", "  l1 & l2\nend", "  # p l1\n  # p l2\n  # a = (l1 & l2).sort\n\
    \  # return a\n  l1 & l2\nend", "  l1 & l2 # or l1.to_set.intersection(l2.to_set).to_a.sort\n\
    end", "    #new_arr = []\n    #l1.each do |i|\n    #    if l2.include?(i)\n  \
    \  #        new_arr << i\n    #    end\n    #end\n    #new_arr.uniq.sort\n   \
    \ new_arr = l1 & l2\n    new_arr.uniq.sort\nend", "  (l1 & l2).sort.uniq\nend",
  "  # YOUR CODE HERE\nend", "  l1.select { |x| l2.include?(x) }.uniq.sort\nend",
  "  # TODO: Implement this method\n  # return l1 & l2\n  l1.select{|x| l2.include?(x)}.uniq.sort\n\
    end", "\tl1 = l1.sort\n\tl2 = l2.sort\n\tl1.uniq.select{|x| l2.include?(x)}\n\
    end", "\tl1 & l2\nend", "  (l1 & l2).sort.uniq\nend", "  l1 & l2\nend", "  uniq_l1\
    \ = l1.uniq.sort\n  uniq_l2 = l2.uniq.sort\n  if uniq_l1.length > uniq_l2.length\n\
    \    uniq_l1 & uniq_l2\n  else\n    uniq_l2 & uniq_l1\n  end\nend", "  return\
    \ (l1 & l2).sort\nend", "  (l1 & l2).sort.uniq\nend", "  common_eles = l1 & l2\n\
    \  common_eles.sort.uniq\nend", "  l1 & l2\nend", "  (l1 & l2).sort\nend", end,
  "\nend", "  # return (l1 & l2).sort\n  (l1 & l2).sort { |x, y| x <=> y }\nend",
  "  (l1 & l2).sort\nend", "  l1 & l2\nend", "    l1 & l2\nend", "\t((l1 & l2).sort).uniq\n\
    end", "  l1 & l2 # Using & operator to get common elements of two lists.\nend",
  "\tif l1.size >= l2.size\n\t\tl2.select { |e| l1.include?(e) }.uniq.sort\n\telse\n\
    \t\tl1.select { |e| l2.include?(e) }.uniq.sort\n\tend\nend", "  l1 & l2\nend",
  "  (l1 & l2).sort.uniq\nend", "  (l1 & l2).sort.uniq\nend", "  # your code here\n\
    end", "  count = []\n  l1.each do |value|\n    count << value if l2.include?(value)\n\
    \  end\n  count.uniq.sort\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
