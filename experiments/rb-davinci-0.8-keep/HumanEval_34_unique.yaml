name: HumanEval_34_unique
language: rb
prompt: "# Return sorted unique elements in a list\n# >>> unique([5, 3, 5, 2, 3, 3,\
  \ 9, 0, 123])\n# [0, 2, 3, 5, 9, 123]\ndef unique(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_unique\n\
  \    candidate = method(:unique)\n    assert_equal([0, 2, 3, 5, 9, 123], candidate.call([5,\
  \ 3, 5, 2, 3, 3, 9, 0, 123]))\n  end\nend\n"
completions: ["\tl.each do |num|\n\t\tif l.count(num) != 1\n\t\t\tl.delete(num)\n\t\
    \tend\n\tend\n\tl.sort\nend", "  l.sort.uniq\nend", "  l.to_set.to_a\nend", " \
    \ raise ArgumentError, \"Argument #{l} is not an array\" unless l.is_a?(Array)\n\
    \  l.inject([]) { |a, x| a.include?(x) ? a : a << x }.sort\nend", "    l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  raise NotImplementedError\nend", "  l.sort.uniq\n\
    end", "  # ...\nend", "  l.uniq.sort\nend", "  raise 'unique() takes a list as\
    \ an argument' unless l.is_a?(Array)\n  raise 'unique() only take a list of numbers\
    \ as an argument' unless l.all? { |el| el.is_a?(Integer) }\n  l.uniq.sort\nend",
  "  l.sort.uniq\nend", "  a = []\n  l.each do |v|\n    a << v unless a.include?(v)\n\
    \  end\n  a\nend", "    p l.uniq\nend", "    return l.uniq\nend", "  l.uniq.sort\n\
    end", "  # TODO: implement this\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  l.uniq!\n  l.sort!\nend", "  l.sort.uniq\nend", "  # TODO\nend", "  l.uniq.sort\n\
    end", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.uniq.sort\nend", "  l.uniq.sort\n\
    end", "  l.uniq.sort\nend", "  sorted = l.sort\n  unique = []\n  sorted.each do\
    \ |e|\n    unique << e unless unique.include?(e)\n  end\n  unique\nend", "  l.sort.uniq\n\
    end", "  l.uniq.sort\nend", "  l.sort.uniq\nend", "  return l.uniq.sort()\nend",
  "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  # TODO \nend", "  l.uniq.sort\nend",
  "    l.reduce([]) { |a, i| a.include?(i) ? a : a << i }.sort\nend", "  # l.uniq\n\
    \  # l.sort.uniq\n  l.sort.uniq\nend", "  l.uniq!\n  l.sort!\nend", "\treturn\
    \ l.sort.uniq\nend", "  l.select { |i| l.count(i) == 1 }.sort\nend", "  l.uniq.sort\n\
    end", "  l.uniq.sort\nend", "  l.sort.uniq\nend", "  l.uniq\nend", "  l.uniq.sort\n\
    end", "  raise \"not a list\" unless l.is_a? Array\n  l.uniq.sort\nend", "  return\
    \ l.uniq.sort\nend", "  return l.sort.uniq\nend", "\tl.uniq.sort\nend", "  return\
    \ l.uniq.sort\nend", "  l.inject(Array.new){|result, x| result << x unless result.include?(x);\
    \ result}\nend", "  l.inject([]) do |result, element|\n    unless result.include?(element)\n\
    \      result << element\n    end\n    result\n  end.sort\nend", "  uniq_l = []\n\
    \  l.each do |item|\n    if uniq_l.count(item) == 0\n      uniq_l << item\n  \
    \  end\n  end\n  return uniq_l.sort\nend", "  l.uniq\nend", "    l.sort.uniq\n\
    end", "  l.uniq\nend", "  l.uniq.sort\nend", "    l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "\t\tl.sort.uniq\nend", "  raise ArgumentError, \"Argument must be an array\"\
    \ unless l.class == Array\n  l.uniq\nend", "  l.inject([]) { |result, element|\
    \ result.include?(element) ? result : result << element }.sort\nend", "  l.sort.uniq\n\
    end", "    return l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.uniq.sort\nend",
  "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "\tputs l.uniq\n\
    end", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.to_set.to_a\nend", "  l.sort.uniq\n\
    end", "  # YOUR CODE HERE\nend", "  l.sort.uniq\nend", "  # TODO\nend", "  l.sort.uniq\n\
    end", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.uniq\nend", "  # TODO:\
    \ return sorted unique elements in a list\nend", "  l.sort.uniq\nend", end, " \
    \ l.uniq!\n  l.sort!\nend", "  l.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\n\
    end", "  l.sort.uniq\nend", "  # Your Code Here\nend", "  l.uniq!\n  l.sort!\n\
    end", "  l.inject([]) { |acc, v| acc.include?(v) ? acc : acc << v }.sort\nend",
  "  l.sort.uniq\nend", "    l.sort.uniq\nend", "    x = l.uniq\n    x.sort\nend",
  "  answer = []\n  l.each do |x|\n    answer << x unless answer.include?(x)\n  end\n\
    \  answer\nend", "  return l.sort.uniq\nend", "\tl.sort.uniq\nend", "    # l.uniq.sort\n\
    \    l.uniq.sort_by { |n| l.count(n) }\nend", "  l.reduce([]) do |acc, e|\n  \
    \  acc.include?(e) ? acc : acc << e\n  end.sort\nend", "  l.uniq.sort\nend", " \
    \ # YOUR CODE HERE\nend", "  l.uniq\nend", "  l.sort.uniq\nend", "  l.inject([])\
    \ { |p, c| p.include?(c) ? p : p << c }.sort\nend", "  l.inject([]) do |result,\
    \ e|\n    result << e unless result.include?(e)\n    result\n  end\nend", "  l.uniq.sort\n\
    end", "\tsorted = []\n\tl.each do |element|\n\t\tsorted << element if !sorted.include?(element)\n\
    \tend\n\treturn sorted\nend", "  l.inject([]) { |m, x| m.include?(x) ? m : m <<\
    \ x }.sort\nend", "  l.uniq.sort\nend", "    array = l.sort.uniq\n    puts array\n\
    end", "  l.sort.uniq\nend", "  h = {}\n  l.each do |e|\n    h[e] = true\n  end\n\
    \  h.keys.sort\nend", end, "    # write your code here\n    l.sort.uniq\nend",
  "  l.sort.uniq\nend", "  l.uniq.sort\nend", "\tl.uniq\nend", "  l.uniq.sort\nend",
  "  l.sort.uniq\nend", "  # TODO\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend",
  "    # l.uniq.sort\n    l.sort.uniq\nend", "\tresult = []\n\tl.each do |e|\n\t\t\
    result << e unless result.include?(e)\n\tend\n\tresult\nend", "    l.sort.uniq\n\
    end", "  l.uniq.sort\nend", end, "end\n```", "  #l.uniq\n  l.sort.uniq\nend",
  "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "  # Your code\
    \ goes here.\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  # l.uniq.sort\n\
    \  # l.sort.uniq\n  l.sort.uniq!\nend", "    l.uniq.sort\nend", "  [l].flatten.sort.uniq\n\
    end", "  l.uniq\nend", "  array = []\n  l.each do |x|\n    if !array.include?(x)\n\
    \      array << x\n    end\n  end\n  array.sort\nend", "  l.sort.uniq\nend", " \
    \ l.inject([]) { |total, n| total.include?(n) ? total : total << n }.sort\nend",
  "  res = []\n  l.each do |i|\n    res << i unless res.include?(i)\n  end\n  res\n\
    end", "    l.uniq!\n    l.sort!\nend", "  l.sort.uniq\nend", "\tl.sort.uniq\n\
    end", "  return l.sort.uniq\nend", "  return l.uniq.sort\nend", "  l.uniq.sort\n\
    end", "  #puts(l.inspect)\n  set = Set.new(l)\n  list = set.to_a\n  list.sort!\n\
    \  return list\nend", "  l.sort.uniq\nend", "  l.sort.uniq\nend", "    return\
    \ l.to_set.to_a\nend", "  if l.empty?\n    return []\n  end\n  l.uniq.sort\nend",
  "  l.sort.uniq\nend", "  results = []\n  l.each do |i|\n    if !results.include?(i)\n\
    \      results << i\n    end\n  end\n  results.sort\nend", "  l.sort.uniq\nend",
  "\treturn l.sort.uniq\nend", "  l.sort.uniq\nend", "    l.uniq\nend", "  list =\
    \ l.dup\n  sorted = false\n  until sorted\n    sorted = true\n    (list.length\
    \ - 1).times do |i|\n      if list[i] > list[i + 1]\n        list[i], list[i +\
    \ 1] = list[i + 1], list[i]\n        sorted = false\n      end\n    end\n  end\n\
    \  index = 0\n  while index < list.length\n    if list[index] == list[index +\
    \ 1]\n      list.delete_at(index)\n    else\n      index += 1\n    end\n  end\n\
    \  list\nend", "  l.uniq.sort\nend", "  # @DONE@\n  unique_elements = []\n  l.each\
    \ do |element|\n    if !unique_elements.include?(element)\n      unique_elements\
    \ << element\n    end\n  end\n  unique_elements.sort\nend", "  l.sort.uniq\nend",
  "    return l.uniq.sort\nend", "  l.uniq.sort\nend", "    l.uniq\nend", "    l.sort.uniq\n\
    end", "  # YOUR CODE HERE\nend", "  l.inject([]) { |a, e| a.include?(e) ? a :\
    \ a << e }.sort\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", end, "  list\
    \ = []\n  l.each { |x| list << x unless list.include?(x) }\n  list\nend", "  \
    \  l.uniq.sort\nend", "  # YOUR CODE HERE\nend", "  l.sort.uniq\nend", "\tl.inject([])\
    \ { |x,y| x.include?(y) ? x : x << y }.sort\nend", "  l.sort!.uniq!\nend", " \
    \ return l.uniq\nend", "  puts l.sort.uniq\nend", "  return l.uniq.sort\nend",
  "\tl.sort.uniq\nend", "  l.uniq.sort\nend", "  l.uniq.sort\nend", "  l.sort.uniq\n\
    end", "    l.uniq.sort\nend", "  # ...\nend", "  # TODO: return sorted unique\
    \ elements in a list\n  #       use a hash to test the element uniqueness\n  #\
    \       and then translate the hash back to an array\n  #       instead of returning\
    \ the hash.\n  unique_hash = Hash.new(0)\n  unique_hash.merge!(l.group_by { |v|\
    \ v })\n  unique_hash.keys.sort\nend", "  l.uniq.sort\nend", "    l.sort.uniq\n\
    end", "\t# Your code here\nend", "  n = l.length\n  k = 0\n  while k < n\n   \
    \ e = l[k]\n    i = k + 1\n    while i < n\n      if e == l[i]\n        n -= 1\n\
    \        l[i] = l[n]\n      else\n        i += 1\n      end\n    end\n    k +=\
    \ 1\n  end\n  l[0...n].sort\nend", "  l.inject([]) { |uniq, val| uniq.include?(val)\
    \ ? uniq : uniq.push(val) }.sort\nend", "  # FIXME\nend", "  # Do your thing\n\
    end", "  l.sort.uniq\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
