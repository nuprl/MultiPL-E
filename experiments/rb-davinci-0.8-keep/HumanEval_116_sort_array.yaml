name: HumanEval_116_sort_array
language: rb
prompt: "# In this Kata, you have to sort an array of non-negative integers according\
  \ to\n# number of ones in their binary representation in ascending order.\n# For\
  \ similar number of ones, sort based on decimal value.\n# It must be implemented\
  \ like this:\n# >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n# >>> sort_array([-2,\
  \ -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n# >>> sort_array([1, 0, 2, 3, 4]) [0,\
  \ 1, 2, 3, 4]\ndef sort_array(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_sort_array\n\
  \    candidate = method(:sort_array)\n    assert_equal([1, 2, 4, 3, 5], candidate.call([1,\
  \ 5, 2, 3, 4]))\n    assert_equal([-4, -2, -6, -5, -3], candidate.call([-2, -3,\
  \ -4, -5, -6]))\n    assert_equal([0, 1, 2, 4, 3], candidate.call([1, 0, 2, 3, 4]))\n\
  \    assert_equal([], candidate.call([]))\n    assert_equal([2, 2, 4, 4, 3, 3, 5,\
  \ 5, 5, 7, 77], candidate.call([2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4]))\n    assert_equal([32,\
  \ 3, 5, 6, 12, 44], candidate.call([3, 6, 44, 12, 32, 5]))\n    assert_equal([2,\
  \ 4, 8, 16, 32], candidate.call([2, 4, 8, 16, 32]))\n    assert_equal([2, 4, 8,\
  \ 16, 32], candidate.call([2, 4, 8, 16, 32]))\n  end\nend\n"
completions: ["  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by{|x|\
    \ [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'),\
    \ x]}\nend", "  arr.sort_by { |i| [i.to_s(2).count('1'), i] }\nend", "  arr.sort_by\
    \ { |int| [int.to_s(2).count('1'), int] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort\
    \ do |x, y|\n    x_ones, y_ones = ones_in_binary(x), ones_in_binary(y)\n    x_ones\
    \ == y_ones ? x <=> y : x_ones <=> y_ones\n  end\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\nend", "  arr.sort_by{|n| [n.to_s(2).count('1'), n]}\nend", "  # Group\
    \ elements by the number of ones in their binary representation\n  #\n  # elements\
    \ - Array containing the elements\n  #\n  # Return Hash with the groups\n  def\
    \ group_elements(elements)\n    groups = Hash.new { |hash, key| hash[key] = []\
    \ }\n    elements.each do |e|\n      groups[e.to_s(2).count('1')] << e\n    end\n\
    \    groups\n  end", "  arr.sort_by { |number| [number.to_s(2).count('1'), number]\
    \ }\nend", "  arr.sort { |a, b| [a.to_s(2).count('1'), a] <=> [b.to_s(2).count('1'),\
    \ b] }\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by{|a|\
    \ [a.to_s(2).count('1'), a]}\nend", "  arr.sort_by{|i| [i.to_s(2).count('1'),\
    \ i]}\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by\
    \ { |num| [num.to_s(2).count('1'), num] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\nend", "  arr.sort_by { |e| [e.to_s(2).count('1'), e] }\nend", "  # your\
    \ code here\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", " \
    \ arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'),\
    \ x]}\nend", "  arr.sort do |a, b|\n    a_ones = a.to_s(2).count('1')\n    b_ones\
    \ = b.to_s(2).count('1')\n    if a_ones == b_ones\n      a <=> b\n    else\n \
    \     a_ones <=> b_ones\n    end\n  end\nend", "  arr.sort_by { |e| [e.to_s(2).count('1'),\
    \ e] }\nend", "  arr.sort_by { |x| [ones(x), x] }\nend", "  number_with_ones =\
    \ []\n  numbers_with_one = []\n  numbers_without_one = []\n  arr.each do |number|\n\
    \    number_with_ones.push([number, number.to_s(2).count('1')])\n  end\n  number_with_ones.each\
    \ do |pair|\n    if pair[1] == 0\n      numbers_without_one.push(pair[0])\n  \
    \  else\n      numbers_with_one.push(pair)\n    end\n  end\n  numbers_with_one.sort!\
    \ { |a, b| a[1] <=> b[1] }\n  numbers_with_one.each_with_index do |number, index|\n\
    \    numbers_with_one[index] = number[0]\n  end\n  (numbers_with_one + numbers_without_one)\n\
    end", "  arr.sort_by { |i| [i.to_s(2).count('1'), i] }\nend", "  arr.sort { |x,\
    \ y| [x.to_s(2).count('1'), x] <=> [y.to_s(2).count('1'), y] }\nend", "  # your\
    \ code here\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", " \
    \ #your code here\n  count_hash = {}\n  arr.each do |num|\n    count_hash[num]\
    \ = num.to_s(2).count(\"1\")\n  end\n  p count_hash\n  count_hash.sort_by { |k,\
    \ v| v }.to_h.keys\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'), num]\
    \ }\nend", "  arr.sort_by{|i| [i.to_s(2).count('1'), i]}\nend", "  ones = []\n\
    \  zeros = []\n  arr.each do |num|\n    num.to_s(2).count('1') == 0 ? zeros <<\
    \ num : ones << num\n  end\n  zeros.sort!\n  ones.sort! { |a, b| a.to_s(2).count('1')\
    \ <=> b.to_s(2).count('1') }\n  ones + zeros\nend", "  arr.sort_by { |number|\
    \ [number.to_s(2).count('1'), number] }\nend", "  # your code here\nend", "  if\
    \ arr == []\n    return []\n  end\n  sorted_array = arr.sort_by { |num| [num.to_s(2).count(\"\
    1\"), num] }\n  return sorted_array\nend", "  arr.sort_by { |a| [a.to_s(2).count('1'),\
    \ a] }\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'), x]}\nend", "  # fix me\n\
    \  r = arr.map { |v| [count_ones(v), v] }\n  r.sort! { |a, b| a[0] == b[0] ? a[1]\
    \ <=> b[1] : a[0] <=> b[0] }\n  r.map { |v| v[1] }\nend", "  ones = Hash.new\n\
    \  arr.each do |item|\n    ones[item] = item.to_s(2).count(\"1\")\n  end\n  ones\
    \ = ones.sort_by { |key, value| [value, key] }\n  ones.map { |key, value| key\
    \ }\nend", "  ones = {}\n  arr.each do |x|\n    ones[x] = (x.to_s(2).count('1'))\n\
    \  end\n  arr.sort_by { |x| [ones[x], x] }\nend", "  # sort_by(arr){|x| [x.to_s(2).chars.count(\"\
    1\"), x]}\n  arr.sort_by{|x| [x.to_s(2).chars.count(\"1\"), x]}\nend", "  sort_ones\
    \ = arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by { |n|\
    \ [n.to_s(2).count('1'), n] }\nend", "  ones = []\n  zeros = []\n  arr.each do\
    \ |x|\n    if x.to_s(2).count('1') == 0\n      zeros << x\n    else\n      ones\
    \ << x\n    end\n  end\n  ans = []\n  ans << ones.sort_by { |x| x.to_s(2).count('1')\
    \ } << zeros.sort\n  ans.flatten\nend", "  return [] if arr.nil? || arr.empty?\n\
    \  arr.sort_by { |i| [i.to_s(2).count('1'), i] }\nend", "  # your code here\n\
    end", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  if arr.all? {\
    \ |x| x.negative? }\n    arr.sort\n  else\n    arr.sort_by { |i| [i.to_s(2).count('1'),\
    \ i] }\n  end\nend", "  arr.sort_by{|n| [n.to_s(2).count('1'), n]}\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by { |e| [e.to_s(2).count('1'),\
    \ e] }\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'), num] }\nend", " \
    \ hash = {}\n  arr.each do |el|\n    hash[el] = el.to_s(2).count('1')\n  end\n\
    \  hash.sort_by { |k, v| [v, k] }.to_h.keys\nend", "    sorted = arr.sort_by do\
    \ |x|\n        if (x.to_s(2) =~ /1/)\n            x.to_s(2).count('1')\n     \
    \   else\n            0\n        end\n    end\n    sorted.map { |x| x.to_s(2).count('1')\
    \ != 0 ? x : -x }\nend", "  sorted = arr.sort_by { |n| n.to_s(2).count('1') }\n\
    \  sorted.sort_by { |n| n.to_s(2).count('1') }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  return arr if arr.length <= 1\n  pivot = arr.pop\n  less, more\
    \ = arr.partition { |x| x.to_s(2).count('1') < pivot.to_s(2).count('1') }\n  sort_array(less)\
    \ + [pivot] + sort_array(more)\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'),\
    \ num] }\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'), num] }\nend",
  "    arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by { |x| [ones(x),\
    \ x] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  count = Hash.new(0)\n  arr.each do |num|\n    count[num] = num.to_s(2).count('1')\n\
    \  end\n  sorted = arr.sort_by { |num| [count[num], num] }\nend", "  # Sort by\
    \ binary representation\n  arr.sort_by do |x|\n    x.to_s(2).count(\"1\")\n  end\n\
    end", "  arr.sort_by { |n| [ones(n), n] }\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'),\
    \ x]}\nend", "    arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  # your\
    \ code here\nend", "  arr.sort_by{|num| [num.to_s(2).count('1'), num]}\nend",
  "  # your code here\nend", "  arr.sort_by { |number| [number.to_s(2).count('1'),\
    \ number] }\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by\
    \ { |e| [-e.to_s(2).count('1'), e] }\nend", "  # your code here\nend", "  return\
    \ arr if arr.empty?\n  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", " \
    \ arr.sort_by{|n| [n.to_s(2).count('1'), n]}\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort_by { |el| [el.to_s(2).count('1'), el] }\nend", "  arr.sort_by\
    \ { |i| [i.to_s(2).count('1'), i] }\nend", "  # your code here\nend", "  h = {}\n\
    \  arr.each do |item|\n    h[item] = item.to_s(2).count('1')\n  end\n  h.sort_by\
    \ { |k, v| [v, k] }.map { |v| v[0] }\nend", "  arr.sort_by{|a| [a.to_s(2).count('1'),\
    \ a]}\nend", "  arr.sort { |a, b| a.to_s(2).count('1') <=> b.to_s(2).count('1')\
    \ }\nend", "  arr.sort { |a, b| [a.to_s(2).count('1'), a] <=> [b.to_s(2).count('1'),\
    \ b] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by{|n|\
    \ n.to_s(2).count('1') }\nend", "  p arr.sort_by{|i| [i.to_s(2).count('1'), i]}\n\
    end", "  # use a hash to pair a number with the number of ones in its binary\n\
    \  # representation\n  hash = Hash.new { |h, k| h[k] = [] }\n  arr.each do |x|\n\
    \    ones = x.to_s(2).count(\"1\")\n    hash[ones] << x\n  end\n  # sort the hash\
    \ by keys\n  hash = hash.sort_by { |k, v| k }\n  # flatten the hash\n  hash.flatten!.delete_if\
    \ { |x| x.is_a?(Integer) == false }\n  # return the flattened array\n  hash\n\
    end", "  return [] if arr.empty?\n  return arr if arr.size == 1\n  arr.sort do\
    \ |a, b|\n    a_ones, b_ones = a.to_s(2).count('1'), b.to_s(2).count('1')\n  \
    \  a_ones != b_ones ? a_ones <=> b_ones : a <=> b\n  end\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by { |n| [-n.to_s(2).count('1'),\
    \ n] }\nend", "  # your code here\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\nend", "  ones = {}\n  arr.each do |num|\n    ones[num] = num.to_s(2).count(\"\
    1\")\n  end\n  ones.sort_by{|k,v| [v,k]}.to_h.keys\nend", "  #your code here\n\
    \  arr.sort_by do |num|\n    ones = num.to_s(2).count('1')\n    [ones, num]\n\
    \  end\nend", "  arr.sort_by{|n| [n.to_s(2).count('1'), n]}\nend", "  arr.sort_by\
    \ { |e| [e.to_s(2).count('1'), e] }\nend", "  sorted = []\n  for i in 0..(arr.size\
    \ - 1)\n    if arr[i] < 0\n      next\n    end\n    for j in 0..(sorted.size -\
    \ 1)\n      if arr[i].to_s(2).count('1') < sorted[j].to_s(2).count('1')\n    \
    \    sorted.insert(j, arr[i])\n        break\n      elsif arr[i].to_s(2).count('1')\
    \ == sorted[j].to_s(2).count('1')\n        if arr[i] < sorted[j]\n          sorted.insert(j,\
    \ arr[i])\n          break\n        end\n      end\n      if j == sorted.size\
    \ - 1\n        sorted.insert(j + 1, arr[i])\n        break\n      end\n    end\n\
    \    if sorted.size == 0\n      sorted.insert(0, arr[i])\n    end\n  end\n  sorted\n\
    end\nputs sort_array([1, 5, 2, 3, 4])\nputs sort_array([-2, -3, -4, -5, -6])\n\
    puts sort_array([1, 0, 2, 3, 4])", "  arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\nend", "  arr.sort_by { |v| [v.to_s(2).count('1'), v] }\nend", "  arr.sort_by\
    \ { |e| [e.to_s(2).count('1'), e] }\nend", "    arr.sort_by{|x| [(bin(x).count('1')),x]}\n\
    end", "  arr.sort_by { |i| [i.to_s(2).count('1'), i] }\nend", "  arr.sort_by {\
    \ |el| [el.to_s(2).count('1'), el] }\nend", "  arr.sort_by { |i| [i.to_s(2).count('1'),\
    \ i] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by{|n| [n.to_s(2).count('1'),\
    \ n]}\nend", "  arr.sort_by{|x| [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by { |n| [ n.to_s(2).count('1'),\
    \ n ] }\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'), num] }\nend", " \
    \ arr.sort_by{|x| [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'),\
    \ num] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  # your code here\nend", "  counts\
    \ = {}\n  arr.each do |element|\n    binary = element.to_s(2)\n    counts[element]\
    \ = binary.count('1')\n  end\n  counts.sort_by { |x,y| [y,x] }.map { |x,y| x }\n\
    end", "  arr.sort_by { |num| [num.to_s(2).count('1'), num] }\nend", "  arr.sort_by\
    \ { |x| [count_ones(x), x] }\nend", "  arr.sort_by{|i| [i.to_s(2).count('1'),\
    \ i]}\nend", "  arr.sort_by{|x|[x.to_s(2).count('1'), x]}\nend\np sort_array([1,\
    \ 5, 2, 3, 4]) #== [1, 2, 3, 4, 5]\np sort_array([-2, -3, -4, -5, -6]) #== [-6,\
    \ -5, -4, -3, -2]\np sort_array([1, 0, 2, 3, 4]) #[0, 1, 2, 3, 4]", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by { |item| [item.to_s(2).count('1'),\
    \ item] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by { |i| [i.to_s(2).count('1'),\
    \ i] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort\
    \ { |a, b| [a.to_s(2).count('1'), a] <=> [b.to_s(2).count('1'), b] }\nend", " \
    \ return arr if arr.empty?\n  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\n\
    end", "  arr.sort_by { |e| [e.to_s(2).count('1'), e] }\nend", "  arr.sort_by {\
    \ |num| [num.to_s(2).count('1'), num] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort { |x, y| ones(x) <=> ones(y) }\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by { |e| [e.to_s(2).count('1'),\
    \ e] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by{|x|\
    \ [x.to_s(2).count('1'), x]}\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'), num] }\nend", " \
    \ arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  decimals = []\n  decimals_ones\
    \ = {}\n  arr.each do |num|\n    one_count = num.to_s(2).count('1')\n    if decimals_ones[one_count]\n\
    \      decimals_ones[one_count] << num\n    else\n      decimals_ones[one_count]\
    \ = [num]\n    end\n  end\n  decimals_ones.each do |key, value|\n    decimals\
    \ << value.sort\n  end\n  decimals.flatten\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\nend", "  arr.sort_by { |a| [a.to_s(2).count('1'), a] }\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  return arr if arr.empty?\n  # sort\
    \ the array based on the number of ones in the binary representation\n  # of the\
    \ numbers in the array\n  sorted_arr = arr.sort_by { |n| [n.to_s(2).count('1'),\
    \ n] }\n  # make sure the negative numbers are at the end of the array\n  sorted_arr.reject!\
    \ { |n| n < 0 }\n  sorted_arr + arr.select { |n| n < 0 }\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'), num] }\nend", " \
    \ # Your code here\nend", "  arr.sort_by{|i| i.to_s(2).count('1')}.reverse\nend",
  "  ones = []\n  zeros = []\n  arr.each do |x|\n    if x < 0\n      zeros << x\n\
    \    else\n      ones << x\n    end\n  end\n  ones = ones.sort_by { |x| x.to_s(2).count(\"\
    1\") }\n  ones + zeros\nend", "  # puts \"Array: #{arr}\"\n  # puts \"One: #{arr.find_all\
    \ { |n| n.to_s(2).count('1') == 1 }}\"\n  # puts \"Two: #{arr.find_all { |n| n.to_s(2).count('1')\
    \ == 2 }}\"\n  # puts \"Three: #{arr.find_all { |n| n.to_s(2).count('1') == 3\
    \ }}\"\n  # puts \"Four: #{arr.find_all { |n| n.to_s(2).count('1') == 4 }}\"\n\
    \  # puts \"Five: #{arr.find_all { |n| n.to_s(2).count('1') == 5 }}\"\n  # puts\
    \ \"Six: #{arr.find_all { |n| n.to_s(2).count('1') == 6 }}\"\n  # puts \"Seven:\
    \ #{arr.find_all { |n| n.to_s(2).count('1') == 7 }}\"\n  # puts \"Eight: #{arr.find_all\
    \ { |n| n.to_s(2).count('1') == 8 }}\"\n  # puts \"Nine: #{arr.find_all { |n|\
    \ n.to_s(2).count('1') == 9 }}\"\n  # puts \"Ten: #{arr.find_all { |n| n.to_s(2).count('1')\
    \ == 10 }}\"\n  # puts \"Eleven: #{arr.find_all { |n| n.to_s(2).count('1') ==\
    \ 11 }}\"\n  # puts \"Twelve: #{arr.find_all { |n| n.to_s(2).count('1') == 12\
    \ }}\"\n  # puts \"Thirteen: #{arr.find_all { |n| n.to_s(2).count('1') == 13 }}\"\
    \n  # puts \"Fourteen: #{arr.find_all { |n| n.to_s(2).count('1') == 14 }}\"\n\
    \  # puts \"Fifteen: #{arr.find_all { |n| n.", "  #your code here\n  arr.sort_by{|x|\
    \ [x.to_s(2).count(\"1\"), x]}\nend", "  arr.sort_by { |i| [i.to_s(2).count('1'),\
    \ i] }\nend", "  arr.sort do |a, b|\n    ones_a = a.to_s(2).chars.select { |c|\
    \ c == '1' }.count\n    ones_b = b.to_s(2).chars.select { |c| c == '1' }.count\n\
    \    if ones_a == ones_b\n      a <=> b\n    else\n      ones_a <=> ones_b\n \
    \   end\n  end\nend", "  arr.sort { |a, b| a.to_s(2).count('1') == b.to_s(2).count('1')\
    \ ? a <=> b : a.to_s(2).count('1') <=> b.to_s(2).count('1') }\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort { |a, b| a.to_s(2).count('1')\
    \ <=> b.to_s(2).count('1') }\nend", "  arr.sort_by { |num| [num.to_s(2).count('1'),\
    \ num] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  # sort the array in ascending order\n\
    \  # for the same number of 1s, sort by the decimal value\n  arr.sort_by do |x|\n\
    \    [x.to_s(2).count('1'), x]\n  end\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  # Your code here\nend", "  # your code here\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by { |i| [i.to_s(2).count('1'),\
    \ i] }\nend", "  arr.sort_by { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort_by\
    \ { |a| [a.to_s(2).count('1'), a] }\nend", "  arr.sort_by{|el| [el.to_s(2).count('1'),\
    \ el]}\nend", "  arr.sort_by { |a| [a.to_s(2).count('1'), a] }\nend", "  arr.sort_by\
    \ { |x| [x.to_s(2).count('1'), x] }\nend", "  sorted = arr.sort_by { |i| [i.to_s(2).count('1'),\
    \ i] }\nend", "  a = []\n  b = []\n  sorted = []\n  arr.each do |i|\n    b <<\
    \ i\n    a << i.to_s(2).count(\"1\")\n  end\n  a.sort!.uniq!\n  a.each do |i|\n\
    \    k = []\n    b.each do |j|\n      if i == j.to_s(2).count(\"1\")\n       \
    \ k << j\n      end\n    end\n    sorted << k.sort\n  end\n  sorted.flatten\n\
    end", "  arr.sort_by { |e| e.to_s(2).count('1') }\nend", "  # TODO: implement\n\
    end", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  # Your code here\n\
    end", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort { |a,\
    \ b| [a.to_s(2).count('1'), a] <=> [b.to_s(2).count('1'), b] }\nend", "  arr.sort_by\
    \ { |n| [n.to_s(2).count('1'), n] }\nend", "  arr.sort do |a, b|\n    a_ones =\
    \ a.to_s(2).count('1')\n    b_ones = b.to_s(2).count('1')\n    a_ones == b_ones\
    \ ? a <=> b : a_ones <=> b_ones\n  end\nend", "  count_ones = ->(n) { n.to_s(2).count(\"\
    1\") }\n  arr.sort_by { |x| [count_ones[x], x] }\nend", "  # your code here\n\
    end", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort_by {\
    \ |e| [e.to_s(2).count('1'), e] }\nend", "  arr.sort { |a, b| a.to_s(2).scan(/1/).count\
    \ <=> b.to_s(2).scan(/1/).count }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort { |a, b| a.to_s(2).count('1') == b.to_s(2).count('1')\
    \ ? a <=> b : a.to_s(2).count('1') <=> b.to_s(2).count('1') }\nend", "    arr.sort_by{|x|\
    \ [x.to_s(2).count(\"1\"), x]}\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'),\
    \ x] }\nend", "  arr.sort_by { |x| [x.to_s(2).count('1'), x] }\nend", "  arr.sort\
    \ do |a, b|\n    if count_ones(a) == count_ones(b)\n      a <=> b\n    else\n\
    \      count_ones(a) <=> count_ones(b)\n    end\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
