name: HumanEval_93_encode
language: rb
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode('test')\n# 'TGST'\n# >>>\
  \ encode('This is a message')\n# 'tHKS KS C MGSSCGG'\ndef encode(message)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encode\n\
  \    candidate = method(:encode)\n    assert_equal(\"tgst\", candidate.call(\"TEST\"\
  ))\n    assert_equal(\"mWDCSKR\", candidate.call(\"Mudasir\"))\n    assert_equal(\"\
  ygs\", candidate.call(\"YES\"))\n    assert_equal(\"tHKS KS C MGSSCGG\", candidate.call(\"\
  This is a message\"))\n    assert_equal(\"k dQnT kNqW wHcT Tq wRkTg\", candidate.call(\"\
  I DoNt KnOw WhAt tO WrItE\"))\n  end\nend\n"
completions: ["  alphabet = (\"a\"..\"z\").to_a\n  vowels = [\"a\", \"e\", \"i\",\
    \ \"o\", \"u\"]\n  encoded_message = \"\"\n  message.each_char do |letter|\n \
    \   if vowels.include?(letter.downcase)\n      index = vowels.index(letter.downcase)\n\
    \      if index == 4\n        encoded_message += alphabet[1].upcase\n      else\n\
    \        encoded_message += alphabet[index + 2].upcase\n      end\n    elsif alphabet.include?(letter.downcase)\n\
    \      encoded_message += letter.swapcase\n    else\n      encoded_message +=\
    \ letter\n    end\n  end\n  encoded_message\nend", "  message = message.chars\n\
    \  alphabet = (\"a\"..\"z\").to_a\n  result = []\n  message.each do |ch|\n   \
    \ if ch == ch.upcase\n      ch = ch.downcase\n      result << alphabet[alphabet.index(ch)+2].upcase\n\
    \    else\n      result << alphabet[alphabet.index(ch)+2]\n    end\n  end\n  result.join\n\
    end", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  # to_return = ''\n  # vowels.each\
    \ do |vowel|\n  #   to_return << message.gsub(vowel, vowels[vowels.index(vowel)\
    \ + 2])\n  # end\n  # to_return", "  # choose a message\n  # split the message\
    \ into an array of chars\n  # go through each char\n  #   determine if it is lowercase\
    \ or uppercase\n  #   if lower, make uppercase and save\n  #   if uppercase, make\
    \ lowercase and save\n  #   if it is not a letter, save it\n  #   if it is a vowel,\
    \ save its position and change it to the next 2 letters in alphabet\n  # join\
    \ the chars back into a string\n  # return the string\n  message_chars = message.split('')\n\
    \  encoded_chars = []\n  vowels = %w(a e i o u)\n  positions = {}\n  message_chars.each_with_index\
    \ do |char, index|\n    if char =~ /[a-z]/\n      encoded_chars << char.upcase\n\
    \    elsif char =~ /[A-Z]/\n      encoded_chars << char.downcase\n    else\n \
    \     encoded_chars << char\n    end\n    if vowels.include?(char.downcase)\n\
    \      positions[index] = char\n    end\n  end\n  vowel_positions = positions.keys\n\
    \  vowel_positions.each do |position|\n    encoded_chars[position] = get_next_vowel(encoded_chars[position])\n\
    \  end\n  encoded_chars.join('')\nend", "    vowels = \"aeiou\"\n    result =\
    \ \"\"\n    message.each_char do |char|\n        if vowels.include?(char.downcase)\n\
    \            result += swap_vowel(char)\n        else\n            result += swap_case(char)\n\
    \        end\n    end\n    result\nend", "\nend", "  coded_message = ''\n  alphabet\
    \ = 'abcdefghijklmnopqrstuvwxyz'.chars\n  new_alphabet = 'cdefghijklmnopqrstuvwxyzab'.chars\n\
    \  message.chars.each do |char|\n    if char.match(/[a-z]/i)\n      coded_message\
    \ += char.match(/[A-Z]/) ? new_alphabet[alphabet.index(char.downcase)].upcase\
    \ : new_alphabet[alphabet.index(char)]\n    else\n      coded_message += char\n\
    \    end\n  end\n  coded_message\nend", end, "\t# encode function goes here\n\
    end", "    # Algorithm:\n    # Variables: \n    #   alphabet => array of all the\
    \ letters in the alphabet\n    #   vowels => array of all the vowels in the alphabet\n\
    \    #   encoded_message => empty string to be used to store the encoded message\n\
    \    #   character => placeholder for the current character that we are on\n \
    \   #   current_position => placeholder for the current position within the alphabet\n\
    \    #   next_position => placeholder for the next position within the alphabet\n\
    \    #   new_character => placeholder for the new character to be replaced\n \
    \   #\n    # Encode the message:\n    # For each character in the message:\n \
    \   #   1) If the character is uppercase, add an uppercase letter from the alphabet\
    \ that is 2 steps ahead to the encoded message.\n    #   2) If the character is\
    \ lowercase, add a lowercase letter from the alphabet that is 2 steps ahead to\
    \ the encoded message.\n    #\n    # Return the encoded message\n    alphabet\
    \ = ('a'..'z').to_a << ('A'..'Z').to_a\n    vowels = %w(a e i o u A E I O U)\n\
    \    encoded_message = ''\n    message.split('').each do |character|\n       \
    \ if character == ' '\n            encoded_message << ' '\n        else\n    \
    \        current_position = alphabet.index(character)\n            next_position\
    \ = current_position + 2\n            if character == character.upcase\n     \
    \           new_character = alphabet[next_position].upcase\n            else\n\
    \                new_character = alphabet[next_position]\n            end\n  \
    \          encoded_message << new_character\n        end\n    end\n    encoded_message\n\
    end", "  vowels = \"aeiou\"\n  new_message = \"\"\n  message.downcase.split(\"\
    \").each do |letter|\n    if vowels.include?(letter)\n      new_message += vowels[vowels.index(letter)+2]\n\
    \    else\n      new_message += letter\n    end\n  end\n  new_message.upcase\n\
    end", "  result = ''\n  message.each_char do |ch|\n    if (ch >= 'a' && ch <=\
    \ 'z')\n      if ch == 'z'\n        result << 'B'\n      elsif ch == 'y'\n   \
    \     result << 'A'\n      else\n        result << (ch.ord + 2).chr\n      end\n\
    \    elsif (ch >= 'A' && ch <= 'Z')\n      if ch == 'Z'\n        result << 'b'\n\
    \      elsif ch == 'Y'\n        result << 'a'\n      else\n        result << (ch.ord\
    \ + 2).chr\n      end\n    else\n      result << ch\n    end\n  end\n  result\n\
    end", end, "\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tencoded_string = ''\n\tmessage.each_char\
    \ do |letter|\n\t\tcase letter\n\t\twhen 'a'..'z'\n\t\t\tletter = letter.upcase\n\
    \t\t\tletter = letter.next\n\t\t\tletter = letter.next\n\t\t\tif letter == 'AA'\n\
    \t\t\t\tletter = 'A'\n\t\t\telsif letter == 'EE'\n\t\t\t\tletter = 'E'\n\t\t\t\
    elsif letter == 'II'\n\t\t\t\tletter = 'I'\n\t\t\telsif letter == 'OO'\n\t\t\t\
    \tletter = 'O'\n\t\t\telsif letter == 'UU'\n\t\t\t\tletter = 'U'\n\t\t\tend\n\t\
    \t\tif vowels.include?(letter.downcase)\n\t\t\t\tletter = letter.next\n\t\t\t\t\
    letter = letter.next\n\t\t\tend\n\t\twhen 'A'..'Z'\n\t\t\tletter = letter.next\n\
    \t\t\tletter = letter.next\n\t\t\tif letter == 'AA'\n\t\t\t\tletter = 'A'\n\t\t\
    \telsif letter == 'EE'\n\t\t\t\tletter = 'E'\n\t\t\telsif letter == 'II'\n\t\t\
    \t\tletter = 'I'\n\t\t\telsif letter == 'OO'\n\t\t\t\tletter = 'O'\n\t\t\telsif\
    \ letter == 'UU'\n\t\t\t\tletter = 'U'\n\t\t\tend\n\t\t\tif vowels.include?(letter.downcase)\n\
    \t\t\t\tletter = letter.next\n\t\t\t\tletter = letter.next\n\t\t\tend\n\t\telse\n\
    \t\t\tletter = letter\n\t\tend\n\t\tencoded_string << letter\n\tend\n\tencoded_string\n\
    end", "    # your code here\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n  alpha = (\"a\"..\"z\").to_a\n  answer = \"\"\n  new_arr = message.split(\"\
    \")\n  new_arr.each do |c|\n    if alpha.include?(c)\n      alpha_index = alpha.index(c)\n\
    \      new_index = alpha_index + 2\n      if new_index > 25\n        new_index\
    \ = new_index - 26\n      end\n      c = alpha[new_index]\n    end\n    answer\
    \ << c\n  end\n  answer\nend", "    # your code here\n    str = \"\"\n    message.each_char\
    \ do |x|\n        if x == x.upcase\n            str << x.downcase\n        else\n\
    \            str << x.upcase\n        end\n    end\n    str.tr!('aeiou', 'cfilor')\n\
    \    str\nend", "  message.split(\"\").map do |char|\n    if ('a'..'z').include?(char)\n\
    \      case char\n      when 'a'\n        'c'\n      when 'b'\n        'd'\n \
    \     when 'c'\n        'e'\n      when 'd'\n        'f'\n      when 'e'\n   \
    \     'g'\n      when 'f'\n        'h'\n      when 'g'\n        'i'\n      when\
    \ 'h'\n        'j'\n      when 'i'\n        'k'\n      when 'j'\n        'l'\n\
    \      when 'k'\n        'm'\n      when 'l'\n        'n'\n      when 'm'\n  \
    \      'o'\n      when 'n'\n        'p'\n      when 'o'\n        'q'\n      when\
    \ 'p'\n        'r'\n      when 'q'\n        's'\n      when 'r'\n        't'\n\
    \      when 's'\n        'u'\n      when 't'\n        'v'\n      when 'u'\n  \
    \      'w'\n      when 'v'\n        'x'\n      when 'w'\n        'y'\n      when\
    \ 'x'\n        'z'\n      when 'y'\n        'a'\n      when 'z'\n        'b'\n\
    \      end\n    elsif ('A'..'Z').include?(char)\n      case char\n      when 'A'\n\
    \        'C'\n      when 'B'\n        'D'\n      when 'C'\n        'E'\n     \
    \ when 'D'\n        'F'\n      when 'E'\n        'G'\n      when 'F'\n       \
    \ 'H'\n      when 'G'\n        'I'\n      when 'H'\n        'J'\n      when 'I'\n\
    \        'K'\n      when 'J'\n        'L'\n      when 'K'\n        'M'\n     \
    \ when 'L'\n        'N'\n      when 'M'\n        'O'\n      when 'N'\n       \
    \ 'P'\n      when 'O'\n        'Q'\n      when 'P'", "    vowels = 'aeiou'\n \
    \   alphabet = ('a'..'z').to_a\n    cipher = Hash.new\n    alphabet.each_with_index\
    \ do |letter, idx|\n        if vowels.include?(letter)\n            cipher[letter]\
    \ = alphabet[(idx + 2) % 26]\n        else\n            cipher[letter] = letter\n\
    \        end\n    end\n    p cipher\n    new_message = ''\n    message.each_char\
    \ do |char|\n        if char == char.upcase\n            new_message += cipher[char.downcase].upcase\n\
    \        else\n            new_message += cipher[char]\n        end\n    end\n\
    \    new_message\nend", "  alphabet = (\"a\"..\"z\").to_a\n  vowels = [\"a\",\
    \ \"e\", \"i\", \"o\", \"u\"]\n  # split the message into an array, iterate through\
    \ it and then push each letter of the message into encoded message. \n  # If the\
    \ letter is a vowel, replace with its encoded vowel, else push letter into encoded\
    \ message. \n  encoded_message = []\n  message.downcase.split(\"\").each do |letter|\n\
    \    if vowels.include?(letter)\n      index = alphabet.index(letter)\n      encoded_message\
    \ << alphabet[index + 2]\n    else\n      encoded_message << letter\n    end\n\
    \  end\n  encoded_message.join.upcase\nend\nputs encode(\"This is a message\")",
  "\nend", "\t# return message.swapcase.tr(abc,'cdefghijklmnopqrstuvwxyzab')\n\t#\
    \ return message.swapcase.tr('aeiou','eioua')\n\treturn message.swapcase.tr('bcdfghjklmnpqrstvwxyz','defghijklmnopqrstuvwxyza')\n\
    end", "\talphabet = ('a'..'z').to_a\n\tnew_array = []\n\tstring = message.downcase\n\
    \tarray = string.split('')\n\tarray.each do |letter|\n\t\tindex = alphabet.index(letter)\n\
    \t\tif index.nil?\n\t\t\tnew_array << letter\n\t\telsif index + 2 > 25\n\t\t\t\
    letter = alphabet[(index + 2) - 26]\n\t\t\tnew_array << letter\n\t\telse\n\t\t\
    \tletter = alphabet[index + 2]\n\t\t\tnew_array << letter\n\t\tend\n\tend\n\t\
    new_array.join('').upcase\nend", "  vowels = 'aeiou'\n  alphabet = ('a'..'z').to_a\n\
    \  message.chars.map { |c| \n    if vowels.include?(c.downcase)\n      alphabet[(alphabet.index(c.downcase)\
    \ + 2) % 26]\n    else\n      c.swapcase\n    end\n  }.join\nend", "\nend", " \
    \   # Create an alphabet string\n    alpha = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\
    \    # Create an empty string to be filled with the encoded message.\n    new_message\
    \ = \"\"\n    # Split the message into an array of characters.\n    char_array\
    \ = message.split(\"\")\n    # Iterate through the characters\n    char_array.each\
    \ do |char|\n        # If the character is a vowel, find its position\n      \
    \  if \"AEIOU\".include?(char.upcase)\n            char_index = alpha.index(char.upcase)\n\
    \            # If the index is equal to 23 or 24, wrap around to the beginning\
    \ of the alphabet.\n            if char_index == 23 || char_index == 24\n    \
    \            char_index = 0\n            elsif char_index == 25\n            \
    \    char_index = 1\n            # Otherwise, add 2 to the index\n           \
    \ else\n                char_index += 2\n            end\n            # Find the\
    \ corresponding encoded letter and push it to the new message\n            new_message\
    \ << alpha[char_index]\n        # If the character is not a vowel, swap case and\
    \ push it to the new message\n        else\n            new_message << char.swapcase\n\
    \        end\n    end\n    # Return the encoded message\n    return new_message\n\
    end", "  # YOUR CODE HERE\nend", "    def swap_case(letter)\n        if 'a' <=\
    \ letter && letter <= 'z'\n            letter.upcase\n        else\n         \
    \   letter.downcase\n        end\n    end", "\t#add your solution here\nend",
  "\nend", end, "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  text = message.downcase.split(\"\
    \")\n  encoded_message = []\n  text.each do |char|\n    if vowels.include?(char)\n\
    \      encoded_message << vowels[vowels.index(char) + 2]\n    else\n      encoded_message\
    \ << char\n    end\n  end\n  encoded_message.join(\"\").upcase\nend", "\nend",
  "  encoded_message = []\n  message.split(\"\").each do |char|\n    if \"aeiou\"\
    .include?(char.downcase)\n      encoded_message << encode_vowel(char)\n    else\n\
    \      encoded_message << char.swapcase\n    end\n  end\n  encoded_message.join(\"\
    \")\nend", "  vowels = \"aeiouAEIOU\"\n  alpha = (\"a\"..\"z\").to_a\n  new_message\
    \ = []\n  message.each_char do |c|\n    if vowels.include?(c)\n      new_message\
    \ << alpha[alpha.index(c.downcase) + 2]\n    else\n      new_message << c\n  \
    \  end\n  end\n  new_message.join.upcase\nend", "\tresult = []\n\tvowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n\talphabet = ('a'..'z').to_a\n\tmessage.split('').each\
    \ do |letter|\n\t\tif letter.downcase == letter\n\t\t\tletter = letter.upcase\n\
    \t\telse\n\t\t\tletter = letter.downcase\n\t\tend\n\t\tif vowels.include?(letter)\n\
    \t\t\tcase letter\n\t\t\twhen 'a'\n\t\t\t\tletter = 'c'\n\t\t\twhen 'e'\n\t\t\t\
    \tletter = 'g'\n\t\t\twhen 'i'\n\t\t\t\tletter = 'k'\n\t\t\twhen 'o'\n\t\t\t\t\
    letter = 'm'\n\t\t\twhen 'u'\n\t\t\t\tletter = 'p'\n\t\t\tend\n\t\tend\n\t\tresult\
    \ << letter\n\tend\n\tresult.join('')\nend", "\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tencode_message = []\n\ti = 0", "\tencode_arr = []\n\tvowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n\tmessage.split('').each do |letter|\n\t\tif letter == letter.upcase\n\
    \t\t\tencode_arr << letter.downcase\n\t\telse\n\t\t\tencode_arr << letter.upcase\n\
    \t\tend\n\tend\n\tencode_arr.join.tr('aeiou', 'ecigv').tr('bcdfghjklmnpqrstvwxyz',\
    \ 'cdfghjklmnpqrstvwxyzb')\nend", "\t# your code here\n\t# ???\nend", "  # give\
    \ me your code!\nend", "\tmessage = message.split(\"\")\n\tvowels = [\"a\", \"\
    e\", \"i\", \"o\", \"u\"]\n\tresult = []\n\tmessage.each do |char|\n\t\tif vowels.include?(char)\n\
    \t\t\tvowels.each_with_index do |vowel, index|\n\t\t\t\tif vowel == char\n\t\t\
    \t\t\tif index == 4\n\t\t\t\t\t\tresult << vowels[0]\n\t\t\t\t\telse\n\t\t\t\t\
    \t\tresult << vowels[index + 2]\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\telsif\
    \ char == char.upcase\n\t\t\tresult << char.downcase\n\t\telsif char == char.downcase\n\
    \t\t\tresult << char.upcase\n\t\tend\n\tend\n\tresult.join(\"\")\nend", "\nend",
  "\t\n\t# What do we do?\n\t# First we will initialize an array that contains all\
    \ the vowels\n\tvowels = ['a', 'e', 'i', 'o', 'u']\n\t# then we initialize an\
    \ empty array that will contain our result\n\tresult = []\n\t# iterate through\
    \ the message by character\n\tmessage.split('').each do |character|\n\t\tif vowels.include?(character.downcase)\n\
    \t\t\t# get the current index\n\t\t\tcurrent_index = vowels.index(character.downcase)\n\
    \t\t\t# make sure we are not exceeding the length of the array\n\t\t\tif current_index\
    \ >= (vowels.length - 1)\n\t\t\t\t# if that's the case, we just take the modulus\
    \ of the index\n\t\t\t\tresult << vowels[current_index % vowels.length]\n\t\t\t\
    else\n\t\t\t\t# otherwise we add 2 to the index to get the next character\n\t\t\
    \t\tresult << vowels[current_index + 2]\n\t\t\tend\n\t\telsif character == character.upcase\n\
    \t\t\t# if the character is upper case, we will make it upper case\n\t\t\tresult\
    \ << character.downcase\n\t\telse\n\t\t\t# otherwise, we will just make it lower\
    \ case\n\t\t\tresult << character.upcase\n\t\tend\n\tend\n\t# return the result\
    \ as a string and not an array\n\tresult.join\nend", "  alphabet = ('a'..'z').to_a\n\
    \  vowels = 'aeiou'\n  # Capitalize each letter in message and swap cases\n  message.split.map\
    \ { |word| word.upcase.swapcase }.join(' ').split('').map do |letter|\n    # If\
    \ letter is a vowel, move 2 places ahead\n    if vowels.include?(letter.downcase)\n\
    \      index = alphabet.index(letter.downcase)\n      alphabet[index + 2]\n  \
    \  else\n      letter\n    end\n  end.join('')\nend", "    vowels = \"aeiou\"\n\
    \    encoded_message = \"\"\n    i = 0\n    while i < message.length\n       \
    \ case message[i]\n        when \"A\"..\"Z\"\n            encoded_message << message[i].downcase\n\
    \        when \"a\"..\"z\"\n            if vowels.include?(message[i])\n     \
    \           if message[i] == \"u\"\n                    encoded_message << \"\
    a\"\n                else\n                    encoded_message << vowels[vowels.index(message[i])\
    \ + 2]\n                end\n            else\n                encoded_message\
    \ << message[i]\n            end\n        else\n            encoded_message <<\
    \ message[i]\n        end\n        i += 1\n    end\n    encoded_message\nend",
  "\nend", "  v = \"aeiou\"\n  vp = \"cdfgjklmnpqrstvwxyz\"\n  count = 0\n  msg =\
    \ message.downcase.split(\"\")\n  msg.each do |char|\n    if v.include?(char)\n\
    \      count = v.index(char) + 2\n      if count > 4\n        count = count -\
    \ 5\n      end\n      msg[msg.index(char)] = v[count]\n    elsif vp.include?(char)\n\
    \      count = vp.index(char) + 2\n      if count > 20\n        count = count\
    \ - 21\n      end\n      msg[msg.index(char)] = vp[count]\n    end\n  end\n  msg.join(\"\
    \").upcase\nend", "    count = 0\n    letters = (\"a\"..\"z\").to_a\n    vowels\
    \ = \"aeiou\".split(\"\")\n    message = message.split(\"\")\n    while count\
    \ < message.length\n        if letters.include?(message[count])\n            if\
    \ vowels.include?(message[count])\n                if vowels.index(message[count])\
    \ + 2 > 4\n                    message[count] = vowels[vowels.index(message[count])\
    \ + 2 - 5]\n                else\n                    message[count] = vowels[vowels.index(message[count])\
    \ + 2]\n                end\n            end\n            if message[count] ==\
    \ message[count].upcase\n                message[count] = message[count].downcase\n\
    \            else\n                message[count] = message[count].upcase\n  \
    \          end\n        end\n        count += 1\n    end\n    return message.join(\"\
    \")\nend", "  message.downcase!\n  message.tr!('abcdefghijklmnopqrstuvwxyz', 'bdfhjlnprtvxzaeiouycgkqmsw')\n\
    \  message.tr!('aeiou', 'cgkq')\n  message.upcase!\nend", "    encoded_message\
    \ = \"\"\n    index = 0\n    vowels = \"aeiou\"\n    while index < message.length\n\
    \        current_letter = message[index]\n        if vowels.include?(current_letter.downcase)\n\
    \            current_letter = vowels[vowels.index(current_letter.downcase) + 2]\n\
    \        end\n        encoded_message += current_letter.upcase\n        index\
    \ += 1\n    end\n    return encoded_message\nend", "\t# write your code here\n\
    end", "  new_message = message.downcase\n  message.length.times do |idx|\n   \
    \ if new_message[idx] =~ /[aeiou]/\n      new_message[idx] = new_message[idx].next.next\n\
    \    end\n  end\n  new_message.upcase\nend", "\tlowercase = (\"a\"..\"z\").to_a\n\
    \tuppercase = (\"A\"..\"Z\").to_a\n\tencode_message = \"\"\n\tmessage.each_char\
    \ do |letter|\n\t\tif lowercase.include?(letter)\n\t\t\t# if the current letter\
    \ is lowercase...\n\t\t\tletter_index = lowercase.index(letter)\n\t\t\tnew_letter_index\
    \ = letter_index + 2\n\t\t\tif new_letter_index > 25\n\t\t\t\tnew_letter_index\
    \ = new_letter_index - 26\n\t\t\tend\n\t\t\tnew_letter = lowercase[new_letter_index]\n\
    \t\t\tencode_message += new_letter\n\t\telsif uppercase.include?(letter)\n\t\t\
    \t# if the current letter is uppercase...\n\t\t\tletter_index = uppercase.index(letter)\n\
    \t\t\tnew_letter_index = letter_index + 2\n\t\t\tif new_letter_index > 25\n\t\t\
    \t\tnew_letter_index = new_letter_index - 26\n\t\t\tend\n\t\t\tnew_letter = uppercase[new_letter_index]\n\
    \t\t\tencode_message += new_letter\n\t\telse\n\t\t\t# if the current letter is\
    \ a character other than a letter...\n\t\t\tencode_message += letter\n\t\tend\n\
    \tend\n\treturn encode_message\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('')\n\
    \    result = \"\"\n    message.downcase.each_char do |char|\n        index =\
    \ alphabet.index(char)\n        if !index.nil?\n            result += alphabet[(index\
    \ + 2) % 26]\n        else\n            result += char\n        end\n    end\n\
    \    result.upcase\nend", "  encoded_message = \"\"\n  message.each_char do |char|\n\
    \    if (char =~ /[aeiou]/i) == 0\n      if char.downcase == \"y\"\n        encoded_message\
    \ += \"a\"\n      elsif char.downcase == \"z\"\n        encoded_message += \"\
    b\"\n      else\n        encoded_message += char.next\n      end\n    else\n \
    \     encoded_message += char\n    end\n  end\n  encoded_message.swapcase\nend",
  "  vowels = 'AEIOUaeiou'\n  letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\
    \  encoded_message = ''\n  # letter case\n  message.each_char do |char|\n    encoded_message\
    \ += if char.upcase == char\n                         char.downcase\n        \
    \               else\n                         char.upcase\n                 \
    \      end\n  end\n  # vowels\n  encoded_message.each_char.with_index do |char,\
    \ i|\n    encoded_message[i] = if vowels.include?(char)\n                    \
    \       letters[letters.index(char) + 2]\n                         else\n    \
    \                       char\n                         end\n  end\n  encoded_message\n\
    end", "    code = \"\"\n    i = 0\n    while i < message.length\n        if message[i]\
    \ == \" \"\n            code += \" \"\n        elsif message[i] == message[i].upcase\n\
    \            code += message[i].downcase\n        else\n            code += message[i].upcase\n\
    \        end\n        i += 1\n    end\n    code = code.tr \"aeiou\", \"cfjqrw\"\
    \n    return code\nend", "  vowels = %w[a e i o u]\n  message = message.chars.map\
    \ do |char|\n    if vowels.include?(char.downcase)\n      index = vowels.index(char.downcase)\n\
    \      new_char = vowels[(index + 2) % 5]\n      char == char.upcase ? new_char.upcase\
    \ : new_char\n    else\n      char == char.upcase ? char.downcase : char.upcase\n\
    \    end\n  end\n  message.join('')\nend", "\tmsg = ''\n\tmessage.split('').each\
    \ do |char|\n\t\tif 'AEIOUaeiou'.include?(char)\n\t\t\tmsg += (('A'..'Z').to_a\
    \ + ('a'..'z').to_a)[(('A'..'Z').to_a + ('a'..'z').to_a).index(char)+2]\n\t\t\
    else\n\t\t\tmsg += char\n\t\tend\n\tend\n\tmsg\nend", "  # solution code here\n\
    end", "\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tupcase_vowels = vowels.map { |vowel|\
    \ vowel.upcase }\n\tvowels.each_with_index do |vowel, i|\n\t\tif i == 4\n\t\t\t\
    message.gsub!(vowel, 'a')\n\t\telse\n\t\t\tmessage.gsub!(vowel, vowels[i+2])\n\
    \t\tend\n\tend\n\tupcase_vowels.each_with_index do |vowel, i|\n\t\tif i == 4\n\
    \t\t\tmessage.gsub!(vowel, 'A')\n\t\telse\n\t\t\tmessage.gsub!(vowel, upcase_vowels[i+2])\n\
    \t\tend\n\tend\n\tmessage.swapcase\nend", "\nend", "  alphabet = ('a'..'z').to_a\n\
    \  message.chars.map do |ch|\n    if ch.ord >= 97 && ch.ord <= 122\n      alphabet[(alphabet.index(ch)\
    \ + 2) % 26]\n    elsif ch.ord >= 65 && ch.ord <= 90\n      alphabet[(alphabet.index(ch.downcase)\
    \ + 2) % 26].upcase\n    else\n      ch\n    end\n  end.join\nend", "\t# Start\
    \ with defining constants\n\t# These are the sets of alphabet letters\n\tlower_case\
    \ = ('a'..'z').to_a\n\tupper_case = ('A'..'Z').to_a\n\t# Then define a hash for\
    \ vowels\n\t# Only need to define for lower case\n\tvowels = {\n\t\ta: 'c',\n\t\
    \te: 'g',\n\t\ti: 'k',\n\t\to: 'q',\n\t\tu: 'y'\n\t}\n\t# Split message into an\
    \ array\n\tsplit_message = message.split('')\n\t# Check character one by one\n\
    \tencoded_message = split_message.map do |character|\n\t\tif lower_case.include?(character)\n\
    \t\t\tif vowels.keys.include?(character.to_sym)\n\t\t\t\tvowels[character.to_sym]\n\
    \t\t\telse\n\t\t\t\tcharacter.upcase\n\t\t\tend\n\t\telsif upper_case.include?(character)\n\
    \t\t\tif vowels.keys.include?(character.downcase.to_sym)\n\t\t\t\tvowels[character.downcase.to_sym].upcase\n\
    \t\t\telse\n\t\t\t\tcharacter.downcase\n\t\t\tend\n\t\telse\n\t\t\tcharacter\n\
    \t\tend\n\tend\n\t# Join and return\n\tencoded_message.join\nend", "  vowels =\
    \ {'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'y'}\n  code = ''\n\
    \  message.each_char do |x|\n    if vowels.keys.include?(x.downcase)\n      code\
    \ += vowels[x.downcase]\n    elsif x.downcase == 'z'\n      code += 'b'\n    elsif\
    \ x.downcase == 'w'\n      code += 'y'\n    elsif x.downcase == 'v'\n      code\
    \ += 'x'\n    elsif x.downcase == 'y'\n      code += 'z'\n    elsif x.downcase\
    \ == 'x'\n      code += 'v'\n    elsif x.downcase == 'u'\n      code += 'w'\n\
    \    elsif x.downcase == 't'\n      code += 'u'\n    elsif x.downcase == 's'\n\
    \      code += 't'\n    elsif x.downcase == 'r'\n      code += 's'\n    elsif\
    \ x.downcase == 'q'\n      code += 'r'\n    elsif x.downcase == 'p'\n      code\
    \ += 'q'\n    elsif x.downcase == 'o'\n      code += 'p'\n    elsif x.downcase\
    \ == 'n'\n      code += 'o'\n    elsif x.downcase == 'm'\n      code += 'n'\n\
    \    elsif x.downcase == 'l'\n      code += 'm'\n    elsif x.downcase == 'k'\n\
    \      code += 'l'\n    elsif x.downcase == 'j'\n      code += 'k'\n    elsif\
    \ x.downcase == 'i'\n      code += 'j'\n    elsif x.downcase == 'h'\n      code\
    \ += 'i'\n    elsif x.downcase == 'g'\n      code += 'h'\n    elsif x.downcase\
    \ == 'f'\n      code += 'g'\n    elsif x", end, "\t# Check for uppercase\n\tmessage.upcase!\
    \ if message[0] == message[0].upcase\n\t# Encode\n\tmessage.each_char do |letter|\n\
    \t\tif letter =~ /[AEIOU]/\n\t\t\tcase letter\n\t\t\twhen \"A\"\n\t\t\t\tletter.replace(\"\
    C\")\n\t\t\twhen \"E\"\n\t\t\t\tletter.replace(\"G\")\n\t\t\twhen \"I\"\n\t\t\t\
    \tletter.replace(\"K\")\n\t\t\twhen \"O\"\n\t\t\t\tletter.replace(\"S\")\n\t\t\
    \twhen \"U\"\n\t\t\t\tletter.replace(\"Y\")\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ message\nend\nputs encode(\"test\")\nputs encode(\"This is a message\")", end,
  "\tarray = message.split(\"\")\n\tpunctuation = []\n\tarray.each_with_index do |letter,\
    \ index|\n\t\tif !letter.match(/[a-zA-Z]/)\n\t\t\tpunctuation << letter\n\t\t\t\
    array.delete_at(index)\n\t\tend\n\tend\n\tarray.map! do |letter|\n\t\tif letter.match(/[aeiou]/)\n\
    \t\t\tif letter.match(/[a-z]/)\n\t\t\t\tif letter == \"u\"\n\t\t\t\t\tletter =\
    \ \"a\"\n\t\t\t\telse\n\t\t\t\t\tletter = letter.next\n\t\t\t\t\tletter = letter.next\n\
    \t\t\t\tend\n\t\t\telse\n\t\t\t\tif letter == \"U\"\n\t\t\t\t\tletter = \"A\"\n\
    \t\t\t\telse\n\t\t\t\t\tletter = letter.next\n\t\t\t\t\tletter = letter.next\n\
    \t\t\t\tend\n\t\t\tend\n\t\telsif letter.match(/[A-Z]/)\n\t\t\tletter = letter.downcase\n\
    \t\t\tletter = letter.next\n\t\t\tletter = letter.next\n\t\t\tletter = letter.upcase\n\
    \t\telse\n\t\t\tletter = letter.next\n\t\t\tletter = letter.next\n\t\tend\n\t\
    end\n\tarray.each_with_index do |letter, index|\n\t\tif letter == \"aa\"\n\t\t\
    \tarray[index] = \"a\"\n\t\telsif letter == \"bb\"\n\t\t\tarray[index] = \"b\"\
    \n\t\telsif letter == \"cc\"\n\t\t\tarray[index] = \"c\"\n\t\telsif letter ==\
    \ \"dd\"\n\t\t\tarray[index] = \"d\"\n\t\telsif letter == \"ee\"\n\t\t\tarray[index]\
    \ = \"e\"\n\t\telsif letter == \"ff\"\n\t\t\tarray[index] = \"f\"\n\t\telsif letter\
    \ == \"gg\"\n\t\t\tarray[index] = \"g\"\n\t\telsif letter == \"hh\"\n\t\t\tarray[index]\
    \ = \"", "\tmessage.split('').each_with_index do |x, index|\n\t\tif x == x.upcase\n\
    \t\t\tmessage[index] = x.downcase\n\t\telse\n\t\t\tmessage[index] = x.upcase\n\
    \t\tend\n\tend\n\tmessage = message.gsub(/[aeiou]/, 'a' => 'c', 'e' => 'g', 'i'\
    \ => 'k', 'o' => 'q', 'u' => 'y')\n\treturn message\nend", "  # replace all vowels\
    \ with the letter that appears 2 places ahead of that vowel in the english alphabet\n\
    \  # [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  # => [\"c\", \"g\", \"k\", \"o\",\
    \ \"y\"]\n  # a => c, e => g, i => k, o => o, u => y\n  # swap case of all letters\n\
    \  # A => a, B => b, C => c, D => d, E => e, F => f, G => g, H => h, I => i, J\
    \ => j, K => k, L => l, M => m, N => n, O => o, P => p, Q => q, R => r, S => s,\
    \ T => t, U => u, V => v, W => w, X => x, Y => y, Z => z\n  letters = (\"a\"..\"\
    z\").to_a\n  letters_caps = (\"A\"..\"Z\").to_a\n  vowels = [\"a\", \"e\", \"\
    i\", \"o\", \"u\"]\n  vowels_caps = [\"A\", \"E\", \"I\", \"O\", \"U\"]\n  encoded_vowels\
    \ = []\n  encoded_message = \"\"\n  encoded_vowels = vowels.map do |vowel|\n \
    \   letters[(letters.index(vowel) + 2) % 26]\n  end\n  encoded_vowels_caps = vowels_caps.map\
    \ do |vowel|\n    letters_caps[(letters_caps.index(vowel) + 2) % 26]\n  end\n\
    \  message.each_char do |char|\n    if encoded_vowels.include?(char)\n      encoded_message\
    \ += encoded_vowels_caps[encoded_vowels.index(char)]\n    elsif encoded_vowels_caps.include?(char)\n\
    \      encoded_message += encoded_vowels[encoded_vowels_caps.index(char)]\n  \
    \  elsif vowels.include?(char)\n      encoded_message += encoded_vowels_caps[vowels.index(char)]\n\
    \    elsif vowels_caps.include?(", "  message = message.split('')\n  message.map!\
    \ do |char|\n    if char == char.downcase\n      char.upcase\n    else\n     \
    \ char.downcase\n    end\n  end\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  message.map!\
    \ do |char|\n    if vowels.include?(char)\n      if char == 'u'\n        char\
    \ = 'a'\n      else\n        char = vowels[vowels.index(char) + 1]\n      end\n\
    \    else\n      char\n    end\n  end\n  return message.join('')\nend", "  alphabet\
    \ = {\n    \"a\" => \"c\", \"b\" => \"d\", \"c\" => \"e\", \"d\" => \"f\", \"\
    e\" => \"g\",\n    \"f\" => \"h\", \"g\" => \"i\", \"h\" => \"j\", \"i\" => \"\
    k\", \"j\" => \"l\",\n    \"k\" => \"m\", \"l\" => \"n\", \"m\" => \"o\", \"n\"\
    \ => \"p\", \"o\" => \"q\",\n    \"p\" => \"r\", \"q\" => \"s\", \"r\" => \"t\"\
    , \"s\" => \"u\", \"t\" => \"v\",\n    \"u\" => \"w\", \"v\" => \"x\", \"w\" =>\
    \ \"y\", \"x\" => \"z\", \"y\" => \"a\",\n    \"z\" => \"b\",\n  }\n  result =\
    \ \"\"\n  message.each_char do |letter|\n    if alphabet.has_key?(letter.downcase)\n\
    \      result += alphabet[letter.downcase]\n    else\n      result += letter\n\
    \    end\n  end\n  result\nend", end, "    vowels = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n    encoded_message = \"\"\n    message.split(\"\").each do |char|\n\
    \        if vowels.include?(char.downcase)\n            encoded_message += encode_vowel(char)\n\
    \        else\n            encoded_message += char.upcase\n        end\n    end\n\
    \    encoded_message\nend", "  new_msg = []\n  message.each_char do |i|\n    if\
    \ ('a'..'z').include?(i)\n      new_msg << (\"a\"..\"z\").to_a[((\"a\"..\"z\"\
    ).to_a.index(i) + 2) % 26]\n    elsif ('A'..'Z').include?(i)\n      new_msg <<\
    \ (\"A\"..\"Z\").to_a[((\"A\"..\"Z\").to_a.index(i) + 2) % 26]\n    else\n   \
    \   new_msg << i\n    end\n  end\n  new_msg.join\nend", "  # your code here\n\
    end", "\t# message.downcase!\n\t# vowels = \"aeiou\"\n\t# message.each_char do\
    \ |x|\n\t# \tif vowels.include?(x) \n\t# \t\tif x == \"u\"\n\t# \t\t\tmessage[x]\
    \ = \"a\"\n\t# \t\telsif x == \"o\"\n\t# \t\t\tmessage[x] = \"e\"\n\t# \t\telse\n\
    \t# \t\t\tmessage[x] = (x.next).next\n\t# \t\tend\n\t# \tend\n\t# end\n\t# return\
    \ message\n\tmessage.tr('a-z', 'b-za')\nend", "  # convert the message to an array\n\
    \  # go through the array and replace each letter with the 2 letters ahead of\
    \ it\n  # join the array back together\n  vowels = \"aeiou\"\n  letters = ('a'..'z').to_a\n\
    \  encoded_letters = letters.rotate(2)\n  alphabet = letters.zip(encoded_letters).to_h\n\
    \  message.chars.map do |char|\n    if alphabet.keys.include?(char)\n      alphabet[char]\n\
    \    elsif char == char.upcase\n      alphabet[char.downcase].upcase\n    else\n\
    \      char\n    end\n  end.join\nend", "  encoded_message = \"\"\n  vowels =\
    \ \"aeiou\"\n  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  message.split(\"\"\
    ).each do |char|\n    if alphabet.include?(char)\n      if char == \"z\"\n   \
    \     encoded_message += \"b\"\n      elsif char == \"Z\"\n        encoded_message\
    \ += \"B\"\n      elsif vowels.include?(char)\n        encoded_message += alphabet[(vowels.index(char)\
    \ + 2) % 5]\n      else\n        encoded_message += alphabet[(alphabet.index(char)\
    \ + 2) % 26]\n      end\n    else\n      encoded_message += char\n    end\n  end\n\
    \  encoded_message\nend", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  encoded_message\
    \ = []\n  message.split(\"\").each do |char|\n    if vowels.include?(char.downcase)\n\
    \      encoded_message << vowels[(vowels.index(char.downcase) + 2) % 5]\n    elsif\
    \ char == char.upcase\n      encoded_message << char.downcase\n    else\n    \
    \  encoded_message << char.upcase\n    end\n  end\n  encoded_message.join(\"\"\
    )\nend", "\nend", "  # your code here\nend", "    vowels = \"aeiou\"\n    encoded_message\
    \ = \"\"\n    message.each_char do |char|\n        if vowels.include?(char.downcase)\n\
    \            encoded_message += (vowels[(vowels.index(char.downcase) + 2) % 5]).upcase\n\
    \        else\n            encoded_message += char.swapcase\n        end\n   \
    \ end\n    encoded_message\nend", "  message.each_char do |char|\n    if char\
    \ == char.upcase\n      char.downcase!\n    else\n      char.upcase!\n    end\n\
    \  end\n  message.each_char do |char|\n    if char == \"a\"\n      char.replace\
    \ \"c\"\n    elsif char == \"e\"\n      char.replace \"g\"\n    elsif char ==\
    \ \"i\"\n      char.replace \"k\"\n    elsif char == \"o\"\n      char.replace\
    \ \"q\"\n    elsif char == \"u\"\n      char.replace \"s\"\n    end\n  end\n \
    \ message\nend", "\tmessage = message.split('')\n\tvowels = ['a', 'e', 'i', 'o',\
    \ 'u']\n\tnew_message = []\n\tmessage.each do |char|\n\t\tif vowels.include?(char)\n\
    \t\t\tnext_vowel = (vowels.index(char) + 2) % 5\n\t\t\tnew_message << vowels[next_vowel]\n\
    \t\telsif char == char.upcase\n\t\t\tnew_message << char.downcase\n\t\telse \n\
    \t\t\tnew_message << char.upcase\n\t\tend\n\tend\n\treturn new_message.join('')\n\
    end", "  encoded_message = ''\n  vowels = 'aeiou'\n  chars = message.split('')\n\
    \  chars.each do |char|\n    encoded_message += if vowels.include?(char.downcase)\n\
    \      vowels[(vowels.index(char.downcase) + 2) % 5]\n    else\n      char.upcase\n\
    \    end\n  end\n  encoded_message\nend", "\tvowels = [\"a\", \"e\", \"i\", \"\
    o\", \"u\"]\n\tmessage = message.split(\" \")\n\tmessage.each do |word|\n\t\t\
    word.each_char.with_index do |ch, idx|\n\t\t\tif vowels.include?(ch.downcase)\n\
    \t\t\t\tword[idx] = vowels[((vowels.index(ch.downcase)) + 2) % 5]\n\t\t\telse\n\
    \t\t\t\tword[idx] = word[idx].swapcase\n\t\t\tend\n\t\tend\n\tend\n\tmessage.join(\"\
    \ \")\nend", "  vowels = ['a', 'e', 'i', 'o', 'u']\n  code = \"\"\n  i = 0\n \
    \ while i < message.length\n    current_letter = message[i]\n    if vowels.include?(current_letter.downcase)\n\
    \      code += vowels[vowels.index(current_letter.downcase) + 2]\n    elsif current_letter\
    \ == current_letter.upcase\n      code += current_letter.downcase\n    else\n\
    \      code += current_letter.upcase\n    end\n    i += 1\n  end\n  code\nend",
  end, "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  new_message = \"\"\n  message.split(\"\
    \").each do |letter|\n    if vowels.include?(letter.downcase)\n      new_message\
    \ += get_the_letter_from_the_alphabet(letter, 2)\n    else\n      new_message\
    \ += letter.upcase\n    end\n  end\n  new_message\nend", "\nend", "  # alphabet\
    \ = (\"a\"..\"z\").to_a\n  # vowels = %w(a e i o u)\n  # new_message = message.split(\"\
    \")\n  # new_message.map! do |letter|\n  #   if vowels.include?(letter)\n  # \
    \    index = alphabet.index(letter)\n  #     alphabet[index + 2]\n  #   else\n\
    \  #     letter\n  #   end\n  # end\n  # new_message.join.upcase\nend", end, " \
    \ vowels = \"aeiou\"\n  encoded_message = \"\"\n  idx = 0\n  while idx < message.length\n\
    \    letter = message[idx]\n    if vowels.include?(letter.downcase)\n      encoded_message\
    \ += get_next_vowel(letter)\n    else\n      encoded_message += letter.swapcase\n\
    \    end\n    idx += 1\n  end\n  encoded_message\nend", "\tnew_message = \"\"\n\
    \talpha = 'abcdefghijklmnopqrstuvwxyz'\n\tvowels = \"aeiou\"\n\talpha_array =\
    \ alpha.split(\"\")\n\tmessage_array = message.split(\"\")\n\tmessage_array.each\
    \ do |char|\n\t\tcurrent_index = alpha_array.index(char)\n\t\tif vowels.include?(char)\n\
    \t\t\tvowel_current_index = vowels.index(char)\n\t\t\tvowel_two_index = vowel_current_index\
    \ + 2\n\t\t\tif vowel_two_index >= 5\n\t\t\t\tvowel_two_index = vowel_two_index\
    \ - 5\n\t\t\tend\n\t\t\tnew_message += vowels[vowel_two_index]\n\t\telsif current_index\
    \ != nil\n\t\t\tnew_message += alpha_array[current_index - 2]\n\t\telse\n\t\t\t\
    new_message += char\n\t\tend\n\tend\n\tnew_message\nend", "    vowels = \"aeiou\"\
    \n    new_message = \"\"\n    message.each_char do |char|\n        if vowels.include?(char.downcase)\n\
    \            vowels_index = vowels.index(char.downcase)\n            new_message\
    \ += char.upcase == char ? vowels[(vowels_index + 2) % 5].upcase : vowels[(vowels_index\
    \ + 2) % 5]\n        else\n            new_message += char.upcase == char ? char.downcase\
    \ : char.upcase\n        end\n    end\n    new_message\nend", "    res = ''\n\
    \    # check if char is lower/upper case\n    # if letter is vowel, replace letter\
    \ with next 2 letters\n    # if not, replace with it's counterpart\n    for char\
    \ in message.split('')\n        if char == char.downcase\n            if char\
    \ == 'a'\n                res += 'c'\n            elsif char == 'e'\n        \
    \        res += 'g'\n            elsif char == 'i'\n                res += 'k'\n\
    \            elsif char == 'o'\n                res += 'q'\n            elsif\
    \ char == 'u'\n                res += 'y'\n            else\n                res\
    \ += char.upcase\n            end\n        else\n            if char == 'A'\n\
    \                res += 'C'\n            elsif char == 'E'\n                res\
    \ += 'G'\n            elsif char == 'I'\n                res += 'K'\n        \
    \    elsif char == 'O'\n                res += 'Q'\n            elsif char ==\
    \ 'U'\n                res += 'Y'\n            else\n                res += char.downcase\n\
    \            end\n        end\n    end\n    return res\nend", "  coded_message\
    \ = []\n  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  message.chars.each do\
    \ |letter|\n    if vowels.include?(letter.downcase)\n      if letter.downcase\
    \ == \"u\"\n        letter = \"a\"\n      else\n        letter = vowels[vowels.index(letter.downcase)\
    \ + 1]\n      end\n    end\n    if letter.upcase == letter\n      coded_message\
    \ << letter.downcase\n    else\n      coded_message << letter.upcase\n    end\n\
    \  end\n  coded_message.join\nend\nputs encode(\"test\")", "\tvowels = {'a' =>\
    \ 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 'y'}\n\tmessage.downcase.gsub(/[aeiou]/,\
    \ vowels).upcase\nend", "\talphabet = ('a'..'z').to_a\n\tmessage = message.split('')\n\
    \tmessage.map! do |letter|\n\t\tif alphabet.include?(letter)\n\t\t\tletter.swapcase!\n\
    \t\t\tletter = alphabet[alphabet.index(letter) + 2]\n\t\tend\n\t\tletter\n\tend\n\
    \tmessage.join('')\nend", "\tvowels = {\n\t\t'a' => 'c',\n\t\t'e' => 'g',\n\t\t\
    'i' => 'k',\n\t\t'o' => 'q',\n\t\t'u' => 'y'\n\t}\n\tnew_message = message.chars.map\
    \ do |char|\n\t\tchar.swapcase!\n\t\tif vowels.has_key?(char.downcase)\n\t\t\t\
    char = vowels[char.downcase]\n\t\tend\n\t\tchar\n\tend\n\tnew_message.join\nend",
  "  alphabet = ('a'..'z').to_a", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \    vowels = \"aeiou\"\n    answer = []\n    split_message = message.split(\"\
    \")\n    split_message.each do |letter|\n        if vowels.include?(letter.downcase)\n\
    \            answer << alphabet[alphabet.index(letter.downcase) + 2]\n       \
    \ elsif alphabet.include?(letter.downcase)\n            answer << alphabet[alphabet.index(letter.downcase)\
    \ - 25].upcase\n        else\n            answer << letter\n        end\n    end\n\
    \    answer.join(\"\")\nend", "  def encode_char(char)\n    return char if !(/[a-zA-Z]/\
    \ =~ char)\n    position = ('a'..'z').find_index(char.downcase)\n    return char\
    \ if position == nil\n    if char.downcase == char\n      return (position + 2\
    \ > 25) ? ('a'.ord + position + 2 - 26).chr : ('a'.ord + position + 2).chr\n \
    \   else\n      return (position + 2 > 25) ? ('A'.ord + position + 2 - 26).chr\
    \ : ('A'.ord + position + 2).chr\n    end\n  end\n  return message.chars.map {\
    \ |char| encode_char(char) }.join('')\nend", end, "    alpha = ('a'..'z').to_a\n\
    \    vowels = ['a', 'e', 'i', 'o', 'u']\n    new_message = ''\n    message.each_char\
    \ do |letter|\n        if vowels.include?(letter.downcase)\n            new_message\
    \ += alpha[alpha.index(letter.downcase) + 2].upcase\n        elsif letter == letter.upcase\n\
    \            new_message += letter.downcase\n        else \n            new_message\
    \ += letter.upcase\n        end\n    end\n    new_message\nend", "  vowels = ['a',\
    \ 'e', 'i', 'o', 'u']\n  message.each_char.inject('') do |encoded, char|\n   \
    \ if vowels.include?(char.downcase)\n      encoded << next_vowel(char)\n    else\n\
    \      encoded << char\n    end\n  end\nend", "  result = \"\"\n  vowels = \"\
    aeiou\"\n  message.split(\"\").each do |char|\n    if vowels.include?(char.downcase)\n\
    \      if char == \"u\"\n        result += \"a\"\n      else\n        vowels_index\
    \ = vowels.index(char.downcase)\n        result += vowels[vowels_index + 2]\n\
    \      end\n    else\n      if char == char.upcase\n        result += char.downcase\n\
    \      else\n        result += char.upcase\n      end\n    end\n  end\n  result\n\
    end", "\t# YOUR CODE HERE\nend", "  message.upcase.gsub(/[AEIOU]/) { |x| x.ord\
    \ + 2 - (x.ord > 79 ? 26 : 0) }\nend", "\tencode = ''\n\tvowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n\tnew_vowels = ['c', 'f', 'j', 'n', 'r']\n\tmessage.each_char do\
    \ |char|\n\t\tif char.match(/[A-Z]/)\n\t\t\tencode << char.downcase\n\t\telsif\
    \ char.match(/[a-z]/)\n\t\t\tencode << char.upcase\n\t\telse\n\t\t\tencode <<\
    \ char\n\t\tend\n\tend\n\tencode.split('').map do |letter|\n\t\tif vowels.include?(letter)\n\
    \t\t\tletter = new_vowels[vowels.index(letter)]\n\t\tend\n\t\tletter\n\tend.join('')\n\
    end", "  lower_case = ('a'..'z').to_a\n  upper_case = ('A'..'Z').to_a\n  vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n  encoded_message = \"\"\n  message.split(\"\"\
    ).each do |char|\n    if lower_case.include?(char)\n      if vowels.include?(char)\n\
    \        index = lower_case.index(char)\n        index = (index + 2) % lower_case.length\n\
    \        encoded_message += lower_case[index]\n      else\n        index = lower_case.index(char)\n\
    \        encoded_message += lower_case[index].upcase\n      end\n    elsif upper_case.include?(char)\n\
    \      if vowels.include?(char.downcase)\n        index = upper_case.index(char)\n\
    \        index = (index + 2) % upper_case.length\n        encoded_message += upper_case[index]\n\
    \      else\n        index = upper_case.index(char)\n        encoded_message +=\
    \ lower_case[index]\n      end\n    else\n      encoded_message += char\n    end\n\
    \  end\n  encoded_message\nend", end, "  message = message.downcase.split('')\n\
    \  coded_message = []\n  alpha = ('a'..'z').to_a\n  vowels = ['a', 'e', 'i', 'o',\
    \ 'u']\n  message.each do |letter|\n    if alpha.include?(letter)\n      if vowels.include?(letter)\n\
    \        coded_message << alpha[alpha.index(letter) + 2]\n      else\n       \
    \ coded_message << letter\n      end\n    else\n      coded_message << letter\n\
    \    end\n  end\n  coded_message.join.upcase\nend", "  vowels = ['a', 'e', 'i',\
    \ 'o', 'u']\n  idx = 0\n  until idx == message.length\n    if vowels.include?(message[idx])\n\
    \      message[idx] = vowels[vowels.index(message[idx]) + 2]\n    end\n    idx\
    \ += 1\n  end\n  message.swapcase\nend", "\tmessage.split('').map do |char|\n\t\
    \tif char =~ /[a-z]/i\n\t\t\tif char == char.upcase\n\t\t\t\tchar.downcase!\n\t\
    \t\telse\n\t\t\t\tchar.upcase!\n\t\t\tend\n\t\tend\n\t\tif char =~ /[aeiou]/i\n\
    \t\t\tchar = char.next.next\n\t\tend\n\t\tchar\n\tend.join\nend\np encode('test')\n\
    p encode('This is a message')", "    vowels = ['a', 'e', 'i', 'o', 'u']\n    message\
    \ = message.split(\"\")\n    message.map! do |letter|\n        if vowels.include?(letter.downcase)\n\
    \            index = vowels.index(letter.downcase)\n            index = (index\
    \ + 2) % 5\n            letter = vowels[index]\n        end\n        if letter.upcase\
    \ == letter\n            letter = letter.downcase\n        else\n            letter\
    \ = letter.upcase\n        end\n    end\n    message.join(\"\")\nend", "  encoded_message\
    \ = ''\n  vowels = \"aeiou\"\n  message.each_char do |char|\n    letter = char.downcase\n\
    \    if vowels.include?(letter)\n      index = vowels.index(letter)\n      index\
    \ = (index + 2) % 5\n      encoded_message += vowels[index].upcase\n    else\n\
    \      encoded_message += char.swapcase\n    end\n  end\n  encoded_message\nend",
  "\t#First I am creating a new array to store the uppercase alphabet\n\tuppercase_alphabet\
    \ = *(\"A\"..\"Z\")\n\t#First I am creating a new array to store the lowercase\
    \ alphabet\n\tlowercase_alphabet = *(\"a\"..\"z\")\n\t#I am creating a new array\
    \ to store the vowels\n\tvowels = ['a', 'e', 'i', 'o', 'u']\n\t#The message is\
    \ split and stored in an array\n\tmessage_array = message.split('')\n\t#I am creating\
    \ an empty array to store the final encoded array\n\tfinal_encoded_array = []\n\
    \t#I use a each loop to go through each character in the message\n\tmessage_array.each\
    \ do |letter|\n\t\t#If the character is a vowel (lowercase)\n\t\tif vowels.include?(letter)\n\
    \t\t\t#And if it is the last vowel (lowercase)\n\t\t\tif letter == 'u'\n\t\t\t\
    \t#the vowel(lowercase) is stored in a variable\n\t\t\t\tvowel = letter\n\t\t\t\
    \t#the index of that vowel is stored in a variable\n\t\t\t\tvowel_index = lowercase_alphabet.index(vowel)\n\
    \t\t\t\t#Here we are adding two to the vowel index to find the next vowel\n\t\t\
    \t\tnext_vowel_index = vowel_index + 2\n\t\t\t\t#If the next vowel index is more\
    \ than the amount of elements in the alphabet array\n\t\t\t\tif next_vowel_index\
    \ > (lowercase_alphabet.length - 1)\n\t\t\t\t\t#I am subtracting the next vowel\
    \ index from the total length of the alphabet\n\t\t\t\t\t#We do this to be able\
    \ to iterate through the alphabet\n\t\t\t\t\tnext_vowel_index = next_vowel_index\
    \ - lowercase_alphabet.length\n\t\t\t\tend\n\t\t\t\t#The next vowel is stored\
    \ in a variable\n\t\t\t\tnext_vowel = lowercase_alphabet[next_vowel_index]\n\t\
    \t\t\t#The next vowel is then pushed into the final array\n", "    message.downcase!\n\
    \    encoded = ''\n    message.each_char do |c|\n        encoded += if c.between?('a',\
    \ 'z')\n            encode_letter(c)\n        else\n            c\n        end\n\
    \    end\n    encoded\nend", "  vowels = \"aeiou\"\n  res = \"\"\n  message.each_char\
    \ do |char|\n    if vowels.include?(char.downcase)\n      res += get_vowel(char)\n\
    \    else\n      res += char.swapcase\n    end\n  end\n  res\nend", "  # TODO:\
    \ implement me\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    length\
    \ = alphabet.length\n    encoded = ''\n    message.each_char do |char|\n     \
    \   if char == char.upcase\n            letter = alphabet[alphabet.index(char.downcase)\
    \ + 2]\n            encoded += letter.upcase\n        else\n            letter\
    \ = alphabet[alphabet.index(char) + 2]\n            encoded += letter\n      \
    \  end\n    end\n    encoded\nend", "\t# Encode message here\nend", "  letters\
    \ = ('a'..'z').to_a\n  vowels = %w(a e i o u)\n  encoded_message = \"\"\n  message.each_char\
    \ do |letter|\n    index = letters.index(letter.downcase)\n    if index\n    \
    \  if index < 23\n        index += 2\n      else\n        index -= 24\n      end\n\
    \      if vowels.include?(letter.downcase)\n        encoded_message << letters[index].upcase\n\
    \      else\n        encoded_message << letters[index]\n      end\n    else\n\
    \      encoded_message << letter\n    end\n  end\n  encoded_message\nend", " \
    \ # TODO: Implement Function\n  return message.swapcase.tr('aeiou','cegik').split(\"\
    \").join(\" \")\nend", "  # Your code here!\nend", "    alphabet = (\"a\"..\"\
    z\").to_a\n    new_message = \"\"\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"]\n    message.each_char do |letter|\n        if vowels.include?(letter.downcase)\n\
    \            index = alphabet.index(letter.downcase)\n            if index ==\
    \ 24\n                new_message += alphabet[0].upcase\n            elsif index\
    \ == 25\n                new_message += alphabet[1].upcase\n            else\n\
    \                new_message += alphabet[index + 2].upcase\n            end\n\
    \        else\n            if letter == letter.upcase\n                new_message\
    \ += letter.downcase\n            else\n                new_message += letter.upcase\n\
    \            end\n        end\n    end\n    new_message\nend", "\tencode_array\
    \ = []\n\tvowels = %w[a e i o u]\n\tvowels_index = [1, 5, 9, 15, 21]\n\tmessage.split(\"\
    \").each do |letter|\n\t\tif letter.match(/[a-zA-Z]/)\n\t\t\tletter = letter.upcase\n\
    \t\t\t# find the 2 places ahead of vowel letter\n\t\t\tif vowels.include?(letter)\n\
    \t\t\t\tletter = vowels[vowels_index.index(vowels_index.select{|number| number\
    \ > letter.ord - 65}.first)]\n\t\t\tend\n\t\t\t# change the letter to 2 places\
    \ behind of that letter\n\t\t\tletter = (letter.ord - 65 - 2) % 26 + 65\n\t\t\t\
    letter = letter.chr\n\t\t\tencode_array << letter\n\t\telse\n\t\t\tencode_array\
    \ << letter\n\t\tend\n\tend\n\tencode_array.join\nend\np encode('This is a message')",
  "  # put your code here\nend", "    message.tr(\"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ\"\
    , \"cCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZaAbB\")\nend", "  result =\
    \ \"\"\n  message.each_char do |letter|\n    if letter.upcase == letter\n    \
    \  result += letter.downcase\n    else\n      result += letter.upcase\n    end\n\
    \  end\n  vowels = %w(a e i o u)\n  result.each_char do |letter|\n    if vowels.include?(letter)\n\
    \      vowels.each_with_index do |vowel, index|\n        if letter == vowel\n\
    \          index += 2\n          if index > 4\n            index -= 5\n      \
    \    end\n          result[result.index(letter)] = vowels[index]\n        end\n\
    \      end\n    end\n  end\n  result\nend", "  dict = ('a'..'z').to_a\n  vowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n  new_message = ''\n  message.each_char do |c|\n\
    \    if vowels.include?(c.downcase)\n      new_message += dict[(dict.index(c.downcase)\
    \ + 2) % 26]\n    elsif c == c.upcase\n      new_message += dict[(dict.index(c.downcase)\
    \ + 2) % 26].upcase\n    else\n      new_message += c\n    end\n  end\n  return\
    \ new_message\nend", "  result = []\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  message.each_char\
    \ do |char|\n    if vowels.include?(char.downcase)\n      if char.downcase ==\
    \ 'u'\n        result << 'a'\n      else\n        result << vowels[vowels.index(char.downcase)\
    \ + 2]\n      end\n    elsif char == char.upcase\n      result << char.downcase\n\
    \    else\n      result << char.upcase\n    end\n  end\n  result.join('')\nend",
  "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    vw = \"aeiou\"\n    letter_arr\
    \ = message.split(\"\")\n    letter_arr.map! do |letter|\n        if alphabet.include?(letter)\n\
    \            if vw.include?(letter)\n                letter = alphabet[alphabet.index(letter)\
    \ + 2]\n            else\n                letter = letter.swapcase\n         \
    \   end\n        else\n            letter\n        end\n    end\n    letter_arr.join(\"\
    \")\nend", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    abc = (\"a\"\
    ..\"z\").to_a\n    new_message = \"\"\n    message.each_char do |letter|\n   \
    \     if letter == letter.upcase\n            new_message += letter.downcase\n\
    \        else\n            new_message += letter.upcase\n        end\n    end\n\
    \    new_message.each_char do |letter|\n        if vowels.include?(letter)\n \
    \           new_message[new_message.index(letter)] = abc[abc.index(letter) + 2]\n\
    \        end\n    end\n    new_message\nend", "  # We start by creating an empty\
    \ array, where we will put the encoded letters\n  encoded_message = []\n  # We\
    \ create a hash to link the vowel with the one that comes after\n  vowels = {\n\
    \    \"a\" => \"c\",\n    \"e\" => \"g\",\n    \"i\" => \"k\",\n    \"o\" => \"\
    q\",\n    \"u\" => \"y\"\n  }\n  # We split the message into letters, and then\
    \ iterate through this array to encode each letter\n  message.split(\"\").each\
    \ do |letter|\n    # We add the swapped case letter to the array\n    encoded_message\
    \ << letter.swapcase\n    # Then we replace the last added letter in the array\
    \ with the one after if its a vowel\n    if vowels.has_key?(letter.downcase)\n\
    \      encoded_message[-1] = vowels[letter.downcase]\n    end\n  end\n  # Then\
    \ we join the array back together to get the encoded message\n  return encoded_message.join\n\
    end", "  result = []\n  message.split('').each do |char|\n    if char.downcase\
    \ == 'a'\n      result << 'c'\n    elsif char.downcase == 'e'\n      result <<\
    \ 'g'\n    elsif char.downcase == 'i'\n      result << 'k'\n    elsif char.downcase\
    \ == 'o'\n      result << 'q'\n    elsif char.downcase == 'u'\n      result <<\
    \ 'y'\n    elsif char == char.upcase\n      result << char.downcase\n    else\n\
    \      result << char.upcase\n    end\n  end\n  result.join('')\nend", "\t#make\
    \ a constant of all the vowels\n\tvowels = ['a','e','i','o','u']\n\t#make a constant\
    \ with all the letters of the alphabet\n\talphabet = ('a'..'z').to_a", end, "\t\
    encoded_message = ''\n\tvowels = 'AEIOUaeiou'\n\tmessage.each_char do |char|\n\
    \t\tif vowels.include?(char)\n\t\t\tcase char\n\t\t\twhen 'A'\n\t\t\t\tchar =\
    \ 'C'\n\t\t\twhen 'E'\n\t\t\t\tchar = 'G'\n\t\t\twhen 'I'\n\t\t\t\tchar = 'K'\n\
    \t\t\twhen 'O'\n\t\t\t\tchar = 'M'\n\t\t\twhen 'U'\n\t\t\t\tchar = 'Q'\n\t\t\t\
    when 'a'\n\t\t\t\tchar = 'c'\n\t\t\twhen 'e'\n\t\t\t\tchar = 'g'\n\t\t\twhen 'i'\n\
    \t\t\t\tchar = 'k'\n\t\t\twhen 'o'\n\t\t\t\tchar = 'm'\n\t\t\twhen 'u'\n\t\t\t\
    \tchar = 'q'\n\t\t\tend\n\t\telsif char.upcase == char\n\t\t\tchar = char.downcase\n\
    \t\telse\n\t\t\tchar = char.upcase\n\t\tend\n\t\tencoded_message += char\n\tend\n\
    \treturn encoded_message\nend", end, "    vowels = \"aeiou\"\n    new_message\
    \ = \"\"\n    message.each_char do |char|\n        if vowels.include?(char.downcase)\n\
    \            new_message += vowels[(vowels.index(char.downcase) + 2) % 5]\n  \
    \      else\n            new_message += char\n        end\n    end\n    return\
    \ new_message.swapcase\nend", "    lower_case = (\"a\"..\"z\").to_a\n    upper_case\
    \ = (\"A\"..\"Z\").to_a\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  \
    \  consonants = lower_case - vowels\n    new_message = \"\"\n    message.split(\"\
    \").each do |letter|\n        if vowels.include?(letter)\n            new_message\
    \ += lower_case[(lower_case.index(letter) + 2) % 26]\n        elsif consonants.include?(letter)\n\
    \            new_message += lower_case[(lower_case.index(letter) - 4) % 26]\n\
    \        elsif vowels.include?(letter.downcase)\n            new_message += upper_case[(upper_case.index(letter)\
    \ + 2) % 26]\n        elsif consonants.include?(letter.downcase)\n           \
    \ new_message += upper_case[(upper_case.index(letter) - 4) % 26]\n        else\n\
    \            new_message += letter\n        end\n    end\n    new_message\nend",
  "\tmessage_chars = message.split(\"\")\n\tencoded_message = \"\"\n\tmessage_chars.each\
    \ do |char|\n\t\tencoded_message += swap_case(char)\n\t\tif \"aeiou\".include?(char.downcase)\n\
    \t\t\tencoded_message += swap_case(letter_two_ahead(char))\n\t\tend\n\tend\n\t\
    encoded_message\nend", end, "  alphabet = ('a'..'z').to_a + ('A'..'Z').to_a\n\
    \  vowels = ['a', 'e', 'i', 'o', 'u']\n  encoded_message = ''\n  message.each_char\
    \ do |char|\n    if char.match(/[a-zA-Z]/)\n      if vowels.include?(char.downcase)\n\
    \        index = alphabet.index(char)\n        if (index + 2) > alphabet.length\
    \ - 1\n          encoded_message += alphabet[(index + 2) - alphabet.length]\n\
    \        else\n          encoded_message += alphabet[index + 2]\n        end\n\
    \      else\n        if char == char.upcase\n          encoded_message += char.downcase\n\
    \        else\n          encoded_message += char.upcase\n        end\n      end\n\
    \    else\n      encoded_message += char\n    end\n  end\n  encoded_message\n\
    end", "\tencoded_message = \"\"\n\talphabet = (\"a\"..\"z\").to_a\n\talphabet.each_with_index\
    \ do |letter, index|\n\t\tif message.include?(letter)\n\t\t\tcount = 0\n\t\t\t\
    while count < message.length\n\t\t\t\tif message[count] == letter\n\t\t\t\t\t\
    encoded_message += alphabet[index + 2]\n\t\t\t\t\tcount += 1\n\t\t\t\telse\n\t\
    \t\t\t\tencoded_message += message[count]\n\t\t\t\t\tcount += 1\n\t\t\t\tend\n\
    \t\t\tend\n\t\t\tmessage = encoded_message\n\t\t\tencoded_message = \"\"\n\t\t\
    end\n\tend\n\tmessage\nend", "  # Create hash of letters and numbers\n  # Loop\
    \ through message\n  # IF character is letter\n  # CASE character\n  #   WHEN\
    \ char.upcase\n  #     # convert letter to number add two\n  #     # change letter\
    \ back to character with number\n  #   WHEN char.downcase\n  #     # convert letter\
    \ to number add two\n  #     # change letter back to character with number\n \
    \ #   ELSE return message\n  # END CASE\n  # ELSE return message\n  # END IF\n\
    \  # END LOOP\n  # return message\nend", "\tvowels = \"aeiou\"\n\talphabet = \"\
    abcdefghijklmnopqrstuvwxyz\"\n\tvowels2 = \"cdfghjklmnpqrstvwxyzab\"\n\t\n\tencoded\
    \ = \"\"\n\tmessage.split(\"\").each do |letter|\n\t\tif !vowels.include?(letter)\n\
    \t\t\tencoded += letter\n\t\telse\n\t\t\tindex = vowels.index(letter)\n\t\t\t\
    encoded += vowels2[index]\n\t\tend\n\tend\n\t\n\tencoded.upcase\nend\nputs encode(\"\
    test\")\nputs encode(\"This is a message\")", "\tanswer = []\n\tno_caps = message.downcase\n\
    \tputs no_caps\n\tno_caps.each_char do |i|\n\t\tif (\"aeiou\").include? i\n\t\t\
    \tfirst_index = (\"aeiou\").index(i)\n\t\t\tif first_index + 2 <= 4\n\t\t\t\t\
    answer << (\"aeiou\"[first_index + 2])\n\t\t\telse\n\t\t\t\tanswer << (\"aeiou\"\
    [first_index + 2 - 5])\n\t\t\tend\n\t\telse\n\t\t\tanswer << i\n\t\tend\n\tend\n\
    \tanswer.join.upcase\nend", "\t# your code here\nend", "  # For each letter in\
    \ the input string, check if it's \n  # a vowel. If it is, swap to the next next\
    \ letter. Otherwise,\n  # swap to the next letter.\n  letters = ('a'..'z').to_a\n\
    \  encoded_array = []\n  message.split('').each do |char|\n    position = letters.index(char.downcase)\n\
    \    if position == nil\n      encoded_array << char\n    elsif position <= 22\n\
    \      if char == char.upcase\n        encoded_array << letters[position + 2].upcase\n\
    \      else\n        encoded_array << letters[position + 2]\n      end\n    else\n\
    \      if char == char.upcase\n        encoded_array << letters[position - 24].upcase\n\
    \      else\n        encoded_array << letters[position - 24]\n      end\n    end\n\
    \  end\n  encoded_array.join\nend", "\nend", "\tmessage.downcase!\n\tmessage.each_char\
    \ do |char|\n\t\tif char.match(/[aeiou]/)\n\t\t\tif char == 'u'\n\t\t\t\tchar.replace('a')\n\
    \t\t\telse\n\t\t\t\tchar.next!\n\t\t\t\tchar.next!\n\t\t\tend\n\t\tend\n\tend\n\
    \tmessage.upcase!\nend", "\tvowels = ['a', 'e', 'i', 'o', 'u']\n\tencoded_message\
    \ = \"\"\n\tmessage.each_char do |c|\n\t\tnew_letter = c.downcase", "  letters\
    \ = ('a'..'z').to_a\n  vowels = %w(a e i o u)\n  result = ''\n  message.each_char\
    \ do |char|\n    if letters.include?(char)\n      index = letters.index(char)\n\
    \      if vowels.include?(char)\n        result += letters[(index + 2) % 26]\n\
    \      else\n        result += letters[index]\n      end\n    else\n      result\
    \ += char\n    end\n  end\n  result.upcase\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \    vowels = 'aeiou'\n    encoded_message = ''\n    message.each_char do |char|\n\
    \        if vowels.include?(char.downcase)\n            index = vowels.index(char.downcase)\n\
    \            encoded_message += vowels[(index + 2) % 5].upcase\n        elsif\
    \ alphabet.include?(char.downcase)\n            index = alphabet.index(char.downcase)\n\
    \            encoded_message += alphabet[(index + 2) % 26].upcase\n        else\n\
    \            encoded_message += char\n        end\n    end\n    encoded_message\n\
    end", "    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    new_message = []\n\
    \    for char in message.split(\"\")\n        if vowels.include?(char.downcase)\n\
    \            new_message << char.next.next\n        else\n            new_message\
    \ << char\n        end\n    end\n    new_message.join(\"\").upcase\nend", "\t\
    # TODO: Write me!\nend", "  result = \"\"\n  message.each_char do |letter|\n \
    \   if (\"A\"..\"Z\").include?(letter)\n      result += ((letter.ord + 2 - 65)\
    \ % 26 + 65).chr\n    elsif (\"a\"..\"z\").include?(letter)\n      result += ((letter.ord\
    \ + 2 - 97) % 26 + 97).chr\n    else\n      result += letter\n    end\n  end\n\
    \  result\nend", "    result = \"\"\n    VOWELS = [\"a\", \"e\", \"i\", \"o\"\
    , \"u\"]\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    alpha = Hash[alphabet.split(\"\
    \").map.with_index.to_a]\n    message.each_char do |c|\n        if VOWELS.include?(c.downcase)\n\
    \            result += alpha[c.downcase].next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next.next",
  "  vowels = %w[a e i o u]\n  alphabet = [*'a'..'z']\n  encoded_message = \"\"\n\
    \  message.split(\"\").each do |letter|\n    index = alphabet.index(letter.downcase)\n\
    \    if index == 25 \n      new_index = 1\n    elsif index == 24\n      new_index\
    \ = 0\n    else\n      new_index = index + 2\n    end\n    new_letter = alphabet[new_index]\n\
    \    if vowels.include?(letter.downcase)\n      encoded_message += new_letter.upcase\n\
    \    elsif letter == letter.upcase\n      encoded_message += new_letter.upcase\n\
    \    else\n      encoded_message += new_letter\n    end\n  end\n  encoded_message\n\
    end", "  vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n  encoded_message = message.split(\"\
    \").map do |letter|\n    if vowels.include?(letter.downcase)\n      index = vowels.index(letter.downcase)\n\
    \      if index == 4\n        vowels[0]\n      else\n        vowels[index + 2]\n\
    \      end\n    else\n      letter\n    end\n  end\n  return encoded_message.join.swapcase\n\
    end", "  message.upcase.tr(a_z, h_p)\nend", "  cipher = ''\n  vowels = 'AEIOU'\n\
    \  (0...message.length).each do |i|\n    char = message[i]\n    if char =~ /[a-z]/i\n\
    \      cipher += if char =~ /[A-Z]/\n        char.downcase\n      else\n     \
    \   char.upcase\n      end\n    else\n      cipher += char\n    end\n  end\n \
    \ message = cipher\n  cipher = ''\n  (0...message.length).each do |i|\n    char\
    \ = message[i]\n    if vowels.include?(char.upcase)\n      if char.upcase == 'U'\n\
    \        cipher += 'A'\n      else\n        cipher += vowels[vowels.index(char.upcase)\
    \ + 2]\n      end\n    else\n      cipher += char\n    end\n  end\n  return cipher\n\
    end", "  message.downcase.gsub(/[aeiou]/, 'a' => 'c', 'e' => 'g', 'i' => 'k',\
    \ 'o' => 'q', 'u' => 's').capitalize\nend", "    i = 0\n    new_message = \"\"\
    \n    while i < message.length \n        if message[i] == message[i].upcase\n\
    \            new_message += message[i].downcase\n        else\n            new_message\
    \ += message[i].upcase\n        end\n        i += 1\n    end\n    return new_message\n\
    end\nputs encode(\"test\")\nputs encode(\"This is a message\")", "\t# your code\
    \ here\n\t# p message.split('')\n\tp message.split('').map {|x| encode_letter(x)}.join('')\n\
    end", "\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\talphabet = (\"a\"..\"\
    z\").to_a\n\tnew_message = \"\"\n\tmessage.split(\"\").each do |letter|\n\t\t\
    if letter == letter.upcase\n\t\t\tnew_message += letter.downcase\n\t\telse\n\t\
    \t\tnew_message += letter.upcase\n\t\tend\n\tend\n\tnew_message.split(\"\").each\
    \ do |letter|\n\t\tif vowels.include?(letter)\n\t\t\tvowels.each do |vowel|\n\t\
    \t\t\tif letter == vowel\n\t\t\t\t\tindex = alphabet.index(vowel)\n\t\t\t\t\t\
    new_index = index + 2\n\t\t\t\t\tnew_message[new_message.index(letter)] = alphabet[new_index]\n\
    \t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\treturn new_message\nend", "    message\
    \ = message.upcase\n    new_message = \"\"\n    #convert message to uppercase\n\
    \    message.each_char do |char|\n        if (char == \"A\")\n            new_message\
    \ += \"C\"\n        elsif (char == \"E\")\n            new_message += \"G\"\n\
    \        elsif (char == \"I\")\n            new_message += \"K\"\n        elsif\
    \ (char == \"O\")\n            new_message += \"Q\"\n        elsif (char == \"\
    U\")\n            new_message += \"S\"\n        else\n            new_message\
    \ += char\n        end\n    end\n    return new_message\nend", "\t# Split the\
    \ message into a character array\n\tmessage_array = message.chars", "  alpha =\
    \ ('a'..'z').to_a\n  vowels = %w(a e i o u)\n  new_string = \"\"\n  message.split(\"\
    \").each do |char|\n    if vowels.include?(char.downcase)\n      i = alpha.index(char.downcase)\n\
    \      new_string += alpha[i+2]\n    elsif char == char.upcase\n      i = alpha.index(char.downcase)\n\
    \      new_string += alpha[i].upcase\n    else\n      i = alpha.index(char)\n\
    \      new_string += alpha[i]\n    end\n  end\n  new_string\nend", "\tvowels =\
    \ \"aeiou\"\n\tcount = 0\n\tvowels.each_char do |l|\n\t\tif message.include?(l)\n\
    \t\t\tmessage.sub!(l, vowels[count + 2 % 5])\n\t\tend\n\t\tcount += 1\n\tend\n\
    \tmessage.swapcase\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  vowels\
    \ = \"aeiou\"\n  letters = message.chars\n  letters.map! do |letter|\n    if alphabet.include?(letter)\n\
    \      letter = letter.swapcase\n      if vowels.include?(letter.downcase)\n \
    \       alphabet.index(letter.downcase) + 2\n        if alphabet[alphabet.index(letter.downcase)\
    \ + 2] == nil\n          alphabet[alphabet.index(letter.downcase) + 2 - 26]\n\
    \        else\n          alphabet[alphabet.index(letter.downcase) + 2]\n     \
    \   end\n      else\n        letter\n      end\n    else\n      letter\n    end\n\
    \  end\n  letters.join\nend", "  alphabet = ('a'..'z').to_a\n  alphabet << ' '\n\
    \  secret_alphabet = ('c'..'z').to_a\n  secret_alphabet << 'a'\n  secret_alphabet\
    \ << 'b'\n  secret_alphabet << ' '\n  encoded_message = \"\"\n  message.each_char\
    \ do |char|\n    index = alphabet.index(char)\n    encoded_message << secret_alphabet[index]\n\
    \  end\n  encoded_message.upcase\nend", "\nend", "  # your code here\nend", "\t\
    message = message.downcase\n\tmessage = message.gsub(/[aeiou]/, 'a' => 'c', 'e'\
    \ => 'g', 'i' => 'k', 'o' => 'q', 'u' => 's')\n\tmessage = message.upcase\n\t\
    return message\nend", "  message.tr(\"a-zA-Z\", \"c-za-bC-ZA-B\")\nend", "\tvowels\
    \ = ['a', 'e', 'i', 'o', 'u']\n\talphabet = ('a'..'z').to_a", "  # YOUR CODE HERE\n\
    end", "    letras = message.split(\"\")\n    letras.map do |letra|\n        if\
    \ letra == \" \"\n            letra\n        elsif letra == letra.upcase\n   \
    \         letra.downcase\n        elsif letra == letra.downcase\n            letra.upcase\n\
    \        end\n    end\n    letras.join(\"\")\nend", "\nend", "  # Enter your solution\
    \ here!\nend", "\t# <YOUR CODE GOES HERE>\nend", "  message.downcase.gsub(/[aeiou]/,\
    \ 'a' => 'c', 'e' => 'g', 'i' => 'k', 'o' => 'q', 'u' => 's').upcase\nend", " \
    \ alphabet = (\"a\"..\"z\").to_a\n  vowels = ['a', 'e', 'i', 'o', 'u']\n  result\
    \ = ''\n  i = 0\n  while i < message.length\n    if vowels.include?(message[i].downcase)\n\
    \      index = alphabet.index(message[i].downcase)\n      index = (index + 2)\
    \ % 26\n      letter = alphabet[index]\n      if message[i] == message[i].upcase\n\
    \        letter = letter.upcase\n      end\n      result += letter\n    elsif\
    \ message[i] == message[i].upcase\n      result += message[i].downcase\n    else\n\
    \      result += message[i].upcase\n    end\n    i += 1\n  end\n  result\nend",
  "\tcase_message = message.swapcase\n\tvowels = \"AEIOUaeiou\"\n\tencoded_message\
    \ = \"\"\n\tfor letter in case_message.split(\"\")\n\t\tif vowels.include?(letter)\n\
    \t\t\tvowel_idx = vowels.index(letter)\n\t\t\tencoded_message += vowels[vowel_idx\
    \ + 2]\n\t\telse\n\t\t\tencoded_message += letter\n\t\tend\n\tend\n\tencoded_message\n\
    end\nputs encode(\"test\")\nputs encode(\"This is a message\")", end, "  vowels\
    \ = 'aeiouAEIOU'\n  letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n  encoded_message = \"\"\n  message.each_char do |char|\n    if vowels.include?(char)\n\
    \      index = letters.index(char)\n      encoded_message += letters[index + 2]\n\
    \    elsif letters.include?(char)\n      index = letters.index(char)\n      encoded_message\
    \ += letters[index + 2].swapcase\n    else\n      encoded_message += char\n  \
    \  end\n  end\n  encoded_message\nend", "  # Default to upcase\n  output = message.upcase.split('')\n\
    \  output.each_with_index do |letter, index|\n    # Downcase letters that need\
    \ to be downcased\n    output[index] = letter.downcase if message[index] == letter.downcase\n\
    \    if letter == 'A'\n      output[index] = 'C'\n    elsif letter == 'E'\n  \
    \    output[index] = 'G'\n    elsif letter == 'I'\n      output[index] = 'K'\n\
    \    elsif letter == 'O'\n      output[index] = 'Q'\n    elsif letter == 'U'\n\
    \      output[index] = 'S'\n    end\n  end\n  output.join('')\nend\nputs encode('This\
    \ is a message')", "  x = 0\n  new_str = []\n  while x < message.length\n    if\
    \ \"abcdefghijklmnopqrstuvwxyz\".include?(message[x])\n      if message[x] ==\
    \ \"z\"\n        new_str << \"b\"\n      elsif message[x] == \"y\"\n        new_str\
    \ << \"a\"\n      else\n        new_str << message[x].next.next\n      end\n \
    \   elsif \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".include?(message[x])\n      if message[x]\
    \ == \"Z\"\n        new_str << \"B\"\n      elsif message[x] == \"Y\"\n      \
    \  new_str << \"A\"\n      else\n        new_str << message[x].next.next\n   \
    \   end\n    else\n      new_str << message[x]\n    end\n    x += 1\n  end\n \
    \ new_str.join\nend", end, "\nend", "  message.tr('a-zA-Z', 'b-zaB-ZA').gsub(/[aeiou]/i,\
    \ 'x')\nend", "    dictionary = { \"a\" => \"c\", \"e\" => \"g\", \"i\" => \"\
    k\", \"o\" => \"q\", \"u\" => \"w\" }\n    message = message.downcase\n    message.each_char\
    \ do |char|\n        if dictionary.has_key?(char)\n            message[char] =\
    \ dictionary[char]\n        end\n    end\n    message.upcase\nend", "  cap_alpha\
    \ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n  lower_alpha = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  result = ''\n  message.split('').each do |letter|\n    if cap_alpha.include?(letter)\n\
    \      index = cap_alpha.index(letter)\n      if index + 2 >= cap_alpha.length\n\
    \        next_letter = cap_alpha[index + 2 - cap_alpha.length]\n      else\n \
    \       next_letter = cap_alpha[index + 2]\n      end\n      result += next_letter\n\
    \    elsif lower_alpha.include?(letter)\n      index = lower_alpha.index(letter)\n\
    \      if index + 2 >= lower_alpha.length\n        next_letter = lower_alpha[index\
    \ + 2 - lower_alpha.length]\n      else\n        next_letter = lower_alpha[index\
    \ + 2]\n      end\n      result += next_letter\n    else\n      result += letter\n\
    \    end\n  end\n  result\nend", "  final_message = \"\"\n  message.split(\"\"\
    ).each do |letter|\n    if VOWELS.include?(letter.downcase)\n      index = VOWELS.index(letter.downcase)\n\
    \      letter = VOWELS[index + 2]\n    end\n    if letter.downcase == letter\n\
    \      letter = letter.upcase\n    else\n      letter = letter.downcase\n    end\n\
    \    final_message << letter\n  end\n  final_message\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
