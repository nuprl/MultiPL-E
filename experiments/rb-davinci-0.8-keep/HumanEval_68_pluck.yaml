name: HumanEval_68_pluck
language: rb
prompt: "# \"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
  \ plucked node should be the node with the smallest even value.\n# If multiple nodes\
  \ with the same smallest even value are found return the node that has smallest\
  \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
  \ index ],\n# If there are no even values or the given array is empty, return [].\n\
  # Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n# Example 2:\n# Input: [1,2,3]\n# Output:\
  \ [2, 1]\n# Explanation: 2 has the smallest even value, and 2 has the smallest index.\
  \ \n# Example 3:\n# Input: []\n# Output: []\n# Example 4:\n# Input: [5, 0, 3, 0,\
  \ 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest value, but  there are\
  \ two zeros,\n# so we will choose the first zero, which has the smallest index.\n\
  # Constraints:\n# * 1 <= nodes.length <= 10000\n# * 0 <= node.value\ndef pluck(arr)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pluck\n\
  \    candidate = method(:pluck)\n    assert_equal([2, 1], candidate.call([4, 2,\
  \ 3]))\n    assert_equal([2, 1], candidate.call([1, 2, 3]))\n    assert_equal([],\
  \ candidate.call([]))\n    assert_equal([0, 1], candidate.call([5, 0, 3, 0, 4, 2]))\n\
  \    assert_equal([0, 3], candidate.call([1, 2, 3, 0, 5, 3]))\n    assert_equal([4,\
  \ 1], candidate.call([5, 4, 8, 4, 8]))\n    assert_equal([6, 1], candidate.call([7,\
  \ 6, 7, 1]))\n    assert_equal([], candidate.call([7, 9, 7, 1]))\n  end\nend\n"
completions: ["  evens = arr.select(&:even?)\n  evens.size.zero? ? [] : [evens.min,\
    \ arr.index(evens.min)]\nend", "  arr.find_index { |x| x.even? }.nil? ? [] : [arr.min,\
    \ arr.find_index(arr.min)]\nend", "  arr.min_by { |x| x.even? ? x : Float::INFINITY\
    \ }\nend", "  raise 'Not Implemented'\nend", "  min_even_value = nil\n  min_even_index\
    \ = nil\n  arr.each_with_index do |n, i|\n    next if n.odd?\n    if min_even_value.nil?\
    \ || n < min_even_value\n      min_even_value = n\n      min_even_index = i\n\
    \    end\n  end\n  min_even_value ? [min_even_value, min_even_index] : []\nend",
  "\treturn [] if arr.empty?", "  return [] if arr.empty?\n  evens = arr.select {\
    \ |x| x % 2 == 0 }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\n\
    end\nputs pluck([5, 0, 3, 0, 4, 2])\nputs pluck([0, 1, 2, 3, 4, 5])\nputs pluck([1,\
    \ 2, 3])\nputs pluck([4, 2, 3])\nputs pluck([])\nputs pluck([-1, -2, -3])\nputs\
    \ pluck([2, 1, 3])\nputs pluck([1, 1, 1])", "  idx = arr.each_with_index.min_by{|e,i|\
    \ [e&1, e, i]}.last\n  return [] if idx.nil?\n  [arr[idx], idx]\nend", "    return\
    \ [] if arr.length == 0\n    even = arr.select{|x| x.even?}\n    return [] if\
    \ even.length == 0\n    return [even.min, arr.index(even.min)]\nend", "  even_arr\
    \ = arr.select{|x| x % 2 == 0}\n  even_arr.empty? ? [] : [even_arr.min, arr.index(even_arr.min)]\n\
    end\nputs \"expect [2, 1]: #{pluck([4,2,3])}\"\nputs \"expect [2, 1]: #{pluck([1,2,3])}\"\
    \nputs \"expect []: #{pluck([])}\"\nputs \"expect [0, 1]: #{pluck([5, 0, 3, 0,\
    \ 4, 2])}\"", "  evens = []\n  arr.each_with_index { |n, i| evens << [n, i] if\
    \ n.even? }\n  return [] if evens.empty?\n  evens.sort_by { |n, i| [n, i] }.first\n\
    end", "  # your code here\nend", "  return [] if arr.empty?\n  even_values = []\n\
    \  even_values = arr.each_with_index.select{|value, index| value.even?}.sort_by{|value,\
    \ index| value}\n  if even_values.empty?\n    []\n  else\n    even_values[0]\n\
    \  end\nend", "  ans = []\n  arr.each_with_index do |x,i|\n    if x % 2 == 0\n\
    \      if ans.empty?\n        ans << [x,i]\n      else\n        if x < ans[0][0]\n\
    \          ans = [[x,i]]\n        elsif x == ans[0][0]\n          ans << [x,i]\n\
    \        end\n      end\n    end\n  end\n  ans.sort_by!{|x| x[1]}\n  ans.empty?\
    \ ? [] : ans[0]\nend\np pluck([4,2,3]) == [2, 1]\np pluck([1,2,3]) == [2, 1]\n\
    p pluck([]) == []\np pluck([5, 0, 3, 0, 4, 2]) == [0, 1]", "  # your code here\n\
    end", "  arr.each_with_index.select{|v, i| v.even?}.min_by{|a| [a[0], a[1]]}\n\
    end\np pluck([4,2,3]) == [2, 1]\np pluck([1,2,3]) == [2, 1]\np pluck([]) == []\n\
    p pluck([5, 0, 3, 0, 4, 2]) == [0, 1]", "  return [] if arr.empty?\n  smallest_index\
    \ = 0\n  smallest_value = nil\n  (0...arr.length).each do |index|\n    value =\
    \ arr[index]\n    next if value.odd?\n    if smallest_value.nil? || value < smallest_value\n\
    \      smallest_value = value\n      smallest_index = index\n    end\n  end\n\
    \  smallest_value.nil? ? [] : [smallest_value, smallest_index]\nend", "  return\
    \ [] if arr.empty?\n  plucked = []\n  arr.each_with_index { |n, i| plucked = [n,\
    \ i] if n.even? && (plucked.empty? || n < plucked[0]) }\n  plucked\nend", "  \
    \  arr.select { |e| e % 2 == 0 }.sort.first\nend", "  return [] if arr.empty?\n\
    \  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\n\
    end", "  # your code here\nend", "    smallest = 2 ** 32\n    smallest_index =\
    \ nil\n    arr.each_with_index do |val, i|\n        if val % 2 == 0 && val < smallest\n\
    \            smallest = val\n            smallest_index = i\n        end\n   \
    \ end\n    smallest_index == nil ? [] : [smallest, smallest_index]\nend\nputs\
    \ \"Expected: [2, 1], Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1], Actual:\
    \ #{pluck([1,2,3])}\"\nputs \"Expected: [], Actual: #{pluck([])}\"\nputs \"Expected:\
    \ [0, 1], Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"", "    return [] if arr.length\
    \ < 1\n    ans = []\n    evens = []\n    for i in 0...arr.length\n        if arr[i]\
    \ % 2 == 0\n            evens.push(arr[i])\n        end\n    end\n    if evens.length\
    \ < 1\n        return []\n    end\n    evens.sort!\n    for i in 0...arr.length\n\
    \        if arr[i] == evens[0]\n            ans.push(arr[i])\n            ans.push(i)\n\
    \            return ans\n        end\n    end\nend\nputs pluck([4,2,3]) == [2,\
    \ 1]\nputs pluck([1,2,3]) == [2, 1]\nputs pluck([]) == []\nputs pluck([5, 0, 3,\
    \ 0, 4, 2]) == [0, 1]\nputs pluck([1, 4, 6, 5, 7, 8, 4, 5, 4, 3, 2, 5, 6, 3, 2,\
    \ 5, 7, 8, 4, 5, 7, 8, 4, 6, 7, 8, 6, 5, 7, 3, 2, 5, 7, 3, 2, 5, 7, 8, 2, 5, 7,\
    \ 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2,\
    \ 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7,\
    \ 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2,\
    \ 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7, 8, 2, 5, 7,\
    \ 8, 2, 5, 7, 8, 2,", "  small = nil\n  index = nil\n  arr.each_with_index do\
    \ |num,i|\n    next if num % 2 != 0\n    if small.nil? || num < small\n      small\
    \ = num\n      index = i\n    end\n  end\n  if small.nil?\n    []\n  else\n  \
    \  [small,index]\n  end\nend", "  evens = []\n  arr.each_with_index { |e, i| evens\
    \ << [e, i] if e.even? }\n  evens.sort_by(&:first).first\nend", "end\nputs \"\
    Pluck: Given an array representing a branch of a tree that has non-negative integer\
    \ nodes", "  even_indexes = []\n  arr.each_with_index { |v, i| even_indexes <<\
    \ i if v.even? }\n  return [] if even_indexes.empty?\n  res = even_indexes.map\
    \ { |i| [arr[i], i] }.min_by { |v, i| v }\n  res\nend", "  min = nil\n  min_index\
    \ = nil\n  arr.each_with_index do |val, index|\n    if val.even?\n      if min\
    \ == nil || val < min\n        min = val\n        min_index = index\n      end\n\
    \    end\n  end\n  return [] if min == nil\n  [min, min_index]\nend", "  # your\
    \ code here\nend", "    return [] if arr.empty?\n    even = arr.find_all{|x| x\
    \ % 2 == 0}\n    return [] if even.empty?\n    idx = arr.index(even.min)\n   \
    \ [even.min, idx]\nend\nputs \"Expected: [2, 1], Actual: #{pluck([4,2,3])}\"\n\
    puts \"Expected: [2, 1], Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [], Actual:\
    \ #{pluck([])}\"\nputs \"Expected: [0, 1], Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"",
  "  arr.map.with_index { |e, i| [e, i] if e.even? }.compact.min || []\nend", "  return\
    \ [] if arr.empty?\n  smallest = arr.map(&:to_i).select(&:even?).min\n  smallest.nil?\
    \ ? [] : [smallest, arr.index(smallest.to_s)]\nend", "  arr.each_with_index do\
    \ |v, i|\n    return [v, i] if v.even?\n  end\n  []\nend", "  evens = arr.select\
    \ { |node| node.even? }\n  return [] if evens.empty?\n  smallest = evens.min\n\
    \  [smallest, arr.index(smallest)]\nend", "  return [] if arr.empty?\n  evens\
    \ = arr.select { |e| e.even? }\n  return [] if evens.empty?\n  evens.min.to_s\n\
    end", "  return [] if arr.empty?\n  evens = []\n  arr.each_with_index do |n,i|\n\
    \    evens << [n,i] if n.even?\n  end\n  evens.min_by { |a| a[0] }\nend", "  return\
    \ [] if arr.empty?\n  result = []\n  even_arr = arr.select { |e| e.even? }\n \
    \ return [] if even_arr.empty?\n  even_arr.sort!\n  small_even = even_arr[0]\n\
    \  result << small_even\n  result << arr.index(small_even)\n  result\nend\nputs\
    \ \"Expected: [2, 1]\"\nputs \"Output: #{pluck([4,2,3])}\"\nputs \"Expected: [2,\
    \ 1]\"\nputs \"Output: #{pluck([1,2,3])}\"\nputs \"Expected: []\"\nputs \"Output:\
    \ #{pluck([])}\"\nputs \"Expected: [0, 1]\"\nputs \"Output: #{pluck([5, 0, 3,\
    \ 0, 4, 2])}\"", "  return [] if arr.empty?\n  even_nums = []\n  i = 0\n  while\
    \ i < arr.length\n    if arr[i] % 2 == 0\n      even_nums << [arr[i], i]\n   \
    \ end\n    i += 1\n  end\n  return [] if even_nums.empty?\n  result = even_nums[0]\n\
    \  i = 1\n  while i < even_nums.length\n    if even_nums[i][0] < result[0]\n \
    \     result = even_nums[i]\n    end\n    i += 1\n  end\n  result\nend", "  e\
    \ = arr.select { |e| e.even? }\n  return [] if e.empty?\n  e.sort!\n  e.unshift(arr.index(e.first))\n\
    end", "  if arr.length == 0\n    return []\n  end\n  even = []\n  i = 0\n  while\
    \ i < arr.length\n    if arr[i] % 2 == 0\n      even.push([arr[i], i])\n    end\n\
    \    i += 1\n  end\n  return [] if even.length == 0\n  even.sort! { |a, b| a[0]\
    \ <=> b[0] }\n  even[0]\nend", "  # your code here\nend", "  if arr.empty?\n \
    \   return []\n  end\n  even_count = 0\n  nodes = []\n  arr.each_with_index do\
    \ |val, idx|\n    if val.even?\n      even_count += 1\n      nodes << [val, idx]\n\
    \    end\n  end\n  if even_count == 0\n    return []\n  end\n  nodes.sort_by {\
    \ |val, idx| [val, idx] }.first\nend\nputs \"Problem 2: #{pluck([5, 0, 3, 0, 4,\
    \ 2])}\"", "  evens = []\n  arr.each_with_index { |x, i| evens << [x, i] if x.even?\
    \ }\n  evens.empty? ? [] : evens.min\nend\np pluck([4,2,3]) # [2, 1]\np pluck([1,2,3])\
    \ # [2, 1]\np pluck([]) # []\np pluck([5, 0, 3, 0, 4, 2]) # [0, 1]", "  arr.map.with_index{|v,i|\
    \ [v,i] if v.even?}.compact.min_by{|x| x[0]} || []\nend", "  evens = []\n  arr.each_with_index\
    \ { |v, i| evens << [v, i] if v.even? }\n  evens.min_by { |v, i| v } || []\nend",
  "  return [] if arr.empty?\n  evens = arr.select { |e| e.even? }\n  return [] if\
    \ evens.empty?\n  [evens.min, arr.index(evens.min)]\nend", "    smallest = nil\n\
    \    smallest_i = nil\n    arr.each_with_index do |x,i|\n        if (x % 2 ==\
    \ 0)\n            if !smallest || x < smallest\n                smallest = x\n\
    \                smallest_i = i\n            end\n        end\n    end\n    return\
    \ [] if smallest.nil?\n    [smallest, smallest_i]\nend", "  arr.select(&:even?).min\n\
    end", "    odd_arr = []\n    even_arr = []\n    arr.each_with_index do |el, idx|\n\
    \        el.even? ? even_arr << [el, idx] : odd_arr << [el, idx]\n    end\n  \
    \  even_arr.sort[0] || []\nend", "    return [] if arr.empty?\n    curr_min =\
    \ -1;\n    idx = nil;\n    arr.each_with_index { |x, i|\n        next if x%2 ==\
    \ 1\n        if curr_min == -1\n            curr_min = x\n            idx = i\n\
    \        elsif x < curr_min\n            curr_min = x\n            idx = i\n \
    \       end\n    }\n    return [] if curr_min == -1\n    return [curr_min, idx]\n\
    end", "  arr.each_with_index do |e, i|\n    return [e, i] if e.even?\n  end\n\
    \  []\nend", "  idx, min = nil, nil\n  arr.each_with_index { |x, i| idx, min =\
    \ i, x if x % 2 == 0 && (min.nil? || x < min) }\n  idx.nil? ? [] : [min, idx]\n\
    end", "  evens = arr.select { |x| x.even? }\n  return [] if evens.empty?\n  smallest\
    \ = evens.min\n  index = arr.index(smallest)\n  [smallest, index]\nend", "  return\
    \ [] if arr.empty?\n  return [] if arr.all?{|n| n % 2 != 0}\n  evens = arr.select{|n|\
    \ n % 2 == 0}\n  evens.uniq.sort!\n  inds = evens.map{|n| arr.index(n)}\n  [evens[0],\
    \ inds[0]]\nend", "  arr.min_by.with_index { |v, i| v.even? ? [v, i] : [Float::INFINITY,\
    \ Float::INFINITY] }\nend", "  return [] if arr.empty?\n  evens = arr.select(&:even?)\n\
    \  min = evens.min\n  [min, arr.index(min)]\nend", "  even_values = arr.select\
    \ { |x| x.even? }\n  return [] if even_values.empty?\n  even_values.each_with_index.min.reverse\n\
    end", "  min_value = nil\n  min_index = -1\n  arr.each_with_index do |value, index|\n\
    \    if value % 2 == 0\n      if min_value.nil? || value < min_value\n       \
    \ min_value = value\n        min_index = index\n      end\n    end\n  end\n  if\
    \ min_value.nil?\n    []\n  else\n    [min_value, min_index]\n  end\nend", " \
    \   return [] if arr.length == 0\n    even = {}\n    arr.each_with_index { |a,i|\n\
    \        even[a] = i if a%2 == 0\n    }\n    return [] if even.length == 0\n \
    \   min = even.keys.min\n    return [min, even[min]]\nend", end, "  arr.sort_by.with_index\
    \ { |x,i| [x.even? ? 0 : 1, x, i] }.find(&:even?)&.then { |x| [x, arr.index(x)]\
    \ } || []\nend\np pluck([4,2,3])\np pluck([1,2,3])\np pluck([])\np pluck([5, 0,\
    \ 3, 0, 4, 2])", "    evens = arr.find_all { |n| n % 2 == 0 }\n    return [] if\
    \ evens.empty?\n    small_even = evens.min\n    return [small_even, arr.index(small_even)]\n\
    end", "  small = nil\n  ind = nil\n  arr.each_with_index do |e, i|\n    if e.even?\n\
    \      if small.nil?\n        small = e\n        ind = i\n      elsif e < small\n\
    \        small = e\n        ind = i\n      end\n    end\n  end\n  return [] if\
    \ small.nil?\n  [small, ind]\nend", "  arr.each_with_index do |val,idx|\n    return\
    \ [val,idx] if val % 2 == 0 && (arr.empty? || idx == arr.index(arr.min) && val\
    \ == arr.min)\n  end\n  []\nend", "  return [] if arr.empty?\n  evens = arr.select\
    \ { |x| x.even? }\n  return [] if evens.empty?\n  smallest = evens.min\n  index\
    \ = arr.index(smallest)\n  [smallest, index]\nend", "  evens = arr.select { |num|\
    \ num % 2 == 0 }.sort\n  index = evens.index(evens.first)\n  if evens.empty?\n\
    \    []\n  else\n    [evens.first, index]\n  end\nend\np pluck([4,2,3])\np pluck([1,2,3])\n\
    p pluck([])\np pluck([5, 0, 3, 0, 4, 2])", "  evens = arr.select { |e| e.even?\
    \ }\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", "  # Convert\
    \ to list of (val, idx) pairs.\n  pairs = arr.map.with_index { |val, idx| [val,\
    \ idx] }\n  # Keep only even values.\n  evens = pairs.select { |val, idx| val.even?\
    \ }\n  # Sort by value and by index.\n  evens.sort_by! { |val, idx| [val, idx]\
    \ }\n  # Return first even value, or nil if no even values.\n  return evens.first\n\
    end\nputs \"#{pluck([4,2,3])}\"\nputs \"#{pluck([1,2,3])}\"\nputs \"#{pluck([])}\"\
    \nputs \"#{pluck([5, 0, 3, 0, 4, 2])}\"", "    #puts \"pluck_1> arg = #{arr}\"\
    \n    return [] if arr.nil? || arr.empty?\n    #puts \"pluck_2> arr = #{arr}\"\
    \n    min_even_val = 2**40\n    min_even_val_idx = -1\n    arr.each_with_index\
    \ do |item, idx|\n        #puts \"pluck_3> item = #{item}, idx = #{idx}\"\n  \
    \      min_even_val, min_even_val_idx = item, idx if item % 2 == 0 && item < min_even_val\n\
    \    end\n    #puts \"pluck_4> min_even_val = #{min_even_val}, min_even_val_idx\
    \ = #{min_even_val_idx}\"\n    return min_even_val_idx == -1 ? [] : [min_even_val,\
    \ min_even_val_idx]\nend", "\tputs(\"arr: #{arr}\")\n\treturn [] if(arr.length\
    \ == 0)\n\tmin_even_val = nil\n\tmin_even_idx = -1\n\tfor i in 0...arr.length\n\
    \t\tval = arr[i]\n\t\tif((val % 2) == 0)\n\t\t\tif(min_even_val == nil)\n\t\t\t\
    \tmin_even_val = val\n\t\t\t\tmin_even_idx = i\n\t\t\telsif(val < min_even_val)\n\
    \t\t\t\tmin_even_val = val\n\t\t\t\tmin_even_idx = i\n\t\t\tend\n\t\tend\n\tend\n\
    \tif(min_even_val == nil)\n\t\t[]\n\telse\n\t\t[min_even_val, min_even_idx]\n\t\
    end\nend", "  return [] if arr.empty?\n  min, min_ind = nil, nil\n  arr.each_with_index\
    \ do |n, i|\n    if (n % 2).zero?\n      if min.nil? || n < min\n        min =\
    \ n\n        min_ind = i\n      end\n    end\n  end\n  min.nil? ? [] : [min, min_ind]\n\
    end", "  evens = arr.find_all { |node| node.even? }\n  return [] if evens.empty?\n\
    \  evens.min <=> evens.max\nend", "  return [] if arr.empty?\n  evens = arr.select\
    \ { |n| n.even? }\n  return [] if evens.empty?\n  min = evens.min\n  return [min,\
    \ arr.index(min)]\nend", "  return [] if arr.nil? || arr.empty?\n  even_values\
    \ = arr.select { |e| e.even? }\n  return [] if even_values.empty?\n  min_even_value\
    \ = even_values.min\n  [min_even_value, arr.index(min_even_value)]\nend", "  \
    \  i, j = 0, -1\n    for k in (0...arr.length)\n        if (arr[k] % 2 == 0)\n\
    \            if (j == -1)\n                i, j = k, arr[k]\n            elsif\
    \ (arr[k] < j)\n                i, j = k, arr[k]\n            end\n        end\n\
    \    end\n    j == -1 ? [] : [j, i]\nend", "    return [] if arr.empty?\n    min\
    \ = arr.min\n    return [] if min.odd?\n    min = arr.map { |e| e if e.even? }.compact.min\n\
    \    return [] if min.nil?\n    min_arr = arr.map.with_index { |e, i| [e, i] if\
    \ e == min }.compact\n    return min_arr.min { |a, b| a[1] <=> b[1] }\nend", "\t\
    min = arr.find { |x| x % 2 == 0 }\n\treturn [] if min.nil?\n\tres = []\n\tarr.each_with_index\
    \ { |x, i| res = [x, i] if x == min }\n\tres\nend", "    return [] if arr.empty?\n\
    \    if evens = arr.select { |node| node.even? }\n        evens.sort!\n      \
    \  arr.each_with_index do |node, i|\n            return [node, i] if node == evens[0]\n\
    \        end\n    end\n    []\nend", "  # no array, no even numbers\n  return\
    \ [] if arr.length == 0\n  # iterate over the array and find the even numbers\n\
    \  even_numbers = []\n  arr.each_with_index do |num, index|\n    if num % 2 ==\
    \ 0\n      even_numbers << [num, index]\n    end\n  end\n  # select the even number\
    \ with the smallest value\n  even_numbers.min\nend", "    # map!\n    result =\
    \ []\n    return result if arr.empty?\n    arr.map! { |e| e.even? ? e : -1 }\n\
    \    arr.sort!\n    arr.delete_if { |e| e == -1 }\n    return result if arr.empty?\n\
    \    smalest_value = arr[0]\n    index = arr.index(smalest_value)\n    result\
    \ << smalest_value\n    result << index\n    result\nend\nputs pluck([4,2,3])\n\
    puts pluck([1,2,3])\nputs pluck([])\nputs pluck([5, 0, 3, 0, 4, 2])", "    # return\
    \ [] if arr.empty?\n    # return [] if arr.select { |e| e.even? }.empty?\n   \
    \ # return [arr.select { |e| e.even? }.min, arr.index(arr.select { |e| e.even?\
    \ }.min)]\n    return [] if arr.empty?\n    return [] if arr.select { |e| e.even?\
    \ }.empty?\n    return [arr.select { |e| e.even? }.min, arr.index(arr.select {\
    \ |e| e.even? }.min)]\nend", "    return [] if arr.empty?\n    even_arr = arr.select\
    \ { |x| x.even? }\n    return [] if even_arr.empty?\n    even_arr.map.with_index\
    \ { |x, idx| [x, idx] }.min_by { |x| x[0] }\nend", "  return [] if arr.empty?\n\
    \  min_even = nil\n  min_idx = -1\n  arr.each_with_index do |el, idx|\n    if\
    \ el.even? && (min_even.nil? || el < min_even)\n      min_even = el\n      min_idx\
    \ = idx\n    end\n  end\n  min_even.nil? ? [] : [min_even, min_idx]\nend", " \
    \   i, j = 0, arr.size-1\n    while i <= j\n        return [arr[i], i] if arr[i].even?\n\
    \        i += 1\n    end\n    [arr[i], i]\nend", "    # your code here\nend",
  "  # ...\nend", "\treturn [] if !arr || arr.length == 0\n\t\n\tsmallest_value =\
    \ nil\n\tsmallest_index = nil\n\tfor i in 0...arr.length\n\t\tnext if arr[i] %\
    \ 2 != 0\n\t\tif !smallest_value || arr[i] < smallest_value\n\t\t\tsmallest_value\
    \ = arr[i]\n\t\t\tsmallest_index = i\n\t\tend\n\tend\n\treturn [] if !smallest_value\n\
    \t[smallest_value, smallest_index]\nend", "  count = []\n  arr.each_with_index\
    \ { |node, i|\n    if node.even?\n      count << [node, i]\n    end\n  }\n  count.min.nil?\
    \ ? [] : count.min\nend\nputs \"Expected: [2, 1] -- Actual: #{pluck([4,2,3])}\"\
    \nputs \"Expected: [2, 1] -- Actual: #{pluck([1,2,3])}\"\nputs \"Expected: []\
    \ -- Actual: #{pluck([])}\"\nputs \"Expected: [0, 1] -- Actual: #{pluck([5, 0,\
    \ 3, 0, 4, 2])}\"", "  unless arr.empty?\n    evens = arr.each_with_index.select\
    \ { |i, idx| i.even? }\n    evens.sort_by { |i, idx| [i, idx] }.first\n  end\n\
    end", "  answer = []\n  min = 0xffff\n  min_i = 0xffff\n  arr.each_with_index\
    \ do |n, i|\n    if n % 2 == 0\n      min = n if n < min\n      min_i = i if i\
    \ < min_i\n    end\n  end\n  answer = [min, min_i] if min < 0xffff && min_i <\
    \ 0xffff\n  answer\nend", "  min = arr.index do |e|\n    e.even?\n  end\n  return\
    \ [] if min.nil?\n  [arr[min], min]\nend", "  curr_min = [1.0/0.0, 1.0/0.0]\n\
    \  arr.each_with_index do |x, i|\n    curr_min = [x, i] if x < curr_min[0] &&\
    \ x.even?\n  end\n  curr_min[0] == 1.0/0.0 ? [] : curr_min\nend", "  smallest,\
    \ smallest_index = nil, nil\n  arr.each_with_index do |e, i|\n    if e.even?\n\
    \      if smallest.nil? || e < smallest\n        smallest = e\n        smallest_index\
    \ = i\n      end\n    end\n  end\n  return [] if smallest.nil?\n  [smallest, smallest_index]\n\
    end", "  return [] if arr.empty?\n  even_values = arr.reject { |x| x.odd? }\n\
    \  return [] if even_values.empty?\n  min_value = even_values.min\n  min_index\
    \ = arr.index(min_value)\n  [min_value, min_index]\nend", "  num = nil\n  index\
    \ = nil\n  arr.each_with_index do |num_comp, index_comp|\n    if num_comp % 2\
    \ == 0 && (num == nil || num_comp < num)\n      num = num_comp\n      index =\
    \ index_comp\n    end\n  end\n  return [] if num == nil\n  [num, index]\nend",
  "    h = {}\n    arr.each_with_index { |e, i| h[e] = i if e.even? }\n    return\
    \ [] if h.size == 0\n    [h.keys.min, h[h.keys.min]]\nend", "  return [] if arr.length\
    \ == 0 || arr.length > 10000\n  evens = arr.select { |v| v.even? }\n  return []\
    \ if evens.length == 0\n  min_index = evens.map { |v| arr.index(v) }.min\n  [evens.min,\
    \ min_index]\nend", "  return [] if arr.empty?\n  hash = {}\n  arr.each_with_index\
    \ do |num, i|\n    if num.even?\n      hash[num] = i\n    end\n  end\n  return\
    \ [] if hash.empty?\n  sorted = hash.sort\n  smallest = sorted[0][0]\n  index\
    \ = sorted[0][1]\n  [smallest, index]\nend", "  return [] if arr.empty?\n  evens\
    \ = []\n  arr.each_with_index { |n, i| evens << [n, i] if n.even? }\n  evens.sort!\
    \ { |a, b| a[0] <=> b[0] }\n  return [] if evens.empty?\n  evens[0]\nend", " \
    \   return [] if arr.empty?\n    arr = arr.sort\n    evens = arr.select { |el|\
    \ el.even? }\n    evens.empty? ? [] : [evens[0], arr.index(evens[0])]\nend", " \
    \ return [] if arr.empty?\n  return [arr[0], 0] if arr.length == 1", "    even_array\
    \ = arr.select{|e| e.even?}\n    if even_array.empty?\n        return []\n   \
    \ else\n        return [even_array.min, arr.index(even_array.min)]\n    end\n\
    end", "    new_arr = []\n    if arr.all? { |num| num % 2 != 0 } || arr.length\
    \ == 0\n        return []\n    else\n        arr.each_with_index do |num, idx|\n\
    \            if num % 2 == 0\n                new_arr << [num, idx]\n        \
    \    end\n        end\n        return new_arr.sort[0]\n    end\nend", "  min =\
    \ arr.min\n  return [] if !min.even?\n  arr.map.with_index { |e, i| [e, i] }.select\
    \ { |e| e[0] == min }.first\nend", "    ev = arr.select{|x| x.even?}.sort\n  \
    \  return [] if ev.empty?\n    [ev[0], arr.index(ev[0])]\nend", end, "  evens\
    \ = arr.select { |n| n.even? }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\n\
    end", end, "  even_idx = arr.each_with_index.min_by{|v, i| v.even? ? v : Float::INFINITY}\n\
    \  return [] if !even_idx\n  [even_idx[0], even_idx[1]]\nend", "  return [] if\
    \ arr.empty?\n  evens = []\n  arr.each_with_index do |e, idx|\n    if e.even?\n\
    \      evens << [e, idx]\n    end\n  end\n  if evens.empty?\n    []\n  else\n\
    \    evens.sort! { |a, b| [a[0], a[1]] <=> [b[0], b[1]] }\n    evens[0]\n  end\n\
    end", "  # your code here\nend", "  arr.each_with_index do |v,i|\n    return [v,i]\
    \ if v.even?\n  end\n  []\nend", "  return [] if arr.empty?\n  return arr.map{|i|\
    \ i.even? ? i : nil}.compact.min\nend\n  ", "  return [] if arr.empty?\n  res\
    \ = []\n  min = nil\n  for i in 0...arr.length\n    if arr[i].even?\n      if\
    \ min.nil?\n        min = arr[i]\n        res = [min, i]\n      elsif arr[i] <\
    \ min\n        min = arr[i]\n        res = [min, i]\n      end\n    end\n  end\n\
    \  res\nend", "    min = nil\n    min_index = nil\n    even_count = 0\n    arr.each_with_index\
    \ do |val, index|\n        if (val % 2 == 0)\n            even_count += 1\n  \
    \          if (min.nil? || val < min)\n                min = val\n           \
    \     min_index = index\n            end\n        end\n    end\n    if (even_count\
    \ == 0)\n        return []\n    end\n    return [min, min_index]\nend", "    if\
    \ !arr || arr.length == 0\n        return []\n    end\n    arr.each_with_index\
    \ do |item, i|\n        if item % 2 == 0\n            return [item, i]\n     \
    \   end\n    end\n    return []\nend", "  return [] if arr.empty?\n  max = arr.size\n\
    \  i = 0\n  while (i < max) do\n    if (arr[i] % 2 == 0)\n      return [arr[i],\
    \ i]\n    end\n    i += 1\n  end\n  return []\nend", "\treturn [] if arr.empty?",
  "  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\n\
    end", "  return [] if arr.empty?\n  evens = arr.select { |n| n.even? }\n  return\
    \ [] if evens.empty?\n  min_val = evens.min\n  min_idx = arr.index(min_val)\n\
    \  [min_val, min_idx]\nend", "\t# Check for edge cases.\n\tif arr.length == 0\n\
    \t\treturn []\n\tend\n\t\n\t# Create the list of even numbers, and the hash of\
    \ index keys and numbers\n\t# Also keep track of the smallest number\n\teven_numbers\
    \ = []\n\tindex_values = {}\n\tsmallest_number = nil\n\t\n\t# Loop through the\
    \ array, and populate even_numbers and index_values\n\tfor i in 0..arr.length-1\n\
    \t\tif arr[i] % 2 == 0\n\t\t\teven_numbers.push(arr[i])\n\t\t\tindex_values[arr[i]]\
    \ = i\n\t\t\t\n\t\t\tif smallest_number == nil || arr[i] < smallest_number\n\t\
    \t\t\tsmallest_number = arr[i]\n\t\t\tend\n\t\tend\n\tend\n\t\n\t# If there were\
    \ no even numbers\n\tif even_numbers.length == 0\n\t\treturn []\n\tend\n\t\n\t\
    # Get the smallest value, and its index from the dictionary\n\t# And return that\
    \ as an array\n\treturn [smallest_number, index_values[smallest_number]]\nend",
  "    arr.each_with_index do |e,i|\n        if e % 2 == 0 && arr.first(i).select{|e|\
    \ e % 2 == 0}.empty?\n            return [e,i]\n        end\n    end\n    []\n\
    end\nputs 'Given an array representing a branch of a tree that has non-negative\
    \ integer nodes", "    values = []\n    arr.each_with_index { |x,i| values <<\
    \ [x,i] if x.even? }\n    values.min\nend", "  ary = arr.select{|i| i.even?}\n\
    \  ary.empty? ? [] : [ary.min, arr.index(ary.min)]\nend", "    return [] if arr.empty?\n\
    \    smallest_index = nil\n    smallest_even = nil\n    arr.each_with_index do\
    \ |node, index|\n        if node.even?\n            if smallest_even.nil?\n  \
    \              smallest_even = node\n                smallest_index = index\n\
    \            elsif node < smallest_even\n                smallest_even = node\n\
    \                smallest_index = index\n            end\n        end\n    end\n\
    \    smallest_even.nil? ? [] : [smallest_even, smallest_index]\nend", "  return\
    \ [] if arr.empty?\n  evens = []\n  arr.each_with_index { |node, i| evens << [node,\
    \ i] if node.even? }\n  return [] if evens.empty?\n  evens.sort { |a, b| a[0]\
    \ <=> b[0] }[0]\nend", "  arr.each_with_index do |val, idx|\n    return [val,\
    \ idx] if val.even?\n  end\n  []\nend\nputs '##################### Pluck Branch\
    \ #####################'\nputs 'Pluck'\nputs \"Input: [4,2,3]\\nOutput: #{pluck([4,2,3])}\"\
    \nputs \"Input: [1,2,3]\\nOutput: #{pluck([1,2,3])}\"\nputs \"Input: []\\nOutput:\
    \ #{pluck([])}\"\nputs \"Input: [5, 0, 3, 0, 4, 2]\\nOutput: #{pluck([5, 0, 3,\
    \ 0, 4, 2])}\"", "  small = []\n  if arr.empty?\n    return []\n  else\n    arr.each_with_index\
    \ do |number, index|\n      if number % 2 == 0 && number < arr[index + 1]\n  \
    \      small = [number, index]\n      else\n        next\n      end\n    end\n\
    \  end\n  small\nend", "  evens = arr.select(&:even?)\n  evens.empty? ? [] : [evens.min,\
    \ arr.index(evens.min)]\nend", "    if arr.length==0\n        return []\n    end\n\
    \    a = []\n    for i in 0..arr.length-1\n        if arr[i]%2==0\n          \
    \  a.push(arr[i])\n        end\n    end\n    if a.length==0\n        return []\n\
    \    end\n    smallest = a[0]\n    index = 0\n    for i in 0..a.length-1\n   \
    \     if a[i]<smallest\n            smallest = a[i]\n            index = i\n \
    \       end\n    end\n    return [smallest,index]\nend", '  return [] if arr.empty?',
  "  small_even = -1\n  index = -1\n  arr.each_with_index do |num, i|\n    if num.even?\
    \ && small_even == -1\n      small_even = num\n      index = i\n    elsif num.even?\
    \ && num < small_even\n      small_even = num\n      index = i\n    end\n  end\n\
    \  small_even != -1 ? [small_even, index] : []\nend", "  arr.map.with_index do\
    \ |e,i|\n    return [e,i] if e.even?\n  end\n  []\nend", "\treturn [] if arr.empty?\
    \ || arr.select{|n| n.even?}.empty?\n\t\n\tarr.select{|n| n.even?}.min\nend",
  "  raise ArgumentError, \"Argument is nil\" if arr.nil?\n  raise ArgumentError,\
    \ \"Argument is empty\" if arr.empty?\n  evens = arr.select { |num| num.even?\
    \ }\n  return [] if evens.empty?\n  evens.min == 0 ? [0, arr.index(0)] : [evens.min,\
    \ arr.index(evens.min)]\nend", "  return [] if arr.length == 0\n  smallest_even\
    \ = arr.min\n  smallest_even -= 1 if smallest_even.odd?\n  return [] if smallest_even\
    \ < 0\n  smallest_even_index = nil\n  arr.each_with_index do |element, index|\n\
    \    if element == smallest_even\n      smallest_even_index = index\n      break\n\
    \    end\n  end\n  [smallest_even, smallest_even_index]\nend", "    if arr.nil?\
    \ || arr.length == 0\n        []\n    else\n        vals = arr.select { |v| v\
    \ % 2 == 0 }\n        # puts \"vals: #{vals}\"\n        if vals.length == 0\n\
    \            []\n        else\n            smallest = vals.min\n            #\
    \ puts \"smallest: #{smallest}\"\n            idx = arr.index(smallest)\n    \
    \        # puts \"idx: #{idx}\"\n            [smallest, idx]\n        end\n  \
    \  end\nend", "  smallest, smallest_index = nil, nil\n  arr.each_with_index do\
    \ |val, index|\n    if val.even?\n      if smallest.nil? || val < smallest\n \
    \       smallest = val\n        smallest_index = index\n      end\n    end\n \
    \ end\n  smallest.nil? ? [] : [smallest, smallest_index]\nend", "    return []\
    \ if arr.empty?\n    num = []\n    arr.each_with_index do |val, i|\n        num.push([val,\
    \ i]) if val.even?\n    end\n    return [] if num.empty?\n    num.sort!\n    num[0]\n\
    end", "    if arr.empty?\n        return []\n    else\n        even_nums = arr.select\
    \ { |num| num.even? }\n        if even_nums.empty?\n            return []\n  \
    \      else\n            even_min = even_nums.min\n            return [even_min,\
    \ arr.index(even_min)]\n        end\n    end\nend\nputs \"Pluck:\"\nputs pluck([1,2,3])\
    \ == [2, 1]\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([5, 0, 3, 0, 4, 2]) ==\
    \ [0, 1]\nputs pluck([]) == []", "  return [] if arr.length == 0\n  smallest_even\
    \ = arr.min\n  smallest_even_index = 0\n  if smallest_even.even?\n    smallest_even_index\
    \ = arr.index(smallest_even)\n  else\n    while smallest_even.odd?\n      arr.delete_at(arr.index(smallest_even))\n\
    \      smallest_even = arr.min\n    end\n    smallest_even_index = arr.index(smallest_even)\n\
    \  end\n  return [smallest_even, smallest_even_index]\nend\nputs \"Expected: [2,\
    \ 1] -- Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1] -- Actual: #{pluck([1,2,3])}\"\
    \nputs \"Expected: [] -- Actual: #{pluck([])}\"\nputs \"Expected: [0, 1] -- Actual:\
    \ #{pluck([5, 0, 3, 0, 4, 2])}\"", "  # your code here\nend", "  # your code here\n\
    end", "  min_value = nil\n  min_index = nil\n  arr.each_with_index do |val, idx|\n\
    \    next if val % 2 != 0\n    if min_value.nil? || val < min_value\n      min_value\
    \ = val\n      min_index = idx\n    end\n  end\n  return [] if min_value.nil?\n\
    \  [min_value, min_index]\nend", '  return [] if arr.empty?', " \nend", "  h =\
    \ {}\n  arr.each_with_index do |i, index|\n    h[i] = index if i.even?\n  end\n\
    \  arr = h.sort_by{|k,v| k}.first\n  arr[0] == nil ? [] : arr\nend", "    smallest,\
    \ index = [], []\n    for i in (0...arr.length)\n        if arr[i] % 2 == 0 &&\
    \ smallest.length == 0\n            smallest << arr[i]\n            index << i\n\
    \        elsif arr[i] % 2 == 0 && arr[i] < smallest[0]\n            smallest =\
    \ []\n            index = []\n            smallest << arr[i]\n            index\
    \ << i\n        elsif arr[i] % 2 == 0 && arr[i] == smallest[0]\n            smallest\
    \ << arr[i]\n            index << i\n        end\n    end\n    smallest.length\
    \ == 0 ? [] : [smallest[0], index[0]]\nend", "    return [] if arr.empty?\n  \
    \  return [] if arr.all?{|x| x % 2 != 0}\n    smallest_value = arr.min\n    smallest_index\
    \ = 0\n    arr.each_with_index do |x,index|\n        if x == smallest_value\n\
    \            smallest_index = index\n            break\n        end\n    end\n\
    \    return [smallest_value, smallest_index]\nend", "    is_even_arr = arr.select\
    \ { |x| x % 2 == 0}\n    if is_even_arr.length == 0\n        return []\n    end\n\
    \    min_val = is_even_arr.min\n    idx = arr.index(min_val)\n    return [min_val,\
    \ idx]\nend", "    h = Hash.new(0)\n    return [] if arr.empty?\n    min = arr.first\n\
    \    arr.each { |e| h[e] += 1 }\n    h.each do |k, v|\n        if k % 2 == 0 &&\
    \ k < min\n            min = k\n        end\n    end\n    return [min, arr.index(min)]\n\
    end\nputs pluck([4,2,3])\nputs pluck([1,2,3])\nputs pluck([])\nputs pluck([5,\
    \ 0, 3, 0, 4, 2])", "  evens = arr.select { |v| v.even? }\n  return [] if evens.empty?\n\
    \  evens.sort!\n  [evens.first, arr.index(evens.first)]\nend", "  return [] if\
    \ arr.nil? || arr.size == 0\n  lowest_even = arr.select{|val| val.even?}.min\n\
    \  if lowest_even.nil?\n    []\n  else\n    [lowest_even, arr.index(lowest_even)]\n\
    \  end\nend", "  smallest_even = nil\n  smallest_even_idx = nil\n  arr.each_with_index\
    \ do |n, idx|\n    next if n.odd?\n    smallest_even = n\n    smallest_even_idx\
    \ = idx\n    break\n  end\n  return [] if smallest_even.nil?\n  arr.each_with_index\
    \ do |n, idx|\n    next if n.odd?\n    if n < smallest_even\n      smallest_even\
    \ = n\n      smallest_even_idx = idx\n    end\n  end\n  [smallest_even, smallest_even_idx]\n\
    end", "  return [] if arr.empty?\n  sorted = arr.sort\n  sorted.select!{|n| n.even?}\n\
    \  return [] if sorted.empty?\n  min = sorted.first\n  idx = arr.index(min)\n\
    \  return [min, idx]\nend", "  evens = []\n  arr.each_with_index do |val, i|\n\
    \    evens << [val, i] if val.even?\n  end\n  evens.min_by { |val, _| val }\n\
    end", "  smallest_even_idx = nil\n  smallest_even_value = nil\n  arr.each_with_index\
    \ do |value, index|\n    next if value.odd?\n    if smallest_even_value.nil? ||\
    \ value < smallest_even_value\n      smallest_even_value = value\n      smallest_even_idx\
    \ = index\n    end\n  end\n  return [] if smallest_even_value.nil?\n  [smallest_even_value,\
    \ smallest_even_idx]\nend", "  i = 0\n  even = []\n  while i < arr.length\n  \
    \  if arr[i] % 2 == 0\n      even << [arr[i], i]\n    end\n    i += 1\n  end\n\
    \  return [] if even.empty?\n  even.sort! { |a, b| a[0] <=> b[0] }\n  even[0]\n\
    end", "  evens = arr.select { |v| v.even? }\n  return [] if evens.empty?\n  evens.min\n\
    end", "  num = arr.find { |x| x.even? }\n  return [] if num.nil?\n  num_idx =\
    \ arr.index(num)\n  [num, num_idx]\nend", "  x, y = [], nil\n  arr.each_with_index\
    \ do |n, i|\n    next if !n.even?\n    x[0] ||= n\n    if n < x[0]\n      x =\
    \ [n, i]\n    end\n  end\n  x.size == 1 ? [] : x\nend", "  smallest = nil\n  index\
    \ = -1\n  arr.each_with_index do |e,i|\n    next if e.odd?\n    if smallest.nil?\
    \ || e < smallest\n      smallest = e\n      index = i\n    end\n  end\n  return\
    \ [] if smallest.nil?\n  [smallest, index]\nend", "  return [] if arr.length ==\
    \ 0\n  evens = []\n  arr.each_with_index { |e, i| evens << [e, i] if e % 2 ==\
    \ 0 }\n  return [] if evens.length == 0\n  evens.sort!\n  evens[0]\nend", "  return\
    \ [] if arr.empty?\n  even_values = arr.select(&:even?)\n  return [] if even_values.empty?\n\
    \  min_value = even_values.min\n  [min_value, arr.index(min_value)]\nend\nputs\
    \ \"Expected: [2, 1] -- Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1] --\
    \ Actual: #{pluck([1,2,3])}\"\nputs \"Expected: [] -- Actual: #{pluck([])}\"\n\
    puts \"Expected: [0, 1] -- Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"", "  arr.delete_if\
    \ { |x| x.odd? }.min\nend", "    arr.each_with_index do |value, index|\n     \
    \   if value % 2 == 0\n            return [value, index]\n        end\n    end\n\
    \    return []\nend\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([1,2,3]) == [2,\
    \ 1]\nputs pluck([]) == []\nputs pluck([5, 0, 3, 0, 4, 2]) == [0, 1]\nputs pluck([1,3,5,7,9])\
    \ == []\nputs pluck([2,4,6,8,10]) == [2, 0]\nputs pluck([4,4,4,4,4]) == [4, 0]\n\
    puts pluck([0,0,0,0,0]) == [0, 0]\nputs pluck([2,2,2,2,2]) == [2, 0]\nputs pluck([7,3,3,3,7])\
    \ == []\nputs pluck([8,6,4,6,8]) == [4, 2]\nputs pluck([2,1,1,1,2]) == [2, 0]\n\
    puts pluck([2,2,2,2,1]) == [2, 0]\nputs pluck([2,2,2,2,3]) == [2, 0]\nputs pluck([3,3,3,3,3])\
    \ == []\nputs pluck([9,1,1,1,9]) == []\nputs pluck([4,4,4,4,1]) == [4, 0]\nputs\
    \ pluck([4,4,4,4,3]) == [4, 0]\nputs pluck([4,4,4,4,5]) == [4, 0]\nputs pluck([5,5,5,5,5])\
    \ == []\nputs pluck([3,3,3,3,1]) == []\nputs pluck([3,3,3,3,2]) == []\nputs pluck([3,3,3,3,4])\
    \ == []\nputs pluck([2,2,2,2,", "    return [] if arr.size==0\n    sm_even = nil\n\
    \    sm_even_idx = nil\n    arr.each_with_index do |e, i|\n        if sm_even==nil\
    \ && e%2==0\n            sm_even = e\n            sm_even_idx = i\n        elsif\
    \ sm_even!=nil && e%2==0 && e<sm_even\n            sm_even = e\n            sm_even_idx\
    \ = i\n        end\n    end\n    return [] if sm_even==nil\n    [sm_even, sm_even_idx]\n\
    end", "  return [] if arr.empty?\n  evens = arr.map.with_index{|v, i| [v, i] if\
    \ v.even?}.compact\n  return [] if evens.empty?\n  evens.sort_by{|v, i| [v, i]}.first\n\
    end", "  evens = arr.select(&:even?)\n  return [] if evens.empty?\n  return [evens.min,\
    \ arr.index(evens.min)]\nend", "  return [] if arr.empty?\n  evens = arr.select(&:even?)\n\
    \  return [] if evens.empty?\n  res = evens.each_with_index.inject { |acc, val|\
    \ val[0] < acc[0] ? val : acc }\n  [res[0], arr.index(res[0])]\nend", "  return\
    \ [] if arr.empty?\n  res = [0, -1]\n  arr.each_with_index { |x, idx|\n    if\
    \ x % 2 == 0 && res[0] == 0\n      res = [x, idx]\n    elsif x % 2 == 0 && x <\
    \ res[0]\n      res = [x, idx]\n    end\n  }\n  return [] if res[0] == 0\n  res\n\
    end", "  evens = arr.select { |x| x.even? }\n  idx = arr.find_index(evens.min)\n\
    \  idx.nil? ? [] : [evens.min, idx]\nend", "  return [] if arr.empty?\n  arr.each_with_index.min_by{|x,\
    \ idx| x.even? ? x : Float::INFINITY}.with_index(1)\nend", "  min = nil\n  idx\
    \ = nil\n  arr.each_with_index do |val, i|\n    if val.even? && (min.nil? || val\
    \ < min)\n      min = val\n      idx = i\n    end\n  end\n  return [min, idx]\
    \ if idx\n  []\nend", "  even_numbers = arr.select { |n| n.even? }\n  min_even\
    \ = even_numbers.min\n  min_even ? [min_even, arr.index(min_even)] : []\nend",
  "  return [] if arr.empty?\n  evens = arr.each_with_index.select { |val, _| val.even?\
    \ }\n  return [] if evens.empty?\n  evens.min_by { |val, i| [val, i] }.to_a\n\
    end\nputs '###### pluck ######'\nputs pluck([4,2,3]) == [2, 1]\nputs pluck([1,2,3])\
    \ == [2, 1]\nputs pluck([]) == []\nputs pluck([5, 0, 3, 0, 4, 2]) == [0, 1]",
  "\t# Returns the smallest even value and its index from arr, or [] if there is no\
    \ such value.\n\tif arr.length == 0\n\t\treturn []\n\tend\n\tmin = nil\n\tmin_index\
    \ = nil\n\tarr.each_with_index do |value, index|\n\t\tif min == nil and value\
    \ % 2 == 0\n\t\t\tmin = value\n\t\t\tmin_index = index\n\t\tend\n\t\tif value\
    \ % 2 == 0 and value < min\n\t\t\tmin = value\n\t\t\tmin_index = index\n\t\tend\n\
    \tend\n\tif min == nil\n\t\treturn []\n\tend\n\treturn [min, min_index]\nend",
  "  evens = arr.select { |i| i % 2 == 0 }\n  return [] if evens.empty?\n  [evens.min,\
    \ arr.index(evens.min)]\nend", "  res = []\n  return res if arr.nil? or arr.empty?\n\
    \  min_ev = 2**32 - 1\n  n = arr.size\n  (0...n).each { |i|\n    if arr[i] % 2\
    \ == 0 and arr[i] < min_ev\n      min_ev = arr[i]\n      res = [min_ev, i]\n \
    \   end\n  }\n  res\nend", "  evens = arr.select(&:even?)\n  return [] if evens.empty?\n\
    \  [evens.min, arr.index(evens.min)]\nend", "  # your code here\nend", "  min_index\
    \ = nil\n  min_value = nil\n  arr.each_with_index do |node, index|\n    if node.even?\n\
    \      if min_value.nil? || node < min_value\n        min_value = node\n     \
    \   min_index = index\n      end\n    end\n  end\n  return [] if min_value.nil?\n\
    \  [min_value, min_index]\nend", "  # write your code here\n  return [] if arr.empty?\n\
    \  evens = arr.select{|x| x.even?}\n  return [] if evens.empty?\n  min = evens.min\n\
    \  return [min, arr.index(min)]\nend", "  return [] if arr.empty?\n  arr.each_with_index\
    \ { |e, i|\n    if e % 2 == 0\n      return [e, i]\n    end\n  }\n  []\nend",
  "  smallest_even = nil\n  smallest_even_index = nil\n  arr.each_with_index do |n,\
    \ i|\n    if n.even?\n      if smallest_even.nil?\n        smallest_even = n\n\
    \        smallest_even_index = i\n      elsif n < smallest_even\n        smallest_even\
    \ = n\n        smallest_even_index = i\n      end\n    end\n  end\n  return [smallest_even,\
    \ smallest_even_index]\nend", "    return [] if arr.empty?\n    evens = arr.select\
    \ { |val| val.even? }\n    return [] if evens.empty?\n    min_val = evens.min\n\
    \    idx = arr.index(min_val)\n    [min_val, idx]\nend", "  return [] if arr.empty?\n\
    \  # find even numbers\n  # sort by value\n  # sort by index\n  evens = arr.select\
    \ { |e| e.even? }\n  return [] if evens.empty?\n  evens.sort.sort_by.with_index\
    \ { |_, i| i }.first\nend", "  return [] if arr.empty?\n  evens = arr.select(&:even?)\n\
    \  evens.empty? ? [] : [evens.min, arr.index(evens.min)]\nend", "  # your code\
    \ here\nend", "  min_value = arr.select { |e| e.even? }.min\n  min_index = arr.index(min_value)\n\
    \  return [min_value, min_index]\nend", "  min_even_node = arr.each_with_index.min\
    \ { |(a, _), (b, _)| a.even? && b.even? ? a <=> b : a.even? ? -1 : 1 }\n  min_even_node\
    \ ? [min_even_node[0], min_even_node[1]] : []\nend", "  index = 0\n  min = nil\n\
    \  min_index = 0\n  last_index = arr.length-1\n  while index <= last_index\n \
    \   if arr[index] % 2 == 0\n      if min.nil? || arr[index] < min\n        min\
    \ = arr[index]\n        min_index = index\n      end\n    end\n    index += 1\n\
    \  end\n  min.nil? ? [] : [min, min_index]\nend", "  evens = arr.select { |a|\
    \ a.even? }\n  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\n\
    end", "    min_even_value = 2**32-1\n    min_even_index = 0\n    arr.each_with_index\
    \ do |value,index|\n        if value % 2 == 0 && value < min_even_value\n    \
    \        min_even_value = value\n            min_even_index = index\n        end\n\
    \    end\n    if min_even_value == 2**32-1\n        return []\n    else\n    \
    \    return [min_even_value, min_even_index]\n    end\nend\nputs \"Expected: [2,\
    \ 1]\"\nputs \"Output: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1]\"\nputs \"\
    Output: #{pluck([1,2,3])}\"\nputs \"Expected: []\"\nputs \"Output: #{pluck([])}\"\
    \nputs \"Expected: [0, 1]\"\nputs \"Output: #{pluck([5, 0, 3, 0, 4, 2])}\"", " \
    \   return [] if arr.empty?\n    evens = arr.select { |n| n.even? }\n    smallest\
    \ = evens.sort[0]\n    return [] if smallest.nil?\n    idx = arr.index(smallest)\n\
    \    return [smallest, idx]\nend", "  return [] if arr.empty?\n  evens = arr.select(&:even?)\n\
    \  return [] if evens.empty?\n  [evens.min, arr.index(evens.min)]\nend\nputs \"\
    Expected: [2, 1], Actual: #{pluck([4,2,3])}\"\nputs \"Expected: [2, 1], Actual:\
    \ #{pluck([1,2,3])}\"\nputs \"Expected: [], Actual: #{pluck([])}\"\nputs \"Expected:\
    \ [0, 1], Actual: #{pluck([5, 0, 3, 0, 4, 2])}\"", "  i = 0\n  min_val = 10_000\n\
    \  min_i = 10_000\n  while i < arr.length\n    if arr[i] % 2 == 0\n      if arr[i]\
    \ < min_val\n        min_val = arr[i]\n        min_i = i\n      end\n    end\n\
    \    i += 1\n  end\n  if min_val == 10_000\n    return []\n  else\n    return\
    \ [min_val, min_i]\n  end\nend", "    return [] if arr.empty?\n    even_numbers\
    \ = arr.select { |e| e.even? }\n    return [] if even_numbers.empty?\n    even_numbers.sort!\n\
    \    target = even_numbers[0]\n    target_index = arr.index(target)\n    [target,\
    \ target_index]\nend", "  arr.each_with_index do |val, index|\n    return [val,\
    \ index] if val.even?\n  end\n  []\nend", "  return [] if arr.empty?\n  evens\
    \ = arr.each_with_index.select { |x,_| x.even? }\n  evens.empty? ? [] : evens.min_by\
    \ { |x,_| x }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
