name: HumanEval_101_words_string
language: rb
prompt: "# You will be given a string of words separated by commas or spaces. Your\
  \ task is\n# to split the string into words and return an array of the words.\n\
  # For example:\n# words_string(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\"\
  , \"is\", \"John\"]\n# words_string(\"One, two, three, four, five, six\") == [\"\
  One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\ndef words_string(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_words_string\n\
  \    candidate = method(:words_string)\n    assert_equal([\"Hi\", \"my\", \"name\"\
  , \"is\", \"John\"], candidate.call(\"Hi, my name is John\"))\n    assert_equal([\"\
  One\", \"two\", \"three\", \"four\", \"five\", \"six\"], candidate.call(\"One, two,\
  \ three, four, five, six\"))\n    assert_equal([\"Hi\", \"my\", \"name\"], candidate.call(\"\
  Hi, my name\"))\n    assert_equal([\"One\", \"two\", \"three\", \"four\", \"five\"\
  , \"six\"], candidate.call(\"One,, two, three, four, five, six,\"))\n    assert_equal([],\
  \ candidate.call(\"\"))\n    assert_equal([\"ahmed\", \"gamal\"], candidate.call(\"\
  ahmed     , gamal\"))\n  end\nend\n"
completions: ["  s.split(/[, ]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[, ]/)\nend", "  s.split(/[ ,]+/)\n\
    end", "  return s.split(/\\s+|,\\s*/)\nend", "  s.split(\" \")\nend", "  s.split(/[,\
    \ ]+/)\nend", "  s.split\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s|,]/)\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  array = s.split(/[\\\
    s,]+/)\n  puts array\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(\" \")\nend",
  "  s.split(/[,\\s]/).reject(&:empty?)\nend", "  #your code here\n  s.split\nend",
  "    s.split\nend", "  if s.length != 0\n    return s.split\n  else\n    return\
    \ []\n  end\nend", "  s.split(/, | /)\nend", "  s.split(/,\\s?|\\s/)\nend", " \
    \ s.split(/[ ,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(\", \")\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(' ')\n\
    end", "  return s.split(/[,\\s]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\\
    s,]+/)\nend", "  s.split(/[, ]/)\nend", "  s.split(\", \")\nend", "  s.split('\
    \ ')\nend", "  s.split(' ')\nend", "  s.split(/[,\\s]/)\nend", "  s.split\nend",
  "  s.split(/[,\\s]/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[, ]+/)\nend", "  s.split(/[\\\
    s,]+/)\nend", "  # Your code here\nend", "  s.split\nend", "  s.split(/[\\s,]+/)\n\
    end", "  return s.split(/[\\s,]+/)\nend", "  # return s.split(/[\\s,]+/)\n  return\
    \ s.split(/[ ,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(\", \")\nend", "\ts.split(/[,\\s]/)\nend", "  return s.split(',').map{|w|\
    \ w.strip}\nend", "  words = []\n  s.split.each do |word|\n    words << word.delete(',')\n\
    \  end\n  words\nend", "  s.split(\",\").map(&:strip)\nend", "  return s.split(/,\\\
    s|\\s/)\nend", "  s.split(\",\").map{|x| x.strip}\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(' ')\nend", "  s.split(/[ ,]+/)\nend", "  return s.split(/[\\\
    s,]+/)\nend", "  s.split(\" \")\nend", "  s.split(/,? /)\nend", "    return s.split\n\
    end", "  s.split(/,\\s|,|\\s/)\nend", "  s.split(/[ ,]+/)\nend", "    s.split(/\\\
    W/)\nend", "  s.split(/[, ]/)\nend", "  s.split(\", \")\nend", "  #returns array\
    \ of words in a string\n  s.split\nend", "    return s.split(/[\\s,]+/)\nend",
  "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\\
    s,]+/)\nend", "  s.split(/[, ]/)\nend", "  s.scan(/\\w+/)\nend", "\t\nend", " \
    \ s.split(/[ ,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(/[,\\s]/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[,\\\
    s]/)\nend", "  s.split(/[, ]/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(\"\
    \ \")\nend", "  s.split(/[\\s,]+/)\nend", "  s.split\nend", "  s.split(/[, ]/)\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\
    \ ,]+/)\nend", "  s.split(/,\\s*/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split\n\
    end", "  s.split(/[ ,]+/)\nend", "  s.split(' ')\nend", "  s.split(\" \")\nend",
  "    s.split(/,| /)\nend", "  return s.split(/\\W+/)\nend", "  s.split\nend", "\t\
    words = s.split\n\twords = words.map { |word| word.chomp(',') }\n\treturn words\n\
    end", "  a = s.split(\",\")\n  a = a.join(\",\").split(\" \")\n  return a\nend",
  "  # string.split(pattern=nil, [limit]) \u2192 anArray\n  # If pattern is a String,\
    \ then its contents are used as the delimiter when splitting str.\n  # If pattern\
    \ is a single space, str is split on whitespace, with leading whitespace and runs\
    \ of contiguous whitespace characters ignored.\n  # If pattern is a Regexp, str\
    \ is divided where the pattern matches. Whenever the pattern matches a zero-length\
    \ string, str is split into individual characters.\n  # If pattern contains groups,\
    \ the respective matches will be returned in the array as well.\n  # If pattern\
    \ is omitted, the value of $; is used.  If $; is nil (which is the default), str\
    \ is split on whitespace as if ` ' were specified.\n  # If limit is given, the\
    \ array will be limited to limit elements, with the final element being the entire\
    \ rest of the string.\n  # If limit is omitted, trailing null fields are suppressed.\
    \ If limit is zero, trailing null fields are not suppressed.\n  s.split(/[,\\\
    s]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  #Write\
    \ your code here\n  s.split(/[\\s,]+/)\nend", "  s.split(\" \")\nend", "  s.split(/[,\\\
    s]/)\nend", "  s.split(/[,\\s]/)\nend", "  s.split(/[, ]+/)\nend", "  s.split(\"\
    ,\")\nend", "    s.split(/\\W+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split\n\
    end", "  # puts s.split(\",\").join('').split\n  puts s.split(/[\\s,]+/)\nend\n\
    words_string(\"Hi, my name is John\")\nwords_string(\"One, two, three, four, five,\
    \ six\")", "  s.split(' ')\nend", "  s.split(/[,\\s]/)\nend", "  s.split\nend",
  "  # TODO: implement method\n  s.split(/[,\\s]/)\nend", "  s.split(\",\").map(&:strip)\n\
    end", "  s.split(' ')\nend", "  s.split(/[,\\s]/)\nend", "  s.split(/[ ,]+/)\n\
    end", "  s.split\nend", "  s.scan(/\\w+/)\nend", "  s.split\nend", "    s.scan(/\\\
    w+/)\nend", "  s.split(/,\\s|,\\s|\\s/)\nend", "  s.split(/[\\s,]+/)\nend", " \
    \ s.split(/[, ]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/,\\s|\\s/)\n\
    end", "  s.split(/[, ]+/)\nend", "  s.split(',').join('').split(' ')\nend", " \
    \ s.split\nend", "  s.split(/[\\s,]+/)\nend", "  words = s.split(/[\\s,]+/)\n\
    \  words\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[,\\\
    s]/)\nend", "  s.split\nend", "  s.split(' ')\nend", "  return s.split(/[\\s,]+/)\n\
    end", "  s.split(/[ ,]+/)\nend", "  s.split(/,?\\s/)\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(/[ ,]+/)\nend", "  s.split(/[ ,]+/)\nend", "  s.split(/, | /)\n\
    end", "  s.split(/[,\\s]/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[,\
    \ ]+/)\nend", "  # Your code here\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[,\\\
    s]/)\nend", "  s.split(/[, ]/)\nend", "  s.split\nend", "  s.split(/[\\s,]+/)\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[ ,]+/)\nend", "  s.split(/[\\\
    s,]+/)\nend", "  s.split(/[, ]+/)\nend", "  s.split\nend", "  s.split(/[ ,]+/)\n\
    end", "  return s.split(\" \")\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\\
    s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  # Code goes here\nend", "  s.split(/[\\\
    s,]+/)\nend", "  s.split(\" \")\nend", "  s.split(/[\\s,]+/)\nend", "  s.split\n\
    end", "  s.split(/[, ]+/)\nend", "  return s.split(/\\s|,/)\nend", "  s.split\n\
    end", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.scan(/\\\
    w+/)\nend", "    return s.split\nend", "    s.split(/[,\\s]/)\nend", "  s.split(/[\
    \ ,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split(/[\\\
    s,]+/)\nend", "  s.split(/[,\\s]/).reject { |e| e.empty? }\nend", "  s.split(/[,\
    \ ]/)\nend", "  s.split(/[\\s,]+/)\nend", "  #s.split(/[ ,]+/)\n  s.split(/\\\
    s*[, ]\\s*/)\nend", "  s.split(/[\\s,]+/)\nend", "  s.split\nend", "    s.split(/\\\
    s*(,\\s*|\\s+)+/)\nend", "  s.split(/[\\s,]+/)\nend", "  # code goes here\n  s.split(\"\
    \ \")\nend", "  s.split(\",\")\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
