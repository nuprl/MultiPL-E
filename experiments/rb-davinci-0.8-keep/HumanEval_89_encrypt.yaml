name: HumanEval_89_encrypt
language: rb
prompt: "# Create a function encrypt that takes a string as an argument and\n# returns\
  \ a string encrypted with the alphabet being rotated. \n# The alphabet should be\
  \ rotated in a manner such that the letters \n# shift down by two multiplied to\
  \ two places.\n# For example:\n# encrypt('hi') returns 'lm'\n# encrypt('asdfghjkl')\
  \ returns 'ewhjklnop'\n# encrypt('gf') returns 'kj'\n# encrypt('et') returns 'ix'\n\
  def encrypt(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_encrypt\n\
  \    candidate = method(:encrypt)\n    assert_equal(\"lm\", candidate.call(\"hi\"\
  ))\n    assert_equal(\"ewhjklnop\", candidate.call(\"asdfghjkl\"))\n    assert_equal(\"\
  kj\", candidate.call(\"gf\"))\n    assert_equal(\"ix\", candidate.call(\"et\"))\n\
  \    assert_equal(\"jeiajeaijeiak\", candidate.call(\"faewfawefaewg\"))\n    assert_equal(\"\
  lippsqcjvmirh\", candidate.call(\"hellomyfriend\"))\n    assert_equal(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
  , candidate.call(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"))\n    assert_equal(\"\
  e\", candidate.call(\"a\"))\n  end\nend\n"
completions: ["  # create an array of letters for each word and index\n  # each letter,\
    \ and the index where it is located at\n  # and use those indexes to access the\
    \ new rotated alphabet.\n  alphabet = ('a'..'z').to_a\n  new_s = ''\n  s.split('').each\
    \ do |letter|\n    new_s << alphabet[letter.ord - 97 + 2*2]\n  end\n  new_s\n\
    end", "\tl = s.length\n\ts1 = \"\"\n\ts.each_char do |c|\n\t\t#puts c\n\t\t#puts\
    \ c.ord - 97\n\t\tc1 = (c.ord - 97 + 2) % 26 + 97\n\t\t#puts c1\n\t\tc2 = c1.chr\n\
    \t\t#puts c2\n\t\ts1 << c2\n\tend\n\treturn s1\nend", "   a = s.split('')\n  \
    \ ans = []\n   a.each do |i|\n   \tif i == ' '\n   \t\tans.push(' ')\n   \telse\n\
    \      \tval = i.ord + 2*2\n      \tif val > 'z'.ord\n      \t\tval = (val % 'z'.ord)\
    \ + 'a'.ord - 1\n      \tend\n      \tans.push(val.chr)\n  \tend\n   end\n   ans.join('')\n\
    end", "    letters = ('a'..'z').to_a\n    letters_reversed = letters.reverse\n\
    \    letters_rotated = letters_reversed.rotate(2*2)\n    encrypt_word = s.split('').map\
    \ do |letter|\n        if letters.include?(letter)\n            (letters_rotated[letters.index(letter)])\n\
    \        else\n            letter\n        end\n    end\n    encrypt_word.join('')\n\
    end", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    rot = 2*2\n    e = ''\n\
    \    s.each_char do |c|\n        idx = alphabet.index(c)\n        e += alphabet[(idx+rot)%26]\n\
    \    end\n    e\nend", "  alphabet = Array('a'..'z')\n  encrypter = Hash[alphabet.zip(alphabet.rotate(2*2))]\n\
    \  s.chars.map { |c| encrypter.fetch(c, \" \") }\nend", "  n = 2 * 2\n  ascii_num\
    \ = (s.ord + n).chr\n  return ascii_num\nend", "  alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  result = \"\"\n  s.split(\"\").each do |letter|\n    if alpha.index(letter)\
    \ + 3 > 25\n      result += alpha[alpha.index(letter) + 3 - 26]\n    else\n  \
    \    result += alpha[alpha.index(letter) + 3]\n    end\n  end\n  result\nend",
  "  if s.length > 1\n    s.gsub!(/h/, 'j')\n    s.gsub!(/i/, 'k')\n    s.gsub!(/j/,\
    \ 'l')\n    s.gsub!(/k/, 'm')\n    s.gsub!(/l/, 'n')\n    s.gsub!(/m/, 'o')\n\
    \    s.gsub!(/n/, 'p')\n    s.gsub!(/o/, 'q')\n    s.gsub!(/p/, 'r')\n    s.gsub!(/q/,\
    \ 's')\n    s.gsub!(/r/, 't')\n    s.gsub!(/s/, 'u')\n    s.gsub!(/t/, 'v')\n\
    \    s.gsub!(/u/, 'w')\n    s.gsub!(/v/, 'x')\n    s.gsub!(/w/, 'y')\n    s.gsub!(/x/,\
    \ 'z')\n    s.gsub!(/y/, 'a')\n    s.gsub!(/z/, 'b')\n    s.gsub!(/a/, 'c')\n\
    \    s.gsub!(/b/, 'd')\n    s.gsub!(/c/, 'e')\n    s.gsub!(/d/, 'f')\n    s.gsub!(/e/,\
    \ 'g')\n    s.gsub!(/f/, 'h')\n  else\n    s.gsub!(/e/, 'g')\n    s.gsub!(/f/,\
    \ 'h')\n    s.gsub!(/g/, 'j')\n    s.gsub!(/h/, 'k')\n    s.gsub!(/i/, 'l')\n\
    \    s.gsub!(/j/, 'm')\n    s.gsub!(/k/, 'n')\n    s.gsub!(/l/, 'o')\n    s.gsub!(/m/,\
    \ 'p')\n    s.gsub!(/n/, 'q')\n    s.gsub!(/o/,", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    encrypted_string = \"\"\n    s.each_char do |c|\n        i = alphabet.index(c)\
    \ + 2\n        i -= 26 if i > 25\n        encrypted_string += alphabet[i]\n  \
    \  end\n    encrypted_string\nend", "  \nend", "    a = \"\"\n    s.each_char\
    \ do |c|\n        ord = c.ord\n        if ord >= \"a\".ord && ord <= \"y\".ord\n\
    \            a << (ord + 2).chr\n        elsif ord == \"z\".ord\n            a\
    \ << \"b\"\n        elsif ord == \"y\".ord\n            a << \"a\"\n        else\n\
    \            a << c\n        end\n    end\n    return a\nend", "  start = \"a\"\
    \n  finish = \"z\"\n  alpha = start.upto(finish).to_a\n  newS = s.chars.map {\
    \ |letter| alpha[(alpha.index(letter.downcase) + 2*2) % 26]}\n  newS.join\nend",
  end, "  answer = \"\"\n  s.each_char do |char|\n    if char == \"y\"\n      answer\
    \ += \"a\"\n    elsif char == \"z\"\n      answer += \"b\"\n    else\n      answer\
    \ += (char.ord + 2).chr\n    end\n  end\n  answer\nend", "\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tencrypt_alphabet = \"cdefghijklmnopqrstuvwxyzab\"\n\tnew_string = \"\"\n\t\
    letter_array = s.split(\"\")\n\tletter_array.each do |letter|\n\t\tif alphabet.include?(letter)\n\
    \t\t\tnew_string << encrypt_alphabet[alphabet.index(letter)]\n\t\telse\n\t\t\t\
    new_string << letter\n\t\tend\n\tend\n\treturn new_string\nend", "  if s.length\
    \ == 1\n    str = s.bytes[0]\n    str += 2\n    str *= 2\n    str -= 26\n    return\
    \ str.chr\n  end\n  str = s.bytes[0]\n  str += 2\n  str *= 2\n  str -= 26\n  word\
    \ = str.chr\n  word << encrypt(s[1..-1])\nend", "  alphabet = ('a'..'z').to_a\n\
    \  temp = []\n  s.each_char do |c|\n    temp << alphabet[(alphabet.index(c.downcase)\
    \ + 2) % 26]\n  end\n  temp.join\nend", "  s.each_char.reduce(\"\") do |res, char|\n\
    \    res << (char.ord + 2*2).chr\n  end\nend", "\tindex1 = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tindex2 = index1.chars.rotate(2).join\n\tindex1.chars.each_with_index.map {|ch,\
    \ i| ch == s[i] ? index2[i] : ch}.join\nend", "  alpha = ('a'..'z').to_a\n  encrypt_array\
    \ = []\n  s.each_char do |char|\n    encrypt_array << alpha[alpha.index(char)\
    \ + 2 * 2]\n  end\n  encrypt_array.join('')\nend", "  alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \  index = 0\n  new_word = \"\"\n  s.each_char do |char|\n    # get the index\
    \ of the character in the alphabet\n    index = alphabet.index(char)\n    # add\
    \ two to the index\n    index += 2\n    # get the encrypted character at the new\
    \ index and add it to the new word\n    new_word += alphabet[index]\n  end\n \
    \ return new_word\nend", "\t# create a new_string array to store new letters\n\
    \tnew_string = []\n\t# iterate through each character in the string\n\ts.each_char\
    \ do |character|\n\t\t# Add a new character to the new_string array\n\t\t# by\
    \ reassigning to lowercase and then adding to\n\t\t# the string array\n\t\tnew_string\
    \ << (character.downcase.ord + 2).chr\n\tend\n\t# Return the array of new characters\
    \ as a string joined\n\t# together\n\tnew_string.join\nend", "  alpha = (\"a\"\
    ..\"z\").to_a\n  s.split(\"\").map { |l| alpha[alpha.index(l) + 2 * 2] }.join(\"\
    \")\nend", "  letters = ('a'..'z').to_a\n  en = letters.rotate(2 * 2)\n  letters.zip(en).to_h\n\
    \  s.tr(letters.join, en.join)\nend", "  s.split('').map do |c|\n    # The alphabet\
    \ is assumed to be ASCII. So we map from the\n    # ASCII character to the alphabet\
    \ and then to the next two\n    # alphabets.\n    ((c.ord + 2) % 'z'.ord).chr\n\
    \  end.join('')\nend", "  down2 = ('a'..'z').to_a.rotate(2)\n  #p down2\n  alphabet\
    \ = ('a'..'z').to_a\n  array = s.split('')\n  array.map! do |char|\n    index\
    \ = alphabet.index(char)\n    down2[index]\n  end\n  array.join('')\nend", " \
    \   alpha = \"abcdefghijklmnopqrstuvwxyz\"\n    str = \"\"\n    s.each_char do\
    \ |c|\n        if c == \" \"\n            str += \" \"\n        else\n       \
    \     str += alpha[(alpha.index(c) + 5) % 26]\n        end\n    end\n    return\
    \ str\nend", "    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    # initialize an\
    \ empty string\n    new_word = ''\n    # split string\n    str = s.split('')\n\
    \    # iterate through the array\n    str.each do |i|\n        # find the letter\
    \ in the alphabet\n        index = alphabet.index(i)\n        # shift the index\
    \ by two\n        # add two to the index\n        new_index = index + 2\n    \
    \    # add the shifted letter to the empty string\n        new_word += alphabet[new_index]\n\
    \    end\n    # return string\n    return new_word\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  # s.each_char { |c| alphabet.index(c) - 2 * 2 }\n  s.each_char { |c| puts\
    \ c }\nend", "  # need alphabet array\n  # need to rotate alphabet by two\n  #\
    \ need to iterate through array, pushing to new array as we go along\n  # need\
    \ to return new array\n  alphabet = ('a'..'z').to_a\n  new_alphabet = alphabet.rotate(2)\n\
    \  letters = s.split('')\n  encrypted_letters = []\n  i = 0\n  while i < letters.length\n\
    \    j = 0\n    while j < alphabet.length\n      if letters[i] == alphabet[j]\n\
    \        encrypted_letters << new_alphabet[j]\n      end\n      j += 1\n    end\n\
    \    i += 1\n  end\n  encrypted_letters.join('')\nend", "  # code your solution\
    \ here\nend", "  alphabet = ('a'..'z').to_a\n  encrypted = ''\n  s.each_char do\
    \ |x|\n    idx = alphabet.index(x)\n    encrypted << alphabet[idx - 2]\n  end\n\
    \  encrypted\nend", "\t# You can use the .chars method to create an array of chars\
    \ from\n\t# a string. For example:\n\t# 'hello'.chars => ['h', 'e', 'l', 'l',\
    \ 'o']\n\t# Convert your string to an array of chars here, then convert\n\t# them\
    \ back to a string after you have shifted them down two spots\n\t# in the alphabet.\n\
    \ts.chars.map{|letter| (letter.ord + 2).chr}.join\nend", "  alphabet = ('a'..'z').to_a\n\
    \  rotated_string = \"\"\n  string_array = s.split(\"\")\n  string_array.each\
    \ do |ch|\n    index = alphabet.index(ch)\n    rotated_string += alphabet[index\
    \ + 3]\n  end\n  rotated_string\nend", "\t # takes the string and rotates it by\
    \ the value of the string length\n\t # multipled by two\n\t s.downcase.chars.map\
    \ do |c|\n\t \t(c.ord + (s.length * 2)).chr\n\t end.join\nend", "\tword = s.split(\"\
    \")\n\tencrypt_word = word.map do |l|\n\t\tn = l.ord\n\t\tif (n >= 97 && n <=\
    \ 122) || (n >= 65 && n <= 90)\n\t\t\t(((n - 65) + 1) % 26 + 65).chr\n\t\telse\n\
    \t\t\tn.chr\n\t\tend\n\tend\n\tencrypt_word.join(\"\")\nend", "\tc = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\te = c.slice(2, 26) + c.slice(0, 2)\n\ts.tr(c, e)\nend", "  alphabet = ('a'..'z').to_a\n\
    \  new_s = ''\n  s.each_char do |c|\n    index = alphabet.index(c)\n    new_index\
    \ = index + 2\n    new_s += alphabet[new_index]\n  end\n  new_s\nend", "\talphabet\
    \ = ('a'..'z').to_a\n\talphabet_new = alphabet.rotate(3)\n\tnew_string = \"\"\n\
    \t\n\ts.each_char do |c|\n\t\tindex = alphabet.index(c)\n\t\tnew_string << alphabet_new[index]\n\
    \tend\n\treturn new_string\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  encr_arr = []\n  s.each_char do |char|\n    num = alphabet.index(char) + 2\n\
    \    encr_arr << alphabet[num]\n  end\n  encr_arr.join\nend", "\ts.each_char do\
    \ |char|\n\t\tif (char.ord + 2) > 122\n\t\t\tchar = ((char.ord + 2) - 26).chr\n\
    \t\telse\n\t\t\tchar = (char.ord + 2).chr\n\t\tend\n\tend\nend", "  \nend", "\t\
    n = s.length\n\ta = 0\n\ts.each_char do |c|\n\t\ts[a] = (s[a].ord + 2*2).chr\n\
    \t\ta += 1\n\tend\n\treturn s\nend", "\ts.chars.map { |c|\n\t\tc.ord + 2 * 2 >\
    \ 'z'.ord ? (c.ord + 2 * 2 - 26).chr : (c.ord + 2 * 2).chr\n\t}.join\nend", " \
    \ i = 0\n  while i < s.length\n    if s[i] != \" \"\n      if s[i] == \"z\" ||\
    \ s[i] == \"y\"\n        s[i] = (s[i].ord - 24).chr\n      else\n        s[i]\
    \ = (s[i].ord + 2).chr\n      end\n    end\n    i += 1\n  end\n  s\nend", "  \
    \  alph = 'abcdefghijklmnopqrstuvwxyz'\n    counter = 0\n    s.each_char do |x|\n\
    \        if (alph.index(x) + 2) > 25\n            counter = (alph.index(x) + 2)\
    \ - 26\n        else\n            counter = alph.index(x) + 2\n        end\n \
    \       print alph[counter]\n    end\nend", "\tchars = ('a'..'z').to_a\n\ts.chars.map\
    \ do |x|\n\t\tpos = chars.index(x)\n\t\tif pos.nil?\n\t\t\tx\n\t\telse\n\t\t\t\
    chars[(pos + 2) % 26]\n\t\tend\n\tend.join\nend", "\t#locate the alphabet\n\t\
    #put it in some kind of structure so it is accessible\n\t#iterate through each\
    \ letter\n\t#find the index of the letter\n\t#add two\n\t#find the letter at the\
    \ new index\n\t#put that letter in a new string\n\t#return the new string\n\t\
    encrypted_string = ''\n\tletters = ('a'..'z').to_a\n\ts.each_char do |letter|\n\
    \t\tnew_index = letters.index(letter) + 2\n\t\tencrypted_string << letters[new_index]\n\
    \tend\n\treturn encrypted_string\nend", "  @index = s.length\n  @index.times do\n\
    \    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord\
    \ + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n   \
    \ s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord\
    \ + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n   \
    \ s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord\
    \ + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n   \
    \ s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord\
    \ + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n   \
    \ s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord\
    \ + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n   \
    \ s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0].ord + 2).chr\n    s[0] = (s[0",
  "\t# Create a new string for the new characters to be added to\n\tstr = \"\"\n\t\
    # Split the string into an array\n\ts = s.split(\"\")\n\t# For each character\
    \ in the array\n\ts.each do |char|\n\t\t# Find the index of the character in the\
    \ alphabet\n\t\tindex = alphabet.index(char)\n\t\t# If the index is less than\
    \ 24\n\t\tif index < 24\n\t\t\t# Add the new character to the string as the index\
    \ + 3 character\n\t\t\tstr += alphabet[index + 3]\n\t\t# If the index is greater\
    \ than 24\n\t\telsif index > 24\n\t\t\t# Add the new character to the string as\
    \ the index - 23 character\n\t\t\tstr += alphabet[index - 23]\n\t\tend\n\tend\n\
    \t# Return the new string\n\treturn str\nend", "    alph=['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']\n\
    \    str=''\n    s.each_char do |x|\n        index=alph.index(x)\n        str+=alph[index+2]\n\
    \    end\n    return str\nend", "  alphabet = ('a'..'z').to_a", "\t# We've given\
    \ you a little bit of starter code. \n\t# This code creates an array called alphabet\
    \ that has the letters a-z.\n\talphabet = (\"a\"..\"z\").to_a", "\t# Go through\
    \ each letter and change it to the letter two places down,\n\t# and if the letter\
    \ is a g or later, rotate to the front of the alphabet\n\twords = s.split(\"\"\
    )\n\tencrypted = []\n\twords.each do |letter|\n\t\tif letter =~ /[h-z]/\n\t\t\t\
    encrypted << (letter.ord + 2).chr\n\t\telsif letter =~ /[a-f]/\n\t\t\tencrypted\
    \ << (letter.ord + 2 - 26).chr\n\t\tend\n\tend\n\tencrypted.join\nend", "\ts_len\
    \ = s.length\n\tvowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n\ti = 0\n\tnew_string\
    \ = \"\"\n\twhile i < s_len do\n\t\tif s[i] == \"z\"\n\t\t\tnew_string << \"b\"\
    \n\t\telsif s[i] == \"y\"\n\t\t\tnew_string << \"a\"\n\t\telsif vowels.include?(s[i])\n\
    \t\t\tnew_string << s[i]\n\t\telse\n\t\t\tnew_string << s[i].next\n\t\tend\n\t\
    \ti += 1\n\tend\n\tnew_string\nend", "  # find the length of the string\n  # multiple\
    \ the length by 2\n  # use that number as the key in the cypher array\n  # loop\
    \ through the string\n  #   get the index of the string\n  #   add the key to\
    \ the index\n  #   return the letter at the index + key\n  # end loop\n  key =\
    \ s.length * 2\n  encrypted_string = ''\n  s.each_char do |c|\n    string_index\
    \ = ALPHABET.index(c)\n    encrypted_string << CYPHER[string_index + key]\n  end\n\
    \  encrypted_string\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  result\
    \ = \"\"\n  s.each_char do |char|\n    current_index = alphabet.index(char)\n\
    \    result += alphabet[(current_index + 2) % 26]\n  end\n  result\nend", "  \n\
    \  #create an array of characters in the alphabet\n  alpha = (\"a\"..\"z\").to_a",
  "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  s.split(\"\").map{|x| alphabet[(alphabet.index(x)\
    \ + 2 * 2) % 26]}.join(\"\")\nend", "\tlowercase = ('a'..'z').to_a\n\tuppercase\
    \ = ('A'..'Z').to_a\n\tarr = s.split('')\n\tarr.map! do |letter|\n\t\tif lowercase.include?(letter)\n\
    \t\t\ttemp = lowercase.index(letter) + 2\n\t\t\ttemp = temp % 26\n\t\t\tlowercase[temp]\n\
    \t\telsif uppercase.include?(letter)\n\t\t\ttemp = uppercase.index(letter) + 2\n\
    \t\t\ttemp = temp % 26\n\t\t\tuppercase[temp]\n\t\telse\n\t\t\tletter\n\t\tend\n\
    \tend\n\tarr.join('')\nend", "  # take string and make it an array\n  # then map\
    \ each char in the array\n  # if the char is a letter, return the encrypted char\n\
    \  # elsif the char is not a letter, return the char \n  s.split('').map do |char|\n\
    \    if char.match(/[a-z]/i)\n      ascii_num = char.ord\n      new_ascii_num\
    \ = ascii_num + 2 * 2\n      if new_ascii_num > 122\n        new_ascii_num = 97\
    \ + (new_ascii_num - 122 - 1)\n      end\n      new_ascii_num.chr\n    else\n\
    \      char\n    end\n  end.join\nend", "  alphabet = ('a'..'z').to_a\n  str =\
    \ ''\n  (0...s.length).each do |i|\n    idx = alphabet.index(s[i])\n    str +=\
    \ alphabet[(idx + (i+1)*2) % 26]\n  end\n  str\nend", "\talpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tresult = \"\"\n\ts.each_char do |char|\n\t\tresult += alpha[(alpha.index(char)\
    \ + 2*2) % 26]\n\tend\n\treturn result\nend", "\ts.tr('a-z','c-za-b')\nend", " \
    \ e = \"\"\n  for i in 0..s.length-1\n    e = e + rotated_char(s[i])\n  end\n\
    \  return e\nend", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    encrypted_str\
    \ = \"\"\n    s.each_char do |x|\n        if (x == ' ')\n            encrypted_str\
    \ += ' '\n        else\n            old_idx = alphabet.index(x)\n            new_idx\
    \ = old_idx + 2 * 2\n            if new_idx > 25\n                new_idx = new_idx\
    \ - 26\n            end\n            encrypted_str += alphabet[new_idx]\n    \
    \    end\n    end\n    return encrypted_str\nend", "  ascii = s.ord\n  if ascii\
    \ > 97 && ascii < 122\n    ascii = ascii + 2\n    s = ascii.chr\n  elsif ascii\
    \ == 122\n    s = 'b'\n  elsif ascii == 123\n    s = 'c'\n  end\n  return s\n\
    end", "\tencrypt_s = \"\"\n\tfor i in 0..s.length-1\n\t\tif (s[i].ord + 2*2) >\
    \ 122\n\t\t\tdiff = (s[i].ord + 2*2) - 122\n\t\t\tencrypt_s += (96 + diff).chr\n\
    \t\telse\n\t\t\tencrypt_s += (s[i].ord + 2*2).chr\n\t\tend\n\tend\n\tencrypt_s\n\
    end", "\ttemp = s.split('')\n\tencrypted = \"\"\n\ttemp.each do |letter|\n\t\t\
    if letter == \" \"\n\t\t\tencrypted << \" \"\n\t\telsif letter == \"z\"\n\t\t\t\
    encrypted << \"b\"\n\t\telsif letter == \"y\"\n\t\t\tencrypted << \"a\"\n\t\t\
    else\n\t\t\tencrypted << letter.next\n\t\tend\n\tend\n\treturn encrypted\nend",
  "  arr = ('a'..'z').to_a\n  s.each_char.map do |char|\n    num = arr.index(char)\n\
    \    arr[(num + 2) % 26]\n  end.join\nend", "\tfirst_half = \"\"\n\tsecond_half\
    \ = \"\"\n\tnew_string = \"\"\n\tfor x in 0..s.length-1\n\t\tif s[x].ord >= 65\
    \ && s[x].ord <= 89\n\t\t\tfirst_half += s[x].ord+2\n\t\telsif s[x].ord >= 97\
    \ && s[x].ord <= 121\n\t\t\tsecond_half += s[x].ord+2\n\t\tend\n\tend\n\tfirst_half.each_char\
    \ do |c|\n\t\tnew_string += c.chr\n\tend\n\tsecond_half.each_char do |c|\n\t\t\
    new_string += c.chr\n\tend\n\treturn new_string\nend\nputs encrypt('hi')\nputs\
    \ encrypt('asdfghjkl')\nputs encrypt('gf')\nputs encrypt('et')", "\treturn s.chars.map{|c|\
    \ (c.ord + 6).chr}.join\nend", "  abc = \"abcdefghijklmnopqrstuvwxyz\"\n  encrypted\
    \ = \"\"\n  s.each_char do |c|\n    encrypted += abc[(abc.index(c) + 2) * 2]\n\
    \  end\n  encrypted\nend", "  return nil if s.nil?\n  # returns a string\n  alphabet\
    \ = (\"a\"..\"z\").to_a\n  # ^ returns an array\n  encrypted_str = \"\"\n  # empty\
    \ string\n  s.each_char do |char|\n    char_idx = alphabet.index(char)\n    #\
    \ find the index of that character\n    encrypted_str += alphabet[(char_idx +\
    \ 2) % 26]\n    # add the index to 2 so that it's the alphabet\n    # the letter\
    \ 2 spots over to the right\n    # add it to the encrypted string\n  end\n  encrypted_str\n\
    end", "  a=s.split('')\n  alpha=('a'..'z').to_a\n  new_alpha=alpha.rotate(4)\n\
    \  new_string=''\n  a.each do |i|\n    p=alpha.index(i)\n    new_string=new_string+new_alpha[p]\n\
    \  end\n  return new_string\nend", "   #Write your code here\nend", "    alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n    newString = \"\"\n    for i in 0..s.length\
    \ - 1\n        for j in 0..alphabet.length - 1\n            if s[i] == alphabet[j]\n\
    \                newString += alphabet[(j + 1) % 26]\n            end\n      \
    \  end\n    end\n    return newString\nend", "  arr = ('a'..'z').to_a\n  arr2\
    \ = ('a'..'z').to_a\n  arr2.each do |x|\n    if x == 'z' || x == 'y'\n      arr.insert(0,\
    \ arr2.pop)\n    else\n      arr.insert(0, arr2.pop)\n      arr.insert(0, arr2.pop)\n\
    \    end\n  end\n  string = s.split('')\n  string.each_with_index do |x, i|\n\
    \    if x == ' '\n      string[i] = ' '\n    else\n      string[i] = arr[arr2.index(x)]\n\
    \    end\n  end\n  string.join\nend", "  original_alphabet = ('a'..'z').to_a.join\n\
    \  letters = ('a'..'z').to_a\n  encrypted_alphabet = letters.rotate(s.length *\
    \ 2).join\n  s.tr(original_alphabet, encrypted_alphabet)\nend\nputs encrypt('gf')",
  "\treturn s.tr(\"a-z\",\"c-za-b\")\nend\nputs encrypt('hi')\nputs encrypt('asdfghjkl')\n\
    puts encrypt('gf')\nputs encrypt('et')", "\tencrypt = \"\"\n\ts.each_char do |i|\n\
    \t\tascii = i.ord\n\t\tencrypt += ((ascii-97+4)%26+97).chr\n\tend\n\tencrypt\n\
    end", "\ti = 0\n\tnewString = \"\"\n\twhile i < s.length\n\t\tif (s[i].ord + 2*2)\
    \ > 122\n\t\t\tnewString = newString + (s[i].ord + 2*2 - 26).chr\n\t\telse\n\t\
    \t\tnewString = newString + (s[i].ord + 2*2).chr\n\t\tend\n\t\ti = i + 1\n\tend\n\
    \treturn newString\nend", "  alphabet = ('a'..'z').to_a\n  encrypted = \"\"\n\
    \  s.each_char do |c|\n    encrypted << alphabet[alphabet.index(c) + (alphabet.index(c)\
    \ * 2)]\n  end\n  encrypted\nend", "\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n\tindex = 0\n\tword = \"\"\n\twhile index < s.length\n\t\tword += alphabet[alphabet.index(s[index])\
    \ + 2]\n\t\tindex += 1\n\tend\n\treturn word\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  encrypted = \"\"\n  s.each_char do |char|\n    position = alphabet.index(char)\n\
    \    new_position = position + (2 * 2)\n    encrypted << alphabet[new_position]\n\
    \  end\n  encrypted\nend", "  alphabet = ('a'..'z').to_a\n  encode_chars = Hash[*alphabet.zip(alphabet.rotate(2)).flatten]\n\
    \  s.each_char.inject(\"\") { |a, c| a << encode_chars[c] }\nend", "    # create\
    \ an alphabet array\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    # empty\
    \ array to store the encrypted letters\n    encrypted_letters = []\n    # iterate\
    \ through the string given to the function\n    s.each_char do |char|\n      \
    \  # find the index of each character in the string\n        index = alphabet.index(char)\n\
    \        # add two multiplied by two to the index \n        # then use the modulus\
    \ to rotate the alphabet \n        # since the alphabet is 26 characters long\n\
    \        encrypted_letters << alphabet[(index + 4) % 26]\n    end\n    # return\
    \ the encrypted string\n    return encrypted_letters.join\nend", "  alpha = (\"\
    a\"..\"z\").to_a\n  e_alpha = alpha.rotate(2 * -2)\n  arr = s.split(\"\")\n  e_arr\
    \ = []\n  for i in 0..arr.length - 1\n    idx = alpha.index(arr[i])\n    e_arr\
    \ << e_alpha[idx]\n  end\n  return e_arr.join(\"\")\nend", "\tfor i in 0..s.length-1\n\
    \t\tif s[i] == ' '\n\t\t\ts[i] = ' '\n\t\telsif s[i] == 'z'\n\t\t\ts[i] = 'a'\n\
    \t\telsif s[i] == 'y'\n\t\t\ts[i] = 'z'\n\t\telse\n\t\t\ts[i] = s[i].next.next\n\
    \t\tend\n\tend\n\treturn s\nend", "\ti = 0\n\twhile i < s.length\n\t\tif s[i]\
    \ == \"a\" || s[i] == \"b\"\n\t\t\ts[i] = s[i].next.next\n\t\telse\n\t\t\ts[i]\
    \ = s[i].next\n\t\tend\n\t\ti += 1\n\tend\n\ts\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  letters = s.split(\"\")\n  encrypted = []\n  letters.each do |x|\n    i =\
    \ alphabet.index(x)\n    encrypted << alphabet[i-2]\n  end\n  return encrypted.join(\"\
    \")\nend", "\ti = 0\n\twhile i < s.length\n\t\t\n\t\t#This converts the letters\
    \ to their ASCII values.\n\t\ts[i] = s[i].ord\n\t\t\n\t\t#This checks if the letters\
    \ are upper or lower case.\n\t\t#If they are, it changes the ASCII values by the\
    \ appropriate\n\t\t#shift value.\n\t\tif (s[i] >= 65 and s[i] <= 90) or (s[i]\
    \ >= 97 and s[i] <= 122)\n\t\t\ts[i] += 2 * 2\n\t\tend\n\t\t\n\t\t#This catches\
    \ the instances where the ASCII value has become\n\t\t# greater than Z or z. It\
    \ then changes the ASCII value to the\n\t\t# appropriate ASCII value based on\
    \ the case.\n\t\tif s[i] > 90 and s[i] < 97\n\t\t\ts[i] = 64 + (s[i] - 90)\n\t\
    \telsif s[i] > 122\n\t\t\ts[i] = 96 + (s[i] - 122)\n\t\tend\n\t\t\n\t\t#This converts\
    \ the ASCII values back to the letters.\n\t\ts[i] = s[i].chr\n\t\ti += 1\n\tend\n\
    \treturn s\nend", "\ti = 0\n\tstr = ''\n\twhile i < s.length\n\t\tif (s[i].ord\
    \ >= 97 && s[i].ord <= 101) || (s[i].ord >= 104 && s[i].ord <= 109)\n\t\t\t# str\
    \ << s[i].next\n\t\t\t# str << s[i].next.next\n\t\t\tstr << (s[i].ord + 4).chr\n\
    \t\telsif (s[i].ord >= 110 && s[i].ord <= 122) || (s[i].ord >= 102 && s[i].ord\
    \ <= 103)\n\t\t\t# str << s[i].next.next\n\t\t\t# str << s[i].next.next.next\n\
    \t\t\tstr << (s[i].ord + 4).chr\n\t\telsif s[i].ord == 101\n\t\t\tstr << 'g'\n\
    \t\telsif s[i].ord == 102\n\t\t\tstr << 'h'\n\t\telsif s[i].ord == 103\n\t\t\t\
    str << 'i'\n\t\tend\n\t\ti += 1\n\tend\n\treturn str\nend\nputs encrypt('gf')\n\
    puts encrypt('et')\nputs encrypt('z')\nputs encrypt('aa')\nputs encrypt('bb')\n\
    puts encrypt('cd')\nputs encrypt('dh')\nputs encrypt('sd')\nputs encrypt('k')\n\
    puts encrypt('asdfghjkl')", "    output = ''\n    for i in 0..s.length-1\n   \
    \     output += s[i].ord + 2 * 2\n    end\n    return output\nend", "  # code\
    \ goes here\n  len = s.length\n  i = 0\n  code = \"\"\n  while i < len\n     \
    \ if (s[i].ord >= \"a\".ord && s[i].ord <= \"w\".ord)\n          code += (s[i].ord\
    \ + 2).chr\n      elsif (s[i].ord == \"x\".ord)\n          code += \"a\"\n   \
    \   elsif (s[i].ord == \"y\".ord)\n          code += \"b\"\n      elsif (s[i].ord\
    \ == \"z\".ord)\n          code += \"c\"\n      else\n          code += s[i]\n\
    \      end\n      i += 1\n  end\n  return code\nend", "\t# split string into array\
    \ of characters\n\tstring = s.split('')\n\t# set key to 2\n\tkey = 2\n\t# rotate\
    \ the alphabet\n\talphabet = ('a'..'z').to_a.rotate(key)\n\t# create a hash with\
    \ the alphabet as the key and the encrypted alphabet as the value\n\tencryption\
    \ = Hash[alphabet.zip(('a'..'z').to_a)]\n\tencrypted_word = \"\"\n\t# iterate\
    \ through the array of characters\n\tstring.each do |char|\n\t\t# check if the\
    \ character is a letter\n\t\tif /[a-zA-Z]/.match(char)\n\t\t\t# add the encrypted\
    \ letter to the encrypted_word string\n\t\t\tencrypted_word << encryption[char]\n\
    \t\t# if the character is not a letter\n\t\telse\n\t\t\t# add the character to\
    \ the encrypted_word string\n\t\t\tencrypted_word << char\n\t\tend\n\tend\n\t\
    return encrypted_word\nend", "    d = s.split(\"\")\n    a = []\n    b = []\n\
    \    c = []\n    z = \"abcdefghijklmnopqrstuvwxyz\"\n    x = z.split(\"\")\n \
    \   d.each do |i|\n        y = x.index(i)\n        a.push(y)\n    end\n    a.each\
    \ do |i|\n        j = i+2\n        if i+2 > 25\n            j = i+2-26\n     \
    \   end\n        b.push(j)\n    end\n    b.each do |i|\n        k = x[i]\n   \
    \     c.push(k)\n    end\n    c.join(\"\")\nend", "\t\n\t# converts each character\
    \ to its ascii value\n\t# The .to_i method converts the character to an integer.\n\
    \t# The .chr method converts the integer to its character value.\n\tencrypted\
    \ = s.split(\"\").map { |i| i.ord.to_i.chr }", "  # create an alphabet string\n\
    \  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n  # split the string into an array\n\
    \  string_array = s.split(\"\")\n  # create a new string\n  new_string = \"\"\n\
    \  # iterate through the string array\n  string_array.each do |letter|\n    #\
    \ get the index of each letter in the alphabet string\n    index = alphabet.index(letter)\n\
    \    # get the new index, by taking the index, moving it down the alphabet by\
    \ 2, \n    # and then multiply by 2\n    new_index = index + 2 * 2\n    # put\
    \ the letter at the new index into the new string\n    new_string += alphabet[new_index]\n\
    \  end\n  # return the new string\n  return new_string\nend", "\nend", "\talphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n\talphabet_encrypted = \"cdefghijklmnopqrstuvwxyzab\"\
    \n\tindex = 0\n\tencrypted_string = \"\"\n\tstring_length = s.length\n\twhile\
    \ index < string_length\n\t\tletter = s[index]\n\t\tletter_index = alphabet.index(letter)\n\
    \t\tencrypted_letter = alphabet_encrypted[letter_index]\n\t\tencrypted_string\
    \ += encrypted_letter\n\t\tindex += 1\n\tend\n\treturn encrypted_string\nend",
  "\t\n\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\tnumbers = \"0123456789\"\n\t\
    shift_alpha = alphabet[2..-1] + alphabet[0..1]\n\tshift_num = numbers[2..-1] +\
    \ numbers[0..1]\n\t\n\ts = s.downcase.split(\"\")\n\ts.each_with_index do |letter,\
    \ index|\n\t\tif letter.match(/[a-z]/)\n\t\t\ts[index] = shift_alpha[alphabet.index(letter)]\n\
    \t\telsif letter.match(/[0-9]/)\n\t\t\ts[index] = shift_num[numbers.index(letter)]\n\
    \t\tend\n\tend\n\ts.join\nend", "\nend", "  # Code Goes Here\nend", "  # TODO:\
    \ complete this function\n  alph = ('a'..'z').to_a\n  new_alph = ('a'..'z').to_a.rotate(2*2)\n\
    \  s.split('').map{|c| c==' ' ? ' ' : alph.index(c)}.map{|i| new_alph[i]}.join\n\
    end", "  alphabet = ('a'..'z').to_a\n  encrypted = []\n  s.each_char do |char|\n\
    \    p char\n    new_char = alphabet[alphabet.index(char)+4]\n    encrypted <<\
    \ new_char\n  end\n  encrypted.join\nend", "  # Write your code here\nend", "\t\
    \ \n\talphabet = (\"a\"..\"z\").to_a\n\tencrypted = \"\"\n\ts.split(\"\").each\
    \ do |x|\n\t\tidx = alphabet.index(x) + 2\n\t\tidx = idx - 26 if idx > 25\n\t\t\
    idx = idx - 26 if idx > 25\n\t\tencrypted += alphabet[idx]\n\tend\n\tencrypted\n\
    end", "\t$alpha = ('a'..'z').to_a\n\t$alpha2 = ('a'..'z').to_a.push(('a'..'z').to_a)\n\
    \t$alpha2.flatten!\n\t$alpha3 = ('a'..'z').to_a.unshift(('a'..'z').to_a)\n\t$alpha3.flatten!\n\
    \ts.split('').map {|x| \n\t\t$alpha2.index(x) - $alpha.index(x) == 1 ? $alpha2[$alpha2.index(x)\
    \ + 1] : $alpha2[$alpha2.index(x) + 2] \n\t\t}.join('')\nend", "  \ts = s.split('')\n\
    \ts = s.map {|x| x.ord + 2*2}\n\ts = s.map {|x| x.chr}\n\ts = s.join('')\n\treturn\
    \ s\nend", "    s.tr(\"a-y\", \"c-a\")\nend", "  alphabet = ('a'..'z').to_a\n\
    \  un_encrypt = s.split('')\n  encrypted = []\n  un_encrypt.each do |v|\n    next\
    \ if v == ' '\n    index = alphabet.index(v)\n    new_index = index + 4\n    new_index\
    \ -= 26 if new_index > 25\n    encrypted << alphabet[new_index]\n  end\n  encrypted.join('')\n\
    end", "  # s = s.split('')\n  # s.map! do |letter|\n  #   encrypted_index = s.index(letter)\
    \ + 2 * 2\n  #   if encrypted_index < 26\n  #     letter = encrypted_index.chr\n\
    \  #   else\n  #     encrypted_index = encrypted_index - 26\n  #     letter =\
    \ encrypted_index.chr\n  #   end\n  # end\n  # s.join\n  alphabet = (\"a\"..\"\
    z\").to_a\n  encrypted_msg = \"\"\n  s.each_char do |char|\n    old_idx = alphabet.find_index(char)\n\
    \    new_idx = old_idx + 2 * 2\n    if new_idx < 26\n      encrypted_msg += alphabet[new_idx]\n\
    \    else\n      new_idx = new_idx - 26\n      encrypted_msg += alphabet[new_idx]\n\
    \    end\n  end\n  encrypted_msg\nend", "\talphabet = ('a'..'z').to_a\n\talphabet_e\
    \ = alphabet.rotate(4)\n\talphabet_e_h = Hash[alphabet.zip(alphabet_e)]\n\t\n\t\
    array = s.split('')\n\tarray.each_with_index do |a, i|\n\t\tarray[i] = alphabet_e_h[a]\n\
    \tend\n\treturn array.join('')\nend", "    alphabet = ('a'..'z').to_a\n    answer\
    \ = ''\n    s.each_char do |char|\n        if alphabet.include?(char)\n      \
    \      old_index = alphabet.index(char)\n            new_index = old_index + 2\
    \ * 2\n            answer += alphabet[new_index]\n        else\n            answer\
    \ += char\n        end\n    end\n    answer\nend", end, end, "  al = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  al = al.split('')\n  new = ''\n  s.split('').each do |i|\n    new = new + al[al.index(i)\
    \ + 2*2]\n  end\n  return new\nend", "  s.split('').map{|x| x.ord}.map{|x| x +=\
    \ 4; x -= 26 if x > 122; x.chr}.join\nend", "  alphabet = ('a'..'z').to_a\n  code\
    \ = alphabet.rotate(2)\n  new_array = []\n  s.each_char do |letter|\n    i = alphabet.index(letter)\n\
    \    new_array << code[i]\n  end\n  new_array.join\nend", "\ts.tr('a-z', 'c-za-b')\n\
    end", "\talphabet = ('a'..'z').to_a\n\ts.chars.map { |c| alphabet[(alphabet.index(c)\
    \ * 2 - 2) % 26] }.join\nend", end, "  letters = ('a'..'z').to_a\n  encrypted\
    \ = []\n  s.each_char do |char|\n    index = letters.index(char)\n    encrypted\
    \ << letters[index + 2]\n  end\n  encrypted.join\nend", "    alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n    res = \"\"\n    s.split(\"\").each do |char|\n        if alpha.index(char)\
    \ >= 23\n            res += alpha[(alpha.index(char) + 2) - 26]\n        else\n\
    \            res += alpha[alpha.index(char) + 2]\n        end\n    end\n    return\
    \ res\nend", "\t#first, how do we get the alphabets?\n\t#we are going to convert\
    \ the string into an array of characters\n\t#characters = s.split('')\n\tencrypt_array\
    \ = []\n\tstring_array = s.split('')\n\tstring_array.each do |char|\n\t\tfirst_location\
    \ = char.ord\n\t\tencrypted_location = first_location + (2 * 2)\n\t\tencrypted_char\
    \ = encrypted_location.chr\n\t\tencrypt_array << encrypted_char\n\tend\n\tencrypted_string\
    \ = encrypt_array.join('')\n\tputs encrypted_string\nend", "\nend", "  idx = 0\n\
    \  result = \"\"\n  s.each_char do |char|\n    if s[idx].ord >= 97 && s[idx].ord\
    \ <= 100\n      result += s[idx].ord + 23\n    elsif s[idx].ord >= 101 && s[idx].ord\
    \ <= 122\n      result += s[idx].ord - 3\n    end\n    idx += 1\n  end\n  result\n\
    end", "\tencrypt_array = []\n\ts.split(\"\").each do |i|\n\t\ti.ord + 2 == 123\
    \ ? encrypt_array << (i.ord + 2 - 26).chr : encrypt_array << (i.ord + 2).chr\n\
    \tend\n\tencrypt_array.join(\"\")\nend", "\ts.tr('a-z', 'c-za-b')\nend", "  s.tr(\"\
    a-z\", \"c-za-b\")\nend", "  return s.split('').map { |c| (c.ord + 2 * 2).chr\
    \ }.join('')\nend", "    # Your code here\nend", "  # split the string into individual\
    \ characters\n  # use an array to put the index of each character into a variable\n\
    \  # for each character, add an offset\n  # return the new string\n  string =\
    \ s.split('')\n  index = []\n  string.each do |i|\n    index << i.ord\n  end\n\
    \  offset = index.map { |i| i + (2 * 2) }\n  new_string = offset.map { |i| i.chr\
    \ }\n  new_string.join\nend", "  alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n \
    \ i = 0\n  while i < s.length\n    j = 0\n    while j < alphabet.length\n    \
    \  if s[i] == alphabet[j]\n        s[i] = alphabet[j + 2]\n        break\n   \
    \   end\n      j += 1\n    end\n    i += 1\n  end\n  return s\nend\nputs encrypt('asdfghjkl')",
  "  # Add your code here\n  n = s.length\n  str = \"\"\n  n.times do |i|\n    str\
    \ << s[i].ord + 2 * 2\n  end\n  return str\nend", "  letters = s.split('')\n \
    \ letters.map! do |letter|\n    letter = letter.ord\n    if letter < 97\n    \
    \  letter += 65\n    else\n      letter += 97\n    end\n    letter += 2\n    letter\
    \ = ((letter - 2) % 26) + 2\n    if letter < 97\n      letter -= 65\n    else\n\
    \      letter -= 97\n    end\n    letter.chr\n  end\n  letters.join('')\nend",
  "  alpha = \"abcdefghijklmnopqrstuvwxyz\"\n  s_alpha = \"\"\n  s.split(\"\").each\
    \ do |let|\n    if let.ord > 104\n      let = alpha[let.ord - 20]\n    elsif let.ord\
    \ > 97\n      let = alpha[let.ord - 22]\n    else\n      let = alpha[let.ord -\
    \ 4]\n    end\n    s_alpha += let\n  end\n  s_alpha\nend", "\ti = 0\n\twhile i\
    \ < s.length\n\t\tif s[i] == \"z\"\n\t\t\ts[i] = \"b\"\n\t\telsif s[i] == \"y\"\
    \n\t\t\ts[i] = \"a\"\n\t\telsif s[i] == \" \"\n\t\t\ts[i] = \" \"\n\t\telse\n\t\
    \t\ts[i] = s[i].next.next\n\t\tend\n\t\ti += 1\n\tend\n\ts\nend", "\treturn encrypt_helper(s,\
    \ 2)\nend", "  encrypted = ''\n  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  s.each_char\
    \ do |char|\n    encrypted += alphabet[(alphabet.index(char) + 2) * 2]\n  end\n\
    \  encrypted\nend", "\tdef encrypt_letter(l)\n\t\tif l >= \"a\" && l <= \"z\"\n\
    \t\t\tif l >= \"y\"\n\t\t\t\treturn (l.ord - 24).chr\n\t\t\telsif l >= \"w\"\n\
    \t\t\t\treturn (l.ord - 22).chr\n\t\t\telse\n\t\t\t\treturn (l.ord + 4).chr\n\t\
    \t\tend\n\t\telse\n\t\t\treturn l\n\t\tend\n\tend\n\treturn s.split(\"\").map\
    \ { |l| encrypt_letter(l) }.join(\"\")\nend", "\nend", "  l = []\n  s.chars.each\
    \ do |char|\n    l << char.ord + 2 * 2\n  end\n  l.map { |e| e.chr }.join(\"\"\
    )\nend\nputs encrypt('hi')\nputs encrypt('asdfghjkl')\nputs encrypt('gf')\nputs\
    \ encrypt('et')", "    # Write your code here\nend", "  vowels = \"aeiou\"\n \
    \ newString = \"\"\n  s.each_char do |char|\n    if vowels.include?(char)\n  \
    \    newString += char\n    else\n      newString += (char.ord + 2).chr\n    end\n\
    \  end\n  newString\nend", "  #You will use the .ord and .chr methods to achieve\
    \ this.\n  #puts s.ord('a') # This will return 97\n  #puts 'a'.ord # This will\
    \ also return 97\n  #puts 97.chr # This will return a\n  #puts (99).chr # This\
    \ will return c\n  \nend", "  s.downcase.bytes.map{|c| c < 110 ? c+2 : c-24}.map(&:chr).join\n\
    end\nputs encrypt('hi')", "\tindex = 0\n\twhile index < s.length\n\t\tif s[index]\
    \ == \"z\"\n\t\t\ts[index] = \"b\"\n\t\telsif s[index] == \"y\"\n\t\t\ts[index]\
    \ = \"a\"\n\t\telse\n\t\t\ts[index] = s[index].next.next\n\t\tend\n\t\tindex +=\
    \ 1\n\tend\n\ts\nend", "  # Make sure to return something\n  return s\nend", " \
    \   s.tr(\"a-z\",\"c-za-b\")\nend\nputs \"*\"*15\nputs \"Test for encrypt method\"\
    \nputs encrypt(\"hi\") == \"lm\"\nputs encrypt(\"asdfghjkl\") == \"ewhjklnop\"\
    \nputs encrypt(\"gf\") == \"kj\"\nputs encrypt(\"et\") == \"ix\"", "    # create\
    \ an array of letters that are going to be encrypted\n    new_arr = s.split(\"\
    \")\n    new_arr.map! do |x|\n        x.ord\n    end\n    # multiply each letter\
    \ by 2 and add 2\n    new_arr.map! do |x|\n        x * 2 + 2\n    end\n    # take\
    \ the new letters and shift them down the alphabet\n    new_arr.map! do |x|\n\
    \        if x > 122\n            x = x - 24\n        end\n        x\n    end\n\
    \    # convert each letter back to a string\n    new_arr.map! do |x|\n       \
    \ x.chr\n    end\n    # join the array back together into a single string\n  \
    \  new_string = new_arr.join(\"\")\n    return new_string\nend", "\talpha = ('a'..'z').to_a\n\
    \tnew_letters = []\n\ts.each_char do |letter|\n\t\tnew_letters << alpha[alpha.index(letter)\
    \ + 2]\n\tend\n\tnew_letters.join('')\nend", "  alphabet = [\"a\", \"b\", \"c\"\
    , \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"\
    , \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\"\
    , \"z\"]\n  new_string = \"\"\n  s.each_char do |char|\n    idx = alphabet.index(char)\n\
    \    new_char = alphabet[idx + 2 * 2]\n    new_string << new_char\n  end\n  new_string\n\
    end", "  # code goes here\n  alph = ('a'..'z').to_a\n  k = s.split('')\n  encrypted\
    \ = []\n  k.each do |i|\n    val = alph.index(i)\n    encrypted << alph[val+4]\n\
    \  end\n  encrypted.join\nend", "  # your code here\nend", "\t# Your code here\n\
    \tlist1 = ('a'..'z').to_a # array of each letter in the alphabet\n\tlist2 = list1.rotate(2)\
    \ # array of alphabet shifted down by 2\n\tlist3 = ('A'..'Z').to_a # array of\
    \ each letter in the alphabet capitalized\n\tlist4 = list3.rotate(2) # array of\
    \ alphabet capitalized shifted down by 2\n\t\n\t# split input string into an array\n\
    \tstring = s.split('')\n\t\n\t# iterate over the input string array and replace\
    \ each letter with a new letter.\n\tstring.map! do |i|\n\t\tif i =~ /[[:alpha:]]/\
    \ # if the element is a letter\n\t\t\tif i =~ /[[:lower:]]/ # if the element is\
    \ a lowercase letter\n\t\t\t\t# match the letter to its corresponding letter in\
    \ the rotated alphabet and replace it\n\t\t\t\tlist1.index(i)\n\t\t\t\tlist2[list1.index(i)]\n\
    \t\t\telse # if the element is an uppercase letter\n\t\t\t\t# match the letter\
    \ to its corresponding letter in the rotated alphabet and replace it\n\t\t\t\t\
    list3.index(i)\n\t\t\t\tlist4[list3.index(i)]\n\t\t\tend\n\t\telse # if the element\
    \ is a non-letter character\n\t\t\ti # keep the element the same\n\t\tend\n\t\
    end\n\t\n\t# join the array back together into a string and return the string\n\
    \treturn string.join\nend", "\talphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\tindex\
    \ = 0\n\tencrypted_string = ''\n\twhile index < s.length\n\t\tcurrent_letter =\
    \ s[index]\n\t\tif current_letter == \" \"\n\t\t\tencrypted_string << \" \"\n\t\
    \t\tindex += 1\n\t\t\tnext\n\t\tend\n\t\talphabet_index = alphabet.index(current_letter)\n\
    \t\tnew_alphabet_index = alphabet_index + 2\n\t\tencrypted_string << alphabet[new_alphabet_index]\n\
    \t\tindex += 1\n\tend\n\tencrypted_string\nend", "  alpha = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  str = \"\"\n  i = 0\n  while i < s.length\n    index = alpha.index(s[i])\n\
    \    new_index = (index + 2) * 2 % 26\n    str += alpha[new_index]\n    i += 1\n\
    \  end\n  return str\nend", "\t# convert the string to an array\n\tarray = s.split('')\n\
    \t\n\t# create a new array to store the new values\n\tnew_array = []\n\t# iterate\
    \ through the string\n\tarray.each do |i|\n\t\t# create a variable to find the\
    \ new ascii value\n\t\tnew_ascii = i.ord - 2 * 2\n\t\t# if the ascii value is\
    \ less than 97\n\t\tif new_ascii < 97\n\t\t\t# add 26 to bring the number back\
    \ in order\n\t\t\tnew_ascii += 26\n\t\tend\n\t\t# push the new character into\
    \ the new array\n\t\tnew_array.push(new_ascii.chr)\n\tend\n\t# put the new array\
    \ back into a string and return it\n\tnew_array.join('')\nend", "    alphabet\
    \ = (\"a\"..\"z\").to_a\n    res = \"\"\n    s.each_char do |char|\n        res\
    \ += alphabet[(alphabet.index(char) + (alphabet.index(char) * 2)) % 26]\n    end\n\
    \    res\nend", "  alpha = ('a'..'z').to_a\n  encrypted = ''\n  (0...s.length).each\
    \ do |i|\n    encrypted << alpha[((alpha.index(s[i]))+2) % 26]\n  end\n  encrypted\n\
    end", "\talphabet = 'abcdefghijklmnopqrstuvwxyz'\n\twords = s.split(' ')\n\tencrypt\
    \ = \"\"\n\twords.each do |word|\n\t\tencrypt = encrypt + alphabet[alphabet.index(word[0])\
    \ + 2] + alphabet[alphabet.index(word[1]) + 2] + \" \"\n\tend\n\tencrypt.strip\n\
    end", "  \n  letters = ('a'..'z').to_a\n  result = []\n  new_index = 0\n  \n \
    \ s.split('').each do |letter|\n    # convert letter to lowercase\n    letter\
    \ = letter.downcase\n    # find the index in the array of letter\n    current_index\
    \ = letters.index(letter)\n    # rotate the letter\n    new_index = current_index\
    \ + (2 * 2)\n    # make sure it doesn't go beyond z\n    new_index = new_index\
    \ % 26\n    # add rotated letter to result\n    result << letters[new_index]\n\
    \  end\n  \n  result.join('')\nend", "  # your code here\nend", "  s.tr 'a-zA-Z',\
    \ 'c-za-bC-ZA-B'\nend", "\t# code here\nend", "  @alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n  @encrypted_s = \"\"\n  for i in 0..s.length - 1\n    @encrypted_s << @alphabet[(@alphabet.index(s[i])\
    \ + 4) % 26]\n  end\n  return @encrypted_s\nend", "  # Create a variable alphabet\
    \ containing an array of the alphabet\n  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n\
    \  # Create a variable split_alphabet containing an array\n  # that splits alphabet\
    \ into two sections:\n  # The first section contains the first ten letters of\
    \ the alphabet\n  # The second section contains the last sixteen letters of the\
    \ alphabet\n  split_alphabet = [alphabet[0..9], alphabet[10..25]]\n  # Create\
    \ a variable that generates an array of the two letters that\n  # result from\
    \ rotating the alphabet by two places\n  shift_letters = split_alphabet[1][0..1]\n\
    \  # Create a variable shift_alphabet containing the result of\n  # creating the\
    \ alphabet by adding the original alphabet with\n  # the shifted alphabet\n  shift_alphabet\
    \ = split_alphabet[0] + split_alphabet[1] + shift_letters\n  # Create a variable\
    \ alphabet_hash containing a hash\n  # where the alphabet's characters are keys\n\
    \  # and the alphabet's shifted characters are values\n  alphabet_hash = Hash[alphabet.chars.zip(shift_alphabet.chars)]\n\
    \  # Create a variable string_array containing an array\n  # where s is split\
    \ into each of its characters\n  string_array = s.split('')\n  # Create a variable\
    \ new_array that maps over each character in string_array\n  # based on its key\
    \ and value pairs in alphabet_hash\n  new_array = string_array.map { |letter|\
    \ alphabet_hash[letter] }\n  # Create a variable result that joins new_array into\
    \ a string\n  result = new_array.join\n  # Create a variable alphabet_rev_hash\
    \ containing a hash\n  # where the alphabet's shifted characters are keys\n  #\
    \ and the alphabet's characters are values\n  alphabet_rev_hash = Hash[shift_alphabet.chars.zip(alphabet.chars)]\n\
    \  # Create a variable reversed_array containing an array\n  # where result is\
    \ split into each of its characters\n  reversed_array = result.split('')\n  #\
    \ Create a variable reversed_new_array that maps over\n  # each character in reversed_array\
    \ based on its key and value pairs\n  # in alphabet_rev_", "\t\nend", "  alphabet\
    \ = (\"a\"..\"z\").to_a\n  encrypted = []\n  s.each_char do |char|\n    current_index\
    \ = alphabet.index(char)\n    if char == 'z'\n      encrypted << alphabet[current_index\
    \ - 25]\n    elsif char == 'y'\n      encrypted << alphabet[current_index - 24]\n\
    \    else\n      encrypted << alphabet[current_index + 2]\n    end\n  end\n  encrypted.join\n\
    end", "  # Your code here\n  # array = s.split('')\n  # array.each do |letter|\n\
    \  #   letter.next\n  # end\n  # array.join('')\nend", "\t(0..s.length-1).each\
    \ do |n|\n\t\tif s[n]==\"z\"\n\t\t\ts[n]=\"b\"\n\t\telsif s[n]==\"y\"\n\t\t\t\
    s[n]=\"a\"\n\t\telsif s[n]==\"x\"\n\t\t\ts[n]=\"z\"\n\t\telse\n\t\t\ts[n]=s[n].next.next\n\
    \t\tend\n\tend\n\ts\nend", "    alphabet = (\"a\"..\"z\").to_a\n    encrypted\
    \ = \"\"\n    for i in 0..s.length-1\n        new_index = (alphabet.index(s[i])\
    \ + 2 * 2) % 26\n        encrypted += alphabet[new_index]\n    end\n    return\
    \ encrypted\nend", "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    encrypted\
    \ = \"\"\n    s.each_char do |letter|\n        index = alphabet.index(letter)\n\
    \        encrypted += alphabet[index+2]\n    end\n    return encrypted\nend",
  "\t# the array is the alphabet. 'a' returns the number zero and is\n\t# hence the\
    \ starting point\n\tarr = ('a'..'z').to_a\n\t# puts arr.inspect", "  alphabet\
    \ = Array('a'..'z')\n  rotated_alphabet = alphabet.rotate(2)\n  rot = Hash[alphabet.zip(rotated_alphabet)]\n\
    \  t = \"\"\n  s.each_char do |c|\n    t += rot[c]\n  end\n  return t\nend", " \
    \ alphabet = (\"a\"..\"z\").to_a\n  encrypted = \"\"\n  i = 0\n  while i < s.length\n\
    \    if s[i] == \" \"\n      encrypted << \" \"\n    else\n      # rotate the\
    \ alphabet by two spots\n      alphabet.rotate!(2)\n      # find the index of\
    \ the current letter\n      index = alphabet.index(s[i])\n      # add the letter\
    \ to the end of encrypted string\n      encrypted << alphabet[index]\n    end\n\
    \    i += 1\n  end\n  return encrypted\nend", "\t\n\t# Establish the alphabet\n\
    \tlowercase = ('a'..'z').to_a.join\n\t\n\t# Convert the string to an array\n\t\
    arr = s.split('')\n\t\n\t# Replace each element of the array with the corresponding\
    \ element\n\t# in the encrypted alphabet\n\tarr.map! do |letter|\n\t\tif lowercase.index(letter)\
    \ + 2 > 25\n\t\t\tnew_index = (lowercase.index(letter) + 2) - 26\n\t\t\tlowercase[new_index]\n\
    \t\telse\n\t\t\tlowercase[lowercase.index(letter) + 2]\n\t\tend\n\tend\n\t\n\t\
    # Return the concatenated elements of the array\n\treturn arr.join\nend", "  i\
    \ = 0\n  new_s = ''\n  for i in 0..s.length-1\n  \tnew_s += (s[i].ord + 2 * 2).chr\n\
    \  end\n  return new_s\nend", "    # Create an alphabet Array\n    alphabet =\
    \ Array('a'..'z')\n    # Create an array of alphabets\n    encrypter = Hash[alphabet.zip(alphabet.rotate(2*2))]\n\
    \    # Convert each string to an array of characters\n    s.chars.map { |c| encrypter.fetch(c,\
    \ \" \") }\nend", "  alphabet = 'abcdefghijklmnopqrstuvwxyz'\n  result = ''\n\
    \  s.each_char do |c|\n    old_index = alphabet.index(c)\n    new_index = old_index\
    \ + (old_index + 2) * 2\n    result += alphabet[new_index % 26]\n  end\n  result\n\
    end\nputs encrypt('hi')\nputs encrypt('asdfghjkl')\nputs encrypt('gf')\nputs encrypt('et')\n\
    puts encrypt('fedcba')", "\tab = (\"a\"..\"z\").to_a\n\tab_new = ab.rotate(2*2)\n\
    \ts_arr = s.split(\"\")\n\tnew_arr = []\n\ts_arr.each do |el|\n\t\tnew_arr <<\
    \ ab_new[ab.index(el)]\n\tend\n\tnew_arr.join(\"\")\nend", end, "  return\nend",
  "  alph = ('a'..'z').to_a\n  s.each_char.with_index do |char, i|\n    if alph.include?(char)\n\
    \      s[i] = alph[alph.index(char) + 2]\n    end\n  end\n  return s\nend", "\n\
    end", "  alphabet = ('a'..'z').to_a\n  new_alphabet = alphabet.rotate(alphabet.index('c'))\n\
    \  new_str = ''\n  s.each_char do |char|\n    new_str += new_alphabet[alphabet.index(char)]\n\
    \  end\n  new_str\nend", "  new_string = \"\"\n  s.each_char do |x|\n    new_string\
    \ << x.ord + 2*2\n  end\n  new_string\nend\nputs encrypt('abcd')", "  letters\
    \ = s.split('')\n  arr = []\n  letters.each do |x|\n    val = x.ord\n    val =\
    \ val + 2\n    if x == 'y'\n      val = 122\n    elsif x == 'z'\n      val = 97\n\
    \    end\n    arr.push(val.chr)\n  end\n  arr.join\nend", "    # YOUR CODE HERE\n\
    end", "\ta = s.split('')\n\ta.each do |i|\n\t\tif i.ord == 97\n\t\t\ti.replace\
    \ 'c'\n\t\telsif i.ord == 98\n\t\t\ti.replace 'd'\n\t\telsif i.ord == 99\n\t\t\
    \ti.replace 'e'\n\t\telsif i.ord == 100\n\t\t\ti.replace 'f'\n\t\telsif i.ord\
    \ == 101\n\t\t\ti.replace 'g'\n\t\telsif i.ord == 102\n\t\t\ti.replace 'h'\n\t\
    \telsif i.ord == 103\n\t\t\ti.replace 'i'\n\t\telsif i.ord == 104\n\t\t\ti.replace\
    \ 'j'\n\t\telsif i.ord == 105\n\t\t\ti.replace 'k'\n\t\telsif i.ord == 106\n\t\
    \t\ti.replace 'l'\n\t\telsif i.ord == 107\n\t\t\ti.replace 'm'\n\t\telsif i.ord\
    \ == 108\n\t\t\ti.replace 'n'\n\t\telsif i.ord == 109\n\t\t\ti.replace 'o'\n\t\
    \telsif i.ord == 110\n\t\t\ti.replace 'p'\n\t\telsif i.ord == 111\n\t\t\ti.replace\
    \ 'q'\n\t\telsif i.ord == 112\n\t\t\ti.replace 'r'\n\t\telsif i.ord == 113\n\t\
    \t\ti.replace 's'\n\t\telsif i.ord == 114\n\t\t\ti.replace 't'\n\t\telsif i.ord\
    \ == 115\n\t\t\ti.replace 'u'\n\t\telsif i.ord == 116\n\t\t\ti.replace 'v'\n\t\
    \telsif i.ord == 117\n\t\t\ti.replace 'w'\n\t\telsif i.ord == 118\n\t\t\ti.replace\
    \ 'x'\n\t\telsif i.ord == 119\n\t\t\ti.replace 'y'\n\t\telsif i.ord == 120\n\t\
    \t\ti.replace 'z'\n\t\telsif i.ord == 121\n\t\t\t", "  return s.tr(\"a-z\", \"\
    c-za-b\")\nend", "  #solution\nend", "  s.tr(\"a-z\", \"c-za-b\")\nend", "  alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n  s.split(\"\").map { |char| alphabet[(alphabet.index(char)+2*2)%26]\
    \ }.join\nend", "\talb = 'abcdefghijklmnopqrstuvwxyz'\n\tencr = ''\n\ts.each_char\
    \ do |letter|\n\t\tencr += alb[(alb.index(letter) + 2) * 2]\n\tend\n\tencr\nend",
  "  alphabet = (\"a\"..\"z\").to_a\n  encrypted = []\n  s.each_char do |ch|\n   \
    \ old_idx = alphabet.find_index(ch)\n    new_idx = old_idx + 3\n    encrypted\
    \ << alphabet[new_idx % 26]\n  end\n  encrypted.join(\"\")\nend", "  alpha = ('a'..'z').to_a\n\
    \  final = ''\n  s.split('').each do |c|\n    new_index = (alpha.index(c)+2)*2\n\
    \    final += alpha[new_index]\n  end\n  final\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
