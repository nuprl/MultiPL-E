name: HumanEval_21_rescale_to_unit
language: rb
prompt: "# Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n# such that the smallest number will become 0 and the largest will\
  \ become 1\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5,\
  \ 0.75, 1.0]\ndef rescale_to_unit(numbers)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rescale_to_unit\n\
  \    candidate = method(:rescale_to_unit)\n    assert_equal([0.0, 1.0], candidate.call([2.0,\
  \ 49.9]))\n    assert_equal([1.0, 0.0], candidate.call([100.0, 49.9]))\n    assert_equal([0.0,\
  \ 0.25, 0.5, 0.75, 1.0], candidate.call([1.0, 2.0, 3.0, 4.0, 5.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([2.0, 1.0, 5.0, 3.0, 4.0]))\n    assert_equal([0.25,\
  \ 0.0, 1.0, 0.5, 0.75], candidate.call([12.0, 11.0, 15.0, 13.0, 14.0]))\n  end\n\
  end\n"
completions: ["  min = numbers.min\n  max = numbers.max\n  numbers.map { |x| (x -\
    \ min).to_f / (max - min) }\nend", "\t# Find min and max\n\tmin = numbers.min\n\
    \tmax = numbers.max\n\t# Scale everything\n\tnumbers.map do |n|\n\t\t(n - min)\
    \ / (max - min)\n\tend\nend", "  max_num = numbers.max\n  min_num = numbers.min\n\
    \  numbers.map { |num| (num - min_num) / (max_num - min_num) }\nend", "  numbers.collect\
    \ do |num|\n    (num - numbers.min).to_f / (numbers.max - numbers.min)\n  end\n\
    end", "  max_value = numbers.max\n  min_value = numbers.min\n  return numbers.map\
    \ { |value| (value - min_value) / (max_value - min_value) }\nend", "  numbers.map\
    \ { |n| (n - numbers.min) / (numbers.max - numbers.min) }\nend", "  numbers_max\
    \ = numbers.max\n  numbers_min = numbers.min\n  numbers.map { |n| (n - numbers_min)\
    \ / (numbers_max - numbers_min) }\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |x| (x - min) / (max - min) }\nend", "  max = numbers.max\n \
    \ min = numbers.min\n  numbers.map { |x| (x - min) / (max - min) }\nend", "  min\
    \ = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min).to_f / (max\
    \ - min) }\nend", "\tmin = numbers.min\n\tnumbers.map { |n| (n - min) / (numbers.max\
    \ - min) }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |number|\
    \ (number - min).to_f / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |num| (num - min) / (max - min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  range = max - min\n  numbers.map { |x| (x - min) / range\
    \ }\nend", "  (numbers.map { |n| n - numbers.min }).map { |n| n / numbers.max\
    \ }\nend", "  min = numbers.min()\n  max = numbers.max()\n  # if min == max\n\
    \  #   return numbers\n  # end\n  if min == max\n    return numbers.map { 0 }\n\
    \  end\n  numbers.map { |n| (n - min) / (max - min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |x| (x-min)/(max-min) }\nend", "  return\
    \ numbers.map { |n| (n - numbers.min) / (numbers.max - numbers.min) }\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  numbers.map{|x| (x-min)/(max-min)}\n\
    end", "  result = []\n  numbers.each { |n| result << n }\n  max = result.max\n\
    \  min = result.min\n  result.map! { |n| (n - min).to_f / (max - min) }\n  result\n\
    end", "  require \"matrix\"\n  # TODO: Apply the linear transform to the numbers\
    \ and return the rescaled list\n  if numbers.size == 0\n    return numbers\n \
    \ end\n  min = numbers.min\n  max = numbers.max\n  scale = 1.0 / (max - min)\n\
    \  Vector[*numbers].map{|n| (n - min) * scale}\nend", "  min = numbers.min\n \
    \ max = numbers.max\n  numbers.map { |n| (n - min).to_f / (max - min) }\nend",
  "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", "  # find the minimum and maximum values in the list\n  minimum\
    \ = numbers.min\n  maximum = numbers.max", "  min = numbers.min\n  max = numbers.max\n\
    \  if max - min == 0.0\n    return numbers\n  end\n  numbers.map { |x| (x - min)\
    \ / (max - min) }\nend", "  min, max = numbers.minmax\n  numbers.map { |number|\
    \ (number - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |n| (n - min) / (max - min) }\nend", "  min = numbers.min\n \
    \ max = numbers.max\n  numbers.map{|x| x.to_f/max.to_f}\nend", "    min = numbers.min\n\
    \    max = numbers.max\n    numbers.map { |x| (x - min) / (max - min) }\nend",
  '  return numbers if numbers.empty?', "  [numbers.min, numbers.max].map{|n| (n -\
    \ numbers.min) / (numbers.max - numbers.min)}\nend", "  max = numbers.max\n  min\
    \ = numbers.min\n  new_numbers = numbers.map { |n| (n - min) / (max - min) }\n\
    \  new_numbers\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map{|num|\
    \ (num - min) / (max - min)}\nend", "  return numbers if numbers.count < 2\n \
    \ min = numbers.min\n  max = numbers.max\n  range = max - min\n  numbers.map {\
    \ |x| (x - min) / range }\nend", "  max = numbers.max\n  min = numbers.min\n \
    \ numbers.map { |n| ((n - min) / (max - min)).round(2) }\nend", "  numbers_normalized\
    \ = []\n  numbers_min = numbers.min\n  numbers_max = numbers.max\n  numbers.each\
    \ do |n|\n    numbers_normalized << (n - numbers_min) / (numbers_max - numbers_min)\n\
    \  end\n  numbers_normalized\nend", "  numbers.map { |x| ((x - numbers.min) /\
    \ (numbers.max - numbers.min)) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  scaled = numbers.map { |n| (n - min) / (max - min) }\n  return scaled\nend",
  "  numbers.map { |number| (number - numbers.min) / (numbers.max - numbers.min) }\n\
    end", "  max = numbers.max\n  numbers.map { |n| n / max }\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  range = max - min\n  if range == 0\n    raise ArgumentError,\
    \ \"can't rescale a list with only one item\"\n  end\n  numbers.map { |num| (num\
    \ - min) / range }\nend", "  numbers.map do |number|\n    (number - numbers.min)\
    \ / (numbers.max - numbers.min)\n  end\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |num| (num - min) / (max - min) }\nend", "  ret = numbers.map\
    \ { |number| number - numbers.min }\n  ret = ret.map { |number| number / numbers.max\
    \ }\n  return ret\nend", "    min = numbers.min()\n    max = numbers.max()\n \
    \   numbers.map { |num| (num - min) / (max - min) }\nend", "  if numbers.empty?\n\
    \    []\n  else\n    minimum = numbers.min\n    maximum = numbers.max\n    range\
    \ = maximum - minimum\n    numbers.map { |n| (n - minimum) / range }\n  end\n\
    end", "  (numbers.map do |num|\n    num / numbers.max\n  end)\nend", "  min =\
    \ numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max - min)\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map{|x| (x - min)\
    \ / (max - min)}\nend", "  numbers.map { |x| (x - numbers.min) / (numbers.max\
    \ - numbers.min) }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |number| (number - min) / (max - min) }\nend", "  numbers.minmax.map { |min,\
    \ max| min == max ? min : (numbers.map { |n| (n - min) / (max - min) }) }.flatten\n\
    end", "\tmin = numbers.min\n\tmax = numbers.max\n\tnum_len = numbers.length\n\t\
    numbers.map do |num|\n\t\t(num - min) / (max - min)\n\tend\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min)\
    \ / (max - min) }\nend", "\tnumbers.minmax.map { |num| (num - numbers.min) / (numbers.max\
    \ - numbers.min) }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  numbers.map do |number|\n    (number\
    \ - numbers.min).to_f / (numbers.max - numbers.min)\n  end\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  #numbers.map { |i| i.to_f / numbers.max }\n  numbers.minmax.zip(numbers).map\
    \ do |min, max, n|\n    (n - min).to_f / (max - min)\n  end\nend", "    max =\
    \ numbers.max\n    min = numbers.min\n    numbers.map { |number| (number - min)\
    \ / (max - min) }\nend", "  a = numbers.min\n  b = numbers.max\n  scale = b -\
    \ a\n  numbers.map { |number| (number - a) / scale }\nend", "  if numbers.empty?\n\
    \    return []\n  end", "  min = numbers.min\n  max = numbers.max\n  numbers.map\
    \ { |number| (number - min) / (max - min) }\nend", "  new_min = 0\n  new_max =\
    \ 1\n  min = numbers.min\n  max = numbers.max\n  delta = max - min\n  numbers.map\
    \ { |n| (n - min) * (new_max - new_min) / delta + new_min }\nend", "  #numbers.minmax.map\
    \ { |num| num / numbers.max }\n  min, max = numbers.minmax\n  numbers.map { |num|\
    \ num.to_f.quo(max - min) }\nend", "  min, max = numbers.minmax\n  numbers.map\
    \ { |number| ((number - min) / (max - min)).round(2) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  unit_numbers = numbers.map { |number| (number - min) /\
    \ (max - min) }\n  return unit_numbers\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |x| (x - min) / (max - min) }\nend", "  numbers_max = numbers.max\n\
    \  numbers_min = numbers.min\n  numbers.map { |n| (n - numbers_min) / (numbers_max\
    \ - numbers_min) }\nend", "  [\n    numbers.min,\n    numbers.max\n  ].map { |n|\
    \ n.to_f }.then { |min, max|\n    numbers.map { |n|\n      (n - min) / (max -\
    \ min)\n    }\n  }\nend", "  numbers.map { |number|  (number - numbers.min) /\
    \ (numbers.max - numbers.min) }\nend", "  minimum = numbers.min\n  maximum = numbers.max\n\
    \  numbers.map { |number| (number - minimum) / (maximum - minimum) }\nend", " \
    \ numbers.map { |number| (number - numbers.min) / (numbers.max - numbers.min)\
    \ }\nend", "  max_number = numbers.max\n  min_number = numbers.min\n  numbers.map\
    \ { |n| ((n - min_number) / (max_number - min_number)) }\nend", "  minimum = numbers.min\n\
    \  maximum = numbers.max\n  array = []\n  numbers.each do |number|\n    array\
    \ << ((number - minimum) / (maximum - minimum))\n  end\n  array\nend", "  minimum,\
    \ maximum = numbers.minmax\n  numbers.map { |number| (number - minimum).to_f /\
    \ (maximum - minimum) }\nend", "  raise 'The given list is empty' if numbers.length\
    \ == 0\n  numbers.map do |number|\n    number / numbers.max\n  end\nend", "  min,\
    \ max = numbers.minmax\n  numbers.map { |x| (x - min) / (max - min) }\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", '  return numbers if numbers.empty?', "  min = numbers.min\n\
    \  max = numbers.max\n  diff = max - min\n  numbers.map{|x| (x - min) / diff}\n\
    end", "    # TODO: implement this function (optional)\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  scaled = numbers.map { |x| (x - min) / (max - min) }\n\
    \  scaled\nend", "  # TODO: implement this\nend", "  max = numbers.max\n  min\
    \ = numbers.min\n  numbers.map { |x| (x-min)/(max-min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  #return numbers.map { |x| (x - min)/(max - min) }\n  return\
    \ numbers.map { |x| x.fdiv(max) }\nend", "  numbers.map { |num| (num - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  return numbers unless numbers.length\
    \ > 1\n  # max = numbers.max\n  # min = numbers.min\n  numbers = numbers.map{|n|\
    \ (n - numbers.min) / (numbers.max - numbers.min)}\nend", "  numbers.map { |number|\
    \ (number - numbers.min) / (numbers.max - numbers.min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |x| (x - min) / (max - min) }\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", "  num_to_subtract = numbers.min\n  num_to_divide = numbers.max\
    \ - num_to_subtract\n  numbers.map { |num| (num - num_to_subtract) / num_to_divide\
    \ }\nend", "\tmin = numbers.min\n\tmax = numbers.max\n\tnumbers.map { |n| (n -\
    \ min) / (max - min) }\nend", "  # precondition\n  raise ArgumentError, \"Array\
    \ must have at least two elements\" if numbers.size < 2", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |x| (x - min) / (max - min) }\nend", " \
    \   max_val = numbers.max\n    min_val = numbers.min\n    (numbers.map { |x| (x\
    \ - min_val) / (max_val - min_val) }).to_a\nend", "  # PUT YOUR CODE HERE\nend",
  "  numbers_min = numbers.min\n  numbers_max = numbers.max\n  numbers.map { |n| (n\
    \ - numbers_min) / (numbers_max - numbers_min) }\nend", "  low_num = numbers.min\n\
    \  high_num = numbers.max\n  numbers.map { |num| (num - low_num).to_f / (high_num\
    \ - low_num) }\nend", "  maximum = numbers.max\n  minimum = numbers.min\n  numbers.map\
    \ { |i| (i-minimum).to_f / (maximum-minimum) }\nend", "  min = numbers.min\n \
    \ max = numbers.max\n  numbers.map { |num| (num - min) / (max - min) }\nend",
  "    numbers = [0.0, 0.0, 1.0, 1.0, 0.0]\n    min = numbers.min\n    max = numbers.max\n\
    \    range = max - min\n    numbers.map { |n| (n - min) / range }\nend", "  max_number\
    \ = numbers.max\n  min_number = numbers.min\n  numbers.map { |n| (n - min_number)\
    \ / (max_number - min_number) }\nend", "  numbers.map { |num| (num - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  n = numbers.length\n  m = numbers.min\n\
    \  M = numbers.max\n  numbers.map { |i| (i - m).to_f / (M - m) }\nend", "  max\
    \ = numbers.max()\n  min = numbers.min()\n  numbers.map { |x| ((x - min) / (max\
    \ - min)) }\nend", "  min, max = numbers.minmax\n  unit_range = max - min\n  numbers.map\
    \ { |n| (n - min) / unit_range }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map{|x| (x - min) / (max - min)}\nend", "  min = numbers.min\n  max\
    \ = numbers.max\n  max - min != 0.0 ? numbers.map { |n| (n - min)/(max - min)\
    \ } : numbers\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |num| (num - min) / (max - min) }\nend", "    numbers = numbers.sort\n   \
    \ diff = numbers[-1] - numbers[0]\n    numbers.map { |num| (num - numbers[0])\
    \ / diff }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |number|\
    \ (number - min) / (max - min) }\nend", "  # Use this space for your solution.\n\
    \  # You can use enumerators if you want.\n  # Don't change anything below.\n\
    \  max_num = numbers.max\n  min_num = numbers.min\n  numbers.map { |n| n.to_f\
    \ / (max_num - min_num) }\nend", "  max = numbers.max\n  min = numbers.min\n \
    \ numbers.map { |value| (value.to_f - min) / (max - min) }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  diff = max - min\n  numbers.map { |number| (number - min)\
    \ / diff }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map { |number|\
    \ (number - min) / (max - min) }\nend", "  i = numbers.index(numbers.min)\n  a\
    \ = numbers[i]\n  i = numbers.index(numbers.max)\n  b = numbers[i]\n  array =\
    \ numbers.map { |x| (x-a)/(b-a)}\n  return array\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |num| (num - min) / (max - min) }\nend",
  "  number_range = numbers.max - numbers.min\n  numbers.map { |n| ((n - numbers.min)\
    \ / number_range).round(4) }\nend", "  min, max = numbers.minmax\n  numbers.map\
    \ { |n| (n - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |x| (x - min) / (max - min) }\nend", "\tnumbers.minmax.map {\
    \ |x| (x - numbers.min) / (numbers.max - numbers.min) }\nend", "  minimum = numbers.min\n\
    \  maximum = numbers.max\n  numbers.map { |x| (x - minimum) / (maximum - minimum)\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  range = max - min\n  numbers.map\
    \ { |x| (x - min) / range }\nend", "  if numbers.is_a? Array and numbers.count\
    \ > 1\n    minimum = numbers.min\n    maximum = numbers.max\n    if maximum >\
    \ minimum\n      return numbers.map{|x| (x-minimum)/(maximum-minimum)}\n    end\n\
    \  end\n  return numbers\nend", "  min = numbers.min\n  range = numbers.max -\
    \ min\n  numbers.map { |number| (number - min) / range }\nend", "  r = Range.new(numbers.min,\
    \ numbers.max)\n  numbers.map { |x| r.to_unit(x) }\nend", "  # TODO\nend", " \
    \ numbers.map { |n| n.to_f / numbers.max }\nend", "    min = numbers.min\n   \
    \ max = numbers.max\n    numbers.map { |n| (n - min) / (max - min) }\nend", " \
    \ lowest = numbers.min\n  highest = numbers.max\n  numbers.map { |n| (n - lowest)\
    \ / (highest - lowest) }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map\
    \ { |number| (number - min) / (max - min) }\nend", "  max = numbers.max\n  min\
    \ = numbers.min\n  # puts max, min\n  numbers.map { |n| (n-min)/(max-min) }\n\
    end", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min).to_f\
    \ / (max - min) }\nend", "  return [0.0] if numbers.length == 1\n  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |number| (number - min).to_f / (max - min)\
    \ }\nend", "  min = numbers.min\n  max = numbers.max\n  numbers.map { |number|\
    \ (number - min) / (max - min) }\nend", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |number| (number - min) / (max - min) }\nend", "  scale = numbers.max\
    \ - numbers.min\n  scale = 1 if scale == 0\n  numbers.map { |n| (n - numbers.min)\
    \ / scale }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map {\
    \ |num| (num - min) / (max - min) }\nend", "  min = numbers.min\n  max = numbers.max\n\
    \  numbers.map { |number| (number - min) / (max - min) }\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  numbers.map { |n| (n - min) / (max - min) }\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  return [0.0] if min == max", "  numbers_rescaled\
    \ = []\n  min_number = numbers.min\n  max_number = numbers.max\n  range = max_number\
    \ - min_number\n  for number in numbers\n    numbers_rescaled << (number - min_number)\
    \ / range\n  end\n  numbers_rescaled\nend", "  sorted = numbers.sort\n  numbers.map\
    \ do |num|\n    (num - sorted.first) / (sorted.last - sorted.first)\n  end\nend",
  "  #TODO: write your code here\nend", "  values = Set.new(numbers)\n  scale = 1.0\
    \ / (values.max - values.min)\n  values.map{|n| (n - values.min) * scale}\nend",
  "  # TODO: complete the method\nend", "  minimum = numbers.min\n  maximum = numbers.max\n\
    \  numbers.map{|number| (number - minimum) / (maximum - minimum)}\nend", "  max\
    \ = numbers.max\n  min = numbers.min\n  numbers.map { |number| (number - min)\
    \ / (max - min) }\nend", "  min, max = numbers.minmax\n  number_range = max -\
    \ min\n  numbers.map { |n| (n - min) / number_range }\nend", "  numbers.minmax\n\
    \    .yield_self { |(min, max)| minmax_transform(numbers, min, max) }\nend", " \
    \ numbers.map { |n| (n - numbers.min) / (numbers.max - numbers.min) }\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  numbers.map { |n| (n - min) / (max\
    \ - min) }\nend", "  sorted = numbers.sort\n  smallest = sorted.first\n  largest\
    \ = sorted.last\n  numbers.map { |n| (n - smallest).to_f / (largest - smallest)\
    \ }\nend", "  max = numbers.max\n  min = numbers.min\n  range = max - min\n  numbers.map\
    \ { |n| (n - min) / range }\nend", "  [\n    numbers.min,\n    numbers.max\n \
    \ ].map { |number|\n    number.to_f\n  }.tap { |min, max|\n    numbers.map { |number|\n\
    \      (number - min) / (max - min)\n    }\n  }\nend", "  max = numbers.max\n\
    \  min = numbers.min\n  numbers.map { |x| (x - min) / (max - min) }\nend", " \
    \ min = numbers.min\n  max = numbers.max\n  numbers.map { |i| (i - min) / (max\
    \ - min) }\nend", "  # use float division to get float values for division\n \
    \ max_number = numbers.max.to_f\n  min_number = numbers.min.to_f\n  numbers.map\
    \ { |number| (number - min_number) / (max_number - min_number) }\nend", "  max\
    \ = numbers.max\n  min = numbers.min\n  numbers.map { |n| (n-min)/(max-min) }\n\
    end", "    max = numbers.max\n    min = numbers.min\n    numbers.map{|x| (x -\
    \ min) / (max - min)}\nend", "  numbers_with_nan = numbers.map{|x| x.to_f}\n \
    \ max_val = numbers_with_nan.max\n  min_val = numbers_with_nan.min\n  if max_val\
    \ == min_val\n    range = 1\n  else\n    range = max_val - min_val\n  end\n  numbers_with_nan.map{|x|\
    \ (x - min_val)/range}\nend", "  # Find the minimum and maximum values\n  min\
    \ = numbers.min\n  max = numbers.max", "  max = numbers.max\n  min = numbers.min\n\
    \  numbers.map { |x| (x - min) / (max - min) }\nend", "  min = numbers.min\n \
    \ max = numbers.max\n  numbers.map { |number| (number - min) / (max - min) }\n\
    end", "  min = numbers.min\n  range = numbers.max - min\n  numbers.map { |n| (n\
    \ - min) / range }\nend", "  max = numbers.max\n  min = numbers.min\n  length\
    \ = numbers.length\n  range = max - min\n  numbers.map { |num| (num - min) / range\
    \ }\nend", "  # 1. find the smallest and largest numbers\n  # 2. determine how\
    \ much each number needs to change to be at 0 or 1\n  # 3. apply that change to\
    \ every number", "  numbers.map { |x| (x - numbers.min) / (numbers.max - numbers.min)\
    \ }\nend", "\t# TODO: Your code here\nend", "  numbers.map { |n| (n - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  min = numbers.min\n  range = numbers.max\
    \ - min\n  numbers.map { |n| (n - min) / range }\nend", "  numbers.map { |i| i.to_f\
    \ / numbers.max }\nend", "  minimum = numbers.min\n  range = numbers.max - minimum\n\
    \  numbers.map { |n| (n - minimum) / range }\nend", "  scaled_numbers = []\n \
    \ maximum = numbers.max\n  minimum = numbers.min\n  new_max = 1.0\n  new_min =\
    \ 0.0\n  numbers.each do |number|\n    scaled_numbers << new_min + ((number -\
    \ minimum) * (new_max - new_min) / (maximum - minimum))\n  end\n  scaled_numbers\n\
    end", "  numbers.map { |number| (number - numbers.min) / (numbers.max - numbers.min)\
    \ }\nend", "  max = numbers.max\n  min = numbers.min\n  numbers.map { |x| (x -\
    \ min) / (max - min) }\nend", "  assert_not_empty(numbers)\n  assert_is_numeric(numbers)\n\
    \  min = numbers.min\n  max = numbers.max\n  scaled = numbers.map do |n|\n   \
    \ (n - min) / (max - min)\n  end\n  assert_is_numeric(scaled)\n  scaled\nend",
  "  min = numbers.min\n  max = numbers.max\n  size = max - min\n  numbers.map { |number|\
    \ (number - min) / size }\nend", "  min = numbers.min\n  max = numbers.max\n \
    \ range = max - min\n  numbers.map { |n| (n - min) / range }\nend", "  min = numbers.min\n\
    \  max = numbers.max\n  numbers.map { |x| (x - min) / (max - min) }\nend", " \
    \ return numbers.map { |i| i - numbers.min }.map { |i| i / numbers.max }\nend",
  "  numbers.map { |n| (n-numbers.min)/(numbers.max-numbers.min) }\nend", "  numbers.map\
    \ { |x| x / (numbers.max - numbers.min) }\nend", "  min = numbers.min\n  max =\
    \ numbers.max\n  numbers.map { |x| (x - min) / (max - min) }\nend", "  # you can\
    \ use \"p numbers\" to inspect the array before/during/after\n  # p numbers",
  "  numbers.min.upto(numbers.max).map { |number| number - numbers.min }\nend", " \
    \ numbers = numbers.sort\n  min = numbers.first\n  max = numbers.last\n  unit_list\
    \ = []\n  numbers.each do |number|\n    unit_list << (number - min) / (max - min)\n\
    \  end\n  unit_list\nend", "  range = numbers.max - numbers.min\n  numbers.map\
    \ { |number| (number - numbers.min) / range }\nend", "  assert_type numbers, :list\n\
    \  numbers = numbers.map{|x| x.to_f}\n  assert_type numbers[0], :float", "  #\
    \ Find largest and smallest numbers in the list\n  # Subtract smallest number\
    \ from every number\n  # Divide every number by the difference between largest\
    \ and smallest\n  min = numbers.min\n  max = numbers.max\n  numbers.map { |number|\
    \ (number - min).to_f / (max - min) }\nend", "  biggest = numbers.max\n  smallest\
    \ = numbers.min\n  numbers.map { |n| (n - smallest) / (biggest - smallest) }\n\
    end", "  # TODO: write code here\nend", "  numbers.map { |n| (n - numbers.min)\
    \ / (numbers.max - numbers.min) }\nend", "  [0, 1].map { |el| numbers.minmax.zip([el,\
    \ el]).map { |n, i| n * i }.sum }\nend", "    max_number = numbers.max\n    min_number\
    \ = numbers.min\n    numbers.map { |x| (x - min_number) / (max_number - min_number)\
    \ }\nend", "  numbers.map { |number| (number.to_f - numbers.min) / (numbers.max\
    \ - numbers.min) }\nend", "  # for now, just make a copy\n  result = numbers.dup\n\
    \  # TODO: replace with actual rescaling\n  result\nend", "  [\n    numbers.min,\n\
    \    numbers.max\n  ].map do |e|\n    1.0 / (numbers.max - numbers.min) * (e -\
    \ numbers.min)\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
