name: HumanEval_136_largest_smallest_integers
language: rb
prompt: "# Create a function that returns a tuple (a, b), where 'a' is\n# the largest\
  \ of negative integers, and 'b' is the smallest\n# of positive integers in a list.\n\
  # If there is no negative or positive integers, return them as None.\n# Examples:\n\
  # largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n# largest_smallest_integers([])\
  \ == (None, None)\n# largest_smallest_integers([0]) == (None, None)\ndef largest_smallest_integers(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_largest_smallest_integers\n\
  \    candidate = method(:largest_smallest_integers)\n    assert_equal([nil, 1],\
  \ candidate.call([2, 4, 1, 3, 5, 7]))\n    assert_equal([nil, 1], candidate.call([2,\
  \ 4, 1, 3, 5, 7, 0]))\n    assert_equal([-2, 1], candidate.call([1, 3, 2, 4, 5,\
  \ 6, -2]))\n    assert_equal([-7, 2], candidate.call([4, 5, 3, 6, 2, 7, -7]))\n\
  \    assert_equal([-9, 2], candidate.call([7, 3, 8, 4, 9, 2, 5, -9]))\n    assert_equal([nil,\
  \ nil], candidate.call([]))\n    assert_equal([nil, nil], candidate.call([0]))\n\
  \    assert_equal([-1, nil], candidate.call([-1, -3, -5, -6]))\n    assert_equal([-1,\
  \ nil], candidate.call([-1, -3, -5, -6, 0]))\n    assert_equal([-3, 1], candidate.call([-6,\
  \ -4, -4, -3, 1]))\n    assert_equal([-3, 1], candidate.call([-6, -4, -4, -3, -100,\
  \ 1]))\n  end\nend\n"
completions: ["  return (nil, nil) if lst.empty? || lst.all? { |v| v == 0 }\n  return\
    \ (-lst.min, lst.max) if lst.all? { |v| v.positive? }\n  return (lst.min, -lst.max)\
    \ if lst.all? { |v| v.negative? }\n  lst.partition { |v| v.negative? }.map { |l|\
    \ l.empty? ? nil : l.max }\nend", "  if lst.nil? || lst.empty?\n    return [nil,\
    \ nil]\n  end\n  [lst.select { |i| i.negative? }.max, lst.select { |i| i.positive?\
    \ }.min]\nend", '  return [nil, nil] if lst.empty?', "  positives = lst.select\
    \ { |x| x > 0 }\n  negatives = lst.select { |x| x < 0 }\n  [negatives.max, positives.min]\n\
    end", "  # Your Code Here\nend", "   \n   \n   \n   \n   \n   \n   \n   \n   \n\
    \   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n \
    \  \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  \
    \ \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n\
    \   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n \
    \  \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  \
    \ \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n\
    \   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n \
    \  \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  \
    \ \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n\
    \   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n \
    \  \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  \
    \ \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n\
    \   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n \
    \  \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  \
    \ \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n\
    \   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n \
    \  \n   ", "  negatives = lst.select { |num| num < 0 }\n  positives = lst.select\
    \ { |num| num > 0 }\n  negatives.empty? ? (negatives = [nil]) : negatives.sort!\n\
    \  positives.empty? ? (positives = [nil]) : positives.sort!\n  [negatives.last,\
    \ positives.first]\nend", "  if lst.empty?\n    [nil, nil]\n  else\n    result\
    \ = [0, 9]\n    lst.each do |num|\n      result[0] = num if num < 0 && num > result[0]\n\
    \      result[1] = num if num > 0 && num < result[1]\n    end\n    result.include?(0)\
    \ ? [nil, nil] : result\n  end\nend", "\tnegative = []; positive = []\n\tfor i\
    \ in lst do\n\t\tif i < 0\n\t\t\tnegative << i\n\t\telsif i > 0\n\t\t\tpositive\
    \ << i\n\t\tend\n\tend\n\t\tnegative.max == nil ? a = nil : a = negative.max\n\
    \t\tpositive.min == nil ? b = nil : b = positive.min\n\t\tp \"#{a}, #{b}\"\nend",
  "  # your code here\nend", "    if lst.empty?\n        return [nil, nil]\n    end\n\
    \    positives = lst.select { |x| x > 0 }\n    negatives = lst.select { |x| x\
    \ < 0 }\n    return [negatives.max, positives.min]\nend", "  a = b = nil\n  lst.each\
    \ do |n|\n    a = n if n < 0 && (a.nil? || n > a)\n    b = n if n > 0 && (b.nil?\
    \ || n < b)\n  end\n  [a, b]\nend", "  # Take the first element of lst as the\
    \ min_number\n  min_number = lst[0]\n  # Take the first element of lst as the\
    \ max_number\n  max_number = lst[0]\n  # Loop over the list, skipping the first\
    \ element\n  for number in lst[1..-1]\n    # Take the first element of lst as\
    \ the min_number\n    min_number = number if number < min_number\n    # Take the\
    \ first element of lst as the max_number\n    max_number = number if number >\
    \ max_number\n  end\n  # Return a tuple (min_number, max_number)\n  [min_number,\
    \ max_number]\nend", "  return [(lst.select { |item| item.negative? }.max), (lst.select\
    \ { |item| item.positive? }.min)]\nend", "  lst.partition { |i| i < 0 }.map {\
    \ |i| i.empty? ? nil : i.sort.last }\nend", "  neg = nil\n  pos = nil\n  lst.each\
    \ do |n|\n    neg = n if n < 0 && (neg.nil? || n > neg)\n    pos = n if n > 0\
    \ && (pos.nil? || n < pos)\n  end\n  [neg, pos]\nend", "  max_pos = lst.select\
    \ { |i| i > 0 }.min\n  max_neg = lst.select { |i| i < 0 }.max\n  return [max_neg,\
    \ max_pos]\nend", "  return [nil, nil] if lst.length < 1\n  negs = lst.select\
    \ { |x| x < 0 }\n  pos = lst.select { |x| x > 0 }\n  neg = negs.max || nil\n \
    \ pos = pos.min || nil\n  [neg, pos]\nend", "  arr = []\n  lst.each do |x|\n \
    \   if x < 0\n      arr << x\n    end\n  end\n  largest = arr.sort.last\n  small\
    \ = lst.min\n  [largest, small]\nend", "  return [nil, nil] if lst.empty?\n  return\
    \ [nil, nil] if lst.size == 1 && lst[0] == 0\n  max_int = lst.max\n  min_int =\
    \ lst.min\n  if max_int > 0 && min_int < 0\n    [max_int, min_int]\n  else\n \
    \   [nil, nil]\n  end\nend", "  if lst.empty?\n    return [nil, nil]\n  end\n\
    \  i = []\n  s = []\n  lst.each do |x|\n    if x > 0\n      s << x\n    elsif\
    \ x < 0\n      i << x\n    end\n  end\n  [i.max, s.min]\nend", "  if lst.empty?\n\
    \    [nil, nil]\n  else\n    smaller = lst.max_by { |a| a < 0 ? a : -a }\n   \
    \ bigger = lst.min_by { |a| a > 0 ? a : -a }\n    [smaller, bigger]\n  end\nend",
  "  lst.sort!\n  neg = []\n  pos = []\n  lst.each do |x|\n    if x < 0\n      neg\
    \ << x\n    elsif x > 0\n      pos << x\n    end\n  end\n  neg = neg.max\n  pos\
    \ = pos.min\n  if neg == nil && pos == nil\n    return [nil, nil]\n  elsif neg\
    \ == nil\n    return [nil, pos]\n  elsif pos == nil\n    return [neg, nil]\n \
    \ else\n    return [neg, pos]\n  end\nend", "  [lst.select { |num| num < 0 }.max,\
    \ lst.select { |num| num > 0 }.min]\nend", "  positive = []\n  negative = []\n\
    \  lst.each do |i|\n    if i > 0\n      positive << i\n    elsif i < 0\n     \
    \ negative << i\n    end\n  end\n  return [negative.min, positive.min]\nend",
  "\ti = 0\n\twhile i < lst.length\n\t\tif lst[i] < 0\n\t\t\tlst[i] = lst[i]\n\t\t\
    else\n\t\t\tlst[i] = nil\n\t\tend\n\t\ti += 1\n\tend\n\tlst = lst.compact\n\t\
    lst = lst.sort\n\tlst = lst.reverse\n\tneg_first = lst[0]\n\tneg_last = lst[-1]\n\
    \ti = 0\n\twhile i < lst.length\n\t\tif lst[i] > 0\n\t\t\tlst[i] = lst[i]\n\t\t\
    else\n\t\t\tlst[i] = nil\n\t\tend\n\t\ti += 1\n\tend\n\tlst = lst.compact\n\t\
    lst = lst.sort\n\tpos_first = lst[0]\n\tpos_last = lst[-1]\n\tlst = (neg_first,\
    \ pos_first)\n\treturn lst\nend", "\t#return (1,2)\n\tif lst.empty? or (lst.length\
    \ == 1 and lst[0] == 0)\n\t\treturn (nil, nil)\n\telse\n\t\tlst.sort!\n\t\tfor\
    \ i in 0..lst.length-1\n\t\t\tif lst[i] > 0\n\t\t\t\treturn (lst[i-1], lst[i])\n\
    \t\t\tend\n\t\tend\n\tend\nend", "  lst.select! { |i| i < 0 }\n  lst.sort!\n \
    \ return (lst.last, lst.first) if lst.any?\n  (nil, nil)\nend", end, "  negative\
    \ = []\n  positive = []\n  if lst == []\n    return [nil, nil]\n  else\n    lst.each\
    \ do |n|\n      if n < 0\n        negative << n\n      else\n        positive\
    \ << n\n      end\n    end\n    return [negative.max, positive.min]\n  end\nend",
  "  if lst.select { |n| n.negative? }.length.zero? || lst.select { |n| n.positive?\
    \ }.length.zero?\n    return [nil, nil]\n  end\n  [lst.select { |n| n.negative?\
    \ }.max, lst.select { |n| n.positive? }.min]\nend", "  if lst.empty?\n    return\
    \ [nil, nil]\n  elsif lst.none? { |num| num < 0 }\n    return [nil, lst.min]\n\
    \  elsif lst.none? { |num| num > 0 }\n    return [lst.max, nil]\n  else\n    return\
    \ [lst.max, lst.min]\n  end\nend", "  negative_lst = lst.select { |num| num <\
    \ 0 }\n  positive_lst = lst.select { |num| num > 0 }\n  return (negative_lst.max,\
    \ positive_lst.min)\nend", "  # Code goes here\nend", "  max_negative = nil\n\
    \  min_positive = nil\n  lst.each do |item|\n    if item < 0\n      max_negative\
    \ = item if max_negative.nil? || item > max_negative\n    elsif item > 0\n   \
    \   min_positive = item if min_positive.nil? || item < min_positive\n    end\n\
    \  end\n  [max_negative, min_positive]\nend", '  return [nil, nil] if lst.size
    == 0', '  return [nil, nil] if lst.empty?', "  a = lst.select { |n| n < 0 }.max\n\
    \  b = lst.select { |n| n > 0 }.min\n  a = nil if a.nil?\n  b = nil if b.nil?\n\
    \  return [a, b]\nend", "  if lst.empty?\n    return [nil, nil]\n  elsif lst.all?(&:zero?)\n\
    \    return [nil, nil]\n  else\n    non_zero_num = lst.select { |number| number\
    \ != 0 }\n    non_negative_num = non_zero_num.select { |number| number >= 0 }\n\
    \    negative_num = non_zero_num.select { |number| number < 0 }\n    if negative_num.empty?\n\
    \      return [nil, non_negative_num.min]\n    elsif non_negative_num.empty?\n\
    \      return [negative_num.max, nil]\n    else\n      return [negative_num.max,\
    \ non_negative_num.min]\n    end\n  end\nend", "  return [nil, nil] if lst.empty?\n\
    \  neg, pos = lst.partition(&:negative?)\n  neg = neg.max\n  pos = pos.min\n \
    \ neg.nil? ? [nil, pos] : [neg, pos]\nend", "  negative_numbers = lst.select {\
    \ |e| e < 0 }\n  positive_numbers = lst.select { |e| e > 0 }\n  if negative_numbers.empty?\
    \ && positive_numbers.empty?\n    return [nil, nil]\n  elsif negative_numbers.empty?\n\
    \    return [nil, positive_numbers.min]\n  elsif positive_numbers.empty?\n   \
    \ return [negative_numbers.max, nil]\n  else\n    return [negative_numbers.max,\
    \ positive_numbers.min]\n  end\nend", "  # Write your code here.\nend", "  negatives\
    \ = lst.select { |n| n < 0 }\n  positives = lst.select { |n| n > 0 }\n  [negatives.max,\
    \ positives.min]\nend", "\trequire 'pry'\n\tbinding.pry\n\tlst.uniq!", "  positive\
    \ = lst.select{|number| number > 0}.sort.first\n  negative = lst.select{|number|\
    \ number < 0}.sort.last\n  if positive == nil && negative == nil\n    return [nil,\
    \ nil]\n  elsif positive == nil\n    return [negative, nil]\n  elsif negative\
    \ == nil\n    return [nil, positive]\n  else\n    return [negative, positive]\n\
    \  end\nend", "    if lst.nil?\n        return [nil, nil]\n    end\n    a, b =\
    \ nil, nil\n    lst.each do |n|\n        if n > 0\n            if b.nil? || n\
    \ < b\n                b = n\n            end\n        elsif n < 0\n         \
    \   if a.nil? || n > a\n                a = n\n            end\n        end\n\
    \    end\n    [a, b]\nend", "\tif lst.empty?\n\t\treturn [nil, nil]\n\tend\n\t\
    if lst.all? { |n| n == 0 }\n\t\treturn [nil, nil]\n\tend\n\tif lst.all? { |n|\
    \ n > 0 }\n\t\treturn [nil, lst.min]\n\tend\n\tif lst.all? { |n| n < 0 }\n\t\t\
    return [lst.max, nil]\n\tend\n\treturn [lst.select { |n| n < 0 }.max, lst.select\
    \ { |n| n > 0 }.min]\nend", "  negs = lst.select { |num| num < 0 }\n  poss = lst.select\
    \ { |num| num > 0 }\n  if negs.size > 0 && poss.size > 0\n    return negs.max,\
    \ poss.min\n  else\n    return nil, nil\n  end\nend", "  negative_integers = []\n\
    \  positive_integers = []\n  lst.each do |n|\n    if n < 0\n      negative_integers\
    \ << n\n    elsif n > 0\n      positive_integers << n\n    end\n  end\n  [negative_integers.max,\
    \ positive_integers.min]\nend", "  # Your code here\nend", "  if lst.empty?\n\
    \    [nil, nil]\n  else\n    [lst.select { |x| x < 0 }.max, lst.select { |x| x\
    \ > 0 }.min]\n  end\nend", "    nums = lst.select { |n| n < 0 || n > 0 }\n   \
    \ sorted = nums.sort\n    [sorted.last, sorted.first]\nend", "  if lst.size.zero?\n\
    \    return [nil, nil]\n  end\n  [lst.select { |x| x.negative? }.max, lst.select\
    \ { |x| x.positive? }.min]\nend", "  return [nil, nil] if lst.all? { |num| num\
    \ >= 0 } || lst.empty?\n  largest = lst.select { |num| num < 0 }.max\n  smallest\
    \ = lst.select { |num| num > 0 }.min\n  [largest, smallest]\nend", "\tlst = lst.sort()\n\
    \tcount_neg = 0\n\tcount_pos = 0\n\tfor i in 0..lst.length-1\n\t\tif lst[i] <\
    \ 0\n\t\t\tcount_neg += 1\n\t\telsif lst[i] > 0\n\t\t\tcount_pos += 1\n\t\tend\n\
    \tend\n\tif count_neg == 0\n\t\tneg = nil\n\telse\n\t\tneg = lst[0]\n\tend\n\t\
    if count_pos == 0\n\t\tpos = nil\n\telse\n\t\tpos = lst[lst.length-1]\n\tend\n\
    \treturn neg, pos\nend", "\tpositives = lst.select { |x| x > 0 }\n\tnegatives\
    \ = lst.select { |x| x < 0 }\n\tif positives == []\n\t\tb = None\n\telse\n\t\t\
    b = positives.min\n\tend\n\tif negatives == []\n\t\ta = None\n\telse\n\t\ta =\
    \ negatives.max\n\tend\n\treturn a, b\nend", "  pos = nil\n  neg = nil\n  lst.each\
    \ do |i|\n    if i > 0\n      pos = i if pos.nil? || i < pos\n    elsif i < 0\n\
    \      neg = i if neg.nil? || i > neg\n    end\n  end\n  [neg, pos]\nend", " \
    \ if lst.empty?\n    return [nil, nil]\n  elsif lst.all? { |num| num > 0 }\n \
    \   return [nil, lst.min]\n  elsif lst.all? { |num| num < 0 }\n    return [lst.max,\
    \ nil]\n  else\n    return [lst.select { |num| num < 0 }.max, lst.select { |num|\
    \ num > 0 }.min]\n  end\nend", "  return [nil, nil] if lst.empty?\n  negatives\
    \ = lst.select { |num| num < 0 }\n  negatives.sort\n  positives = lst.select {\
    \ |num| num > 0 }\n  positives.sort\n  [negatives.last, positives.first]\nend",
  "  has_neg = false\n  has_pos = false\n  max_neg = nil\n  min_pos = nil\n  lst.each\
    \ do |x|\n    if x < 0\n      has_neg = true\n      if max_neg == nil || x > max_neg\n\
    \        max_neg = x\n      end\n    elsif x > 0\n      has_pos = true\n     \
    \ if min_pos == nil || x < min_pos\n        min_pos = x\n      end\n    end\n\
    \  end\n  return max_neg, min_pos\nend", "  if lst.empty?\n    return [nil, nil]\n\
    \  end\n  positives = []\n  negatives = []\n  lst.each do |x|\n    if x > 0\n\
    \      positives << x\n    elsif x < 0\n      negatives << x\n    end\n  end\n\
    \  smallest_positive = positives.min\n  largest_negative = negatives.max\n  [largest_negative,\
    \ smallest_positive]\nend", "  a, b = nil, nil\n  lst.each do |num|\n    if num\
    \ < 0\n      a = num if a.nil? || num > a\n    elsif num > 0\n      b = num if\
    \ b.nil? || num < b\n    end\n  end\n  [a, b]\nend", "    x = lst.map(&:abs).select\
    \ { |x| x < 0 }.max\n    y = lst.map(&:abs).select { |x| x > 0 }.min\n    return\
    \ (x.nil? ? nil : x, y.nil? ? nil : y)\nend", "  lst.select{|x| x < 0}.max.nil?\
    \ ? a = nil : a = lst.select{|x| x < 0}.max\n  lst.select{|x| x > 0}.min.nil?\
    \ ? b = nil : b = lst.select{|x| x > 0}.min\n  return a, b\nend", "\tif lst.empty?\n\
    \t\treturn [nil, nil]\n\telse\n\t\tnegative_numbers = lst.select { |i| i < 0 }\n\
    \t\tpositive_numbers = lst.select { |i| i > 0 }\n\t\tif negative_numbers.empty?\n\
    \t\t\tnegative_numbers = [nil]\n\t\tend\n\t\tif positive_numbers.empty?\n\t\t\t\
    positive_numbers = [nil]\n\t\tend\n\t\t[negative_numbers.max, positive_numbers.min]\n\
    \tend\nend", end, "    max_neg = lst.min\n    min_pos = lst.max\n    lst.each\
    \ do |i|\n        max_neg = i if i < 0 && i > max_neg\n        min_pos = i if\
    \ i > 0 && i < min_pos\n    end\n    max_neg = nil if max_neg == lst.min\n   \
    \ min_pos = nil if min_pos == lst.max\n    return max_neg, min_pos\nend", "  \
    \  max = nil\n    min = nil\n    lst.each do |n|\n        if n < 0 && max.nil?\
    \ || n < max\n            max = n\n        end\n        if n > 0 && min.nil? ||\
    \ n < min\n            min = n\n        end\n    end\n    return max, min\nend",
  "    a = (lst.select {|e| e < 0}).max\n    b = (lst.select {|e| e > 0}).min\n  \
    \  a = nil if a == -Float::INFINITY\n    b = nil if b == Float::INFINITY\n   \
    \ return a, b\nend\nputs \"largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (#{largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])})\"\nputs \"largest_smallest_integers([]) == (#{largest_smallest_integers([])})\"\
    \nputs \"largest_smallest_integers([0]) == (#{largest_smallest_integers([0])})\"\
    \nputs \"largest_smallest_integers([-1, -2, -3, -4, -5]) == (#{largest_smallest_integers([-1,\
    \ -2, -3, -4, -5])})\"", "  if lst.empty?\n    return [nil, nil]\n  end\n  negatives\
    \ = lst.select { |num| num < 0 }\n  positives = lst.select { |num| num > 0 }\n\
    \  negatives.max ||= nil\n  positives.min ||= nil\n  [negatives.max, positives.min]\n\
    end", "  if lst.select { |num| num < 0 }.length > 0\n    a = lst.select { |num|\
    \ num < 0 }.max\n  else\n    a = nil\n  end\n  if lst.select { |num| num > 0 }.length\
    \ > 0\n    b = lst.select { |num| num > 0 }.min\n  else\n    b = nil\n  end\n\
    \  return [a, b]\nend", "  pos = lst.select { |x| x > 0 }.min\n  neg = lst.select\
    \ { |x| x < 0 }.max\n  pos = None if pos.nil?\n  neg = None if neg.nil?\n  return\
    \ neg, pos\nend", "    if lst.empty?\n        return [nil, nil]\n    end\n   \
    \ pos = []\n    neg = []\n    lst.each do |n|\n        if n > 0\n            pos\
    \ << n\n        elsif n < 0\n            neg << n\n        end\n    end\n    pos.empty?\
    \ ? pos << nil : pos.sort!\n    neg.empty? ? neg << nil : neg.sort!.reverse!\n\
    \    [neg[0], pos[0]]\nend", "  # TODO: Write me\n  positives = []\n  negatives\
    \ = []\n  lst.each do |x|\n    if x < 0\n      negatives << x\n    elsif x > 0\n\
    \      positives << x\n    end\n  end\n  return [negatives.max, positives.min]\n\
    end", "  negatives = lst.select { |x| x < 0 }\n  positives = lst.select { |x|\
    \ x > 0 }\n  negatives.max || negatives.first, positives.min || positives.first\n\
    end", "\tpositive_arr = []\n\tnegative_arr = []\n\tlst.each do |num|\n\t\tif num\
    \ < 0\n\t\t\tnegative_arr << num\n\t\tend\n\t\tif num > 0\n\t\t\tpositive_arr\
    \ << num\n\t\tend\n\tend\n\t\n\tif negative_arr.length > 0\n\t\tlargest_neg =\
    \ negative_arr.sort.last\n\telse\n\t\tlargest_neg = nil\n\tend\n\t\n\tif positive_arr.length\
    \ > 0\n\t\tsmallest_pos = positive_arr.sort.first\n\telse\n\t\tsmallest_pos =\
    \ nil\n\tend\n\t\n\treturn largest_neg, smallest_pos\nend", "    if !lst.any?\
    \ { |num| num < 0 } && !lst.any? { |num| num > 0 }\n        return [nil, nil]\n\
    \    elsif !lst.any? { |num| num < 0 }\n        return [nil, lst.min]\n    elsif\
    \ !lst.any? { |num| num > 0 }\n        return [lst.max, nil]\n    else\n     \
    \   return [lst.max, lst.min]\n    end\nend", "  positive = []\n  negative = []\n\
    \  lst.each do |n|\n    if n > 0\n      positive << n\n    elsif n < 0\n     \
    \ negative << n\n    end\n  end\n  positive = positive.min\n  negative = negative.max\n\
    \  return [negative, positive]\nend", "\ta = b = nil\n\tif lst.empty?\n\t\ta =\
    \ b = nil\n\tend\n\tif lst.any? { |x| x < 0 }\n\t\ta = lst.find_all { |x| x <\
    \ 0 }.max\n\tend\n\tif lst.any? { |x| x > 0 }\n\t\tb = lst.find_all { |x| x >\
    \ 0 }.min\n\tend\n\treturn a, b\nend\nputs largest_smallest_integers([2, 4, 1,\
    \ 3, 5, 7]) == (nil, 1)\nputs largest_smallest_integers([]) == (nil, nil)\nputs\
    \ largest_smallest_integers([0]) == (nil, nil)\nputs largest_smallest_integers([-3,\
    \ -5, -1, -9]) == (-1, nil)\nputs largest_smallest_integers([-8, -1, -5, -9])\
    \ == (-1, nil)\nputs largest_smallest_integers([-1, -5, -8, -9]) == (-1, nil)\n\
    puts largest_smallest_integers([1, -5, -8, -9]) == (-8, 1)\nputs largest_smallest_integers([-5,\
    \ -8, -9, 1]) == (-5, 1)\nputs largest_smallest_integers([-5, -8, -9, -1]) ==\
    \ (-1, nil)\nputs largest_smallest_integers([1, 9, 5, 8]) == (nil, 1)\nputs largest_smallest_integers([5,\
    \ 9, 8, 1]) == (nil, 1)\nputs largest_smallest_integers([8, 9, 5, 1]) == (nil,\
    \ 1)\nputs largest_smallest_integers([1, 5, 8, 9]) == (nil, 1)\nputs largest_smallest_integers([1,\
    \ -5, -8, 9]) == (-5, 1)\nputs largest_smallest_integers([-5, -8, 9, 1]) == (-5,\
    \ 1)\nputs largest_small", "  negatives = []\n  positives = []\n  for i in lst\n\
    \    if i > 0\n      positives << i\n    elsif i < 0\n      negatives << i\n \
    \   end\n  end\n  return negatives.min, positives.min\nend", "  positives = lst.select\
    \ { |i| i > 0 }\n  negatives = lst.select { |i| i < 0 }\n  return [negatives.max,\
    \ positives.min] if positives.length > 0 && negatives.length > 0\n  [nil, nil]\n\
    end", "  negative_max = nil\n  positive_min = nil\n  lst.each do |n|\n    if n\
    \ < 0\n      negative_max = n if negative_max.nil? || n > negative_max\n    elsif\
    \ n > 0\n      positive_min = n if positive_min.nil? || n < positive_min\n   \
    \ end\n  end\n  [negative_max, positive_min]\nend", "  if lst.length == 0\n  \
    \  return [nil, nil]\n  end\n  negatives = []\n  positives = []\n  lst.each do\
    \ |num|\n    if num > 0\n      positives << num\n    elsif num < 0\n      negatives\
    \ << num\n    end\n  end\n  if negatives.length == 0 || positives.length == 0\n\
    \    return [negatives.max, positives.min]\n  end\n  [negatives.max, positives.min]\n\
    end", "  lst.select{|i| i<0}.max, lst.select{|i| i>0}.min\nend", "  pos_int, neg_int\
    \ = lst.partition { |x| x > 0 }.map { |x| x.minmax.reverse }\n  [neg_int[0], pos_int[0]]\n\
    end", "    if lst.count > 0\n        a = b = nil\n        lst.each { |val| val\
    \ > 0 ? b = b ? [b, val].min : val : a = a ? [a, val].max : val }\n        [a,\
    \ b]\n    else\n        [nil, nil]\n    end\nend", "  # your code here\nend",
  "  positive = []\n  negative = []\n  lst.each do |n|\n    n > 0 ? positive << n\
    \ : n < 0 ? negative << n : n\n  end\n  (negative.empty? ? negative << nil : negative.sort).last,\
    \ (positive.empty? ? positive << nil : positive.sort).first\nend", "  if lst.length\
    \ == 0\n    return [nil, nil]\n  end\n  max_neg = nil\n  min_pos = nil\n  lst.each\
    \ do |num|\n    if num < 0 && (max_neg == nil || num > max_neg)\n      max_neg\
    \ = num\n    elsif num > 0 && (min_pos == nil || num < min_pos)\n      min_pos\
    \ = num\n    end\n  end\n  return [max_neg, min_pos]\nend", "\tlargest_neg, largest_pos\
    \ = nil, nil\n\tlst.each do |x|\n\t\tlargest_neg = x if largest_neg.nil? || x\
    \ < largest_neg\n\t\tlargest_pos = x if largest_pos.nil? || x > largest_pos\n\t\
    end\n\t[largest_neg, largest_pos]\nend", "  # your code here\nend", "  largest_negative\
    \ = nil\n  smallest_positive = nil\n  lst.each do |num|\n    if num < 0 && (largest_negative.nil?\
    \ || num > largest_negative)\n      largest_negative = num\n    elsif num > 0\
    \ && (smallest_positive.nil? || num < smallest_positive)\n      smallest_positive\
    \ = num\n    end\n  end\n  return largest_negative, smallest_positive\nend", " \
    \ positive = lst.select { |x| x > 0 }.min || nil\n  negative = lst.select { |x|\
    \ x < 0 }.max || nil\n  [negative, positive]\nend", "  negatives = lst.select\
    \ { |num| num < 0 }\n  positives = lst.select { |num| num > 0 }\n  largest_negative\
    \ = negatives.max\n  smallest_positive = positives.min\n  p [largest_negative,\
    \ smallest_positive]\nend", "  if lst.any?\n    if lst.any? { |x| x > 0 }\n  \
    \    if lst.any? { |x| x < 0 }\n        return lst.select { |x| x < 0 }.max, lst.select\
    \ { |x| x > 0 }.min\n      else\n        return lst.select { |x| x < 0 }.max,\
    \ lst.select { |x| x > 0 }.min\n      end\n    else\n      return lst.select {\
    \ |x| x < 0 }.max, lst.select { |x| x > 0 }.min\n    end\n  else\n    return nil,\
    \ nil\n  end\nend", "  return nil, nil if lst.empty?\n  return nil, nil if lst.all?(&:zero?)\n\
    \  only_ints = lst.select(&:integer?)\n  return nil, nil if only_ints.empty?\n\
    \  negatives = only_ints.select(&:negative?)\n  positives = only_ints.select(&:positive?)\n\
    \  return negatives.max, positives.min\nend", "  a = nil\n  b = nil\n  if lst.empty?\
    \ == true\n    a = nil\n    b = nil\n  elsif lst.min > 0\n    a = nil\n    b =\
    \ lst.min\n  elsif lst.max < 0\n    a = lst.max\n    b = nil\n  else\n    a =\
    \ lst.max_by { |e| e.negative? ? e : 0 }\n    b = lst.min_by { |e| e.positive?\
    \ ? e : 0 }\n  end\n  return a, b\nend", "  negatives = []\n  positives = []\n\
    \  tuple = [None, None]\n  lst.each do |num|\n    if num > 0\n      positives\
    \ << num\n    elsif num < 0\n      negatives << num\n    end\n  end\n  if negatives.length\
    \ == 0\n    tuple[0] = nil\n  else\n    tuple[0] = negatives.max\n  end\n  if\
    \ positives.length == 0\n    tuple[1] = nil\n  else\n    tuple[1] = positives.min\n\
    \  end\n  tuple\nend", "  # your code here\nend", "  positives = lst.select {\
    \ |x| x >= 0 }\n  negatives = lst.select { |x| x < 0 }\n  return positives.first,\
    \ negatives.last\nend", "  largest_neg = nil\n  smallest_pos = nil\n  lst.each\
    \ do |n|\n    if n < 0\n      largest_neg = n if largest_neg.nil?\n      largest_neg\
    \ = n if n > largest_neg\n    end\n    if n > 0\n      smallest_pos = n if smallest_pos.nil?\n\
    \      smallest_pos = n if n < smallest_pos\n    end\n  end\n  [largest_neg, smallest_pos]\n\
    end", "  # write your code here\nend", "  positive = lst.select { |num| num >\
    \ 0 }.sort\n  negative = lst.select { |num| num < 0 }.sort\n  return [negative.last,\
    \ positive.first]\nend", "  return [nil, nil] if lst.all?(0)\n  sorted = lst.sort\n\
    \  max_neg = sorted.select { |int| int < 0 }.max\n  min_pos = sorted.select {\
    \ |int| int > 0 }.min\n  [max_neg, min_pos]\nend", "  positives = lst.reject {\
    \ |num| num < 0 }\n  negatives = lst.reject { |num| num > 0 }\n  p negatives\n\
    \  if negatives.length == 0\n    negatives = nil\n  end\n  if positives.length\
    \ == 0\n    positives = nil\n  end\n  if negatives != nil\n    negatives = negatives.max\n\
    \  end\n  if positives != nil\n    positives = positives.min\n  end\n  return\
    \ negatives, positives\nend", "  #puts \"#{lst}\"\n  a = lst.find_all {|i| i <\
    \ 0}\n  b = lst.find_all {|i| i > 0}\n  #puts \"#{a}\"\n  #puts \"#{b}\"\n  #puts\
    \ \"max of a is: #{a.max}\"\n  #puts \"min of b is: #{b.min}\"\n  if a == []\n\
    \    a = nil\n  else\n    a = a.max\n  end\n  if b == []\n    b = nil\n  else\n\
    \    b = b.min\n  end\n  puts \"(#{a}, #{b})\"\nend", "  return [nil, nil] if\
    \ lst.empty?\n  max_negative, min_positive = nil, nil\n  lst.each do |int|\n \
    \   if int.negative?\n      max_negative = int if !max_negative || int > max_negative\n\
    \    elsif int.positive?\n      min_positive = int if !min_positive || int < min_positive\n\
    \    end\n  end\n  [max_negative, min_positive]\nend", "  # your code here\nend",
  "  if lst.any? { |n| n.is_a?(Integer) }\n    [lst.select{ |i| i < 0 }.max, lst.select{\
    \ |i| i > 0 }.min]\n  else\n    [nil, nil]\n  end\nend", "  neg = lst.select {\
    \ |x| x < 0 }.max\n  pos = lst.select { |x| x > 0 }.min\n  [neg, pos]\nend", " \
    \ # your code here\nend", "  # your code here\nend", "  max = nil\n  min = nil\n\
    \  lst.each do |n|\n    if n >= 0\n      if min.nil? || n < min\n        min =\
    \ n\n      end\n    else\n      if max.nil? || n > max\n        max = n\n    \
    \  end\n    end\n  end\n  return max, min\nend", "  if lst.length == 0 || lst.all?\
    \ { |num| num == 0 }\n    return [nil, nil]\n  elsif lst.all? { |num| num < 0\
    \ }\n    return lst.min, nil\n  elsif lst.all? { |num| num > 0 }\n    return nil,\
    \ lst.min\n  else\n    return lst.select { |num| num < 0 }.max, lst.select { |num|\
    \ num > 0 }.min\n  end\nend", "\tnegs = lst.select { |num| num < 0 }\n\tpos =\
    \ lst.select { |num| num > 0 }\n\tif negs.empty? && pos.empty?\n\t\t[nil, nil]\n\
    \telsif negs.empty?\n\t\t[nil, pos.min]\n\telsif pos.empty?\n\t\t[negs.max, nil]\n\
    \telse\n\t\t[negs.max, pos.min]\n\tend\nend", "  if lst.empty?\n    return [nil,\
    \ nil]\n  end\n  negative_numbers = []\n  positive_numbers = []\n  lst.each do\
    \ |n|\n    if n < 0\n      negative_numbers << n\n    elsif n > 0\n      positive_numbers\
    \ << n\n    end\n  end\n  [negative_numbers.max, positive_numbers.min]\nend",
  "  largest_negative = lst.sort_by(&:abs).select { |n| n < 0 }.last\n  smallest_positive\
    \ = lst.sort_by(&:abs).select { |n| n > 0 }.first\n  [largest_negative, smallest_positive]\n\
    end", "  positive = []\n  negative = []\n  lst.each do |i|\n    if i > 0\n   \
    \   positive << i\n    elsif i < 0\n      negative << i\n    end\n  end\n  return\
    \ [negative.max, positive.min]\nend", "  positive_number = lst.select { |x| x\
    \ > 0 }.min\n  negative_number = lst.select { |x| x < 0 }.max\n  [negative_number,\
    \ positive_number]\nend", "\tmin_pos = nil\n\tmax_neg = nil\n\tlst.each do |x|\n\
    \t\tif x < 0 and (max_neg == nil or x > max_neg)\n\t\t\tmax_neg = x\n\t\telsif\
    \ x > 0 and (min_pos == nil or x < min_pos)\n\t\t\tmin_pos = x\n\t\tend\n\tend\n\
    \treturn max_neg, min_pos\nend", "  if lst.length == 0\n    [nil, nil]\n  else\n\
    \    largest = nil\n    smallest = nil\n    lst.each do |i|\n      if i > 0\n\
    \        if smallest == nil\n          smallest = i\n        elsif i < smallest\n\
    \          smallest = i\n        end\n      elsif i < 0\n        if largest ==\
    \ nil\n          largest = i\n        elsif i > largest\n          largest = i\n\
    \        end\n      end\n    end\n    [largest, smallest]\n  end\nend", "  return\
    \ [nil, nil] if lst.empty?\n  p lst\n  negs = lst.select{|x| x < 0}\n  pos = lst.select{|x|\
    \ x > 0}\n  [negs.max, pos.min]\nend", "  # your code here\nend", end, "  positive\
    \ = lst.select { |n| n > 0 }.min\n  negative = lst.select { |n| n < 0 }.max\n\
    \  [negative, positive]\nend", "  positive_integers = lst.select { |num| num >\
    \ 0 }\n  negative_integers = lst.select { |num| num < 0 }\n  if negative_integers.empty?\
    \ && positive_integers.empty?\n    return [nil, nil]\n  elsif negative_integers.empty?\n\
    \    return [nil, positive_integers.min]\n  elsif positive_integers.empty?\n \
    \   return [negative_integers.max, nil]\n  else\n    return [negative_integers.max,\
    \ positive_integers.min]\n  end\nend", "  a = lst.select { |n| n < 0 }.max\n \
    \ b = lst.select { |n| n > 0 }.min\n  [a, b]\nend", "  if lst.any?{|x| x > 0}\
    \ && lst.any?{|x| x < 0}\n    [lst.map{|x| x if x < 0}.compact.max, lst.map{|x|\
    \ x if x > 0}.compact.min]\n  else\n    [nil, nil]\n  end\nend", "  new_lst =\
    \ lst.reject { |x| x == 0}\n  if new_lst.count == 0\n    return [nil, nil]\n \
    \ elsif new_lst.max > 0 && new_lst.min < 0\n    return [new_lst.min, new_lst.max]\n\
    \  elsif new_lst.max < 0\n    return [new_lst.max, nil]\n  elsif new_lst.min >\
    \ 0\n    return [nil, new_lst.min]\n  end\nend", "  max_neg = nil\n  min_pos =\
    \ nil\n  lst.each do |x|\n    if x < 0\n      max_neg = x if max_neg.nil? || x\
    \ > max_neg\n    elsif x > 0\n      min_pos = x if min_pos.nil? || x < min_pos\n\
    \    end\n  end\n  [max_neg, min_pos]\nend", "  negative_max = lst.select { |x|\
    \ x < 0 }.max\n  positive_min = lst.select { |x| x > 0 }.min\n  [negative_max,\
    \ positive_min]\nend", "  smallest_number = nil\n  largest_number = nil\n  lst.each\
    \ do |x|\n    if x > 0\n      if smallest_number.nil? || x < smallest_number\n\
    \        smallest_number = x\n      end\n    elsif x < 0\n      if largest_number.nil?\
    \ || x > largest_number\n        largest_number = x\n      end\n    end\n  end\n\
    \  return [largest_number, smallest_number]\nend", "  if lst.empty?\n    [nil,\
    \ nil]\n  else\n    new_lst = lst.select { |x| x != 0 }\n    pos = new_lst.select\
    \ { |x| x > 0 }\n    neg = new_lst.select { |x| x < 0 }\n    if pos.empty?\n \
    \     [neg.max, nil]\n    elsif neg.empty?\n      [nil, pos.min]\n    else\n \
    \     [neg.max, pos.min]\n    end\n  end\nend", "  negatives = lst.select { |n|\
    \ n < 0 }\n  positives = lst.select { |n| n > 0 }\n  negatives.empty? ? a = nil\
    \ : a = negatives.max\n  positives.empty? ? b = nil : b = positives.min\n  [a,\
    \ b]\nend", "  # write your code here\nend", "  #your code here\nend", "  # TODO\n\
    end", "  new_lst = lst.select{|n| n > 0 || n < 0}\n  return [nil, nil] if new_lst.empty?\n\
    \  sorted_lst = new_lst.sort\n  return [sorted_lst.first, sorted_lst.last]\nend",
  "\treturn [lst.select{|n| n < 0}.max, lst.select{|n| n > 0}.min] if lst.size > 0\
    \ \n\t[nil, nil]\nend", "  a = lst.select { |x| x < 0 }.max\n  b = lst.select\
    \ { |x| x > 0 }.min\n  if a.nil?\n    a = nil\n  end\n  if b.nil?\n    b = nil\n\
    \  end\n  return [a, b]\nend", "  positives = []\n  negatives = []\n  lst.each\
    \ do |num|\n    if num > 0\n      positives << num\n    elsif num < 0\n      negatives\
    \ << num\n    end\n  end\n  if negatives.length == 0\n    negatives << nil\n \
    \ end\n  if positives.length == 0\n    positives << nil\n  end\n  [negatives.max,\
    \ positives.min]\nend", "  min = nil\n  max = nil\n  lst.each do |i|\n    if i\
    \ < 0\n      max = i if max.nil? || i > max\n    elsif i > 0\n      min = i if\
    \ min.nil? || i < min\n    end\n  end\n  return max, min\nend", "  lst.keep_if\
    \ { |num| num < 0 }\n  lst.max", "  min, max = nil, nil\n  lst.each do |x|\n \
    \   if x >= 0\n      min = x if min.nil? || x < min\n    else\n      max = x if\
    \ max.nil? || x > max\n    end\n  end\n  [max, min]\nend", " \nend", "  negatives\
    \ = []\n  positives = []\n  if lst.all? { |num| num == 0 }\n    return [nil, nil]\n\
    \  else\n    lst.each do |num|\n      if num > 0\n        positives << num\n \
    \     elsif num < 0\n        negatives << num\n      end\n    end\n    return\
    \ [negatives.max, positives.min]\n  end\nend", "  smallest = lst.min\n  largest\
    \ = lst.max\n  return [largest, smallest]\nend", "  arr = lst.reject { |n| n ==\
    \ 0 }\n  return [nil, nil] if arr.empty?\n  smallest = arr.min\n  largest = arr.max\n\
    \  [arr.select { |n| n < 0 }.max, arr.select { |n| n > 0 }.min]\nend", "  pos\
    \ = []\n  neg = []\n  [pos, neg] = lst.partition { |x| x > 0 }\n  pos.empty? ?\
    \ b = nil : b = pos.min\n  neg.empty? ? a = nil : a = neg.max\n  return a, b\n\
    end", "  # your code here\nend", "  a = lst.max_by { |x| x < 0 ? x : -x } || nil\n\
    \  b = lst.min_by { |x| x > 0 ? x : -x } || nil\n  [a, b]\nend", "    largest_negative\
    \ = nil\n    smallest_positive = nil\n    for value in lst\n        if value <\
    \ 0\n            if largest_negative == nil\n                largest_negative\
    \ = value\n            elsif value > largest_negative\n                largest_negative\
    \ = value\n            end\n        elsif value > 0\n            if smallest_positive\
    \ == nil\n                smallest_positive = value\n            elsif value <\
    \ smallest_positive\n                smallest_positive = value\n            end\n\
    \        end\n    end\n    (largest_negative, smallest_positive)\nend", "  if\
    \ lst.empty?\n    return [nil, nil]\n  elsif lst.none? { |e| e < 0 } && lst.none?\
    \ { |e| e > 0 }\n    return [nil, nil]\n  elsif lst.none? { |e| e < 0 }\n    return\
    \ [nil, lst.min]\n  elsif lst.none? { |e| e > 0 }\n    return [lst.max, nil]\n\
    \  else\n    return [lst.max, lst.min]\n  end\nend", "  if lst.length == 0\n \
    \   return [nil, nil]\n  end\n  negatives = []\n  positives = []\n  lst.each do\
    \ |num|\n    if num > 0\n      positives << num\n    elsif num < 0\n      negatives\
    \ << num\n    end\n  end\n  puts negatives\n  puts positives\n  return [negatives.max,\
    \ positives.min]\nend", "  negs = []\n  lst.each do |i|\n    if i < 0\n      negs\
    \ << i\n    end\n  end\n  pos = []\n  lst.each do |i|\n    if i > 0\n      pos\
    \ << i\n    end\n  end\n  return [negs.max, pos.min]\nend", "  if lst.length >\
    \ 0\n    new_lst = lst.select{|x| x > 0 || x < 0}.sort\n    if new_lst.length\
    \ > 0\n      [new_lst.first, new_lst.last]\n    else\n      [nil, nil]\n    end\n\
    \  else\n    [nil, nil]\n  end\nend", "  if lst.empty?\n    return [nil, nil]\n\
    \  elsif lst.count(0) == lst.size\n    return [nil, nil]\n  else\n    lst.reject!\
    \ { |x| x <= 0 }\n    lst.sort!\n    smallest = lst[0]\n    lst.reject! { |x|\
    \ x >= 0 }\n    lst.sort!.reverse!\n    largest = lst[0]\n    return [largest,\
    \ smallest]\n  end\nend", "  def inner(a, b, lst)\n    return [a, b] if lst.empty?\n\
    \    first, *rest = lst\n    a = first if first < 0 && (a.nil? || first > a)\n\
    \    b = first if first > 0 && (b.nil? || first < b)\n    inner(a, b, rest)\n\
    \  end\n  result = inner(nil, nil, lst)\n  result.map! { |e| e.nil? ? None : e\
    \ }\n  result\nend", "  if lst.empty?\n    return [nil, nil]\n  end\n  min = nil\n\
    \  max = nil\n  lst.each do |e|\n    if e < 0\n      max = e if max.nil? || e\
    \ > max\n    elsif e > 0\n      min = e if min.nil? || e < min\n    end\n  end\n\
    \  [max, min]\nend", "\tlst.sort\n\tn_max, n_min = nil, nil\n\tlst.each { |n|\
    \ n < 0 ? n_max = n : n_min = n if n_min == nil && n < 0; break if n > 0 }\n\t\
    [n_max, n_min]\nend", "  a = lst.select { |n| n < 0 }.max\n  b = lst.select {\
    \ |n| n > 0 }.min\n  a.nil? ? a = nil : a\n  b.nil? ? b = nil : b\n  return a,\
    \ b\nend", "  a = lst.select { |x| x < 0 }.max\n  b = lst.select { |x| x > 0 }.min\n\
    \  [a || nil, b || nil]\nend", "  big = lst.select { |x| x < 0 }.max\n  small\
    \ = lst.select { |x| x > 0 }.min\n  [big, small]\nend", "  new_list = []\n  lst.each\
    \ do |number|\n    new_list << number if number < 0\n  end\n  if new_list.empty?\n\
    \    a = nil\n  else\n    a = new_list.max\n  end\n  new_list = []\n  lst.each\
    \ do |number|\n    new_list << number if number > 0\n  end\n  if new_list.empty?\n\
    \    b = nil\n  else\n    b = new_list.min\n  end\n  return a, b\nend\nputs \"\
    ------------Largest/Smallest Integers------------\"\nputs largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]) == [nil, 1]\nputs largest_smallest_integers([]) == [nil, nil]\n\
    puts largest_smallest_integers([0]) == [nil, nil]\nputs largest_smallest_integers([-1,\
    \ 1]) == [-1, 1]\nputs largest_smallest_integers([-1, -2, 1, 2]) == [-2, 1]\n\
    puts largest_smallest_integers([-1, -2, -1, -2]) == [-2, nil]\nputs largest_smallest_integers([1,\
    \ 2, 1, 2]) == [nil, 1]\nputs", "  # get lst of positive and negative numbers\n\
    \  if lst.length > 0\n    pos_nums = lst.select { |x| x > 0 }\n    neg_nums =\
    \ lst.select { |x| x < 0 }\n    # if there are pos/neg nums in the list\n    if\
    \ pos_nums.length > 0 && neg_nums.length > 0\n      return (neg_nums.max, pos_nums.min)\n\
    \    else\n      return (nil, nil)\n    end\n  else\n    return (nil, nil)\n \
    \ end\nend", end, "  if lst.all? { |x| x > 0 || x < 0 }\n    return (lst.max,\
    \ lst.min)\n  elsif lst.all? { |x| x > 0 }\n    return (None, lst.min)\n  elsif\
    \ lst.all? { |x| x < 0 }\n    return (lst.max, None)\n  else\n    return (None,\
    \ None)\n  end\nend", "  min_pos_num = nil\n  max_neg_num = nil\n  lst.each do\
    \ |num|\n    if num > 0\n      min_pos_num = num if min_pos_num.nil? || num <\
    \ min_pos_num\n    elsif num < 0\n      max_neg_num = num if max_neg_num.nil?\
    \ || num > max_neg_num\n    end\n  end\n  [max_neg_num, min_pos_num]\nend", " \
    \ min, max = nil, nil\n  lst.each do |i|\n    if i < 0\n      max = i if max.nil?\
    \ || i > max\n    elsif i > 0\n      min = i if min.nil? || i < min\n    end\n\
    \  end\n  [max, min]\nend", "  if lst.length.zero?\n    return [nil, nil]\n  end\n\
    \  negatives = lst.select { |n| n < 0 }\n  positives = lst.select { |n| n > 0\
    \ }\n  [negatives.max, positives.min]\nend", '  return [nil, nil] if lst.empty?',
  "  negative_lst = lst.select { |el| el < 0 }\n  positive_lst = lst.select { |el|\
    \ el > 0 }\n  return [negative_lst.max, positive_lst.min]\nend", "  negative =\
    \ []\n  positive = []\n  result = []\n  lst.each do |x|\n    if x < 0\n      negative\
    \ << x\n    elsif x > 0\n      positive << x\n    end\n  end\n  if negative.length\
    \ > 0\n    result << negative.max\n  else\n    result << nil\n  end\n  if positive.length\
    \ > 0\n    result << positive.min\n  else\n    result << nil\n  end\n  result\n\
    end", "\t# a = lst.select { |x| x < 0 }.max\n\t# b = lst.select { |x| x > 0 }.min\n\
    \t# [a, b]\n\tif lst.all? { |x| x <= 0 }\n\t\ta = lst.max\n\telse\n\t\ta = nil\n\
    \tend\n\tif lst.all? { |x| x >= 0 }\n\t\tb = lst.min\n\telse\n\t\tb = nil\n\t\
    end\n\t[a, b]\nend", "  return [nil, nil] if lst.length == 0 || lst.uniq == [0]\n\
    \  lst.uniq.sort\n  if lst.min < 0\n    largest = lst.select { |num| num < 0 }.max\n\
    \  else\n    largest = nil\n  end\n  if lst.max > 0\n    smallest = lst.select\
    \ { |num| num > 0 }.min\n  else\n    smallest = nil\n  end\n  [largest, smallest]\n\
    end", "  return [nil, nil] if lst.length == 0\n  negative_numbers = []\n  positive_numbers\
    \ = []\n  lst.each do |num|\n    if num > 0\n      positive_numbers << num\n \
    \   elsif num < 0\n      negative_numbers << num\n    end\n  end\n  sorted_positive_numbers\
    \ = positive_numbers.sort\n  sorted_negative_numbers = negative_numbers.sort\n\
    \  smallest_positive_number = sorted_positive_numbers[0]\n  largest_negative_number\
    \ = sorted_negative_numbers[-1]\n  [largest_negative_number, smallest_positive_number]\n\
    end", "  neg_lst = []\n  pos_lst = []\n  lst.each do |num|\n    if num < 0\n \
    \     neg_lst << num\n    elsif num > 0\n      pos_lst << num\n    end\n  end\n\
    \  if neg_lst.length > 0\n    neg_sort = neg_lst.sort\n    a = neg_sort[-1]\n\
    \  else\n    a = nil\n  end\n  if pos_lst.length > 0\n    pos_sort = pos_lst.sort\n\
    \    b = pos_sort[0]\n  else\n    b = nil\n  end\n  return a, b\nend", "  if lst.empty?\n\
    \    return [nil, nil]\n  elsif lst.all?(&:zero?)\n    return [nil, nil]\n  else\n\
    \    max = lst.select { |x| x < 0 }.max\n    min = lst.select { |x| x > 0 }.min\n\
    \    return [max, min]\n  end\nend", "  return [nil, nil] if lst.length == 0\n\
    \  return [nil, nil] if lst.length == 1 && lst[0] == 0\n  pos = []\n  neg = []\n\
    \  lst.each do |i|\n    if i < 0\n      neg << i\n    elsif i > 0\n      pos <<\
    \ i\n    end\n  end\n  neg.length == 0 ? neg = nil : neg = neg.max\n  pos.length\
    \ == 0 ? pos = nil : pos = pos.min\n  [neg, pos]\nend", "  positive = []\n  negative\
    \ = []\n  positive << lst.select { |n| n > 0 }\n  negative << lst.select { |n|\
    \ n < 0 }\n  return [negative.max, positive.min]\nend", "  lst = lst.map(&:to_i)\n\
    \  neg = lst.select { |num| num < 0 }.max\n  pos = lst.select { |num| num > 0\
    \ }.min\n  [neg, pos]\nend", "  a = lst.select { |n| n < 0 }.max\n  b = lst.select\
    \ { |n| n > 0 }.min\n  a = nil if a.nil? && b.nil?\n  b = nil if b.nil?\n  [a,\
    \ b]\nend", "  # code here\nend", "  small = nil\n  large = nil\n  lst.each do\
    \ |i|\n    if i >= 0\n      small = i if small.nil? || i < small\n    else\n \
    \     large = i if large.nil? || i > large\n    end\n  end\n  [large, small]\n\
    end", "  if lst.any?\n    sorted = lst.sort.delete_if { |e| e == 0 }\n    return\
    \ sorted.first < 0 ? [sorted.first, sorted.last] : [nil, sorted.first]\n  else\n\
    \    return [nil, nil]\n  end\nend", '  return [nil, nil] if lst.empty? || (lst.all?
    { |x| x == 0 })', "  (lst.select{|x| x<0}.max),(lst.select{|x| x>0}.min)\nend",
  "  neg_max = []\n  pos_min = []\n  if lst.empty?\n    return [nil, nil]\n  end\n\
    \  lst.each do |i|\n    if i < 0\n      neg_max << i\n    elsif i > 0\n      pos_min\
    \ << i\n    end\n  end\n  if neg_max.empty?\n    neg_max = nil\n  end\n  if pos_min.empty?\n\
    \    pos_min = nil\n  end\n  return [neg_max.max, pos_min.min]\nend", "  lst.sort!\n\
    \  a = b = nil\n  lst.each do |n|\n    if n > 0\n      b = n\n      break\n  \
    \  end\n    a = n if n < 0\n  end\n  [a, b]\nend", "  a = lst.select { |x| x <\
    \ 0 }.max\n  b = lst.select { |x| x > 0 }.min\n  a.nil? ? a = nil : a\n  b.nil?\
    \ ? b = nil : b\n  [a, b]\nend", "  # TODO: write your code here\nend", "  negatives\
    \ = lst.select { |num| num < 0 }\n  positives = lst.select { |num| num > 0 }\n\
    \  [negatives.empty? ? nil : negatives.max, positives.empty? ? nil : positives.min]\n\
    end", "  return [nil, nil] if lst.empty?\n  lst.reject! { |e| e == 0 }\n  lst.sort!\n\
    \  lst.reverse!\n  return [lst[-1], lst[0]] if lst.length == 1\n  [lst[lst.length\
    \ - 2], lst[1]]\nend", "    # Find the largest negative integer (a)\n    # Find\
    \ the smallest positive integer (b)\n    # Return a tuple (a, b)\nend", "  negative_number\
    \ = lst.select { |num| num < 0 }.max\n  positive_number = lst.select { |num| num\
    \ > 0 }.min\n  return negative_number, positive_number\nend", "  a = lst.select\
    \ { |x| x <= 0 }.max\n  b = lst.select { |x| x >= 0 }.min\n  if a == nil\n   \
    \ a = nil\n  end\n  if b == nil\n    b = nil\n  end\n  [a, b]\nend", "  negatives\
    \ = lst.select { |x| x < 0 }\n  positives = lst.select { |x| x > 0 }\n  negatives.max\
    \ ? a = negatives.max : a = nil\n  positives.min ? b = positives.min : b = nil\n\
    \  return a, b\nend", "  if lst.length == 0\n    return [nil, nil]\n  end\n  pos\
    \ = lst.sort.last\n  neg = lst.sort.first\n  if pos <= 0 || neg >= 0\n    return\
    \ [nil, nil]\n  end\n  return [neg, pos]\nend", "\tmin = nil\n\tmax = nil\n\t\
    lst.each do |num|\n\t\tif num > 0 && (min == nil || num < min)\n\t\t\tmin = num\n\
    \t\telsif num < 0 && (max == nil || num > max)\n\t\t\tmax = num\n\t\tend\n\tend\n\
    \treturn max, min\nend", "\tpos = lst.select { |i| i > 0 }.min\n\tneg = lst.select\
    \ { |i| i < 0 }.max\n\tpos = neg = nil if lst.all? { |i| i == 0 }\n\t[neg, pos]\n\
    end"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
