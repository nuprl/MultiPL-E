name: HumanEval_147_get_max_triples
language: rb
prompt: "# You are given a positive integer n. You have to create an integer array\
  \ a of length n.\n# For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i\
  \ - i + 1.\n# Return the number of triples (a[i], a[j], a[k]) of a where i < j <\
  \ k, \n# and a[i] + a[j] + a[k] is a multiple of 3.\n# Example :\n# Input: n = 5\n\
  # Output: 1\n# Explanation: \n# a = [1, 3, 7, 13, 21]\n# The only valid triple is\
  \ (1, 7, 13).\ndef get_max_triples(n)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_get_max_triples\n\
  \    candidate = method(:get_max_triples)\n    assert_equal(1, candidate.call(5))\n\
  \    assert_equal(4, candidate.call(6))\n    assert_equal(36, candidate.call(10))\n\
  \    assert_equal(53361, candidate.call(100))\n  end\nend\n"
completions: ["    return 0 if n < 3\n    a = [1]\n    (1..n-1).each do |i|\n    \
    \    a << i * i - i + 1\n    end\n    valid_triples = 0\n    (0..n-3).each do\
    \ |i|\n        (i+1..n-2).each do |j|\n            (j+1..n-1).each do |k|\n  \
    \              valid_triples += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n         \
    \   end\n        end\n    end\n    valid_triples\nend", "  a = Array.new(n) {\
    \ |i| i + 1 }\n  a = a.map{ |el| el * el - el + 1 }\n  a\nend", "    a = []\n\
    \    (1..n).each do |i|\n        a.push(i * i - i + 1)\n    end\n    count = 0\n\
    \    (0..n-3).each do |i|\n        ((i+1)..n-2).each do |j|\n            ((j+1)..n-1).each\
    \ do |k|\n                if (a[i] + a[j] + a[k]) % 3 == 0\n                 \
    \   count += 1\n                end\n            end\n        end\n    end\n \
    \   return count\nend", "    triples = 0\n    a = Array.new(n)\n    a[0] = 1\n\
    \    a[1] = 3\n    (2..n-1).each do |i|\n        a[i] = i*i - i + 1\n    end\n\
    \    (2..n-1).each do |j|\n        ((j+1)..n-1).each do |k|\n            if (a[j]\
    \ + a[k]) % 3 == 0\n                if j > 1\n                    triples += (j-1)\n\
    \                end\n            end\n        end\n    end\n    return triples\n\
    end\nputs get_max_triples(100)", "\tarr = Array.new(n) { |i| i*i - i + 1 }\n\t\
    count = 0\n\t(0..n-3).each do |i|\n\t\t(i+1..n-2).each do |j|\n\t\t\t(j+1..n-1).each\
    \ do |k|\n\t\t\t\tcount += 1 if (arr[i] + arr[j] + arr[k]) % 3 == 0\n\t\t\tend\n\
    \t\tend\n\tend\n\tcount\nend", "  return 0 if n < 3\n  arr = []\n  arr_len = 0\n\
    \  for i in (1..n)\n    val = i * i - i + 1\n    return i if val % 3 == 0\n  \
    \  if val >= 6\n      arr[arr_len] = val\n      arr_len += 1\n    end\n  end\n\
    \  find_max_triples(arr, arr_len)\nend", "  count = 0\n  (1..n).each do |a|\n\
    \    (a+1..n).each do |b|\n      (b+1..n).each do |c|\n        count += 1 if (a\
    \ + b + c) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  a = Array.new(n)\n\
    \  for i in 1..n\n    a[i-1] = i * i - i + 1\n  end\n  cnt = 0\n  for i in 0..n-3\n\
    \    for j in i+1..n-2\n      for k in j+1..n-1\n        cnt += 1 if a[i] + a[j]\
    \ + a[k] % 3 == 0\n      end\n    end\n  end\n  cnt\nend", "  return 0 if n <\
    \ 3\n  a = (1..n).map { |i| i * i - i + 1 }\n  cnt = 0\n  (0..n-3).each do |i|\n\
    \    (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        cnt += 1 if\
    \ a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n  cnt\nend", "    #\
    \ Write your code here\n    count = 0\n    1.upto(n-2) do |a|\n        (a+1).upto(n-1)\
    \ do |b|\n            (b+1).upto(n) do |c|\n                if (a*a - a + 1 +\
    \ b*b - b + 1 + c*c - c + 1) % 3 == 0\n                    count += 1\n      \
    \          end\n            end\n        end\n    end\n    count\nend", "  # a[i]\
    \ = i * i - i + 1\n  # => a[i] = i * (i - 1) + 1\n  #\n  # a[i] = i * i - i +\
    \ 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i]\
    \ = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1)\
    \ + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i]\
    \ = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1)\
    \ + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i]\
    \ = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1)\
    \ + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i]\
    \ = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1)\
    \ + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i]\
    \ = i * (i - 1) + 1\n  # => a[i] = i * (i - 1) + 1\n  # => a[i] = i * (i - 1)\
    \ + 1\n  # => a[i] = i *", "  a = []\n  (1..n).each do |i|\n    a << i * i - i\
    \ + 1\n  end\n  count = 0\n  (0..a.length - 3).each do |i|\n    (i + 1..a.length\
    \ - 2).each do |j|\n      (j + 1..a.length - 1).each do |k|\n        if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n          count += 1\n        end\n      end\n    end\n\
    \  end\n  count\nend", "  # write your code here\n  return 0 if n < 3\n  a = []\n\
    \  count = 0\n  (1..n).each do |i|\n    a << i * i - i + 1\n  end\n  (0..n-3).each\
    \ do |i|\n    ((i+1)..n-2).each do |j|\n      (j+1..n-1).each do |k|\n       \
    \ count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\n\
    end", "    a = Array.new(n)\n    a[0] = 1\n    for i in 1..n-1\n        a[i] =\
    \ i * i - i + 1\n    end\n    puts a.inspect\n    count = 0\n    for i in 0..n-3\n\
    \        for j in i+1..n-2\n            for k in j+1..n-1\n                if\
    \ (a[i] + a[j] + a[k]) % 3 == 0\n                    puts \"(#{a[i]}, #{a[j]},\
    \ #{a[k]})\"\n                    count += 1\n                end\n          \
    \  end\n        end\n    end\n    count\nend", "    if n < 3\n        return 0\n\
    \    end\n    a = [1]\n    max_triples = 0\n    sum = 1\n    (2..n).each do |i|\n\
    \        a[i-1] = i * i - i + 1\n        sum += a[i-1]\n        if sum % 3 ==\
    \ 0\n            max_triples += 1\n        end\n    end\n    return max_triples\n\
    end\nputs get_max_triples(5)\nputs get_max_triples(7)\nputs get_max_triples(11)\n\
    puts get_max_triples(12)", "\t# Get the array\n\ta = Array.new(n) { |i| i * i\
    \ - i + 1 }\n\ta.each_with_index.map { |num, i| a[0..i] }.flatten.combination(3).count\
    \ { |x, y, z| (x + y + z) % 3 == 0 }\nend", "  r = []\n  (1..n).each do |i|\n\
    \    (i..n).each do |j|\n      (j..n).each do |k|\n        r << [i, j, k] if (i\
    \ * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0\n      end\n    end\n\
    \  end\n  r.size\nend", "\trange = 1..n\n\ttriples = []\n\tfor a in range\n\t\t\
    for b in range\n\t\t\tfor c in range\n\t\t\t\ttriples << [a, b, c]\n\t\t\tend\n\
    \t\tend\n\tend\n\treturn triples.select { |triple| triple[0] < triple[1] && triple[1]\
    \ < triple[2] && (triple[0] + triple[1] + triple[2]) % 3 == 0 }.count\nend", " \
    \ return 0 if n < 3\n  a = (1..n).map { |i| i * i - i + 1 }\n  a.combination(3).count\
    \ { |x, y, z| (x + y + z) % 3 == 0 }\nend", "    triples = 0\n    arr = []\n \
    \   (1..n).each do |i|\n        arr << i * i - i + 1\n    end\n    (1..n-2).each\
    \ do |i|\n        (i+1..n-1).each do |j|\n            (j+1..n).each do |k|\n \
    \               if (arr[i-1] + arr[j-1] + arr[k-1]) % 3 == 0\n               \
    \     triples += 1\n                end\n            end\n        end\n    end\n\
    \    return triples\nend", "  triples = []\n  for i in 1..n-2\n    for j in i+1..n-1\n\
    \      for k in j+1..n\n        if (1*1 - 1 + 1 + 3*3 - 3 + 1 + 7*7 - 7 + 1) %\
    \ 3 == 0\n          triples << [1, 3, 7]\n        end\n      end\n    end\n  end\n\
    \  triples\nend", "  return 0 if n < 3\n  arr = []\n  for i in 1..n\n    arr.push(i\
    \ * i - i + 1)\n  end\n  count = 0\n  for i in 0..n-3\n    for j in i+1..n-2\n\
    \      for k in j+1..n-1\n        count += 1 if arr[i] + arr[j] + arr[k] % 3 ==\
    \ 0\n      end\n    end\n  end\n  count\nend", "  return 0 if n < 3\n  a = []\n\
    \  for i in 1..n\n    a << i * i - i + 1\n  end\n  result = 0\n  for i in 0..n-3\n\
    \    for j in i+1..n-2\n      for k in j+1..n-1\n        result += 1 if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  result\nend", "  arr =\
    \ []\n  for i in 1..n\n    arr << i * i - i + 1\n  end\n  count = 0\n  for i in\
    \ 0..arr.length-3\n    for j in i+1..arr.length-2\n      for k in j+1..arr.length-1\n\
    \        sum = arr[i] + arr[j] + arr[k]\n        if sum % 3 == 0\n          count\
    \ += 1\n        end\n      end\n    end\n  end\n  return count\nend\nputs get_max_triples(5)\n\
    puts get_max_triples(10)\nputs get_max_triples(13)\nputs get_max_triples(15)",
  "  a = []\n  (1..n).each { |e| a << e * e - e + 1 }\n  a.combination(3).count {\
    \ |a| a.sum % 3 == 0 }\nend", "    triples = {}\n    i = 1\n    while i < n -\
    \ 1\n        j = i + 1\n        while j < n\n            k = j + 1\n         \
    \   while k <= n\n                a_i = i * i - i + 1\n                a_j = j\
    \ * j - j + 1\n                a_k = k * k - k + 1\n                if (a_i +\
    \ a_j + a_k) % 3 == 0\n                    triples[i] = {a_i => [j, k]}\n    \
    \            end\n                k += 1\n            end\n            j += 1\n\
    \        end\n        i += 1\n    end\n    triples\nend", "    count = 0\n   \
    \ (1..n).each do |i|\n        (i+1..n).each do |j|\n            (j+1..n).each\
    \ do |k|\n                if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) %\
    \ 3 == 0\n                    count += 1\n                end\n            end\n\
    \        end\n    end\n    count\nend", "  a = (1..n).map { |i| i * i - i + 1\
    \ }\n  p a\n  (1..n-2).to_a.reduce(0) do |t, i|\n    (i+1..n-1).to_a.reduce(t)\
    \ do |t, j|\n      t + ((j+1..n).to_a.select { |k| (a[i] + a[j] + a[k]) % 3 ==\
    \ 0 }).size\n    end\n  end\nend", "  array = []\n  result = 0\n  (1..n).each\
    \ do |i|\n    array << i * i - i + 1\n  end\n  for i in 0..array.length-3\n  \
    \  for j in i+1..array.length-2\n      for k in j+1..array.length-1\n        if\
    \ array[i] + array[j] + array[k] % 3 == 0\n          result += 1\n        end\n\
    \      end\n    end\n  end\n  result\nend", "\ttriples = []\n\ta = (1..n).map\
    \ { |i| i * i - i + 1 }\n\tfor i in 0..a.length - 3\n\t\tfor j in i + 1..a.length\
    \ - 2\n\t\t\tfor k in j + 1..a.length - 1\n\t\t\t\ttriples << [a[i], a[j], a[k]]\
    \ if a[i] + a[j] + a[k] % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\ttriples.length\n\
    end", "  arr = Array.new(n) { |i| i * i - i + 1 }\n  puts \"arr = #{arr}\"\n \
    \ triples = []\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        if arr[i] + arr[j] + arr[k] % 3 == 0\n          triples << [arr[i],\
    \ arr[j], arr[k]]\n        end\n      end\n    end\n  end\n  puts \"triples =\
    \ #{triples}\"\n  triples.length\nend", "\ttriples = []\n\tindices = (0..n-1).to_a\n\
    \tfor i in 0..n-1\n\t\tfor j in i+1..n-1\n\t\t\tfor k in j+1..n-1\n\t\t\t\ttriples\
    \ << [i,j,k] if (i+j+k) % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\treturn triples\n\
    end", "  array = (1..n).map{|i| i * i - i + 1}\n  triple_hash = Hash.new{|h,k|\
    \ h[k] = []}\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        if (array[i] + array[j] + array[k]) % 3 == 0\n          triple_hash[array[i]\
    \ + array[j] + array[k]] << [array[i], array[j], array[k]]\n        end\n    \
    \  end\n    end\n  end\n  triple_hash.max_by{|k,v| v.length}\nend", "  return\
    \ 0 if n < 3\n  n > 10 ** 5 ? n = 10 ** 5 : n\n  a = []\n  for i in 1..n\n   \
    \ a << i * i - i + 1\n  end\n  count = 0\n  a.each_with_index do |num, i|\n  \
    \  for j in i + 1..n - 1\n      for k in j + 1..n\n        count += 1 if (num\
    \ + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "    a =\
    \ [1]\n    n.times do |i|\n        a << i*i - i + 1\n    end\n    count = 0\n\
    \    a.each_with_index do |item, index|\n        (index+1).upto(a.length-1) do\
    \ |index2|\n            (index2+1).upto(a.length-1) do |index3|\n            \
    \    count += 1 if a[index] + a[index2] + a[index3] % 3 == 0\n            end\n\
    \        end\n    end\n    count\nend", "  # a[i] = i^2 - i + 1\n  # a[i] + a[j]\
    \ + a[k] = 3 * (i^2 - i + 1)\n  # a[i] + a[j] + a[k] = 3 * (i-1)^2 + 4 = 3 * (i-1)^2\
    \ + 3 * (i-1) + 1\n  # a[i] + a[j] + a[k] = 3 * (i-1)^2 + 3 * (i-1) + 1\n  # 1\
    \ <= a[i] + a[j] + a[k] <= 3 * (n-1)^2 + 3 * (n-1) + 1\n  # 1 <= a[i] + a[j] +\
    \ a[k] <= 3 * (n-1)^2 + 3 * (n-1) + 1\n  count = 0\n  n.times do |i|\n    (i+1).upto(n)\
    \ do |j|\n      (j+1).upto(n) do |k|\n        # p \"i=#{i}, j=#{j}, k=#{k}\"\n\
    \        # p \"a[i]=#{i*i-i+1}, a[j]=#{j*j-j+1}, a[k]=#{k*k-k+1}\"\n        #\
    \ p \"#{i*i-i+1} + #{j*j-j+1} + #{k*k-k+1} = #{i*i-i+1 + j*j-j+1 + k*k-k+1}\"\n\
    \        count += 1 if (i*i-i+1 + j*j-j+1 + k*k-k+1) % 3 == 0\n      end\n   \
    \ end\n  end\n  count\nend", "  # Write your code here\nend", "  return 0 if n\
    \ <= 2\n  array = (1..n).map{|i| i * i - i + 1}\n  count = 0\n  (0..n-3).each\
    \ do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        count\
    \ += 1 if (array[i] + array[j] + array[k]) % 3 == 0\n      end\n    end\n  end\n\
    \  count\nend\nputs get_max_triples(5)\nputs get_max_triples(10)\nputs get_max_triples(4)\n\
    puts get_max_triples(0)", "\ta = []\n\tfor i in 1..n\n\t\ta << i * i - i + 1\n\
    \tend\n\ta\nend", "  a = (1..n).map { |el| el * el - el + 1 }\n  triples = []\n\
    \  i = 0\n  while i < a.length\n    j = i + 1\n    while j < a.length\n      k\
    \ = j + 1\n      while k < a.length\n        triples << [a[i], a[j], a[k]] if\
    \ (a[i] + a[j] + a[k]) % 3 == 0\n        k += 1\n      end\n      j += 1\n   \
    \ end\n    i += 1\n  end\n  triples.uniq.length\nend", "  a = Array.new(n,0)\n\
    \  max_triples = 0\n  for i in 1..n\n    a[i-1] = i*i - i + 1\n  end\n  for i\
    \ in 0..n-1\n    for j in i+1..n-1\n      for k in j+1..n-1\n        if a[i] +\
    \ a[j] + a[k] % 3 == 0\n          max_triples += 1\n        end\n      end\n \
    \   end\n  end\n  return max_triples\nend", "  a = Array.new(n)\n  a[0] = 1\n\
    \  (1..n-1).each do |i|\n    a[i] = i * i - i + 1\n  end\n  a.each do |i|\n  \
    \  print \"#{i} \"\n  end\n  puts\n  count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        count += 1 if (a[i] + a[j] + a[k])\
    \ % 3 == 0\n      end\n    end\n  end\n  count\nend", "\tarr = (1..n).map { |i|\
    \ i * i - i + 1 }\n\ttriples = 0\n\tfor i in 0..arr.length - 3\n\t\tfor j in i\
    \ + 1..arr.length - 2\n\t\t\tfor k in j + 1..arr.length - 1\n\t\t\t\ttriples +=\
    \ 1 if arr[i] + arr[j] + arr[k] % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\ttriples\n\
    end", "  max_triples = 0\n  a = []\n  for i in 1..n\n    a[i] = i * i - i + 1\n\
    \  end\n  for i in 1..n-2\n    for j in i+1..n-1\n      for k in j+1..n\n    \
    \    if(a[i] + a[j] + a[k]) % 3 == 0\n          max_triples += 1\n        end\n\
    \      end\n    end\n  end\n  return max_triples\nend", "  1.upto(n).to_a.combination(3).count\
    \ { |i, j, k| (i + j + k) % 3 == 0 }\nend", "  arr = []\n  (1..n).each do |i|\n\
    \    arr << i * i - i + 1\n  end\n  p arr\n  triples = []\n  arr.each_with_index\
    \ do |e, i|\n    arr.each_with_index do |e2, j|\n      next if j <= i\n      arr.each_with_index\
    \ do |e3, k|\n        next if k <= j\n        triples << [e, e2, e3]\n      end\n\
    \    end\n  end\n  p triples\n  p triples.select { |x| x.reduce(:+) % 3 == 0 }.size\n\
    end", "  # a[i] + a[j] + a[k] = i*i - i + 1 + j*j - j + 1 + k*k - k + 1 = 3(i*i\
    \ + j*j + k*k - i - j - k + 1)\n  # = 3(i*i + j*j + k*k + i + j + k + 1)\n  #\
    \ = 3(i + j + k + 1)^2 - 3(i + j + k)\n  # Since we need to find the number of\
    \ triples for which a[i] + a[j] + a[k] is a multiple of 3,\n  # the highest power\
    \ of 2 in the prime factorization of 3(i + j + k + 1)^2 - 3(i + j + k)\n  # (which\
    \ is 3(i + j + k + 1)^2) should be less than or equal to 2\n  # => 3(i + j + k\
    \ + 1)^2 <= 24\n  # => i + j + k + 1 <= 4\n  # => i + j + k <= 3\n  # => i + j\
    \ + k < 4\n  # No sum is equal to 4 because a[i] >= 1, i.e., 1 * 1 - 1 + 1 = 1,\
    \ for all i\n  # The next step is to find the number of triples for which i +\
    \ j + k = 3\n  # Cases to consider:\n  # i = 0, j = 1, k = 2\n  # i = 0, j = 2,\
    \ k = 1\n  # i = 1, j = 0, k = 2\n  # i = 1, j = 2, k = 0\n  # i = 2, j = 0, k\
    \ = 1\n  # i = 2, j = 1, k = 0\n  # Now, we need to find the number of valid triples\
    \ for each case\n  # We know that the only valid triple is (1, 7, 13).\n  # Let\
    \ i be the index of 1, j be the index of 7, and k be the index of 13.\n  # i =\
    \ 0, j = 2, k = 4\n  # i = 1, j = 1, k = 3\n  # i = 2, j =", "    res = 0\n  \
    \  arr = []\n    n.times { |i| arr.push(i*i - i + 1) }\n    n.times do |i|\n \
    \       i.upto(n-1) do |j|\n            j.upto(n-1) do |k|\n                res\
    \ += 1 if (arr[i] + arr[j] + arr[k]) % 3 == 0\n            end\n        end\n\
    \    end\n    res\nend", "  i = 1\n  count = 0\n  while(i < n)\n    j = i + 1\n\
    \    while(j < n)\n      k = j + 1\n      while(k < n)\n        sum = i * i -\
    \ i + 1 + j * j - j + 1 + k * k - k + 1\n        if sum % 3 == 0\n          count\
    \ += 1\n        end\n        k += 1\n      end\n      j += 1\n    end\n    i +=\
    \ 1\n  end\n  count\nend", "  a = []\n  for i in 1..n\n    a << i * i - i + 1\n\
    \  end\n  count = 0\n  for i in 0..a.length - 3\n    for j in i + 1..a.length\
    \ - 2\n      for k in j + 1..a.length - 1\n        if (a[i] + a[j] + a[k]) % 3\
    \ == 0\n          count += 1\n        end\n      end\n    end\n  end\n  count\n\
    end", "\ta = [1]\n\t(2..n).each do |i|\n\t\ta[i-1] = i * i - i + 1\n\tend\n\t\
    return a\nend", "    # create an array of length n\n    arr = Array.new(n) { |i|\
    \ i * i - i + 1 }\n    # iterate through the array and find all triples\n    res\
    \ = []\n    arr.each_with_index do |el, i|\n        arr.each_with_index do |el2,\
    \ j|\n            next if j <= i\n            arr.each_with_index do |el3, k|\n\
    \                next if k <= j\n                res << [el, el2, el3] if (el\
    \ + el2 + el3) % 3 == 0\n            end\n        end\n    end\n    res.uniq.length\n\
    end", "  lis = []\n  #lis[0] = lis[1] = lis[2] = -1\n  lis[0] = 0\n  lis[1] =\
    \ 0\n  lis[2] = 1\n  j = 1\n  (3..n).each do |i|\n    j = i - 1\n    while(j >\
    \ 2)\n      if (lis[j] + lis[j-1] + lis[j-2]) > (lis[i-1] + lis[i-2] + lis[i-3])\n\
    \        lis[i] = lis[i-1] + lis[i-2] + lis[i-3]\n        break\n      else\n\
    \        lis[i] = lis[j] + lis[j-1] + lis[j-2]\n        j -= 1\n      end\n  \
    \  end\n  end\n  lis[n]\nend", "\tcount = 0\n\ti = 1\n\tj = 2\n\tk = 3\n\twhile\
    \ k <= n\n\t\tif (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0\n\t\t\tcount\
    \ += 1\n\t\tend\n\t\tk += 1\n\t\tif k == n + 1\n\t\t\tj += 1\n\t\t\tk = j + 1\n\
    \t\t\tif j == n\n\t\t\t\ti += 1\n\t\t\t\tj = i + 1\n\t\t\t\tk = j + 1\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn count\nend", "  # a[i] + a[j] + a[k] == i*i - i\
    \ + 1 + j*j - j + 1 + k*k - k + 1\n  # == (i+j+k) * (i+j+k) - i - j - k + 3\n\
    \  # == (i+j+k) * (i+j+k) - 3\n  # == (i+j+k) * (i+j+k) - 3 * 3\n  triples = []\n\
    \  (0..n-3).each do |i|\n    ((i+1)..n-2).each do |j|\n      ((j+1)..n-1).each\
    \ do |k|\n        val = (i+j+k) * (i+j+k) - 3\n        triples << val\n      end\n\
    \    end\n  end\n  puts triples.inspect\n  # now count up the values of triples\
    \ that are divisible by 3\n  count = 0\n  triples.each do |val|\n    count +=\
    \ 1 if val % 3 == 0\n  end\n  return count\nend", "  (1..n).map { |e| e*e - e\
    \ + 1 }.combination(3).select { |t| t.reduce(:+) % 3 == 0 }.count\nend", "   \
    \ a = []\n    num_triples = 0\n    (1..n).each do |i|\n        a << i * i - i\
    \ + 1\n    end\n    # puts a.to_s\n    (1..n-2).each do |i|\n        (i+1..n-1).each\
    \ do |j|\n            (j+1..n).each do |k|\n                num_triples += 1 if\
    \ a[i] + a[j] + a[k] % 3 == 0\n            end\n        end\n    end\n    num_triples\n\
    end", "  return 0 if n<3\n  (1..n).inject([]){|acc,i| acc<<(i*i-i+1)}.combination(3).count{|x|\
    \ x.inject(:+)%3==0}\nend", "\tarray = []\n\tfor i in 1..n\n\t\tarray << i * i\
    \ - i + 1\n\tend\n\tputs array.inspect\n\tp array.combination(3).to_a.keep_if\
    \ { |x| x.reduce(:+) % 3 == 0 }.count\nend\nget_max_triples(5)", "  arr = (1..n).map\
    \ { |i| i * i - i + 1 }\n  triples = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        triples += 1 if (arr[i] + arr[j]\
    \ + arr[k]) % 3 == 0\n      end\n    end\n  end\n  triples\nend", "  count = 0\n\
    \  (0..n-3).each do |i|\n    i2 = i * i - i + 1\n    (i+1..n-2).each do |j|\n\
    \      j2 = j * j - j + 1\n      (j+1..n-1).each do |k|\n        k2 = k * k -\
    \ k + 1\n        if (i2 + j2 + k2) % 3 == 0\n          count += 1\n        end\n\
    \      end\n    end\n  end\n  count\nend", "  triples = 0\n  (1..n-2).each do\
    \ |i|\n    (i+1..n-1).each do |j|\n      (j+1..n).each do |k|\n        if (i*i\
    \ - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0\n          triples += 1\n    \
    \    end\n      end\n    end\n  end\n  triples\nend", "  a = (1..n).map { |i|\
    \ i * i - i + 1 }\n  puts a.inspect\n  a.combination(3).select { |i, j, k| (i\
    \ + j + k) % 3 == 0 }.count\nend", "\ta = []\n\tx = 1\n\tfor i in 1..n\n\t\ta[i]\
    \ = i * i - i + 1\n\tend\n\tputs a.to_s\n\tfor i in 1..n-2\n\t\tfor j in i+1..n-1\n\
    \t\t\tfor k in j+1..n\n\t\t\t\tx += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n\t\t\t\
    end\n\t\tend\n\tend\n\tx\nend", "    arr = (1..n).to_a.map { |i| i * i - i + 1\
    \ }\n    get_triples(arr, n)\nend", "    a = Array.new(n)\n    a[0] = 1\n    i\
    \ = 1\n    counter = 0\n    while i < n\n        a[i] = i * i - i + 1\n      \
    \  j = 0\n        while j < i\n            k = j + 1\n            while k < i\n\
    \                if ((a[i] + a[j] + a[k]) % 3) == 0\n                    counter\
    \ += 1\n                end\n                k += 1\n            end\n       \
    \     j += 1\n        end\n        i += 1\n    end\n    return counter\nend",
  "  a = []\n  a[0] = 0\n  (1..n).each do |i|\n    a[i] = i * i - i + 1\n  end\n \
    \ count = 0\n  (1..n).each do |i|\n    (i+1..n).each do |j|\n      (j+1..n).each\
    \ do |k|\n        count += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n\
    \  end\n  count\nend", "\ta = (1..n).map { |i| i * i - i + 1 }\n\tpairs = []\n\
    \ta.each do |i|\n\t\ta.each do |j|\n\t\t\tpairs << [i, j]\n\t\tend\n\tend\n\t\
    triples = 0\n\tpairs.each do |p|\n\t\ta.each do |k|\n\t\t\tif p[0] + p[1] + k\
    \ % 3 == 0\n\t\t\t\ttriples += 1\n\t\t\tend\n\t\tend\n\tend\n\ttriples\nend",
  "  a = (1..n).map { |i| i * i - i + 1 }\n  c = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        if (a[i] + a[j] + a[k]) % 3 ==\
    \ 0\n          c += 1\n        end\n      end\n    end\n  end\n  c\nend", "  #\
    \ Time Complexity - O(n^3)\n  # ntriples = 0\n  # (1..n).each do |i|\n  #   (i+1..n).each\
    \ do |j|\n  #     (j+1..n).each do |k|\n  #       ntriples += 1 if (i * i - i\
    \ + 1 + j * j - j + 1 + k * k - k + 1) % 3 == 0\n  #     end\n  #   end\n  # end\n\
    \  # ntriples", "  return 0 if n <= 2\n  a = Array.new(n)\n  a[0] = 1\n  (1..n-1).each\
    \ { |i| a[i] = i * i - i + 1 }\n  a_hash = a.reduce({}) { |acc, num| acc[num]\
    \ ||= 0; acc[num] += 1; acc }\n  # p a_hash\n  result = 0\n  (1..n-1).each do\
    \ |i|\n    (i+1..n-1).each do |j|\n      m3 = (a[i] + a[j]) % 3\n      m2 = a[i]\
    \ % 3\n      m1 = a[j] % 3\n      r = m1 + m2 - m3\n      if r == 1 || r == 2\n\
    \        k = m3 + 3 - m1\n        result += a_hash[k]\n      elsif r == 0\n  \
    \      k = m3\n        result += a_hash[k]\n      end\n    end\n  end\n  # p result\n\
    \  return result / 6\nend", "  a = []\n  for i in 1..n\n    a << i * i - i + 1\n\
    \  end\n  result = 0\n  for i in 0..n-3\n    for j in i+1..n-2\n      for k in\
    \ j+1..n-1\n        if a[i] + a[j] + a[k] % 3 == 0\n          result += 1\n  \
    \      end\n      end\n    end\n  end\n  result\nend", "  return 0 if n < 3\n\
    \  res = 0\n  sums = [0] * 3\n  i = 1\n  while i <= n\n    sums[(i * i - i + 1)\
    \ % 3] += 1\n    i += 1\n  end\n  res += sums[0] * (sums[0] - 1) * (sums[0] -\
    \ 2) / 6\n  res += sums[1] * (sums[1] - 1) * (sums[2] - 2) / 6\n  res += sums[2]\
    \ * (sums[2] - 1) * (sums[1] - 2) / 6\n  res += sums[0] * sums[1] * sums[2]\n\
    \  res\nend", "    # a[i] + a[j] + a[k] = i * i - i + 1 + j * j - j + 1 + k *\
    \ k - k + 1\n    #                   = (i + j + k) * (i + j + k) - 3 * (i + j\
    \ + k) + 3\n    #                   = (i + j + k) * (i + j + k - 3) + 3\n    #\
    \                   = (i + j + k) * (i + j + k - 3) + (3 - (i + j + k)) + (i +\
    \ j + k)\n    #                   = (i + j + k) * (i + j + k - 3) + (i + j + k)\n\
    \    # => i + j + k + (i + j + k) * (i + j + k - 3) is a multiple of 3\n    #\
    \ => i + j + k is a multiple of 3\n    # => i + j + k - 3 is a multiple of 3\n\
    \    # => i + j is a multiple of 3\n    # ...\n    # => j is a multiple of 3\n\
    \    # => i is a multiple of 3\n    # => i * i - i + 1 is a multiple of 3\n  \
    \  # => i * i - i is a multiple of 3\n    # => i * i is a multiple of 3\n    #\
    \ => i is a multiple of 3\n    # Therefore, we can calculate how many triples\
    \ there are using only i = 0, 1, 2 mod 3.\n    # a[0] = 0 * 0 - 0 + 1 = 1 is a\
    \ multiple of 3\n    # a[1] = 1 * 1 - 1 + 1 = 1 is a multiple of 3\n    # a[2]\
    \ = 2 * 2 - 2 + 1 = 3 is a multiple of 3\n    # a[3] = 3 * 3 - 3 + 1 = 7 is not\
    \ a multiple of 3\n    # Therefore, we need to calculate the number of triples\
    \ of a[0], a[1], a[2].\n    # a[0] and a[1] can form a triple with every a[i]\
    \ where i > 2.\n    # There are (n - 3) such numbers.\n    # a[1] and a[2]", "\t\
    numbers = (1..n).map { |i| i * i - i + 1 }\n\tp numbers\n\ttriples = 0\n\tfor\
    \ i in 0..numbers.length-1\n\t\tfor j in i+1..numbers.length-1\n\t\t\tfor k in\
    \ j+1..numbers.length-1\n\t\t\t\ttriples += 1 if numbers[i] + numbers[j] + numbers[k]\
    \ % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\ttriples\nend", "    count = 0\n    for\
    \ i in 0..n-1\n        for j in i+1..n-1\n            for k in j+1..n-1\n    \
    \            if (i*i-i+1+j*j-j+1+k*k-k+1)%3 == 0\n                    count +=\
    \ 1\n                end\n            end\n        end\n    end\n    return count\n\
    end\nputs get_max_triples(5)\nputs get_max_triples(10)\nputs get_max_triples(1000)",
  "  arr = [1]\n  (1..n-1).each do |i|\n    arr << i * i - i + 1\n  end\n  triples\
    \ = []\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        triples << [arr[i], arr[j], arr[k]] if (arr[i] + arr[j] + arr[k])\
    \ % 3 == 0\n      end\n    end\n  end\n  triples.length\nend", "    max_triples\
    \ = 0\n    (1..n).each do |i|\n        (i+1..n).each do |j|\n            (j+1..n).each\
    \ do |k|\n                max_triples += 1 if i*i - i + 1 + j*j - j + 1 + k*k\
    \ - k + 1 % 3 == 0\n            end\n        end\n    end\n    max_triples\nend",
  '    pascal = Array.new(n+1) { Array.new(n+1, 0) }', "  multiples = Hash.new(0)\n\
    \  (1..n).each do |i|\n    a_i = i * i - i + 1\n    (1..n).each do |j|\n     \
    \ a_j = j * j - j + 1\n      next if j == i\n      (1..n).each do |k|\n      \
    \  a_k = k * k - k + 1\n        next if k == i || k == j\n        multiples[(a_i\
    \ + a_j + a_k) % 3] += 1\n      end\n    end\n  end\n  multiples[0]\nend", " \
    \ arr = (1..n).map { |i| i * i - i + 1 }\n  result = 0\n  for i in 0..n-1\n  \
    \  for j in i+1..n-1\n      for k in j+1..n-1\n        result += 1 if arr[i] +\
    \ arr[j] + arr[k] % 3 == 0\n      end\n    end\n  end\n  result\nend\nputs get_max_triples(1)\
    \ == 0\nputs get_max_triples(2) == 0\nputs get_max_triples(3) == 0\nputs get_max_triples(4)\
    \ == 0\nputs get_max_triples(5) == 1\nputs get_max_triples(6) == 1\nputs get_max_triples(7)\
    \ == 2\nputs get_max_triples(8) == 2\nputs get_max_triples(9) == 2\nputs get_max_triples(10)\
    \ == 2\nputs get_max_triples(20000) == 57407\nputs get_max_triples(15000) == 24109\n\
    puts get_max_triples(10000) == 6696\nputs get_max_triples(5000) == 776\nputs get_max_triples(4000)\
    \ == 375\nputs get_max_triples(3000) == 157\nputs get_max_triples(2000) == 43\n\
    puts get_max_triples(1000) == 5", "  ary = []\n  n.times do |i|\n    ary << i*i\
    \ - i + 1\n  end\n  # puts ary.inspect\n  result = 0\n  n.times do |i|\n    (i+1).upto(n-1)\
    \ do |j|\n      (j+1).upto(n-1) do |k|\n        result += 1 if (ary[i] + ary[j]\
    \ + ary[k]) % 3 == 0\n      end\n    end\n  end\n  result\nend", "\t# n = n-1\n\
    \ta = Array.new(n)\n\ta[0] = 1\n\t1.upto(n-1) do |i|\n\t\ta[i] = i * i - i + 1\n\
    \tend\n\ti = 0\n\tj = 1\n\tk = 2\n\tt = 0\n\twhile k < n do\n\t\tif a[i] + a[j]\
    \ + a[k] == 0\n\t\t\ti = i + 1\n\t\t\tj = j + 1\n\t\t\tk = k + 1\n\t\t\tt = t\
    \ + 1\n\t\t\tnext\n\t\tend\n\t\tif a[i] + a[j] + a[k] < 0\n\t\t\tif k == n-1\n\
    \t\t\t\ti = i + 1\n\t\t\t\tj = j + 1\n\t\t\t\tk = k + 1\n\t\t\telse\n\t\t\t\t\
    k = k + 1\n\t\t\tend\n\t\telse\n\t\t\tif j == k-1\n\t\t\t\ti = i + 1\n\t\t\t\t\
    j = j + 1\n\t\t\t\tk = k + 1\n\t\t\telse\n\t\t\t\tj = j + 1\n\t\t\tend\n\t\tend\n\
    \tend\n\tt\nend", "    total = 0\n    (1..n).each do |a|\n        a_val = a *\
    \ a - a + 1\n        (a+1..n).each do |b|\n            b_val = b * b - b + 1\n\
    \            if (a_val + b_val) % 3 == 0\n                (b+1..n).each do |c|\n\
    \                    if (a_val + b_val + (c * c - c + 1)) % 3 == 0\n         \
    \               total += 1\n                    end\n                end\n   \
    \         end\n        end\n    end\n    total\nend", "  arr = Array.new(n) {\
    \ |i| i * i - i + 1 }\n  arr.combination(3).count { |a, b, c| (a + b + c) % 3\
    \ == 0 }\nend", "    a = []\n    1.upto(n) do |i|\n        a << i * i - i + 1\n\
    \    end\n    count = 0\n    a.each_with_index do |val, i|\n        ((i + 1)...a.length).each\
    \ do |j|\n            ((j + 1)...a.length).each do |k|\n                count\
    \ += 1 if (val + a[j] + a[k]) % 3 == 0\n            end\n        end\n    end\n\
    \    count\nend\nputs get_max_triples(5)\nputs get_max_triples(1000)", "    a\
    \ = Array.new(n)\n    a[0] = 1\n    (1..n-1).each do |i|\n        a[i] = i * i\
    \ - i + 1\n    end\n    count = 0\n    (0..n-3).each do |i|\n        (i+1..n-2).each\
    \ do |j|\n            (j+1..n-1).each do |k|\n                sum = a[i] + a[j]\
    \ + a[k]\n                if sum % 3 == 0\n                    count += 1\n  \
    \              end\n            end\n        end\n    end\n    count\nend", " \
    \ res = 0\n  a = []\n  for i in 1..n\n    a[i] = i*i - i + 1\n  end\n  for i in\
    \ 1..n\n    for j in i+1..n\n      for k in j+1..n\n        res += 1 if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  res\nend", "  a = (1..n).to_a.map\
    \ { |x| x * x - x + 1 }\n  triples = []\n  while a.size > 2\n    first = a.shift\n\
    \    a.each_with_index do |x, idx|\n      if first + x + a[idx + 1] % 3 == 0\n\
    \        triples << [first, x, a[idx + 1]]\n      end\n    end\n  end\n  triples.count\n\
    end", "  a = (1..n).map { |i| i * i - i + 1 }\n  count = 0\n  (1..n - 2).each\
    \ do |i|\n    (i + 1..n - 1).each do |j|\n      (j + 1..n).each do |k|\n     \
    \   count += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n \
    \ count\nend", "    a = (1..n).map { |v| v * v - v + 1 }\n    valid_triples =\
    \ []\n    (a.length - 2).times do |i|\n        ((i + 1)..(a.length - 1)).each\
    \ do |j|\n            ((j + 1)..(a.length - 1)).each do |k|\n                if\
    \ (a[i] + a[j] + a[k]) % 3 == 0\n                    valid_triples << [a[i], a[j],\
    \ a[k]]\n                end\n            end\n        end\n    end\n    return\
    \ valid_triples.length\nend\nputs get_max_triples(5)\nputs get_max_triples(10)\n\
    puts get_max_triples(100)\nputs get_max_triples(200)\nputs get_max_triples(1000)\n\
    puts get_max_triples(10000)\nputs get_max_triples(100000)\nputs get_max_triples(1000000)",
  "    a = (1..n).map { |i| i * i - i + 1 }\n    count = 0\n    a.each_with_index\
    \ do |ai,i|\n        next if i + 1 == a.length\n        a[i+1..-1].each_with_index\
    \ do |aj,j|\n            next if j + 1 == a.length\n            a[j+1..-1].each\
    \ do |ak|\n                count += 1 if (ai + aj + ak) % 3 == 0\n           \
    \ end\n        end\n    end\n    count\nend", "  # Your code here\nend", "  a\
    \ = [1]\n  for i in 2..n\n    a << (i * i - i + 1)\n  end\n  triple_count = 0\n\
    \  for i in 0..n-1\n    for j in i+1..n-1\n      for k in j+1..n-1\n        if\
    \ (a[i] + a[j] + a[k]) % 3 == 0\n          triple_count += 1\n        end\n  \
    \    end\n    end\n  end\n  triple_count\nend", "  # initialize array\n  a = Array.new(n)\
    \ {|i| i * i - i + 1}\n  a.length.times.reduce(0) do |max, i|\n    ((i + 1)...(a.length)).each\
    \ do |j|\n      ((j + 1)...(a.length)).each do |k|\n        max += 1 if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n      end\n    end\n    max\n  end\nend", "  res =\
    \ 0\n  (1..n-2).each do |i|\n    (i+1..n-1).each do |j|\n      (j+1..n).each do\
    \ |k|\n        res += 1 if (i*i - i + 1 + j*j - j + 1 + k*k - k + 1) % 3 == 0\n\
    \      end\n    end\n  end\n  res\nend", "  array = (1..n).map{|x| x * x - x +\
    \ 1}\n  count = 0\n  for i in 0..n-1\n    for j in i+1..n-1\n      for k in j+1..n-1\n\
    \        if (array[i] + array[j] + array[k]) % 3 == 0\n          count += 1\n\
    \        end\n      end\n    end\n  end\n  count\nend", end, "  arr = Array.new(n)\
    \ { |i| i*i - i + 1 }\n  count = 0\n  for i in 0..n-3\n    for j in i+1..n-2\n\
    \      for k in j+1..n-1\n        count += 1 if arr[i] + arr[j] + arr[k] % 3 ==\
    \ 0\n      end\n    end\n  end\n  count\nend", "  return 0 if n < 3\n  a = []\n\
    \  (1..n).each do |x|\n    a << x * x - x + 1\n  end\n  count = 0\n  (1..n-2).each\
    \ do |i|\n    (i+1..n-1).each do |j|\n      (j+1..n).each do |k|\n        count\
    \ += 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\n\
    end", "  a = Array.new(n,0)\n  result = 0\n  (1..n).each do |i|\n    a[i-1] =\
    \ i*i - i + 1\n  end\n  #puts a.to_s\n  for i in (0..n-3)\n    for j in (i+1..n-2)\n\
    \      for k in (j+1..n-1)\n        if (a[i] + a[j] + a[k]) % 3 == 0\n       \
    \   result += 1\n        end\n      end\n    end\n  end\n  return result\nend",
  "  a = []\n  (1..n).each { |i| a << i * i - i + 1 }\n  index = 0\n  sum = 0\n  count\
    \ = 0\n  for i in (0..a.length - 3)\n    for j in (i + 1..a.length - 2)\n    \
    \  for k in (j + 1..a.length - 1)\n        sum = a[i] + a[j] + a[k]\n        count\
    \ += 1 if sum % 3 == 0\n      end\n    end\n  end\n  count\nend", "  raise RuntimeError,\
    \ \"Invalid input\" if n <= 0\n  return 0 if n < 3\n  if n >= 3\n    n = n - 3\n\
    \    return n * (n + 1) / 2\n  end\nend", "    # Create an array a of length n\n\
    \    a = Array.new(n)\n    # For each element of a, set the value to the equation\n\
    \    for i in 0..n-1\n        a[i] = i * i - i + 1\n    end\n    # Get the max\
    \ number of valid triples, keeping in mind that i < j < k\n    sum = 0\n    for\
    \ i in 0..n-3\n        for j in i+1..n-2\n            for k in j+1..n-1\n    \
    \            if (a[i] + a[j] + a[k]) % 3 == 0\n                    sum += 1\n\
    \                end\n            end\n        end\n    end\n    return sum\n\
    end", "  a = (1..n).map { |i| i * i - i + 1 }\n  count = 0\n  (0..n-3).each do\
    \ |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        count\
    \ += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n  count\nend",
  "  # O(n)\n  array = []\n  for i in 1..n\n    array << i*i - i + 1\n  end\n  puts\
    \ array.inspect\n  # O(n**3)\n  count = 0\n  for i in 0..array.length-3\n    for\
    \ j in i+1..array.length-2\n      for k in j+1..array.length-1\n        count\
    \ += 1 if array[i] + array[j] + array[k] % 3 == 0\n      end\n    end\n  end\n\
    \  count\nend\nputs get_max_triples(5)\nputs get_max_triples(10)\nputs get_max_triples(2)\n\
    puts get_max_triples(15)\nputs get_max_triples(17)\nputs get_max_triples(20)",
  "  a = (1..n).map { |i| i * i - i + 1 }\n  arr = []\n  (0..n - 3).each do |i|\n\
    \    (i + 1..n - 2).each do |j|\n      (j + 1..n - 1).each do |k|\n        arr\
    \ << [a[i], a[j], a[k]] if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n \
    \ end\n  arr.size\nend", "  a = (1..n).to_a.map { |i| i * i - i + 1 }\n  count\
    \ = 0\n  for i in 0..a.length - 3\n    for j in i + 1..a.length - 2\n      for\
    \ k in j + 1..a.length - 1\n        sum = a[i] + a[j] + a[k]\n        count +=\
    \ 1 if sum % 3 == 0\n      end\n    end\n  end\n  count\nend", "  a = (1..n).map\
    \ { |i| i * i - i + 1 }\n  count = 0\n  (1..n - 2).each do |i|\n    (i + 1..n\
    \ - 1).each do |j|\n      (j + 1..n).each do |k|\n        count += 1 if (a[i]\
    \ + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "  a = (1..n).to_a.map\
    \ { |x| x * x - x + 1 }\n  result = 0\n  for i in 0..a.length - 3\n    for j in\
    \ i + 1..a.length - 2\n      for k in j + 1..a.length - 1\n        result += 1\
    \ if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  result\nend",
  "    a = (1..n).map { |i| i * i - i + 1 }\n    count = 0\n    (1..n-2).each do |i|\n\
    \        (i+1..n-1).each do |j|\n            (j+1..n).each do |k|\n          \
    \      count += 1 if a[i] + a[j] + a[k] % 3 == 0\n            end\n        end\n\
    \    end\n    count\nend", "    return 0 if n < 3\n    count = 0\n    (2..n-1).each\
    \ do |i|\n        if (i*i - i + 1) % 3 == 0\n            count += i - 1\n    \
    \    end\n    end\n    count\nend", "  # Create an array of length n\n  array\
    \ = (1..n).to_a\n  # Iterate through array and transform each number to n * n\
    \ - n + 1\n  array.map! { |num| num * num - num + 1 }\n  # return the number of\
    \ triples that is a multiple of 3\n  array.combination(3).select { |triple| triple.sum\
    \ % 3 == 0 }.count\nend", "  # Write your code here\nend", "  if n < 3\n    0\n\
    \  else\n    (((n-2)**2)*(n-2)+n-2) / 6\n  end\nend", "  arr = []\n  n.times {\
    \ |i| arr << i*i - i + 1 }\n  p arr\n  total = 0\n  (0..n-3).each do |i|\n   \
    \ (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        total += 1 if\
    \ (arr[i] + arr[j] + arr[k]) % 3 == 0\n      end\n    end\n  end\n  p total\n\
    end", "  return 0 if n < 3\n  a = Array.new(n)\n  (1..n).each do |i|\n    a[i-1]\
    \ = i * i - i + 1\n  end\n  h = {}\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      k = a[i] + a[j]\n      h[k] = (h[k] || 0) + 1\n    end\n  end\n\
    \  h.keys.map { |k| h[k] * (h[k] - 1) / 2 }.sum\nend\np get_max_triples(5)\np\
    \ get_max_triples(4)\np get_max_triples(3)\np get_max_triples(2)\np get_max_triples(1)\n\
    p get_max_triples(0)\np get_max_triples(1000)\np get_max_triples(10000)\np get_max_triples(100000)\n\
    p get_max_triples(1000000)\np get_max_triples(10000000)\np get_max_triples(100000000)\n\
    p get_max_triples(1000000000)\np get_max_triples(10000000000)\np get_max_triples(100000000000)\n\
    p get_max_triples(1000000000000)\np get_max_triples(10000000000000)\np get_max_triples(100000000000000)\n\
    p get_max_triples(1000000000000000)\np get_max_triples(10000000000000000)\np get_max_triples(100000000000000000)\n\
    p get_max_triples(1000000000000000000)\np get_max_triples(10000000000000000000)\n\
    p get_max_triples(100000000000000000000)\np get_max_triples(1000000000000000000000)\n\
    p get_max_triples(10000000000000000000000)\np get_max_triples(100000000000000000000000)\n\
    p get_max_triples(1000000000000000000000000)\np get_max_triples(10000000000000000000000000)\n\
    p get", "    values = (1..n).map { |i| i * i - i + 1 }\n    count = 0\n    (0..n-3).each\
    \ do |i|\n        (i+1..n-2).each do |j|\n            (j+1..n-1).each do |k|\n\
    \                count += 1 if values[i] + values[j] + values[k] % 3 == 0\n  \
    \          end\n        end\n    end\n    count\nend", "    # If a[i] + a[j] +\
    \ a[k] is a multiple of 3, then \n    # a[i] + a[j] is also a multiple of 3, and\
    \ so is a[j] + a[k].\n    # Consider a[i] + a[j]. If we fix i and loop through\
    \ j,\n    # the count of numbers that are divisible by 3 is the same \n    # as\
    \ the count of numbers that are not divisible by 3.\n    # Hence, we can use the\
    \ fact that:\n    # for a[i] + a[j] to be a multiple of 3, the number of numbers\n\
    \    # that are divisible by 3 and the numbers that are not divisible\n    # by\
    \ 3 have to be equal.\n    # For a[j] + a[k] to be a multiple of 3, we will use\
    \ a similar logic.\n    # We loop through k, and count the number of numbers that\
    \ are divisible\n    # by 3 and the number of numbers that are not divisible by\
    \ 3.\n    # If the number of numbers that are divisible by 3 and the numbers\n\
    \    # that are not divisible by 3 are equal, we increase the count.\n    # Time\
    \ Complexity: O(n ^ 2), Space Complexity: O(1)\n    count = 0\n    a = Array.new(n)\
    \ { |i| i * i - i + 1 }\n    for i in 0...n\n        div_3 = 0\n        not_div_3\
    \ = 0\n        for j in i + 1...n\n            if a[j] % 3 == 0\n            \
    \    div_3 += 1\n            else\n                not_div_3 += 1\n          \
    \  end\n        end\n        for k in i + 1...n\n            if a[k] % 3 == 0\n\
    \                div_3 -= 1\n            else\n                not_div_3 -= 1\n\
    \            end\n            if (a[i] + a[k]) % 3 == 0 and div_3 == not_div_3\n\
    \                count += 1\n            end\n        end\n    end\n    return\
    \ count\nend", "  a = (1..n).map { |i| i * i - i + 1 }\n  h = Hash.new(0)\n  a.each\
    \ do |e|\n    h[e] += 1\n  end\n  res = 0\n  for i in 1..n\n    for j in (i +\
    \ 1)..n\n      for k in (j + 1)..n\n        res += 1 if (a[i] + a[j] + a[k]) %\
    \ 3 == 0\n      end\n    end\n  end\n  res\nend", "    a = []\n    (1..n).each\
    \ do |i|\n        a << i * i - i + 1\n    end\n    #p a\n    count = 0\n    (0..n-3).each\
    \ do |i|\n        (i+1..n-2).each do |j|\n            (j+1..n-1).each do |k|\n\
    \                count += 1 if a[i] + a[j] + a[k] % 3 == 0\n            end\n\
    \        end\n    end\n    count\nend", "    array = Array.new(n) { |i| i * i\
    \ - i + 1 }\n    count = 0\n    (0..array.length - 3).each do |i|\n        (i\
    \ + 1..array.length - 2).each do |j|\n            (j + 1..array.length - 1).each\
    \ do |k|\n                count += 1 if array[i] + array[j] + array[k] % 3 ==\
    \ 0\n            end\n        end\n    end\n    count\nend", "  arr = Array.new(n+1)\n\
    \  (1..n).each { |i| arr[i] = i*i - i + 1 }\n  count = 0\n  (1..n-2).each do |i|\n\
    \    (i+1..n-1).each do |j|\n      k = j + 1\n      while k <= n && arr[i] + arr[j]\
    \ + arr[k] < 3 * arr[k]\n        k += 1\n      end\n      count += 1 if k <= n\
    \ && arr[i] + arr[j] + arr[k] == 3 * arr[k]\n    end\n  end\n  count\nend", " \
    \ arr = Array.new(n) { |i| i*i - i + 1 }\n  count = 0\n  for i in 0..n-3\n   \
    \ for j in i+1..n-2\n      for k in j+1..n-1\n        count += 1 if (arr[i] +\
    \ arr[j] + arr[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "    answer\
    \ = 0\n    (1..n-2).each do |i|\n        (i+1..n-1).each do |j|\n            (j+1..n).each\
    \ do |k|\n                if ((i*i - i + 1) + (j*j - j + 1) + (k*k - k + 1)) %\
    \ 3 == 0\n                    answer += 1\n                end\n            end\n\
    \        end\n    end\n    answer\nend", "  triples = 0\n  for i in 0..n-3\n \
    \   for j in i+1..n-2\n      for k in j+1..n-1\n        triples += 1 if (i+j+k)\
    \ % 3 == 0\n      end\n    end\n  end\n  triples\nend", "  # create an array of\
    \ length n\n  a = []\n  i = 1\n  n.times do\n    a << i * i - i + 1\n    i +=\
    \ 1\n  end\n  # find the number of triples where a[i] + a[j] + a[k] is a multiple\
    \ of 3\n  sum = 0\n  i = 0\n  while i < a.length - 2\n    j = i + 1\n    while\
    \ j < a.length - 1\n      k = j + 1\n      while k < a.length\n        sum +=\
    \ 1 if (a[i] + a[j] + a[k]) % 3 == 0\n        k += 1\n      end\n      j += 1\n\
    \    end\n    i += 1\n  end\n  sum\nend", "  return 0 if n < 3\n  a = []\n  for\
    \ i in 1..n\n    a << i * i - i + 1\n  end\n  triples = 0\n  for i in 0..n-3\n\
    \    for j in i+1..n-2\n      for k in j+1..n-1\n        if a[i] + a[j] + a[k]\
    \ % 3 == 0\n          triples += 1\n        end\n      end\n    end\n  end\n \
    \ triples\nend", "    if n < 3\n        return 0\n    end\n    a = Array.new(n)\n\
    \    for i in 0..n-1\n        a[i] = i * i - i + 1\n    end\n    max_triples =\
    \ 0\n    for i in 0..n-3\n        for j in i+1..n-2\n            for k in j+1..n-1\n\
    \                if (a[i] + a[j] + a[k]) % 3 == 0\n                    max_triples\
    \ += 1\n                end\n            end\n        end\n    end\n    return\
    \ max_triples\nend", "  # Write your code here\nend\nputs get_max_triples(5)",
  "    res = 0\n    return res if n < 3\n    max_i = 1\n    max_j = 2\n    a = [1]\n\
    \    for i in 2..n\n        a << (i * i - i + 1)\n    end\n    for k in 3..n-1\n\
    \        for i in 1..max_i\n            for j in i+1..max_j\n                res\
    \ += 1 if a[i] + a[j] + a[k] % 3 == 0\n            end\n        end\n        max_i\
    \ += 1\n        max_j += 1\n    end\n    res\nend", "    return 0 if n < 3\n \
    \   # create array of 1, 3, 7, 13, 21,...\n    a = []\n    for i in 1..n\n   \
    \     a.push(i * i - i + 1)\n    end\n    count = 0\n    # take 3 numbers at a\
    \ time and check the sum\n    for i in 0..n-3\n        for j in i+1..n-2\n   \
    \         for k in j+1..n-1\n                if (a[i] + a[j] + a[k]) % 3 == 0\n\
    \                    count += 1\n                end\n            end\n      \
    \  end\n    end\n    return count\nend", '  raise RuntimeError if n <= 0', " \
    \ arr = []\n  count = 0\n  0.upto(n-1) do |i|\n    0.upto(n-1) do |j|\n      0.upto(n-1)\
    \ do |k|\n        if i < j && j < k\n          x = (i+1) * (i+1) - (i+1) + 1\n\
    \          y = (j+1) * (j+1) - (j+1) + 1\n          z = (k+1) * (k+1) - (k+1)\
    \ + 1\n          if (x + y + z) % 3 == 0\n            count += 1\n          end\n\
    \        end\n      end\n    end\n  end\n  return count\nend", "    a = (1..n).map\
    \ { |i| i * i - i + 1 }\n    triples = []\n    (0..n-3).each do |i|\n        (i+1..n-2).each\
    \ do |j|\n            (j+1..n-1).each do |k|\n                triples << [a[i],\
    \ a[j], a[k]] if a[i] + a[j] + a[k] % 3 == 0\n            end\n        end\n \
    \   end\n    puts \"Triples: #{triples}\"\n    triples.size\nend", "  count =\
    \ 0\n  # Initialize the array\n  a = (1..n).map { |i| i * i - i + 1 }\n  # Check\
    \ the criteria\n  for i in 0..n-3\n    for j in i+1..n-2\n      for k in j+1..n-1\n\
    \        if ((a[i] + a[j] + a[k]) % 3 == 0)\n          count += 1\n        end\n\
    \      end\n    end\n  end\n  count\nend", "  a = Array.new(n)\n  a.each_with_index\
    \ { |_e, i| a[i] = i * i - i + 1 }\n  triples = 0\n  a.each_with_index do |i,\
    \ i_index|\n    a.each_with_index do |j, j_index|\n      break if j_index <= i_index\n\
    \      a.each_with_index do |k, k_index|\n        break if k_index <= j_index\n\
    \        triples += 1 if i + j + k % 3 == 0\n      end\n    end\n  end\n  triples\n\
    end", "  a = (1..n).map { |i| i * i - i + 1 }\n  puts a.inspect\n  count = 0\n\
    \  (0..n - 3).each do |i|\n    (i + 1..n - 2).each do |j|\n      (j + 1..n - 1).each\
    \ do |k|\n        count += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n\
    \  end\n  count\nend", "    n - 1\nend", "    array = (1..n).map { |number| number\
    \ * number - number + 1 }\n    counter = 0\n    array.each_with_index do |item1,\
    \ index1|\n        array.each_with_index do |item2, index2|\n            array.each_with_index\
    \ do |item3, index3|\n                if index1 < index2 && index2 < index3 &&\
    \ (item1 + item2 + item3) % 3 == 0\n                    counter += 1\n       \
    \         end\n            end\n        end\n    end\n    counter\nend\nputs get_max_triples(5)",
  "  a = []\n  (1..n).each { |i| a << i * i - i + 1 }\n  count = 0\n  (1..a.length-2).each\
    \ do |i|\n    (i+1..a.length-1).each do |j|\n      if a[i] + a[j] < a[-1]\n  \
    \      k = a.bsearch_index { |x| x >= a[i] + a[j] }\n        count += 1 if a[i]\
    \ + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n  count\nend", "  a = [1]\n\
    \  (2..n).each do |x|\n    a[x-1] = x*x - x + 1\n  end\n  puts a.inspect\n  #\
    \ Brute force solution\n  count = 0\n  (0..n-3).each do |i|\n    (i+1..n-2).each\
    \ do |j|\n      (j+1..n-1).each do |k|\n        if a[i] + a[j] + a[k] % 3 == 0\n\
    \          count += 1\n        end\n      end\n    end\n  end\n  count\nend",
  "    a = []\n    (1..n).each do |i|\n        a << i * i - i + 1\n    end\n    #p\
    \ a\n    max_triples = 0\n    (0..a.length-3).each do |i|\n        (i+1..a.length-2).each\
    \ do |j|\n            (j+1..a.length-1).each do |k|\n                #puts \"\
    i = #{i}, j = #{j}, k = #{k}\"\n                sum = a[i] + a[j] + a[k]\n   \
    \             #puts \"a[i] = #{a[i]}, a[j] = #{a[j]}, a[k] = #{a[k]}, sum = #{sum}\"\
    \n                if sum % 3 == 0\n                    max_triples += 1\n    \
    \            end\n            end\n        end\n    end\n    max_triples\nend",
  "\ta = [1]\n\tfor i in 1..n-1\n\t\ta << i*i - i + 1\n\tend\n\tt = 0\n\tfor i in\
    \ 0..n-3\n\t\tfor j in i+1..n-2\n\t\t\tfor k in j+1..n-1\n\t\t\t\tt += 1 if a[i]\
    \ + a[j] + a[k] % 3 == 0\n\t\t\tend\n\t\tend\n\tend\n\tt\nend", "  array = [1]\n\
    \  for i in 1..n-1\n    array << (i*i - i + 1)\n  end\n  array\nend", "  arr =\
    \ []\n  (1..n).each { |i| arr.push(i * i - i + 1) }\n  count = 0\n  (1..n-2).each\
    \ do |i|\n    (i+1..n-1).each do |j|\n      (j+1..n).each do |k|\n        count\
    \ += 1 if arr[i] + arr[j] + arr[k] % 3 == 0\n      end\n    end\n  end\n  count\n\
    end", "  triple_count = 0\n  a = [1]\n  (1..n-1).each do |i|\n    a[i] = i*i -\
    \ i + 1\n  end\n  (0..n-3).each do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        if (a[i] + a[j] + a[k]) % 3 == 0\n          triple_count +=\
    \ 1\n        end\n      end\n    end\n  end\n  triple_count\nend", "  # Write\
    \ your code here\nend", "  # 1 \u2264 n \u2264 10^9\n  # 1 \u2264 i \u2264 n\n\
    \  # a[i] = i * i - i + 1\n  # i < j < k\n  # a[i] + a[j] + a[k] is a multiple\
    \ of 3", "  arr = Array.new(n+1, 0)\n  (1..n).each do |i|\n    arr[i] = i * i\
    \ - i + 1\n  end\n  puts arr.inspect\n  hash = Hash.new(0)\n  (0..n).each do |i|\n\
    \    (i+1..n).each do |j|\n      sum = arr[i] + arr[j]\n      hash[sum] += 1\n\
    \    end\n  end\n  puts hash.inspect\n  result = 0\n  hash.each do |k, v|\n  \
    \  result += (v * (v-1) / 2) if k % 3 == 0\n  end\n  result\nend\nputs get_max_triples(5)",
  "  return 0 if n < 3\n  max_triples = 0\n  a = Array.new(n) { |i| (i * i) - i +\
    \ 1 }\n  a.each_with_index do |i, index|\n    b = a[index + 1..-1]\n    b.each_with_index\
    \ do |j, index2|\n      c = b[index2 + 1..-1]\n      c.each do |k|\n        max_triples\
    \ += 1 if i + j + k % 3 == 0\n      end\n    end\n  end\n  max_triples\nend",
  "    if n < 3\n        return 0\n    end\n    a = []\n    count = 0\n    sum = 0\n\
    \    i = 1\n    while i <= n\n        a.push(i * i - i + 1)\n        i += 1\n\
    \    end\n    # p a\n    i = 0\n    while i < n - 2\n        j = i + 1\n     \
    \   while j < n - 1\n            k = j + 1\n            while k < n\n        \
    \        sum = a[i] + a[j] + a[k]\n                if sum % 3 == 0\n         \
    \           count += 1\n                end\n                k += 1\n        \
    \    end\n            j += 1\n        end\n        i += 1\n    end\n    return\
    \ count\nend", "  return 0 if n < 3\n  triples = 0\n  a = []\n  i = 1\n  while\
    \ a.length < n\n    a << i * i - i + 1\n    i += 1\n  end\n  p a\n  a.each_with_index\
    \ do |num, index|\n    a[index + 1..-1].each_with_index do |num2, index2|\n  \
    \    temp = index + index2 + 2\n      next if temp >= a.length\n      # p \"3\
    \ * #{num} + 3 * #{num2} + 3 * #{a[temp]} = #{3 * num + 3 * num2 + 3 * a[temp]}\"\
    \n      triples += 1 if 3 * num + 3 * num2 + 3 * a[temp] % 3 == 0\n    end\n \
    \ end\n  triples\nend", "    # create an array\n    arr = Array.new(n)\n    #\
    \ populate it with values\n    (1..n).each do |i|\n        arr[i-1] = i*i - i\
    \ + 1\n    end\n    puts \"array = #{arr}\"\n    # get all triples\n    triples\
    \ = arr.combination(3).to_a\n    puts \"triples = #{triples}\"\n    # count total\
    \ triplets\n    count = 0\n    triples.each do |triple|\n        if triple.sum\
    \ % 3 == 0\n            count += 1\n        end\n    end\n    count\nend", " \
    \ arr = (1..n).map { |x| x * x - x + 1 }\n  count = 0\n  for i in (0..n-3)\n \
    \   for j in (i+1..n-2)\n      for k in (j+1..n-1)\n        count += 1 if (arr[i]\
    \ + arr[j] + arr[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "   \
    \ a = []\n    for i in 1..n\n        a.push(i*i - i + 1)\n    end\n    puts \"\
    a = #{a}\"\n    c = 0\n    for i in 0..n-3\n        for j in i+1..n-2\n      \
    \      for k in j+1..n-1\n                if (a[i] + a[j] + a[k]) % 3 == 0\n \
    \                   c += 1\n                end\n            end\n        end\n\
    \    end\n    return c\nend", "  a = []\n  a[0] = 0\n  for i in 1..n\n    a[i]\
    \ = i * i - i + 1\n  end\n  res = 0\n  for i in 1..n\n    for j in 1..n\n    \
    \  for k in 1..n\n        if (i < j && j < k && a[i] + a[j] + a[k] % 3 == 0)\n\
    \          res += 1\n        end\n      end\n    end\n  end\n  return res\nend",
  "  return 0 if n < 3\n  a = (1..n).map { |i| i * i - i + 1 }\n  res = 0\n  (2..n\
    \ - 1).each do |i|\n    (1..i - 1).each do |j|\n      res += 1 if (a[i] + a[j])\
    \ % 3 == 0\n    end\n  end\n  res\nend\nn = 5\np get_max_triples(n)\nn = 3\np\
    \ get_max_triples(n)\nn = 10\np get_max_triples(n)", "  arr = (1..n).map { |item|\
    \ item * item - item + 1 }\n  arr.each_with_index.select { |item, index| item\
    \ % 3 == 0 }.map { |item, index| index }\nend", "  number_of_triples = 0\n  a\
    \ = Array.new(n)\n  a.each_with_index do |v, i|\n    a[i] = i * i - i + 1\n  end\n\
    \  puts a\n  a.each_with_index do |v, i|\n    a.each_with_index do |v, j|\n  \
    \    a.each_with_index do |v, k|\n        if i < j && j < k && (a[i] + a[j] +\
    \ a[k]) % 3 == 0\n          number_of_triples += 1\n        end\n      end\n \
    \   end\n  end\n  return number_of_triples\nend", "  arr = get_array(n)\n  count\
    \ = 0\n  (0..n-1).each do |i|\n    (i+1..n-1).each do |j|\n      (j+1..n-1).each\
    \ do |k|\n        #printf \"Triples: #{arr[i]}, #{arr[j]}, #{arr[k]}\\n\"\n  \
    \      sum = arr[i] + arr[j] + arr[k]\n        if sum % 3 == 0\n          count\
    \ += 1\n        end\n      end\n    end\n  end\n  count\nend", "  return 0 if\
    \ n < 3\n  # The constraints are such that the number can be represented as a\
    \ long\n  # in Java and as an int in C++.\n  total_triples = 0\n  return total_triples\
    \ if n < 3\n  # Convert the number to long for Java\n  number = 0\n  for i in\
    \ 0..n - 1\n    number = (i * i) - i + 1\n    total_triples += n - i - 1\n  end\n\
    \  puts total_triples\nend", "  a = []\n  i = 1\n  while i <= n\n    a << i *\
    \ i - i + 1\n    i += 1\n  end\n  # puts a.inspect\n  count = 0\n  i = 0\n  while\
    \ i < a.length - 2\n    j = i + 1\n    while j < a.length - 1\n      k = j + 1\n\
    \      while k < a.length\n        sum = a[i] + a[j] + a[k]\n        if sum %\
    \ 3 == 0\n          count += 1\n        end\n        k += 1\n      end\n     \
    \ j += 1\n    end\n    i += 1\n  end\n  return count\nend", "  a = [*1..n]\n \
    \ a.map! { |i| i * i - i + 1 }\n  result = 0\n  (1..n-2).each do |i|\n    (i+1..n-1).each\
    \ do |j|\n      (j+1..n).each do |k|\n        if (a[i] + a[j] + a[k]) % 3 == 0\n\
    \          result += 1\n        end\n      end\n    end\n  end\n  result\nend",
  "\ta = Array.new(n, 0)\n\t(1..n).each do |i|\n\t\ta[i-1] = i * i - i + 1\n\tend\n\
    \tcount = 0\n\tfor i in 0..(n-3)\n\t\tfor j in (i+1)..(n-2)\n\t\t\tfor k in (j+1)..(n-1)\n\
    \t\t\t\tif a[i] + a[j] + a[k] % 3 == 0\n\t\t\t\t\tcount += 1\n\t\t\t\tend\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn count\nend", "  count = 0\n  (1..n).each do |num|\n\
    \    if num.odd?\n      count += 1\n    else\n      count += 3\n    end\n  end\n\
    \  count\nend", "  s = 0\n  (1..n).each do |i|\n    (i..n).each do |j|\n     \
    \ (j..n).each do |k|\n        s += 1 if (i*i - i + 1 + j*j - j + 1 + k*j - k +\
    \ 1) % 3 == 0\n      end\n    end\n  end\n  s\nend", "  triples = 0\n  total =\
    \ n * n\n  a = Array.new(n) { |i| (i + 1) * (i + 1) - (i + 1) + 1 }\n  i = 0\n\
    \  while (i < n - 2)\n    j = i + 1\n    while (j < n - 1)\n      k = j + 1\n\
    \      while (k < n)\n        if ((a[i] + a[j] + a[k]) % 3 == 0)\n          triples\
    \ += 1\n        end\n        k += 1\n      end\n      j += 1\n    end\n    i +=\
    \ 1\n  end\n  triples\nend", "  a = [1]\n  (2..n).each { |i| a << (i*i - i + 1)\
    \ }\n  # puts \"a: #{a}\"\n  a_triples = []\n  a.each_with_index do |v, i|\n \
    \   a.each_with_index do |vv, ii|\n      a.each_with_index do |vvv, iii|\n   \
    \     next if v == vv || v == vvv || vv == vvv\n        next if (i >= ii) || (ii\
    \ >= iii)\n        next if (v + vv + vvv) % 3 != 0\n        a_triples << [v, vv,\
    \ vvv]\n      end\n    end\n  end\n  a_triples.uniq.count\nend\nputs get_max_triples(5)\
    \ == 1\nputs get_max_triples(15) == 0\nputs get_max_triples(23) == 5\nputs get_max_triples(24)\
    \ == 9\nputs get_max_triples(30) == 14\nputs get_max_triples(97) == 116\nputs\
    \ get_max_triples(100) == 137\nputs get_max_triples(123) == 178\nputs get_max_triples(200)\
    \ == 357", "    res = 0\n    a = []\n    for i in 1..n\n        a << i * i - i\
    \ + 1\n    end\n    (0..n-3).each do |i|\n        (i+1..n-2).each do |j|\n   \
    \         (j+1..n-1).each do |k|\n                res += 1 if (a[i] + a[j] + a[k])\
    \ % 3 == 0\n            end\n        end\n    end\n    res\nend", "  array = (1..n).map\
    \ { |x| x * x - x + 1 }\n  count = 0\n  (1..n-2).each do |i|\n    (i+1..n-1).each\
    \ do |j|\n      (j+1..n).each do |k|\n        count += 1 if (array[i] + array[j]\
    \ + array[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend", "    if n <\
    \ 3\n        return 0\n    end\n    i = 0\n    arr = []\n    res = 0\n    #generate\
    \ array\n    (1..n).each do |i|\n        arr.push(i*i - i + 1)\n    end\n    #check\
    \ for triples\n    i = 0\n    while i < arr.length\n        j = i + 1\n      \
    \  while j < arr.length\n            k = j + 1\n            while k < arr.length\n\
    \                if arr[i] + arr[j] + arr[k] % 3 == 0\n                    res\
    \ += 1\n                end\n                k += 1\n            end\n       \
    \     j += 1\n        end\n        i += 1\n    end\n    return res\nend", "  \
    \  # It is important to know how the numbers are calculated in this case.\n  \
    \  # When I first looked at the problem, I naively thought it was some sort of\
    \ \n    # prime numbers issue or something related to prime factors.\n    # After\
    \ researching a little bit and running some numbers, I figured out that:\n   \
    \ # a[i] = i * i - i + 1\n    # In order to find a pattern, I decided to find\
    \ the sum of the first n numbers:\n    # a[1] + a[2] + a[3] + ... + a[n] = (1\
    \ + 3 + 7 + 13 + ... + a[n])\n    # Using the equation above, we can rewrite it\
    \ as:\n    # (1 + 3 + 7 + 13 + ... + a[n]) = ((1 * 1) - 1 + 1) + ((2 * 2) - 2\
    \ + 1) + ... + ((n * n) - n + 1)\n    # We can now use the summation formula to\
    \ find the maximum value of the sum of the first n numbers:\n    # (1 + 3 + 7\
    \ + 13 + ... + a[n]) = n(n + 1) / 2\n    # For example, if we want to find the\
    \ sum of the first 5 numbers:\n    # (1 + 3 + 7 + 13 + 21) = 5(5 + 1) / 2 = 5\
    \ * 6 / 2 = 15\n    # So, if n = 5, the maximum value of the sum of the first\
    \ 5 numbers is 15.\n    # Now, we can continue with the problem.\n    # Let us\
    \ try to find a pattern to the sum of the first n triples where a[i] + a[j] +\
    \ a[k] is a multiple of 3:\n    # [(1 + 3 + 7), (1 + 3 + 13), (1 + 3 + 21), (1\
    \ + 7 + 13), (1 + 7 + 21), (1 + 13 + 21), \n    # (3 + 7 + 13), (3 + 7 + 21),\
    \ (3 + 13 + 21), (7 + 13 + 21)]\n    # We can see that all the numbers in each\
    \ triple are evenly spaced by 2.\n    # So, the equation for a triple will look\
    \ like this:\n    # a[i] + a[", "  # Write your code here\n  arr = []\n  (1..n).each\
    \ do |i|\n    arr << i*i - i + 1\n  end\n  count = 0\n  arr.each_with_index do\
    \ |a, i|\n    arr.each_with_index do |b, j|\n      next if j <= i\n      arr.each_with_index\
    \ do |c, k|\n        next if k <= j\n        count += 1 if a + b + c == 0\n  \
    \    end\n    end\n  end\n  count\nend", "    # Write your code here\n    a =\
    \ (1..n).map { |i| i * i - i + 1 }\n    triples = []\n    a.each_with_index do\
    \ |x, i|\n        a.each_with_index do |y, j|\n            a.each_with_index do\
    \ |z, k|\n                if i < j && j < k && (x + y + z) % 3 == 0\n        \
    \            # triples << [x, y, z]\n                    triples += 1\n      \
    \          end\n            end\n        end\n    end\n    triples\nend", "  \
    \  a = [0]\n    1.upto(n) do |i|\n        a << i*i - i + 1\n    end\n    puts\
    \ \"a = #{a}\"\n    count = 0\n    3.upto(n) do |i|\n        2.upto(i-1) do |j|\n\
    \            1.upto(j-1) do |k|\n                if a[i] + a[j] + a[k] % 3 ==\
    \ 0\n                    count += 1\n                end\n            end\n  \
    \      end\n    end\n    return count\nend\nputs get_max_triples(20)", "  res\
    \ = 0\n  t = 2\n  s = 2\n  a = []\n  (1..n).each do |i|\n    a << i * i - i +\
    \ 1\n  end\n  p a\n  a.each_with_index do |e, i|\n    t = i + 2\n    s = i + 2\n\
    \    while t < n do\n      s = t + 1\n      while s < n do\n        if (e + a[t]\
    \ + a[s]) % 3 == 0\n          res += 1\n        end\n        s += 1\n      end\n\
    \      t += 1\n    end\n  end\n  res\nend", "  i, j, k = 0, 1, 2\n  a = []\n \
    \ (1..n).each do |i|\n    a << i * i - i + 1\n  end\n  res = 0\n  while i < j\
    \ < k < n\n    triple = a[i] + a[j] + a[k]\n    res += 1 if triple % 3 == 0\n\
    \    i += 1\n    j += 1\n    k += 1\n  end\n  res\nend", "  i = 1\n  j = 2\n \
    \ k = 3\n  output = 0\n  while i < n\n    j = i + 1\n    while j < n\n      k\
    \ = j + 1\n      while k < n\n        val = (i*i - i + 1) + (j*j - j + 1) + (k*k\
    \ - k + 1)\n        if val % 3 == 0\n          output += 1\n        end\n    \
    \    k += 1\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return output\n\
    end", "  # write your code here\n  result = 0\n  triples = (1..n).to_a.map { |x|\
    \ x * x - x + 1 }", "  max_triples = 0\n  a = []\n  1.upto(n) do |i|\n    a[i]\
    \ = i * i - i + 1\n  end\n  1.upto(n) do |i|\n    (i+1).upto(n) do |j|\n     \
    \ (j+1).upto(n) do |k|\n        if(a[i] + a[j] + a[k]) % 3 == 0\n          max_triples\
    \ += 1\n        end\n      end\n    end\n  end\n  max_triples\nend", "\tresult\
    \ = 0\n\t(1..n).each do |i|\n\t\t(i..n).each do |j|\n\t\t\t(j..n).each do |k|\n\
    \t\t\t\tresult += 1 if (i * i - i + 1 + j * j - j + 1 + k * k - k + 1) % 3 ==\
    \ 0\n\t\t\tend\n\t\tend\n\tend\n\tresult\nend\np get_max_triples(1)\np get_max_triples(5)\n\
    p get_max_triples(20)", "  a = (1..n).to_a.map { |el| el * el - el + 1 }\n  count\
    \ = 0\n  for i in 0..n-3\n    for j in i+1..n-2\n      for k in j+1..n-1\n   \
    \     count += 1 if a[i] + a[j] + a[k] % 3 == 0\n      end\n    end\n  end\n \
    \ count\nend", "    n_square = n*n\n    triple_sum = 0\n    # get max possible\
    \ value of (i,j,k)\n    for i in 1..n-2\n        for j in i+1..n-1\n         \
    \   for k in j+1..n\n                triple_sum += 1 if (i*i - i + 1 + j*j - j\
    \ + 1 + k*k - k + 1) % 3 == 0\n            end\n        end\n    end\n    triple_sum\n\
    end", "  a = Array.new(n, 0)\n  a[0] = 1\n  (1..n - 1).each do |idx|\n    a[idx]\
    \ = idx * idx - idx + 1\n  end\n  count = 0\n  (0..n - 3).each do |i|\n    (i\
    \ + 1..n - 2).each do |j|\n      (j + 1..n - 1).each do |k|\n        sum = a[i]\
    \ + a[j] + a[k]\n        if sum % 3 == 0\n          count += 1\n        end\n\
    \      end\n    end\n  end\n  count\nend", "  multiples = {}\n  (1..n).each do\
    \ |i|\n    a_i = i * i - i + 1\n    (1..n).each do |j|\n      a_j = j * j - j\
    \ + 1\n      return multiples[a_i] if multiples[a_i] && multiples[a_i].include?(a_j)\n\
    \      multiples[a_i] ||= []\n      multiples[a_i] << a_j\n    end\n  end\n  multiples\n\
    end", "  a = Array.new(n)\n  triples = 0\n  for i in 1..n do\n    a[i] = i * i\
    \ - i + 1\n  end\n  for i in 1..n do\n    for j in i+1..n do\n      for k in j+1..n\
    \ do\n        if (a[i] + a[j] + a[k]) % 3 == 0\n          triples += 1\n     \
    \   end\n      end\n    end\n  end\n  triples\nend", "  triples = 0\n  (1..n-2).each\
    \ do |i|\n    for j in (i+1..n-1)\n      k = j + 1\n      if (i*i - i + 1 + j*j\
    \ - j + 1 + k*k - k + 1) % 3 == 0\n        puts [i, j, k].to_s\n        triples\
    \ += 1\n      end\n    end\n  end\n  triples\nend", "  ary = (1..n).map { |x|\
    \ x * x - x + 1 }\n  triples = []\n  (0..n-3).each do |i|\n    ((i+1)..n-2).each\
    \ do |j|\n      ((j+1)..n-1).each do |k|\n        triples << [ary[i], ary[j],\
    \ ary[k]] if ary[i] + ary[j] + ary[k] % 3 == 0\n      end\n    end\n  end\n  triples.size\n\
    end", "    a = [1]\n    n.times do\n        a << a[-1] + ((n - a.length + 1) *\
    \ (n - a.length + 1) - (n - a.length + 1) + 1)\n    end\n    count = 0\n    (a.length\
    \ - 2).times do |i|\n        (i + 1..a.length - 1).each do |j|\n            (j\
    \ + 1..a.length - 1).each do |k|\n                count += 1 if a[i] + a[j] +\
    \ a[k] % 3 == 0\n            end\n        end\n    end\n    count\nend", "  a\
    \ = (1..n).map { |x| x * x - x + 1 }\n  count = 0\n  (2..n-1).each do |i|\n  \
    \  (1..i-1).each do |j|\n      count += 1 if (a[i] + a[j]) % 3 == 0\n    end\n\
    \  end\n  count\nend", "    max_triples = 0\n    a = []\n    for i in (1..n)\n\
    \        a << i * i - i + 1\n    end\n    for i in (0..n-3)\n        for j in\
    \ (i+1..n-2)\n            for k in (j+1..n-1)\n                max_triples +=\
    \ 1 if (a[i] + a[j] + a[k]) % 3 == 0\n            end\n        end\n    end\n\
    \    max_triples\nend\nputs get_max_triples(5)\nputs get_max_triples(2)\nputs\
    \ get_max_triples(8)", "  triples = []\n  (1..n).each do |i|\n    a = i * i -\
    \ i + 1\n    (i+1..n).each do |j|\n      b = j * j - j + 1\n      (j+1..n).each\
    \ do |k|\n        c = k * k - k + 1\n        triples << [a, b, c] if ((a + b +\
    \ c) % 3 == 0)\n      end\n    end\n  end\n  triples.size\nend", "  a = []\n \
    \ num_triples = 0\n  for i in 1..n\n    a << i * i - i + 1\n  end\n  puts \"Array\
    \ is #{a}\"\n  for i in 0..n-3\n    for j in i+1..n-2\n      for k in j+1..n-1\n\
    \        if a[i] + a[j] + a[k] % 3 == 0\n          num_triples += 1\n        end\n\
    \      end\n    end\n  end\n  num_triples\nend", "  a = Array.new(n) { |i| i *\
    \ i - i + 1 }\n  count = 0\n  (0..a.length - 3).each do |i|\n    ((i + 1)..a.length\
    \ - 2).each do |j|\n      ((j + 1)..a.length - 1).each do |k|\n        count +=\
    \ 1 if (a[i] + a[j] + a[k]) % 3 == 0\n      end\n    end\n  end\n  count\nend",
  "  triples = (1..n).map { |i| i * i - i + 1 }\n  # can also try:\n  # triples =\
    \ (1..n).map { |i| (2 * i**2 - 2 * i + 2) / 3 }\n  triples_count = 0\n  (0..n-3).each\
    \ do |i|\n    (i+1..n-2).each do |j|\n      (j+1..n-1).each do |k|\n        triples_count\
    \ += 1 if (triples[i] + triples[j] + triples[k]) % 3 == 0\n      end\n    end\n\
    \  end\n  triples_count\nend", "\ta = []\n\ti = 1\n\twhile i <= n\n\t\ta << i\
    \ * i - i + 1\n\t\ti += 1\n\tend\n\ttriples = 0\n\ta.each_with_index do |e1, i|\n\
    \t\tj = i + 1\n\t\twhile j < a.length\n\t\t\tk = j + 1\n\t\t\twhile k < a.length\n\
    \t\t\t\ttriples += 1 if a[i] + a[j] + a[k] % 3 == 0\n\t\t\t\tk += 1\n\t\t\tend\n\
    \t\t\tj += 1\n\t\tend\n\tend\n\ttriples\nend", "    count = 0\n    if n == 1\n\
    \        return count\n    end\n    start = 2\n    stop = n - 1\n    while start\
    \ < stop\n        if (start * start - start + 1 + stop * stop - stop + 1) % 3\
    \ == 0\n            count += 1\n        end\n        stop -= 1\n    end\n    count\n\
    end", "  return 0 if n < 3\n  a = (1..n).map { |i| i * i - i + 1 }\n  max_triples\
    \ = []\n  a.each_with_index do |e1, idx1|\n    a.each_with_index do |e2, idx2|\n\
    \      next if idx2 <= idx1\n      a.each_with_index do |e3, idx3|\n        next\
    \ if idx3 <= idx2\n        max_triples << [e1, e2, e3] if e1 + e2 + e3 % 3 ==\
    \ 0\n      end\n    end\n  end\n  max_triples.count\nend", "    r = n * (n + 1)\
    \ / 2 - 2 * n\n    return [0, r].max\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
