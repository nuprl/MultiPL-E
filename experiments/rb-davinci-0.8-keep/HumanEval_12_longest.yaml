name: HumanEval_12_longest
language: rb
prompt: "# Out of list of strings, return the longest one. Return the first one in\
  \ case of multiple\n# strings of the same length. Return None in case the input\
  \ list is empty.\n# >>> longest([])\n# >>> longest(['a', 'b', 'c'])\n# 'a'\n# >>>\
  \ longest(['a', 'bb', 'ccc'])\n# 'ccc'\ndef longest(strings)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_longest\n\
  \    candidate = method(:longest)\n    assert_equal(nil, candidate.call([]))\n \
  \   assert_equal(\"x\", candidate.call([\"x\", \"y\", \"z\"]))\n    assert_equal(\"\
  zzzz\", candidate.call([\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"]))\n\
  \  end\nend\n"
completions: ["  strings.max_by { |s| s.length }\nend", "  if strings.length == 0\n\
    \    nil\n  else\n    longest = strings[0]\n    strings.each do |string|\n   \
    \   if string.length > longest.length\n        longest = string\n      end\n \
    \   end\n    longest\n  end\nend", "  if strings.empty?\n    return nil\n  end\n\
    \  strings.max { |a, b| a.length <=> b.length }\nend", "  longest = nil\n  strings.each\
    \ do |string|\n    if longest.nil? || string.length > longest.length\n      longest\
    \ = string\n    end\n  end\n  longest\nend", "  if strings.empty?\n    return\
    \ nil\n  else\n    longest_string = strings[0]\n    strings.each do |string|\n\
    \      if string.length > longest_string.length\n        longest_string = string\n\
    \      end\n    end\n    return longest_string\n  end\nend", "  return strings.max_by\
    \ { |x| x.length }\nend", "  max_len = 0\n  max_str = nil\n  strings.each do |str|\n\
    \    if str.length > max_len\n      max_len = str.length\n      max_str = str\n\
    \    end\n  end\n  max_str\nend", "  # strings.sort.last\n  longest = nil\n  strings.each\
    \ do |string|\n    if longest.nil? || string.length > longest.length\n      longest\
    \ = string\n    end\n  end\n  longest\nend", "  max = 0\n  longest = nil\n  strings.each\
    \ do |string|\n    if string.length > max\n      max = string.length\n      longest\
    \ = string\n    end\n  end\n  longest\nend", "\tstrings.sort_by(&:length).last\n\
    end", "  strings.max_by(&:length)\nend", "\nend", "\treturn nil if strings.empty?",
  "  return nil if strings.empty?\n  strings.max_by(&:length)\nend", "  longest =\
    \ strings.max_by { |string| string.length }\n  return longest\nend", "  strings.max_by\
    \ { |x| x.length }\nend", "  raise 'Not implemented'\nend", "  longest = nil\n\
    \  strings.each do |s|\n    if longest.nil? || s.length > longest.length\n   \
    \   longest = s\n    end\n  end\n  longest\nend", "  if strings.empty?\n    return\
    \ nil\n  else\n    longest_word = strings[0]\n    strings.each do |current_word|\n\
    \      if current_word.length > longest_word.length\n        longest_word = current_word\n\
    \      end\n    end\n    return longest_word\n  end\nend", "  return nil if strings.empty?\n\
    \  longest = strings[0]\n  strings.each do |string|\n    longest = string if string.length\
    \ > longest.length\n  end\n  longest\nend", "  i = strings.length\n  if i == 0\n\
    \    return\n  else\n    longest = strings[0]\n    for i in strings\n      if\
    \ i.length > longest.length\n        longest = i\n      end\n    end\n    return\
    \ longest\n  end\nend", "  # BEGIN (write your solution here)\n  longest_word\
    \ = strings.max_by { |x| x.length }", "  if strings.empty?\n    return nil\n \
    \ else\n    strings.sort_by(&:length).last\n  end\nend", "  strings.max_by(&:length)\n\
    end", "\tstrings.sort_by {|s| s.length}.last\nend", "  if strings.length == 0\n\
    \    nil\n  else\n    strings.max_by(&:length)\n  end\nend", "  strings.max_by(&:length)\n\
    end", "  if strings.empty?\n    return nil\n  else\n    strings.max { |a, b| a.length\
    \ <=> b.length }\n  end\nend", "  strings.max_by(&:length)\nend", "  longest =\
    \ strings.sort { |a, b| b.length <=> a.length }.first\n  return longest.nil? ?\
    \ nil : longest\nend", "  # strings.max_by(&:length)\n  if strings.empty?\n  \
    \  nil\n  else\n    strings.sort_by(&:length).last\n  end\nend", "\tif strings.length\
    \ == 0\n\t\treturn nil\n\tend\n\treturn strings.max_by(&:length)\nend", "  return\
    \ nil if strings.empty?\n  strings.sort_by! { |s| s.length }\n  return strings.last\n\
    end", "  strings.max_by(&:length)\nend", end, "\tlongest = nil\n\tstrings.each\
    \ do |string|\n\t\tif (longest == nil)\n\t\t\tlongest = string\n\t\telsif (string.length\
    \ > longest.length)\n\t\t\tlongest = string\n\t\tend\n\tend\n\treturn longest\n\
    end", "  lengths = []\n  strings.each do |string|\n    lengths << string.length\n\
    \  end\n  biggest = lengths.max\n  strings.each do |string|\n    if string.length\
    \ == biggest\n      return string\n    end\n  end\nend", "  strings.sort { |x,\
    \ y| y.length <=> x.length }.first\nend", "  if strings.length == 0\n    return\
    \ nil\n  end\n  str = strings[0]\n  strings.each do |s|\n    if s.length > str.length\n\
    \      str = s\n    end\n  end\n  return str\nend", "  if strings.length == 0\n\
    \    return nil\n  else\n    return strings.max_by(&:length)\n  end\nend", " \
    \ longest = strings.sort_by { |string| string.length }.last\n  if strings.empty?\n\
    \    return nil\n  else\n    return longest\n  end\nend", "  return nil if strings.empty?\n\
    \  answer = strings[0]\n  strings.each do |str|\n    answer = str if str.length\
    \ > answer.length\n  end\n  answer\nend", "  # if strings == []\n  #   return\
    \ nil\n  # end\n  if strings.length == 0\n    return nil\n  end\n  longest_length\
    \ = 0\n  longest_string = \"\"\n  strings.each do |string|\n    if string.length\
    \ > longest_length\n      longest_length = string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  return nil if strings.empty?\n\
    \  strings.max_by(&:length)\nend", "  return strings.sort_by(&:length).last\n\
    end", "  #the same as the last method, but I've been working with this method\
    \ lately so I wanted to use it\n  strings.max_by{|word| word.length}\nend", " \
    \ if strings.length == 0\n    return nil\n  end\n  longest_string = ''\n  strings.each\
    \ do |string|\n    if string.length > longest_string.length\n      longest_string\
    \ = string\n    end\n  end\n  return longest_string\nend", "  # TODO\nend", " \
    \ # TODO: complete function\nend", "  # your code here\nend", "  longest = nil\n\
    \  strings.each do |s|\n    if longest.nil? || s.length > longest.length\n   \
    \   longest = s\n    end\n  end\n  longest\nend", "  answer = nil\n  longest_string\
    \ = 0\n  strings.each do |string|\n    if string.length > longest_string\n   \
    \   longest_string = string.length\n      answer = string\n    end\n  end\n  answer\n\
    end", "\tlongest = nil\n\tstrings.each do |s|\n\t\tif longest == nil || s.length\
    \ > longest.length\n\t\t\tlongest = s\n\t\tend\n\tend\n\treturn longest\nend",
  "\tlongest = nil\n\tstrings.each do |string|\n\t\tif longest == nil\n\t\t\tlongest\
    \ = string\n\t\telsif string.length > longest.length\n\t\t\tlongest = string\n\
    \t\tend\n\tend\n\tlongest\nend", "  return nil if strings.empty?\n  longest =\
    \ strings[0]\n  strings.each do |str|\n    longest = str if str.length > longest.length\n\
    \  end\n  longest\nend", "  longest = strings.max_by { |x| x.length }\n  puts\
    \ longest\nend", "  if strings.empty?\n    return nil\n  else\n    strings.sort_by!(&:length)\n\
    \    return strings[-1]\n  end\nend", "  long_str = nil\n  strings.each do |str|\n\
    \    if long_str.nil?\n      long_str = str\n    elsif str.length > long_str.length\n\
    \      long_str = str\n    end\n  end\n  long_str\nend", "  # YOUR CODE HERE\n\
    end", "  # code here\nend", "  #TODO: implement me\nend", "  max_length = 0\n\
    \  longest_str = nil\n  strings.each do |str|\n    if str.length > max_length\n\
    \      max_length = str.length\n      longest_str = str\n    end\n  end\n  longest_str\n\
    end", "  strings.max_by { |x| x.length }\nend", "  index = 0\n  strings.each do\
    \ |x|\n    if strings[index].length < x.length\n      index = strings.index(x)\n\
    \    end\n  end\n  strings[index]\nend", "  if strings.length < 1\n    return\
    \ nil\n  end\n  current_length = 0\n  index = 0\n  index_max = 0\n  longest_string\
    \ = nil\n  strings.each do |string|\n    index = index + 1\n    if string.length\
    \ > current_length\n      current_length = string.length\n      index_max = index\n\
    \      longest_string = string\n    end\n  end\n  return longest_string\nend",
  "\tlongest = 0\n\tstrings.each do |string|\n\t\tif string.length > longest\n\t\t\
    \tlongest = string.length\n\t\tend\n\tend\n\treturn longest\nend", "  longest\
    \ = strings.max_by(&:length)\n  longest.nil? ? nil : longest\nend", "  return\
    \ strings.max_by { |string| string.length }\nend", "  return nil if strings.empty?\n\
    \  longest = strings[0]\n  strings.each do |s|\n    longest = s if s.length >\
    \ longest.length\n  end\n  longest\nend", "\tlongest = nil\n\tstrings.each do\
    \ |string|\n\t\tif longest == nil || string.length > longest.length\n\t\t\tlongest\
    \ = string\n\t\tend\n\tend\n\tlongest\nend", "  return strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by(&:length)\nend", '  longest
    = strings.first', "  strings.max { |a, b| a.length <=> b.length }\nend", "  longest\
    \ = strings.first\n  strings.each do |word|\n    if word.length > longest.length\n\
    \      longest = word\n    end\n  end\n  longest\nend", "  if strings.empty?\n\
    \    return nil\n  end\n  longest_string = strings[0]\n  strings.each do |string|\n\
    \    if string.length > longest_string.length\n      longest_string = string\n\
    \    end\n  end\n  return longest_string\nend", "  if strings.empty?\n    return\
    \ nil\n  end\n  long_string = ''\n  strings.each do |string|\n    if string.length\
    \ > long_string.length\n      long_string = string\n    end\n  end\n  return long_string\n\
    end", "  if strings.length == 0\n    return nil\n  else\n    strings.max { |a,\
    \ b| a.length <=> b.length }\n  end\nend", "  longest = strings.inject do |memo,\
    \ string|\n    memo.length > string.length ? memo : string\n  end\n  longest ||\
    \ ''\nend", "  return strings.max_by { |x| x.length }\nend", "  if strings.empty?\n\
    \    nil\n  else\n    max = strings[0]\n    strings.each do |x|\n      if x.length\
    \ > max.length\n        max = x\n      end\n    end\n    max\n  end\nend", " \
    \ longest = nil\n  strings.each do |string|\n    if longest.nil?\n      longest\
    \ = string\n    elsif string.length > longest.length\n      longest = string\n\
    \    end\n  end\n  longest\nend", "  longest = strings.max_by { |string| string.length\
    \ }\n  return longest\nend", "  if strings.empty?\n    return nil\n  else\n  \
    \  strings.sort_by { |a| a.length }.last\n  end\nend", "\tif strings.length >\
    \ 0\n\t\tlongest = strings[0]\n\t\tfor i in 1..strings.length-1\n\t\t\tif strings[i].length\
    \ > longest.length\n\t\t\t\tlongest = strings[i]\n\t\t\tend\n\t\tend\n\t\treturn\
    \ longest\n\telse\n\t\treturn nil\n\tend\nend", "\nend", "  return nil if strings.empty?\n\
    \  strings.sort { |x, y| y.length <=> x.length }.first\nend", "\tstrings.max {\
    \ |a, b| a.length <=> b.length }\nend", "  longest = strings.sort_by { |str| str.length\
    \ }.last\n  if strings.empty?\n    return nil\n  else\n    return longest\n  end\n\
    end", "  longest = strings.inject do |memo, str|\n    memo.length > str.length\
    \ ? memo : str\n  end\n  longest ? longest : nil\nend", "  return nil if strings.empty?\n\
    \  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\nend", "  longest\
    \ = nil\n  strings.each do |string|\n    if longest.nil? || string.length > longest.length\n\
    \      longest = string\n    end\n  end\n  longest\nend", "  return nil if strings.empty?\n\
    \  strings.sort_by { |s| s.length }.last\nend", "  return nil if strings.empty?\n\
    \  long = strings[0]\n  strings.each do |x|\n    long = x if x.length > long.length\n\
    \  end\n  long\nend", "  longest = strings.first\n  strings.each do |string|\n\
    \    if string.length > longest.length\n      longest = string\n    end\n  end\n\
    \  longest\nend", "  length = strings.map { |str| str.length }\n  length.include?(0)\
    \ ? nil : strings[length.index(length.max)]\nend", "  strings.max_by(&:length)\n\
    end", "  if strings.length == 0\n    return nil\n  else\n    longest = ''\n  \
    \  strings.each do |word|\n      if word.length > longest.length\n        longest\
    \ = word\n      end\n    end\n    return longest\n  end\nend", "  longest = ''\n\
    \  strings.each do |s|\n    longest = s if s.length > longest.length\n  end\n\
    \  longest\nend", "\nend", "  raise NotImplementedError()\nend", "  strings.max_by(&:length)\n\
    end", "  return nil if strings.empty?\n  strings.max_by(&:length)\nend", "\tlen\
    \ = 0\n\tlongest = nil\n\tstrings.each do |string|\n\t\tif string.length > len\n\
    \t\t\tlen = string.length\n\t\t\tlongest = string\n\t\tend\n\tend\n\tlongest\n\
    end", "  if strings.empty?\n    nil\n  else\n    strings.max_by(&:length)\n  end\n\
    end", "  if strings.empty?\n    nil\n  else\n    strings.max_by(&:length)\n  end\n\
    end", "  if strings.empty?\n    return nil\n  end\n  # strings = %w(a bbbb cccc\
    \ ddddd)\n  longest_string = ''\n  strings.each do |string|\n    if string.length\
    \ > longest_string.length\n      longest_string = string\n    end\n  end\n  longest_string\n\
    end", "  if strings.length > 0\n    longest = strings[0]\n    strings.each do\
    \ |string|\n      if string.length > longest.length\n        longest = string\n\
    \      end\n    end\n    return longest\n  end\nend", "  max = 0\n  max_i = 0\n\
    \  strings.each_with_index do |string, i|\n    if string.length > max\n      max\
    \ = string.length\n      max_i = i\n    end\n  end\n  if max == 0\n    nil\n \
    \ else\n    strings[max_i]\n  end\nend", "\nend", "  # Create a list of strings,\
    \ including the length of each string as a second attribute\n  strings_with_length\
    \ = strings.map { |string| [string, string.length] }\n  # Sort the list by the\
    \ length of the strings\n  strings_with_length.sort! { |a, b| a[1] <=> b[1] }\n\
    \  # Return the string with the longest length\n  strings_with_length.reverse!\n\
    \  if strings_with_length.first.nil?\n    return nil\n  else\n    return strings_with_length.first[0]\n\
    \  end\nend", "  longest = nil\n  strings.each do |word|\n    if longest.nil?\
    \ || word.length > longest.length\n      longest = word\n    end\n  end\n  longest\n\
    end", "  return strings.max_by(&:length) if strings.any?\nend", "  if strings.length\
    \ == 0\n    return nil\n  else\n    longest_word = strings[0]\n    strings.each\
    \ do |word|\n      if word.length > longest_word.length\n        longest_word\
    \ = word\n      end\n    end\n    return longest_word\n  end\nend", "  strings.max_by(&:length)\n\
    end", "\nend", "  if strings.empty?\n    return nil\n  else\n    longest_string\
    \ = strings[0]\n    strings.each do |string|\n      if string.length > longest_string.length\n\
    \        longest_string = string\n      end\n    end\n    return longest_string\n\
    \  end\nend", "  return nil if strings.empty?\n  strings.sort_by(&:length).last\n\
    end", "  longest = nil\n  strings.each do |x|\n    if longest == nil || x.length\
    \ > longest.length\n      longest = x\n    end\n  end\n  longest\nend", "  return\
    \ nil if strings.empty?\n  strings.sort_by(&:length).reverse.first\nend", "\t\
    strings.max_by(&:length)\nend", "  max_len = strings.max_by(&:length).length\n\
    \  strings.detect { |str| str.length == max_len }\nend", end, "  strings.max\n\
    end", "  lengths = strings.collect { |s| s.length }\n  max = lengths.max\n  strings.bsearch\
    \ { |s| s.length >= max }\nend", "\nend", "  return strings.max_by { |s| s.length\
    \ } if strings.length > 0\n  return nil\nend", "  return nil if strings.empty?\n\
    \  strings.max\nend", "  strings.max_by(&:length)\nend", "  strings.inject{|memo,\
    \ word| memo.length > word.length ? memo : word}\nend", "  return strings.max_by\
    \ { |i| i.length }\nend", "  strings.max_by(&:length)\nend", "  return strings.max_by(&:length)\n\
    end", "\treturn nil if strings.empty?\n\tstrings.sort_by { |string| string.length\
    \ }.last\nend", "  return nil if strings.empty?\n  strings.max_by { |str| str.length\
    \ }\nend", "  return nil if strings.empty?\n  longest = strings[0]\n  strings.each\
    \ do |string|\n    longest = string if string.length > longest.length\n  end\n\
    \  longest\nend", "  strings.max_by(&:length)\nend", end, "  if strings.empty?\n\
    \    return nil\n  end\n  strings.max_by { |x| x.length }\nend", "  # TODO YOUR\
    \ CODE HERE\nend", "  strings.reduce do |longest, string|\n    if string.length\
    \ > longest.length\n      string\n    else\n      longest\n    end\n  end\nend",
  "  strings.sort_by(&:length).last\nend", "  maxlen = 0\n  maxstring = nil\n  strings.each\
    \ do |s|\n    if s.length > maxlen\n      maxlen = s.length\n      maxstring =\
    \ s\n    end\n  end\n  maxstring\nend", "  longest = nil\n  if strings.length\
    \ > 0\n    longest = strings[0]\n    strings.each do |str|\n      if str.length\
    \ > longest.length\n        longest = str\n      end\n    end\n  end\n  longest\n\
    end", "  return nil if strings.empty?\n  strings.inject { |memo, str| str.length\
    \ > memo.length ? str : memo }\nend", "  if strings.empty?\n    return nil\n \
    \ end\n  strings.max_by { |string| string.length }\nend", "  long = ''\n  strings.each\
    \ do |n|\n    if n.length > long.length\n      long = n\n    end\n  end\n  return\
    \ long\nend", "  return nil if strings.empty?\n  longest = strings[0]\n  strings.each\
    \ do |string|\n    longest = string if string.length > longest.length\n  end\n\
    \  longest\nend", "  if strings.length == 0\n    return nil\n  else\n    strings.sort_by!\
    \ { |x| x.length }\n    return strings[-1]\n  end\nend", "  longest = nil\n  strings.each\
    \ do |string|\n    if longest.nil? || string.length > longest.length\n      longest\
    \ = string\n    end\n  end\n  longest\nend", "  longest = strings.sort_by { |string|\
    \ string.length }.reverse[0]\n  longest != nil ? longest : nil\nend", "  # TODO:\
    \ implementation goes here\nend", "  return nil if strings.empty?\n  strings.sort_by(&:length).last\n\
    end", "  return nil if strings.empty?\n  strings.sort_by(&:length).last\nend",
  "  longest = strings.max_by { |word| word.length }\n  if strings.empty?\n    return\n\
    \  else\n    return longest\n  end\nend", "  # your code here\nend", "  strings.sort_by\
    \ { |str| str.length }.last\nend", "  if strings.length == 0\n    return nil\n\
    \  else\n    longest = strings[0]\n    strings.each do |s|\n      if s.length\
    \ > longest.length\n        longest = s\n      end\n    end\n    return longest\n\
    \  end\nend", "  strings.max_by { |string| string.length }\nend", "  return nil\
    \ if strings.empty?\n  strings.max_by(&:length)\nend", "  strings.max_by(&:length)\n\
    end", "  strings.inject do |memo, string|\n    memo.length > string.length ? memo\
    \ : string\n  end\nend", "  strings.max_by(&:length)\nend", "\nend", "  # your\
    \ code goes here\nend", "  longest = nil\n  strings.each do |str|\n    if longest.nil?\
    \ || str.length > longest.length\n      longest = str\n    end\n  end\n  longest\n\
    end", "  return nil if strings.empty?\n  longest = strings[0]\n  strings.each\
    \ do |string|\n    longest = string if string.length > longest.length\n  end\n\
    \  longest\nend", "\t#<YOUR CODE HERE>\nend", "  strings.max_by { |string| string.length\
    \ }\nend", "  strings.max_by(&:length)\nend", "  if !strings.empty?\n    return\
    \ strings.max_by(&:length)\n  end\nend", "  strings.map(&:length).max\nend", "\t\n\
    end", "  strings.sort_by(&:length).last\nend", "  longest = nil\n  strings.each\
    \ do |str|\n    if longest.nil? || str.length > longest.length\n      longest\
    \ = str\n    end\n  end\n  longest\nend", "  len = 0\n  long = \"\"\n  strings.each\
    \ do |string|\n    if string.length > len\n      len = string.length\n      long\
    \ = string\n    end\n  end\n  long\nend", "  return nil if strings.empty?\n  longest\
    \ = strings[0]\n  strings.each do |word|\n    longest = word if word.length >\
    \ longest.length\n  end\n  longest\nend", "  strings.empty? ? nil : strings.max_by(&:length)\n\
    end", "  # your code here\nend", "  if strings.length == 0\n    return nil\n \
    \ else\n    strings.max_by(&:length)\n  end\nend", "\treturn nil if strings.empty?\n\
    \tlongest = strings[0]\n\tstrings.each do |string|\n\t\tlongest = string if string.length\
    \ > longest.length\n\tend\n\tlongest\nend", "  longest = strings.max_by { |string|\
    \ string.length }\n  if strings.empty?\n    nil\n  else\n    longest\n  end\n\
    end", "\tif strings.length > 0\n\t\tlongestString = strings[0]\n\t\tfor i in 1..strings.length-1\n\
    \t\t\tif strings[i].length > longestString.length\n\t\t\t\tlongestString = strings[i]\n\
    \t\t\tend\n\t\tend\n\t\treturn longestString\n\telse\n\t\treturn nil\n\tend\n\
    end", "  return nil if strings.empty?\n  strings.sort_by { |str| str.length }.last\n\
    end", "  max = strings.max_by(&:length)\n  return max if max != nil\nend", " \
    \ strings.max_by { |s| s.length }\nend", "  #return nil if strings.empty?\n  longest\
    \ = strings.inject do |memo, word|\n    memo.length > word.length ? memo : word\n\
    \  end\n  longest\nend", "  str = nil\n  strings.each do |s|\n    if str.nil?\
    \ || s.length > str.length\n      str = s\n    end\n  end\n  str\nend", "  if\
    \ strings.empty?\n    return nil\n  else\n    longest_word = strings[0]\n    strings.each\
    \ do |word|\n      if word.length > longest_word.length\n        longest_word\
    \ = word\n      end\n    end\n    return longest_word\n  end\nend", "  return\
    \ nil if strings.length == 0\n  longest = \"\"\n  strings.each do |string|\n \
    \   longest = string if string.length > longest.length\n  end\n  longest\nend",
  "  return nil if strings.empty?\n  strings.max_by { |x| x.length }\nend", "  return\
    \ nil if strings.empty?\n  longest = strings[0]\n  strings.each do |string|\n\
    \    longest = string if string.length > longest.length\n  end\n  longest\nend",
  "  strings.max_by(&:length)\nend", "  if strings.empty?\n    return nil\n  else\n\
    \    max_length = strings.max_by { |word| word.length }\n    return max_length\n\
    \  end\nend", "  return nil if strings.empty?\n  longest = strings[0]\n  strings.each\
    \ do |string|\n    longest = string if string.length > longest.length\n  end\n\
    \  longest\nend", "  strings.max_by { |string| string.length }\nend", "  # \n\
    end", "  longest = nil\n  strings.each do |word|\n    if longest.nil? || word.length\
    \ > longest.length\n      longest = word\n    end\n  end\n  longest\nend", " \
    \ strings.empty? ? nil : strings.max_by { |s| s.length }\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
