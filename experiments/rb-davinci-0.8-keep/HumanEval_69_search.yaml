name: HumanEval_69_search
language: rb
prompt: "# You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n# zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n# The frequency of an integer is the number\
  \ of times it appears in the list.\n# If no such a value exist, return -1.\n# Examples:\n\
  # search([4, 1, 2, 2, 3, 1]) == 2\n# search([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n\
  # search([5, 5, 4, 4, 4]) == -1\ndef search(lst)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_search\n\
  \    candidate = method(:search)\n    assert_equal(1, candidate.call([5, 5, 5, 5,\
  \ 1]))\n    assert_equal(4, candidate.call([4, 1, 4, 1, 4, 4]))\n    assert_equal(-1,\
  \ candidate.call([3, 3]))\n    assert_equal(8, candidate.call([8, 8, 8, 8, 8, 8,\
  \ 8, 8]))\n    assert_equal(2, candidate.call([2, 3, 3, 2, 2]))\n    assert_equal(1,\
  \ candidate.call([2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10,\
  \ 8, 1]))\n    assert_equal(2, candidate.call([3, 2, 8, 2]))\n    assert_equal(1,\
  \ candidate.call([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]))\n    assert_equal(-1, candidate.call([8,\
  \ 8, 3, 6, 5, 6, 4]))\n    assert_equal(1, candidate.call([6, 9, 6, 7, 1, 4, 7,\
  \ 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]))\n    assert_equal(1,\
  \ candidate.call([1, 9, 10, 1, 3]))\n    assert_equal(5, candidate.call([6, 9, 7,\
  \ 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]))\n    assert_equal(1,\
  \ candidate.call([1]))\n    assert_equal(4, candidate.call([8, 8, 10, 6, 4, 3, 5,\
  \ 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]))\n    assert_equal(2, candidate.call([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]))\n    assert_equal(1, candidate.call([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]))\n    assert_equal(4, candidate.call([9, 2,\
  \ 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8,\
  \ 10, 9, 4]))\n    assert_equal(4, candidate.call([2, 6, 4, 2, 8, 7, 5, 6, 4, 10,\
  \ 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]))\n    assert_equal(2, candidate.call([9,\
  \ 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]))\n    assert_equal(-1,\
  \ candidate.call([5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10,\
  \ 8]))\n    assert_equal(-1, candidate.call([10]))\n    assert_equal(2, candidate.call([9,\
  \ 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]))\n    assert_equal(1, candidate.call([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]))\n    assert_equal(1, candidate.call([7, 9, 9,\
  \ 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]))\n    assert_equal(-1,\
  \ candidate.call([3, 10, 10, 9, 2]))\n  end\nend\n"
completions: ["  max_freq = 0\n  # Find most frequent number\n  lst.each do |num|\n\
    \    if lst.count(num) > max_freq\n      max_freq = lst.count(num)\n    end\n\
    \  end\n  # Find max number\n  max_num = lst.max\n  # Return num if frequency\
    \ is greater than or equal to the num\n  if max_freq >= max_num\n    return max_num\n\
    \  else\n    return -1\n  end\nend", "    frequencies = Hash.new(0)\n    lst.each\
    \ { |n| frequencies[n] += 1 }\n    maximum_key = frequencies.max_by { |k, v| k\
    \ }[0]\n    frequencies.each { |k, v| return k if k <= v && k > 0 && k >= maximum_key\
    \ }\n    -1\nend", "    hash = Hash.new(0)\n    lst.each {|x| hash[x] += 1}\n\
    \    hash.each {|k, v| return k if k <= v}\n    -1\nend", "    uniques = lst.uniq\n\
    \    answer = -1\n    uniques.each do |n|\n        if lst.count(n) >= n\n    \
    \        answer = n\n        end\n    end\n    answer\nend", "\t# create a hash\
    \ where keys are integers and values are the frequencies of the integers\n\t#\
    \ in the input list\n\thash = Hash.new(0)\n\tlst.each do |num|\n\t\thash[num]\
    \ += 1\n\tend\n\t# create an array of integers that is greater than zero and has\
    \ a frequency\n\t# greater than or equal to its value\n\tgreater_than_zero = hash.select\
    \ { |k, v| k > 0 && v >= k }.keys\n\t# sort the array in decreasing order, and\
    \ return the first number\n\treturn greater_than_zero.sort.reverse[0] == nil ?\
    \ -1 : greater_than_zero.sort.reverse[0]\nend\nputs search([4, 1, 2, 2, 3, 1])",
  "  new_lst = lst.uniq.sort\n  return -1 if new_lst.last == new_lst.size \n  new_lst.reverse.each\
    \ { |v| return v if lst.count(v) >= v }\nend", "  lst.uniq.sort.reverse.each do\
    \ |i|\n    return i if lst.count(i) >= i\n  end\n  -1\nend", "  count = {}\n \
    \ lst.each { |item| count[item] = count[item].to_i + 1 }\n  result = count.max_by\
    \ { |k, v| k }\n  result[0] <= result[1] ? result[0] : -1\nend", "  lst.sort.reverse.each\
    \ do |i|\n    return i if lst.count(i) >= i\n  end\n  -1\nend", "  hash = {}\n\
    \  max = 0\n  lst.each do |e|\n    if hash[e] == nil\n      hash[e] = 1\n    else\n\
    \      hash[e] += 1\n    end\n    max = e if e > max\n  end\n  hash.each do |k,\
    \ v|\n    return k if k == v && k >= max\n  end\n  -1\nend\np search([4, 1, 2,\
    \ 2, 3, 1])\np search([1, 2, 2, 3, 3, 3, 4, 4, 4])\np search([5, 5, 4, 4, 4])\n\
    p search([3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3",
  "  lst.uniq.select { |n| lst.count(n) >= n }.max || -1\nend", "  max, result = 0,\
    \ -1\n  lst.each { |x| lst.count(x) >= x && x > max ? (max, result = x, x) : x\
    \ }\n  result\nend", "  hash = Hash.new(0)\n  lst.each { |num| hash[num] += 1\
    \ }\n  hash.select { |k, v| k == v }.max_by { |k, v| k }.last\nend", "  freq =\
    \ {}\n  lst.each { |n| freq[n] = lst.count(n) }\n  freq.select { |k, v| k <= v\
    \ }.max[0]\nend", "  new_hash = Hash.new(0)\n  lst.each { |i| new_hash[i] += 1\
    \ }\n  new_hash.select { |key, value| key == value }.key(new_hash.values.max)\
    \ || -1\nend", "  return -1 if lst.count == 0\n  return -1 if lst.count { |x|\
    \ x == 5 } < 5\n  return -1 if lst.count { |x| x == 4 } < 4\n  return -1 if lst.count\
    \ { |x| x == 3 } < 3\n  return -1 if lst.count { |x| x == 2 } < 2\n  return -1\
    \ if lst.count { |x| x == 1 } < 1\n  return -1 if lst.count { |x| x == 6 } < 6\n\
    \  return -1 if lst.count { |x| x == 7 } < 7\n  return -1 if lst.count { |x| x\
    \ == 8 } < 8\n  return -1 if lst.count { |x| x == 9 } < 9\n  return 1 if lst.count\
    \ { |x| x == 1 } == 1\n  return 2 if lst.count { |x| x == 2 } == 2\n  return 3\
    \ if lst.count { |x| x == 3 } == 3\n  return 4 if lst.count { |x| x == 4 } ==\
    \ 4\n  return 5 if lst.count { |x| x == 5 } == 5\n  return 6 if lst.count { |x|\
    \ x == 6 } == 6\n  return 7 if lst.count { |x| x == 7 } == 7\n  return 8 if lst.count\
    \ { |x| x == 8 } == 8\n  return 9 if lst.count { |x| x == 9 } == 9\nend", "  a\
    \ = lst.group_by{|v| v}.select{|k,v| k == v.size}\n  if a.size == 0\n    return\
    \ -1\n  else\n    a.max[0]\n  end\nend", "    # your code here\nend", "\tanswer\
    \ = []\n\tlst.each do |num|\n\t\tanswer << num if lst.count(num) >= num\n\tend\n\
    \tanswer.uniq.max || -1\nend", "\tnew_lst = lst.sort\n\ta = Hash.new\n\tnew_lst.each\
    \ do |x|\n\t\tif a[x] == nil\n\t\t\ta[x] = 1\n\t\telse\n\t\t\ta[x] += 1\n\t\t\
    end\n\tend\n\ta = a.sort_by {|k,v| k}\n\ta.each do |x|\n\t\tif x[0] == x[1]\n\t\
    \t\treturn x[0]\n\t\tend\n\tend\n\treturn -1\nend", "    # Create dictionary with\
    \ key as the value and value as the count\n    d = {}\n    lst.each do |v|\n \
    \       if d.has_key?(v)\n            d[v] += 1\n        else\n            d[v]\
    \ = 1\n        end\n    end\n    # Iterate over keys of dictionary\n    d.keys.each\
    \ do |k|\n        # Key cannot be greater than length of list\n        if k <=\
    \ lst.length\n            # If key is greater than value, return key\n       \
    \     if k <= d[k]\n                return k\n            end\n        end\n \
    \   end\n    # If no value found, return -1\n    return -1\nend", "    ans = -1\n\
    \    freq = Hash.new(0)\n    lst.each do |int|\n        freq[int] += 1\n    end\n\
    \    lst.each do |int|\n        if freq[int] >= int && int > ans\n           \
    \ ans = int\n        end\n    end\n    ans\nend", "  number = 1\n  frequency =\
    \ Hash.new(0)\n  lst.each { |x| frequency[x] += 1 }\n  frequency.each do |num,\
    \ frequency|\n    return number if num == frequency && num > 0\n    number +=\
    \ 1\n  end\n  -1\nend", "  #Your code here\nend", "  return -1 if lst.length ==\
    \ 1\n  hsh = lst.inject(Hash.new(0)) { |h, e| h[e] += 1; h }\n  key_max = hsh.max_by\
    \ { |k, v| v }[0]\n  if hsh[key_max] >= key_max\n    key_max\n  else\n    -1\n\
    \  end\nend", "  out_hash = {}\n  out_arr = []\n  lst.each do |i|\n    if !out_hash.key?(i)\n\
    \      out_hash[i] = 1\n    else\n      out_hash[i] += 1\n    end\n  end\n  out_hash.each\
    \ do |k, v|\n    if v >= k\n      out_arr << k\n    end\n  end\n  out_arr.sort.last\n\
    end", "    # one liner\n    lst.uniq.sort.map{|x| x if lst.count(x) >= x}.compact.last\n\
    \    \n    # regular way\n    lst = lst.uniq.sort\n    lst.each {|x| return x\
    \ if lst.count(x) >= x}\n    -1\nend", "  count = Hash.new 0\n  lst.each do |x|\n\
    \    count[x] += 1\n  end\n  count.each_pair do |key, value|\n    if key == value\n\
    \      return key\n    end\n  end\n  return -1\nend", "  freq = {}\n  lst.each\
    \ do |num|\n    freq[num] ||= 0\n    freq[num] += 1\n  end\n  freq.keys.max {\
    \ |a, b| (freq[a] >= a) && (freq[b] >= b) ? a <=> b : freq[b] <=> freq[a] }\n\
    end", "  hash = Hash.new(0)\n  lst.each { |val| hash[val] += 1 }\n  hash.keys.sort.each\
    \ do |k|\n    return k if k <= hash[k]\n  end\n  -1\nend", "  hash = Hash.new(0)\n\
    \  lst.each { |num| hash[num] += 1 }\n  sorted = hash.sort_by { |num, count| count\
    \ }.reverse.to_h\n  sorted.map { |num, count| sorted.key(num) if num <= count\
    \ }.compact.first\nend", "  counts = lst.group_by(&:itself).transform_values(&:count)\n\
    \  counts.max_by { |k, v| v >= k ? v : 0 }&.first || -1\nend", "  lst.sort!\n\
    \  lst.uniq.each do |i|\n    return i if lst.count(i) >= i\n  end\n  -1\nend",
  "    freq = {}\n    lst.each { |item| freq[item] = lst.count(item) }\n    freq.each\
    \ { |key, value| return key if key <= value }\n    -1\nend", "    max_int = 1\n\
    \    max_count = 0\n    lst.each do |i|\n        count = lst.count(i)\n      \
    \  if count >= i\n            if i > max_int\n                max_int = i\n  \
    \              max_count = count\n            elsif i == max_int && count > max_count\n\
    \                max_count = count\n            end\n        end\n    end\n  \
    \  if max_count < max_int\n        return -1\n    else\n        return max_int\n\
    \    end\nend", "  lst.group_by(&:itself).select { |_, v| v.size >= _ }.keys.max\
    \ || -1\nend", "  result = 0\n  lst.sort.each do |num|\n    if lst.count(num)\
    \ >= num\n      result = num\n    else\n      return -1\n    end\n  end\n  result\n\
    end", "  lst.each_with_object(Hash.new(0)) { |num, hash| hash[num] += 1 }\n  \
    \     .reject { |k,v| k < v }\n       .max_by { |k,v| k }\n       .first\nend",
  "    numbers = {}\n    lst.each do |number|\n        if numbers[number]\n      \
    \      numbers[number] += 1\n        else\n            numbers[number] = 1\n \
    \       end\n    end\n    numbers = numbers.sort_by {|k, v| k}\n    numbers.each\
    \ do |number|\n        if number[0] > number[1]\n            return -1\n     \
    \   elsif number[0] == number[1]\n            return number[0]\n        end\n\
    \    end\nend", "  lst.max if lst.count(lst.max) >= lst.max\nend", "  hsh = {}\n\
    \  sorted_array = []\n  lst.each do |x|\n    if hsh[x] == nil\n      hsh[x] =\
    \ 1\n    else\n      hsh[x] += 1\n    end\n  end\n  hsh.each do |key, value|\n\
    \    value.times do\n      sorted_array << key\n    end\n  end\n  sorted_array\
    \ = sorted_array.sort\n  sorted_array.each do |x|\n    if x >= sorted_array.count(x)\n\
    \      return x\n    end\n  end\n  return -1\nend", "    max_count = -1\n    max_val\
    \ = -1\n    lst.each do |n|\n        count = lst.count(n)\n        if count >=\
    \ n && count > max_count\n            max_count = count\n            max_val =\
    \ n\n        end\n    end\n    max_val\nend", "    elements_with_frequency = {}\n\
    \    lst.each do |element|\n        elements_with_frequency[element] = lst.count(element)\n\
    \    end\n    p elements_with_frequency.sort_by {|x,y| y}.reverse.find{|k,v| k\
    \ == v} || -1\nend", "    dic = {}\n    for i in lst\n        if dic[i] != nil\n\
    \            dic[i] += 1\n        else\n            dic[i] = 1\n        end\n\
    \    end\n    while dic.size != 0\n        val = dic.keys.max\n        if dic[val]\
    \ < val\n            dic.delete(val)\n        else\n            return val\n \
    \       end\n    end\n    return -1\nend", "    # return lst.length if lst.uniq.size\
    \ == 1\n    lst.uniq.max { |a, b| lst.count(a) <=> lst.count(b) }\nend", "  lst.group_by(&:itself).select\
    \ { |k, v| k <= v.size }.max.last.first rescue -1\nend", "  freq = {}\n  lst.each\
    \ { |num| freq[num] = lst.count(num) }\n  freq.select { |k, v| v >= k }.sort.reverse.first.first\
    \ rescue -1\nend", "    counts = lst.each_with_object(Hash.new(0)) { |num,counts|\
    \ counts[num] += 1 }\n    counts.each do |key,value|\n        return key if key\
    \ <= value\n    end\n    -1\nend", "  lst.select { |x| lst.count(x) >= x }.max\
    \ || -1\nend", "  val = lst.size.downto(1).find { |i| lst.count(i) >= i }\n  val\
    \ ? val : -1\nend", "  lst.each_with_object(Hash.new(0)) { |num, hsh| hsh[num]\
    \ += 1 }\n    .max_by { |k, v| k <= v ? v : 0 }\n    .first\nend", "  #your code\
    \ here\nend", "    return -1 if lst.uniq.all? { |el| lst.count(el) < el }\n  \
    \  lst.uniq.sort { |a, b| lst.count(b) <=> lst.count(a) }.find { |el| lst.count(el)\
    \ >= el }\nend", "  # convert list to hash with ints as keys and frequency as\
    \ values\n  hash = Hash.new(0)\n  lst.each { |num| hash[num] += 1 }\n  # return\
    \ the largest value that is greater than zero and its frequency is >= to the int\
    \ value\n  hash.keys.sort.reverse.each { |key| return key if key <= hash[key]\
    \ }\n  # if no such value exists, return -1\n  -1\nend", "  return -1 if lst.size\
    \ < 1\n  counts = {}\n  lst.each do |n|\n    counts[n] ||= 0\n    counts[n] +=\
    \ 1\n  end\n  (counts.size - 1).downto(1) do |n|\n    return n if counts[n] >=\
    \ n\n  end\n  -1\nend", "  arr = Array.new(lst.length + 1, 0)\n  lst.each do |num|\n\
    \    arr[num] += 1\n  end\n  arr.each_with_index do |num, idx|\n    return idx\
    \ if num >= idx && idx > 0\n  end\n  -1\nend", "  return -1 if lst.empty?\n  lst.max.downto(1)\
    \ do |n|\n    return n if lst.count(n) >= n\n  end\n  -1\nend", "\treturn -1 if\
    \ lst.uniq.length == lst.length\n\tlst.max { |a, b| lst.count(a) <=> lst.count(b)\
    \ }\nend", "  lst.uniq.map{|n| [n, lst.count(n)]}.select{|n, c| n <= c}.max.try(:first)\
    \ || -1\nend", "  new_lst = lst.sort\n  new_lst.each do |x|\n    if x == new_lst.count(x)\n\
    \      return x\n    end\n  end\n  return -1\nend", "  hash = Hash.new(0)\n  lst.each\
    \ { |e| hash[e] += 1 }\n  unique_keys = hash.keys.uniq.sort\n  unique_keys.reverse.each\
    \ do |k|\n    return k if hash[k] >= k\n  end\n  -1\nend", "    # Your code here\n\
    \    return -1 if lst.max < 2\n    count = 1\n    biggest = lst.max\n    (1..lst.max).each\
    \ do |i|\n      if lst.count(i) >= i\n        biggest = i\n      end\n    end\n\
    \    biggest\nend", "  freq = Hash.new(0)\n  lst.each { |v| freq[v] += 1 }\n \
    \ freq.select { |k,v| v >= k }.max[0]\nend\np search([4, 1, 2, 2, 3, 1])\np search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4])\np search([5, 5, 4, 4, 4])", "  lst.each do |num|\n\
    \    if lst.count(num) >= num\n      return num\n    end\n  end\n  return -1\n\
    end", "\tlst.each_with_object(Hash.new(0)) { |n, h| h[n] += 1 }.select { |k, v|\
    \ k == v }.max&.first || -1\nend", "  lst.max_by { |x| lst.count(x) >= x ? x :\
    \ 0 } || -1\nend", "  lst.uniq.each do |el|\n    return el if lst.count(el) >=\
    \ el\n  end\n  -1\nend", "  lst.uniq.each do |x|\n    return x if lst.count(x)\
    \ >= x\n  end\n  -1\nend", "  lst.each do |i|\n    return i if lst.count(i) >=\
    \ i\n  end\n  -1\nend", "  counts = Hash.new(0)\n  lst.each do |num|\n    counts[num]\
    \ += 1\n  end\n  counts.each do |key, value|\n    return key if key == value\n\
    \  end\n  -1\nend", "  h = {}\n  lst.each { |n| h[n] = lst.count(n) }\n  h.select!\
    \ { |k, v| v >= k }\n  h.any? ? h.keys.max : -1\nend", "  final_number = -1\n\
    \  num_freq = {}\n  lst.each do |num|\n    num_freq[num] ||= 0\n    num_freq[num]\
    \ += 1\n  end\n  num_freq.sort_by { |k, v| k }.reverse.each do |k, v|\n    if\
    \ k <= v && k > final_number\n      final_number = k\n    end\n  end\n  final_number\n\
    end", "  return -1 if lst.uniq.all? { |x| lst.count(x) < x }\n  lst.uniq.each\
    \ { |x| return x if lst.count(x) >= x }\nend", "    freq = {}\n    lst.each do\
    \ |num|\n        freq[num] = lst.count(num)\n    end\n    freq.each do |k, v|\n\
    \        if k > v\n            return -1\n        elsif k == v\n            return\
    \ k\n        end\n    end\nend", "  lst.group_by(&:itself).max_by{|k,v| v.size}.try(:first)\n\
    end", "    lst.uniq.sort.each do |x|\n        if lst.count(x) >= x\n         \
    \   return x\n        end\n    end\n    return -1\nend", "    return -1 if lst.empty?\n\
    \    search = lst.max\n    while search > 0\n        if lst.count(search) >= search\n\
    \            return search\n        else\n            search -= 1\n        end\n\
    \    end\n    return -1\nend", "  hash = {}\n  max = 0\n  value = 0\n  lst.each\
    \ do |item|\n    hash[item] = 0 if hash[item].nil?\n    hash[item] += 1\n    if\
    \ hash[item] >= item && hash[item] > max\n      max = hash[item]\n      value\
    \ = item\n    end\n  end\n  max == 0 ? -1 : value\nend", "    hash = Hash.new(0)\n\
    \    lst.each {|i| hash[i] += 1}\n    hash.each {|k, v| return k if k <= v}\n\
    \    -1\nend", "\t# Create dictionary for frequencies\n\tfreq = Hash.new(0)\n\t\
    # Track which number is greater than zero and has a frequency \n\t# greater than\
    \ or equal to the value of the integer itself\n\tanswer = -1\n\t# Store frequencies\
    \ into dictionary\n\tlst.each do |num|\n\t\tfreq[num] += 1\n\tend\n\t# Find number\n\
    \tfreq.each do |num, f|\n\t\tif num > 0 and f >= num\n\t\t\tanswer = num\n\t\t\
    end\n\tend\n\treturn answer\nend", "    counts = Hash.new(0)\n    lst.each { |i|\
    \ counts[i] += 1 }\n    counts.select { |k, v| k <= v }.keys.max || -1\nend",
  "  values = lst.group_by(&:itself).transform_values(&:size)\n  values.find { |k,\
    \ v| v >= k }.first\nend", "    h=Hash.new(0)\n    lst.each{|x| h[x]+=1}\n   \
    \ r=h.reject{|k,v|v<k}\n    r.empty? ? -1 : r.max_by{|k,v|k}[0]\nend", "  list\
    \ = Hash.new(0)\n  max = 0\n  lst.each { |x| list[x] += 1 }\n  list.each { |k,\
    \ v| max = k if k >= v && k > max }\n  max == 0 ? -1 : max\nend", "  #using hash\
    \ to count the frequency of each int\n  hash = Hash.new(0)\n  lst.each {|i| hash[i]\
    \ += 1}\n  #checking if the freq. is >= to the value itself\n  hash.each do |k,\
    \ v|\n    if v >= k\n      return k\n    end\n  end\n  return -1\nend\nputs \"\
    search\"\nputs search([1, 2, 2, 3, 3, 3, 4, 4, 4])\nputs search([5, 5, 4, 4, 4])\n\
    puts search([4, 1, 2, 2, 3, 1])\nputs ", "    max_integer = lst.max\n    freq_hash\
    \ = {}\n    lst.each do |num|\n        if freq_hash[num]\n            freq_hash[num]\
    \ += 1\n        else\n            freq_hash[num] = 1\n        end\n    end\n \
    \   freq_hash.each do |key, value|\n        if key >= value && key > 0\n     \
    \       max_integer = key\n        end\n    end\n    if max_integer == freq_hash[max_integer]\n\
    \        return max_integer\n    else\n        return -1\n    end\nend", "  return\
    \ -1 if lst.size == 1 && lst[0] != 1\n  return -1 if lst.size == 1 && lst[0] ==\
    \ 1\n  return -1 if lst.size == 0\n  numbers = lst.uniq.sort\n  numbers.each do\
    \ |num|\n    return num if num <= lst.count(num)\n  end\n  -1\nend", "  #the frequency\
    \ of a number is stored in a hash\n  lst_hash = {}\n  lst.each do |num|\n    lst_hash[num]\
    \ = 0\n  end\n  lst.each do |num|\n    lst_hash[num] += 1\n  end\n  lst_hash.each\
    \ do |key, value|\n    if key <= value\n      return key\n    end\n  end\n  return\
    \ -1\nend\nputs search([4, 1, 2, 2, 3, 1])\nputs search([1, 2, 2, 3, 3, 3, 4,\
    \ 4, 4])\nputs search([5, 5, 4, 4, 4])", "  num_count = Hash.new(0)\n  lst.each\
    \ do |num|\n    num_count[num] += 1\n  end\n  num_count.values.sort.reverse.each\
    \ do |count|\n    num_count.key(count).to_i >= count ? (return count) : (next)\n\
    \  end\n  -1\nend", "  count = 0\n  lst.sort!\n  value = lst.length - 1\n  while\
    \ value >= 0\n    if lst[value] == lst[value - 1]\n      count += 1\n    else\n\
    \      if lst[value] <= count\n        return lst[value]\n      else\n       \
    \ count = 0\n      end\n    end\n    value -= 1\n  end\n  -1\nend", "  lst.uniq.map\
    \ { |num| lst.count(num) >= num ? num : -1 }.max\nend", "  if lst.count > 0\n\
    \    mx = 0\n    for i in lst\n      mx = i if i > mx\n    end\n    for i in 1..mx\n\
    \      return i if lst.count(i) >= i\n    end\n    return -1\n  else\n    return\
    \ -1\n  end\nend", "  max = -1\n  frequency = Hash.new(0)\n  lst.each do |number|\n\
    \    frequency[number] += 1\n  end\n  frequency.each do |k, v|\n    if v >= k\
    \ && k > max\n      max = k\n    end\n  end\n  max\nend", "  count = 0\n  lst.each\
    \ do |l|\n    count += 1 if lst.count(l) >= l\n  end\n  count.zero? ? -1 : count\n\
    end", "  counts = lst.each_with_object(Hash.new(0)) { |num, count| count[num]\
    \ += 1 }\n  maximum = counts.max_by { |key, value| key if value >= key }\n  maximum[0]\
    \ > 0 ? maximum[0] : -1\nend", "  return -1 if lst.empty?\n  max = lst.max\n \
    \ counts = Hash.new(0)\n  lst.each { |i| counts[i] += 1 }\n  (max).downto(1) do\
    \ |n|\n    return n if counts[n] >= n\n  end\n  -1\nend", "\tcount = Hash.new(0)\n\
    \tlst.each { |x| count[x] += 1 }\n\tcount.each do |k, v|\n\t\treturn k if k <=\
    \ v\n\tend\n\t-1\nend", "  freq = lst.each_with_object(Hash.new(0)) { |v, h| h[v]\
    \ += 1 }\n  freq.select { |k, v| k <= v }.sort.last&.first || -1\nend\np search([4,\
    \ 1, 2, 2, 3, 1]) #== 2\np search([1, 2, 2, 3, 3, 3, 4, 4, 4]) #== 3\np search([5,\
    \ 5, 4, 4, 4]) #== -1", "  frequencies = lst.each_with_object(Hash.new(0)) { |num,\
    \ hash| hash[num] += 1 }\n  frequencies.map { |freq, num| freq >= num ? num :\
    \ nil }.compact.max\nend", "\th = {}\n\th_freq = {}\n\tlst.each do |x|\n\t\tif\
    \ !h[x]\n\t\t\th[x] = 0\n\t\tend\n\t\th[x] += 1\n\tend\n\th.each do |key, value|\n\
    \t\tif value >= key\n\t\t\th_freq[key] = value\n\t\tend\n\tend\n\th_freq.keys.max\n\
    end", "  lst.uniq.sort.each do |i|\n    return i if lst.count(i) >= i\n  end\n\
    \  -1\nend", "  return -1 if lst.empty?\n  frequencies = lst.inject(Hash.new(0))\
    \ { |total, e| total[e] += 1 ;total}\n  frequencies.each { |x, y| return x if\
    \ x <= y }\n  -1\nend", "  lst.uniq.sort.each { |x| return x if lst.count(x) >=\
    \ x }\n  -1\nend", "  largest = lst.uniq.sort[-1]\n  largest_freq = lst.count(largest)\n\
    \  if largest_freq >= largest\n    largest\n  else\n    -1\n  end\nend", "   \
    \ # the value we're looking for\n    val = 0\n    # the frequency of the value\
    \ we're looking for\n    frequency = 0\n    # create a hash to count the frequency\
    \ of each integer\n    hash = Hash.new(0)\n    lst.each do |i|\n        hash[i]\
    \ += 1\n    end\n    # iterate over each integer\n    hash.each do |k, v|\n  \
    \      # if the frequency is >= the key and the key is > the value we're looking\
    \ for\n        if v >= k && k > val\n            # update the value we're looking\
    \ for and its frequency\n            val = k\n            frequency = v\n    \
    \    end\n    end\n    # if the value we're looking for is > 0, return the value\n\
    \    if val > 0\n        return val\n    # else return -1\n    else\n        return\
    \ -1\n    end\nend", "  return -1 if lst.none?\n  lst.sort!\n  count = 0\n  i\
    \ = 0\n  while i < lst.length\n    current = lst[i]\n    while lst[i] == current\n\
    \      count += 1\n      i += 1\n    end\n    return current if count >= current\n\
    \    count = 0\n  end\n  -1\nend", "  max = lst.max\n  idx = lst.length - 1\n\
    \  (1..max).each do |i|\n    if lst.count(i) >= i\n      return i\n    elsif lst.count(i)\
    \ < i\n      max = max - 1\n    end\n  end\n  return -1\nend", "  frequencies\
    \ = Hash.new(0)\n  lst.each { |num| frequencies[num] += 1 }\n  frequencies.each\
    \ do |num, freq|\n    return num if num <= freq\n  end\n  -1\nend", "  n = lst.max\n\
    \  (1..n).each do |i|\n    return i if lst.count(i) >= i\n  end\n  -1\nend", " \
    \   hash = {}\n    lst.each do |i|\n        if hash[i] == nil\n            hash[i]\
    \ = 1\n        else\n            hash[i] += 1\n        end\n    end\n    hash.each\
    \ do |key, value|\n        if value >= key && key > 0\n            return key\n\
    \        end\n    end\n    return -1\nend", "  (1..lst.size).each do |i|\n   \
    \ if lst.count(i) >= i\n      return i\n    end\n  end\n  -1\nend", "  freq =\
    \ Hash.new(0)\n  freq = lst.inject(Hash.new(0)) { |h,v| h[v] += 1; h }\n  (1..lst.max).reverse_each\
    \ { |n| return n if freq[n] >= n }\n  -1\nend", "  counted = Hash.new(0)\n  lst.each\
    \ do |i|\n    counted[i] += 1\n  end\n  counted.each do |k, v|\n    return k if\
    \ k <= v\n  end\n  -1\nend", "  frequency = lst.reduce(Hash.new(0)) { |freq, i|\
    \ freq[i] += 1; freq }\n  frequency.select { |num, count| count >= num }.keys.max\n\
    end", "  mapper = lst.each_with_object(Hash.new(0)) { |value, count| count[value]\
    \ += 1 }\n  mapper.each { |k, v| return k if k <= v }\n  -1\nend", "    lst.sort.each_with_index{|n,i|\
    \ return n if lst.count(n) >= n && lst.count(n) > lst.count(lst[i+1])}\n    -1\n\
    end", "\tlst.group_by{|i| i}.max_by{|k,v| v.size}.first rescue -1\nend", "  cnt\
    \ = lst.inject(Hash.new(0)) { |h,v| h[v] += 1; h }\n  cnt.select { |k,v| v >=\
    \ k }.map(&:first).max || -1\nend", "  vals = lst.group_by(&:itself).select {\
    \ |k, v| k <= v.size }.values\n  vals.empty? ? -1 : vals.sort.last.first\nend",
  "  # your code here\nend", "    lst.reject{|v| v > lst.count(v)}.sort.last\nend\n\
    puts search([4, 1, 2, 2, 3, 1]) # == 2\nputs search([1, 2, 2, 3, 3, 3, 4, 4, 4])\
    \ # == 3\nputs search([5, 5, 4, 4, 4]) # == -1\nputs search([1, 1, 1, 1, 2, 2,\
    \ 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,", "  lst.uniq.sort.reverse.find\
    \ { |e| lst.count(e) >= e } || -1\nend", "  freq = Hash.new\n  lst.each do |x|\n\
    \    freq[x] = lst.count(x)\n  end\n  answer = -1\n  freq.each do |key, value|\n\
    \    if key <= value && key > answer\n      answer = key\n    end\n  end\n  answer\n\
    end", "    max_f = 0\n    max_i = 0\n    hash = {}\n    lst.each do |i|\n    \
    \    hash[i] = lst.count(i)\n    end\n    hash.each do |key, value|\n        if\
    \ key >= value && key > max_i\n            max_i = key\n        end\n    end\n\
    \    max_i > 0 ? max_i : -1\nend", "  lst.each do |x|\n    return x if lst.count(x)\
    \ >= x\n  end\n  -1\nend", "    hash = {}\n    max = 0\n    lst.each do |element|\n\
    \        if hash[element] == nil\n            hash[element] = 1\n        else\n\
    \            hash[element] += 1\n        end\n        if element > max\n     \
    \       max = element\n        end\n    end\n    if hash[max] >= max\n       \
    \ return max\n    else\n        return -1\n    end\nend", "\tresult = 0\n\tfor\
    \ i in lst\n\t\tif lst.count(i) >= i && i > result\n\t\t\tresult = i\n\t\tend\n\
    \tend\n\tif result == 0\n\t\treturn -1\n\telse\n\t\treturn result\n\tend\nend\n\
    puts search([4, 1, 2, 2, 3, 1])\nputs search([1, 2, 2, 3, 3, 3, 4, 4, 4])\nputs\
    \ search([5, 5, 4, 4, 4])", "  lst.each_with_object(Hash.new(0)) { |i, h| h[i]\
    \ += 1 }.sort.each do |i, count|\n    return i if i <= count\n  end\n  -1\nend",
  "  m = {}\n  lst.each { |n| m[n] = lst.count(n) }\n  x = m.select { |k, v| k ==\
    \ v }\n  x.empty? ? -1 : x.keys.max\nend", "  numbers = Hash.new(0)\n  lst.each\
    \ do |x|\n    numbers[x] += 1\n  end\n  numbers.each do |k, v|\n    if k == v\
    \ && k > 0\n      return k\n    end\n  end\n  return -1\nend", "  lst.sort!.uniq.each\
    \ do |num|\n    return num if lst.count(num) >= num\n  end\n  -1\nend", "  lst.each\
    \ do |x|\n    if lst.count(x) >= x\n      return x\n    end\n  end\n  return -1\n\
    end", "  frequency = Hash.new(0)\n  lst.each { |i| frequency[i] += 1 }\n  frequency.key(frequency.values.max)\
    \ >= frequency.values.max ? frequency.key(frequency.values.max) : -1\nend", " \
    \ lst.each { |x| return x if lst.count(x) >= x }\n  -1\nend", "  lst.select{|x|\
    \ lst.count(x) >= x}.max || -1\nend", "\tlst.sort!\n\tlast, count = nil, 0\n\t\
    lst.each do |x|\n\t\tlast, count = x, lst.count(x) if last != x\n\t\treturn x\
    \ if x == count\n\tend\n\t-1\nend", "  #Good Luck!\n  lst.max < lst.count(lst.max)\
    \ ? lst.max : -1\nend", "    frequency = {}\n    lst.each { |num| frequency[num]\
    \ = lst.count(num) }\n    greatest = frequency.key(frequency.values.max)\n   \
    \ frequency.values.max >= greatest ? greatest : -1\nend", "  n = lst.max\n  n\
    \ > lst.count(n) ? -1 : n\nend", "  if lst.length == 0\n    return -1\n  end\n\
    \  lst_hash = Hash.new(0)\n  lst.each do |num|\n    lst_hash[num] += 1\n  end\n\
    \  lst_hash.max_by { |k, v| v }.first\nend", "  lst.sort.uniq.select { |i| lst.count(i)\
    \ >= i }.max || -1\nend", "    val = lst.uniq.sort\n    val.each do |n|\n    \
    \    if lst.count(n) >= n\n            return n\n        end\n    end\n    return\
    \ -1\nend", "  max_num = 0\n  lst.each do |num|\n    max_num = num if lst.count(num)\
    \ >= num && num > max_num\n  end\n  max_num == 0 ? -1 : max_num\nend", "    num_hash\
    \ = {}\n    lst.each {|num| num_hash[num] ? num_hash[num] += 1 : num_hash[num]\
    \ = 1}\n    lst.sort!.reverse!\n    lst.each do |num|\n        return num if num_hash[num]\
    \ >= num\n    end\n    return -1\nend", "  counter = Hash.new {|h,k| h[k] = 0}\n\
    \  lst.each do |x|\n    counter[x] += 1\n  end\n  output = []\n  counter.keys.each\
    \ do |x|\n    if x <= counter[x]\n      output << x\n    end\n  end\n  output.sort.last\
    \ || -1\nend", "  lst.uniq.sort.reverse.find { |i| lst.count(i) >= i } || -1\n\
    end", "  freq = lst.inject(Hash.new(0)) { |h,v| h[v] += 1; h }\n  lst.max { |a,b|\
    \ freq[a] == freq[b] ? b <=> a : freq[a] <=> freq[b] }\nend", "  freq = {}\n \
    \ lst.each do |num|\n    freq[num] = lst.count(num)\n  end\n  freq.each do |k,\
    \ v|\n    return k if k == v && k > 0\n  end\n  -1\nend\np search([4, 1, 2, 2,\
    \ 3, 1]) #== 2\np search([1, 2, 2, 3, 3, 3, 4, 4, 4]) #== 3\np search([5, 5, 4,\
    \ 4, 4]) #== -1", "  n = 0\n  h = Hash.new(0)\n  lst.each { |v| h[v] += 1 }\n\
    \  h.each do |v,f|\n    if (f >= v && f > n)\n      n = v\n    end\n  end\n  n\
    \ == 0 ? -1 : n\nend", "  num = lst.max\n  counts = {}\n  lst.each do |x|\n  \
    \  counts[x] = 0 if counts[x].nil?\n    counts[x] += 1\n  end\n  counts.each do\
    \ |x, c|\n    return x if x == c && x > 0\n  end\n  -1\nend", "  return -1 if\
    \ lst.count(lst.max) < lst.max\n  lst.max\nend", "  counts = lst.inject(Hash.new(0))\
    \ { |h, v| h[v] += 1; h }\n  greatest = -1\n  counts.each do |k, v|\n    if k\
    \ <= v && k > greatest\n      greatest = k\n    end\n  end\n  greatest\nend",
  "    max = 0\n    for i in 0..lst.length-1\n        # count the occurrence of each\
    \ number in the array\n        if lst.count(lst[i]) >= lst[i]\n            # check\
    \ if the number is greater than zero and greater than the max number\n       \
    \     if lst[i] > 0 && lst[i] > max\n                max = lst[i]\n          \
    \  end\n        end\n    end\n    # if all the numbers are zero, return -1\n \
    \   if max == 0\n        return -1\n    else\n        return max\n    end\nend",
  "  # your code here\nend", "\t# create a hash of the frequencies of each number\n\
    \tfreq = Hash.new(0)\n\tlst.each do |num|\n\t\tfreq[num] += 1\n\tend\n\t# sort\
    \ the hash by key value\n\tfreq = freq.sort_by {|k,v| k}\n\tfreq.each do |key,\
    \ value|\n\t\t# if the key value is <= to the frequency of the key\n\t\tif key\
    \ <= value\n\t\t\t# return the key\n\t\t\treturn key\n\t\tend\n\tend\n\t# if no\
    \ key is found that satisfies the above condition\n\treturn -1\nend", "  lst.uniq.sort.each\
    \ do |x|\n    return x if lst.count(x) >= x\n  end\n  -1\nend", "  # your code\
    \ here\n  max = lst.max\n  return -1 if max == 1\n  (max - 1).downto(1) do |i|\n\
    \    return i if lst.count(i) >= i\n  end\nend", "  dict = lst.each_with_object(Hash.new(0))\
    \ { |item, counts| counts[item] += 1 }\n  dict.select { |k, v| k <= v }.max[0]\
    \ if dict.any?\nend", "  lst.each do |val|\n    return val if lst.count(val) >=\
    \ val\n  end\n  -1\nend", "  lst.uniq.each do |el|\n    if lst.count(el) >= el\n\
    \      return el\n    end\n  end\n  -1\nend", "  hash = Hash.new(0)\n  lst.each\
    \ do |num|\n    hash[num] += 1\n  end\n  hash.each do |k, v|\n    return k if\
    \ k <= v\n  end\n  -1\nend", "  return -1 if lst.empty?\n  return -1 if lst.all?\
    \ { |v| v < 1 }\n  lst.max { |a, b| lst.count(a) <=> lst.count(b) }\nend", " \
    \ if lst.empty?\n    return -1\n  else\n    if lst.count >= lst.uniq.last\n  \
    \    return lst.uniq.last\n    else\n      return -1\n    end\n  end\nend", " \
    \ max = lst.max\n  count = 0\n  lst.uniq.each do |element|\n    if element > 0\
    \ && element <= max\n      count = lst.count(element)\n      return element if\
    \ element <= count\n    end\n  end\n  -1\nend", "  # your code here\n  lst_hash\
    \ = Hash.new(0)\n  lst.each do |n|\n    lst_hash[n] += 1\n  end\n  lst_hash.each\
    \ do |k, v|\n    if v >= k\n      return k\n    end\n  end\n  return -1\nend",
  "    return -1 if lst.uniq.size == lst.size\n    freq = 0\n    value = 0\n    lst.uniq.each\
    \ do |n|\n        if lst.count(n) >= n\n            if lst.count(n) > freq\n \
    \               freq = lst.count(n)\n                value = n\n            end\n\
    \        end\n    end\n    return value\nend\np search([4, 1, 2, 2, 3, 1])\np\
    \ search([1, 2, 2, 3, 3, 3, 4, 4, 4])\np search([5, 5, 4, 4, 4])", "    frequencies\
    \ = Hash.new(0)\n    # frequencies = {}\n    lst.each { |x| frequencies[x] +=\
    \ 1 }", "  h = Hash.new(0)\n  lst.each { |e| h[e] += 1 }\n  h.max_by { |k, v|\
    \ k < v ? -1 : 1 }.first\nend", "  lst.map{|i| lst.count(i)}.max >= lst.max ?\
    \ lst.max : -1\nend", "  max_freq = 0\n  max_num = 0\n  freq = Hash.new { 0 }\n\
    \  lst.each do |num|\n    freq[num] += 1\n    if freq[num] > max_freq && freq[num]\
    \ >= num\n      max_freq = freq[num]\n      max_num = num\n    end\n  end\n  max_num\
    \ == 0 ? -1 : max_num\nend", "    # your code here\n    lst.uniq.sort.each { |n|\
    \ return n if lst.count(n) >= n }\n    -1\nend", "  return -1 if lst.length ==\
    \ 0\n  new_lst = {}\n  lst.each do |num|\n    if new_lst[num]\n      new_lst[num]\
    \ += 1\n    else\n      new_lst[num] = 1\n    end\n  end\n  new_lst.each do |k,\
    \ v|\n    return k if k == v\n  end\n  -1\nend", "  dict = Hash.new(0)\n  lst.each\
    \ { |item| dict[item] += 1 }\n  dict.sort.reverse.each do |num, freq|\n    return\
    \ num if num <= freq\n  end\n  -1\nend", "  lst.max == lst.count(lst.max) ? lst.max\
    \ : -1\nend", "    counts = Hash.new(0)\n    lst.each { |num| counts[num] += 1\
    \ }\n    counts.sort_by { |num, count| count }.reverse.each do |num, count|\n\
    \        return num if count >= num\n    end\n    -1\nend", "  count_of_numbers\
    \ = {}\n  lst.each do |num|\n    count_of_numbers[num] = lst.count(num)\n  end\n\
    \  count_of_numbers.each do |key, value|\n    if value >= key\n      return key\n\
    \    end\n  end\n  return -1\nend", "  lst.uniq.sort.each do |x|\n    return x\
    \ if lst.count(x) >= x\n  end\n  -1\nend", "  lst.uniq.max { |a, b| lst.count(a)\
    \ <=> lst.count(b) }\nend", "\tfreq = Hash.new(0)\n\tfor i in lst\n\t\tfreq[i]\
    \ += 1\n\tend\n\treturn -1 if freq.none? {|k,v| k <= v}\n\tfreq.max_by {|k,v|\
    \ k <= v ? k : 0}[0]\nend", "\tmax = 0\n\tmax_count = 0\n\th = Hash.new(0)\n\t\
    lst.each do |v|\n\t\tif h[v] >= v && h[v] > max_count\n\t\t\tmax = v\n\t\t\tmax_count\
    \ = h[v]\n\t\tend\n\t\th[v] += 1\n\tend\n\tmax == 0 ? -1 : max\nend", "  lst.group_by(&:itself).map\
    \ { |_, v| v.size }.sort.reverse.index(lst.max) ? lst.max : -1\nend", "  count\
    \ = Hash.new(0)\n  lst.each { |i| count[i] += 1 }\n  max_num = lst.max\n  (1..max_num).reverse_each\
    \ do |i|\n    return i if count[i] >= i\n  end\n  -1\nend", "    counts = lst.each_with_object(Hash.new(0))\
    \ { |num,hash| hash[num] += 1 }\n    counts.each do |num, freq|\n        return\
    \ num if num <= freq\n    end\n    -1\nend", "    set = {}\n    lst.each { |v|\
    \ set[v] = 0 }\n    lst.each { |v| set[v] += 1 }\n    set.each { |k, v| return\
    \ k if k <= v }\n    -1\nend", "  unique_numbers = lst.uniq.sort\n  result = unique_numbers.each_with_object([])\
    \ do |num, obj|\n    obj << num if lst.count(num) >= num\n  end\n  result.last\
    \ || -1\nend", "  #count frequency of each number\n  counts = lst.uniq.each_with_object({})\
    \ do |num,hash|\n    hash[num] = lst.count(num)\n  end\n  #select numbers greater\
    \ than value of frequency \n  h = counts.select{|k,v| k <= v}\n  #return the key\
    \ of the selected hash\n  h.keys.max\nend", "  hsh = Hash.new(0)\n  lst.each do\
    \ |x|\n    hsh[x] += 1\n  end\n  sorted = hsh.sort_by{|k,v| v}.reverse.to_h\n\
    \  sorted.each do |k,v|\n    if k >= v\n      return k\n    end\n  end\n  return\
    \ -1\nend", "  h = Hash.new(0)\n  lst.each { |num| h[num] += 1 }\n  solution =\
    \ h.sort.reverse\n  solution.each do |k, v|\n    return k if k <= v\n  end\n \
    \ -1\nend", "  lst.each_with_object(Hash.new(0)) { |e, h| h[e] += 1 }.sort.reverse.each\
    \ do |e|\n    return e[0] if e[0] <= e[1]\n  end\n  -1\nend", "  lst.group_by(&:itself).values.select\
    \ { |arr| arr.size >= arr[0] }.max.first\nend", "  h = {}\n  lst.each do |x|\n\
    \    h[x] = lst.count(x)\n  end\n  result = h.select { |k, v| v >= k }\n  result.empty?\
    \ ? -1 : result.keys.max\nend", "\t# create a hash that counts each number in\
    \ the array\n\tlst.each_with_object(Hash.new(0)) { |item, counts| counts[item]\
    \ += 1 }.each do |k, v|\n\t\t# if the number is less than or equal to the number\
    \ of times it appears,\n\t\t# return that number\n\t\treturn k if k <= v\n\tend\n\
    \t# else return -1\n\t-1\nend", "\tmax_freq = 1\n\tmax_num = 1\n\tlst.each do\
    \ |i|\n\t\tif lst.count(i) >= i && i > max_num\n\t\t\tmax_num = i\n\t\t\tmax_freq\
    \ = lst.count(i)\n\t\tend\n\tend\n\tif max_freq >= max_num\n\t\treturn max_num\n\
    \telse\n\t\treturn -1\n\tend\nend", "  # filter only unique values\n  unique_values\
    \ = lst.uniq\n  # sort array descending\n  sorted_values = unique_values.sort.reverse\n\
    \  # check if value is greater than zero \n  if sorted_values[0] > 0\n    # and\
    \ if value greater than or equal to its frequency\n    if sorted_values[0] <=\
    \ lst.count(sorted_values[0])\n      return sorted_values[0]\n    else\n     \
    \ return -1\n    end\n  else\n    return -1\n  end\nend", "  lst.each_with_object(Hash.new(0))\
    \ { |k, v| v[k] += 1 }.sort_by { |k, v| v }.reverse.each do |k, v|\n    return\
    \ k if k <= v\n  end\n  -1\nend", "  counts = lst.group_by { |x| x }.map { |k,\
    \ v| [k, v.size] }.to_h\n  counts.each do |k, v|\n    return k if k == v\n  end\n\
    \  -1\nend", "  return -1 if lst.size < 2\n  hash = lst.reduce(Hash.new(0)) {\
    \ |h, n| h[n] += 1; h }\n  hash.select { |k, v| k <= v }.max[0]\nend\np search([5,\
    \ 5, 4, 4, 4]) == -1", "  # return -1 if lst.empty?\n  # max = lst.max\n  # max\
    \ if lst.count(max) >= max\n  # -1\n  lst.group_by(&:itself).values.max_by(&:size).try(:first)\
    \ || -1\nend", "  return -1 if lst.empty?\n  lst.max{|x,y| lst.count(x) <=> lst.count(y)}\n\
    end", "  lst.sort!.uniq!\n  min = lst.min\n  return -1 if min > lst.length\n \
    \ (min..lst.length).each do |i|\n    return i if lst.count(i) >= i\n  end\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
