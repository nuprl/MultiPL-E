name: HumanEval_43_pairs_sum_to_zero
language: rb
prompt: "# pairs_sum_to_zero takes a list of integers as an input.\n# it returns True\
  \ if there are two distinct elements in the list that\n# sum to zero, and False\
  \ otherwise.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2,\
  \ 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\ndef pairs_sum_to_zero(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_pairs_sum_to_zero\n\
  \    candidate = method(:pairs_sum_to_zero)\n    assert_equal(false, candidate.call([1,\
  \ 3, 5, 0]))\n    assert_equal(false, candidate.call([1, 3, -2, 1]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 7]))\n    assert_equal(true, candidate.call([2, 4, -5,\
  \ 3, 5, 7]))\n    assert_equal(false, candidate.call([1]))\n    assert_equal(true,\
  \ candidate.call([-3, 9, -1, 3, 2, 30]))\n    assert_equal(true, candidate.call([-3,\
  \ 9, -1, 3, 2, 31]))\n    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 30]))\n\
  \    assert_equal(false, candidate.call([-3, 9, -1, 4, 2, 31]))\n  end\nend\n"
completions: ["  #your code here\n  for i in (0..l.length - 1)\n  \tfor j in (i+1..l.length\
    \ - 1)\n  \t\tif l[i] + l[j] == 0\n  \t\t\treturn true\n  \t\tend\n  \tend\n \
    \ end\n  return false\nend", "  if l.length > 1\n    if l.length == 2\n      if\
    \ l[0] + l[1] == 0\n        return True\n      else\n        return False\n  \
    \    end\n    else\n      if l[0] + l[1] == 0\n        return True\n      else\n\
    \        return pairs_sum_to_zero(l[1..l.length])\n      end\n    end\n  else\n\
    \    return False\n  end\nend", "  if l.length < 2\n    return False\n  end\n\
    \  hash = {}\n  l.each do |e|\n    if hash[-e]\n      return True\n    end\n \
    \   hash[e] = 1\n  end\n  return False\nend", "    if l.length == 1\n        return\
    \ False\n    end\n    for i in 0..l.length - 1\n        for j in 0..l.length -\
    \ 1\n            if i != j and l[i] + l[j] == 0\n                return True\n\
    \            end\n        end\n    end\n    return False\nend", "  i = 0\n  while\
    \ i < l.length\n    j = i + 1\n    while j < l.length\n      if l[i] + l[j] ==\
    \ 0\n        return True\n      end\n      j += 1\n    end\n    i += 1\n  end\n\
    \  return False\nend", "\tfor i in 0..l.length-1\n\t\tfor j in 0..l.length-1\n\
    \t\t\tif (l[i] + l[j] == 0)\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "    for i in 0...l.length\n        for j in i+1...l.length\n\
    \            if l[i] + l[j] == 0\n                return True\n            end\n\
    \        end\n    end\n    return False\nend", "  for i in 0..l.length - 1\n \
    \   for j in i + 1..l.length - 1\n      if l[i] + l[j] == 0\n        return True\n\
    \      end\n    end\n  end\n  return False\nend", "  if l.length < 2\n    return\
    \ False\n  end\n  result = false\n  h = Hash.new()\n  l.each do |num|\n    if\
    \ !h.has_key?(num)\n      h[num] = 0\n    end\n    h[num] += 1\n  end\n  l.each\
    \ do |num|\n    if h.has_key?(-num)\n      if num != 0 or h[num] > 1\n       \
    \ result = true\n      end\n    end\n  end\n  return result\nend", "  return False\
    \ if l.length < 2\n  for i in 0..l.length - 1\n    for j in 0..l.length - 1\n\
    \      if i != j && l[i] + l[j] == 0\n        return True\n      end\n    end\n\
    \  end\n  return False\nend", "\tfor i in 0..l.length-1\n\t\tfor j in i+1..l.length-1\n\
    \t\t\tif l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "    for i in l do\n        for j in l do\n            if\
    \ i != j && i + j == 0\n                return true\n            end\n       \
    \ end\n    end\n    return false\nend", "    for a in l:\n        for b in l:\n\
    \            if a != b and a + b == 0:\n                return True\n    return\
    \ False", "\tfor x in 0...l.length\n\t\tfor y in x+1...l.length\n\t\t\tif l[x]\
    \ + l[y] == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\n\
    end", "    if l.length <= 1\n        return False\n    else\n        for i in\
    \ l\n            for j in l\n                if i + j == 0 and l.index(i) != l.index(j)\n\
    \                    return True\n                end\n            end\n     \
    \   end\n    end\n    return False\nend", "  for i in 0..l.length-1\n    for j\
    \ in i+1..l.length-1\n      if l[i] + l[j] == 0\n        return True\n      end\n\
    \    end\n  end\n  return False\nend", "  for i in (0...l.length)\n    for j in\
    \ (i+1...l.length)\n      if l[i] + l[j] == 0\n        return True\n      end\n\
    \    end\n  end\n  return False\nend", "  l.each_with_index do |value, index|\n\
    \    l.each_with_index do |value2, index2|\n      if index2 > index && value +\
    \ value2 == 0\n        return true\n      end\n    end\n  end\n  return false\n\
    end", "  if l.length >= 2\n    for i in (0...l.length)\n      for j in (i+1...l.length)\n\
    \        if l[i] + l[j] == 0\n          return True\n        end\n      end\n\
    \    end\n  end\n  return False\nend", "  if l.length <= 1\n    return False\n\
    \  end\n  l.each do |num1|\n    l.each do |num2|\n      if num1 != num2 and num1\
    \ + num2 == 0\n        return True\n      end\n    end\n  end\n  return False\n\
    end", "  return False if l.length < 2\n  i = 0\n  while i < l.length\n    j =\
    \ i + 1\n    while j < l.length\n      return True if l[i] + l[j] == 0\n     \
    \ j += 1\n    end\n    i += 1\n  end\n  return False\nend", "    d = {}\n    for\
    \ i in l\n        if l.include? -i\n            return True\n        end\n   \
    \ end\n    return False\nend", "  l.each_with_index do |x, i|\n    l.each_with_index\
    \ do |y, j|\n      if i != j && x + y == 0\n        return true\n      end\n \
    \   end\n  end\n  return false\nend", "\ti = 0\n\twhile i < l.length\n\t\tj =\
    \ i + 1\n\t\twhile j < l.length\n\t\t\tif l[i] + l[j] == 0\n\t\t\t\treturn true\n\
    \t\t\tend\n\t\t\tj += 1\n\t\tend\n\t\ti += 1\n\tend\n\treturn false\nend", " \
    \   i = 0\n    found = false\n    for i in 0..l.length - 1\n        for j in i+1..l.length\
    \ - 1\n            if l[i] + l[j] == 0\n                found = true\n       \
    \     end\n        end\n    end\n    found\nend", "  i = 0\n  while i < l.length\n\
    \    j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ True\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return False\n\
    end", "  for i in 0..l.length-1\n    for j in 0..l.length-1\n      if i != j\n\
    \        if l[i] + l[j] == 0\n          return True\n        end\n      end\n\
    \    end\n  end\n  return False\nend", "  if l.length > 1\n    for i in 0..l.length-1\n\
    \      for j in i+1..l.length-1\n        if l[i] + l[j] == 0\n          return\
    \ True\n        end\n      end\n    end\n  end\n  return False\nend", "    i =\
    \ 0\n    while i < l.length do\n        j = i + 1\n        while j < l.length\
    \ do\n            if l[i] + l[j] == 0\n                return True\n         \
    \   end\n            j += 1\n        end\n        i += 1\n    end\n    return\
    \ False\nend", "  if l.length == 1\n    return false\n  end\n  for i in 0..l.length-1\n\
    \    for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "    for i in (0...l.length-1)\n\
    \        for j in (i+1...l.length)\n            if l[i] + l[j] == 0\n        \
    \        return True\n            end\n        end\n    end\n    return False\n\
    end", "\tif l.length < 2\n\t\treturn false\n\tend\n\tl.each do |x|\n\t\tl.each\
    \ do |y|\n\t\t\tif x + y == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\
    \treturn false\nend", "  return False if l.size < 2\n  already_seen = []\n  l.each\
    \ do |i|\n    x = 0 - i\n    if already_seen.include?(x)\n      return True\n\
    \    else\n      already_seen.push(i)\n    end\n  end\n  return False\nend", " \
    \ l.each_with_index do |x, i|\n    for y in (i+1...l.length)\n      if x + l[y]\
    \ == 0\n        return true\n      end\n    end\n  end\n  return false\nend",
  "  # complete the body of this function\n  # the current return statement is a placeholder\n\
    \  # it should be replaced with your own solution\n  return False\nend", "  #\
    \ create a hash map to track the number of times each element appears in the list.\n\
    \  # We'll use this to keep track of how many times a number appears in the list.\n\
    \  #\n  # We use num as a key and the number of times it appears as the value.\n\
    \  # We'll initialize each value in the hash to 0.\n  counts = Hash.new(0)\n \
    \ l.each do |num|\n    counts[num] += 1\n  end", "  if l.length < 2\n    return\
    \ False\n  end\n  for i in 0..l.length-1\n    for j in i+1..l.length-1\n     \
    \ if l[i] + l[j] == 0\n        return True\n      end\n    end\n  end\n  return\
    \ False\nend", "  a=[]\n  b=[]\n  l.each do |x|\n    if a.include?(-x)\n     \
    \ b.push(x)\n    else\n      a.push(x)\n    end\n  end\n  return b.size!=0\nend",
  "  l.each_with_index do |x, i|\n    return true if l.include?(-x) && l.index(x)\
    \ != i\n  end\n  false\nend", "  # YOUR CODE HERE\nend", "\nend", "  n = l.length\n\
    \  i = 0\n  while i < n\n    j = i + 1\n    while j < n\n      return True if\
    \ l[i] + l[j] == 0\n      j += 1\n    end\n    i += 1\n  end\n  return False\n\
    end", "\t\n\thash_table = {}\n\tl.each do |item|\n\t\tif hash_table[item] == nil\n\
    \t\t\thash_table[item] = 1\n\t\telse\n\t\t\thash_table[item] += 1\n\t\tend\n\t\
    end", "  if l.length == 1\n    return false\n  end\n  for i in 0...l.length\n\
    \    if l.include?(-l[i])\n      return true\n    end\n  end\n  return false\n\
    end", "  for x in l:\n    for y in l:\n      if x == y:\n        return False\n\
    \      elif x + y == 0:\n        return True\n      else:\n        return False",
  "  if l.empty?\n    return false\n  end\n  if l.length == 1\n    return false\n\
    \  end\n  if l.length == 2\n    if l[0] + l[1] == 0\n      return true\n    else\n\
    \      return false\n    end\n  end\n  i = 0\n  while i < l.length\n    j = i\
    \ + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return true\n\
    \      end\n      j += 1\n    end\n    i += 1\n  end\n  return false\nend", " \
    \ l.each_with_index do |x, i|\n    l.each_with_index do |y, j|\n      return true\
    \ if x + y == 0 && i != j\n    end\n  end\n  false\nend", "\tl.sort!\n\tleft =\
    \ 0\n\tright = l.length - 1\n\twhile left < right\n\t\tif l[left] + l[right] ==\
    \ 0\n\t\t\treturn true\n\t\telsif l[left] + l[right] < 0\n\t\t\tleft += 1\n\t\t\
    else\n\t\t\tright -= 1\n\t\tend\n\tend\n\treturn false\nend", "    #check to see\
    \ if there are two different instances of a number that adds to zero\n    #loop\
    \ over the array and compare the first to the rest\n    count = 0\n    l.each\
    \ do |num|\n        newNum = l.delete_at(count)\n        l.each do |secondNum|\n\
    \            if newNum + secondNum == 0\n                return true\n       \
    \     end\n        end\n        count += 1\n    end\n    return false\nend", " \
    \ # l.combination(2).any? { |a, b| a + b == 0 }\n  l.each_with_index do |x, i|\n\
    \    j = i + 1\n    while j < l.length\n      return true if x + l[j] == 0\n \
    \     j += 1\n    end\n  end\n  false\nend", "  l.each do |i|\n    l.each do |j|\n\
    \      if i + j == 0\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "    i = 0\n    while i < l.length\n        j = i + 1\n       \
    \ while j < l.length\n            if l[i] + l[j] == 0\n                return\
    \ True\n            end\n            j += 1\n        end\n        i += 1\n   \
    \ end\n    return False\nend", "    if l.length <= 1\n        return False\n \
    \   end\n    for i in 0...l.length\n        for j in (i+1)...l.length\n      \
    \      if l[i] + l[j] == 0\n                return True\n            end\n   \
    \     end\n    end\n    return False\nend", "  i = 0\n  while i < l.length\n \
    \   j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ True\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return False\n\
    end", "\tfor a in l:\n\t\tfor b in l:\n\t\t\tif (a + b == 0) and (a != b):\n\t\
    \t\t\treturn True\n\treturn False", "  # Your code here\nend", "    if l.length\
    \ <= 1\n        return False\n    else\n        l.each_with_index do |num, index|\n\
    \            if l.length <= index + 1\n                return False\n        \
    \    else\n                l[index + 1, l.length].each do |num2|\n           \
    \         if num + num2 == 0\n                        return True\n          \
    \          end\n                end\n            end\n        end\n    end\nend",
  "    i = 0\n    while i < l.length\n        j = i + 1\n        while j < l.length\n\
    \            if l[i] + l[j] == 0\n                return True\n            end\n\
    \            j += 1\n        end\n        i += 1\n    end\n    return False\n\
    end", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] +\
    \ l[j] == 0\n        return True\n      end\n    end\n  end\n  return False\n\
    end", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] +\
    \ l[j] == 0\n        return True\n      end\n    end\n  end\n  return False\n\
    end", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] +\
    \ l[j] == 0\n        return True\n      end\n    end\n  end\n  return False\n\
    end", "  # your code here\n  h = {}\n  pairs = []\n  l.each do |num|\n    if h[num]\n\
    \      pairs << [num, h[num]]\n    else\n      h[num] = -num\n    end\n  end\n\
    \  return true if pairs.size > 0\n  false\nend", "  answer = False\n  (l.length\
    \ - 1).times do |i|\n    (i + 1).upto(l.length - 1) do |j|\n      answer = (l[i]\
    \ + l[j] == 0)\n      return answer if answer\n    end\n  end\n  answer\nend",
  "  l.each do |n|\n    if l.include?(-n) && n != 0\n      return true\n    end\n\
    \  end\n  return false\nend", "  # write your code here\n  num_of_elements = l.length\n\
    \  if num_of_elements < 2\n    return false\n  end\n  l.each do |num|\n    if\
    \ l.include?(-num)\n      return true\n    end\n  end\n  return false\nend", "\t\
    #l.sort!\n\t#l.each do |i|\n\t#\tl.each do |j|\n\t#\t\tif j!=i and j+i==0\n\t\
    #\t\t\treturn True\n\t#\t\tend\n\t#\tend\n\t#end\n\t#return False\n\thash = {}\n\
    \tl.each do |x|\n\t\tif hash.has_key?(-x)\n\t\t\treturn True\n\t\telse\n\t\t\t\
    hash[x] = 1\n\t\tend\n\tend\n\treturn False\nend", "  (0...l.length-1).each do\
    \ |i|\n    (i+1...l.length).each do |j|\n      if l[i] + l[j] == 0\n        return\
    \ true\n      end\n    end\n  end\n  return false\nend", "  # initialize a hash\n\
    \  hash = {}\n  # iterate through the list\n  l.each do |i|\n    # check if there\
    \ is a number in the hash that is the negation of the current number\n    if hash[i\
    \ * -1]\n      # if so, return true\n      return true\n    else\n      # otherwise,\
    \ add the current number to the hash\n      hash[i] = i\n    end\n  end\n  # if\
    \ the loop is exited, return false\n  return false\nend", "  for num in l\n  \
    \  for num2 in l\n      if num + num2 == 0 && num != num2\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "\tl.combination(2).to_a.each\
    \ do |x|\n\t\tif x[0] + x[1] == 0\n\t\t\treturn true\n\t\tend\n\tend\n\treturn\
    \ false\nend", "  # put your code here\n  l.size.times do |i|\n    if l.include?\
    \ -l[i]\n      return true\n    end\n  end\n  return false\nend", "\nend", " \
    \ for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] + l[j] ==\
    \ 0\n        return True\n      end\n    end\n  end\n  return False\nend", " \
    \   # l.each do |i|\n    #     l.each do |j|\n    #         if i != j\n    # \
    \            if i + j == 0\n    #                 return True\n    #         \
    \    end\n    #         end\n    #     end\n    # end\n    # return False\n  \
    \  for i in range(0, len(l)):\n        for j in range(i+1, len(l)):\n        \
    \    if i != j:\n                if l[i] + l[j] == 0:\n                    return\
    \ True\n    return False", "  z = false\n  if l.length <=1\n    return z\n  end\n\
    \  i = 0\n  while i < l.length\n    j = i + 1\n    while j < l.length\n      if\
    \ l[i] + l[j] == 0\n        z = true\n      end\n      j = j + 1\n    end\n  \
    \  i = i + 1\n  end\n  return z\nend", "  l.each_with_index do |num1, i|\n   \
    \ l.each_with_index do |num2, j|\n      return true if num1 + num2 == 0 && i !=\
    \ j\n    end\n  end\n  false\nend", "  if l.length < 2\n    return False\n  end\n\
    \  l.each do |x|\n    if l.count(x*-1) > 0\n      return True\n    end\n  end\n\
    \  return False\nend", "    for i in 0..l.length - 1\n        for j in i + 1..l.length\
    \ - 1\n            if l[i] + l[j] == 0\n                return True\n        \
    \    end\n        end\n    end\n    return False\nend", "  for i in 0..l.length-1\n\
    \    for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n        return True\n\
    \      end\n    end\n  end\n  return False\nend", "  if l.length < 2\n    return\
    \ False\n  end\n  for i in 0..l.length - 1\n    for j in i+1..l.length - 1\n \
    \     if l[i] + l[j] == 0\n        return True\n      end\n    end\n  end\n  return\
    \ False\nend", "    i = 0\n    while i < l.length\n        j = i + 1\n       \
    \ while j < l.length\n            if l[i] + l[j] == 0\n                return\
    \ True\n            end\n            j += 1\n        end\n        i += 1\n   \
    \ end\n    return False\nend", "  i = 0\n  while i < l.length\n    j = i + 1\n\
    \    while j < l.length\n      if l[i] + l[j] == 0\n        return True\n    \
    \  end\n      j += 1\n    end\n    i += 1\n  end\n  return False\nend", "    for\
    \ i in 0..l.length - 1\n        for j in i+1..l.length - 1\n            if l[i]\
    \ + l[j] == 0\n                return True\n            end\n        end\n   \
    \ end\n    return False\nend", "  for i in l\n    for j in l\n      if i + j ==\
    \ 0\n        return True\n      end\n    end\n  end\n  return False\nend", " \
    \ if l.empty?\n    return False\n  end\n  for i in 0...l.length\n    for j in\
    \ i+1...l.length\n      if l[i] + l[j] == 0\n        return True\n      end\n\
    \    end\n  end\n  return False\nend", "  for i in l:\n    for j in l:\n     \
    \ if l.index(i) != l.index(j) and (i + j) == 0:\n        return True\n  return\
    \ False", "  # look at the list, if you find 2 numbers that sum to zero, return\
    \ True\n  # if you go through the whole list and don't find 2 numbers that sum\
    \ to zero, return False\n  for i in l\n    for j in l\n      if i + j == 0\n \
    \       return True\n      end\n    end\n  end\n  return False\nend", "  for i\
    \ in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n\
    \        return True\n      end\n    end\n  end\n  return False\nend", "  # your\
    \ code here\nend", "  # your code here\n  x = l.permutation(2).to_a\n  y = x.map{|a|\
    \ a.inject(:+)}\n  z = y.include?(0)\nend", "    return false if l.length <= 1\n\
    \    l.each_with_index do | num, idx |\n        next if idx == l.length - 1\n\
    \        # (idx + 1..l.length - 1).each do | idx2 |\n        #     if num + l[idx2]\
    \ == 0\n        #         return true\n        #     end\n        # end\n    \
    \    l.each_with_index do | num2, idx2 |\n            next if idx2 == idx\n  \
    \          if num + num2 == 0\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "    #define a function that takes\
    \ a list as an input\n    # go through list and see if any elements sums to zero,\
    \ then return true and end\n    #if there is none return false\n    #base case\
    \ \n    return false if l.length == 1\n    #take the first value in the list \n\
    \    #compare that value to all the other values in the list to see if any sums\
    \ to zero\n    #if it sums to zero return true and end, then pop it off the list\
    \ and repeat\n    #if it doesn't sum to zero, pop it off the list, then repeat\n\
    \    for i in 0...l.length do\n        for j in 0...l.length do\n            if\
    \ l[i] + l[j] == 0 and i != j\n                return true\n            end\n\
    \        end\n    end\n    return false\nend", "  for i in (0...l.length)\n  \
    \  for j in (i+1...l.length)\n      if (l[i] + l[j] == 0)\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  if l.length <= 1\n    return\
    \ False\n  end\n  for i in 0..l.length-1\n    for j in i+1..l.length-1\n     \
    \ if l[i] + l[j] == 0\n        return True\n      end\n    end\n  end\n  return\
    \ False\nend", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n     \
    \ if l[i] + l[j] == 0\n        return True\n      end\n    end\n  end\n  return\
    \ False\nend", "    # --- check if length of l is greater than 1\n    if l.length\
    \ > 1\n        # --- for i in l:\n        for i in l\n            # --- for j\
    \ in l:\n            for j in l\n                # --- check if i and j are equal:\n\
    \                if i == j\n                    # --- do nothing\n           \
    \     else\n                    # --- check if i + j == 0\n                  \
    \  if i + j == 0\n                        # --- return True\n                \
    \        return True\n                    else\n                        # ---\
    \ do nothing\n                    end\n                end\n            end\n\
    \        end\n    else\n        # --- return False\n        return False\n   \
    \ end\n    # --- return False\n    return False\nend", "  flag = false\n  l.each_with_index\
    \ do |a, i|\n    l.each_with_index do |b, j|\n      if (a + b == 0) && (i != j)\n\
    \        flag = true\n      end\n    end\n  end\n  return flag\nend", "    for\
    \ i in 0...l.length\n        for j in i+1...l.length\n            if l[i] + l[j]\
    \ == 0\n                return True\n            end\n        end\n    end\n \
    \   return False\nend", "  # if l.length == 1\n  #   return false\n  # end\n \
    \ # i = 0\n  # while i < l.length\n  #   j = 0\n  #   while j < l.length\n  #\
    \     if l[i] + l[j] == 0\n  #       return true\n  #     end\n  #     j += 1\n\
    \  #   end\n  #   i += 1\n  # end\n  # return false\n  hash = {}\n  l.each do\
    \ |int|\n    if hash[int]\n      return true\n    else\n      hash[int] = 1\n\
    \    end\n  end\n  return false\nend", "  if (l.length < 2)\n    return false\n\
    \  end\n  for i in 0..(l.length - 1)\n    for j in (i + 1)..(l.length - 1)\n \
    \     if (l[i] + l[j] == 0)\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  no_dups = l.uniq\n  for item in no_dups do\n    if no_dups.include?(-item)\n\
    \      return True\n    end\n  end\n  return False\nend", "  check = false\n \
    \ index1 = 0\n  index2 = 1\n  while index1 < l.length\n    while index2 < l.length\n\
    \      if l[index1] + l[index2] == 0\n        check = true\n      end\n      index2\
    \ += 1\n    end\n    index1 += 1\n    index2 = index1 + 1\n  end\n  check\nend",
  "    s = Set.new\n    l.each do |value|\n        if s.include?(-value)\n       \
    \     return True\n        end\n        s.add(value)\n    end\n    return False\n\
    end", "  if l.size < 2\n    return false\n  end\n  l.each do |a|\n    l.each do\
    \ |b|\n      if a != b && a + b == 0\n        return true\n      end\n    end\n\
    \  end\n  return false\nend", "  if l.length <= 1\n    return False\n  end\n \
    \ for i in l\n    for j in l\n      if i == j\n        next\n      end\n     \
    \ if i + j == 0\n        return True\n      end\n    end\n  end\n  return False\n\
    end", "  x = []\n  for i in 0..l.length-1\n    for j in i+1..l.length-1\n    \
    \  if l[i] + l[j] == 0\n        x << l[i]\n        x << l[j]\n      end\n    end\n\
    \  end\n  if x.empty?\n    return false\n  else\n    return true\n  end\nend",
  "    if l.length < 2\n        return False\n    else\n        l.each do |i|\n  \
    \          l.each do |j|\n                if i == j\n                    next\n\
    \                elsif i + j == 0\n                    return True\n         \
    \       end\n            end\n        end\n    end\n    return False\nend", "\t\
    #create a new list to hold the list elements that\n\t#sum to zero\n\tif l.length\
    \ == 1\n\t\treturn false\n\telse\n\t\tresult = []\n\t\tfor i in 0..l.length-1\n\
    \t\t\tfor j in i+1..l.length-1\n\t\t\t\tif l[i] + l[j] == 0\n\t\t\t\t\tresult\
    \ << l[i] << l[j]\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t#if the new list is not\
    \ empty then return true\n\t\tif result.empty?\n\t\t\treturn false\n\t\telse\n\
    \t\t\treturn true\n\t\tend\n\tend\nend", "  l = l.sort\n  i = 0\n  for i in (0..l.length-1)\n\
    \    for j in (i+1..l.length-1)\n      if (l[i] + l[j]) == 0\n        return True\n\
    \      end\n    end\n  end\n  return False\nend", "  pairs = l.combination(2).to_a\n\
    \  if pairs.length == 0\n    return False\n  else\n    for pair in pairs\n   \
    \   if pair[0] + pair[1] == 0\n        return True\n      end\n    end\n  end\n\
    \  return False\nend", "\tl.each_with_index do |num1,i|\n\t\tl.each_with_index\
    \ do |num2,j|\n\t\t\tif num1+num2 == 0 and i != j\n\t\t\t\treturn true\n\t\t\t\
    end\n\t\tend\n\tend\n\treturn false\nend", "    for i in (0...l.length-1)\n  \
    \      for j in (i+1...l.length)\n            if l[i] + l[j] == 0\n          \
    \      return True\n            end\n        end\n    end\n    return False\n\
    end", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] +\
    \ l[j] == 0\n        return True\n      end\n    end\n  end\n  return False\n\
    end", "    l.each do |i|\n        l.each do |j|\n            if (i + j == 0) &&\
    \ (i != j)\n                return true\n            end\n        end\n    end\n\
    \    return false\nend", "    l.each_with_index do |num, i|\n        l.each_with_index\
    \ do |num2, j|\n            if i != j && num + num2 == 0\n                return\
    \ true\n            end\n        end\n    end\n    return false\nend", "    return\
    \ False if l.length < 2 # Can't have a pair sum to zero if there's only one item!\n\
    \    for i in 0..l.length - 1\n        for j in i + 1..l.length - 1\n        \
    \    return True if l[i] + l[j] == 0\n        end\n    end\n    return False\n\
    end", "\tmax = l.length\n\tmax.times do |i|\n\t\tmax.times do |j|\n\t\t\tif i\
    \ != j && l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "    pairs = l.combination(2).to_a\n    pairs.each do |pair|\n\
    \        if pair[0] + pair[1] == 0\n            return True\n        end\n   \
    \ end\n    return False\nend", "    for i in (0...l.length)\n        for j in\
    \ (i+1...l.length)\n            if l[i] + l[j] == 0\n                return True\n\
    \            end\n        end\n    end\n    return False\nend", "  if l.length\
    \ <= 1\n    return False\n  end\n  h = Hash.new()\n  l.each do |i|\n    if h.has_key?(-i)\n\
    \      return True\n    end\n    h[i] = 1\n  end\n  return False\nend", "  if\
    \ l.empty? || l.length == 1\n    return false\n  end\n  for i in 0..l.length-1\n\
    \    for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "    for i in 0..l.length-1\n\
    \        j = i+1\n        while j < l.length\n            if l[i] + l[j] == 0\n\
    \                return True\n            end\n            j = j + 1\n       \
    \ end\n    end\n    return False\nend", "  for num in l\n    for i in l\n    \
    \  if num != i\n        if num + i == 0\n          return True\n        end\n\
    \      end\n    end\n  end\n  return False\nend", "    # check every possible\
    \ pair\n    for i in 0...l.length\n        for j in i+1...l.length\n         \
    \   if l[i] + l[j] == 0\n                return True\n            end\n      \
    \  end\n    end\n    return False\nend", "    n = l.length\n    for i in 0..n-1\n\
    \        for j in i+1..n-1\n            if l[i] + l[j] == 0\n                return\
    \ True\n            end\n        end\n    end\n    return False\nend", "  for\
    \ num in l\n    for num2 in l\n      if num + num2 == 0\n        return true\n\
    \      end\n    end\n  end\n  return false\nend", "  if l.length < 2\n    return\
    \ False\n  end\n  l.each do |x|\n    if l.count(x*-1) > 0\n      return True\n\
    \    end\n  end\n  return False\nend", "  return l.sort!\nend", "  l.permutation(2).to_a.uniq.each\
    \ do |e1, e2|\n    return true if e1 + e2 == 0\n  end\n  false\nend", "  if l.length\
    \ == 1\n    return false\n  end\n  for i in 0...l.length\n    for j in i+1...l.length\n\
    \      if l[i] + l[j] == 0\n        return true\n      end\n    end\n  end\n \
    \ return false\nend", "\ti = 0\n\twhile i < l.length - 1\n\t\treturn true if l.include?(-l[i])\
    \ && l[i] != -l[i]\n\t\ti += 1\n\tend\n\treturn false\nend", "    # check if 2\
    \ distinct elements exist in l\n    if l.uniq.length == 1\n        return False\n\
    \    end\n    # create array to store the indices of the elements in l\n    indices\
    \ = []\n    # determine if any pairs of distinct elements in l sum to zero\n \
    \   # iterate over the list l\n    l.each_with_index do |value, index|\n     \
    \   # check if the value is equal to the negative of another value in l\n    \
    \    # if so, add the indices of the values that sum to zero to indices\n    \
    \    if l.include?(-value)\n            indices.push(index)\n            indices.push(l.index(-value))\n\
    \        end\n    end\n    # check if indices has any pairs\n    # if so, return\
    \ True\n    # if not, return False\n    if indices.length > 0\n        return\
    \ True\n    else\n        return False\n    end\nend", "  i = 0\n  while i < l.length\n\
    \    j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ True\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return False\n\
    end", "    # if l.empty?\n    #     return False\n    # end\n    if l.length ==\
    \ 1\n        return False\n    end\n    if l.length == 2\n        if l[0] + l[1]\
    \ == 0\n            return True\n        else\n            return False\n    \
    \    end\n    end\n    for i in 0..l.length-1\n        for j in i+1..l.length-1\n\
    \            if l[i] + l[j] == 0\n                return True\n            end\n\
    \        end\n    end\n    return False\nend", "  if l.length < 2\n    return\
    \ False\n  end\n  for i in l\n    for j in l\n      if i+j == 0\n        return\
    \ True\n      end\n    end\n  end\n  return False\nend", "  found = false\n  l.length.times\
    \ do |i|\n    (i+1).upto(l.length-1) do |j|\n      if l[i] + l[j] == 0\n     \
    \   found = true\n      end\n    end\n  end\n  found\nend", "  if l.empty?\n \
    \   return False\n  end\n  idx1 = 0\n  while idx1 < l.length\n    idx2 = idx1\
    \ + 1\n    while idx2 < l.length\n      if l[idx1] + l[idx2] == 0\n        return\
    \ True\n      end\n      idx2 += 1\n    end\n    idx1 += 1\n  end\n  return False\n\
    end", "\tif l.length < 2\n\t\treturn false\n\tend\n\tif l.empty?\n\t\treturn false\n\
    \tend\n\tl.each do |i|\n\t\tl.each do |j|\n\t\t\tif i != j && i + j == 0\n\t\t\
    \t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend", "\tnewl = Array.new\n\
    \tl.each do |x|\n\t\tif newl.include?(x) == false\n\t\t\tnewl << x\n\t\tend\n\t\
    end\n\tnewl.each do |x|\n\t\tif newl.include?(-x) == true\n\t\t\treturn true\n\
    \t\tend\n\tend\n\treturn false\nend", "    if l.length == 1\n        return False\n\
    \    end\n    for i in 0...l.length\n        for j in i+1...l.length\n       \
    \     if l[i] + l[j] == 0\n                return True\n            end\n    \
    \    end\n    end\n    return False\nend", "  # insert code here\n  l.each_with_index\
    \ do |x, i|\n    l.each_with_index do |y, j|\n      if i != j && x + y == 0\n\
    \        return true\n      end\n    end\n  end\n  return false\nend", "  sum\
    \ = 0\n  for i in 0..l.length\n    for j in i+1..l.length\n      sum = l[i] +\
    \ l[j]\n      if sum == 0\n        return true\n      end\n    end\n  end\n  return\
    \ false\nend", "  # edge case:\n  if l.length < 2\n    return false\n  end\n \
    \ # if the length is two, check if it sums to zero\n  if l.length == 2\n    if\
    \ l[0] + l[1] == 0\n      return true\n    else\n      return false\n    end\n\
    \  end\n  # if the length is longer than two, check if the first two elements\
    \ sum to zero\n  if l.length > 2\n    if l[0] + l[1] == 0\n      return true\n\
    \    else\n      # if they don't, create an array to hold the used elements\n\
    \      used = [l[0], l[1]]\n      # iterate through the rest of the list and check\
    \ if they sum to zero with a used element\n      for i in 2..l.length - 1\n  \
    \      for j in 0..used.length - 1\n          if used[j] + l[i] == 0\n       \
    \     return true\n          end\n        end\n        # if no pairs exist, add\
    \ the element to the used list\n        used << l[i]\n      end\n      # if there\
    \ are no pairs in the list, return false\n      return false\n    end\n  end\n\
    end", "    seen = {}\n    for i in l\n        seen[i] = true\n    end\n    for\
    \ i in l\n        if seen[-i]\n            return true\n        end\n    end\n\
    \    return false\nend", "  for i in 0..l.length-1\n    for j in i+1..l.length-1\n\
    \      if l[i] + l[j] == 0\n        return True\n      end\n    end\n  end\n \
    \ return False\nend", "\tfor i in (0..l.length-1)\n\t\tfor j in (i+1..l.length-1)\n\
    \t\t\tif l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\t\
    return false\nend", "  i = 0\n  while i < l.length\n    j = i + 1\n    while j\
    \ < l.length\n      if l[i] + l[j] == 0\n        return True\n      end\n    \
    \  j += 1\n    end\n    i += 1\n  end\n  return False\nend", "  # You will need\
    \ to do something with the elements in the list here!\n  # It might be useful\
    \ to use another function here.\n  has_sum_of_zero(l)\nend", "    for i in 0..l.length-1\n\
    \        for j in i+1..l.length-1\n            if (l[i] + l[j] == 0)\n       \
    \         return True\n            end\n        end\n    end\n    return False\n\
    end", "    l.each do |i|\n        l.each do |j|\n            if i + j == 0\n \
    \               return true\n            end\n        end\n    end\n    return\
    \ false\nend", "    l.combination(2).any? { |a, b| a + b == 0 }\nend", "\nend",
  "    neg_l = l.map {|x| -x}\n    found = false\n    i = 0\n    while (i < l.length)\
    \ do\n        j = 0\n        while (j < neg_l.length) do\n            if (l[i]\
    \ == neg_l[j])\n                found = true\n            end\n            j +=\
    \ 1\n        end\n        i += 1\n    end\n    return found\nend", "\nend", " \
    \ # Reminder: you must check every pair of items in the list,\n  # and you can\
    \ assume that l is non-empty", "  length = l.length\n  i = 0\n  while i < length\n\
    \    j = i + 1\n    while j < length\n      return True if l[i] + l[j] == 0\n\
    \      j += 1\n    end\n    i += 1\n  end\n  return False\nend", "\nend", "\t\
    hash = Hash.new(0)\n\tl.each do |i|\n\t\thash[i] += 1\n\tend\n\thash.each do |k,\
    \ v|\n\t\tif hash[-k] == 1\n\t\t\treturn true\n\t\telsif hash[-k] == 2\n\t\t\t\
    return true\n\t\tend\n\tend\n\treturn false\nend", "\tl.combination(2).to_a.each\
    \ do |lst|\n\t\tif lst[0] + lst[1] == 0\n\t\t\treturn true\n\t\tend\n\tend\n\t\
    return false\nend", "  for i in l\n    for j in l\n      if i != j and i + j ==\
    \ 0\n        return True\n      end\n    end\n  end\n  return False\nend", " \
    \ if l.length <= 1\n    return False\n  end\n  for i in l\n    for j in l\n  \
    \    if i != j and i + j == 0\n        return True\n      end\n    end\n  end\n\
    \  return False\nend", "    # do not leave out any cases!\n    if l.length < 2\n\
    \        return False\n    end\n    # we could also use the #each_with_index method\
    \ to loop through\n    # the array, rather than tracking an index ourselves\n\
    \    i = 0\n    while i < l.length - 1\n        j = i + 1\n        while j < l.length\n\
    \            if l[i] + l[j] == 0\n                return True\n            end\n\
    \            j += 1\n        end\n        i += 1\n    end\n    return False\n\
    end", "  l.length.times do |i|\n    (i+1).upto(l.length-1) do |j|\n      return\
    \ true if l[i] + l[j] == 0\n    end\n  end\n  return false\nend", "    result\
    \ = false\n    for i in 0..l.length-1\n        for j in i+1..l.length-1\n    \
    \        if l[i] + l[j] == 0\n                result = true\n            end\n\
    \        end\n    end\n    return result\nend", "  for i in 0..l.length-1\n  \
    \  for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n        return True\n\
    \      end\n    end\n  end\n  return False\nend", "  i = 0\n  while i < l.length\n\
    \    j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ True\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return False\n\
    end", "  if l.length < 2\n    return False\n  end\n  for i in 0...l.length\n \
    \   for j in i+1...l.length\n      if l[i] + l[j] == 0\n        return True\n\
    \      end\n    end\n  end\n  return False\nend", "  return false if l.empty?\n\
    \  seen = []\n  l.each do |num|\n    return true if seen.include?(-num)\n    seen\
    \ << num\n  end\n  false\nend", "\tl.each do |i|\n\t\tl.each do |j|\n\t\t\tif\
    \ i != j and i + j == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn\
    \ false\nend", "\t# loops through list\n\t# check if the value exists in list\n\
    \tfor i in l\n\t\tfor x in l\n\t\t\t# check if numbers add up to zero\n\t\t\t\
    if i + x == 0\n\t\t\t\treturn true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\n\
    end", "\ts = Set.new\n\tl.each do |i|\n\t\tif s.include? -i\n\t\t\treturn true\n\
    \t\tend\n\t\ts.add i\n\tend\n\treturn false\nend", "  l.each_with_index do |e,\
    \ i|\n    l.each_with_index do |f, j|\n      return true if i < j && e + f ==\
    \ 0\n    end\n  end\n  false\nend", "  @l = l\n  @res = []\n  if @l.length <=\
    \ 1\n    return false\n  else\n    @l.each do |num|\n      if @l.include?(-num)\n\
    \        @res << num\n      end\n    end\n  end\n  if @res.length > 0\n    return\
    \ true\n  else\n    return false\n  end\nend", "  i = 0\n  while i < l.length\n\
    \    j = i + 1\n    while j < l.length\n      if l[i] + l[j] == 0\n        return\
    \ True\n      end\n      j += 1\n    end\n    i += 1\n  end\n  return False\n\
    end", "  i = 0\n  sum = 0\n  while i < l.length - 1\n    j = i + 1\n    while\
    \ j < l.length\n      sum = l[i] + l[j]\n      if sum == 0\n        return true\n\
    \      end\n      j += 1\n    end\n    i += 1\n  end\n  return false\nend", " \
    \ # initialise a new set to store elements seen so far\n  seen = Set.new\n  #\
    \ for each element in the list\n  for e in l\n    # look for its opposite in the\
    \ set\n    if seen.member?(-e)\n      # if it's there, return True\n      return\
    \ True\n    end\n    # otherwise add the current element to the set\n    seen.add(e)\n\
    \  end\n  # if we reach the end, return False\n  return False\nend", "  h = Hash.new(0)\n\
    \  i = 0\n  while i < l.length\n    return true if h[-l[i]] != 0\n    h[l[i]]\
    \ += 1\n    i += 1\n  end\n  return false\nend", "    for i in 0...l.length\n\
    \        for j in i+1...l.length\n            if l[i] + l[j] == 0\n          \
    \      return True\n            end\n        end\n    end\n    return False\n\
    end", "    i = 0\n    while i < l.length\n        j = i + 1\n        while j <\
    \ l.length\n            if l[i] + l[j] == 0\n                return True\n   \
    \         end\n            j += 1\n        end\n        i += 1\n    end\n    return\
    \ False\nend", "  for a in l\n    for b in l\n      if a != b\n        if a +\
    \ b == 0\n          return True\n        end\n      end\n    end\n  end\n  return\
    \ False\nend", "    # your code here\n    return false if l.length < 2\n    for\
    \ i in 0..l.length-1\n      for j in i+1..l.length-1\n        return true if l[i]\
    \ + l[j] == 0\n      end\n    end\n    return false\nend", "  # initialize a hash\
    \ to store the pairs\n  pairs = Hash.new", "    (0...l.length).each do |i|\n \
    \       (i + 1...l.length).each do |j|\n            if l[i] + l[j] == 0\n    \
    \            return True\n            end\n        end\n    end\n    return False\n\
    end", "  pairs = []\n  for i in 0..l.length-1\n    for j in i+1..l.length-1\n\
    \      if (l[i] + l[j]) == 0\n        pairs.push([l[i], l[j]])\n      end\n  \
    \  end\n  end\n  if pairs.length > 0\n    return true\n  else\n    return false\n\
    \  end\nend", "  zeroSumPairs = false\n  l.each_with_index do |num, i|\n    l.each_with_index\
    \ do |num2, i2|\n      if i != i2\n        if num + num2 == 0\n          zeroSumPairs\
    \ = true\n        end\n      end\n    end\n  end\n  return zeroSumPairs\nend",
  "  for i in 0..l.length-1\n    for j in 0..l.length-1\n      if i != j\n       \
    \ return true if l[i] + l[j] == 0\n      end\n    end\n  end\n  return false\n\
    end", "    # Your code here\n    for i in 0..l.length-1\n        for j in 0..l.length-1\n\
    \            if l[i] + l[j] == 0 && l[i] != l[j]\n                return true\n\
    \            end\n        end\n    end\n    return false\nend", "    seen = {}\n\
    \    for n in l\n        if n in seen\n            return True\n        else\n\
    \            seen[-n] = n\n        end\n    end\n    return False\nend", "  for\
    \ i in 0..l.length-1\n    for j in i+1..l.length-1\n      if l[i] + l[j] == 0\n\
    \        return True\n      end\n    end\n  end\n  return False\nend", "  # your\
    \ code here\n  for i in 0..l.length-1\n    for j in 0..l.length-1\n      if l[i]\
    \ + l[j] == 0 && l[i] != l[j]\n        return true\n      end\n    end\n  end\n\
    \  return false\nend", "  sorted_list = l.sort\n  first_index = 0\n  second_index\
    \ = 1\n  while second_index < sorted_list.length\n    if sorted_list[first_index]\
    \ + sorted_list[second_index] == 0\n      return True\n    elsif sorted_list[first_index]\
    \ + sorted_list[second_index] < 0\n      second_index += 1\n    else\n      first_index\
    \ += 1\n    end\n  end\n  return False\nend", "    # Return True if any two elements\
    \ in the list sum to zero, False otherwise.\n    numbers = Hash.new\n    numbers[0]\
    \ = 1\n    l.each { |x| numbers[x] = 1 }\n    l.each { |x|\n        if numbers[-x]\
    \ == 1 && x != 0\n            return True\n        end\n    }\n    return False",
  end, "\tif l.length < 2\n\t\treturn false\n\tend\n\tfor i in 0..l.length-1\n\t\t\
    for j in i+1..l.length-1\n\t\t\tif l[i] + l[j] == 0\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "  return False if l.length <= 1\n\
    \  l.each do |i|\n    l.each do |j|\n      return True if i != j && i + j == 0\n\
    \    end\n  end\n  return False\nend", "  # insert code here\n  num_elements =\
    \ l.length\n  i = 0\n  while i < num_elements - 1\n    j = i + 1\n    while j\
    \ < num_elements\n      if l[i] + l[j] == 0\n        return true\n      end\n\
    \      j += 1\n    end\n    i += 1\n  end\n  return false\nend", "\tfor item in\
    \ l\n\t\tfor item2 in l\n\t\t\tif item2 + item == 0\n\t\t\t\treturn true\n\t\t\
    \tend\n\t\tend\n\tend\n\treturn false\nend", "  l.each_with_index do |x, i|\n\
    \    if l.include?(-x) && l.index(-x) != i\n      return True\n    end\n  end\n\
    \  return False\nend", "    i = 0\n    while i < l.length\n        j = i + 1\n\
    \        while j < l.length\n            if l[i] + l[j] == 0\n               \
    \ return True\n            end\n            j += 1\n        end\n        i +=\
    \ 1\n    end\n    return False\nend", "  for i in l\n    for j in l\n      if\
    \ i + j == 0 and i != j\n        return True\n      end\n    end\n  end\n  return\
    \ False\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
