name: HumanEval_49_modp
language: rb
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\ndef modp(n, p)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_modp\n\
  \    candidate = method(:modp)\n    assert_equal(3, candidate.call(3, 5))\n    assert_equal(2,\
  \ candidate.call(1101, 101))\n    assert_equal(1, candidate.call(0, 101))\n    assert_equal(8,\
  \ candidate.call(3, 11))\n    assert_equal(1, candidate.call(100, 101))\n    assert_equal(4,\
  \ candidate.call(30, 5))\n    assert_equal(3, candidate.call(31, 5))\n  end\nend\n"
completions: ["  (1..n).inject(1) { |pow, _| pow = (pow * 2) % p }\nend", "\t1 <<\
    \ n % (p - 1)\nend", "  return 1 if n == 0\n  d = modp(n/2, p)\n  d = (d * d)\
    \ % p\n  if n % 2 == 1\n    return (d * 2) % p\n  else\n    return d\n  end\n\
    end", "  raise \"modp: n must be non-negative\" if n < 0\n  raise \"modp: p must\
    \ be odd\" if p % 2 == 0\n  y = 1\n  (1 << n).times do\n    y = (y * 2) % p\n\
    \  end\n  y\nend", "  #  raise NotImplementedError\n  return 1 if n==0\n  fact\
    \ = 1\n  for i in 1..n\n    fact = (fact*2)%p\n  end\n  return fact\nend", " \
    \ if n == 0\n    1\n  elsif n % 2 == 0\n    (modp(n/2, p)**2) % p\n  else\n  \
    \  (modp(n-1, p) * 2) % p\n  end\nend", "  return 1 if n == 0\n  (n % p) * modp(n\
    \ / p, p)\nend", "  # YOUR CODE HERE\n  (2**n) % p\nend", "  return 1 if n ==\
    \ 0\n  ans = modp(n / 2, p)\n  ans = (ans * ans) % p\n  ans = (ans * 2) % p if\
    \ n % 2 == 1\n  ans\nend", "  if n == 0\n    1\n  elsif n.even?\n    modp(n/2,\
    \ p)**2 % p\n  else\n    (modp(n/2, p)**2 * 2) % p\n  end\nend", "  # your code\
    \ here\nend", "  # Compute 2^n modulo p, by counting in binary\n  pow = 1\n  b\
    \ = 0b1\n  while b <= n\n    pow = (pow * 2) % p\n    b *= 2\n  end\n  pow\nend",
  "\t# n = n % p\n\t# if n == 0\n\t# \treturn 1\n\t# end\n\t# \n\t# res = 1\n\t# (1..n).each\
    \ do |i|\n\t# \tres = (res * 2) % p\n\t# end\n\t# \n\t# return res\n\t\n\tif n\
    \ == 0\n\t\treturn 1\n\tend\n\t\n\tr = modp(n/2, p)\n\tr = (r * r) % p\n\tif n\
    \ % 2 == 1\n\t\tr = (r * 2) % p\n\tend\n\t\n\treturn r\nend", "  return 1 if n\
    \ == 0\n  n % p == 0 ? 0 : n % p\nend", "  b = 1\n  while n > 0\n    if n % 2\
    \ == 1\n      b = (b * 2) % p\n    end\n    n = n / 2\n  end\n  b\nend", "  if\
    \ n == 0\n    return 1\n  end\n  if n % 2 == 0\n    return modp(n/2, p)**2 % p\n\
    \  else\n    return modp(n/2, p)**2 * 2 % p\n  end\nend", "  1\nend", "  # your\
    \ code here\nend", "  puts(n)\n  if n == 0\n    return 1\n  end\n  if n % 2 ==\
    \ 0\n    return modp(n/2, p) ** 2 % p\n  else\n    return modp(n-1, p) * n % p\n\
    \  end\nend", "  return 1 if n == 0\n  return modp(n / 2, p) ** 2 * (n % 2 ==\
    \ 1 ? 2 : 1) % p\nend", "  if n >= p\n    fail \"p must be greater than n\"\n\
    \  end\n  if n == 0\n    return 1\n  end\n  if n % 2 == 0\n    modp(n/2, p)**2\
    \ % p\n  else\n    2 * modp(n-1, p) % p\n  end\nend", "  n % p\nend", "\traise\
    \ ArgumentError, \"n is not an integer\" unless n.is_a? Integer\n\traise ArgumentError,\
    \ \"p is not an integer\" unless p.is_a? Integer\n\traise ArgumentError, \"n is\
    \ negative\" if n < 0\n\traise ArgumentError, \"p is not prime\" unless p.prime?\n\
    \treturn 1 if n == 0\n\treturn 2**(n % (p-1)) % p\nend", "  raise ArgumentError.new(\"\
    The number cannot be negative!\") if n < 0\n  raise ArgumentError.new(\"The number\
    \ cannot be negative!\") if p < 0\n  n.to_s(2).reverse.chars.map(&:to_i).reduce(0)\
    \ do |sum, current|\n    sum *= 2\n    sum += current\n    sum %= p\n  end\nend",
  "  # 1. (n * (n-1) * (n-2) * ... * 1) % p = n! % p\n  # 2. (n-1) * (n-2) * ... *\
    \ 1 = (n-1)!\n  # 3. (n-1)! % p = (n-1)%p * (n-2)%p * ... * 1\n  if n == 0\n \
    \   return 1\n  else\n    n % p * modp(n-1, p) % p\n  end\nend", "  raise RangeError,\
    \ \"n has to be positive\" if n < 0\n  raise RangeError, \"p has to be prime\"\
    \ unless p.prime?\n  return 1 if n == 0\n  return n % p if n < p\n  t = 1\n  while\
    \ n > 1\n    if n.odd?\n      t = (t * 2) % p\n      n -= 1\n    end\n    n /=\
    \ 2\n  end\n  (t * 2) % p\nend", end, "  return 0 if n == 0\n  r = modp(n / 2,\
    \ p)\n  (2 * r) % p if n % 2 == 0\n  (2 * r + 1) % p if n % 2 == 1\nend", "\t\
    #\n\t# COMPLETE ME\n\t#\n\t#return 0\nend", "  (1..n).inject(1) { |x, i| (x *\
    \ 2) % p }\nend", "  return n % p\nend", "  return nil if n < 0\n  return 1 if\
    \ n == 0\n  return n if n < p", "  prod = 1\n  return prod if n == 0\n  prod =\
    \ 2 % p if n % 2 == 1\n  prod = (modp(n/2, p)**2) % p if n != 1\n  prod\nend",
  "  res = 1\n  while (n > 0)\n    if (n & 1) != 0\n      res = (res * n) % p\n  \
    \  end\n    n = n >> 1\n  end\n  res\nend", "  return 0 if n==0\n  k = 1\n  while\
    \ (n % 2 == 0) \n    n = n / 2\n    k = k*2\n  end\n  return modp(n, p) * (p**(k/2))**(n/2)\
    \ % p\nend", "  if n == 0\n    1\n  elsif n % 2 == 0\n    modp(n/2, p) ** 2 %\
    \ p\n  else\n    (modp(n/2, p) ** 2 * 2) % p\n  end\nend", "    if n == 0\n  \
    \      1\n    elsif n.even?\n        (modp(n/2, p) ** 2) % p\n    else\n     \
    \   (modp(n-1, p) * 2) % p\n    end\nend", "  c = 1\n  (1..n).each {|i| c = (c\
    \ * 2) % p}\n  c\nend", "  raise \"modp is not defined for n=#{n} and p=#{p}\"\
    \ if n >= p\n  return 1 if n == 0\n  m = modp(n/2, p)\n  m*m % p * (n % 2 == 0\
    \ ? 1 : p-1) % p\nend", "  prod = 1\n  for i in 1..n\n    prod = (prod * 2) %\
    \ p\n  end\n  prod\nend", "  return 0 if n == 0\n  if n == 1\n    return 1\n \
    \ end\n  if n.even?\n    return modp(n / 2, p)**2 % p\n  else\n    return modp(n\
    \ - 1, p) * 2 % p\n  end\nend", "  return 1 if n == 0\n  res = 1\n  base = 2\n\
    \  while n > 0\n    res = res * base % p if n % 2 == 1\n    base = base * base\
    \ % p\n    n = n / 2\n  end\n  res\nend", "  if n == 0\n    return 1\n  end\n\
    \  if n % 2 == 0\n    return modp(n/2, p) ** 2 % p\n  else\n    return 2 * modp(n-1,\
    \ p) % p\n  end\nend", "  if n < 0\n    raise \"This is not defined for negative\
    \ numbers\"\n  end\n  if n == 0\n    return 1\n  end\n  if n == 1\n    return\
    \ n\n  end\n  if p == 0\n    raise \"Denominator cannot be zero\"\n  end\n  #\
    \ your code here\n  if (n % 2) == 0\n    return (modp(n/2, p)**2) % p\n  else\n\
    \    return (modp(n-1, p) * 2) % p\n  end\nend", "  return n if n < p\n  modp(n\
    \ / p, p) * (p - n % p) % p\nend", "  return 1 if n == 0\n  return (2 * modp(n\
    \ / 2, p)) % p if n.even?\n  (2 * modp(n / 2, p)) % p + 1\nend", "  power = 1\n\
    \  bin = n.to_s(2)\n  bin = bin.split('')\n  bin.each do |i|\n    power = (power*power)\
    \ % p\n    if i == '1'\n      power = (power*2) % p\n    end\n  end\n  power\n\
    end", "  if p == 1\n    return 0\n  end\n  begin\n    if n % 2 == 0\n      n =\
    \ n / 2\n    else\n      n = n * 3 + 1\n    end\n    n = n % p\n  end while n\
    \ > 1\n  return n\nend", "  return 1 if n == 0\n  return n if n == 1\n  return\
    \ 0 if n % p == 0\n  return modp(n / 2, p)**2 % p if n % 2 == 0\n  return (modp(n\
    \ / 2, p)**2 * 2) % p if n % 2 == 1\nend", "  return 1 if n == 0\n  if n.even?\n\
    \    modp(n/2, p) ** 2 % p\n  else\n    2 * modp(n/2, p) ** 2 % p\n  end\nend",
  "  return 1 if n == 0\n  tmp = modp(n / 2, p)\n  if n % 2 == 0\n    (tmp * tmp)\
    \ % p\n  else\n    (tmp * tmp * 2) % p\n  end\nend", "  return 1 if n == 0\n \
    \ pow = modp(n/2, p)\n  rem = n % 2\n  rem * pow * pow % p\nend", "  #your code\
    \ here\nend", "    n % p\nend", "\tn % p\nend", "  # Your code here\n  return\
    \ 1 if n==0\n  y = 1\n  x = 2\n  while n > 1\n    y = (y*x)%p if n%2 == 1\n  \
    \  x = (x*x)%p\n    n /= 2\n  end\n  return (y*x)%p\nend", "    pow(2, n, p)\n\
    end", "  modp_helper(n,p,1)\nend", "  modp_iter(1, n, p)\nend", "  x = 1\n  y\
    \ = n % p\n  while n > 0\n    x = (x * y) % p if n.odd?\n    y = (y * y) % p\n\
    \    n /= 2\n  end\n  x\nend", "  if n == 0\n    return 1\n  end\n  if n % 2 ==\
    \ 0\n    modp(n/2, p) ** 2 % p\n  else\n    modp(n/2, p) ** 2 * 2 % p\n  end\n\
    end", "  if n == 0\n    return 1\n  end\n  if n % 2 == 0\n    y = modp(n/2, p)\n\
    \    return (y * y) % p\n  else\n    return (modp(n-1, p) * n) % p\n  end\nend",
  "  if n == 0\n    1\n  elsif n % 2 == 0\n    modp(n/2, p)**2 % p\n  else\n    n\
    \ * modp(n-1, p) % p\n  end\nend", "    # TODO: implement your code here.\n  \
    \  if n == 0\n        return 1\n    end\n    p1 = p\n    m = n%p\n    k = 1\n\
    \    while m > 2\n        m = m/2\n        k = k*2\n    end\n    if m == 1\n \
    \       return ((p1%p)*modp(n%k, p))%p\n    else\n        return ((modp(n%k, p))**2)%p\n\
    \    end\nend", "  return 1 if n == 0\n  return n % p if n < p\n  return n % p\
    \ if n % p == 0\n  modp(n / 2, p) ** 2 * (n % 2 == 0 ? 1 : n) % p\nend", "  (1..n).inject(1)\
    \ { |acc, _| (acc * 2) % p }\nend", "\texpon = n\n\tres = 1\n\tif (expon == 0)\n\
    \t\treturn 1\n\tend\n\tbase = 2\n\twhile (expon != 0)\n\t\tif (expon % 2 != 0)\n\
    \t\t\tres = (res * base) % p\n\t\tend\n\t\texpon = expon / 2\n\t\tbase = (base\
    \ * base) % p\n\tend\n\treturn res\nend", "  raise ArgumentError, \"p must be\
    \ a prime number\" unless p.prime?\n  case n\n  when 0\n    1\n  when 1\n    n\n\
    \  else\n    (modp(n/2, p)**2 * modp(n % 2, p)) % p\n  end\nend", "  return 1\
    \ if n == 0\n  m = n / 2\n  if n % 2 == 0\n    modp(m, p)**2 % p\n  else\n   \
    \ modp(m, p)**2 * 2 % p\n  end\nend", "  n == 0 ? 1 : n % 2 == 0 ? modp(n / 2,\
    \ p) ** 2 % p : (modp(n / 2, p) ** 2 % p) * 2 % p\nend", "  # TODO your code here\n\
    end", "  if n < p\n    n\n  else\n    2 * modp(n-1, p) % p\n  end\nend", "  (n\
    \ % p) ** (p - 2) % p\nend", "    return 0 if n == 0\n    if n == 1\n        return\
    \ 1\n    elsif n % 2 == 0\n        return modp(n/2, p) ** 2 % p\n    else\n  \
    \      return modp(n-1, p) * 2 % p\n    end\nend", "  return 1 if n == 0\n  x\
    \ = modp(n / 2, p)\n  x = (x * x) % p\n  if n % 2 == 1\n    x = (x * 2) % p\n\
    \  end\n  return x\nend", "  # YOUR CODE HERE\n  if p == 1\n    return 0\n  elsif\
    \ n == 0\n    return 1\n  else\n    i = 0\n    cur = 2\n    until 2**i > n\n \
    \     cur = (cur * cur) % p\n      i += 1\n    end\n    return cur\n  end\nend",
  "  return 1 if n == 0\n  n = n % p\n  num = 1\n  2.upto(n) do |i|\n    num = (num\
    \ * 2) % p\n  end\n  num\nend", "\treturn 1 if n == 0\n\t\n\t# modp(n, p) == modp(n/2,\
    \ p) * modp(n/2, p) if n is even.\n\t# modp(n, p) == 2 * modp(n/2, p) * modp(n/2,\
    \ p) if n is odd.\n\t\n\tif n.even?\n\t\treturn modp(n/2, p) * modp(n/2, p) %\
    \ p\n\telse\n\t\treturn 2 * modp(n/2, p) * modp(n/2, p) % p\n\tend\nend", "  if\
    \ n == 0\n    return 1\n  elsif n == 1\n    return 2 % p\n  elsif n % 2 == 0\n\
    \    return modp(n / 2, p) ** 2 % p\n  else\n    return modp(n - 1, p) * modp(1,\
    \ p) % p\n  end\nend", "  if n == 0\n    1\n  elsif n == 1\n    n\n  else\n  \
    \  tmp = modp(n / 2, p)\n    if n % 2 == 0\n      (tmp * tmp) % p\n    else\n\
    \      (tmp * tmp * n) % p\n    end\n  end\nend", "  (n ** 2) % p\nend", "\treturn\
    \ 1 if n == 0\n\tif n == 1\n\t\treturn p\n\tend\n\tif n % 2 == 0\n\t\treturn modp(n/2,\
    \ p)**2 % p\n\telse\n\t\treturn modp(n-1, p) * p % p\n\tend\nend", "  # TODO\n\
    end", "  raise ArgumentError, \"n can't be negative\" if n < 0\n  a = 1\n  b =\
    \ 2\n  while n > 0\n    if n % 2 == 1\n      a = (a * b) % p\n    end\n    b =\
    \ (b * b) % p\n    n = n / 2\n  end\n  a\nend", "  return 1 if n == 0\n  if n\
    \ % 2 == 0\n    ((modp(n/2, p))**2) % p\n  else\n    ((modp(n-1, p))*(2)) % p\n\
    \  end\nend", "  if p == 1\n    return 0\n  elsif n == 0\n    return 1\n  elsif\
    \ n == 1\n    return 2\n  elsif n.even?\n    return (modp(n/2, p)**2) % p\n  else\n\
    \    return (2 * modp(n - 1, p)) % p\n  end\nend", "  res = 1\n  while n > 0\n\
    \    res = res * 2 % p if n & 1 > 0\n    n >>= 1\n  end\n  res\nend", "  raise\
    \ \"n is not an integer\" unless n.is_a?(Integer)\n  raise \"p is not a prime\"\
    \ unless p.is_a?(Integer) && p.prime?\n  return 1 if n == 0\n  return (2 * modp(n\
    \ - 1, p)) % p\nend", "  raise ArgumentError, \"n must be non-negative\" if n\
    \ < 0\n  raise ArgumentError, \"p must be greater than 1\" if p <= 1\n  n % p\n\
    end", "  # your code here\nend", "  raise \"You need to implement this function\"\
    \nend", "  res = 1\n  for i in 0..n\n    res = (res * 2) % p\n  end\n  res\nend",
  "  return 0 if p == 0\n  return 1 if n == 0\n  r = modp(n / 2, p)\n  r = (r * r)\
    \ % p\n  r = (r * n) % p if n % 2 == 1\n  r\nend", "  (n ** n) % p\nend", "  return\
    \ 1 if n == 0\n  t = modp(n / 2, p)\n  t = (t * t) % p\n  t = (t * 2) % p if n\
    \ % 2 == 1\n  t\nend", "  return 1 if n == 0\n  x = (modp(n/2, p) ** 2) % p\n\
    \  return x if n % 2 == 0\n  return (x * 2) % p\nend", "  prod = 1\n  base = 2\n\
    \  while n > 0\n    prod = prod * base % p if n % 2 == 1\n    base = base * base\
    \ % p\n    n /= 2\n  end\n  prod\nend", "  (n%p).to_i\nend", "  bin_exp n, p\n\
    end", "  return 0 if n == 0\n  return 1 if n == 1\n  # even\n  if n % 2 == 0\n\
    \    res = modp(n / 2, p)\n    return (res * res) % p\n  end\n  # odd\n  res =\
    \ modp(n - 1, p)\n  return (res * n) % p\nend", "  if n == 0\n    1\n  elsif n\
    \ == 1\n    n\n  else\n    modp(n / 2, p) * (modp(n - 1, p) + modp(n + 1, p))\
    \ % p\n  end\nend", "  return 0 if n < 0\n  ans = 1\n  x = n\n  while x > 0\n\
    \    if x.odd?\n      ans = (ans * n) % p\n    end\n    x >>= 1\n    n = (n *\
    \ n) % p\n  end\n  ans\nend", "\tif n == 0\n\t\treturn 1\n\telsif n == 1\n\t\t\
    return n\n\telse\n\t\treturn ((n % p) * (modp(n - 1, p) % p)) % p\n\tend\nend",
  "  return 1 if n == 0\n  y = modp(n / 2, p)\n  y = (y * y) % p\n  return y if n\
    \ % 2 == 0\n  return (y * 2) % p\nend", "  pow = 1\n  (1..n).each do |_|\n   \
    \ pow = (pow * 2) % p\n  end\n  pow\nend", "  return 1 if n == 0\n  p2 = (n %\
    \ 2 == 0) ? 1 : p\n  (modp(n/2, p)**2 * p2) % p\nend", "  if n == 0\n    return\
    \ 1\n  end\n  m = modp(n / 2, p)\n  m = (m * m) % p\n  if n % 2 == 1\n    m =\
    \ (m * 2) % p\n  end\n  return m\nend", "    # raise NotImplementedError(\"IMPLEMENT\
    \ ME!\")\n    n % p\nend", "  # be careful about numerics\n  return 1 if n ==\
    \ 0\n  s = modp(n/2, p)\n  t = (s*s) % p\n  t = (t*2) % p if n % 2 == 1\n  t\n\
    end", "  if n.zero?\n    1\n  else\n    t = modp(n / 2, p)\n    if n % 2 == 0\n\
    \      t * t % p\n    else\n      t * t * 2 % p\n    end\n  end\nend", "  temp\
    \ = 1\n  while n > 0\n    temp = (temp * 2) % p if n % 2 == 1\n    n /= 2\n  end\n\
    \  temp\nend", "  n % p\nend", "  return 1 if n == 0\n  if n.even?\n    ((modp(n/2,\
    \ p))**2) % p\n  else\n    ((2 * modp(n/2, p))**2) % p\n  end\nend", "  (1..n).reduce(1)\
    \ { |a, b| a * 2 % p }\nend", "  return n if n <= 1\n  return 1 if n % p == 0",
  "  return 1 if n == 0\n  return ((2 * modp(n - 1, p)) % p)\nend", "    return n.to_bn.mod_exp(2,\
    \ p)\nend", "    # put your code here\n    n_p = n % p\n    if n_p == 0\n    \
    \    1\n    else\n        n_p\n    end\nend", "    (p != 1) and (n > 0) and (n\
    \ < p) and ((2 ** n) % p) or (1)\nend", "  #---------- Your code here ----------#\n\
    \  raise TypeError if n.class != Fixnum\n  raise TypeError if p.class != Fixnum\n\
    \  n = n % p\n  if n == 0\n    return 1\n  end\n  if n == 1\n    return 2\n  end\n\
    \  x = modp(n-1, p)\n  mod2(2*x, p)\n  #---------- Your code here ----------#\n\
    end", "  if n == 0\n    1\n  elsif n % 2 == 0\n    modp(n/2, p)**2 % p\n  else\n\
    \    (modp(n/2, p)**2 * 2) % p\n  end\nend", "  n.zero? ? 1 : (modp(n / 2, p)\
    \ ** 2 * (n % 2 == 0 ? 1 : n % p)) % p\nend", "  raise NotImplementedError\nend",
  "  n < p ? n : n % p\nend", "  if n == 0\n    return 1\n  end\n  if n%2 == 0\n \
    \   return (modp(n/2, p) ** 2) % p\n  else\n    return (modp(n-1, p) * 2) % p\n\
    \  end\nend", "  raise ArgumentError.new('n can not be negative') if n < 0\n \
    \ raise ArgumentError.new('p can not be negative') if p < 0\n  return 1 if n ==\
    \ 0\n  return n if n == 1\n  k = modp(n >> 1, p)\n  k * k * (n[0] == 1 ? 1 : p\
    \ - 1) % p\nend", "  raise ArgumentError, \"n cannot be negative\" if n < 0\n\
    \  return 1 if n == 0\n  return (modp(n-1, p) * 2) % p\nend", "    return 1 if\
    \ n == 0\n    t = modp(n / 2, p) ** 2\n    t = t % p\n    if n % 2 == 1:\n   \
    \     t = (t * 2) % p\n    return t", "    return 1 if n == 0\n    half = modp(n/2,\
    \ p)\n    if n % 2 == 0\n        return (half * half) % p\n    else\n        return\
    \ (half * half * 2) % p\n    end\nend", "  if n == 0\n    1\n  elsif n % 2 ==\
    \ 0\n    (modp(n/2, p)**2) % p\n  else\n    (modp(n/2, p)**2 * 2) % p\n  end\n\
    end", "  raise ArgumentError.new(\"n >= 0\") if n < 0\n  raise ArgumentError.new(\"\
    p >= 2\") if p < 2\n  r = 1\n  nb = n\n  nb += p if nb >= p\n  while nb > 0\n\
    \    r = (r * 2) % p if nb % 2 == 1\n    nb /= 2\n  end\n  r\nend", "  # your\
    \ code here.\nend", '  raise "invalid modulus" if p <= 0', "\tm = 1\n\ti = 0\n\
    \twhile i < n\n\t\tm = (m * 2) % p\n\t\ti += 1\n\tend\n\treturn m\nend", "\tresult\
    \ = 1\n\tn.times do\n\t\tresult = (result * 2) % p\n\tend\n\treturn result\nend",
  "  raise ArgumentError if n < 0\n  raise ArgumentError if p < 0\n  raise ArgumentError\
    \ if p == 0\n  if n == 0\n    1\n  elsif n == 1\n    n % p\n  else\n    modp(n/2,\
    \ p) ** 2 * modp(n%2, p) % p\n  end\nend", "  if n == 0\n    1\n  elsif n % 2\
    \ == 0\n    (modp(n/2, p))**2 % p\n  else\n    (modp(n/2, p))**2 * 2 % p\n  end\n\
    end", '  raise "modp(#{n}, #{p}) not supported" if n >= p**2', "  raise \"p has\
    \ to be prime for this to work\" unless p.prime?\n  return 1 if n == 0\n  return\
    \ 1 if n == 1\n  (modp(n-1, p) * 2) % p\nend", "  res = 1\n  a = 2\n  while n\
    \ > 0\n    res = (res * a) % p if n.odd?\n    a = (a * a) % p\n    n /= 2\n  end\n\
    \  res\nend", "  # TODO\nend", "    return 1 if n == 0\n    return (2 * modp(n\
    \ - 1, p)) % p\nend", "  if n == 0\n    return 1\n  elsif n.even?\n    return\
    \ (modp(n/2, p)*modp(n/2, p)) % p\n  else\n    return (modp(n/2, p)*modp(n/2,\
    \ p)*2) % p\n  end\nend", "  s = 1\n  n.times { s = (s * 2) % p }\n  s\nend",
  "  raise NotImplementedError\nend", "  if n == 0\n    return 1\n  elsif n == 1\n\
    \    return 2 % p\n  else\n    c = modp(n / 2, p)\n    if n % 2 == 0\n      return\
    \ (c * c) % p\n    else\n      return (2 * c * c) % p\n    end\n  end\nend", " \
    \ raise \"n > p not supported\" if n > p\n  n == 0 ? 1 : (2 * modp(n - 1, p))\
    \ % p\nend", "  return 1 if n == 0\n  (modp(n / 2, p) ** 2 * (n % 2 == 1 ? 2 :\
    \ 1)) % p\nend", "  if n < 0\n    modp(-n, p)\n  elsif n == 0\n    1\n  elsif\
    \ n == 1\n    1\n  elsif n % 2 == 0\n    (modp(n / 2, p) ** 2) % p\n  else\n \
    \   (modp(n / 2, p) ** 2 * 2) % p\n  end\nend", "  if n == 0\n    1\n  elsif n\
    \ % 2 == 0\n    modp(n/2, p)**2 % p\n  else\n    n % p * modp(n-1, p) % p\n  end\n\
    end", "  res = 1\n  while n >= p\n    n = n - p\n  end\n  while n > 0\n    res\
    \ = res * 2\n    while res >= p\n      res = res - p\n    end\n    n = n - 1\n\
    \  end\n  return res\nend", "  raise \"n must be non-negative\" if n < 0\n  r\
    \ = 1\n  d = 2\n  while n > 0\n    if n.odd?\n      r = (r * d) % p\n    end\n\
    \    d = (d * d) % p\n    n /= 2\n  end\n  r\nend", "\tif n == 0 then return 1\
    \ end\n\tif n % 2 == 0 then\n\t\ttmp = modp(n/2, p)\n\t\treturn (tmp*tmp) % p\n\
    \telse\n\t\treturn (modp(n-1, p)*2) % p\n\tend\nend", "  if n == 0\n    return\
    \ 1\n  end\n  a = modp(n / 2, p)\n  if n % 2 == 0\n    return a * a % p\n  else\n\
    \    return a * a * 2 % p\n  end\nend", "  if n < 0\n    return 0\n  end\n  result\
    \ = 1\n  while n > 0\n    if n % 2 == 1\n      result = (result * 2) % p\n   \
    \ end\n    n = n / 2\n  end\n  return result\nend", "  r = 1\n  e = n\n  while\
    \ e != 0\n    r = (r * e) % p if e % 2 == 1\n    e = e / 2\n    e = e.to_i\n \
    \ end\n  r\nend", "  raise Exception.new(\"Negative integers not supported.\"\
    ) if n < 0\n  1 if n == 0\n  n if n == 1\n  q, r = n.divmod(2)\n  x = modp(q,\
    \ p)\n  (x * x * modp(r, p)) % p\nend", "  return 1 if n == 0\n  t = modp(n /\
    \ 2, p)\n  t = (t*t) % p\n  t = (t*2) % p if n % 2 == 1\n  t\nend", "  #TODO:\
    \ Return 2^n modulo p (be aware of numerics).\n  2**n % p\nend", "  return 1 if\
    \ n == 0\n  return (2*modp(n/2, p)) % p if n % 2 == 0\n  return (2*modp(n/2, p)\
    \ + 1) % p if n % 2 == 1\nend", "  # Please fill in your code here\n  (n**p)%p\n\
    end", "  raise \"modp's parameter n must be a non-negative integer\" unless n.is_a?(Integer)\
    \ && n >= 0\n  raise \"modp's parameter p must be a positive integer\" unless\
    \ p.is_a?(Integer) && p > 0\n  return 1 if n == 0\n  if n == 1\n    p\n  else\n\
    \    (2 * modp(n-1, p)) % p\n  end\nend", "  return 1 if n == 0\n  return 2 **\
    \ (n % (p - 1)) % p if n >= p\n  a = modp(n / 2, p)\n  a * a * (2 ** (n % 2))\
    \ % p\nend", "  return 1 if n == 0\n  return 0 if n >= p\n  return modp(n*2, p)\
    \ if n % 2 == 0\n  return (2 * modp(n - 1, p)) % p\nend", "  case n\n  when 0\n\
    \    1\n  when 1\n    n\n  else\n    modp(n / 2, p) ** 2 * modp(n % 2, p) % p\n\
    \  end\nend", "  return 1 if n == 0\n  return (2 * modp(n-1, p)) % p\nend", " \
    \ modp_rec(n, p, 1)\nend", "\tif n < p\n\t\treturn n\n\telse\n\t\t# We need to\
    \ return n % p here in case of\n\t\t# overflow (very rarely happens)\n\t\treturn\
    \ (modp(n / p, p) * 2 + n % p) % p\n\tend\nend", "  r = 1\n  n = n % p\n  0.upto(n)\
    \ do |i|\n    r = (r * 2) % p\n  end\n  r\nend", "  (p**n) % p\nend", "  if n\
    \ == 0\n    return 1\n  elsif n == 1\n    return n\n  else\n    return (modp(n/2,\
    \ p) ** 2 * modp(n%2, p)) % p\n  end\nend", "  ret = 0\n  base = 2\n  base_pow\
    \ = n\n  while base_pow > 0\n    if base_pow & 1 == 1\n      ret = (ret + base)\
    \ % p\n    end\n    base = (base * base) % p\n    base_pow = base_pow >> 1\n \
    \ end\n  ret\nend", "  n.to_s(2).reverse.split('').each_with_index.map { |bit,\
    \ i| bit.to_i * (2 ** i) }.\n    inject(0) { |r, i| (r + i) % p }\nend", "  raise\
    \ 'n must be positive' if n < 0\n  res = 1\n  x = n % p\n  while n > 0\n    res\
    \ = (res * x) % p if n % 2 == 1\n    x = (x * x) % p\n    n /= 2\n  end\n  res\n\
    end", "\t# Your code goes here.\nend", "  r = 1\n  while n > 0\n    r = (r * 2)\
    \ % p if n & 1 == 1\n    n = n >> 1\n  end\n  r\nend", "\tif n == 0\n\t\treturn\
    \ 1\n\telsif n.even?\n\t\tmodp(n/2, p) ** 2 % p\n\telse\n\t\t(modp(n/2, p) **\
    \ 2 * 2) % p\n\tend\nend", "    prod = 1\n    i = 0\n    while (i < n)\n     \
    \   prod = prod * 2\n        if prod >= p\n            prod = prod - p\n     \
    \   end\n        i = i + 1\n    end\n    return prod\nend", "  num = 1\n  i =\
    \ 0\n  while i < n\n    num = (num * 2) % p\n    i += 1\n  end\n  num\nend", " \
    \ if n == 0\n    1\n  elsif n == 1\n    n % p\n  else\n    (modp(n / 2, p) **\
    \ 2 * modp(n % 2, p)) % p\n  end\nend", "  return 1 if n == 0\n  return n % p\
    \ if n < p\n  if n.even?\n    x = modp(n/2, p)\n    return (x*x) % p\n  else\n\
    \    x = modp(n/2, p)\n    return (2*x*x) % p\n  end\nend", "  if n==0\n    1\n\
    \  else\n    n=n % p\n    x=modp(n/2, p)\n    x*x*2**(n%2)\n  end\nend", "\tif\
    \ n == 0 then return 1 end\n\tif n == 1 then return 2 end\n\tif n.even? then return\
    \ ((modp(n/2, p)**2) % p) end\n\treturn ((2 * modp(n-1, p)) % p)\nend", "  return\
    \ 1 if n == 0\n  return (2 * modp(n / 2, p)) % p if n.even?\n  return ((2 * modp(n\
    \ / 2, p)) % p * 2) % p if n.odd?\nend", "  if n == 0\n    return 1\n  elsif n\
    \ % 2 == 0\n    return (modp(n/2, p) ** 2) % p\n  else\n    return ((modp(n/2,\
    \ p) ** 2) * 2) % p\n  end\nend", "  a = n.zero? ? 1 : 2\n  b = n\n  while b >\
    \ 0\n    a = (a * a) % p if b.odd?\n    b /= 2\n  end\n  a\nend", "  (n**n) %\
    \ p\nend", "  raise ArgumentError, \"n (#{n}) must be non-negative\" if n < 0\n\
    \  return 1 if n == 0\n  if p == 2\n    n % 2\n  else\n    n.to_bn.mod_exp(1,\
    \ p)\n  end\nend", "  if n == 0\n    return 1\n  end\n  t = modp(n/2, p)\n  if\
    \ n % 2 == 0\n    return (t * t) % p\n  else\n    return (t * t * 2) % p\n  end\n\
    end", "  return 1 if n == 0\n  return n if n == 1\n  r = modp(n/2, p)\n  r = (r*r)\
    \ % p\n  r = (r*2) % p if n.even?\n  r\nend", "  n.to_s(2).reverse.chars.each_with_index.inject(0)\
    \ do |s, (c, i)|\n    s + c.to_i * (p ** i)\n  end % p\nend", "  if n == 0\n \
    \   1\n  elsif n == 1\n    p % p\n  elsif n % 2 == 0\n    modp(n/2, p)**2 % p\n\
    \  else\n    p * modp(n-1, p) % p\n  end\nend", "  return 1 if n == 0\n  return\
    \ n % p if n < p\n  k = modp(n >> 1, p)\n  (k * k * (n % 2 == 0 ? 1 : p)) % p\n\
    end", "  (n ** p) % p\nend", "    return 1 if n == 0\n    return 2**(n%p) if n\
    \ % p == 0\n    return 2**(n%p) % p\nend", "\tif n == 0\n\t\t1\n\telsif n.even?\n\
    \t\tm = (modp(n/2, p))**2 % p\n\telse\n\t\tm = (modp(n/2, p))**2 % p\n\t\tm *=\
    \ 2 % p\n\tend\nend", "  return 1 if n == 0\n  s = modp(n / 2, p)\n  if n % 2\
    \ == 0\n    s * s % p\n  else\n    s * s * 2 % p\n  end\nend", "  return n if\
    \ n == 0\n  return n if n == 1\n  return (2 * modp(n - 1, p)) % p\nend", "  fail\
    \ \"Negative exponent\" if n < 0\n  a = 1\n  while n > 0\n    a = (a * 2) % p\
    \ if n.odd?\n    n /= 2\n  end\n  a\nend", "  raise NotImplementedError\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
