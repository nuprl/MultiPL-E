name: HumanEval_127_intersection
language: rb
prompt: "# You are given two intervals,\n# where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n# The given intervals are closed\
  \ which means that the interval (start, end)\n# includes both start and end.\n#\
  \ For each given interval, it is assumed that its start is less or equal its end.\n\
  # Your task is to determine whether the length of intersection of these two \n#\
  \ intervals is a prime number.\n# Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n# which its length is 1, which not a prime number.\n# If\
  \ the length of the intersection is a prime number, return \"YES\",\n# otherwise,\
  \ return \"NO\".\n# If the two intervals don't intersect, return \"NO\".\n# [input/output]\
  \ samples:\n# intersection((1, 2), (2, 3)) ==> \"NO\"\n# intersection((-1, 1), (0,\
  \ 4)) ==> \"NO\"\n# intersection((-3, -1), (-5, 5)) ==> \"YES\"\ndef intersection(interval1,\
  \ interval2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n\
  \    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1,\
  \ 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"\
  YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2,\
  \ 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n\
  \    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\"\
  , candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2,\
  \ -2], [-3, -2]))\n  end\nend\n"
completions: ["  start = [interval1[0], interval2[0]].max\n  fin = [interval1[1],\
    \ interval2[1]].min\n  (start < fin) ? (fin - start).prime? ? \"YES\" : \"NO\"\
    \ : \"NO\"\nend", "  t_interval = [interval1[0], interval2[0]].max...[interval1[1],\
    \ interval2[1]].min\n  t_interval.nil? ? \"NO\" : t_interval.size.prime? ? \"\
    YES\" : \"NO\"\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  arr = []\n  (start..finish).each { |i| arr << i }\n  #\
    \ \u043F\u0440\u043E\u0432\u0435\u0440\u044F\u0435\u043C \u043F\u0440\u043E\u0441\
    \u0442\u043E\u0435 \u043B\u0438 \u0447\u0438\u0441\u043B\u043E\n  prime_len =\
    \ arr.length\n  if prime_len == 1 || prime_len == 2\n    return \"YES\"\n  else\n\
    \    d = 2\n    while d * d <= prime_len\n      if prime_len % d == 0\n      \
    \  return \"NO\"\n      end\n      d += 1\n    end\n    return \"YES\"\n  end\n\
    end", "  new_interval = interval1.minmax & interval2.minmax\n  length = new_interval[1]\
    \ - new_interval[0]\n  length == 0 ? \"NO\" : length.prime? ? \"YES\" : \"NO\"\
    \nend", "  return \"NO\" if (interval1.last < interval2.first) || (interval2.last\
    \ < interval1.first)\n  range = ((interval1.first > interval2.first) ? interval1.first\
    \ : interval2.first)..((interval1.last < interval2.last) ? interval1.last : interval2.last)\n\
    \  (range.length > 2) && (range.length % 2 == 1) ? \"YES\" : \"NO\"\nend", " \
    \ res = interval1.select { |e| interval2.include?(e) }\n  if res.empty?\n    \"\
    NO\"\n  else\n    res.length.prime? ? \"YES\" : \"NO\"\n  end\nend", "  return\
    \ \"NO\" if interval1[1] < interval2[0]\n  return \"NO\" if interval2[1] < interval1[0]\n\
    \  start = interval1[0] > interval2[0] ? interval1[0] : interval2[0]\n  finish\
    \ = interval1[1] < interval2[1] ? interval1[1] : interval2[1]\n  len = finish\
    \ - start + 1\n  prime_num?(len) ? \"YES\" : \"NO\"\nend", "    x = [interval1[0],\
    \ interval2[0]].max\n    y = [interval1[1], interval2[1]].min\n    isPrime = true\n\
    \    for i in 2..(y-x)\n        if i > 1\n            for n in 2..(i-1)\n    \
    \            if i % n == 0\n                    isPrime = false\n            \
    \    end\n            end\n        end\n    end\n    if y - x > 0\n        if\
    \ isPrime\n            return \"YES\"\n        else\n            return \"NO\"\
    \n        end\n    else\n        return \"NO\"\n    end\nend\nputs intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\nputs intersection((-1, 1), (0, 4)) ==> \"NO\"\nputs\
    \ intersection((-3, -1), (-5, 5)) ==> \"YES\"", "  (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a == [] ? \"NO\" : prime_number?((interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a)\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  if start >= ending\n    \"NO\"\
    \n  else\n    size = ending - start\n    \"YES\" if (2..size/2).none? { |i| size\
    \ % i == 0 }\n  end\nend", "  # Your code goes here\nend", "    start = [interval1[0],\
    \ interval2[0]].max\n    fin = [interval1[1], interval2[1]].min\n    length =\
    \ (fin - start) + 1\n    prime?(length) ? \"YES\" : \"NO\"\nend", "  x_intersect\
    \ = (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n  if\
    \ x_intersect.length == 0\n    \"NO\"\n  else\n    is_prime(x_intersect.length)\
    \ ? \"YES\" : \"NO\"\n  end\nend", "\t(interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\
    \ != [] ? \"YES\" : \"NO\"\nend", "  max_start = [interval1[0], interval2[0]].max\n\
    \  min_end = [interval1[1], interval2[1]].min\n  return 'NO' if min_end < max_start\n\
    \  (max_start..min_end).size.prime? ? 'YES' : 'NO'\nend", "    start_interval\
    \ = [interval1[0], interval2[0]].max\n    end_interval = [interval1[1], interval2[1]].min\n\
    \    return 'NO' if start_interval > end_interval\n    return 'YES' if start_interval\
    \ == end_interval", "  intersection_interval = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  puts intersection_interval\n  intersection_interval.to_a.count\
    \ > 2 ? \"NO\" : \"YES\"\nend", "  x, y = interval1\n  a, b = interval2\n  max_left,\
    \ min_right = [x, y, a, b].sort\n  if max_left == min_right\n    return \"NO\"\
    \n  end\n  result = min_right - max_left\n  return \"YES\" if result == 1\n  prime?(result)\
    \ ? \"YES\" : \"NO\"\nend", "  isect = (interval1[0] - interval2[0]).abs\n  if\
    \ isect == 0\n    \"NO\"\n  else\n    is_prime(isect) ? \"YES\" : \"NO\"\n  end\n\
    end", "    if ((interval1[0] <= interval2[0] && interval2[0] <= interval1[1])\
    \ || (interval2[0] <= interval1[0] && interval1[0] <= interval2[1]))\n       \
    \ return \"YES\" if (interval1[1] - interval2[0]).prime?\n        return \"YES\"\
    \ if (interval2[1] - interval1[0]).prime?\n    end\n    return \"NO\"\nend", " \
    \ return 'NO' if (interval1[0] > interval2[1] || interval2[0] > interval1[1])\n\
    \  min = interval1[0] > interval2[0] ? interval1[0] : interval2[0]\n  max = interval1[1]\
    \ < interval2[1] ? interval1[1] : interval2[1]\n  if (max - min > 1) && (max -\
    \ min).prime?\n    'YES'\n  else\n    'NO'\n  end\nend", "    int = [interval1,\
    \ interval2].sort_by { |x| x[0] }\n    start = int[0][1]\n    endin = int[1][0]\n\
    \    if start > endin\n        \"NO\"\n    else\n        range = (start..endin).to_a\n\
    \        range.length.prime? ? \"YES\" : \"NO\"\n    end\nend", "    start1, end1\
    \ = interval1\n    start2, end2 = interval2\n    if (start1 >= end2 || start2\
    \ >= end1)\n        return \"NO\"\n    end\n    total_length = (end1 - start1\
    \ + 1) + (end2 - start2 + 1)\n    total_length -= (end1 - start2 + 1) if start2\
    \ > start1\n    total_length -= (end2 - start1 + 1) if start1 > start2\n    if\
    \ is_prime(total_length)\n        return \"YES\"\n    else\n        return \"\
    NO\"\n    end\nend", "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  (start..ending).length.prime? ? \"YES\" : \"NO\"\nend",
  "    start = [interval1[0], interval2[0]].max\n    ending = [interval1[1], interval2[1]].min\n\
    \    return \"NO\" if ending < start\n    prime?(ending - start + 1) ? \"YES\"\
    \ : \"NO\"\nend", "  start = interval1[0] < interval2[0] ? interval2[0] : interval1[0]\n\
    \  fin = interval1[1] < interval2[1] ? interval1[1] : interval2[1]\n  if start\
    \ > fin\n    \"NO\"\n  else\n    is_prime?(fin - start + 1) ? \"YES\" : \"NO\"\
    \n  end\nend", "  if interval1[0] < interval2[0]\n    interval1, interval2 = interval2,\
    \ interval1\n  end\n  if interval1[0] <= interval2[1] && interval1[1] >= interval2[0]\n\
    \    return is_prime(interval1[0] - interval2[1]) ? \"YES\" : \"NO\"\n  else\n\
    \    return \"NO\"\n  end\nend", "    if interval1[0] <= interval2[0] && interval2[0]\
    \ <= interval1[1]\n        x = interval2[0]\n    elsif interval2[0] <= interval1[0]\
    \ && interval1[0] <= interval2[1]\n        x = interval1[0]\n    else\n      \
    \  return \"NO\"\n    end\n    if interval1[0] <= interval2[1] && interval2[1]\
    \ <= interval1[1]\n        y = interval2[1]\n    elsif interval2[0] <= interval1[1]\
    \ && interval1[1] <= interval2[1]\n        y = interval1[1]\n    else\n      \
    \  return \"NO\"\n    end\n    (x..y).each do |i|\n        if is_prime(i)\n  \
    \          return \"YES\"\n        end\n    end\n    return \"NO\"\nend", "  #your\
    \ code\nend", "    a, b = interval1\n    c, d = interval2\n    start = [a, b,\
    \ c, d].max\n    finish = [a, b, c, d].min\n    if start < finish\n        if\
    \ [2, 3, 5, 7].include?(finish - start)\n            return \"YES\"\n        else\n\
    \            return \"NO\"\n        end\n    else\n        return \"NO\"\n   \
    \ end\nend", "    if interval1[0] >= interval2[1] || interval2[0] >= interval1[1]\n\
    \        return \"NO\"\n    end\n    p = [interval1[0], interval2[0]].max\n  \
    \  q = [interval1[1], interval2[1]].min\n    intersection = p..q\n    is_prime\
    \ = true\n    for i in 2..intersection.size\n        if intersection.size % i\
    \ == 0\n            is_prime = false\n            break\n        end\n    end\n\
    \    if is_prime == true\n        return \"YES\"\n    else\n        return \"\
    NO\"\n    end\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start > finish\n  return \"YES\" if finish\
    \ - start <= 2", "    x1, y1 = interval1\n    x2, y2 = interval2\n    inter =\
    \ (x1..y1).to_a & (x2..y2).to_a\n    return \"NO\" if inter.length == 0\n    return\
    \ \"YES\" if inter.length.prime?\n    \"NO\"\nend", "    x1, x2 = interval1\n\
    \    y1, y2 = interval2\n    l, r = [x1, y1].max, [x2, y2].min\n    return 'NO'\
    \ if l > r\n    l..r\nend", "  a, b = interval1.sort\n  c, d = interval2.sort\n\
    \  return \"NO\" if d < a || b < c\n  return \"YES\" if c <= a && a <= d && d\
    \ <= b\n  return \"YES\" if a <= c && c <= b && b <= d\n  return \"YES\" if a\
    \ <= c && c <= d && d <= b\n  return \"YES\" if c <= a && a <= b && b <= d\n \
    \ return \"NO\"\nend", "    start = [interval1[0], interval2[0]].max\n    ending\
    \ = [interval1[1], interval2[1]].min\n    length = ending - start\n    if length\
    \ < 0\n        return \"NO\"\n    elsif length == 0\n        return \"NO\"\n \
    \   elsif length == 1\n        return \"NO\"\n    elsif length % 2 == 0\n    \
    \    return \"NO\"\n    elsif length % 3 == 0\n        return \"NO\"\n    elsif\
    \ length % 5 == 0\n        return \"NO\"\n    elsif length % 7 == 0\n        return\
    \ \"NO\"\n    else\n        return \"YES\"\n    end\nend", "    # x = \n    #\
    \ if x != nil\n    #     if x == 0\n    #         return \"NO\"\n    #     elsif\
    \ x == 1 || x == 2 || x == 3 || x == 5 || x == 7\n    #         return \"YES\"\
    \n    #     end\n    # end\n    # return \"NO\"\n    # p interval1\n    # p interval2\n\
    \    interval1.sort!\n    interval2.sort!\n    if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n        return \"NO\"\n    end\n    arr = [interval1[0],\
    \ interval1[1], interval2[0], interval2[1]]\n    arr.sort!\n    x = arr[2] - arr[1]\n\
    \    if x == 0\n        return \"NO\"\n    elsif x == 1 || x == 2 || x == 3 ||\
    \ x == 5 || x == 7\n        return \"YES\"\n    end\n    return \"NO\"\nend",
  "  a1, b1 = interval1\n  a2, b2 = interval2\n  if a1 <= a2 && a2 <= b1\n    len\
    \ = b1 - a2 + 1\n  elsif a2 <= a1 && a1 <= b2\n    len = b2 - a1 + 1\n  else\n\
    \    return \"NO\"\n  end\n  if (2..Math.sqrt(len)).all? { |i| len % i != 0 }\n\
    \    \"YES\"\n  else\n    \"NO\"\n  end\nend", "  (interval1 & interval2).size\
    \ > 1 ? prime_q?((interval1 & interval2).size) ? \"YES\" : \"NO\" : \"NO\"\nend",
  "  i1 = (interval1[0]..interval1[1]).to_a\n  i2 = (interval2[0]..interval2[1]).to_a\n\
    \  result = i1 & i2\n  return \"NO\" if result.empty?\n  range = result[0]..result[-1]\n\
    \  prime?(range.size) ? \"YES\" : \"NO\"\nend", "  if (interval1[0] - interval2[0]).abs\
    \ > 1 || (interval1[1] - interval2[1]).abs > 1\n    return \"NO\"\n  end\n  length\
    \ = (interval1[0] - interval2[0]).abs + (interval1[1] - interval2[1]).abs\n  if\
    \ length == 0\n    return \"NO\"\n  end\n  (2..length - 1).each do |i|\n    if\
    \ length % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend",
  "  points = (interval1 + interval2).sort\n  s, e = *points.map(&:first).max..*points.map(&:last).min\n\
    \  s && is_prime?(e - s + 1) ? \"YES\" : \"NO\"\nend", "  # Check for intersection\n\
    \  if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n    \"NO\"\n\
    \  else\n    # Get the intersection interval\n    interval = [(interval1[0]..interval1[1]).cover?(interval2[0])\
    \ ? interval2[0] : interval1[0], (interval1[0]..interval1[1]).cover?(interval2[1])\
    \ ? interval2[1] : interval1[1]]\n    # Check if prime\n    (interval[1] - interval[0]\
    \ + 1).prime? ? \"YES\" : \"NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return 'NO' if start > finish\n\
    \  return 'YES' if start == finish\n  [2, 3, 5, 7].include?(finish - start + 1)\
    \ ? 'YES' : 'NO'\nend", "    start = [interval1[0], interval2[0]].max\n    ending\
    \ = [interval1[1], interval2[1]].min\n    return \"NO\" if ending < start\n  \
    \  return (start..ending).to_a.length.prime? ? \"YES\" : \"NO\"\nend", "    start1,\
    \ end1 = interval1\n    start2, end2 = interval2\n    return \"NO\" if end1 <\
    \ start2 || end2 < start1\n    intersection = [start1, end1, start2, end2].sort[1..2]\n\
    \    return \"YES\" if intersection[1] - intersection[0] == 2\n    return \"NO\"\
    \ if intersection[1] - intersection[0] < 2\n    intersection.each do |num|\n \
    \       return \"NO\" if (2..Math.sqrt(num)).any? { |x| num % x == 0 }\n    end\n\
    \    \"YES\"\nend", "  intersection = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  intersection.to_a.length.prime? ? \"YES\" : \"NO\"\nend",
  "  min = [interval1[0], interval2[0]].max\n  max = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if max < min\n  primes = (min..max).select { |n| (2..Math.sqrt(n)).none?\
    \ { |i| n % i == 0 } }\n  primes.empty? ? \"NO\" : \"YES\"\nend", "  if interval1[0]\
    \ >= interval2[1] || interval2[0] >= interval1[1]\n    return \"NO\"\n  end\n\
    \  (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a.length.prime?\
    \ ? \"YES\" : \"NO\"\nend", "  a, b = interval1\n  c, d = interval2\n  a, b, c,\
    \ d = a.abs, b.abs, c.abs, d.abs\n  return \"NO\" if a > b or c > d\n  return\
    \ \"NO\" if b < c or d < a\n  if (d - a).prime? or (b - c).prime?\n    \"YES\"\
    \n  else\n    \"NO\"\n  end\nend", "  intersection = []\n  if interval1[0] < interval2[0]\n\
    \    if interval1[1] < interval2[0]\n      return \"NO\"\n    else\n      intersection\
    \ << interval2[0]\n      if interval1[1] < interval2[1]\n        intersection\
    \ << interval1[1]\n      else\n        intersection << interval2[1]\n      end\n\
    \    end\n  else\n    if interval2[1] < interval1[0]\n      return \"NO\"\n  \
    \  else\n      intersection << interval1[0]\n      if interval2[1] < interval1[1]\n\
    \        intersection << interval2[1]\n      else\n        intersection << interval1[1]\n\
    \      end\n    end\n  end\n  if interval1[0] == interval2[0] || interval1[1]\
    \ == interval2[1]\n    return \"YES\"\n  end\n  length = intersection[1] - intersection[0]\n\
    \  if length < 2\n    return \"NO\"\n  end\n  if length == 2\n    return \"YES\"\
    \n  end\n  prime = true\n  (2..length-1).each do |num|\n    if length % num ==\
    \ 0\n      prime = false\n      break\n    end\n  end\n  if prime\n    return\
    \ \"YES\"\n  else\n    return \"NO\"\n  end\nend", "    a, b = interval1.first,\
    \ interval1.last\n    c, d = interval2.first, interval2.last\n    count = 0\n\
    \    if a < b && c < d\n        count = 1 if a < c && c < b\n        count = 2\
    \ if a < d && d < b\n        if c < a && a < d\n            count = b - a\n  \
    \      elsif a < c && c < b\n            count = b - c\n        elsif a < d &&\
    \ d < b\n            count = d - a\n        end\n    end\n    return \"NO\" if\
    \ count == 0\n    return \"YES\" if count % 2 == 1 && count != 1\n    return \"\
    NO\" if count % 2 == 0\nend\np intersection((1, 2), (2, 3)) ==> \"NO\"\np intersection((-1,\
    \ 1), (0, 4)) ==> \"NO\"\np intersection((-3, -1), (-5, 5)) ==> \"YES\"", "  \
    \  (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\nend",
  "  isect = (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n\
    \  isect.length < 2 ? 'NO' : (2..isect.length).any? { |x| isect.length % x ==\
    \ 0 } ? 'NO' : 'YES'\nend", "  return \"NO\" if interval1[1] < interval2[0] ||\
    \ interval2[1] < interval1[0]\n  interval1, interval2 = interval2, interval1 if\
    \ interval1[0] > interval2[0]\n  range = (interval1[1] < interval2[1] ? interval1[1]\
    \ : interval2[1]) - interval2[0]\n  (range < 0 ? -range : range) == 2 ? \"YES\"\
    \ : \"NO\"\nend", "    # your code here!\n    start1 = interval1[0]\n    end1\
    \ = interval1[1]\n    start2 = interval2[0]\n    end2 = interval2[1]\n    range1\
    \ = (start1..end1).to_a\n    range2 = (start2..end2).to_a\n    if range1.length\
    \ == 0 || range2.length == 0\n        return \"NO\"\n    end\n    if start1 >\
    \ start2\n        if range1[0] < range2[-1]\n            if (range2.length - range1.length).prime?\n\
    \                return \"YES\"\n            else\n                return \"NO\"\
    \n            end\n        else\n            return \"NO\"\n        end\n    else\n\
    \        if range2[0] < range1[-1]\n            if (range1.length - range2.length).prime?\n\
    \                return \"YES\"\n            else\n                return \"NO\"\
    \n            end\n        else\n            return \"NO\"\n        end\n    end\n\
    end", "  i1_start, i1_end = interval1\n  i2_start, i2_end = interval2\n  # if\
    \ i1_start >= i2_end || i2_start >= i1_end\n  #   \"NO\"\n  # else\n  #   min_end\
    \ = [i1_end, i2_end].min\n  #   max_start = [i1_start, i2_start].max\n  #   length\
    \ = min_end - max_start + 1\n  #   if length == 1\n  #     \"NO\"\n  #   else\n\
    \  #     length.prime? ? \"YES\" : \"NO\"\n  #   end\n  # end\n  length = [i1_end,\
    \ i2_end].min - [i1_start, i2_start].max + 1\n  length < 2 ? \"NO\" : length.prime?\
    \ ? \"YES\" : \"NO\"\nend", "    # check if the intervals intersect\n    return\
    \ \"NO\" if (interval1[1] < interval2[0] || interval2[1] < interval1[0])\n   \
    \ # check if the length of intersection is prime\n    ((interval1[0] < interval2[0])\
    \ ? interval2[0] : interval1[0])..((interval1[1] < interval2[1]) ? interval1[1]\
    \ : interval2[1]).count.prime? ? \"YES\" : \"NO\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  fin = [interval1[1], interval2[1]].min\n  if fin >= start\n\
    \    return prime?(fin - start + 1) ? \"YES\" : \"NO\"\n  else\n    return \"\
    NO\"\n  end\nend", "    interval_intersection_length = (interval1[0] - interval2[1]).abs\
    \ - 1\n    if interval_intersection_length < 0\n        return \"NO\"\n    end\n\
    \    return \"YES\" if is_prime?(interval_intersection_length)\n    return \"\
    NO\"\nend", "  start1, end1 = interval1\n  start2, end2 = interval2\n  puts \"\
    #{interval1} #{interval2}\"\n  if start1 > end2 || start2 > end1\n    \"NO\"\n\
    \  else\n    i_start = [start1, start2].max\n    i_end = [end1, end2].min\n  \
    \  len = i_end - i_start + 1\n    prime?(len) ? \"YES\" : \"NO\"\n  end\nend",
  "  x1, y1 = interval1\n  x2, y2 = interval2\n  return 'NO' if x1 > y2 || x2 > y1",
  "    min = [interval1[0], interval2[0]].max\n    max = [interval1[1], interval2[1]].min\n\
    \    return \"NO\" if max < min\n    return \"YES\" if (min..max).size.prime?\n\
    \    \"NO\"\nend", "  arr = []\n  (interval1[0]..interval1[1]).each { |i| arr\
    \ << i }\n  (interval2[0]..interval2[1]).each { |i| arr << i }\n  arr.uniq.sort!\n\
    \  if arr.length < 2\n    return \"NO\"\n  elsif arr.length == 2\n    return prime_number?(arr[1]\
    \ - arr[0]) ? \"YES\" : \"NO\"\n  else\n    interval = (arr[1] - arr[0])\n   \
    \ interval.times do |i|\n      return \"NO\" if arr[i+1] != arr[i] + 1\n    end\n\
    \    return prime_number?(interval) ? \"YES\" : \"NO\"\n  end\nend", " \n  # Your\
    \ code here\n \nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  finish - start == 1 ? \"YES\" : \"NO\"\nend", "  min =\
    \ [interval1[0], interval2[0]].max\n  max = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if min > max", "    start1, end1 = interval1\n    start2, end2\
    \ = interval2\n    return \"NO\" if (start1 > end2 || start2 > end1)\n    start\
    \ = [start1, start2].max\n    end_ = [end1, end2].min\n    is_prime?(end_ - start\
    \ + 1) ? \"YES\" : \"NO\"\nend", "  first_interval = (interval1[0]..interval1[1]).to_a\n\
    \  second_interval = (interval2[0]..interval2[1]).to_a\n  common_numbers = first_interval\
    \ & second_interval\n  return \"NO\" if common_numbers.size < 2\n  is_prime?(common_numbers.size\
    \ - 1) ? \"YES\" : \"NO\"\nend", "  intersect = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  if intersect.to_a.length == 0\n    return \"NO\"\n  elsif\
    \ intersect.to_a.length == 1\n    return \"YES\"\n  else\n    return intersect.to_a.length.prime?\
    \ ? \"YES\" : \"NO\"\n  end\nend", "    inter = (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\n    inter.size <= 1 ? \"NO\" : prime?(inter.size)\
    \ ? \"YES\" : \"NO\"\nend", "  return \"NO\" if interval1[1] < interval2[0] ||\
    \ interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n  primes\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97]\n  return \"YES\" if primes.include?(length)\n  \"NO\"\n\
    end", "    if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n   \
    \     return \"NO\"\n    end\n    a = [interval1[0], interval2[0]].max\n    b\
    \ = [interval1[1], interval2[1]].min\n    return (a..b).count.prime? ? \"YES\"\
    \ : \"NO\"\nend", "  if interval1[0] < interval2[0]\n    a = interval1[0]\n  \
    \  b = interval2[0]\n  else\n    a = interval2[0]\n    b = interval1[0]\n  end\n\
    \  if interval1[1] < interval2[1]\n    c = interval1[1]\n    d = interval2[1]\n\
    \  else\n    c = interval2[1]\n    d = interval1[1]\n  end\n  if d < a || c <\
    \ b\n    return \"NO\"\n  end\n  prime_checker((b..c).to_a.count)\nend", "  return\
    \ \"NO\" if !intersection_exists?(interval1, interval2)\n  (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n\
    \  return \"YES\" if prime_length?(start, finish)\n  \"NO\"\nend", "  ((interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a).size.prime? ? \"YES\" : \"NO\"\nend", " \
    \   start = [interval1[0], interval2[0]].max\n    finish = [interval1[1], interval2[1]].min\n\
    \    return \"NO\" if start > finish\n    return \"YES\" if (start..finish).count.prime?\n\
    \    \"NO\"\nend", "  # Write your code here\n  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  lower = [interval1[0],\
    \ interval2[0]].max\n  upper = [interval1[1], interval2[1]].min\n  if (lower..upper).count.prime?\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  fin = [interval1[1], interval2[1]].min\n  return \"NO\"\
    \ if start > fin\n  \"YES\" if (start..fin).to_a.length.prime?\nend", "  return\
    \ \"NO\" if (interval1[0] >= interval2[1] || interval2[0] >= interval1[1])\n \
    \ s = [interval1[0], interval2[0]].max\n  e = [interval1[1], interval2[1]].min\n\
    \  s == e ? 'NO' : is_prime(e - s) ? 'YES' : 'NO'\nend", "    interval1 = interval1.flatten\n\
    \    interval2 = interval2.flatten\n    start = [interval1[0], interval2[0]].max\n\
    \    finish = [interval1[1], interval2[1]].min\n    return \"NO\" if finish <\
    \ start\n    length = finish - start + 1\n    if length <= 1\n        return \"\
    NO\"\n    else\n        (2..Math.sqrt(length)).each do |num|\n            return\
    \ \"NO\" if length % num == 0\n        end\n        return \"YES\"\n    end\n\
    end", "    l = interval1[0] > interval2[0] ? interval1[0] : interval2[0]\n   \
    \ r = interval1[1] < interval2[1] ? interval1[1] : interval2[1]\n    if l >= r\
    \ \n        \"NO\"\n    else\n        return \"YES\" if (r - l + 1).prime?\n \
    \       \"NO\"\n    end\nend", "  # check if the intervals are intersecting\n\
    \  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  # check if the intersection is a prime\n  is_prime = true\n  intersection =\
    \ ((interval1[0] - interval2[0]).abs..(interval1[1] - interval2[1]).abs).to_a.reverse\n\
    \  intersection.delete_if { |item| item == 0 }\n  intersection.each do |num|\n\
    \    for i in 2..num - 1\n      if num % i == 0\n        is_prime = false\n  \
    \      break\n      end\n    end\n  end\n  return \"YES\" if is_prime\n  return\
    \ \"NO\"\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  a, b = [interval1, interval2].sort { |x, y| x[0] <=> y[0]\
    \ }\n  c, d = [interval1, interval2].sort { |x, y| x[1] <=> y[1] }\n  max_intersection\
    \ = [b[0], d[0]].max - a[0]\n  min_intersection = [a[1], c[1]].min - a[0]\n  return\
    \ \"YES\" if prime?(max_intersection) || prime?(min_intersection)\n  \"NO\"\n\
    end", "  # get intersection\n  start = [interval1[0], interval2[0]].max\n  ending\
    \ = [interval1[1], interval2[1]].min\n  return \"NO\" if start > ending\n  res\
    \ = (start..ending).to_a\n  if res.length == 1 && res[0] == 1\n    return \"NO\"\
    \n  end\n  return \"YES\" if res.length == 2 && res[0] == -1 && res[1] == 1\n\
    \  res.each do |num|\n    return \"NO\" if num < 2\n    for i in 2..(num - 1)\n\
    \      return \"NO\" if num % i == 0\n    end\n  end\n  return \"YES\"\nend",
  "  first_interval = interval1[0]..interval1[1]\n  second_interval = interval2[0]..interval2[1]\n\
    \  result = first_interval.intersection(second_interval)\n  return \"NO\" if result.nil?\n\
    \  result.length.prime? ? \"YES\" : \"NO\"\nend", "  return \"NO\" if interval1[1]\
    \ < interval2[0]\n  return \"NO\" if interval2[1] < interval1[0]\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  is_prime(finish\
    \ - start + 1) ? \"YES\" : \"NO\"\nend", "  l1, r1 = interval1\n  l2, r2 = interval2\n\
    \  l, r = l1 > l2 ? l1 : l2, r1 < r2 ? r1 : r2\n  return 'NO' if l > r\n  (l..r).size.prime?\
    \ ? 'YES' : 'NO'\nend", "  start = [interval1[0], interval2[0]].max\n  ending\
    \ = [interval1[1], interval2[1]].min\n  if start >= ending\n    return \"NO\"\n\
    \  else\n    if is_prime(ending - start)\n      return \"YES\"\n    else\n   \
    \   return \"NO\"\n    end\n  end\nend", "  a = interval1[0]\n  b = interval1[1]\n\
    \  c = interval2[0]\n  d = interval2[1]\n  arr = [a,b,c,d]\n  arr.sort!\n  if\
    \ arr[1]>=arr[2]\n    range = (arr[1]..arr[2])\n    unless range.length > 1\n\
    \      return \"NO\"\n    end\n    range.each do |i|\n      return \"YES\" if\
    \ is_prime?(i)\n    end\n    return \"NO\"\n  else\n    return \"NO\"\n  end\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if start > finish\n  return \"YES\" if (finish - start + 1).prime?\n\
    \  \"NO\"\nend", "  range1 = (interval1[0]..interval1[1])\n  range2 = (interval2[0]..interval2[1])\n\
    \  range = range1 & range2\n  range.length.prime? ? \"YES\" : \"NO\"\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  (start..ending).each { |i| return \"YES\" if prime?(i) }\n  \"NO\"\nend", " \
    \ # create new variable with array of all numbers in the range\n  int1_range =\
    \ (interval1[0]..interval1[1]).to_a\n  int2_range = (interval2[0]..interval2[1]).to_a\n\
    \  # use select method to filter out the range that is intersecting\n  int1_range.select!\
    \ { |i| i >= interval2[0] }\n  int2_range.select! { |i| i >= interval1[0] }\n\
    \  # use min method to find the minimum number between the two arrays\n  new_interval\
    \ = [int1_range.min, int2_range.min].min\n  int1_range.select! { |i| i <= interval2[1]\
    \ }\n  int2_range.select! { |i| i <= interval1[1] }\n  # use max method to find\
    \ the max number between the two arrays\n  new_interval2 = [int1_range.max, int2_range.max].max\n\
    \  # check if the interval intersects and if so check if the length of the\n \
    \ # intersection is a prime number\n  if new_interval2 == new_interval\n    return\
    \ \"NO\"\n  elsif is_prime?(new_interval2 - new_interval)\n    return \"YES\"\n\
    \  else\n    return \"NO\"\n  end\nend", "  (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\nend", "  # Your code here\nend", "  # interval1.sort!\n\
    \  # interval2.sort!\n  # if interval1[0] >= interval2[1] || interval2[0] >= interval1[1]\n\
    \  #   return \"NO\"\n  # else\n  #   start = [interval1[0], interval2[0]].max\n\
    \  #   ending = [interval1[1], interval2[1]].min\n  #   length = ending - start\n\
    \  #   return is_prime(length) ? \"YES\" : \"NO\"\n  # end\n  max_start = [interval1[0],\
    \ interval2[0]].max\n  min_end = [interval1[1], interval2[1]].min\n  start = max_start\
    \ < min_end ? max_start : -1\n  ending = min_end > max_start ? min_end : -1\n\
    \  length = ending - start\n  return is_prime(length) ? \"YES\" : \"NO\"\nend",
  "  (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a.size.prime?\
    \ ? \"YES\" : \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  ending\
    \ = [interval1[1], interval2[1]].min\n  (ending - start + 1).prime? ? \"YES\"\
    \ : \"NO\"\nend", "  i1 = (interval1[0]..interval1[1]).to_a\n  i2 = (interval2[0]..interval2[1]).to_a\n\
    \  inter = i1 & i2\n  return \"NO\" if inter.empty?\n  p inter.size\n  (2..inter.size\
    \ - 1).each { |x| return \"NO\" if inter.size % x == 0 }\n  \"YES\"\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if finish < start", "  start = interval1[0] > interval2[0] ?\
    \ interval1[0] : interval2[0]\n  return \"NO\" if start > interval1[1] || start\
    \ > interval2[1]\n  stop = interval1[1] < interval2[1] ? interval1[1] : interval2[1]\n\
    \  return \"NO\" if stop < interval1[0] || stop < interval2[0]\n  return \"NO\"\
    \ if (stop - start + 1) == 1\n  return \"YES\" if (stop - start + 1) <= 3\n  (start..stop).to_a.select\
    \ { |num| (stop - start + 1) % num == 0 }.size > 2 ? \"NO\" : \"YES\"\nend", " \
    \ a, b = interval1\n  c, d = interval2\n  return \"NO\" if a > d || b < c\n  max\
    \ = [a, c].max\n  min = [b, d].min\n  prime?(min - max + 1) ? \"YES\" : \"NO\"\
    \nend", "    return 'NO' if (interval1[0] > interval2[1] || interval2[0] > interval1[1])\n\
    \    a, b = [interval1, interval2].sort\n    (b[0] - a[1]).abs\nend", "    start\
    \ = [interval1[0], interval2[0]].max\n    finish = [interval1[1], interval2[1]].min\n\
    \    range = (start..finish).to_a\n    return \"NO\" if range.length == 0\n  \
    \  return \"YES\" if prime?(range.length)\n    \"NO\"\nend", "  #create a range\
    \ that is the intersection of the two ranges\n  range = (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\n  #find the length of the intersection\n\
    \  range_length = range.length\n  #check if the length is a prime number or not\n\
    \  if range_length <= 1\n    \"NO\"\n  else\n    (2..range_length - 1).each do\
    \ |n|\n      if range_length % n == 0\n        return \"NO\"\n      end\n    end\n\
    \    \"YES\"\n  end\nend", "  a = interval1[0]\n  b = interval1[1]\n  c = interval2[0]\n\
    \  d = interval2[1]\n  if (a>d || b<c)\n    return \"NO\"\n  end\n  if (a<=c &&\
    \ d<=b)\n    return is_prime?(d-c+1) ? \"YES\" : \"NO\"\n  end\n  if (c<=a &&\
    \ b<=d)\n    return is_prime?(b-a+1) ? \"YES\" : \"NO\"\n  end\n  return is_prime?(b-c+1)\
    \ ? \"YES\" : \"NO\"\nend", "  intersection = (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\n  intersection.size.prime? ? \"YES\" :\
    \ \"NO\"\nend", "  intersection = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  intersection = 0 if intersection.first > intersection.last\n\
    \  prime?(intersection.count) ? \"YES\" : \"NO\"\nend", "  intersection_interval\
    \ = [interval1[0], interval2[0]].max..[interval1[1], interval2[1]].min\n  intersection_interval.to_a.length\
    \ == 0 ? \"NO\" :\n  (2..intersection_interval.to_a.length-1).to_a.any? { |div|\
    \ intersection_interval.to_a.length % div == 0 } ? \"NO\" : \"YES\"\nend", " \
    \ (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\nend",
  "  max = [interval1[0], interval2[0]].max\n  min = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if max > min\n  is_prime?(min - max + 1) ? \"YES\" : \"NO\"\n\
    end", "  return 'NO' if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  return 'NO' if !intersection_length(interval1, interval2).prime?\n  'YES'\n\
    end", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  intersection = [interval1[0], interval2[0]].max..[interval1[1], interval2[1]].min\n\
    \  return \"YES\" if intersection.count > 1 && (2..intersection.count-1).all?\
    \ { |i| intersection.count % i != 0 }\n  \"NO\"\nend", "  return \"NO\" if interval1[1]\
    \ < interval2[0] || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  ends = [interval1[1], interval2[1]].min\n  return \"NO\" if start == ends\n\
    \  return \"YES\" if is_prime(ends - start)\n  \"NO\"\nend", "  first = interval1.first\
    \ > interval2.first ? interval1.first : interval2.first\n  last = interval1.last\
    \ < interval2.last ? interval1.last : interval2.last\n  length = last - first\
    \ + 1\n  return \"NO\" if length < 0\n  prime?(length) ? \"YES\" : \"NO\"\nend",
  "  arr = (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n\
    \  arr.length == 0 ? \"NO\" : is_prime(arr.length) ? \"YES\" : \"NO\"\nend", " \
    \   start = [interval1[0], interval2[0]].max\n    finish = [interval1[1], interval2[1]].min\n\
    \    intersection = (start..finish).to_a\n    if intersection.empty?\n       \
    \ \"NO\"\n    elsif intersection.length == 1\n        \"NO\"\n    elsif (2..intersection.length\
    \ - 1).all? { |d| intersection.length % d != 0 }\n        \"YES\"\n    else\n\
    \        \"NO\"\n    end\nend", "  a1, b1 = interval1[0], interval1[1]\n  a2,\
    \ b2 = interval2[0], interval2[1]\n  return false if (a1 > b2 || a2 > b1)\n  arr\
    \ = [a1, b1, a2, b2].sort\n  is_prime?(arr[2] - arr[1]) ? \"YES\" : \"NO\"\nend",
  "  start1, end1 = interval1\n  start2, end2 = interval2\n  intersection = (start1..end1).to_a\
    \ & (start2..end2).to_a\n  if intersection.empty?\n    \"NO\"\n  else\n    intersection.size.prime?\
    \ ? \"YES\" : \"NO\"\n  end\nend", "  #puts \"interval1 #{interval1} interval2\
    \ #{interval2}\"\n  (interval1[0]..interval1[1]).each { |num|\n    if interval2[0]\
    \ <= num && num <= interval2[1]\n      return is_prime?(num) ? \"YES\" : \"NO\"\
    \n    end\n  }\n  \"NO\"\nend", "  int1_start, int1_end = interval1\n  int2_start,\
    \ int2_end = interval2\n  if int1_start < int2_start\n    i1_start, i1_end = int1_start,\
    \ int1_end\n    i2_start, i2_end = int2_start, int2_end\n  else\n    i1_start,\
    \ i1_end = int2_start, int2_end\n    i2_start, i2_end = int1_start, int1_end\n\
    \  end\n  common_range = (i1_start..i1_end).to_a & (i2_start..i2_end).to_a\n \
    \ return \"NO\" if common_range.empty?\n  common_range.length.prime? ? \"YES\"\
    \ : \"NO\"\nend", "  start1,end1 = interval1\n  start2,end2 = interval2\n  return\
    \ \"NO\" if start1 > end2 || start2 > end1\n  intersect_len = [end1, end2].min\
    \ - [start1, start2].max + 1\n  intersect_len.prime? ? \"YES\" : \"NO\"\nend",
  "  intersect_range = (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n\
    \  intersect_range.length.prime? ? \"YES\" : \"NO\"\nend", "    intersection =\
    \ nil\n    if interval1[0] <= interval2[0]\n        if interval1[1] >= interval2[0]\n\
    \            intersection = [interval2[0], interval1[1]]\n        end\n    else\n\
    \        if interval2[1] >= interval1[0]\n            intersection = [interval1[0],\
    \ interval2[1]]\n        end\n    end\n    return \"NO\" if intersection.nil?\n\
    \    length = (intersection[1] - intersection[0]) + 1\n    return \"YES\" if length\
    \ == 2 || length == 3 || length == 5 || length == 7\n    return \"NO\"\nend",
  "  (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\nend",
  "  p [(interval1[0]..interval1[1]), (interval2[0]..interval2[1])]\n  if (interval1[0]..interval1[1]).include?(interval2[0])\
    \ || (interval1[0]..interval1[1]).include?(interval2[1]) || (interval2[0]..interval2[1]).include?(interval1[0])\
    \ || (interval2[0]..interval2[1]).include?(interval1[1])\n    p ((interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a).count\n    ((interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a).count.prime? ? \"YES\" : \"NO\"\n  else\n\
    \    \"NO\"\n  end\nend", "    p_start = [interval1[0], interval2[0]].max\n  \
    \  p_end = [interval1[1], interval2[1]].min\n    if p_start > p_end\n        return\
    \ \"NO\"\n    else\n        return (p_end - p_start).prime? ? \"YES\" : \"NO\"\
    \n    end\nend", "  interval1, interval2 = interval2, interval1 if interval1[0]\
    \ > interval2[0]\n  return \"NO\" if interval1[1] < interval2[0] || interval1[0]\
    \ > interval2[1]\n  return \"YES\" if (interval2[0] - interval1[1]).abs == 1\n\
    \  (interval2[0] - interval1[1]).abs.prime? ? \"YES\" : \"NO\"\nend", "    if\
    \ interval1[0] >= interval2[1] || interval2[0] >= interval1[1]\n        \"NO\"\
    \n    else\n        diff = [(interval1[0]...interval1[1]).to_a, (interval2[0]...interval2[1]).to_a].sort_by\
    \ { |r| r[0] }\n        p diff\n        diff[0].each_with_index do |interval,\
    \ i|\n            if diff[0][i] >= diff[1][0] && diff[0][i] <= diff[1][1]\n  \
    \              prime_check = (diff[0][i]-diff[1][0])+1\n                if prime_check\
    \ <= 0\n                    return \"NO\"\n                elsif prime_check ==\
    \ 1\n                    return \"YES\"\n                elsif prime_check % 2\
    \ == 0\n                    return \"NO\"\n                else\n            \
    \        return \"YES\"\n                end\n            end\n        end\n \
    \   end\nend", "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  return 'NO' if start > ending\n  ending - start <= 1 ?\
    \ 'NO' : 'YES'\nend", "  start = [interval1[0], interval2[0]].max\n  ending =\
    \ [interval1[1], interval2[1]].min\n  return \"NO\" if starting > ending\n  is_prime?(ending\
    \ - starting + 1) ? \"YES\" : \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  stop = [interval1[1], interval2[1]].min\n  return \"NO\" if start > stop\n\
    \  (start..stop).to_a.size.prime? ? \"YES\" : \"NO\"\nend", "    a = interval1[0]\n\
    \    b = interval1[1]\n    c = interval2[0]\n    d = interval2[1]\n    if a >\
    \ b\n        a, b = b, a\n    end\n    if c > d\n        c, d = d, c\n    end\n\
    \    if b < c || a > d\n        return \"NO\"\n    end\n    e = [a, c].max\n \
    \   f = [b, d].min\n    if e == f\n        if e > 1\n            return \"YES\"\
    \n        else\n            return \"NO\"\n        end\n    end\n    g = f - e\
    \ + 1\n    (2..Math.sqrt(g)).each do |h|\n        if g % h == 0\n            return\
    \ \"NO\"\n        end\n    end\n    return \"YES\"\nend", "  range1 = (interval1[0]..interval1[1])\n\
    \  range2 = (interval2[0]..interval2[1])\n  intersection = range1.intersection(range2)\n\
    \  intersection.length.prime? ? \"YES\" : \"NO\"\nend", "  first_interval_list\
    \ = interval1.to_a\n  second_interval_list = interval2.to_a\n  intersection_start\
    \ = first_interval_list[0] if second_interval_list[0] > first_interval_list[0]\n\
    \  intersection_start = second_interval_list[0] if second_interval_list[0] < first_interval_list[0]\n\
    \  intersection_end = first_interval_list[1] if second_interval_list[1] < first_interval_list[1]\n\
    \  intersection_end = second_interval_list[1] if second_interval_list[1] > first_interval_list[1]\n\
    \  intersection_start == intersection_end ? \"NO\" : (intersection_end - intersection_start).prime?\
    \ ? \"YES\" : \"NO\"\nend", "  intersection_interval = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if intersection_interval.begin >= intersection_interval.end\n\
    \  interval_len = (interval1[1] - interval1[0]) + 1\n  interval_len = (interval2[1]\
    \ - interval2[0]) + 1 if interval_len > (interval2[1] - interval2[0]) + 1\n  return\
    \ \"NO\" if interval_len < intersection_interval.end - intersection_interval.begin\
    \ + 1\n  return \"YES\" if primes(intersection_interval.end - intersection_interval.begin\
    \ + 1)\n  \"NO\"\nend", "    if interval1[0] <= interval2[0]\n        lower_interval\
    \ = interval1\n        higher_interval = interval2\n    else\n        lower_interval\
    \ = interval2\n        higher_interval = interval1\n    end\n    if lower_interval[1]\
    \ < higher_interval[0]\n        return \"NO\"\n    else\n        intersection_length\
    \ = [lower_interval[1], higher_interval[0]].min - higher_interval[0]\n       \
    \ if intersection_length < 2\n            return \"NO\"\n        else\n      \
    \      return is_prime(intersection_length) ? \"YES\" : \"NO\"\n        end\n\
    \    end\nend", "  interval = []\n  interval[0] = interval1[0] > interval2[0]\
    \ ? interval1[0] : interval2[0]\n  interval[1] = interval1[1] < interval2[1] ?\
    \ interval1[1] : interval2[1]\n  return \"NO\" if interval[0] > interval[1]\n\
    \  is_prime?(interval[1] - interval[0] + 1) ? \"YES\" : \"NO\"\nend", "    # combine\
    \ the two ranges\n    combined_range = (interval1[0]..interval1[1]).to_a + (interval2[0]..interval2[1]).to_a\n\
    \    # remove the duplicates\n    combined_range.uniq!\n    # check if the intersection\
    \ is not empty\n    if combined_range.length > 0\n        # return the length\
    \ of the intersection\n        intersec_length = combined_range.length\n     \
    \   # assign the answer variable\n        answer = \"NO\"\n        # check if\
    \ the length is a prime number\n        if is_prime(intersec_length)\n       \
    \     answer = \"YES\"\n        end\n        # return the answer\n        return\
    \ answer\n    else\n        return \"NO\"\n    end\nend", "  # Your code here\n\
    \  length = [interval1[0], interval2[0]].max - [interval1[1], interval2[1]].min\n\
    \  (1..length).select { |e| length % e == 0 }.size == 2 ? \"YES\" : \"NO\"\nend",
  "  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  fin = [interval1[1], interval2[1]].min\n\
    \  return \"YES\" if prime?(fin - start + 1)\n  \"NO\"\nend", "  s1, e1 = interval1[0],\
    \ interval1[1]\n  s2, e2 = interval2[0], interval2[1]\n  s, e = [s1, s2].max,\
    \ [e1, e2].min\n  #puts \"#{interval1} #{interval2} #{s} #{e}\"\n  s > e ? \"\
    NO\" : is_prime(e - s + 1) ? \"YES\" : \"NO\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  end_ = [interval1[1], interval2[1]].min\n  return \"NO\"\
    \ if start > end_\n  (start..end_).size.prime? ? \"YES\" : \"NO\"\nend", "  return\
    \ \"NO\" if (interval1[0] > interval2[1] || interval2[0] > interval1[1])\n  max_start\
    \ = [interval1[0], interval2[0]].max\n  min_end = [interval1[1], interval2[1]].min\n\
    \  is_prime(min_end - max_start + 1) ? \"YES\" : \"NO\"\nend", "  start_interval\
    \ = [interval1[0], interval2[0]].max\n  end_interval = [interval1[1], interval2[1]].min\n\
    \  if (end_interval < start_interval)\n    return \"NO\"\n  end\n  if prime?(end_interval\
    \ - start_interval + 1)\n    return \"YES\"\n  else\n    return \"NO\"\n  end\n\
    end", "    intersect_begin = [interval1[0], interval2[0]].max\n    intersect_end\
    \ = [interval1[1], interval2[1]].min\n    length = intersect_end - intersect_begin\
    \ + 1\n    length = 0 if length < 0\n    return \"NO\" if length == 0\n    return\
    \ \"YES\" if length.prime?\n    return \"NO\"\nend", "  start1, end1 = interval1\n\
    \  start2, end2 = interval2\n  if start1 > end2 || start2 > end1\n    \"NO\"\n\
    \  else\n    prime_numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
    \ 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    length = (start1..end1).to_a\
    \ & (start2..end2).to_a\n    prime_numbers.include?(length.length) ? \"YES\" :\
    \ \"NO\"\n  end\nend", "  range = (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n\
    \  range == [] ? \"NO\" : is_prime?(range.length) ? \"YES\" : \"NO\"\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if finish < start\n  return \"YES\" if prime?(finish - start\
    \ + 1)\n  \"NO\"\nend", "  # your code here\nend", "    start_first, end_first\
    \ = interval1\n    start_second, end_second = interval2\n    if start_first >\
    \ end_second || start_second > end_first\n        return \"NO\"\n    end\n   \
    \ intersection_length = [start_first, start_second].max..[end_first, end_second].min\n\
    \    return \"YES\" if is_prime?(intersection_length.to_a.length)\n    return\
    \ \"NO\"\nend", "    if interval1[0] < interval2[0]\n        return \"NO\" if\
    \ interval1[1] < interval2[0]\n        if interval1[1] < interval2[1]\n      \
    \      return is_prime?(interval1[1] - interval2[0] + 1) ? \"YES\" : \"NO\"\n\
    \        else\n            return is_prime?(interval2[1] - interval2[0] + 1) ?\
    \ \"YES\" : \"NO\"\n        end\n    else\n        return \"NO\" if interval2[1]\
    \ < interval1[0]\n        if interval2[1] < interval1[1]\n            return is_prime?(interval2[1]\
    \ - interval1[0] + 1) ? \"YES\" : \"NO\"\n        else\n            return is_prime?(interval1[1]\
    \ - interval1[0] + 1) ? \"YES\" : \"NO\"\n        end\n    end\nend", "\tlen =\
    \ 0\n\tinterval = []\n\tif interval1[0] <= interval2[0]\n\t\tif interval1[1] >=\
    \ interval2[0]\n\t\t\tif interval1[1] <= interval2[1]\n\t\t\t\tlen = interval1[1]\
    \ - interval2[0] + 1\n\t\t\t\tinterval[0] = interval2[0]\n\t\t\t\tinterval[1]\
    \ = interval1[1]\n\t\t\telse\n\t\t\t\tlen = interval2[1] - interval2[0] + 1\n\t\
    \t\t\tinterval[0] = interval2[0]\n\t\t\t\tinterval[1] = interval2[1]\n\t\t\tend\n\
    \t\tend\n\telse\n\t\tif interval2[1] >= interval1[0]\n\t\t\tif interval2[1] <=\
    \ interval1[1]\n\t\t\t\tlen = interval2[1] - interval1[0] + 1\n\t\t\t\tinterval[0]\
    \ = interval1[0]\n\t\t\t\tinterval[1] = interval2[1]\n\t\t\telse\n\t\t\t\tlen\
    \ = interval1[1] - interval1[0] + 1\n\t\t\t\tinterval[0] = interval1[0]\n\t\t\t\
    \tinterval[1] = interval1[1]\n\t\t\tend\n\t\tend\n\tend\n\tif len != 0\n\t\tif\
    \ prime?(len)\n\t\t\treturn \"YES\"\n\t\telse\n\t\t\treturn \"NO\"\n\t\tend\n\t\
    else\n\t\treturn \"NO\"\n\tend\nend", "  x1, y1 = interval1\n  x2, y2 = interval2\n\
    \  x = [x1,x2].max\n  y = [y1,y2].min\n  x > y ? \"NO\" : y - x + 1\nend", " \
    \ return \"NO\" if (interval1[0] > interval2[1] || interval2[0] > interval1[1])\n\
    \  return \"NO\" if (interval1[0] == interval2[1] || interval2[0] == interval1[1])\n\
    \  start = [interval1[0], interval2[0]].max\n  end_val = [interval1[1], interval2[1]].min\n\
    \  return \"YES\" if prime?(end_val - start + 1)\n  \"NO\"\nend", "  if interval1[0]\
    \ >= interval2[1] || interval2[0] >= interval1[1]\n    return \"NO\"\n  else\n\
    \    return \"YES\" if (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a.length.prime?\n\
    \    return \"NO\"\n  end\nend", "  intersect = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  return 'NO' if intersect.size == 0\n  return 'YES' if intersect.size.prime?\n\
    \  'NO'\nend", "  answer = false\n  if (interval1[0]...interval1[1]).include?(interval2[0])\
    \ && (interval1[0]...interval1[1]).include?(interval2[1])\n    answer = true\n\
    \  elsif (interval2[0]...interval2[1]).include?(interval1[0]) && (interval2[0]...interval2[1]).include?(interval1[1])\n\
    \    answer = true\n  else\n    answer = false\n  end\n  if answer == true\n \
    \   if interval1[0] > interval2[0]\n      interval1[0] = interval2[0]\n    end\n\
    \    if interval1[1] < interval2[1]\n      interval1[1] = interval2[1]\n    end\n\
    \    range = (interval1[0]...interval1[1])\n    if range.count.to_i.prime?\n \
    \     answer = \"YES\"\n    else\n      answer = \"NO\"\n    end\n  else\n   \
    \ answer = \"NO\"\n  end\n  answer\nend\nputs intersection((1, 2), (2, 3)) ==>\
    \ \"NO\"\nputs intersection((-1, 1), (0, 4)) ==> \"NO\"\nputs intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"", "  intervals = []\n  intervals << interval1\n  intervals\
    \ << interval2\n  if (intervals[0][0] >= intervals[1][0] && intervals[0][0] <=\
    \ intervals[1][1]) || (intervals[0][1] >= intervals[1][0] && intervals[0][1] <=\
    \ intervals[1][1])\n    is_prime?((intervals[0][0]..intervals[0][1]).to_a & (intervals[1][0]..intervals[1][1]).to_a)\
    \ ? \"YES\" : \"NO\"\n  else\n    \"NO\"\n  end\nend", "  x, y = interval1[0],\
    \ interval1[1]\n  u, v = interval2[0], interval2[1]\n  return \"NO\" if (x < u\
    \ && y < u) || (x > v && y > v)\n  x = u if x < u\n  y = v if y > v\n  return\
    \ \"YES\" if x == y && is_prime(x)\n  return \"NO\"\nend", "  if interval1[0]\
    \ <= interval2[0] && interval2[0] <= interval1[1]\n    p = [interval2[0], interval1[1]].min\
    \ - [interval2[0], interval1[1]].max + 1\n  elsif interval2[0] <= interval1[0]\
    \ && interval1[0] <= interval2[1]\n    p = [interval1[0], interval2[1]].min -\
    \ [interval1[0], interval2[1]].max + 1\n  else\n    return \"NO\"\n  end\n  if\
    \ p == 2 || p == 3 || p == 5 || p == 7\n    return \"YES\"\n  else\n    return\
    \ \"NO\"\n  end\nend", "  start = interval1[0]\n  end1 = interval1[1]\n  start1\
    \ = interval2[0]\n  end2 = interval2[1]\n  if start > end1\n    start = interval1[1]\n\
    \    end1 = interval1[0]\n  end\n  if start1 > end2\n    start1 = interval2[1]\n\
    \    end2 = interval2[0]\n  end\n  if start1 > end1 || start > end2\n    return\
    \ \"NO\"\n  end\n  if start > start1\n    start = start1\n  end\n  if end1 > end2\n\
    \    end1 = end2\n  end\n  length = end1 - start + 1\n  for i in 2..(length/2)\n\
    \    if length % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\
    \nend", "  a1, a2 = interval1\n  b1, b2 = interval2\n  if (a1 > b2) || (b1 > a2)\n\
    \    return \"NO\"\n  end\n  start = [a1, b1].max\n  finish = [a2, b2].min\n \
    \ while start <= finish\n    if start.prime?\n      return \"YES\"\n    end\n\
    \    start += 1\n  end\n  return \"NO\"\nend", "    if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n        return \"NO\"\n    else\n        start\
    \ = [interval1[0], interval2[0]].max\n        finish = [interval1[1], interval2[1]].min\n\
    \        length = finish - start + 1\n        if (length == 2) || (length == 3)\
    \ || (length == 5) || (length == 7)\n            return \"YES\"\n        else\n\
    \            return \"NO\"\n        end\n    end\nend", "  min = [interval1[0],\
    \ interval2[0]].max\n  max = [interval1[1], interval2[1]].min\n  return \"NO\"\
    \ if max < min || max - min == 0\n  primes = [2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n  (min..max).each\
    \ do |num|\n    return \"YES\" if primes.include?(num)\n  end\n  \"NO\"\nend",
  "  intersection = (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n\
    \  return \"NO\" if intersection.empty?\n  return \"YES\" if intersection.length\
    \ < 2\n  return is_prime(intersection.length)\nend", "  inter = (interval1[0]\
    \ - interval2[0]).abs\n  inter = (interval1[1] - interval2[1]).abs if inter >\
    \ (interval1[1] - interval2[1]).abs\n  return \"NO\" if inter < 1\n  prime = (2..inter/2).none?\
    \ { |i| inter % i == 0 }\n  prime ? \"YES\" : \"NO\"\nend", "  arr = (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\n  return \"NO\" if arr.empty?\n  return\
    \ \"YES\" if arr.length.prime?\n  \"NO\"\nend", "  x1, y1 = interval1\n  x2, y2\
    \ = interval2\n  x = [x1, x2].max\n  y = [y1, y2].min\n  return 'NO' if x > y\
    \ || y <= 0\n  %w(YES NO)[y.prime? ? 0 : 1]\nend", "  #your code here\nend", " \
    \ return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  fin = [interval1[1], interval2[1]].min\n\
    \  return \"YES\" if (start..fin).count.prime?\n  \"NO\"\nend", "  # your code\
    \ here\nend", "  a1, b1 = interval1\n  a2, b2 = interval2\n  if (a1 >= b2 || a2\
    \ >= b1)\n    'NO'\n  else\n    x = [a1, a2].max\n    y = [b1, b2].min\n    if\
    \ x == y\n      'YES'\n    else\n      (x..y).map { |x| (2..x-1).select { |i|\
    \ x % i == 0 }.size == 0 }.all? ? 'YES' : 'NO'\n    end\n  end\nend", "  # your\
    \ code here\nend", "  a, b = interval1\n  c, d = interval2\n  return \"NO\" if\
    \ b < c || d < a\n  if a < c\n    x, y = c, [b, d].min\n  else\n    x, y = a,\
    \ [b, d].min\n  end\n  x, y = y - x + 1, (x..y).to_a\n  return \"YES\" if y.size\
    \ < 3\n  #3rd:\n  # return \"YES\" if (x..y).to_a.size < 3\n  # return \"NO\"\
    \ if (x..y).to_a.size < 3\n  #2nd:\n  # y.each { |i| return \"NO\" if y.delete_if\
    \ { |j| i%j == 0 && i != j }.empty? }\n  # return \"YES\"\n  #1st:\n  # i = 0\n\
    \  # while i < y.size\n  #   j = i + 1\n  #   while j < y.size\n  #     return\
    \ \"NO\" if y[i]%y[j] == 0 && y[i] != y[j]\n  #     j += 1\n  #   end\n  #   i\
    \ += 1\n  # end\n  # return \"YES\"\nend", "  return \"NO\" if interval1[1] <\
    \ interval2[0] || interval2[1] < interval1[0]\n  is_prime = false\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  (start..finish).each\
    \ do |i|\n    is_prime = true if i.prime?\n  end\n  is_prime ? \"YES\" : \"NO\"\
    \nend", "    array = []\n    (interval1[0]..interval1[1]).each { |num|\n     \
    \   if (interval2[0]..interval2[1]).include?(num)\n            array << num\n\
    \        end\n    }\n    if array.length == 0\n        return \"NO\"\n    elsif\
    \ is_prime(array.length)\n        return \"YES\"\n    else\n        return \"\
    NO\"\n    end\nend", "    i1 = (interval1[0]..interval1[1]).to_a\n    i2 = (interval2[0]..interval2[1]).to_a\n\
    \    inter = i1 & i2\n    return \"NO\" if inter.length == 0\n    return \"YES\"\
    \ if inter.length == 1\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    return primes.include?(inter.length)\
    \ ? \"YES\" : \"NO\"\nend", "  arr = []\n  for i in interval1[0]..interval1[1]\n\
    \    for j in interval2[0]..interval2[1]\n      if i == j\n        arr << i\n\
    \      end\n    end\n  end\n  if arr.length == 0\n    return \"NO\"\n  end\n \
    \ if prime(arr.length)\n    return \"YES\"\n  else\n    return \"NO\"\n  end\n\
    end", "  a, b = interval1\n  c, d = interval2\n  e, f = [a, c].max, [b, d].min\n\
    \  (e..f).to_a.length == 1 ? \"NO\" : \"YES\"\nend", "    return \"NO\" if interval1[1]\
    \ < interval2[0] || interval2[1] < interval1[0]\n    return \"NO\" if interval1[0]\
    \ <= interval2[0] && interval2[1] <= interval1[1]\n    return \"NO\" if interval2[0]\
    \ <= interval1[0] && interval1[1] <= interval2[1]\n    s = [interval1[0], interval2[0]].max\n\
    \    e = [interval1[1], interval2[1]].min\n    len = e - s + 1\n    is_prime?(len)\
    \ ? \"YES\" : \"NO\"\nend", "  # code here\nend", "  # interval1 = interval1.map\
    \ { |x| x.to_i }\n  # interval2 = interval2.map { |x| x.to_i }\n  # interval3\
    \ = [interval1[0], interval2[0]].min, [interval1[1], interval2[1]].max\n  # interval4\
    \ = interval1[0] > interval2[0] ? interval1 : interval2\n  # interval5 = interval1[0]\
    \ < interval2[0] ? interval1 : interval2\n  # return 'NO' if interval4[0] >= interval5[1]\
    \ || interval3[0] >= interval3[1]\n  # return 'YES' if (interval3[1] - interval3[0]).prime?",
  "  start1, end1 = interval1\n  start2, end2 = interval2\n  start = [start1, start2].max\n\
    \  stop = [end1, end2].min\n  if start > stop\n    \"NO\"\n  else\n    prime =\
    \ true\n    for i in (2..(stop - start))\n      if (stop - start) % i == 0\n \
    \       prime = false\n        break\n      end\n    end\n    prime ? \"YES\"\
    \ : \"NO\"\n  end\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    \"NO\"\n  else\n    intersection_length = [interval1[0], interval2[0]].max\
    \ - [interval1[1], interval2[1]].min\n    return \"YES\" if [1, 2, 3, 5, 7].include?(intersection_length)\n\
    \    \"NO\"\n  end\nend", "    start = [interval1[0], interval2[0]].max\n    finish\
    \ = [interval1[1], interval2[1]].min\n    if start <= finish\n        range =\
    \ (start..finish).to_a\n        if range.length == 1\n            \"YES\"\n  \
    \      else\n            \"NO\"\n        end\n    else\n        \"NO\"\n    end\n\
    end", "  a = (interval1[0]..interval1[1]).to_a\n  b = (interval2[0]..interval2[1]).to_a\n\
    \  intersect = (a & b).length\n  return \"NO\" if intersect == 0\n  return \"\
    YES\" if intersect == 1\n  (2..Math.sqrt(intersect)).each do |num|\n    return\
    \ \"NO\" if intersect % num == 0\n  end\n  \"YES\"\nend", "  answer = \"NO\"\n\
    \  if interval1[0] < interval2[0]\n    if interval1[1] >= interval2[0]\n     \
    \ puts \"interval1: #{interval1}\"\n      puts \"interval2: #{interval2}\"\n \
    \     intersection = (interval2[0]..interval1[1]).to_a\n      answer =  \"YES\"\
    \ if is_prime?(intersection.size)\n    end\n  else\n    if interval2[1] >= interval1[0]\n\
    \      puts \"interval1: #{interval1}\"\n      puts \"interval2: #{interval2}\"\
    \n      intersection = (interval1[0]..interval2[1]).to_a\n      answer =  \"YES\"\
    \ if is_prime?(intersection.size)\n    end\n  end\n  answer\nend", "  a = [interval1,\
    \ interval2].sort\n  return 'NO' if a[0][1] < a[1][0]\n  b = [a[0][0], a[1][0]].max\n\
    \  c = [a[0][1], a[1][1]].min\n  if b > c\n    'NO'\n  else\n    d = (c - b) +\
    \ 1\n    is_prime(d) ? 'YES' : 'NO'\n  end\nend", "  first = interval1[0]\n  second\
    \ = interval1[1]\n  third = interval2[0]\n  fourth = interval2[1]\n  if first\
    \ > second\n    first, second = second, first\n  end\n  if third > fourth\n  \
    \  third, fourth = fourth, third\n  end\n  if first > fourth || third > second\n\
    \    \"NO\"\n  else\n    array = []\n    ((first >= third) ? first : third).upto(((second\
    \ <= fourth) ? second : fourth)) { |i| array << i }\n    array.uniq!\n    if array.length\
    \ == 1\n      if array[0] == 1\n        \"NO\"\n      else\n        \"YES\"\n\
    \      end\n    else\n      \"NO\"\n    end\n  end\nend", "  start1, end1 = interval1[0],\
    \ interval1[1]\n  start2, end2 = interval2[0], interval2[1]\n  [start1, end1,\
    \ start2, end2].sort!\n  if end1 < start2 || end2 < start1\n    return \"NO\"\n\
    \  else\n    interval = [start1, end1].max..[start2, end2].min\n    return prime?(interval.to_a.length)\
    \ ? \"YES\" : \"NO\"\n  end\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  length = ending - start + 1\n\
    \  return \"YES\" if length.prime?\n  \"NO\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return 'NO'\
    \ if start > finish\n  return 'YES' if prime?(finish - start + 1)\n  'NO'\nend",
  "  if interval1[0] <= interval2[0] && interval2[0] <= interval1[1]\n    return is_prime?(interval1[1]\
    \ - interval2[0]) ? \"YES\" : \"NO\"\n  elsif interval2[0] <= interval1[0] &&\
    \ interval1[0] <= interval2[1]\n    return is_prime?(interval2[1] - interval1[0])\
    \ ? \"YES\" : \"NO\"\n  else\n    return \"NO\"\n  end\nend", "  # write your\
    \ code here\n  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  return 'NO' if start > ending\n  return 'YES' if is_prime?(ending\
    \ - start + 1)\n  'NO'\nend", "    is_prime = true\n    (interval1[0]..interval1[1]).each\
    \ do |n|\n        if n >= interval2[0] && n <= interval2[1]\n            (2..n-1).each\
    \ do |i|\n                if n % i == 0\n                    is_prime = false\n\
    \                    break\n                end\n            end\n           \
    \ return \"YES\" if is_prime == true\n        end\n    end\n    return \"NO\"\n\
    end", "  if interval1[0] < interval2[0]\n    first_interval = interval1\n    second_interval\
    \ = interval2\n  else\n    first_interval = interval2\n    second_interval = interval1\n\
    \  end\n  if first_interval[1] < second_interval[0]\n    \"NO\"\n  else\n    if\
    \ first_interval[1] > second_interval[1]\n      prime?(second_interval[1] - second_interval[0]\
    \ + 1) ? \"YES\" : \"NO\"\n    else\n      prime?(first_interval[1] - second_interval[0]\
    \ + 1) ? \"YES\" : \"NO\"\n    end\n  end\nend", "    first_min, first_max = interval1.min,\
    \ interval1.max\n    second_min, second_max = interval2.min, interval2.max\n \
    \   intersect_min = [first_min, second_min].max\n    intersect_max = [first_max,\
    \ second_max].min\n    intersect_length = intersect_max - intersect_min\n    return\
    \ \"NO\" if intersect_length < 0\n    return \"YES\" if is_prime?(intersect_length)\n\
    \    \"NO\"\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
